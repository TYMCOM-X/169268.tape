*-TTY FORM
*-TYPE NEEDLE.F4 /SIZE 57
******************************************************************************
*                                                                            *
*               PROGRAM : NEEDLE DUMP FROM SUP'S SYSMSG                      *
*                                                                            *
*               SOURCE FILE   :   (PERSTATS:39)NEEDLE.F4                     *
*               CRETAED       :   JANUARY ,1986                              *
*               AUTHOR        :   RAIKI HUANG (446-7298)                     *
*               LAST UPDATED  :   JANUARY ,1986                              *
*                                                                            *
*                               VERSION 1.0                                  *
*                                                                            *
*       THE NEEDLE PROGRAM COLLECTS NEEDLE DATA FROM THE DUMP FILE OF        *
*	LU 7 OF SUPERVISOR. THE NEEDLE COLLECTION FROM SYSMSG WILL BE        *
*       ENVOKED ONLY WHILE THE SUP IS IN SLEEPING STATE.                     *
*                                                                            *
*       THIS PROGRAM WILL HANDSHAKE WITH SUP'S SLAVE MODE, SYSMSG , FROM     *
*       A DEC-10 HOST ON THE PUBLIC NETWORK.   THE HANDSHAKING TO SYSMSG     *
*       IS AVAILABLE BOTH FOR PUBLIC NETWORK AND PRIVATE NETWORK THROUGH     *
*       A GATEWAY.  THE DEC-10 SYSTEM WILL BUILD AN AUXILAIRY CIRCUIT TO     *
*       SYSMSG AND COMPLETE HANDSHAKING AND SENDING 01020304 SERIAL BYTE.    *
*       THE NEEDLE DATA COLLECTION WILL BE INVOKED BY SENDING CODE 07 TO     *
*       SYSMSG.  AFTER CODE 07 IS RETRIEVED FROM SYSMSG INDICATING THE       *
*       SUP IS IN SLEEPING STATE, OTHERWISE, CODE 08 IS EXPECTED FOR AWAKE   *
*       SUP, THE REMOTE HOST ISSUES OTHER SUBTYPE COMMAND.                   *
*                                                                            *
*       THE FOLLOWING SUBTYPE COMMANDS FOR NEEDLE INFORMATION ARE INVOKED    *
*       ONLY AFTER SYSMSG ECHOES CODE 07 TO THE REMOTE HOST.                 *
*       A.  SEND CODE 01 TO GET THE FILE  SIZE (IN SECTORS; 1 WORD)          *
*       B.  SEND CODE 02 TO GET THE BLOCK SIZE (IN SECTORS; 1 WORD)          *
*       C.  LOCATION OF THE CONTROL BLOCK = FILE SIZE - BLOCK SIZE           *
*       D.  SEND CODE 03 TO READ THE FIRST BLOCK FROM THE CONTROL BLOCK      *
*       E.  GET THE POINTER INFORMATION FROM THE CONTROL BLOCK FOR THE       *
*           LAST UPDATED SECTOR, OFFSET RELATIVE TO THE BEGINNING OF THE     *
*           FILE.                                                            *
*       F.  SEND CODE 03 AND NUMBER OF SECTORS TO BE COLLECTED BY THE        *
*           REMOTE HOST                                                      *
*       AFTER CODE 03 IS SEND, SYSMSG WILL SEND BACK THE NEEDLE INFO.        *
*       FOR THE REQUESTED NUMBER OF SECTORS.  THE DEC-10 PROGRAM WILL        *
*       STORE THIS DATA IN A FLAT FILE, IN THE FOLLOWING FORMAT:             *
*                                                                            *
*       LINK COUNT - NUMBER OF HOPS                                          *
*       INVOICE NUMBER                                                       *
*	NEEDLE FLAGS ( INDICATE COMMAND CIRCUIT OR REBUILT CIRCUIT )         *
*	ORIGINATION NODE                                                     *
*	LIST OF NODE #'S IN THE CIRCUIT                                      *
*	DESTINATION HOST                                                     *
*	USER FLAGS ( INDICATE TID )                                          *
*	ORIGINATION HOST                                                     *
*  	                                                                     *
*                                                                            *
******************************************************************************

        INTEGER NODES(101),HOSTS(101),NAME1(2),PORT,MTRPOS,PROMPT,ERRCKT,
     X          LOGPOS,OUTFIL,OFLNAM(2),ACTIVE,COMAND(13),LOGFIL(2)
        INTEGER APORTS(80),CHANNL(80),NLINKS(80),HTIME(2),OCHANL,RSPONS
        INTEGER IDATE(2),CIRC,APORT,T1,PCHANL,NAME2(2)
        INTEGER STAR,EXIT(5),QUIT(6),LOC1(101),LOC2(101),LOC3(101)
        INTEGER VERSN(101),MENGIN,KERN(101),LOC4(101),DIGIT(10),DTIME

	COMMON IPORT,IGX,IPX,IBUF(101),IWD,IALIGN,ICHS
        COMMON /AUX/ PORT
        COMMON /OUTPOS/ MTRPOS

*       ACCEPT NAME OF FILE FOR OUTPUT
        TYPE 12
12      FORMAT(1X,'ENTER NAME OF FILE FOR STORAGE OF OUTPUT: ',$)
        ACCEPT 13,NAME2
13      FORMAT(2A5)

*       INITIALISE NODE AND HOST ARRAYS

*       OPEN DATA OUTPUT AND MONITOR LOG FILE
22      CLOSE(10)
        OPEN(23,NAME2,OUTPUT,ERR=1110)
        OPEN(22,'NEEDEL.LOG',RANDOUT,ERR=1120)
        MTRPOS = SIZE(22) + 1
        IF (MTRPOS .EQ. 0) MTRPOS = MTRPOS + 1

*       ENTER GATEWAY
24      CALL GPWD(NETFLG)

*       BUILD CIRCUIT TO SYSMSG
	TYPE 250
250	FORMAT(' ENTER SUP NUMBER FOR TEST: ',$)
	ACCEPT 251,ISUP
251	FORMAT(I3)
        CALL XSMSG(CIRC,NETFLG,ISUP,ERR)
        IF (ERR .EQ. 0) GOTO 290
        WRITE(23,260,ERR=1190)ERR
        TYPE 260,ERR
260	FORMAT(/,' UNABLE TO ESTABLISH CIRCUIT TO SYSMSG.',' STATUS:',I4)
270	TYPE 275
275     FORMAT(/1X,'TRY AGAIN ? Y/N: ',$)
        ACCEPT 280,NY
280     FORMAT(A1)
        IF (NY .EQ. 'Y') GOTO 24
        IF (NY .NE. 'N') GOTO 270
        GOTO 1200

290	TYPE 295,ISUP
295	FORMAT(/,' DUMPING NEEDLE FILE FROM SUP :',I5,' ...')
	CALL NDUMP(IERR)
        IZAP = 0
322     CALL ZAP(PORT)
        GOTO 1200

*       ZAP CIRCUIT TO PROBE AND TMCS.
400     PORT = CIRC
        CALL SEND(EXIT)
        CALL SCAN(STAR,IRSLT)
        IF (IRSLT .NE. 1) GOTO 500
        CALL SEND(QUIT)
*       TYPE 450
450     FORMAT(/,1X,'CIRCUIT TO SYSMSG ZAPPED',/)
500     CALL ZAP(PORT)
        CLOSE(22)
        CLOSE(23)
        GOTO 1200

1150    TYPE 1155
1155    FORMAT(1X,'LOST SYSMSG CIRCUIT.UNABLE TO RE-BUILD CONNECTION.')
        CLOSE(22)
        CLOSE(23)
        GOTO 1200

1000    TYPE 1005
1005    FORMAT(1X,'UNABLE TO OPEN NODE-HOST FILE FOR READING',/)
1100    TYPE 1105
1105    FORMAT(1X,'UNABLE TO COMPLETE READ OPERATION',/)
        GOTO 1200

1110    TYPE 1115
1115    FORMAT(1X,'UNABLE TO OPEN OUTPUT FILE',/)
        GOTO 1200

1120    TYPE 1125
1125    FORMAT(1X,'UNABLE TO OPEN PROGRAM MONITOR FILE',/)
        CLOSE(23)
        GOTO 1200

1190    TYPE 1195
1195    FORMAT(1X,'UNABLE TO WRITE ON OUTPUT FILE',/)
        CLOSE(22)
        CLOSE(23)

1200    TYPE 1205
1205    FORMAT(/,' NEEDLE DUMP COMPLETED ! ')
        END


************************************************************************
*                                                                      *
*                        SUBROUTINE: XRGLIN                            *
*                                                                      *
*    GETS ONE LINE (MAX 78 CHARS) OF OUTPUT FROM AN AUX CKT TO XRAY.   *
*                                                                      *
*        FORMAT:     CALL XRGLIN (PROMPT, LARRAY, ERR)                 *
*        ARGUMENTS:                                                    *
*           PROMPT : VARIABLE WITH THE PROMPT CHARACTER FOR TESTING    *
*                    FOR END OF OUTPUT.                                *
*           LARRAY : ARRAY CONTAINING THE OUTPUT LINE FROM XRAY        *
*           ERR    : VARIABLE CONTAINING ERROR FLAG.                   *
*                    O = NO ERROR.                                     *
*                    1 = OVER-LONG LINE ( > 79 CHARACTERS).            *
*                    2 = END OF OUTPUT FROM XRAY.                      *
*                    3 = ERROR:  CKT ZAPPED OR 30 SEC. TIMEOUT.        *
*                                                                      *
*        ACCESSES:   COMMON/AUX/PORT                                   *
*                                                                      *
************************************************************************

        SUBROUTINE XRGLIN (PROMPT, LARRAY, ERR)

        INTEGER PROMPT, LARRAY (79), ERR, PORT, CHAR, WTCNT, CR, LF,WAIT

C GET THE AUX. CKT'S. PORT NUMBER FOR EXTRACTING DATA, AND INITIALIZE
C CONSTANTS FOR TESTING FOR END OF LINE, AND INITIALIZE ERROR CODE.

        COMMON /AUX/ PORT
        DATA CR /13/, LF /10/
        ERR = 0
        WTCNT = 0

C READ EACH CHAR. IN LINE OF XRAY OUTPUT, AND LOAD THEM INTO AN ARRAY
C FOR PASSING BACK TO THE CALLING SUBROUTINE (XRFOUT).
C*******************************************************

        DO 100 I = 1,80
   25   CALL GTCHAR (PORT, CHAR)

C TEST FOR ERROR RETURNS: -1 = NO CHAR; -2 = AUX. CKT. ZAPPED.

        IF (CHAR.EQ.-1) GOTO  50
        IF (CHAR.EQ.-2) GOTO 600

C MASK FOR ONLY THE LAST 7 BITS.

        CHAR=IAND(CHAR,"177)

C TEST FOR END OF LINE AND FOR END OF OUTPUT FROM HOST.  IGNORE
C CARRIAGE RETURN THEN END READING DATA AT LINE FEED, AND SEND LINE OF
C DATA (WITHOUT CR/LF PAIR) TO CALLING ROUTINE AND RETURN TO CALLER.
C DO NOT SEND THE PROMPT AT END OF OUTPUT, BUT SET END-OF-OUTPUT FLAG
C AND RETURN TO CALLER.

        IF (CHAR .EQ. CR) GOTO 25
        IF (CHAR .EQ. LF) RETURN
        IF (CHAR .EQ. PROMPT) GOTO 500

C MOVE THE CHAR TO THE LEFTMOST 8 BITS AND PAD THE WORD WITH BLANKS.
C LOAD THE CHARACTER INTO THE PROPER ARRAY ELEMENT.

        CHAR=LSH(CHAR,29)
        CHAR=IOR(CHAR,"1004020100)

        LARRAY(I)=CHAR
        GOTO 100

C TIMEOUT HAS OCCURRED.  IF 60 SEC. WITH NO CHAR., DO ERROR RETURN.

50      CALL WAIT(1.0)
        WTCNT = WTCNT + 1
        IF (WTCNT .GE. 30) GOTO 600
        GOTO 25

  100   CONTINUE

C END OF LOOP.
C*******************************************************

C MORE THAN 80 CHARS. IN LINE.

        ERR = 1
        RETURN

C END OF OUTPUT FROM XRAY:  PROMPT WAS RECEIVED.

  500   ERR = 2
        RETURN

C CKT. ZAPPED OR 30 SEC. TIMEOUT.

  600   ERR = 3
        RETURN

        END


************************************************************************
*                                                                      *
*               SUBROUTINE : XSMSG                                     *
*                                                                      *
*   ESTABLISHES AN AUXILIARY CIRCUIT TO SYSMSG AND RETURNS PORT #.     *
*                                                                      *
*       FORMAT : CALL XSMSG(CIRC,NETFLG,ISUP,ERR)                      *
*       ARGUMENTS:                                                     *
*               CIRC : INTEGER IN WHICH AUXILIARY CIRCUIT NUMBER IS    *
*                       RETURNED TO CALLING ROUTINE.                   *
*               ERR : ERROR CODE                                       *
*                       0 = NO ERROR                                   *
*                      -1 = COULD NOT BUILD AUXILIARY CIRCUIT          *
*                       1 = UNABLE TO ESTABLISH CIRCUIT TO SMSG        *
*                           EITHER USERNAME OR PASSWORD NOT VALID      *
*                       2 = HANDSHAKING WAS FAILED ON SYSMSG           *
*	                3 = SUP IS AWAKE, NEEDLE DUMP NOT ALLOWED      *   
*                       4 = UNEXPECTED CODE WAS SEND FROM SYSMSG       *
*                       5 = UNABLE TO ESTABLISH GATEWAY CIRCUIT        *
*                                                                      *
*       ACCESSES :  COMMON /AUX/ PORT (USED IN SCAN SUBROUTINE)        *
*                                                                      *
************************************************************************

        SUBROUTINE XSMSG(CIRC,NETFLG,ISUP,ERR)
        TYPE 999
999     FORMAT(1X,' ** XSMSG **')

        INTEGER CIRC,RESULT,PASSWD(5),HANSHK(5),COMAND(43),NCOM(43)
        INTEGER CR,LF,COLON,ERR,SAVE,PORT,IPWD(2),GWAY(9),NAME(4)
        INTEGER STAR,GNAME(4),GHOST,GPASS(3),SYSMSG(4),MSGPAS(3)
	INTEGER ONE,TWO,THREE,FOUR,SEVEN,EIGHT,HANSHK,PASSWD
	DATA COLON/58/,STAR/42/,CR/13/,LF/10/
	DATA ONE/01/,TWO/02/,THREE/03/,FOUR/04/,SEVEN/07/,EIGHT/08/
	DATA HANSHK/4,01,02,03,04/
	DATA PASSWD/4,85,71,79,13/
	COMMON /AUX/PORT
	COMMON /GATE/GNAME,GHOST
	COMMON /SMSG/SYSMSG,MSGPAS

*       INITIALISE HOST AND PASSWORD ARRAYS TO BLANKS
        IHOST = ISUP
        DO 300 I=1,2
300     IPWD(I) = '     '

	IF (NETFLG .EQ. 1) GOTO 305
	GOTO 60

*       CONSTRUCT COMMAND STRING AND BUILD CIRCUIT THROUGH GATEWAY
305	CALL CONSTR(GNAME,GHOST,IPWD,COMAND)
        DO 310 I=2,42
310     NCOM(I) = LSH(COMAND(I),29)

        ENCODE (41,320,GWAY)(NCOM(I),I=2,42)
320     FORMAT(41A1)

*       BUILD CIRCUIT TO THE GATEWAY HOST
10      IER = 0
        CALL FBCIR(GWAY,CIRC,IER)
        IF (IER .EQ. 0) GOTO 50
        IF (IER .NE. 4) GOTO 20
        TYPE 15
15      FORMAT(1X,'GATEWAY HOST OUT OF PORTS. TRYING AGAIN ....')
        CALL ZAP(CIRC)
        CALL WAIT(5.0)
        GOTO 10
20      ERR = -1
        IF (IER .EQ. 524288)TYPE 25
25      FORMAT(1X,'NO AUXILIARY CIRCUIT LICENSE.',/)
	TYPE 30
30	FORMAT(' COULD NOT BUILD AUXILIARY CIRCUIT TO GATEWAY ....')
        GOTO 1500

*       SWAP VALUES OF PORT AND CIRC. RESWAP AT END OF ROUTINE.
50        PORT = CIRC

*       SCAN FOR COLON , THE APPROPRIATE GATEWAY RESPONSE
        CALL SCAN(COLON,RESULT)
        IF(RESULT .EQ. 1) GOTO 60
	TYPE 55
55	FORMAT(' UNABLE TO ESTABLISH GATEWAY CIRCUIT ....')
        ERR = 5
        GOTO 1500

*       ISSUE SYSMSG USERNAME AND CHECK HAND SHAKING
60      CALL CONSTR(SYSMSG,IHOST,MSGPAS,COMAND)
        CALL SEND(COMAND)

	CALL SCAN(ONE,RESULT)
        IF (RESULT .EQ. 1) GOTO 102
        GOTO 108
102     CALL SCAN(TWO,RESULT)
        IF (RESULT .EQ. 1) GOTO 103
        GOTO 108
103     CALL SCAN(THREE,RESULT)
        IF (RESULT .EQ. 1) GOTO 104
        GOTO 108
104     CALL SCAN(FOUR,RESULT)
        IF (RESULT .EQ. 1) GOTO 110
108	TYPE 109
109	FORMAT(' SYSMSG USERNAME, HOST# OR PASSWORD NOT VALID ....')
	ERR = 1
        GOTO 1500

*       SENDS THE DATA STRING '01020304' BACK FOR HANDSHAKING
110	TYPE 115
115	FORMAT(' HANDSHAKING FROM SYSMSG : 01020304 !',/)
	DELAYC = 0
        TYPE 119
119     FORMAT(' REMOTE HOST SENDING BACK  01020304 !')
	CALL SEND(HANSHK)
120	CALL GTCHAR(PORT,CHAR)
	IF (CHAR .GE. 0) GOTO 125
*       SLEEP A LITTLE
        CALL WAIT(2.0)
        DELAYC = DELAYC + 1
        IF (DELAYC .GE. 10) GOTO 135
        GOTO 120
*       GOT A CHAR,
125	CHAR=IAND(CHAR,127)
	IF (CHAR .EQ. IHOST) GOTO 140
	TYPE 130,IHOST
130	FORMAT(' WRONG SUP :',I5)
135	TYPE 136
136	FORMAT(' HANDSHAKING WAS FAILED ON SYSMSG ....')
	ERR = 2
        GOTO 1500

140	TYPE 141,IHOST
141	FORMAT(' RIGHT SUP :',I5)
	CALL OUTCHR(PORT,SEVEN)
	DELAYC = 0
200	CALL GTCHAR(PORT,CHAR)
	IF (CHAR .GE. 0) GOTO 210
	CALL WAIT(2.0)
	DELAYC = DELAYC + 1
	IF (DELAYC .GE. 10) GOTO 530
	GOTO 200
210	type 211,char
211	format(' 07,08::',i5) 
	CHAR=IAND(CHAR,127)
	IF (CHAR .EQ. SEVEN) GOTO 500
	IF (CHAR .EQ. EIGHT) GOTO 510
	GOTO 530
500	ERR = 0 
	GOTO 1550
510	TYPE 520,IHOST
520	FORMAT(' SUP : ',I5,' IS AWAKE ! ') 
	ERR = 3
	GOTO 1500
530	TYPE 540
540	FORMAT(/,' UNEXPECTED CODE WAS SEND FROM SYSMSG !',/,
     X   ' NO INDICATION THAT SUP IS AWAKE OR SLEEPING !')
	ERR = 4
1500	CALL ZAP(CIRC)
1550	RETURN
        END
************************************************************************
*                                                                      *
*	SUBROUTINE  :  NDUMP(IERR)                                     *
*								       *	
************************************************************************
  
	SUBROUTINE NDUMP(IERR)
	TYPE 999
999	FORMAT(1X,' ** NDUMP **')

	INTEGER ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,CHAR,RESULT
	INTEGER PORT,PTRLOC,PASBYT,SUBTY3,SUBTY4,SUBTY5,SUBTY6,SUBTY7
	INTEGER PTROFF,PATHSC,GMTFLG,SWITCH,PASBYT,ROUTES(12),BYTES
	INTEGER START,ONODE,OHOST,THOST,EOFNED
	DATA NULL/00/,ONE/01/,TWO/02/,THREE/03/,FOUR/04/,FIVE/05/
	DATA SIX/06/,SEVEN/07/,EIGHT/08/,CR/13/
	COMMON BYTES,PATHSC,GMTFLG,SWITCH,PASBYT,START,ONODE,OHOST,THOST
	COMMON /AUX/ PORT
 
	NVALUE = 0
*	TELL ME THE FILE SIZE

	CALL OUTCHR(PORT,ONE)
	CALL SCAN(ONE,RESULT)
	IF (RESULT .EQ. 1) GOTO 110
100	TYPE 105
105	FORMAT(' CANNOT GET THE FILE SIZE !')
	GOTO 1500
110	CALL GTWORD(NVALUE,JERR)
	IF (JERR .NE. 0) GOTO 1500
	IFSIZE = NVALUE
	TYPE 2222,IFSIZE
2222	FORMAT(' FSIZE::',I5)

*	TELL ME THE BLOCK SIZE
	CALL OUTCHR(PORT,TWO)
	CALL SCAN(TWO,RESULT)
	IF (RESULT .EQ. 1) GOTO 310
300	TYPE 305
305	FORMAT(' CANNOT GET THE BLOCK SIZE !')
	GOTO 1500
310	PASBYT = 2
	CALL PBYTES(PASBYT,JERR)
	IF (JERR .NE. 0) GOTO 1500
	IBSIZE = 0
	DO 400 J = 1,2
	DELAYC = 0
320	CALL GTCHAR(PORT,CHAR)
	TYPE 3333,CHAR
3333	FORMAT(' CHAR ::',I5)
	IF (CHAR .GE. 0) GOTO 325
*	SLEEP A LITTLE
	CALL WAIT(2.0)
	DELAYC = DELAYC + 1
	IF (DELAYC .GE. 10) GOTO 300
	GOTO 320
325	CHAR = IAND(CHAR,"177)
 	
	IF (J .EQ. 1) GOTO 330
	IBSIZE = IBSIZE + CHAR
	GOTO 400
330	IBSIZE = IBSIZE + 256*CHAR

400	CONTINUE
	TYPE 4444,IBSIZE
4444	FORMAT(' BFIZE::',I5)

*	TELL ME THE LOCATION OF THE CONTROL BLOCK IN SECTORS
*	THE LAST BLOCK = ( FILE SIZE - BLOCK SIZE )
	
	PTRLOC = IFSIZE - IBSIZE
	NVALUE = PTRLOC
	CALL GWDVAL(NVALUE,NBYTE1,NBYTE2,NBYTE3,NBYTE4)
	CALL SUBTY3(NBYTE1,NBYTE2,NBYTE3,NBYTE4)

	CALL SCAN(THREE,RESULT)
	IF (RESULT .EQ. 1) GOTO 600
	TYPE 560
560	FORMAT(' CANNOT GET THE CONTROL BLOCK !')
	GOTO 1500
*600	PASBYT = 4
*	CALL PBYTES(PASBYT,JERR)
*	IF (JERR .NE. 0) GOTO 1500
600	CALL GTWORD(NVALUE,JERR)
	NBYTS = NVALUE
	TYPE 6660,NBYTS
6660	FORMAT(' NBYTS::',I5)

*	GET THE FIRST  4 BYTES ( ONE WORD ) WITH POINTER DATA
*	GET THE SECOND 4 BYTES ( ONE WORD ) WITH   GMT   DATA	

*	GET POINTER OFFSET VALUE IN SECTORS
	CALL GTWORD(NVALUE,JERR)
	IF (JERR .NE. 0) GOTO 1500
	PTROFF = NVALUE
	TYPE 6666,PTROFF
6666	FORMAT(' PTROFF:',I)ET GMT DATA
	CALL GTWORD(NVALUE,JERR)
	IF (JERR .NE. 0) GOTO 1500
	INGMT = NVALUE
	TYPE 6667,INGMT
6667	FORMAT(' INGMT::',I)
	PASBYT = 248
	CALL PBYTES(PASBYT,JERR)
	IF (JERR .NE. 0) GOTO 1500
	CALL SCAN(FOUR,RESULT)
	IF (RESULT .EQ. 1) GOTO 620
	TYPE 610
610	FORMAT(' END-OF-DATA CODE 04 MISSING FROM SYSMSG !')
	GOTO 1500

*	END OF NEEDLE FILE IN SECTORS = (POINTER OFFSET) - 1 SECTOR  
620	NOFNED = PTR0FF - 1

	INVOCE = 1
	GMTFLG = 1
	LNKFLG = 1
	START = 1
	SWITCH = 1
	DO 700 NSECTR = 0,EOFNED
	CALL GWDVAL(NSECTR,NBYTE1,NBYTE2,NBYTE3,NBYTE4)
	CALL SUBTY3(NBYTE1,NBYTE2,NBYTE3,NBYTE4)	
	CALL SCAN(THREE,RESULT)
	IF (RESULT .EQ. 1) GOTO 690
	TYPE 680
680	FORMAT(' ERROR OCCURS AFTER SUBTYPE 03 WAS SEND !')
	GOTO 1500

*	CHECK THE CODE SEND BACK FROM SYSMSG AFTER THE REMOTE HOST
*	SENDING SUBTYPE 03 TO THE SYSMSG .... 
C	CALL CHKSUB
690	CALL GTSECT(KERR)
	IF (KERR .NE. 0) GOTO 1000
700	CONTINUE
	GOTO 1550
1000	TYPE 1001,KERR
1001	FORMAT(' INTERRUPTION ON DUMPING NEEDLE !',/)


1500	CALL ZAP(PORT)
1550	RETURN
	END



************************************************************************
*                                                                      *
*       SUBROUTINE  :  CONSTR                                          *
*                                                                      *
*       THIS IS A UTILITY SUBROUTINE THAT BUILDS A ARRAY USED BY       *
*       THE 'SEND' ROUTINE TO SEND CHARACTERS DOWN AN AUXILIARY        *
*       CIRCUIT.                                                       *
*                                                                      *
*       FORMAT  :  CALL CONSTR (NAME,IHOST,PWD,COMAND)                 *
*                                                                      *
*       ARGUMENTS :                                                    *
*       NAME  :  20 CHARACTER ARRAY CONTAINING THE NAME OF USER        *
*                (FOR LOG-IN) OR COMMAND STRING TO SEND DOWN THE       *
*                THE AUXILIARY CIRCUIT                                 *
*       IHOST :  4 CHARACTER ARRAY CONTAINING HOST # THE USER          *
*                WISHES TO LOG INTO                                    *
*       PWD   :  USER PASSWORD                                         *
*       COMAND : 43 WORD ARRAY IN WHICH THE BUILT COMMAND STRING       *
*                OR LOG-IN STREAM IS RETURNED                          *
*                                                                      *
************************************************************************


        SUBROUTINE CONSTR(NAME,IHOST,PWD,COMAND)

        INTEGER COMAND(43),NAME(4),PWD(3),COMM(9),CHAR,CR
        DATA CR /13/,COMM /9*5H     /

        DO 5 I=1,43
5       COMAND(I) = 0
        DO 7 I=1,9
7       COMM(I) = '     '

        IF (IHOST .NE. '    ') GOTO 25
        IF (PWD(1) .NE. '     ') GOTO 20

        ENCODE(20,10,COMM)NAME
10      FORMAT(4A5)
        GOTO 50

20      ENCODE (36,22,COMM)NAME,PWD
22      FORMAT(4A5,';',3A5)
        GOTO 50

25      ENCODE (41,30,COMM)NAME,IHOST,PWD
30      FORMAT(4A5,':',I3,';',3A5)

50      J=1
*       TYPE 55,COMM
55      FORMAT(1X,9A5)

*       LOOK A CHARACTER AHEAD AND REMOVE STRINGS OF EMBEDDED BLANKS
*       WHICH ARE MORE THAN 1 BLANK IN LENGTH.

        DO 75 I=2,42
                CALL RTC(CHAR,COMM,I-1)
                IF (I .NE. 42) CALL RTC(NCHAR,COMM,I)
                IF (I .EQ. 42) NCHAR = ' '
                IF (CHAR .EQ. ' ' .AND. NCHAR .EQ. ' ') GOTO 75
                IF (CHAR .EQ. ' ' .AND. NCHAR .EQ. ':') GOTO 75
                IF (CHAR .EQ. ' ' .AND. NCHAR .EQ. ';') GOTO 75

                J = J+1
*
*       RIGHT JUSTIFY CHARACTER
*
                CHAR = LSH(CHAR,-29)
                COMAND(J) = CHAR
75      CONTINUE

*       INCLUDE LENGTH OF COMMAND STRING IN FIRST WORD AND A 'CR' IN THE LAST

        COMAND(1) = J
        J = J+1
        COMAND(J) = CR

        RETURN
        END

***********************************************************************
*                                                                     *
*                          SUBROUTINE  :  GPWD                        *
*                                                                     *
*          THIS SUBROUTINE OBTAINS THE FOLLOWING USERNAMES AND        *
*          PASSWORDS AND PLACES THEM IN A COMMON AREA FOR ACCESS      *
*          BY THE 'XSMSG'.                                            *
*                                                                     *
*          1. GATEWAY USERNAME                                        *
*          2. GATEWAY HOST NUMBER (OPTIONAL)                          *
*          3. GATEWAY PASSWORD (OPTIONAL)                             *
*          4. PRIVATE NETWORK SYSMSG USERNAME                         *
*          5. PRIVATE NETWORK SYSMSG PASSWORD                         *
*                                                                     *
***********************************************************************

        SUBROUTINE GPWD(NETFLG)

        INTEGER GNAME(4),GHOST,GPASS(3),SYSMSG(4),MSGPAS(3)

*	COMMON /GATE/GNAME,GHOST,GPASS
	COMMON /GATE/GNAME,GHOST
        COMMON /SMSG/SYSMSG,MSGPAS

1	TYPE 3
3	FORMAT(' 1. PUBLIC NETWORK 2. PRIVATE NETWORK: ',$)
	ACCEPT 6,NY
6	FORMAT(A1)
	IF (NY .EQ. '2') GOTO 9
	IF (NY .EQ. '1') GOTO 8
	GOTO 1
8	NETFLG = 0
	GOTO 39
 
9	NETFLG = 1
        TYPE 10
10      FORMAT(' GATEWAY USERNAME: ',$)
        ACCEPT 15,GNAME
15      FORMAT(4A5)

        TYPE 20
20      FORMAT(' GATEWAY HOST: ',$)
        ACCEPT 25, GHOST
25      FORMAT(A4)

* 	CALL ECHO(0)
*	TYPE 30
*30	FORMAT(' GATEWAY PASSWORD: ',$)
*	ACCEPT 35, GPASS
*35	FORMAT(4A5)

39	TYPE 40
40      FORMAT(' SYSMSG USERNAME: ',$)
        ACCEPT 45,SYSMSG
45      FORMAT(4A5)

        CALL ECHO(0)
        TYPE 50
50      FORMAT(' SYSMSG PASSWORD: ',$)
        ACCEPT 55,MSGPAS
55      FORMAT(3A5)
	CALL ECHO(1)

        TYPE 80
80      FORMAT(/,' BUILDING CIRCUIT ....',/)

        RETURN
        END
	
	SUBROUTINE GTWORD(NVALUE,JERR)
C	------------------------------
C	GET ONE WORK AND CONVERT TO DECIMAL VALUE

	INTEGER PORT,DELAYC
	COMMON /AUX/ PORT
	JERR = 0
	NVALUE = 0
	TYPE 999
999	FORMAT(' ** GTWORD **')

	DO 500 I = 1,4
	DELAYC = 0
100	CALL GTCHAR(PORT,NCHAR)
	type 2222,nchar
2222	format(' char ::',I5)
	IF (NCHAR .GE. 0) GOTO 200
	IF (NCHAR .EQ. -2) GOTO 700
*	SLEEP A LITTLE
	CALL WAIT(2.0)
	DELAYC = DELAYC + 1
	IF (DELAYC .GE. 10) GOTO 600
	GOTO 100
200	NCHAR = IAND(NCHAR,"177777)
	GOTO (210,220,230,240), I
	GOTO 500
210	NVALUE = NVALUE + (NCHAR*256)*256*256
	GOTO 490
220	NVALUE = NVALUE + (NCHAR*256)*256
	GOTO 490
230	NVALUE = NVALUE + NCHAR*256
	GOTO 490
240	NVALUE = NVALUE + NCHAR

490	type 499,nvalue
499	format(' nvalue:',i)
500	CONTINUE
	GOTO 900

C	CANNOT GET 4 BYTES
600	JERR = 1
	GOTO 900

C	CKT. ZAPPED OR 30 SEC. TIMEOUT.
700	JERR = 2

900	RETURN
	END

	SUBROUTINE GTHWRD(NVALUE,JERR)
C	------------------------------
C	GET HALF WORD AND CONVERT TO DECIMAL VALUE

	INTEGER PORT,DELAYC
	COMMON /AUX/ PORT

	JERR = 0
	NVALUE = 0
	TYPE 999
999	FORMAT(' ** GTHWRD **')
	DO 500 I = 1,2
	DELAYC = 0
100	CALL GTCHAR(PORT,NCHAR)
	type 2222,nchar
2222	format(' char  ::',i5)
	IF (NCHAR .GE. 0) GOTO 200
	IF (NCHAR .EQ. -2) GOTO 700
*	SLEEP A LITTLE
	CALL WAIT(2.0)
	DELAYC = DELAYC + 1
	IF (DELAYC .GE. 10) GOTO 600
	GOTO 100
200	NCHAR = IAND(NCHAR,"177777)
	IF (I .EQ. 2) GOTO 210
	NVALUE = NVALUE + NCHAR*256
	GOTO 500
210	NVALUE = NVALUE + NCHAR
500	CONTINUE
	GOTO 900
C	CANNOT GET 2 BYTES ( HALF WORD )
600	JERR = 1
	GOTO 900
C	CKT. ZAPPED OR 30 SEC. TIMEOUT.
700	JERR = 2
900	RETURN
	END




	SUBROUTINE GTBYTE(NVALUE,JERR)
C	------------------------------
C	GET ONE BYTE AND ITS DECIMAL VALUE

	INTEGER PORT,DELAYC
	COMMON /AUX/ PORT
	JERR = 0
	NVALUE = 0
	DELAYC = 0
	TYPE 999
999	FORMAT(' ** GTBYTE **')
100	CALL GTCHAR(PORT,NCHAR)
	type 2222,nchar
2222	format(' char ::',i5)
	IF (NCHAR .GE. 0) GOTO 200
	IF (NCHAR .EQ. -2) GOTO 700
	CALL WAIT(2.0)
	DELAYC = DELAYC + 1
	IF (DELAYC .GE. 10) GOTO 600
	GOTO 100
200	NCHAR = IAND(NCHAR,"177777)
	NVALUE = NCHAR
	GOTO 900
600	JERR = 1
	GOTO 900
700	JERR = 2
900	RETURN
	END

	SUBROUTINE PBYTES(NUMBYT,JERR)
C	------------------------------
C	IGNORE NUMBER OF CHARS FROM PORT INPUT

	INTEGER PORT
	COMMON /AUX/ PORT
	JERR = 0
	ICNT = 0

	TYPE 999
999	FORMAT(' ** PBYTES **')
 
	DO 500 I = 1,NUMBYT
100	CALL GTCHAR(PORT,NCHAR)
*	type 2222,nchar
2222 	format(' gbyte:',i)
	IF (NCHAR .GE. 0) GOTO 400
C	TEST FOR ERROR RETURN: -1 = NO CHAR; -2 = AUX. CKT. ZAPPED.
 
	IF (NCHAR .EQ. -1) GOTO 200
	IF (NCHAR .EQ. -2) GOTO 700
	GOTO 600
 
200	CALL WAIT(1.0)
	ICNT = ICNT + 1
	IF (ICNT .GE. 30) GOTO 600
	GOTO 100

400	ICNT = 0
500	CONTINUE
	GOTO 900
 
C	CKT. ZAPPED OR 30 SEC. TIMEOUT.

600	JERR = 1
	GOTO 900

700	JERR = 2

900	RETURN
	END



	SUBROUTINE GWDVAL(NVALUE,NBYTE1,NBYTE2,NBYTE3,NBYTE4)
C	-----------------------------------------------
C	GET EACH BYTE'S DECIMAL TRANSLATION IN ONE WORD

	INTEGER PORT
	COMMON /AUX/ PORT
	NBYTE1 = 0
	NBYTE2 = 0
	NBYTE3 = 0
	NBYTE4 = 0
	TYPE 999
999	FORMAT(' ** GWDVAL **')

	IF (NVALUE .GE. 256) GOTO 100
	NBYTE4 = NVALUE
	GOTO 900
100	NBYTE4 = MOD(NVALUE,256)
	NRMAIN = NVALUE/256
	IF (NRMAIN .GE. 256) GOTO 200
	NBYTE3 = NRMAIN
	GOTO 900

200	NBYTE3 = MOD(NRMAIN,256)
	NRMAIN = NRMAIN/256
	IF (NRMAIN .GE. 256) GOTO 300
	NBYTE2 = NRMAIN
	GOTO 900
300	NBYTE2 = MOD(NRMAIN,256)
	NBYTE1 = NRMAIN/256

900	RETURN
	END

	SUBROUTINE GHWVAL(NVALUE,NBYTE1,NBYTE2)
C	---------------------------------------
C	GET EACH BYTE'S DECIMAL TRANSLATION IN HALF WORD

	INTEGER PORT
	COMMON /AUX/ PORT

	TYPE 999
999	FORMAT(' ** GHWVAL **')

	NBYTE1 = 0
	NBYTE2 = 0
	IF (NVALUE .GE. 256) GOTO 100
	NBYTE2 = NVALUE
	GOTO 900
100	NBYTE2 = MOD(NVALUE,256)
	NBYTE1 = NVALUE/256

900	RETURN
	END	




	SUBROUTINE SUBTY3(NBYTE1,NBYTE2,NBYTE3,NBYTE4)
C	----------------------------------------------
C	SEND SUBTYPE 03 DATA STRING TO SYSMSG

	INTEGER ONE,THREE,RESULT,PORT
	DATA NULL/00/,ONE/01/,THREE/03/
	COMMON /AUX/ PORT

	TYPE 999
999	FORMAT(' ** SUBTY3 **')
	CALL OUTCHR(PORT,THREE)
	CALL OUTCHR(PORT,NBYTE1)
	CALL OUTCHR(PORT,NBYTE2)
	CALL OUTCHR(PORT,NBYTE3)
	CALL OUTCHR(PORT,NBYTE4)
	CALL OUTCHR(PORT,NULL)
	CALL OUTCHR(PORT,NULL)
	CALL OUTCHR(PORT,NULL)
	CALL OUTCHR(PORT,ONE)

	RETURN
	END

	SUBROUTINE GTFFFF(BYTES,JERR)
C	-----------------------------
C	GET TO END MARK (FFFF) OF EACH NEEDLE

	INTEGER TARGET,RESULT,PORT,DELAYC,BYTES
	COMMON /AUX/ PORT 

	TYPE 999
999	FORMAT(' ** GTFFFF **')

	JERR = 0
	NFFFF = 0
	DELAYC = 0
100	CALL GTCHAR(PORT,NCHAR)
	IF (NCHAR .GE. 0 ) GOTO 400
	IF (NCHAR .EQ. -1) GOTO 200
	IF (NCHAR .EQ. -2) GOTO 700

200	CALL WAIT(1.0)
	DELAYC = DELAYC + 1
	IF (DELAYC .GE. 30) GOTO 600
	GOTO 100

400	DELAYC = 0
	NCHAR = IAND(NCHAR,"177777)
	IF (NCHAR .EQ. 255) GOTO 420
	NFFFF = 0
	GOTO 100
420	type 2222,nchar
2222	format(' gtffff:',i)
	NFFFF = NFFFF + 1
	IF (NFFFF .EQ. 2) GOTO 900
	GOTO 100 

600	JERR = 1
	GOTO 900
700	JERR = 2
	GOTO 900
800	JERR = 256

900	RETURN
	END

	SUBROUTINE GTSECT(KERR)
C	-----------------------
C	GET ONE SECTOR (256 BYTES) EACH TIMES AND SPLIT EVERY NEEDLE

	INTEGER BYTES,PATHSC,GMTFLG,SWITCH,PASBYT,START,ONODE,OHOST,
     X          ROUTES(12),THOST,PORT,DELAYC
	COMMON  BYTES,PATHSC,GMTFLG,SWITCH,PASBYT,START,ONODE,OHOST,THOST
	COMMON /AUX/ PORT

	TYPE 999
999	FORMAT(' ** GTSECT **')
*	SKIP 1 WORD LONG BYTE COUNT 
	PASBYT = 4
	CALL PBYTES(PASBYT,JERR)
	IF (JERR .EQ. 0) GOTO 50
	GOTO 800
50	BYTES = 0
100	IF (BYTES .GE. 256) GOTO 900
	GOTO (110,120,130,140,150,160,170,180,190,200,310,320,330) SWITCH
*	SEARCH FOR NEEDLE END MARK
110	NFFFF = 0
	DELAYC = 0
111	CALL GTCHAR(PORT,NCHAR)
	IF (NCHAR .GE. 0 ) GOTO 114
	IF (NCHAR .EQ. -1) GOTO 112
	IF (NCHAR .EQ. -2) GOTO 117
112	CALL WAIT(1.0)
	DELAYC = DELAYC + 1
	IF (DELAYC .GE. 60) GOTO 116
114	DELAYC = 0
	BYTES = BYTES + 1
	IF (BYTES .GE. 256) GOTO 900
	NCHAR = IAND(NCHAR,"177777)
	IF (NCHAR .EQ. 255) GOTO 115
	NFFFF = 0
	GOTO 111
115	TYPE 1115,NCHAR
1115	format(' GTFFFF:',i)
	NFFFF = NFFFF + 1
	IF (NFFFF .EQ. 2) GOTO 119
	GOTO 111
116	JERR = 1	
	GOTO 800
117	JERR = 2
	GOTO 800

119	SWITCH = 2
	GOTO 100
*	GET THE PATH SELECTION TIME
120	CALL GTHWRD(NVALUE,JERR)
	IF (JERR .EQ. 0) GOTO 125
	GOTO 800
125	PATHSC = NVALUE
	BYTES = BYTES + 2
	SWITCH = 3
	GOTO 100
*	GET 1 WORD LONG GMT
130	IF (GMTFLG .EQ. 2) GOTO 134
	GMTFLG = 1
	CALL GTHWRD(NGMT1,JERR)
	IF (JERR .EQ. 0) GOTO 132
	GOTO 800

132	BYTES = BYTES + 2
	GMTFLG = 2
	GOTO 100
134	CALL GTHWRD(NGMT2,JERR)
	IF (JERR .EQ. 0) GOTO 135
	GOTO 800
*	CONVERT FASTC GMT INTO MM/DD/YY HR:MN:SC
135	GMTFLG = 1
	NIDGMT = (NGMT2*256*256) + NGMT1
C	CALL SLOWC(NVALUE,A5)
	BYTES = BYTES + 2
	SWITCH = 4
	GOTO 100

*	SKIP 2 BYTES
140	PASBYT = 2
	CALL PBYTES(PASBYT,JERR)
	IF (JERR .EQ. 0) GOTO 145
	GOTO 800
145	BYTES = BYTES + 2
	SWITCH = 5
	GOTO 100

*	SKIP 1 BYTE AND GET 1 BYTE LONG NEEDLE LINK COUNT
150	PASBYT = 1
	CALL PBYTES(PASBYT,JERR)
	IF (JERR .EQ. 0) GOTO 152
	GOTO 800
152	CALL GTBYTE(NVALUE,JERR)
	IF (JERR .EQ. 0) GOTO 155
	GOTO 800
155	LINKS = NVALUE - 128
	BYTES = BYTES + 2
	SWITCH = 6
	GOTO 100

*	SKIP ONE WORD LONG INVOICE NUMBER
160	IF (INVOCE .EQ. 2) GOTO 164
	PASBYT = 2
	CALL PBYTES(PASBYT,JERR)
	IF (JERR .EQ. 0) GOTO 162
	GOTO 800
162	BYTES = BYES + 2
	INVOCE = 2
	GOTO 100
164	PASBYT = 2
	CALL PBYTES(PASBYT,JERR)
	IF (JERR .EQ. 0) GOTO 165
	GOTO 800
165	INVOCE = 1
	BYTES = BYTES + 2
	SWITCH = 7
	GOTO 100

*	GET NEEDLE CIRCUIT TYPE
170	CALL GTHWRD(NVALUE,JERR)
	IF (JERR .EQ. 0) GOTO 175
	GOTO 800
175	CIRTYP = NVALUE - 32896
C	CALL GTCIRC(CIRTYP,NIDTYP)
	BYTES = BYTES + 2
	SWITCH = 8
	GOTO 100

*	GET THE ORIGINATING NODE
180	CALL GTHWRD(NVALUE,JERR)
	IF (JERR .EQ. 0) GOTO 185
	GOTO 800
185	ONODE = NVALUE
	BYTES = BYTES + 2
	SWITCH = 9
	GOTO 100

*	SKIP HALF-WORD LONG REQUESTING PORT #
190	PASBYT = 2
	CALL PBYTES(PASBYT,JERR)
	IF (JERR .EQ. 0) GOTO 195
	GOTO 800
195	BYTES = BYTES + 2
	SWITCH = 10
	GOTO 100

*	GET THE LIST OF NODE IN THE CIRCUIT
200	IF (LNKFLG .GE. 2) GOTO 210
	GOTO 220
210	START = LNKFLG
220	DO 300 I = START,LINKS
	CALL GTHWRD(NVALUE,JERR)
 	IF (JERR .EQ. 0) GOTO 240
	GOTO 800
240	ROUTES(I) = NVALUE
	BYTES = BYTES + 2
	LNKFLG = LNKFLG + 1
	IF (BYTES .GE. 256) GOTO 302
300	CONTINUE
	GOTO 310
302	IF (LNKFLG .GT. LINKS) GOTO 305
	GOTO 900
305	SWITCH = 11
	GOTO 900

*	GET THE TERMINATING HOST #
310	LNKFLG = 1
	START = 1
	CALL GTHWRD(NVALUE,JERR)
	IF (JERR .EQ. 0) GOTO 315
	GOTO 800
315	IF (NVALUE .EQ. 32896) GOTO 316
	GOTO 318
316	OHOST = 0
	THOST = 0
	GOTO 350

318	THOST = NVALUE - 32768
	BYTES = BYTES + 2
	SWITCH = 12
	GOTO 100

*	GET USER FLAGS, FIRST BYTE IS REGARDING TO TID
320	CALL GTBYTE(NVALUE,JERR)
	IF (JERR .EQ. 0) GOTO 322
	GOTO 800
322	NIDTID = NVALUE - 192
	BYTES = BYTES + 1
	PASBYT = 1
	CALL PBYTES(PASBYT,JERR)
	IF (JERR .EQ. 0) GOTO 325
	GOTO 800
325	BYTES = BYTES + 1
	SWITCH = 13
	GOTO 100

*	GET THE ORIGINATING NODE #
330	CALL GTHWRD(NVALUE,JERR)
	IF (JERR .EQ. 0) GOTO 335
	GOTO 800
335	OHOST = NVALUE - 32768

350	BYTES = BYTES + 2
	SWITCH = 1

*	WRITE OUT EACH NEEDLE
	TYPE 400,PATHSC,LINKS,ONODE,OHOST,THOST
400	FORMAT(' NEEDLE:',I5,1X,I5,1X,O5,1X,O5,1X,O5)
	DO 420 J = 1,LINKS
	TYPE 410,ROUTES(J)
410	FORMAT(2X,O5)
420	CONTINUE

	DO 440 I = 1,LINKS
	ROUTES(I) = 0
440	CONTINUE

	GOTO 100

800	KERR= JERR

900	RETURN
	END

C	SUBROUTINE GTCIRC(CIRTYP,NIDTYP)
C	--------------------------------
C	TELL ME THE NEEDLE CIRCUIT TYPE
	
    l&f–