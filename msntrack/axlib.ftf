CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                    C
C                       SUBROUTINE: AXASCA                           C
C                                                                    C
C       THIS SUBROUTINE SCANS AN ARRAY FOR A CHARACTER STRING. THE   C
C       ARRAY MUST BE IN THE FORMAT RETURNED BY SUBROUTINE AXMOUT    C
C                                                                    C
C       FORMAT: CALL AXASCA(ARRAY,ASIZE,STRING,LINE,LPOS)            C
C       ARGUMENTS:                                                   C
C          ARRAY: ARRAY CONTAINING DATA TO BE SCANNED FOR STRING     C
C          ASIZE: A VARIABLE CONTAINING THE NUMBER OF LINES  (OR     C
C                 ROWS) IN ARRAY                                     C
C          STRING: A 15 WORD ARRAY CONTAINING THE STRING TO BE FOUND C
C          LINE  : A VARIABLE RETURNING THE LINE NUMBER IN ARRAY     C
C                  IN WHICH THE STRING WAS FOUND.                    C
C          LPOS  : A VARIABLE RETURNING THE CURRENT POSITION OF LINE C
C                  THAT IS THE NEXT POSITION AFTER THE POSITION OF   C
C                  THE LAST CHARACTER OF STRING.                     C
C                                                                    C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        SUBROUTINE AXASCA(ARRAY,ASIZE,STRING,LINE,LPOS)

        IMPLICIT INTEGER(A-Z)

        DIMENSION ARRAY(ASIZE,80),STRING(15),LARRAY(80)

        LINE=0
        LPOS=0

C INIT THESE VARIABLES
C       CLINE = CURRENT LINE TO SCAN
C       SPOS  = POSITION TO START SCANNING CLINE

        SPOS=1
        CLINE=1

C PLACE CONTENTS OF LINE TO BE SCANNED INTO ARRAY TO PASS TO
C LINE SCANNING ROUTINE
100     DO 110 I=1,80
        LARRAY(I)=ARRAY(CLINE,I)
110     CONTINUE

C SCAN THIS LINE FOR STRING
120     CALL AXLSCA(LARRAY,STRING,SPOS,NEXT)

C CK IF STRING WAS FOUND
125     IF (NEXT.NE.0) GO TO 200

C STRING WAS NOT FOUND, INCREMENT CURRENT LINE POINTER
130     CLINE=CLINE+1

C CK IF AT END OF ARRAY
135     IF (CLINE.GT.ASIZE) GO TO 150

C SET START POSITION OF LINE BACK TO 1
140     SPOS=1


C GO SEARCH NEXT LINE
        GO TO 100

C REACHED END OF ARRAY WITHOUT FINDING STRING. SET  LINE NUMBER
C TO REFLECT THIS FAILURE AND RETURN
150     LINE=0
        GO TO 900

C FOUND STRING. RETURN LINE NUMBER AND LINE POSITION OF LINE IN WHICH
C STRING WAS FOUND.

200     LINE=CLINE
        LPOS=NEXT

C FINISHED. RETURN
900     RETURN
        END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                    C
C                       SUBROUTINE: AXBCOM                           C
C                                                                    C
C       THIS SUBROUTINE INSERTS A PROBE OR XRAY COMMAND INTO AN      C
C       ARRAY IN PROPER FORMAT FOR SUBROUTINE 'SEND', AND APPENDS    C
C       A NUMBER (I.E. A KERNEL-HOST OR A NEIGHBOR NODE NUMBER),     C
C       WHICH WAS ORIGINALLY IN INTEGER FORMAT, ALSO IN PROPER       C
C       FORMAT FOR 'SEND', AS PART OF THE COMMAND.                   C
C                                                                    C
C       FORMAT: CALL AXBCOM(COMM,NUM,COMAND)                         C
C       ARGUMENTS:                                                   C
C          COMM   : VARIABLE CONTAINING THE COMMAND:  MAX = 5 CHARS  C
C          NUM    : NODE OR HOST NUMBER TO BE APPENDED TO COMMAND:   C
C                   MAX = 99999                                      C
C          COMAND : 13 WORD ARRAY RETURNING THE COMPLETED COMMAND    C
C                   IN FORMAT TO BE USED BY THE SUBROUTINE 'SEND'    C
C                                                                    C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                    C
C  IF NUM = 0, THEN JUST THE COMMAND IS RETURNED IN FORMAT FOR       C
C   SUBROUTINE 'SEND', WITHOUT ANY NUMBER APPENDED.                  C
C                                                                    C
C  FORMAT OF ARRAY 'COMAND', FOR USE BY SUBROUTINE 'SEND':  FIRST    C
C  ELEMENT OF ARRAY IS COUNT OF CHARS. TO BE SENT; EACH SUBSEQUENT   C
C  ELEMENT IS ONE CHAR., RIGHT JUSTIFIED IN THE COMPUTER WORD.       C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        SUBROUTINE AXBCOM(COMM,NUM,COMAND)

        IMPLICIT INTEGER(A-Z)

        DIMENSION COMAND(13),TEMP(5),L(2)

        DATA SPACE/32/,CR/13/

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C PLACE EACH CHARACTER OF THE COMMAND INTO A SEPARATE ELEMENT OF
C ARRAY 'COMAND':  EXTRACT EACH CHARACTER, RIGHT JUSTIFY IT IN ITS
C MEMORY WORD, THEN LOAD IT INTO AN ELEMENT OF THE ARRAY.  SET A
C POINTER TO THE NUMBER OF THE LAST ELEMENT OF THE ARRAY 'COMAND'.
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        DO 120 I=2,6
        CALL RTC(CHAR,COMM,I-1)
        CHAR=LSH(CHAR,-29)
        COMAND(I)=CHAR
        COMPTR=I
120     CONTINUE

C  FIND THE LAST NON-BLANK CHARACTER IN THE COMMAND, AND SET THE
C  POINTER TO THE NUMBER OF THE NEXT ARRAY ELEMENT.
CCCCCCCCCCCCCCCCCCCCCC
        DO 130 I = 1,5
        IF (COMAND(COMPTR).NE.SPACE) GO TO 140
        COMPTR=COMPTR-1
130     CONTINUE

140     COMPTR=COMPTR+1

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  APPEND THE NUMBER (KERNEL-HOST OR NEIGHBOR NODE NUMBER) TO THE
C  INITIAL PART OF THE COMMAND FOR PROBE OR X-RAY.
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C  IF NO NUMBER IS TO BE APPENDED TO THE COMMAND, SKIP THIS SECTION;
C  OTHERWISE INSERT ONE BLANK AFTER THE COMMAND AND APPEND THE NUMBER.
CCCCCCCCCCCCCCCCCCCCCC
        IF (NUM.EQ.0) GO TO 160
        COMAND(COMPTR)=SPACE
        COMPTR=COMPTR+1

C  PLACE EACH DIGIT OF THE KERNEL-HOST OR NEIGHBOR NUMBER INTO AN
C  ELEMENT OF THE ARRAY 'TEMP'.
CCCCCCCCCCCCCCCCCCCCCC
        ENCODE(5,5000,L)NUM
5000    FORMAT (I5)
        DECODE(5,5005,L)(TEMP(J),J=1,5)
5005    FORMAT (5A1)

C  RIGHT-JUSTIFY EACH DIGIT OF THE NUMBER IN ITS ELEMENT OF THE ARRAY
C  'TEMP' AND APPEND THIS ARRAY ELEMENT TO THE ARRAY 'COMAND'; AND
C  INCREMENT THE POINTER VALUE FOR EACH ELEMENT ADDED TO THE ARRAY.
CCCCCCCCCCCCCCCCCCCCCC
        DO 150 I=1,5
        IF (TEMP(I).EQ.' ') GO TO 150
        COMAND(COMPTR)=LSH(TEMP(I),-29)
        COMPTR=COMPTR+1
150     CONTINUE

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  APPEND A CARRIAGE-RETURN TO THE END OF THE ARRAY TO TERMINATE THE
C  COMMAND TO BE SENT; INSERT A COUNT OF CHARACTERS IN THE COMMAND INTO
C  THE FIRST ELEMENT OF THE ARRAY; THEN RETURN TO CALLER.
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
160     COMAND(COMPTR)=CR
        COMAND(1)=COMPTR-1
900     RETURN
        END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                    C
C                       SUBROUTINE: AXFOUT                           C
C                                                                    C
C       THIS SUBROUTINE WRITES THE OUTPUT FROM AN AUXILIARY CIRCUIT  C
C       ONTO A SPECIFIED FILE.                                       C
C                                                                    C
C       FORMAT: CALL AXFOUT(PROMPT,FILNUM,FPTR)                      C
C       ARGUMENTS:                                                   C
C          PROMPT : VARIABLE CONTAINING THE PROMPT CHARACTER WHICH   C
C                   SIGNALS END OF OUTPUT AND READINESS FOR NEXT     C
C                   COMMAND..                                        C
C          FILNUM : THE VARIABLE CONTAINING THE DISC DEVICE NUMBER   C
C                   TO WHICH THE OUTPUT IS TO BE WRITTEN.            C
C          FPTR  : VARIABLE IN WHICH THE NUMBER OF LINES WRITTEN TO  C
C                  THE FILE WILL BE RETURNED.                        C
C                                                                    C
C       ACCESSES:  COMMON/AUX/PORT                                   C
C                                                                    C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        SUBROUTINE AXFOUT(PROMPT,FILNUM,FPTR)

        IMPLICIT INTEGER(A-Z)

        DIMENSION LARRAY(80)

C GET THE AUXILIARY CIRCUIT PORT NUMBER
        COMMON/AUX/PORT

C INIT FILE POINTER
        FPTR=1

C GET A LINE OF OUTPUT
100     CALL AXGLIN(PROMPT,LARRAY,NUMCHR,IERR)

C CK IF ANY ERRORS
110     IF (IERR.EQ.0) GO TO 140

C CK IF END OF OUTPUT
115     IF (IERR.EQ.1) GO TO 175

C LINE EXCEEDS 80 CHARACTERS. PRINT WARNING
120     TYPE 121,FPTR
121     FORMAT (1X,'WARNING! LINE: ',I4,' TRUNCATED AT 80 CHARACTERS.'
     +  ,/)

C MAKE SURE OUTPUT AT LEAST ONE CHARACTER
140     IF (NUMCHR.EQ.0) NUMCHR=1

C WRITE OUTPUT TO FILE
150     WRITE(FILNUM,155)(LARRAY(I),I=1,NUMCHR)
155     FORMAT(80A1)

C INCREMENT FILE POINTER
160     FPTR=FPTR+1

C GO GET NEXT LINE
        GO TO 100

C END OF OUTPUT- RETURN
175     RETURN
        END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                    C
C                       SUBROUTINE: AXGLIN                           C
C                                                                    C
C       THIS SUBROUTINE GETS A LINE OF OUTPUT FROM AN AUXILIARY      C
C       CIRCUIT.  MAX LENGTH OF LINE = 80 CHARACTERS.                C
C                                                                    C
C       FORMAT: CALL AXGLIN(PROMPT,ARRAY,NUMCHR,IERR)                C
C       ARGUMENTS:                                                   C
C          PROMPT : VARIABLE CONTAINING THE PROMPT CHARACTER WHICH   C
C                   SIGNALS END OF OUTPUT AND READINESS FOR NEXT     C
C                   COMMAND.                                         C
C          ARRAY  : ARRAY IN WHICH THE OUTPUT LINE WILL BE RETURNED  C
C          NUMCHR : VARIABLE IN WHICH THE NUMBER OF CHARACTERS IN    C
C                   THE OUTPUT LINE IS RETURNED.                     C
C          IERR   : VARIABLE CONTAINING ERROR FLAG. IF SET TO 0 =    C
C                   NO ERROR. IF SET TO 1 = OVER 80 CHARACTERS IN    C
C                   OUTPUT LINE.                                     C
C                                                                    C
C       ACCESSES:   COMMON/AUX/PORT                                  C
C                                                                    C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        SUBROUTINE AXGLIN(PROMPT,ARRAY,NUMCHR,IERR)

        IMPLICIT INTEGER (A-Z)

        DIMENSION ARRAY(80)

C GET THE AUXILIARY CIRCUIT PORT NUMBER
        COMMON /AUX/PORT

        DATA CR/13/,LF/10/

C INITIALIZE CHARACTER COUNTER AND ERROR FLAG
        NUMCHR=1
        IERR=0

C INITIALIZE FLAG THAT INDICATES WHETHER OR NOT MAX SIZE OF LINE HAS
C BEEN EXCEEDED

        EXFLAG=0

C INIT ARRAY
        DO 90 I=1,80
        ARRAY(I)=' '
90      CONTINUE


C WAIT FOR 1 SECOND BEFORE TRYING TO GET A CHARACTER
100     CALL WAIT(1.0)

C GET A CHARACTER
110     CALL GTCHAR(PORT,CHAR)

C IF NO CHAR, GO WAIT AND TRY AGAIN
115     IF (CHAR.LT.0) GO TO 100

C LOOK AT ONLY LAST 7 BITS. MASK = "177
120     CHAR=IAND(CHAR,127)

C CK IF WE'RE BACK TO THE PROMPT. (MEANS END OF OUTPUT)
130     IF (CHAR.NE.PROMPT) GO TO 140

C SET ERROR FLAG TO INDICATE END OF OUTPUT AND RETURN.
135     IERR=1
        GO TO 900

C AT END OF EACH LINE OF OUTPUT WE GET A LF,CR SEQUENCE.  IF THIS
C C CHAR IS A CR WE'RE FINISHED.
140     IF (CHAR.NE.CR) GO TO 150

C DECREMENT NUMBER OF CHARACTERS BY 1 AND RETURN
145     NUMCHR=NUMCHR-1
        IF (EXFLAG.EQ.1)NUMCHR=80

C IF EXFLAG IS SET THEN SET ERROR FLAG. EXFLAG = 1 WHEN MAX SIZE OF
C LINE HAS BEEN EXCEEDED.

        IF (EXFLAG.EQ.1) IERR=2

C FINISHED.

        GO TO 900

C IF THIS IS A LINE FEED, IGNORE IT AND LOOK AT NEXT CHAR.
150     IF (CHAR.EQ.LF) GO TO 110

C LEFT SHIFT THIS CHAR 29 BITS
155     CHAR=LSH(CHAR,29)

C ADD 4 SPACES TO FILL IN WORD.  THIS MAKES COMPARISONS WITH OTHER
C CHARACTERS EASIER.
157     CHAR=IOR(CHAR,"1004020100)

C PUT CHAR INTO LINE ARRAY UNLESS WE'VE EXCEEDED MAX SIZE OF ARRAY
160     IF (EXFLAG.EQ.0) ARRAY(NUMCHR)=CHAR

C INCREMENT CHARACTER COUNTER
165     NUMCHR=NUMCHR+1

C CK IF EXCEEDING SIZE OF ARRAY
        IF (NUMCHR.GT.80) EXFLAG=1

C GO GET NEXT CHAR
        GO TO 110

C ERROR. TOO MANY CHARACTERS IN LINE. EXCEEDING SIZE OF ARRAY
175     IERR=2

C FINISHD. RETURN
900     RETURN
        END


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                    C
C                       SUBROUTINE: AXISCA                           C
C                                                                    C
C       THIS SUBROUTINE IS DESIGNED TO WORK WITH THE OUTPUT FROM     C
C       THE AXGLIN SUBROUTINE, AND IN CONJUNCTION WITH THE AXLSCA    C
C       SBROUTINE. IT SCANS FOR AN INTEGER IN THE LINE ARRAY.        C
C                                                                    C
C       FORMAT : CALL AXISCA(ARRAY,SPOS,VALUE,IERR)                  C
C       ARGUMENTS:                                                   C
C          ARRAY : ARRAY CONTAINING LINE TO BE SCANNED               C
C          SPOS  : VARIABLE CONTAINING POSITION IN LINE TO START     C
C                  SCANNING                                          C
C          VALUE : VARIABLE RETURNING THE VALUE OF THE INTEGER       C
C                  NUMBER, IF FOUND. MAX = 9999999999                C
C                  OTHERWISE RETURNS A ZERO.                         C
C          IERR  : VARIABLE RETURNING STATUS OF SCAN.                C
C                  IF SET TO 0 = NOTHING MORE ON LINE                C
C                  IF SET TO +NN = POINTER TO NEXT POSITION IN LINE  C
C                                  AFTER INTEGER                     C
C                  IF SET TO -1 = INTEGER WAS NOT FOUND AT POSTION   C
C                                 SPECIFIED.                         C
C                                                                    C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        SUBROUTINE AXISCA(ARRAY,SPOS,VALUE,IERR)

        IMPLICIT INTEGER(A-Z)

        DIMENSION ARRAY(80),TEMP(10),L(2)

        VALUE=0
        IERR=0

C INIT THESE VARIABLES
C       TCNT = POINTER TO ARRAY TEMP. TEMP WILL HOLD CHARACTERS
C              THAT WILL FORM THE INTEGER
C       NBLANK = IF SET TO ONE, INDICATES A NON-BLANK CHAR HAS BEEN FOUND
C       EPOS = POSITON OF LAST DIGIT OF THE INTEGER IN THE LINE ARRAY

        TCNT=1
        NBLANK=0
        EPOS=0

C START SCANNING LINE AT USER DEFINED POSITION
100     DO 150 I=SPOS,80
        CHAR=ARRAY(I)

C IGNORE ANY BLANKS PRECEEDING THE INTEGER
105     IF (CHAR.EQ.' '.AND.NBLANK.EQ.0) GO TO 150

C IF THIS IS A BLANK AND WE'VE ALREADY ENCOUNTERED A NON-BLANK CHAR
C THEN THIS IS THE END OF THE INTEGER.
        IF (CHAR.EQ.' '.AND.NBLANK.NE.0) GO TO 180

C THIS IS A NON-BLANK CHAR. SET THE FLAG
        NBLANK=1

C IF CHAR IS NOT A NUMBER, THEN WE DON'T HAVE AN INTEGER
110     IF (CHAR.NE.'0'.AND.CHAR.NE.'1'.AND.CHAR.NE.'2'.AND.
     +     CHAR.NE.'3'.AND.CHAR.NE.'4'.AND.CHAR.NE.'5'.AND.
     +     CHAR.NE.'6'.AND.CHAR.NE.'7'.AND.CHAR.NE.'8'.AND.
     +     CHAR.NE.'9') GO TO 170

C THIS IS A NUMBER. SAVE IT
115     TEMP(TCNT)=CHAR
        TCNT=TCNT+1

C SET END POSITION TO CURRENT POSITION
        EPOS=I

C GO LOOK AT NEXT CHAR
150     CONTINUE

C FINISHED SCAN. CK IF ANY NON-BLANK CHARS WERE PRESENT
155     IF (NBLANK.NE.0) GO TO 180

C ERROR. THERE WAS NOTHING LEFT ON LINE. 
160     IERR=0
        GO TO 900

C ERROR. INTEGER NOT FOUND

170     IERR=-1
        GO TO 900

C INTEGER WAS FOUND. BUILD THE INTEGR

180     TCNT=TCNT-1
        ENCODE(TCNT,181,L)(TEMP(I),I=1,TCNT)
181     FORMAT(10A1)
        DECODE(TCNT,182,L)VALUE
182     FORMAT(I)

C SET ERROR FLAG TO INDICATE NO ERROR AND POINT TO NEXT POSITION IN
C LINE ARRAY
190     IERR=EPOS+1

C CK IF AT END OF LINE
        IF (IERR.GT.80) IERR=0


C FINISHED, RETURN
900     RETURN 
        END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                    C
C                       SUBROUTINE: AXLSCA                           C
C                                                                    C
C       THIS SUBROUTINE SCANS A CHARACTER STRING FOR ANOTHER         C
C       CHARACTER STRING.                                            C
C                                                                    C
C       FORMAT: CALL AXLSCA(STR1,STR2,SPOS,NEXT)                     C
C       ARGUMENTS:                                                   C
C          STR1   : ARRAY CONTAINING STRING TO BE SEARCHED.          C
C                   80 ELEMENT ARRAY WITH 1 CHAR PER ELEMENT         C
C          STR2   : ARRAY CONTAINING STRING TO BE FOUND.             C
C          SPOS   : VARIABLE CONTAINING POSITION IN STR1 TO START    C
C                   LOOKING FOR STR2.                                C
C          NEXT   : VARIABLE WHICH RETURNS THE CURRENT POSITON IN    C
C                   STR1. (THE POSITON OF THE LAST CHAR OF STR2 +1)  C
C                   A ZERO IS RETURNED IF STR2 IS NOT FOUND.         C
C                                                                    C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        SUBROUTINE AXLSCA(STR1,STR2,SPOS,NEXT)

        IMPLICIT INTEGER(A-Z)

   DIMENSION STR1(80),STR2(15)

C FIRST FIND THE POSITION OF THE LAST NON-BLANK CHAR OF STR2
C
C INIT SOME VARIABLES
C FIRST = FLAG WHICH IF SET MEANS FIRST NON-BLANK CHAR HAS BEEN FOUND
C END2 = POSITION IN STR2 OF LAST NON-BLANK CHARACTER

        FIRST=0
        END2=0

C START LOOPING THROUGH STR2
100     DO 110 I=1,71
        IPOS=I

C GET A CHARACTER FROM THE STRING
        CALL RTC(CHAR,STR2,IPOS)

C CK IF CHAR IS A BLANK
        IF (CHAR.EQ.' ') GO TO 105

C THIS IS NOT A BLANK. SET BLANK FLAG TO 0
        BLANK=0

C IF THIS IS NOT THE FIRST NON-BLANK CHAR, IGNORE IT.
        IF (FIRST.NE.0) GO TO 110

C THIS IS FIRST NON-BLANK CHAR. SET FIRST FLAG.
        FIRST=1
        GO TO 110

C IF FIRST NON-BLANK CHAR HAS NOT BEEN FOUND YET IGNORE THIS BLANK
105     IF (FIRST.EQ.0) GO TO 110

C IF PREVIOUS CHAR WAS ALSO A BLANK, IGNORE THIS ONE
        IF (BLANK.NE.0) GO TO 110

C THE CHAR PRIOR TO THIS ONE WAS NON-BLANK. WE COULD BE AT THE
C END OF THE STRING. SET END2 TO PRIOR CHAR.
        END2=IPOS-1
        BLANK=1

110     CONTINUE


C SET BEGINNING POSITION OF STR1 TO USER SUPPLIED START POSITION
115     POS1=SPOS

C SET BEGINNING POSITION OF STR2 TO 1

120     POS2=1

C GET A CHAR FROM STR2

122     CALL RTC(CHAR,STR2,POS2)

C SEARCH STR1 FOR THIS CHAR
125     DO 130 I=POS1,71
        CUR=I
        IF (CHAR.EQ.STR1(CUR)) GO TO 145
130     CONTINUE

C NO MATCH
140     NEXT=0
        GO TO 900

C FOUND FIRST CHAR OF STR2 IN STR1. SET POINTER TO CURRENT POSITION
C IN STR1
145     NPOS1=CUR

C INCREMENT POINTER IN STR2 TO NEXT POSITION
150     POS2=POS2+1

C CK IF REACHED END OF STR2
        IF (POS2.GT.END2) GO TO 200

C INCREMENT POINTER IN STR1 TO NEXT POSITION
        NPOS1=NPOS1+1

C CK IF NEXT CHAR OF STR1 = NEXT CHAR OF STR2. IF SO GO CK NEXT CHARS
C FOR MATCH
        CALL RTC(NCHAR,STR2,POS2)
        IF (NCHAR.EQ.STR1(NPOS1)) GO TO 150

C NEXT CHARS DO NOT MATCH - TRY AGAIN. SET POINTER OF STR2 BACK TO 
C THE BEGINNING OF THE STRING.
        POS2=1

C SET POINTER OF STR1 BACK TO WHERE WE FOUND THE PREVIOUS 1ST
C CHAR OF STR2.
        POS1=CUR+1
        GO TO 120

C WE'VE GOT A MATCH. SET NEXT TO NEXT POSITION IN STR1
200     NEXT=NPOS1+1

C RETURN
900     RETURN
        END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                    C
C                       SUBROUTINE: AXMOUT                           C
C                                                                    C
C       THIS SUBROUTINE STORES THE OUTPUT FROM AN AUXILIARY CIRCUIT  C
C       INTO MEMORY.                                                 C
C                                                                    C
C       FORMAT: CALL AXMOUT(PROMPT,ASIZE,ARRAY,APTR)                 C
C       ARGUMENTS:                                                   C
C          PROMPT : VARIABLE CONTAINING THE PROMPT CHARACTER WHICH   C
C                   SIGNALS END OF OUTPUT AND READINESS FOR NEXT     C
C                   COMMAND..                                        C
C          ASIZE : THE OUTPUT WILL BE STORED IN MEMORY IN AN ARRAY   C
C                   WHOSE DIMENSIONS WILL BE ASIZE BY 80. ASIZE      C
C                   SHOULD BE THE MAX. NUMBER OF LINES OF OUTPUT     C
C                   EXPECTED.                                        C
C          ARRAY : THE ARRAY IN WHICH  THE OUTPUT FROM THE CIRCUIT   C
C                  WILL BE RETURNED.                                 C
C          APTR  : VARIABLE IN WHICH THE POINTER TO THE LAST LINE OF C
C                  OUTPUT STORED IN ARRAY WILL BE RETURNED.          C
C                                                                    C
C       ACCESSES:  COMMON/AUX/PORT                                   C
C                                                                    C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        SUBROUTINE AXMOUT(PROMPT,ASIZE,ARRAY,APTR)

        IMPLICIT INTEGER(A-Z)

        DIMENSION ARRAY(ASIZE,80),LARRAY(80)

C GET THE AUXILIARY CIRCUIT PORT NUMBER
        COMMON/AUX/PORT

C INIT ARRAY POINTER
        APTR=1

C GET A LINE OF OUTPUT
100     CALL AXGLIN(PROMPT,LARRAY,NUMCHR,IERR)

C CK IF ANY ERRORS
110     IF (IERR.EQ.0) GO TO 150

C CK IF END OF OUTPUT
115     IF (IERR.EQ.1) GO TO 175

C LINE EXCEEDS 80 CHARACTERS. PRINT WARNING
120     TYPE 121,APTR
121     FORMAT (1X,'WARNING! LINE: ',I4,' TRUNCATED AT 80 CHARACTERS.'
     + ,/)

C PLACE OUTPUT INTO ARRAY
150     DO 155 I=1,80
        ARRAY(APTR,I)=LARRAY(I)
155     CONTINUE

C INCREMENT ARRAY POINTER
160     APTR=APTR+1

C GO GET NEXT LINE
        GO TO 100

C END OF OUTPUT- RETURN
175     RETURN
        END
uyf