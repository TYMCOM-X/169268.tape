








                           NAD68


              External Reference Specification




                             by
                      P. K. Whitehurst





                      August 27, 1990



TYMNET's proprietary rights are included in the information
disclosed herein.  The recipient, by receiving this docu-
ment, agrees that neither this document nor the information
disclosed herein nor any part thereof shall be reproduced or
transferred to other documents or used or disclosed to oth-
ers for manufacturing or for any other purpose except as
specifically authorized in writing by TYMNET.


























Page 0-0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001







NAD68 E.R.S.                                 August 27, 1990



                 1.  Introduction to NAD68

NAD68 is a version of NAD which runs in a UNIX environment
and generates 68020 object code.

This document describes how to use NAD68.  It includes a
description of the commands, instructions, directives, and
files used by NAD68.

This document does not explain Engine or 68020 object code.
It does not explain 68020 assembler language.  It does not
explain PDP/10 NAD.  For information on these subjects, the
user is directed to: _T_y_m_n_e_t _E_n_g_i_n_e _R_e_f_e_r_e_n_c_e _M_a_n_u_a_l,
_M_o_t_o_r_o_l_a _M_C_6_8_0_2_0 _U_s_e_r'_s _M_a_n_u_a_l, and _T_o_o_l_s _A_n_d _U_t_i_l_i_t_i_e_s.

1.1  Starting NAD68

NAD68 may be started by entering the Unix command

     nad68

This command places the user in the NAD68 environment.
NAD68 commands may be entered after this point.

The user may also choose to specify certain options on the
Unix command line.  These are described in section 1.2.

1.2  Options available for NAD68

The user may specify options on the command line which per-
form the following functions:

1.2.1  _C_o_m_m_a_n_d__F_i_l_e__S_p_e_c_i_f_i_c_a_t_i_o_n

     -_c _f_i_l_e_n_a_m_e

The -c option allows the user to specify a command file in
the required field _f_i_l_e_n_a_m_e.  When the end of command file
is reached, control will return to the previous level,
either CMF or UNIX.  If this option is not used NAD68 will
be in interactive mode and commands will be accepted from
STDIN.  If the -c option is given but a command file is not
specified, an error condition exists and NAD68 is ter-
minated.

1.2.2  _6_8_0_2_0__L_i_s_t_i_n_g__L_i_n_e__C_o_n_t_r_o_l

     -_i _n_u_m_b_e_r

The -i option allows the user to indicate the number of
68020 partial listing lines to put on a physical listing



Page 1-00000000000000N0A0D060800C0o0m0m0a0n0d00L0i0n0e000000000000000000000000000000000000000000000000000000000000000000000002







NAD68 E.R.S.                                 August 27, 1990



line.  The number of partial listing lines is specified by
_n_u_m_b_e_r.  If the -i option is not used only one 68020 partial
listing line will be placed on a physical listing line.  The
physical listing line must contain 60 character spaces for
each partial listing line plus an additional 16 spaces for
indentation.

1.2.3  _L_i_s_t_i_n_g__F_i_l_e__S_p_e_c_i_f_i_c_a_t_i_o_n

     -_l _f_i_l_e_n_a_m_e

The -l option allows the user to specify a file to contain
any listings generated by the assembler.  The field _f_i_l_e_n_a_m_e
contains the listing file name.  A page will be generated at
the start of the listing which contains the current date and
time and the listing file name.  The -l option will override
any listing options specified in the command file.  If the
-l option is given but a listing file is not specified, an
error condition exists and NAD68 is terminated.  Any assem-
bly errors detected will be sent to both the listing file
and the message file.

1.2.4  _M_e_s_s_a_g_e__F_i_l_e__S_p_e_c_i_f_i_c_a_t_i_o_n

     -_m _f_i_l_e_n_a_m_e

The -m option allows the user to specify a file to contain
messages.  The field _f_i_l_e_n_a_m_e contains the message file
name.  If the -m option is not chosen, any messages gen-
erated will be sent to STDERR.

Messages are defined as informative notices from the assem-
bler, assembly error and warning notices, and information
displayed by directives such as REMARK and ERRCNT.

If the -m option is selected and a message file is not
specified an error condition exists and NAD68 is terminated.

1.2.5  _I_m_a_g_e__(_o_b_j_e_c_t_)__F_i_l_e__S_p_e_c_i_f_i_c_a_t_i_o_n

     -_o _f_i_l_e_n_a_m_e

The -o option allows the user to specify an image file.  The
field _f_i_l_e_n_a_m_e contains the image file name.  This will
override any file name specified by the ;F or %F commands.
The image file specified by the -o option will overwrite
existing files with the same name.

If the -o option is selected and an image file is not speci-
fied an error condition exists and NAD68 is terminated.




Page 1-00000000000000N0A0D060800C0o0m0m0a0n0d00L0i0n0e000000000000000000000000000000000000000000000000000000000000000000000003







NAD68 E.R.S.                                 August 27, 1990



1.2.6  _P_a_t_h__S_p_e_c_i_f_i_c_a_t_i_o_n

     -_p

This options allows the user to indicate that NAD68 is to
use the path specified by CMF to locate the NAD68 input
files.

1.2.7  _R_e_m_o_v_a_l__o_f__W_a_r_n_i_n_g__N_o_t_i_f_i_c_a_t_i_o_n

     -_w

The -w option causes NAD68 to not list warning messages to
STDERR or STDOUT.  The default is to list warning messages.

1.2.8  _C_r_o_s_s__R_e_f_e_r_e_n_c_e__F_i_l_e__S_p_e_c_i_f_i_c_a_t_i_o_n

The -x option causes NAD68 to generate an intermediate cross
reference data file.  The syntax for specifying NADX options
on the NAD68 command line is:

     nad68 -x[slfom]  _f_i_l_e_n_a_m_e

     Where:


          -x        is required and indicates that cross
                    reference information is to be collected

          s         specifies that source line numbers are
                    to be saved, this is a default and has
                    the side effect of turning on the _f
                    modifier

          l         specifies that listing line numbers are
                    to be saved

          f         indicates that source file names are to
                    be saved

          o         indicates that the name of the module in
                    which a symbol is used is to be saved

          m         specifies that the name of the macro in
                    which a symbol is used is to be saved


          filename  is required and indicates the name of
                    the intermediate xref file.

     The information is placed in the specified file



Page 1-00000000000000N0A0D060800C0o0m0m0a0n0d00L0i0n0e000000000000000000000000000000000000000000000000000000000000000000000004







NAD68 E.R.S.                                 August 27, 1990



     _f_i_l_e_n_a_m_e, which may then be processed by NADX into a
     printable format.  If _f_i_l_e_n_a_m_e exists it will be
     overwritten.

     If the -x option is selected and a filename is not
     specified, then an error condition exists and NAD68 is
     terminated.















































Page 1-00000000000000N0A0D060800C0o0m0m0a0n0d00L0i0n0e000000000000000000000000000000000000000000000000000000000000000000000005







NAD68 E.R.S.                                 August 27, 1990



                 2.  NAD68 Command Language

2.1  Using the NAD68 Command Language

Like NAD, NAD68 is controlled by a series of commands.
These commands may be contained in a command file (batch
mode) or entered directly from the screen (interactive
mode).  A command file may be started from interactive mode
with a ";x" command.  In this case, interactive mode will
resume when the end of the command file is encountered.  A
command file may not start interactive mode.

Once a command file is started, NAD68 will receive all of
its commands from that file until: a %Q is encountered, an
end of file is encountered, or an error is detected that
prevents further processing.  A %Q will cause NAD68 to ter-
minate.  An end of file will cause control to be returned to
the previous level.  The previous level may be CMF, UNIX,
the NAD68 interactive command mode, or an outer level com-
mand file.  If NAD68 is unable to continue because of an
error, a message will be sent to the user and NAD68 will
terminate.

2.2  NAD68 Commands

NAD68 commands are composed of single characters or charac-
ter pairs.  Commands may be preceded by 0 to 4 arguments.
Commands may be followed by parameters.

2.3  NAD68 Arguments

A command may be preceded by 0 to 4 arguments.

Arguments generally follow the assembler rules for symbols
and expressions.  Null arguments are interpreted as zeros.
Commas are usually interpreted as argument delimiters.  The
only exception is: if an argument string contains a blank,
the argument string is considered to be an instruction.  Any
comma found in such an argument will be considered part of
the instruction.

For example:

       BETA*70/3-(1+4),,3

will be interpreted as three arguments, with the middle
argument being 0.

        STH 1,2,3

will be considered a single argument.



Page 2-000000000000N0A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000006







NAD68 E.R.S.                                 August 27, 1990



On some commands, arguments which were valid for NAD version
1 no longer have an influence.  Arguments specified on these
commands are ignored.

2.4  Assembly Commands

2.4.1  _'_;_A_'__A_s_s_e_m_b_l_e__C_o_m_m_a_n_d

The ';A' command starts the assembler.  The assembler will
generate a memory image from the contents of the specified
source file.  A listing will not be generated.

The complete syntax is:

        n;A filename

The argument 'n' is optional.  This argument will be ignored
by the NAD68 Command Language.

The parameter 'filename' is required.  It may be a PDP/10 or
UNIX formatted path to the source file.  If a file name con-
tains the character '(' it will be interpreted as a PDP/10
file specification and the system will locate the appropri-
ate file on the UNIX system. 1 Any other file name will be
interpreted as a UNIX formatted path to the source file.

In both batch and interactive mode, the file name is con-
tained on the same line as the ;A command.  It is separated
from the command by zero or more spaces or tabs.

2.4.2  _'_;_@_'__A_s_s_e_m_b_l_e__C_o_m_m_a_n_d

This is equivalent to the ';A' command.  It has the same
argument, parameter and function.

2.4.3  _'_%_A_'__A_s_s_e_m_b_l_e__a_n_d__L_i_s_t__C_o_m_m_a_n_d

This command has the same argument and parameter as the ';A'
command.  Its function is the same except that it causes an
assembly time listing to be generated.  The listing will
have the same filename as the NAD file and a file extension
of 'lst'.




__________

 1. NAD68 users who are not running under CMF must user the
    -p command line option or specify a UNIX path.




Page 2-000000000000N0A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000007







NAD68 E.R.S.                                 August 27, 1990



2.4.4  _'_%_@_'__A_s_s_e_m_b_l_e__a_n_d__L_i_s_t__C_o_m_m_a_n_d

This is equivalent to the '%A' command.  It has the same
argument, parameter and function.

2.5  Image File Manipulation Commands

2.5.1  _'_;_F_'__O_p_e_n__N_e_w__I_m_a_g_e__F_i_l_e__C_o_m_m_a_n_d

The ';F' command causes the creation of a new NAD68 image
file.  However, nothing is  written to the file unless a ;P
command is specified.

The complete syntax is:

        n;F filename

The argument 'n' is optional and may have a value of 0 or 1.
If n is omitted, the value will be 0 by default.

A value of 1 will cause any file with the name specified in
the command line to be created or replaced with the new
image file.  In interactive mode, if n is 0 and the file
exists, the user will be given the option of replacing the
existing file or canceling the command.  In batch mode, if n
is 0 and the file exists, NAD68 will be terminated and a
message sent to the user.

The parameter 'filename' is optional and contains the name
to be given to the image file.  If the file name is omitted,
the image file will be named 'IMAGE'.  The file name is
separated from the command by zero or more spaces or tabs.
If the file name contains a '(' it will be considered a
PDP/10 file specification and the system will open an
appropriate UNIX file.  This command is overridden by the -o
option in the UNIX command line.

2.5.2  _'_%_F_'__O_p_e_n__E_x_i_s_t_i_n_g__I_m_a_g_e__F_i_l_e__C_o_m_m_a_n_d

The '%F' command causes an existing image file to be opened.
The contents of the file are not modified by the command.
The complete syntax is:

        n%F filename

The argument 'n' is optional.  If n is omitted, it has a
value of zero.

If n is zero, the file becomes write protected.  The user
may copy the contents of the file to memory but may not
write to the file.



Page 2-000000000000N0A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000008







NAD68 E.R.S.                                 August 27, 1990



If n is one, new information may be written to the file.  A
message

     Data ranges read xxxx

will be displayed on the message file when this command is
used.  New segments will be inserted in segment order.
Information added to an existing segment will be inserted in
address order.

The parameter 'filename' is required. If the file does not
exist, a new file will be created.  The file name is
separated from the command by zero or more spaces or tabs.
If the file name contains a '(' it will be considered a
PDP/10 file specification and the system will open the
appropriate UNIX file.

If the object code of the image file is not for the same
processor as the object code generated by the assembler the
file is closed and an error message sent to the user.  NAD68
will not accept Engine image files, NAD will not accept
68020 image files.

This command is overridden by the -o option in the UNIX com-
mand line.

2.5.3  _'_;_G_'__R_e_a_d__T_e_x_t__F_r_o_m__I_m_a_g_e__F_i_l_e__C_o_m_m_a_n_d

The  ';G' command gets a range of memory image data from the
image file.

The complete syntax is:

        pad,vad,cnt;G

The argument 'pad' is optional and specifies the physical
address.  If pad is omitted, the physical address will have
a value of vad.  Since NAD68 does not create BND file, the
pad argument will be ignored if it is specified.

The argument 'vad' is optional and specifies the virtual
address.  If vad is omitted, the virtual address and the
physical address will have a value of zero.  If vad is
specified, the entire segment which the vad resides is
copied to the local memory image.

The argument 'cnt' is optional and specifies the number of
bytes to copy.  If cnt is omitted, the entire image file is
copied to the local memory image.  If cnt is specified, the
entire segment which the cnt resides is copied to the local
memory image.



Page 2-000000000000N0A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000009







NAD68 E.R.S.                                 August 27, 1990



Arguments are omitted starting with the leftmost argument.
That is, if only one argument is specified it will be
assigned to cnt.

2.5.4  _'_%_G_'__R_e_a_d__S_y_m_b_o_l_s__F_r_o_m__I_m_a_g_e__F_i_l_e__C_o_m_m_a_n_d

The '%G' command causes the symbol table to be read from an
open image file.  The complete syntax is:

        module %G

If specified, the argument module is ignored.  The entire
symbol table is read into the memory image.

2.5.5  _'_;_P_'__W_r_i_t_e__T_e_x_t__T_o__I_m_a_g_e__F_i_l_e__C_o_m_m_a_n_d

The ';P' command copies a range of memory image data to an
image file.

The complete format is:

        pad,vad,cnt;P

The argument 'pad' is optional and specifies the physical
address. If pad is omitted, the physical address will have
the same value as the argument vad.  Since NAD68 does not
create BND files the pad argument will be ignored if it is
specified.

The argument 'vad' is optional and specifies the virtual
address.  If vad is omitted, the virtual address and the
physical address will have a value of 0.

The argument 'cnt' is optional and specifies the number of
bytes to append.  If cnt is omitted, the entire local image
is copied to the image file.

Arguments are omitted starting with the leftmost argument.
That is, if only one argument is specified, it will be
assigned to cnt.

2.5.6  _'_%_P_'__W_r_i_t_e__S_y_m_b_o_l_s__T_o__I_m_a_g_e__F_i_l_e__C_o_m_m_a_n_d

The '%P' command causes symbol table information to be writ-
ten to an open image file.

The complete syntax is:

        module%P

If specified, the argument _m_o_d_u_l_e is ignored.  The entire



Page 2-0000000000A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000010







NAD68 E.R.S.                                 August 27, 1990



symbol table is written to the image file.

2.5.7  _'_;_T_'__W_r_i_t_e__E_n_t_r_y__P_o_i_n_t__T_o__I_m_a_g_e__F_i_l_e__C_o_m_m_a_n_d

The ';T' command specifies the program start address.  This
address is saved in the image header record and becomes the
entry point of the program.

The complete syntax is:

        pad;T

The argument _p_a_d is optional and specifies the physical
address.  If _p_a_d is omitted, the physical address has the
value of zero.

If the ';T' command is not invoked, the program start
address is zero.

2.6  Listing Control Commands

Listings may be generated by using the -l option on the
NAD68 command line or by using the %A command.

2.6.1  _'_;_%_'__S_e_t__L_i_s_t_i_n_g__P_a_g_e_S_i_z_e__C_o_m_m_a_n_d

This command sets the page listing dimensions.  The syntax
is:

     arg1,arg2;%

The arguments are optional.  If only one argument is
present, NAD68 will set the page length to _a_r_g_1.  If both
arguments are present, then NAD68 will set the line length
to _a_r_g_1 and the page length to _a_r_g_2.

Minimum line length is 50, maximum line length is 145.
Default line length is 120.

Minimum page length is 4, default page length is 56.

2.6.2  _'_;_(_'__O_p_e_n__L_i_s_t_i_n_g__F_i_l_e__C_o_m_m_a_n_d

This command opens a listing file, if not overridden by the
-l option.  The syntax is:

     type,filename;(

If present, _t_y_p_e is ignored, as only a pass one listing is
generated.  _F_i_l_e_n_a_m_e defaults to the source file name with
an extension of lst.  If filename is specified, the filename



Page 2-000000000000N0A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000011







NAD68 E.R.S.                                 August 27, 1990



will be converted into upper case.

2.6.3  _'_;_)_'__C_l_o_s_e__L_i_s_t_i_n_g__F_i_l_e__C_o_m_m_a_n_d

This command closes a listing file.

2.7  Debugger Commands

2.7.1  _'_?_'__D_e_l_e_t_e__C_o_m_m_a_n_d

The '?' command is not available in NAD68 or the Unix NAD
Analogue.  Since line-mode is used, a command may be edited
by backspacing over unwanted characters before the return
key is pressed.

2.7.2  _C_R__R_e_s_e_t__A_n_d__U_p_d_a_t_e__C_o_m_m_a_n_d

The CR command sets the current type-out mode and the
halfword/fullword mode to their standard setting, sets the
value of the current radix to the standard radix, and closes
memory.  If memory was open and an argument was specified,
memory is updated before it is closed.

2.7.3  _L_F__U_p_d_a_t_e__C_o_m_m_a_n_d

This command is replaced by the ~ command.

2.7.4  _'_~_'__U_p_d_a_t_e_,__I_n_c_r_e_m_e_n_t__A_n_d__D_i_s_p_l_a_y__C_o_m_m_a_n_d

This command updates current memory, if it is open and an
argument is specified.  It increments the pc and displays
the new memory location.  This command replaces the PDP/10
LF command.

2.7.5  _'_;_^_'__U_p_d_a_t_e_,__D_e_c_r_e_m_e_n_t__A_n_d__D_i_s_p_l_a_y__C_o_m_m_a_n_d

The ';^' command updates current memory, if it is open and
an argument is specified.  It decrements the pc by 2 or 4
and displays the new memory location.

2.7.6  _B_a_c_k_s_l_a_s_h__D_i_s_p_a_l_y__C_o_m_m_a_n_d

The '\' command displays part of the internal memory image.

The complete syntax is:

        start,finish\

The argument finish is optional.  If finish is omitted, its
value is considered as 0. If finish is present and smaller
than start, finish is the number of bytes to display.  If



Page 2-000000000000N0A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000012







NAD68 E.R.S.                                 August 27, 1990



finish is larger than start, finish is the last address to
display.

If the type-out mode is _i_n_s_t_r_u_c_t_i_o_n, NAD68 will display
68020 memory.

2.7.7  _'_[_'__D_i_s_p_l_a_y__M_a_g_n_i_t_u_d_e__C_o_m_m_a_n_d

The '[' command sets the current type-out mode to _m_a_g_n_i_t_u_d_e
and works like '\'.

2.7.8  _'_]_'__D_i_s_p_l_a_y__I_n_s_t_r_u_c_t_i_o_n__C_o_m_m_a_n_d

The ']' command sets the current type-out mode to _i_n_s_t_r_u_c_-
_t_i_o_n and works like '\'.  NAD68 will display 68020 instruc-
tions.

2.7.9  _'_;_B_a_c_k_s_l_a_s_h__'__M_o_d_i_f_y__P_C__a_n_d__D_i_s_p_l_a_y__C_o_m_m_a_n_d

This command takes the last value displayed by the debugger
and assigns it to the PC.  The memory at the new location is
opened and displayed.  If the type-out mode is _i_n_s_t_r_u_c_t_i_o_n,
NAD68 will display 68020 instructions.

2.7.10  _'_;_[_'__M_o_d_i_f_y__P_C__A_n_d__D_i_s_p_l_a_y__M_a_g_n_i_t_u_d_e__C_o_m_m_a_n_d

This command sets the current type-out mode to _m_a_g_n_i_t_u_d_e.
It takes last value displayed by the debugger and assigns it
to the PC.  The memory at the new location is opened and
displayed.

2.7.11  _'_;_]_'__M_o_d_i_f_y__P_C__a_n_d__D_i_s_p_l_a_y__I_n_s_t_r_u_c_t_i_o_n__C_o_m_m_a_n_d

This command sets the current type-out mode to _i_n_s_t_r_u_c_t_i_o_n
It takes the last value displayed by the debugger and
assigns it to the PC.  The memory at the new location is
opened and displayed.  NAD68 will display 68020 instruc-
tions.

2.7.12  _'_=_'__D_i_s_p_l_a_y__C_o_m_m_a_n_d

This command takes the last value showing on the screen,
whether entered by the user or typed by the debugger, and
translates it to the current type-out mode.

The complete syntax is:

     value=

where value is a symbol or expression.




Page 2-000000000000N0A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000013







NAD68 E.R.S.                                 August 27, 1990



2.7.13  _'_#_'__D_i_s_p_l_a_y__M_a_g_n_i_t_u_d_e__C_o_m_m_a_n_d

This command sets the current type-out mode to magnitude and
then proceeds like the '=' command.

The complete syntax is:

     value#

where value is a symbol or expression.

2.7.14  _'___'__D_i_s_p_l_a_y__S_y_m_b_o_l_i_c__C_o_m_m_a_n_d

This command sets the current type-out mode to _s_y_m_b_o_l_i_c and
then proceeds like the '=' command.

The complete syntax is:

     value_

where _v_a_l_u_e is a symbol or expression

2.7.15  _Q_u_o_t_e__S_t_o_r_e__A_S_C_I_I__C_o_m_m_a_n_d

The quote (") command stores ascii text in memory starting
at the current pc.

The complete syntax is:

     "xabcx

The character following the quote  character is interpreted
as a delimiter.  Characters are stored in memory until the
delimiter character or an end of record character is found.

2.7.16  _'_:_'__D_e_f_i_n_e__S_y_m_b_o_l__C_o_m_m_a_n_d

This command defines a symbol which has the current value of
the pc.

The complete syntax is:

     sym:

where _s_y_m is a user defined symbol.









Page 2-000000000000N0A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000014







NAD68 E.R.S.                                 August 27, 1990



2.7.17  _'_%_M_'__S_e_t__S_t_a_n_d_a_r_d__T_y_p_e_-_o_u_t__T_o__M_a_g_n_i_t_u_d_e__C_o_m_m_a_n_d

This command sets the standard type-out mode to _m_a_g_n_i_t_u_d_e.

2.7.18  _'_%_N_'__S_e_t__S_t_a_n_d_a_r_d__T_y_p_e_-_o_u_t__T_o__N_u_m_b_e_r__C_o_m_m_a_n_d

This command sets the standard type-out mode to (signed)
_n_u_m_b_e_r.

2.7.19  _'_%_Q_u_o_t_e_'__S_e_t__S_t_a_n_d_a_r_d__T_y_p_e_-_o_u_t__T_o__A_s_c_i_i__C_o_m_m_a_n_d

The command %" sets the standard type-out mode to _a_s_c_i_i.

2.7.20  _'_%_S_'__S_e_t__S_t_a_n_d_a_r_d__T_y_p_e_-_o_u_t__T_o__S_y_m_b_o_l_i_c__C_o_m_m_a_n_d

This command sets the standard type-out mode to _s_y_m_b_o_l_i_c.

2.7.21  _'_%_I_'__S_e_t__S_t_a_n_d_a_r_d__T_y_p_e_-_o_u_t__T_o__I_n_s_t_r_u_c_t_i_o_n__C_o_m_m_a_n_d

This command sets the standard type-out mode to _i_n_s_t_r_u_c_t_i_o_n.

2.7.22  _'_;_M_'__S_e_t__C_u_r_r_e_n_t__T_y_p_e_-_o_u_t__T_o__M_a_g_n_i_t_u_d_e__C_o_m_m_a_n_d

This command sets the current type-out mode to _m_a_g_n_i_t_u_d_e.

2.7.23  _'_;_N_'__S_e_t__C_u_r_r_e_n_t__T_y_p_e_-_o_u_t__t_o__N_u_m_b_e_r__C_o_m_m_a_n_d

This command sets the current type-out mode to (signed)
_n_u_m_b_e_r.

2.7.24  _'_;_Q_u_o_t_e_'__S_e_t__C_u_r_r_e_n_t__T_y_p_e_-_o_u_t__T_o__A_S_C_I_I__C_o_m_m_a_n_d

The ;" command sets the current type-out mode to _a_s_c_i_i.

2.7.25  _'_;_S_'__S_e_t__C_u_r_r_e_n_t__T_y_p_e_-_o_u_t__T_o__S_y_m_b_o_l_i_c__C_o_m_m_a_n_d

This command sets the current type-out mode to _s_y_m_b_o_l_i_c.

2.7.26  _'_;_I_'__S_e_t__C_u_r_r_e_n_t__T_y_p_e_-_o_u_t__T_o__I_n_s_t_r_u_c_t_i_o_n__C_o_m_m_a_n_d

This command sets the current type-out mode to _i_n_s_t_r_u_c_t_i_o_n.

2.7.27  _'_%_2_'__S_e_t__S_t_a_n_d_a_r_d__H_a_l_f_w_o_r_d__M_o_d_e__C_o_m_m_a_n_d

This command sets standard halfword mode.

The complete syntax is:

        p1,p2%2

_P_1, if present, indicates the column width is to be p1+1



Page 2-000000000000N0A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000015







NAD68 E.R.S.                                 August 27, 1990



characters wide.  The default is a column width of 5 charac-
ters

_P_2 is used to specify the number of columns per line.  A
value of 0 reverts to normal printout.

2.7.28  _'_%_4_'__S_e_t__S_t_a_n_d_a_r_d__F_u_l_l_w_o_r_d__M_o_d_e__C_o_m_m_a_n_d

This command sets standard fullword mode.

The complete syntax is:

        p1,p2%4

_P_1, if present, indicates the column width is to be p1+1
characters wide.  The default is a column width of 9 charac-
ters

_P_2 is used to specify the number of columns per line.  A
value of 0 reverts to normal printout.

2.7.29  _'_;_2_'__S_e_t__C_u_r_r_e_n_t__H_a_l_f_w_o_r_d__M_o_d_e__C_o_m_m_a_n_d

This command sets current halfword mode.

2.7.30  _'_;_4_'__S_e_t__C_u_r_r_e_n_t__F_u_l_l_w_o_r_d__M_o_d_e__C_o_m_m_a_n_d

This command sets current fullword mode.

2.7.31  _'_;_K_'__K_i_l_l__A__S_y_m_b_o_l__C_o_m_m_a_n_d

The ';K' command removes a symbol from the symbol table.

The complete syntax is:

     sym;K

where _s_y_m is a user defined symbol.

2.8  Miscellaneous Commands

2.8.1  _'_;_X_'__E_x_e_c_u_t_e__C_o_m_m_a_n_d__F_i_l_e__C_o_m_m_a_n_d

The ';X' command causes the command interpreter to accept
input from a command file.

The complete syntax is:

        ;X filename

_F_i_l_e_n_a_m_e is a required parameter and specifies the NAD68



Page 2-000000000000N0A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000016







NAD68 E.R.S.                                 August 27, 1990



command file.  If the file name contains the character'(' it
will be interpreted as a PDP/10 file specification and the
system will locate the appropriate file on the UNIX system.
2 Any other file name will be interpreted as a UNIX format-
ted path to the command file.

The file name is contained on the same line as the ;X com-
mand and is separated from the command by zero or more
spaces or tabs.

An end of file will cause control to return to the previous
level. The previous level may be the NAD68 interactive mode,
or an outer level command file.

2.8.2  _'_;_;_'__C_o_m_m_e_n_t__C_o_m_m_a_n_d

The ';;' command causes the remainder of the command line to
be ignored.  It is used to place comments in the command
file.

2.8.3  _'_%_Q_'__Q_u_i_t__C_o_m_m_a_n_d

The '%Q' command causes the NAD68 command processor to exit.
Control is returned to either the CMF system, or the UNIX
Shell environment.





















__________

 2. The -p option must have been specified on the command
    line to use  PDP/10 path name outside of CMF.




Page 2-000000000000N0A0D060800C0o0m0m0a0n0d00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000017







NAD68 E.R.S.                                 August 27, 1990



                3.  NAD68 Assembly Language

Input to the assembler consists of statements.  This section
will cover NAD68 statement formats and opcodes.  Directives
will be covered in section 5.

3.1  Basic Definitions

3.1.1  _S_t_a_t_e_m_e_n_t_s

The general format of a statement is:

     label    opcode    operands     :comment

Not all fields are required.

When a statement begins with a label, the label is left jus-
tified in the statement.  The symbol used for the label does
not need to be unique.  When the symbol is referenced, how-
ever, the most recent definition will be used.

The opcode field may contain opcodes or directives.

The operand field will exist only if the opcode field is
used.  The elements of this field are separated by commas
and consist of expressions or strings.  The number and type
of elements will depend on the specific opcode or directive.

The comment field starts with a ':' and is copied to the
listing file without further processing.  A statement may
contain only a comment.

Statements are separated by ';' or an end of line marker
(LF).

3.1.2  _S_y_m_b_o_l_s

A symbol is a string of 1 to 6 characters which come from
the set of alphabetic characters, numeric characters and
'.'.  The first character of a symbol must be an alphabetic
character or a '.'.  The symbol '.' is a reserved symbol
which represents the location counter.

3.1.3  _C_o_m_p_u_t_e_d__S_y_m_b_o_l_s

Some of the characters of a symbol may be computed during
the assembly process.  The computed character string is
represented by an expression delimited by the character '|'.
During assembly time the expression is evaluated, the
resulting value is converted to a string in the current
radix, and the string of digits replaces the original



Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000018







NAD68 E.R.S.                                 August 27, 1990



expression and its delimiters.

Computed symbols may not be nested.

3.1.4  _N_u_m_b_e_r_s

A number is a string of digits.  The digits must come from
the set of digits appropriate to the current radix.  If the
current radix is larger than 10, the first digit of the
string must be between 0 and 9.

3.1.5  _R_a_d_i_x

The value of a number is determined by the current radix.
The default radix is hexadecimal.  The current radix may be
changed  by using the RA directive, which is described in
the section on NAD68 directives.

The radix may be temporarily changed in an expression by
imbeding a dollar sign and hex digit ($x) in or before the
expression.  The temporary radix setting may occur more than
once in an expression. The current radix resumes at the end
of the expression.

3.1.6  _O_p_e_r_a_t_o_r_s

NAD68 has both binary and unary operators.  A binary opera-
tor is placed between the values upon which it operates.  A
unary operator precedes the value it operates on.  An opera-
tor and the value(s) it operates on may not be separated by
blanks.

The NAD68 operator precedence is:





















Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000019







NAD68 E.R.S.                                 August 27, 1990



____________________________________________________________________
_|_o__p__e__r__a__t__o__r________p__r__e__c__e__d__e__n__c__e________t__y__p__e____o__f____o__p__e__r__a__t__o__r______________________f__u__n__c__t__i__o__n___________________|_
|   (    |      8+    |                  |  start of sub-expression|
|   )    |      8+    |                  |  end of sub-expression  |
|   +    |      7     |       unary      |  unary plus             |
|   -    |      7     |       unary      |  unary minus            |
|   @    |      7     |       unary      |  one's compliment       |
|   \    |      7     |       unary      |  is defined (see below) |
|   ^    |      6     |       binary     |  shift                  |
|   *    |      5     |       binary     |  multiplication         |
|   /    |      5     |       binary     |  division               |
|   +    |      4     |       binary     |  addition               |
|   -    |      4     |       binary     |  subtraction            |
|   &    |      1     |       binary     |  and                    |
|   !    |      0     |       binary     |  or                     |
|   %    |      0     |       binary     |  exclusive or           |
_|_________|_____________|___________________|__________________________|


Higher precedence operations are performed first.

The  \ operator  returns a value of one if the expression
contains no undefined symbols, a value of zero if the
expression contains one undefined symbol, and an undefined
value if the expression contains more than one undefined
symbol.

3.1.7  _E_x_p_r_e_s_s_i_o_n_s

A NAD68 expression is a series of operators and numbers or
symbols that evaluate to a single value following the NAD68
operator precedence table. Sub-expression, delimited by
parentheses, are evaluated first, with the  most nested
sub-expression having the highest precedence.  A simple
expression may contain only one symbol or number.  An
expression may also contain one or more temporary radix
change constructs which were described above.

Only one undefined symbol is allowed in an expression.  Some
instructions do not allow undefined symbols.

3.2  Instruction Format

NAD68 instructions fit into 4 categories based on the type
of their operands: register, short, immediate and memory.









Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000020







NAD68 E.R.S.                                 August 27, 1990



3.2.1  _R_e_g_i_s_t_e_r__I_n_s_t_r_u_c_t_i_o_n_s

Register instructions contain an opcode field, and two
operands separated by a comma. The operands specify Engine
registers.  The operands may not contain undefined symbols.

The syntax is:

     rop  rexp,rexp

where _r_o_p is a register instruction opcode (see instruction
table) and _r_e_x_p is an expression which evaluates to a number
between 0 and 15d.

3.2.2  _S_h_o_r_t__I_n_s_t_r_u_c_t_i_o_n_s

Short instructions contain an opcode field and two operands
separated by a comma.  The first operand  specifies an
Engine register.  The second operand must evaluate to a
value which can be expressed in four bits.

The syntax is:

     shop  rexp,shexp

where _s_h_o_p is an short instruction opcode (see instruction
table), _r_e_x_p is an expression which evaluates to a number
between 0 and 15d, and _s_h_e_x_p is an expression which evalu-
ates to a number between -8d and 7d.

3.2.3  _I_m_m_e_d_i_a_t_e__I_n_s_t_r_u_c_t_i_o_n_s

An immediate instruction contains an opcode and up to three
operands separated by commas.  The first operand is a regis-
ter, the second is an immediate value.  The third operand is
optional and specifies an index register.

The syntax is:

     iop  rexp,imed,irexp

where _i_o_p is an immediate opcode (see instruction table)
_r_e_x_p is an expression which evaluates to a number between 0
and 15d, and _i_m_e_d is an immediate expression which evaluates
to a number between -4294967296d and 4294967295d.  _I_r_e_x_p is
an optional expression which evaluates to a number between 0
and 15d and is used as an index register.







Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000021







NAD68 E.R.S.                                 August 27, 1990



3.2.4  _M_e_m_o_r_y__I_n_s_t_r_u_c_t_i_o_n_s

A memory instruction contains an opcode and up to four
operands separated by commas. The first operand is a regis-
ter and the second is a memory location.  The third and
fourth are optional index registers.  A memory instruction
may contain 0, 1, or 2 index registers.

The syntax is:

     xop rexp,memexp,rexp,rexp

where _x_o_p is a memory opcode (see instruction table), _r_e_x_p
is an expression which evaluates to a number between 0 and
15d, and _m_e_m_e_x_p is an expression whose value is used in com-
puting an effective address.

The effective address is computed by adding the value of
_m_e_m_e_x_p and the contents of the index registers, when speci-
fied.

3.3  NAD Instructions Valid In NAD68

This section will explain the operation of NAD instructions.
These instructions are translated to 68020 instructions by
NAD68.  Not all valid NAD instructions are valid under
NAD68.  Only NAD instructions which are valid in NAD68 will
be explained in this section.

Condition codes are described as they would have been set by
an Engine.  A one indicates the condition code bit is set.
A zero indicates the condition code bit is cleared.  An x
indicates that the condition code bit is set to an arbitrary
value.  NAD68 will produce instructions that set and test
the appropriate 68020 condition code bits.

3.3.1  _L_o_g_i_c_a_l__I_n_s_t_r_u_c_t_i_o_n_s

These instructions include loads, stores, compares, and
shifts.  They provide a means  for manipulation binary data.

Unless otherwise specified, halfword operands are expanded
to a fullword by propagating the most significant bit.

Short operands are expanded to a fullword by propagating
zeros.








Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000022







NAD68 E.R.S.                                 August 27, 1990



3.3.1.1  _L_o_a_d_s

The load opcodes  replace the contents of the first operand
with the contents specified by the following operand(s).
The load opcodes include the set of:

     _________________________________________________________________
    |__M__n__e__m__o__n__i__c___|_________________I__n__s__t__r__u__c__t__i__o__n_________________|_________F__o__r__m__a__t_______|______________________________|_
    | L       |  load word               |  memory    |              |
    |__________|___________________________|_____________|_______________|
    |_L_H________|__l_o_a_d__h_a_l_f_w_o_r_d_____________|__m_e_m_o_r_y______|_______________|
    | LI      |  load immediate          |  immediate |              |
    |__________|___________________________|_____________|_______________|
    |_L_H_I_______|__l_o_a_d__h_a_l_f_w_o_r_d__i_m_m_e_d_i_a_t_e___|__i_m_m_e_d_i_a_t_e___|_______________|
    | LR      |  load register           |  register  |              |
    |__________|___________________________|_____________|_______________|
    |_L_I_S_______|__l_o_a_d__i_m_m_e_d_i_a_t_e__s_h_o_r_t______|__s_h_o_r_t_______|_______________|
    | LCS     |  load complement short   |  short     |  This        |
    |         |                          |            |  instruction |
    |         |                          |            |  takes the   |
    |         |                          |            |  two's com-  |
    |         |                          |            |  plement of  |
    |         |                          |            |  the second  |
    |         |                          |            |  operand and |
    |         |                          |            |  loads it    |
    |         |                          |            |  into the    |
    |         |                          |            |  register    |
    |         |                          |            |  specified by|
    |         |                          |            |  the first   |
    |         |                          |            |  operand.    |
    |__________|___________________________|_____________|_______________|


Condition code settings are:
     _____________________________________________________________
    |          condition          |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________________|________________|______________________|____________|____________|_
    |_o_p_e_r_a_n_d__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | operand is less than zero   |    x  |     0    |   0 |   1 |
    |______________________________|________|___________|______|______|
    |_o_p_e_r_a_n_d__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|

3.3.1.2  _L_o_a_d__A_d_d_r_e_s_s

The effective address, a fill 32 bit value, is loaded into
the register specified by the first operand.








Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000023







NAD68 E.R.S.                                 August 27, 1990



     __________________________________
    |__M__n__e__m__o__n__i__c___|_____I__n__s__t__r__u__c__t__i__o__n_____|_____F__o__r__m__a__t___|_
    | LA      |  load address|  memory|
    |__________|_______________|_________|


Condition code settings are:
     _____________________________________________________________
    |          condition          |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________________|________________|______________________|____________|____________|_
    |_o_p_e_r_a_n_d__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | operand is less than zero   |    x  |     0    |   0 |   1 |
    |______________________________|________|___________|______|______|
    |_o_p_e_r_a_n_d__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|

3.3.1.3  _L_o_a_d__H_a_l_f_w_o_r_d__L_o_g_i_c_a_l

The halfword specified by the second operand  replaces the
right half of the register specified by the first operand.
The left half of the register is zero filled.

     ___________________________________________
    |__M__n__e__m__o__n__i__c___|_______________I__n__s__t__r__u__c__t__i__o__n_____________|_____F__o__r__m__a__t___|_
    | LHL     |  load halfword logical|  memory|
    |__________|________________________|_________|


Condition code settings are:
     _____________________________________________________________
    |          condition          |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________________|________________|______________________|____________|____________|_
    |_o_p_e_r_a_n_d__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | operand is greater than zero|    x  |     0    |   1 |   0 |
    |______________________________|________|___________|______|______|

3.3.1.4  _L_o_a_d__M_u_l_t_i_p_l_e

Successive registers are loaded from successive memory loca-
tions.  The registers start with the register specified in
the first operand.  The memory locations start at the loca-
tion  specified by the effective address of the second
operand.  The process stops when register 15 has been
loaded.
     ___________________________________
    | Mnemonic|   Instruction |  Format|
    |___________________|________________________________|__________________|_
    |_L_M________|__l_o_a_d__m_u_l_t_i_p_l_e__|__m_e_m_o_r_y__|







Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000024







NAD68 E.R.S.                                 August 27, 1990



The condition codes are not affected.

3.3.1.5  _L_o_a_d__B_y_t_e

The eight bit second operand replaces the rightmost eight
bits  of the register specified by the first operand.

     __________________________________________
    |__M__n__e__m__o__n__i__c___|___________I__n__s__t__r__u__c__t__i__o__n___________|_______F__o__r__m__a__t_____|_
    | LB      |  load byte         |  memory  |
    |__________|_____________________|___________|
    ||_L_B_R_______||__l_o_a_d__b_y_t_e__r_e_g_i_s_t_e_r__||__r_e_g_i_s_t_e_r__||


Condition code settings are:

     _____________________________________________________________
    |____________________c__o__n__d__i__t__i__o__n_______________________|_____c__a__r__r__y___|_____o__v__e__r__f__l__o__w___|_____>____0___|_____<____0___|_
    | operand is zero             |    x  |     0    |   0 |   0 |
    |______________________________|________|___________|______|______|
    ||_o_p_e_r_a_n_d__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__||____x____||_____0______||___1___||___0___||

3.3.1.6  _E_x_c_h_a_n_g_e__H_a_l_f_w_o_r_d

The right half of the register specified by the second
operand replaces the left half of the register specified by
the first operand. The left half of the register specified
by the second operand replaces the right half of the regis-
ter specified by the first operand.

This instruction can be performed in one register.

     __________________________________________________
    |__M__n__e__m__o__n__i__c___|___________________I__n__s__t__r__u__c__t__i__o__n___________________|_______F__o__r__m__a__t_____|_
    | EXHR    |  exchange halfword register|  register|
    |__________|_____________________________|___________|


Condition code settings are:
     _____________________________________________________________
    |          condition          |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________________|________________|______________________|____________|____________|_
    |_o_p_e_r_a_n_d__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | operand is less than zero   |    x  |     0    |   0 |   1 |
    |______________________________|________|___________|______|______|
    |_o_p_e_r_a_n_d__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|








Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000025







NAD68 E.R.S.                                 August 27, 1990



3.3.1.7  _E_x_c_h_a_n_g_e__B_y_t_e

The two eight bit bytes contained in the right half of the
register specified by the second operand are exchanged and
loaded into the right half of the register specified by the
first operand.  The left half of both registers are
unchanged.

This instruction can be performed in one register.

     ______________________________________________
    |__M__n__e__m__o__n__i__c___|_______________I__n__s__t__r__u__c__t__i__o__n_______________|_______F__o__r__m__a__t_____|_
    | EXBR    |  exchange byte register|  register|
    |__________|_________________________|___________|


Condition code settings are:
     _____________________________________________________________
    |          condition          |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________________|________________|______________________|____________|____________|_
    |_o_p_e_r_a_n_d__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | operand is less than zero   |    x  |     0    |   0 |   1 |
    |______________________________|________|___________|______|______|
    |_o_p_e_r_a_n_d__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|

3.3.1.8  _S_t_o_r_e

The contents of the register specified by the  first operand
replace the contents of the location specified by the effec-
tive address.

     __________________________________________________
    |__M__n__e__m__o__n__i__c___|_______I__n__s__t__r__u__c__t__i__o__n_______|_____F__o__r__m__a__t___|____________________________|_
    | ST      |  store word    |  memory|             |
    |__________|_________________|_________|______________|
    | STH     |  store halfword|  memory|  the right  |
    |         |                |        |  half of the|
    |         |                |        |  register is|
    |         |                |        |  stored in a|
    ||__________||_________________||_________||__h_a_l_f_w_o_r_d_____||


The condition code settings are not affected.

3.3.1.9  _S_t_o_r_e__M_u_l_t_i_p_l_e

The contents of successive registers replaces the contents
of successive memory locations.  The first register is
specified by the first operand.  The first memory location
is specified by the second operand.  The process stops when
register 15 has been stored.



Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000026







NAD68 E.R.S.                                 August 27, 1990



     ____________________________________
    |__M__n__e__m__o__n__i__c___|_______I__n__s__t__r__u__c__t__i__o__n_______|_____F__o__r__m__a__t___|_
    | STM     |  store multiple|  memory|
    |__________|_________________|_________|


The condition code settings are not affected.

3.3.1.10  _S_t_o_r_e__B_y_t_e

The rightmost eight bits of the register specified by the
first operand are stored in a location specified by the
second operand.
     __________________________________________________________
    | Mnemonic|      Instruction    |   Format |              |
    |___________________|____________________________________________|______________________|______________________________|_
    |_S_T_B_______|__s_t_o_r_e__b_y_t_e___________|__m_e_m_o_r_y____|_______________|
    | STBR    |  store byte register|  register|  Only the    |
    |         |                     |          |  rightmost 8 |
    |         |                     |          |  bits of the |
    |         |                     |          |  second      |
    |         |                     |          |  register are|
    |         |                     |          |  modified.   |
    |         |                     |          |  All other   |
    |         |                     |          |  bits remain |
    |         |                     |          |  the same.   |
    |__________|______________________|___________|_______________|


Condition code settings are:
     _____________________________________________________________
    |          condition          |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________________|________________|______________________|____________|____________|_
    |_o_p_e_r_a_n_d__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | operand is greater than zero|    x  |     0    |   1 |   0 |
    |______________________________|________|___________|______|______|

3.3.1.11  _C_o_p_y

COPY is actually a microcode instruction for the engine.

This instruction copies a block of memory from one location
to another.  The register specified by the first operand
designates the last halfword of the source.  The register
following the register specified by the first operand desig-
nates the last halfword of the destination.

The register specified by the second operand contains a
number which is decremented and multiplied by 16 to deter-
mine the number of halfwords to move.




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000027







NAD68 E.R.S.                                 August 27, 1990



     ___________________________________
    |__M__n__e__m__o__n__i__c___|_____I__n__s__t__r__u__c__t__i__o__n___|_______F__o__r__m__a__t_____|_
    | COPY    |  copy       |  register|
    |__________|______________|___________|


Any condition codes set by this instruction are not signifi-
cant.

3.3.1.12  _A_n_d

The logical 32-bit product of the first and second operand
replaces the first operand.  The product is formed on a bit
by bit basis.
     _______________________________________________
    | Mnemonic|       Instruction      |   Format  |
    |___________________|__________________________________________________|________________________|_
    |_N_________|__a_n_d__w_o_r_d________________|__m_e_m_o_r_y_____|
    | NH      |  and halfword          |  memory   |
    |__________|_________________________|____________|
    |_N_I________|__a_n_d__i_m_m_e_d_i_a_t_e___________|__i_m_m_e_d_i_a_t_e__|
    | NHI     |  and halfword immediate|  immediate|
    |__________|_________________________|____________|
    |_N_R________|__a_n_d__r_e_g_i_s_t_e_r____________|__r_e_g_i_s_t_e_r___|


Condition code settings are:

     _____________________________________________________________
    |____________________c__o__n__d__i__t__i__o__n_______________________|_____c__a__r__r__y___|_____o__v__e__r__f__l__o__w___|_____>____0___|_____<____0___|_
    | operand is zero             |    x  |     0    |   0 |   0 |
    |______________________________|________|___________|______|______|
    |_o_p_e_r_a_n_d__i_s__l_e_s_s__t_h_a_n__z_e_r_o_____|____x____|_____0______|___0___|___1___|
    | operand is greater than zero|    x  |     0    |   1 |   0 |
    |______________________________|________|___________|______|______|

3.3.1.13  _O_r

The logical 32-bit sum of the first and second operands
replaces the first operand.  The sum is formed on a bit by
bit basis.













Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000028







NAD68 E.R.S.                                 August 27, 1990



     ______________________________________________
    |__M__n__e__m__o__n__i__c___|_______________I__n__s__t__r__u__c__t__i__o__n_____________|_______F__o__r__m__a__t_______|_
    | O       |  or word              |  memory   |
    |__________|________________________|____________|
    |_O_H________|__o_r__h_a_l_f_w_o_r_d____________|__m_e_m_o_r_y_____|
    | OI      |  or immediate         |  immediate|
    |__________|________________________|____________|
    |_O_H_I_______|__o_r__h_a_l_f_w_o_r_d__i_m_m_e_d_i_a_t_e__|__i_m_m_e_d_i_a_t_e__|
    | OR      |  or register          |  register |
    |__________|________________________|____________|


Condition code settings are:
     _____________________________________________________________
    |          condition          |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________________|________________|______________________|____________|____________|_
    |_o_p_e_r_a_n_d__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | operand is less than zero   |    x  |     0    |   0 |   1 |
    |______________________________|________|___________|______|______|
    |_o_p_e_r_a_n_d__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|

3.3.1.14  _E_x_c_l_u_s_i_v_e__O_r

The logical 32-bit difference of the first and second
operands replaces the first operand.  The difference is
formed on a bit by bit basis

     ________________________________________________________
    |__M__n__e__m__o__n__i__c___|_________________________I__n__s__t__r__u__c__t__i__o__n_______________________|_______F__o__r__m__a__t_______|_
    | X       |  exclusive or word              |  memory   |
    |__________|__________________________________|____________|
    |_X_H________|__e_x_c_l_u_s_i_v_e__o_r__h_a_l_f_w_o_r_d____________|__m_e_m_o_r_y_____|
    | XI      |  exclusive or immediate         |  immediate|
    |__________|__________________________________|____________|
    |_X_H_I_______|__e_x_c_l_u_s_i_v_e__o_r__h_a_l_f_w_o_r_d__i_m_m_e_d_i_a_t_e__|__i_m_m_e_d_i_a_t_e__|
    | XR      |  exclusive or register          |  register |
    |__________|__________________________________|____________|


Condition code settings are:
     _____________________________________________________________
    |          condition          |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________________|________________|______________________|____________|____________|_
    |_o_p_e_r_a_n_d__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | operand is less than zero   |    x  |     0    |   0 |   1 |
    |______________________________|________|___________|______|______|
    |_o_p_e_r_a_n_d__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|







Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000029







NAD68 E.R.S.                                 August 27, 1990



3.3.1.15  _A_r_r_a_y__A_n_d

This is a microcode instruction for the engine.

The first operand specifies the first register of a register
pair.  This register contains the address of the last half-
word in an array.  The second register of this pair contains
the address of another array.  The second operand is a
register which contains the number of bits minus 1 to scan.

The contents of the register pair is updated to reflect the
last halfword examined in each array.

On a normal return, the second operand contains the number
of the "highest" bit set in common in both arrays.  On an
error return, the next instruction (assumed to be 2 bytes
long) is skipped.

     ___________________________________
    |__M__n__e__m__o__n__i__c___|_____I__n__s__t__r__u__c__t__i__o__n___|_______F__o__r__m__a__t_____|_
    | ARAND   |  array and  |  register|
    |__________|______________|___________|


Any condition code settings are insignificant.

3.3.1.16  _T_e_s_t__I_m_m_e_d_i_a_t_e

Each bit of the second operand is logically ANDed with the
corresponding bit of the first operand.  Neither operand is
changed.
     ________________________________________________
    | Mnemonic|        Instruction      |   Format  |
    |___________________|____________________________________________________|________________________|_
    |_T_I________|__t_e_s_t__i_m_m_e_d_i_a_t_e___________|__i_m_m_e_d_i_a_t_e__|
    | THI     |  test halfword immediate|  immediate|
    |__________|__________________________|____________|


Condition code settings are:
     ____________________________________________________________
    |          condition         |  carry|  overflow|  > 0|  < 0|
    |_________________________________________________________|________________|______________________|____________|____________|_
    |_r_e_s_u_l_t__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | result is less than zero   |    x  |     0    |   0 |   1 |
    |_____________________________|________|___________|______|______|
    |_r_e_s_u_l_t__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|







Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000030







NAD68 E.R.S.                                 August 27, 1990



3.3.1.17  _S_h_i_f_t__L_e_f_t__L_o_g_i_c_a_l

The first operand is shifted left by the number of bits
specified by the second operand.  Bits shifted out of posi-
tion 0 are shifted through the carry flag.  Bits shifted
into postion 31 are zeroes.

     ______________________________________________
    |__M__n__e__m__o__n__i__c___|_________________I__n__s__t__r__u__c__t__i__o__n_________________|_____F__o__r__m__a__t___|_
    | SLL     |  shift left logical      |  memory|
    |__________|___________________________|_________|
    ||_S_L_L_S______||__s_h_i_f_t__l_e_f_t__l_o_g_i_c_a_l__s_h_o_r_t__||__s_h_o_r_t___||


Condition code settings are:

     The carry flag is set to the value of the last bit
     shifted out.

3.3.1.18  _S_h_i_f_t__R_i_g_h_t__L_o_g_i_c_a_l

The first operand is shifted right the number of places
specified by the second operand.  Bits shifted out of posi-
tion 31 are shifted through the carry flag.  Bits shifted
into position 0 are zeroes.

     _______________________________________________
    |__M__n__e__m__o__n__i__c___|___________________I__n__s__t__r__u__c__t__i__o__n_________________|_____F__o__r__m__a__t___|_
    | SRL     |  shift right logical      |  memory|
    |__________|____________________________|_________|
    ||_S_R_L_S______||__s_h_i_f_t__r_i_g_h_t__l_o_g_i_c_a_l__s_h_o_r_t__||__s_h_o_r_t___||


Condition code settings are:

     The carry flag contains the value of the last bit
     shifted out of position 31.

3.3.1.19  _S_h_i_f_t__L_e_f_t__H_a_l_f_w_o_r_d__L_o_g_i_c_a_l

Bits 16:31 of the first operand are shifted left the number
of bits specified by the second operand. Bits shifted out of
postion 16 are shifted through the carry flag.  Bits shifted
into postion 31 are zeroes.  Bits 0:15 remain unchanges.










Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000031







NAD68 E.R.S.                                 August 27, 1990



     _______________________________________________________
    |__M__n__e__m__o__n__i__c___|___________________________I__n__s__t__r__u__c__t__i__o__n_________________________|_____F__o__r__m__a__t___|_
    | SLHL    |  shift left halfword logical      |  memory|
    |__________|____________________________________|_________|
    ||_S_L_H_L_S_____||__s_h_i_f_t__l_e_f_t__h_a_l_f_w_o_r_d__l_o_g_i_c_a_l__s_h_o_r_t__||__s_h_o_r_t___||


Condition code settings are:

     _____________________________________________________________
    |____________________c__o__n__d__i__t__i__o__n_______________________|_____c__a__r__r__y___|_____o__v__e__r__f__l__o__w___|_____>____0___|_____<____0___|_
    | operand is zero             |    x  |     0    |   0 |   0 |
    |______________________________|________|___________|______|______|
    |_o_p_e_r_a_n_d__i_s__l_e_s_s__t_h_a_n__z_e_r_o_____|____x____|_____0______|___0___|___1___|
    | operand is greater than zero|    x  |     0    |   1 |   0 |
    |______________________________|________|___________|______|______|

3.3.1.20  _S_h_i_f_t__R_i_g_h_t__H_a_l_f_w_o_r_d__L_o_g_i_c_a_l

Bits 16:31 of the first operand are shifted right the number
of places specified by the second operand.  Bits shifted out
of position 31 are shifted through the carry flag.  Bits
shifted into postion 16 are zeroes.  Bits 0:15 remain
unchanged.
     ________________________________________________________
    | Mnemonic|             Instruction            |  Format|
    |___________________|__________________________________________________________________________|__________________|_
    |_S_R_H_L______|__s_h_i_f_t__r_i_g_h_t__h_a_l_f_w_o_r_d__l_o_g_i_c_a_l________|__m_e_m_o_r_y__|
    | SRHLS   |  shift right halfword logical short|  short |
    |__________|_____________________________________|_________|


Condition code settings are:
     _____________________________________________________________
    |          condition          |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________________|________________|______________________|____________|____________|_
    |_o_p_e_r_a_n_d__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | operand is less than zero   |    x  |     0    |   0 |   1 |
    |______________________________|________|___________|______|______|
    |_o_p_e_r_a_n_d__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|

3.3.1.21  _R_o_t_a_t_e__L_e_f_t__L_o_g_i_c_a_l

The 32-bit first operand is rotated left by the number of
bits specified by the second operand.  Bits shifted out of
position 0 are shifted into position 31.








Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000032







NAD68 E.R.S.                                 August 27, 1990



     ____________________________________________
    |__M__n__e__m__o__n__i__c___|_____________I__n__s__t__r__u__c__t__i__o__n___________|_______F__o__r__m__a__t_______|_
    | RLL     |  rotate left logical|  immediate|
    |__________|______________________|____________|


Condition code settings are:
     _____________________________________________________________
    |          condition          |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________________|________________|______________________|____________|____________|_
    |_o_p_e_r_a_n_d__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | operand is less than zero   |    x  |     0    |   0 |   1 |
    |______________________________|________|___________|______|______|
    |_o_p_e_r_a_n_d__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|

3.3.1.22  _R_o_t_a_t_e__R_i_g_h_t__L_o_g_i_c_a_l

The 32-bit first operand is rotated right by the number of
bits specified by the second operand.  The bits shifted out
of position 31 are shifted into position 0.

     _____________________________________________
    |__M__n__e__m__o__n__i__c___|_____________I__n__s__t__r__u__c__t__i__o__n_____________|_______F__o__r__m__a__t_______|_
    | RRL     |  rotate right logical|  immediate|
    |__________|_______________________|____________|


Condition code settings are:
     _____________________________________________________________
    |          condition          |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________________|________________|______________________|____________|____________|_
    |_o_p_e_r_a_n_d__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | operand is less than zero   |    x  |     0    |   0 |   1 |
    |______________________________|________|___________|______|______|
    |_o_p_e_r_a_n_d__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|

3.3.1.23  _T_e_s_t__a_n_d__S_e_t

A halfword, specified by the second operand, is read and the
location is changed to 0FFFF.  The condition code is set
based upon the original contents of memory.

     __________________________________
    |__M__n__e__m__o__n__i__c___|_____I__n__s__t__r__u__c__t__i__o__n_____|_____F__o__r__m__a__t___|_
    | TS      |  test and set|  memory|
    |__________|_______________|_________|


Condition code settings are:





Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000033







NAD68 E.R.S.                                 August 27, 1990



     ___________________________________________________________
    |__________________c__o__n__d__i__t__i__o__n_____________________|_____c__a__r__r__y___|_____o__v__e__r__f__l__o__w___|_____>____0___|_____<____0___|_
    | value is zero             |    x  |     0    |   0 |   0 |
    |____________________________|________|___________|______|______|
    |_v_a_l_u_e__i_s__l_e_s_s__t_h_a_n__z_e_r_o_____|____x____|_____0______|___0___|___1___|
    | value is greater than zero|    x  |     0    |   1 |   0 |
    |____________________________|________|___________|______|______|

3.3.1.24  _T_e_s_t__B_i_t

The  second operand contains the starting address of an bit
array.  The address must be on a halfword boundary.  The
first operand contains the offset of the bit to test.  The
bit is located and tested.  The value of the bit does not
change.
     _________________________________
    | Mnemonic|  Instruction|  Format|
    |___________________|____________________________|__________________|_
    |_T_B_T_______|__t_e_s_t__b_i_t_____|__m_e_m_o_r_y__|


Condition code settings are:

     ____________________________________________
    |____c__o__n__d__i__t__i__o__n_____|_____c__a__r__r__y___|_____o__v__e__r__f__l__o__w___|_____>____0___|_____<____0___|_
    | bit is zero|    x  |     0    |   0 |   0 |
    |_____________|________|___________|______|______|
    ||_b_i_t__i_s__o_n_e___||____x____||_____0______||___1___||___0___||

3.3.1.25  _S_e_t__B_i_t

The second operand points to a bit array which starts on a
halfword boundary.  The first operand contains the offset of
the bit to set.  The bit is located and set to one.  The
condition code is set based on the previous value of the
bit.

     _________________________________
    |__M__n__e__m__o__n__i__c___|_____I__n__s__t__r__u__c__t__i__o__n___|_____F__o__r__m__a__t___|_
    | SBT     |  set bit    |  memory|
    |__________|______________|_________|


Condition code settings are:
     _____________________________________________
    |  condition  |  carry|  overflow|  > 0|  < 0|
    |___________________________|________________|______________________|____________|____________|_
    |_b_i_t__w_a_s__z_e_r_o__|____x____|_____0______|___0___|___0___|
    | bit was one |    x  |     0    |   1 |   0 |
    |______________|________|___________|______|______|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000034







NAD68 E.R.S.                                 August 27, 1990



    |______________|________|___________|______|______|

3.3.1.26  _R_e_s_e_t__B_i_t

The second operand points to a bit array starting on a half-
word boundary.  The first operand contains the offset of the
bit to reset.  The bit is located and set to zero.  The con-
dition code is set based on the previous value of the bit.
     _________________________________
    | Mnemonic|  Instruction|  Format|
    |___________________|____________________________|__________________|_
    |_R_B_T_______|__r_e_s_e_t__b_i_t____|__m_e_m_o_r_y__|


Condition code settings are:

     _____________________________________________
    |____c__o__n__d__i__t__i__o__n_______|_____c__a__r__r__y___|_____o__v__e__r__f__l__o__w___|_____>____0___|_____<____0___|_
    | bit was zero|    x  |     0    |   0 |   0 |
    |______________|________|___________|______|______|
    ||_b_i_t__w_a_s__o_n_e___||____x____||_____0______||___1___||___0___||

3.3.1.27  _C_o_m_p_l_e_m_e_n_t__B_i_t

The second operand points to a bit array starting on a half-
word boundary.  The first operand is a register which con-
tains the offset of the bit in the array.  The bit is
located and complemented.  The condition code is set based
on the previous value.

     ____________________________________
    |__M__n__e__m__o__n__i__c___|_______I__n__s__t__r__u__c__t__i__o__n_______|_____F__o__r__m__a__t___|_
    | CBT     |  complement bit|  memory|
    |__________|_________________|_________|


Condition code settings are:
     _____________________________________________
    |  condition  |  carry|  overflow|  > 0|  < 0|
    |___________________________|________________|______________________|____________|____________|_
    |_b_i_t__w_a_s__z_e_r_o__|____x____|_____0______|___0___|___0___|
    | bit was one |    x  |     0    |   1 |   0 |
    |______________|________|___________|______|______|

3.3.2  _J_u_m_p__I_n_s_t_r_u_c_t_i_o_n_s

Jump instructions allow no-sequential execution of instruc-
tions.






Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000035







NAD68 E.R.S.                                 August 27, 1990



3.3.2.1  _J_u_m_p__O_n__C_o_n_d_i_t_i_o_n

The condition code is tested for the conditions specified.
If all conditions are found to be false, a jump is executed
to the second operand location.  If any condition is found
to be true, the next sequential instruction is executed.

     __________________________________________________________
    ||__M__n__e__m__o__n__i__c___||___________________________I__n__s__t__r__u__c__t__i__o__n___________________________||_______F__o__r__m__a__t_____||_
    | NOP     |  no operations (jump never)        |  memory  |
    |__________|_____________________________________|___________|
    |__N__O__P__R___________|_____n__o____o__p__e__r__a__t__i__o__n____r__e__g__i__s__t__e__r____(__j__u__m__p____n__e__v__e__r__)___|_____r__e__g__i__s__t__e__r___|_
    | J       |  jump always                       |  memory  |
    |__________|_____________________________________|___________|
    |_J_R________|__j_u_m_p__a_l_w_a_y_s__r_e_g_i_s_t_e_r________________|__r_e_g_i_s_t_e_r__|
    | JBS     |  jump always backward short        |  short   |
    |__________|_____________________________________|___________|
    |__J__F__S_____________|_____j__u__m__p____a__l__w__a__y__s____f__o__r__w__a__r__d____s__h__o__r__t_____________________|_____s__h__o__r__t_________|_
    | JE      |  jump equal                        |  memory  |
    |__________|_____________________________________|___________|
    |_J_E_R_______|__j_u_m_p__e_q_u_a_l__r_e_g_i_s_t_e_r_________________|__r_e_g_i_s_t_e_r__|
    | JEBS    |  jump equal backward short         |  short   |
    |__________|_____________________________________|___________|
    |__J__E__F__S___________|_____j__u__m__p____e__q__u__a__l____f__o__r__w__a__r__d____s__h__o__r__t_______________________|_____s__h__o__r__t_________|_
    | JN      |  jump not equal                    |  memory  |
    |__________|_____________________________________|___________|
    |_J_N_R_______|__j_u_m_p__n_o_t__e_q_u_a_l__r_e_g_i_s_t_e_r_____________|__r_e_g_i_s_t_e_r__|
    | JNBS    |  jump not equal backward short     |  short   |
    |__________|_____________________________________|___________|
    |__J__N__F__S___________|_____j__u__m__p____n__o__t____e__q__u__a__l____f__o__r__w__a__r__d____s__h__o__r__t_______________|_____s__h__o__r__t_________|_
    | JG      |  jump greater                      |  memory  |
    |__________|_____________________________________|___________|
    |_J_G_R_______|__j_u_m_p__g_r_e_a_t_e_r__r_e_g_i_s_t_e_r_______________|__r_e_g_i_s_t_e_r__|
    | JGBS    |  jump greater backward short       |  short   |
    |__________|_____________________________________|___________|
    |__J__G__F__S___________|_____j__u__m__p____g__r__e__a__t__e__r____f__o__r__w__a__r__d____s__h__o__r__t___________________|_____s__h__o__r__t_________|_
    | JGE     |  jump greater equal                |  memory  |
    |__________|_____________________________________|___________|
    |_J_G_E_R______|__j_u_m_p__g_r_e_a_t_e_r__e_q_u_a_l__r_e_g_i_s_t_e_r_________|__r_e_g_i_s_t_e_r__|
    | JGEBS   |  jump greater equal backward short |  short   |
    |__________|_____________________________________|___________|
    |__J__G__E__F__S_________|_____j__u__m__p____g__r__e__a__t__e__r____e__q__u__a__l____f__o__r__w__a__r__d____s__h__o__r__t_______|_____s__h__o__r__t_________|_
    | JLE     |  jump less equal                   |  memory  |
    |__________|_____________________________________|___________|
    |_J_L_E_R______|__j_u_m_p__l_e_s_s__e_q_u_a_l__r_e_g_i_s_t_e_r____________|__r_e_g_i_s_t_e_r__|
    | JLEBS   |  jump less equal backward short    |  short   |
    |__________|_____________________________________|___________|
    |__J__L__E__F__S_________|_____j__u__m__p____l__e__s__s____e__q__u__a__l____f__o__r__w__a__r__d____s__h__o__r__t_____________|_____s__h__o__r__t_________|_
    | JL      |  jump less                         |  memory  |
    |__________|_____________________________________|___________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000036







NAD68 E.R.S.                                 August 27, 1990



     __________________________________________________________
    ||__M__n__e__m__o__n__i__c___||___________________________I__n__s__t__r__u__c__t__i__o__n___________________________||_______F__o__r__m__a__t_____||_
    |__________|_____________________________________|___________|
    |_J_L_R_______|__j_u_m_p__l_e_s_s__r_e_g_i_s_t_e_r__________________|__r_e_g_i_s_t_e_r__|
    | JLBS    |  jump less backward short          |  short   |
    |__________|_____________________________________|___________|
    |__J__L__F__S___________|_____j__u__m__p____l__e__s__s____f__o__r__w__a__r__d____s__h__o__r__t_________________________|_____s__h__o__r__t_________|_
    | JC      |  jump carry                        |  memory  |
    |__________|_____________________________________|___________|
    |_J_C_R_______|__j_u_m_p__c_a_r_r_y__r_e_g_i_s_t_e_r_________________|__r_e_g_i_s_t_e_r__|
    | JCBS    |  jump carry backward short         |  short   |
    |__________|_____________________________________|___________|
    |__J__C__F__S___________|_____j__u__m__p____c__a__r__r__y____f__o__r__w__a__r__d____s__h__o__r__t_______________________|_____s__h__o__r__t_________|_
    | JNC     |  jump no carry                     |  memory  |
    |__________|_____________________________________|___________|
    |_J_N_C_R______|__j_u_m_p__n_o__c_a_r_r_y__r_e_g_i_s_t_e_r______________|__r_e_g_i_s_t_e_r__|
    | JNCBS   |  jump no carry backward short      |  short   |
    |__________|_____________________________________|___________|
    |_J_N_C_F_S_____|__j_u_m_p__n_o__c_a_r_r_y__f_o_r_w_a_r_d__s_h_o_r_t_________|__s_h_o_r_t_____|

Jumps may also be coded specifying a mask in the first
operand which is used to test the condition code portion of
the PSW.  See the _T_y_m_n_e_t _E_n_g_i_n_e _R_e_f_e_r_e_n_c_e _M_a_n_u_a_l for a
description of the PSW.






























Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000037







NAD68 E.R.S.                                 August 27, 1990



     ___________________________________________________________
    ||__M__n__e__m__o__n__i__c___||_____________________________I__n__s__t__r__u__c__t__i__o__n___________________________||_______F__o__r__m__a__t_____||_
    | JF      |  jump false condition               |  memory  |
    |__________|______________________________________|___________|
    |_J_F_R_______|__j_u_m_p__f_a_l_s_e__c_o_n_d_i_t_i_o_n__r_e_g_i_s_t_e_r________|__r_e_g_i_s_t_e_r__|
    | JFBS    |  jump false condition backward short|  short   |
    |__________|______________________________________|___________|
    |_J_F_F_S______|__j_u_m_p__f_a_l_s_e__c_o_n_d_i_t_i_o_n__f_o_r_w_a_r_d__s_h_o_r_t___|__s_h_o_r_t_____|
    | JT      |  jump true condition                |  memory  |
    |__________|______________________________________|___________|
    |_J_T_R_______|__j_u_m_p__t_r_u_e__c_o_n_d_i_t_i_o_n__r_e_g_i_s_t_e_r_________|__r_e_g_i_s_t_e_r__|
    | JTBS    |  jump true condition backward short |  short   |
    |__________|______________________________________|___________|
    |_J_T_F_S______|__j_u_m_p__t_r_u_e__c_o_n_d_i_t_i_o_n__f_o_r_w_a_r_d__s_h_o_r_t____|__s_h_o_r_t_____|


Condition code settings are not affected.

3.3.2.2  _J_u_m_p__A_n_d__L_i_n_k

The address of the next sequential instruction is saved in
the register specified by the first operand.  A branch is
taken to the second operand address.  The branch address is
obtained before the register specified by the first operand
is changed.

     ______________________________________________
    |__M__n__e__m__o__n__i__c___|_______________I__n__s__t__r__u__c__t__i__o__n_______________|_______F__o__r__m__a__t_____|_
    | JAL     |  jump and link         |  memory  |
    |__________|_________________________|___________|
    ||_J_A_L_R______||__j_u_m_p__a_n_d__l_i_n_k__r_e_g_i_s_t_e_r__||__r_e_g_i_s_t_e_r__||


Condition code settings are not affected.

3.3.2.3  _J_u_m_p__O_n__F_i_n_d__F_i_r_s_t__O_n_e

The first operand contains the first register of a register
pair.  The first register of the pair is examined to deter-
mine if it is zero.  If so the next sequential instruction
is executed.  If the register does not contain zero, the
number of the left-most bit that is not set to zero is
placed in the second register of the pair.  For this
instruction, bits are numbered with the left-most bit being
0.









Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000038







NAD68 E.R.S.                                 August 27, 1990



     _________________________________________________________________
    |__M__n__e__m__o__n__i__c___|_____________________I__n__s__t__r__u__c__t__i__o__n_____________________|_____F__o__r__m__a__t___|______________________________|_
    | JFFO    |  jump find first one         |  short |              |
    |__________|_______________________________|_________|_______________|
    | JFFOH   |  jump find first one halfword|  short |  the right-  |
    |         |                              |        |  most 16 bits|
    |         |                              |        |  of the      |
    |         |                              |        |  register are|
    |         |                              |        |  used, with  |
    |         |                              |        |  bit 16d     |
    |         |                              |        |  being num-  |
    ||__________||_______________________________||_________||__b_e_r_e_d__0_______||


Condition code settings are not affected.

3.3.3  _A_r_i_t_h_m_e_t_i_c_I_n_s_t_r_u_c_t_i_o_n_s

These are fixed point arithmetic instructions.

Halfword operations propagate the sign bit  when expanding
halfword to fullwords before performing the operation.

3.3.3.1  _A_d_d

The second operand is added algebraically to the contents of
the register specified by the first operand.

     ______________________________________________________________
    |__M__n__e__m__o__n__i__c___|_______________I__n__s__t__r__u__c__t__i__o__n_______________|_______F__o__r__m__a__t_______|______________________________|_
    | A       |  add                   |  memory   |              |
    |__________|_________________________|____________|_______________|
    |_A_H________|__a_d_d__h_a_l_f_w_o_r_d____________|__m_e_m_o_r_y_____|_______________|
    | AI      |  add immediate         |  immediate|              |
    |__________|_________________________|____________|_______________|
    |_A_H_I_______|__a_d_d__h_a_l_f_w_o_r_d__i_m_m_e_d_i_a_t_e__|__i_m_m_e_d_i_a_t_e__|_______________|
    | AR      |  add register          |  register |              |
    |__________|_________________________|____________|_______________|
    | AIS     |  add immediate short   |  short    |  the four    |
    |         |                        |           |  bits data is|
    |         |                        |           |  expanded to |
    |         |                        |           |  32 bits by  |
    |         |                        |           |  propogating |
    |         |                        |           |  the left-   |
    ||__________||_________________________||____________||__m_o_s_t__b_i_t______||


Condition code settings are:






Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000039







NAD68 E.R.S.                                 August 27, 1990



     _________________________________________________________
    |________________c__o__n__d__i__t__i__o__n___________________|_____c__a__r__r__y___|_____o__v__e__r__f__l__o__w___|_____>____0___|_____<____0___|_
    | sum is zero             |    x  |     0    |   0 |   0 |
    |__________________________|________|___________|______|______|
    |_s_u_m__i_s__l_e_s_s__t_h_a_n__z_e_r_o_____|____x____|_____0______|___0___|___1___|
    | sum is greater than zero|    x  |     0    |   1 |   0 |
    |__________________________|________|___________|______|______|

3.3.3.2  _A_d_d__T_o__M_e_m_o_r_y

The second operand is added algebraically to the contents of
the register specified by the first operand.  The result
replaces the second operand.  The contents of the first
operand do not change.
     ____________________________________________
    | Mnemonic|       Instruction      |  Format|
    |___________________|__________________________________________________|__________________|_
    |_A_M________|__a_d_d__t_o__m_e_m_o_r_y___________|__m_e_m_o_r_y__|
    | AHM     |  add halfword to memory|  memory|
    |__________|_________________________|_________|


Condition code settings are:
     _________________________________________________________
    |        condition        |  carry|  overflow|  > 0|  < 0|
    |___________________________________________________|________________|______________________|____________|____________|_
    |_s_u_m__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | sum is less than zero   |    x  |     0    |   0 |   1 |
    |__________________________|________|___________|______|______|
    |_s_u_m__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|

Condition codes for AHM are determined by assuming 32-bit
addition, not 16-bit addition.  The carry bit can be used to
determine if the result has overflowed 16 bits.

3.3.3.3  _S_u_b_t_r_a_c_t_:

The second operand is subtracted algebraically from the con-
tents of the register specified by the first operand.  The
result replaces the contents of the register specified by
the first operand.













Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000040







NAD68 E.R.S.                                 August 27, 1990



     ____________________________________________________
    |__M__n__e__m__o__n__i__c___|_____________________I__n__s__t__r__u__c__t__i__o__n___________________|_______F__o__r__m__a__t_______|_
    | S       |  subtract                   |  memory   |
    |__________|______________________________|____________|
    |_S_H________|__s_u_b_t_r_a_c_t__h_a_l_f_w_o_r_d____________|__m_e_m_o_r_y_____|
    | SI      |  subtract immediate         |  immediate|
    |__________|______________________________|____________|
    |_S_H_I_______|__s_u_b_t_r_a_c_t__h_a_l_f_w_o_r_d__i_m_m_e_d_i_a_t_e__|__i_m_m_e_d_i_a_t_e__|
    | SR      |  subtract register          |  register |
    |__________|______________________________|____________|
    ||_S_I_S_______||__s_u_b_t_r_a_c_t__i_m_m_e_d_i_a_t_e__s_h_o_r_t_____||__s_h_o_r_t______||


Condition code settings are:

     ________________________________________________________________
    |________________________c__o__n__d__i__t__i__o__n_________________________|_____c__a__r__r__y___|_____o__v__e__r__f__l__o__w___|_____>____0___|_____<____0___|_
    | difference is zero             |    x  |     0    |   0 |   0 |
    |_________________________________|________|___________|______|______|
    |_d_i_f_f_e_r_e_n_c_e__i_s__l_e_s_s__t_h_a_n__z_e_r_o_____|____x____|_____0______|___0___|___1___|
    | difference is greater than zero|    x  |     0    |   1 |   0 |
    |_________________________________|________|___________|______|______|

3.3.3.4  _C_o_m_p_a_r_e__L_o_g_i_c_a_l

The contents fo the register specified by the first operand
is compared to the second operand by subtracting the second
from the first.  The results are indicated by the condition
code setting.  Neither operand is modified.
     ___________________________________________________________
    | Mnemonic|             Instruction            |   Format  |
    |___________________|__________________________________________________________________________|________________________|_
    |_C_L________|__c_o_m_p_a_r_e__l_o_g_i_c_a_l_____________________|__m_e_m_o_r_y_____|
    | CLH     |  compare logical halfword          |  memory   |
    |__________|_____________________________________|____________|
    |_C_L_I_______|__c_o_m_p_a_r_e__l_o_g_i_c_a_l__i_m_m_e_d_i_a_t_e___________|__i_m_m_e_d_i_a_t_e__|
    | CLHI    |  compare logical halfword immediate|  immediate|
    |__________|_____________________________________|____________|
    | CLR     |  compare logical register          |  register |
    |__________|_____________________________________|____________|














Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000041







NAD68 E.R.S.                                 August 27, 1990



Condition code settings are:

     ______________________________________________________
    |______________c__o__n__d__i__t__i__o__n_______________|_____c__a__r__r__y___|_____o__v__e__r__f__l__o__w___|_____>____0___|_____<____0___|_
    | operands are the same|    x  |     0    |   0 |   0 |
    |_______________________|________|___________|______|______|
    | first operand alge-  |    x  |     0    |   0 |   1 |
    | braically less than  |       |          |     |     |
    |_s_e_c_o_n_d_________________|________|___________|______|______|
    | first operand is     |    x  |     0    |   1 |   0 |
    | algebraically greater|       |          |     |     |
    | than second          |       |          |     |     |
    |_______________________|________|___________|______|______|
    | first operand is log-|    1  |     0    |   x |   x |
    | ically greater than  |       |          |     |     |
    |_o_r__e_q_u_a_l__t_o__s_e_c_o_n_d_____|________|___________|______|______|
    | first operand is log-|    0  |     0    |   x |   x |
    | ically less than     |       |          |     |     |
    | second               |       |          |     |     |
    |_______________________|________|___________|______|______|

The only difference between the compare logical and compare
instruction is the C-flag setting.  Exactly the same
(signed) arithmetic processing is performed upon the
operands.  Thus, the JG and JL instructions may not give
correct results, based upon the conventional interpretations
of 'compare logical', xFFFFFFF is always less than
x7FFFFFFF.  JC and JNC should be used for jumping in a true
'logical' compare.

3.3.3.5  _C_o_m_p_a_r_e__L_o_g_i_c_a_l__B_y_t_e

A byte, contained in bits 24:32 of the register specified by
the first operand, is compared to the second operand.  Bits
0:23 are assumed to be zero for the comparison.  The result
of the compare is indicated by the condition code setting.
Neither operand is changed.
     __________________________________________
    | Mnemonic|      Instruction     |  Format|
    |___________________|______________________________________________|__________________|_
    |_C_L_B_______|__c_o_m_p_a_r_e__l_o_g_i_c_a_l__b_y_t_e__|__m_e_m_o_r_y__|


Condition code settings are:










Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000042







NAD68 E.R.S.                                 August 27, 1990



     _____________________________________________________________________
    |____________________________c__o__n__d__i__t__i__o__n_______________________________|_____c__a__r__r__y___|_____o__v__e__r__f__l__o__w___|_____>____0___|_____<____0___|_
    | operands are equal                  |    x  |     0    |   0 |   0 |
    |______________________________________|________|___________|______|______|
    |_f_i_r_s_t__o_p_e_r_a_n_d__i_s__l_e_s_s__t_h_a_n__s_e_c_o_n_d_____|____x____|_____0______|___0___|___1___|
    | first operand is greater than second|    x  |     0    |   1 |   0 |
    |______________________________________|________|___________|______|______|

3.3.3.6  _C_o_m_p_a_r_e__A_l_g_e_b_r_a_i_c

The contents of the register specified by the first operand
are compared algebraically to the second operand.  The
result is indicated by the condition code.  The c-flag has
no significance.  Neither operand is changed.  Positive
numbers are always greater than negative numbers.  The
results of a compare algebraic will differ from the results
of a compare logical when an overflow condition would have
occurred on a subtraction of the operands.
     ___________________________________________________
    | Mnemonic|         Instruction        |   Format  |
    |___________________|__________________________________________________________|________________________|_
    |_C_________|__c_o_m_p_a_r_e_____________________|__m_e_m_o_r_y_____|
    | CH      |  compare halfword          |  memory   |
    |__________|_____________________________|____________|
    |_C_I________|__c_o_m_p_a_r_e__i_m_m_e_d_i_a_t_e___________|__i_m_m_e_d_i_a_t_e__|
    | CHI     |  compare halfword immediate|  immediate|
    |__________|_____________________________|____________|
    |_C_R________|__c_o_m_p_a_r_e__r_e_g_i_s_t_e_r____________|__r_e_g_i_s_t_e_r___|


Condition code settings are:

     __________________________________________________________________
    |__________________________c__o__n__d__i__t__i__o__n___________________________|_____c__a__r__r__y___|_____o__v__e__r__f__l__o__w___|_____>____0___|_____<____0___|_
    | operands are equal               |    x  |     0    |   0 |   0 |
    |___________________________________|________|___________|______|______|
    |_f_i_r_s_t__o_p_e_r_a_n_d__l_e_s_s__t_h_a_n__s_e_c_o_n_d_____|____x____|_____0______|___0___|___1___|
    | first operand greater than second|    x  |     0    |   1 |   0 |
    |___________________________________|________|___________|______|______|

3.3.3.7  _M_u_l_t_i_p_l_y

The register pair specified by the first operand is multi-
plied by a fullword specified by the second operand.  The
result is stored in the register pair  specified by the
first operand.  Unsigned absolute arithmetic is performed.
If the register specified by the first operand is 15 the
register  pair is 15, 0.






Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000043







NAD68 E.R.S.                                 August 27, 1990



     _________________________________________
    |__M__n__e__m__o__n__i__c___|___________I__n__s__t__r__u__c__t__i__o__n_________|_______F__o__r__m__a__t_____|_
    | M       |  multiply         |  memory  |
    |__________|____________________|___________|
    ||_M_R________||__m_u_l_t_i_p_l_y__r_e_g_i_s_t_e_r__||__r_e_g_i_s_t_e_r__||


Condition code settings  are not affected.

3.3.3.8  _M_u_l_t_i_p_l_y__H_a_l_f_w_o_r_d

The right half of the register specified by the first
operand is multiplied by a 16-bit second operand.  The
result replaces the entire contents of the register speci-
fied by the first operand.

     __________________________________________________
    |__M__n__e__m__o__n__i__c___|___________________I__n__s__t__r__u__c__t__i__o__n___________________|_______F__o__r__m__a__t_____|_
    | MH      |  multiply halfword         |  memory  |
    |__________|_____________________________|___________|
    ||_M_H_R_______||__m_u_l_t_i_p_l_y__h_a_l_f_w_o_r_d__r_e_g_i_s_t_e_r__||__r_e_g_i_s_t_e_r__||


Condition code settings are not affected.

3.3.3.9  _D_i_v_i_d_e

The contents of the register pair specified by the first
operand are divided by a fullword divisor.  The 32-bit
signed remainder replaces the contents of the register
specified by the first operand.  The 32-bit quotient
replaces the contents of the second register in the register
pair.

     _______________________________________
    |__M__n__e__m__o__n__i__c___|_________I__n__s__t__r__u__c__t__i__o__n_______|_______F__o__r__m__a__t_____|_
    | D       |  divide         |  memory  |
    |__________|__________________|___________|
    ||_D_R________||__d_i_v_i_d_e__r_e_g_i_s_t_e_r__||__r_e_g_i_s_t_e_r__||


Condition code settings are not affected.

3.3.3.10  _D_i_v_i_d_e__H_a_l_f_w_o_r_d

The 32-bit contents of the first register of a register pair
specified by the first operand is divided by the 16-bits
specified by the second operand.  The 16-bit remainder is
expanded by propagating the left-most bit and stored in the
register specified by the first operand.  The 16-bit quo-
tient is expanded by propogating the left-most bit and



Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000044







NAD68 E.R.S.                                 August 27, 1990



stored in the second register of the register pair.  If the
register specified by the first operand is 15 the register
pair is 15, 0.

     ________________________________________________
    |__M__n__e__m__o__n__i__c___|_________________I__n__s__t__r__u__c__t__i__o__n_________________|_______F__o__r__m__a__t_____|_
    | DH      |  divide halfword         |  memory  |
    |__________|___________________________|___________|
    ||_D_H_R_______||__d_i_v_i_d_e__h_a_l_f_w_o_r_d__r_e_g_i_s_t_e_r__||__r_e_g_i_s_t_e_r__||


Condition code settings are not affected.

3.3.3.11  _S_h_i_f_t__R_i_g_h_t__A_r_i_t_h_m_e_t_i_c

The contents of the register specified by the first operand
is shifted right by the number of bits specified by the
second operand.  The sign bit remains unchanged and is pro-
pagated right as bits are shifted out of position 31.  Bits
shifted out of position 31 are shifted through the carry
flag.

     _______________________________________________
    |__M__n__e__m__o__n__i__c___|_______________I__n__s__t__r__u__c__t__i__o__n_______________|_______F__o__r__m__a__t_______|_
    | SRA     |  shift right arithmetic|  immediate|
    |__________|_________________________|____________|


The last bit shifted out of position 31 remains in the carry
flag.  Other condition code settings are:
     ___________________________________________________________
    |         condition         |  carry|  overflow|  > 0|  < 0|
    |_______________________________________________________|________________|______________________|____________|____________|_
    |_v_a_l_u_e__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | value is less than zero   |    x  |     0    |   0 |   1 |
    |____________________________|________|___________|______|______|
    |_v_a_l_u_e__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|

3.3.3.12  _L_o_a_d__H_a_l_f_w_o_r_d__R_e_g_i_s_t_e_r

The halfword specified by the second operand is expanded to
a full word by sign extension and replaces the contents of
the register specified by the first operand.

     ____________________________________________________________________
    |__M__n__e__m__o__n__i__c___|_________________________I__n__s__t__r__u__c__t__i__o__n_______________________|_______F__o__r__m__a__t_____|__________________________|_
    | LHR     |  load halfword register         |  register|            |
    |__________|__________________________________|___________|_____________|
    | CHVR    |  convert halfword value register|  register|            |
    |__________|__________________________________|___________|_____________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000045







NAD68 E.R.S.                                 August 27, 1990



    |         |                                 |          |  this is an|
    |         |                                 |          |  obsolete  |
    |         |                                 |          |  mnemonic  |
    |__________|__________________________________|___________|_____________|


Condition code settings are:
     ___________________________________________________________
    |         condition         |  carry|  overflow|  > 0|  < 0|
    |_______________________________________________________|________________|______________________|____________|____________|_
    |_v_a_l_u_e__i_s__z_e_r_o_______________|____x____|_____0______|___0___|___0___|
    | value is less than zero   |    x  |     0    |   0 |   1 |
    |____________________________|________|___________|______|______|
    |_v_a_l_u_e__i_s__g_r_e_a_t_e_r__t_h_a_n__z_e_r_o__|____x____|_____0______|___1___|___0___|

3.3.4  _S_t_a_t_u_s__S_w_i_t_c_h_i_n_g__I_n_s_t_r_u_c_t_i_o_n_s

Only UPSW and SVC are supported by NAD68.

3.3.4.1  _U_P_S_W

The current location counter is replaced.  Any other func-
tion performed on an engine is not performed by the code
generated by NAD68.

     ______________________________________________
    |__M__n__e__m__o__n__i__c___|_________________I__n__s__t__r__u__c__t__i__o__n_________________|_____F__o__r__m__a__t___|_
    | UPSW    |  user program status word|  memory|
    |__________|___________________________|_________|


Condition code settings are not affected.

3.3.4.2  _S_u_p_e_r_v_i_s_o_r__C_a_l_l

A trap is performed to the appropriate  ISIS routine.  The
following SVC calls are supported, see _I_S_I_S - _6_8_K _E_x_t_e_r_n_a_l
_S_p_e_c_i_f_i_c_a_t_i_o_n for detailed information.
     ___________________________________________________________________________________________
    | SVC Type|  Function Code|                             Function                           |
    |___________________|________________________________|__________________________________________________________________________________________________________________________________|_
    |_D_I_S_M_I_S____|________________|__d_i_s_m_i_s_s__p_r_o_c_e_s_s__f_o_r__s_p_e_c_i_f_i_e_d__t_i_m_e______________________________|
    | FASTD   |               |  dismiss process                                               |
    |__________|________________|_________________________________________________________________|
    | IO      | _$_0_0____________|  connect synchronous input                                     |
    |         |  $10          |  connect synchronous output                                    |
    |         | _______________|                                                                |
    |         | _$_2_0____________|  force synchronous output                                      |
    |         |  $90          |  connect SIO channel                                           |
    |__________|________________|_________________________________________________________________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000046







NAD68 E.R.S.                                 August 27, 1990



     ___________________________________________________________________________________________
    ||__S__V__C____T__y__p__e___||_____F__u__n__c__t__i__o__n____C__o__d__e___||___________________________________________________________F__u__n__c__t__i__o__n_________________________________________________________||_
    |         | _______________|                                                                |
    |         | _$_A_0____________|  force SIO input                                               |
    |         |  $B0          |  force SIO output                                              |
    |         | _______________|                                                                |
    |         | _$_C_0____________|  connect new async rings                                       |
    |         |  $8000        |  query I/O status                                              |
    |__________|________________|_________________________________________________________________|
    |_K_._I_N______|________________|__g_e_t__K_I_O__i_n_p_u_t___________________________________________________|
    | K.OUT   |               |  KIO output                                                    |
    |__________|________________|_________________________________________________________________|
    | KIO     | _0______________|  zap circuit                                                   |
    |         |  1            |  return back to Alfred                                         |
    |         | _______________|                                                                |
    |         | _2______________|  get CCT of KIO circuit                                        |
    |         |  3            |  turn KIO echo on                                              |
    |         | _______________|                                                                |
    |         | _4______________|  turn KIO echo off                                             |
    |         |  5            |  send gobbler down KIO circuit                                 |
    |         | _______________|                                                                |
    |         | _8______________|  see if background is running                                  |
    |         |  9            |  see if background in any slot is running                      |
    |         | _______________|                                                                |
    |         | _1_0_____________|  convert and output number to KIO circuit                      |
    |         |  11           |  enable error code for "zapper" received in function 101       |
    |         | _______________|                                                                |
    |         | _1_2_____________|  send yellow ball down KIO circuit                             |
    |         |  14           |  output single character to KIO circuit                        |
    |__________|________________|_________________________________________________________________|
    | SYS     | _0______________|  old restart                                                   |
    |         |  1            |  connect foreground process                                    |
    |         | _______________|                                                                |
    |         | _5______________|  freeze slot                                                   |
    |         |  6            |  thaw slot                                                     |
    |         | _______________|                                                                |
    |         | _7______________|  test freeze                                                   |
    |         |  17           |  set protection for one memory section in calling process      |
    |         | _______________|                                                                |
    |         | _1_8_____________|  set protection for a set of memory sections in calling process|
    |         |  29           |  create user entry in system log (old format)                  |
    |         | _______________|                                                                |
    |         | _3_2_____________|  halt all processes in slot, disconnect devices, zap circuit   |
    |         |  35           |  disconnect a logical unit from the slot                       |
    |         | _______________|                                                                |
    |         | _3_6_____________|  connect new Kernel Host circuit                               |
    |         |  37           |  zap a Kernel Host circuit                                     |
    |         | _______________|                                                                |
    |         | _4_7_____________|  kick the watchfrog time                                       |
    |__________|________________|_________________________________________________________________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000047







NAD68 E.R.S.                                 August 27, 1990



     ___________________________________________________________________________________________
    ||__S__V__C____T__y__p__e___||_____F__u__n__c__t__i__o__n____C__o__d__e___||___________________________________________________________F__u__n__c__t__i__o__n_________________________________________________________||_
    |         |  51           |  execute slot from start; slot must be halted                  |
    |         | _______________|                                                                |
    |         | _5_4_____________|  Set (Rodney) UTC clock                                        |
    |         |  58           |  define a restart address                                      |
    |__________|________________|_________________________________________________________________|

The NAD instruction format is:
     __________________________________________
    | Mnemonic|      Instruction     |  Format|
    |___________________|______________________________________________|__________________|_
    | SVC     |  supervisor          |        |
    |__________|__c_a_l_l___________m_e_m_o_r_y__|_________|


Condition code settings are determined by the ISIS routine.

3.3.5  _S_p_e_c_i_a_l__I_n_s_t_r_u_c_t_i_o_n_s

The following microcoded instruction have been translated by
NAD68.

3.3.5.1  _S_C_A_N

Scan through the SYNC input data looking for data other than
marking state ( all ones).  The register specified by the
second operand is expected to contain the address of the
input ring to scan (100x bytes long).  The first operand is
expected to specify a register pair.  The first register
contains the lead pointer and the second contains the trail-
ing pointer.  A normal return is made if non-marking data is
encountered in the input ring, a skip return if not.  The
instruction stops scanning when the trailing pointer is less
than 10x bytes behind the lead pointer.

NAD68 handles the skip return by returning to the second NAD
instruction following the microcode if only marking data is
encountered.

     ___________________________________
    |__M__n__e__m__o__n__i__c___|_____I__n__s__t__r__u__c__t__i__o__n___|_______F__o__r__m__a__t_____|_
    | SCAN    |  scan       |  register|
    |__________|______________|___________|

3.3.5.2  _A_L_I_G_N

Align gets data from the SYNC input ring, shifts it for
correct alignment, and stores it in the designated buffer
(input sector) for RTD.  Both vertical and diagonal check-
sums are computed in the process.  The register specified by
the first operand contains the start address of the input


Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000048







NAD68 E.R.S.                                 August 27, 1990



ring.  The register specified by the second operand contains
the trailing pointer BEYOND the first word of the input
packet.

The following NAD registers must be set up for the ALIGN
instruction:

     ___________________________________________________________
    |__1___|__c_o_u_n_t__o_f__h_a_l_f_w_o_r_d_s__t_o__m_o_v_e___________________________|
    |  3 |  first halfowrd of input data                       |
    |_____|______________________________________________________|
    |__5___|__v_e_r_t_i_c_a_l__c_h_e_c_k_s_u_m__(_i_n_i_t__t_o__0_)________________________|
    |  7 |  diagonal checksum (init to 0)                      |
    |_____|______________________________________________________|
    |  8 |  address of input sector where data is to be stored.|
    |_____|__a__n_e_g_a_t_i_v_e__n_u_m_b_e_r__c_a_u_s_e_s__n_o__s_t_o_r_e__t_o__t_a_k_e__p_l_a_c_e______|
    | 10d|  alignment shift factor                             |
    |_____|______________________________________________________|

The instruction format is:
     ___________________________________
    | Mnemonic|  Instruction|   Format |
    |___________________|____________________________|______________________|_
    |_A_L_I_G_N_____|__a_l_i_g_n________|__r_e_g_i_s_t_e_r__|

3.3.5.3  _C_K_S_U_M

CKSUM computes the vertical and diagonal checksums for the
designated area (up to 10000x bytes long).  The first
operand specifies a register pair which is initialized to
zero and will contain the vertical and diagonal checksums
respectively.  The first operand specifies a register which
contains the current start address of the data.  Register 0
contains the negative byte count.

After execution, register 0 and the register specified by
the second operand are not guaranteed to contain their ori-
ginal values.

     ___________________________________
    |__M__n__e__m__o__n__i__c___|_____I__n__s__t__r__u__c__t__i__o__n___|_______F__o__r__m__a__t_____|_
    | CKSUM   |  cksum      |  register|
    |__________|______________|___________|

3.3.5.4  _G_C_I_6_8

GCI68 is a NAD68 version of the get character bufferlet
microcode.

The syntax is:

     GCI68 rx,ry,beadr,bbadr,error,next,last


Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000049







NAD68 E.R.S.                                 August 27, 1990



where

     rx      nad register   contains input character upon return
     ry      nad register   contains buffer number times 4
     beadr   address        BE storage
     bbadr   address        BB storage
     error   address        routine to handle error returns
     next    address        routine to handle freeing of bufferlets
     last    address        routine to handle emptying of buffer

3.3.5.5  _W_C_I_6_8

WCI68 is a NAD68 version of the write character bufferlet
microcode.

The syntax is:

     WCI68 rx,ry,beadr,bbadr,error,next,last

where

     rx      nad register   contains output character to write
     ry      nad register   contains buffer number times 4
     beadr   address        BE storage
     bbadr   address        BB storage
     error   address        routine to handle error returns
     next    address        routine to handle freeing of bufferlets
     last    address        routine to handle emptying of buffer

3.3.5.6  _C_B_C_T_6_8

CBCT68 is a NAD68 version of the microcode which computes
the exact size of a buffer.

The syntax is:

     CBCT68 rx,ry,bbadr,nbuf

where

     rx      nad register   contains exact size of buffer upon return
     ry      nad register   contains buffer number times 4
     bbadr   address        BB storage
     nbuf    integer        size of BB

3.3.5.7  _A_N_D_6_8_L

Full-word ARAND.  This directive is avaiable in version 2 of
NAD68.

The syntax of the directive:



Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000050







NAD68 E.R.S.                                 August 27, 1990



     AND68L              Ra,Rc,Haddr

where

Ra      nad register   (Ra), (Ra+1) = LAST LONG ADDRESS
Rc      nad register   (Rc) =  NUMBER of bits, bit# -> Rc
Haddr   address        success-transfer address


If successful, returns bit-number, transfers to Haddr; if
fails, falls through to next instruction. In no case are the
pointer-registers updated.

3.3.5.8  _R_M_K_6_8__a_n_d__R_T_D_6_8

These two directives are avaiable in version 2 of NAD68.
RMK68 and RTD68 are slightly different from the Engine
implementation:

  1.  There is a SINGLE entry-point (rather than 2) -- if
      the end-of-bufferlet (Next) trap exit is taken, the
      TRAP ROUTINE is responsible for detecting if the last
      character should be handled as an exception-character
      trap.

  2.  If Nmsk is set to -1, end-of-bufferlet will never
      occur.

  3.  There is a SINGLE character-trap address (rather than
      4) -- The TRAP ROUTINE is responsible for "CASE"-ing
      the character.

  4.  Since Tch specifies the HIGHEST character-code to trap
      upon, using the value -1 will cause it to NEVER trap.

  5.  Unlike the Engine, characters are copied one-by-one,
      and placed into the destination before trapping.

  6.  While faster than the translated implementation, sig-
      nificant wait-states may be encountered if copying
      across the VME buss.


3.3.5.8.1  _R_T_D_6_8

RTD68 emulates the Engine RTDcopy command.  Expects (R3) =
(BB); (R12) = pointer to NEXT char to place.  This version
permits specification of bufferlet-length (to trap at end-
of-bflt) and specification of characters to trap on 0 <=
char <Tch. EOB Trap does not save character (i.e., char is
not "moved", just "removed"). Exits with condition codes



Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000051







NAD68 E.R.S.                                 August 27, 1990



reflecting last character moved.

The syntax of the directive:

     RTD68               Rch,Rct,Nmsk,Naddr,Tch,Taddr

where

Rch     nad register   register to hold char
Rct     nad register   register with count of chars
Nmsk    value          when to take Next exit
Naddr   address        Next BFLT trap code
Tch     value          trap character code
Taddr   address        trap address



3.3.6  _R_M_K_6_8

RMK68 emulates Engine RMKcopy command.  Expects (R3) = (BB);
(R12) = pointer to LAST char.  This version permits specifi-
cation of bufferlet-length (to trap at end-of-bflt) and
specification of characters to trap on 0 <= char <Tch.
Exits with condition codes reflecting last character moved.

The syntax of the directive:

     RMK68               Rch,Rct,Nmsk,Naddr,Tch,Taddr

where

Rch     nad register   register to hold char
Rct     nad register   register with count of chars
Nmsk    value          when to take Next exit
Naddr   address        Next BFLT trap code
Tch     value          trap character code
Taddr   address        trap address



3.4  NAD68 To 68020 Translation

NAD68 statements are translated to 68020 instructions.  A
single statement may produce many 68020 instructions.  In
this way, NAD68 is similar to a compiler.  The following
table describes the 68020 instructions which are generate
for each Engine instruction and the final setting of the
condition codes after executing the 68020 sequence.  If the
optimizer is invoked the 68020 instruction sequence will
vary.




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000052







NAD68 E.R.S.                                 August 27, 1990



If an instruction contains a forward reference, the largest
format is utilized.

The symbols Ax, Ay, and Az are used to specify any address
register.  The term Dx, Dy, and Dz is used to specify any
data register.  The symbols 4x, 4y, and 4z indicate multi-
ples of four.  Generally the suffix x is used for the first
NAD register specified, the suffix y is used fo rthe second,
and the suffix z is used for the third.  They are generally
used with A5 to specify an area of memory  which represents
engine registers.  Address mode setup indicates the actual
code will depend on the addressing mode of the NAD instruc-
tion.

_____________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n___________||_
|L              |               |  address mode setup       |
|               |               |  move.l  addr,4x(A5)      |
_|________________|________________|____________________________|
|LH             |               |  address mode setup       |
|               |               |  move.w  addr,A1          |
_|________________|________________|__m_o_v_e_._l___A_1_,_4_x_(_A_5_)__________|
|LIS            |               |  move.l  #val,4x(A5)      |
|LHI            |               |                           |
|LI             |               |                           |
_|________________|________________|____________________________|
_|L_C_S______________|________________|__m_o_v_e_._l___#_-_v_a_l_,_4_x_(_A_5_)_______|
|LR             |               |  move.l  4y(A5),4x(A5)    |
_|________________|________________|____________________________|
|LA             |               |  address mode setup       |
|               |               |  lea                      |
_|________________|________________|__m_o_v_e_._l___A_0_,_4_x_(_A_5_)__________|
|LHL            |               |  address mode setup       |
|               |               |  moveq.l  #0,D4           |
|               |               |  move.w  addr,D4          |
|               |               |  move.l  D4,4x(A5)        |
_|________________|________________|____________________________|
|LM             |  r>7          |  address mode setup       |
|               |               |  movem.l addr,Dx-D7       |
_|________________|________________|__m_o_v_e_m_._L___D_x_-_D_7_,_4_x_(_A_5_)______|
|LM             |  r<8          |  address mode setup       |
|               |               |  movem.l  addr,D0-D7      |
|               |               |  movem.l  D0-D7,4x(A5)    |
|               |               |  movem.l  addr+32,Dx-D7   |
|               |               |  movem.l  Dx-D7,4x+32(A5) |
_|________________|________________|____________________________|
|LB             |               |  address mode setup       |
|               |               |  moveq.l  #0,D4           |
|               |               |  move.b  addr,D4          |
_|________________|________________|__m_o_v_e_._l___D_4_,_4_x_(_A_5_)__________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000053







NAD68 E.R.S.                                 August 27, 1990



_____________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n___________||_
_|________________|________________|____________________________|
|LBR            |               |  move.l  #0,D4            |
|               |               |  move.b  4y+3(A5),D4      |
_|________________|________________|__m_o_v_e_._l___D_4_,_4_x_(_A_5_)__________|
|LHR            |               |  move.w  4y+2(A5),A0      |
|               |               |  move.l  A0,4x(A5)        |
_|________________|________________|____________________________|
|EXHR           |               |  move.l  4y+2(A5),D4      |
|               |               |  swap    D4               |
_|________________|________________|__m_o_v_e_._l___D_4_,_4_x_+_2_(_A_5_)________|
|EXBR           |               |  move.l  4y(A5),D4        |
|               |               |  ror.w   #8,D4            |
|               |               |  move.l  D4,4x(A5)        |
|               |               |  tst.l   4x(A5)           |
_|________________|________________|____________________________|
|ST             |               |  address mode setup       |
|               |               |  move.l  4x(A5),A1        |
_|________________|________________|__m_o_v_e_m_._l__A_1_,_a_d_d_r____________|
|STH            |               |  address mode setup       |
|               |               |  move.w  4x+2(A5),A1      |
|               |               |  movem.w A1,addr          |
_|________________|________________|____________________________|
|STM            |  [r>7]        |  address mode setup       |
|               |               |  movem.l  4x(A5),D(x-8)-D7|
_|________________|________________|__m_o_v_e_m_._l___D_(_x_-_8_)_-_D_7_,_a_d_d_r____|
|STM            |  [R<8]        |  address mode setup       |
|               |               |  movem.l  4x(A5),D0-D7    |
|               |               |  movem.l  D0-D7,addr      |
|               |               |  movem.l  4x+32(A5),Dx-D7 |
|               |               |  movem.l  Dx-D7,addr+32   |
_|________________|________________|____________________________|
|STB            |               |  address mode setup       |
|               |               |  move  CCR,D4             |
|               |               |  move.b  4x+3(A5),addr    |
_|________________|________________|__m_o_v_e___D_4_,_C_C_R_______________|
|STBR           |               |  move.b  4x+3(A5),4y+3(A5)|
|               |               |  tst.l  4y(A5)            |
_|________________|________________|____________________________|
|COPY           |               |  move.l  4x(A5),A0        |
|               |               |  addq.l  #$2,A0           |
|               |               |  move.l  4x+4(A5),A1      |
|               |               |  addq.l  #$2,A1           |
|               |               |  move.l  4y(A5),D4        |
|               |               |  lsr.l   #$4,D4           |
|               |               |  LL:                      |
|               |               |  move.w  -(A0),-(A1)      |
|               |               |  dbf     D4,LL            |
_|________________|________________|__a_d_d_q_._l___#_$_2_,_A_0_____________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000054







NAD68 E.R.S.                                 August 27, 1990



_____________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n___________||_
|               |               |  move.l  A0,4x(A5)        |
|               |               |  move.l  A1,4x+4(A5)      |
_|________________|________________|____________________________|
|N              |               |  address mode setup       |
|O              |               |  move.l  addr,D4          |
|X              |               |  op.l    D4,4x(A5)        |
_|A________________|________________|____________________________|
|NH             |               |  address mode setup       |
|OH             |               |  move.w  addr,A0          |
|XH             |               |  move.l  A0,D4            |
|AH             |               |  op.L    D4,4x(A5)        |
_|________________|________________|____________________________|
|AIS            |  [0<val<9]    |  addq.l  #val,4x(A5)      |
|AHI            |  NO INDEX     |                           |
_|A_I_______________|________________|____________________________|
|AIS            |  [|val| < 128]|  moveq.l  #val,D4         |
|NHI            |  NO INDEX     |  op.l  D4,4x(A5)          |
|OHI            |               |                           |
|XHI            |               |                           |
|AHI            |               |                           |
|NI             |               |                           |
|OI             |               |                           |
|XI             |               |                           |
|AI             |               |                           |
_|________________|________________|____________________________|
|AIS            |  [|val| < 128]|  moveq.l  #val,D4         |
|NHI            |  INDEXED      |  add.l  4y(A5),D4         |
|OHI            |               |  op.l  D4,4x(A5)          |
|XHI            |               |                           |
|AHI            |               |                           |
|NI             |               |                           |
|OI             |               |                           |
|XI             |               |                           |
_|A_I_______________|________________|____________________________|
|AIS            |  [|val| > 127]|  op.l #val,4x(A5)         |
|NHI            |  NO INDEX     |                           |
|OHI            |               |                           |
|XHI            |               |                           |
|AHI            |               |                           |
|NI             |               |                           |
|OI             |               |                           |
|XI             |               |                           |
|AI             |               |                           |
_|________________|________________|____________________________|
|AIS            |  [|val| > 127]|  move.l  #val,D4          |
|NHI            |  INDEXED      |  add.l  4y(A5),D4         |
|OHI            |               |  op.l  D4,4x(A5)          |
_|X_H_I______________|________________|____________________________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000055







NAD68 E.R.S.                                 August 27, 1990



_____________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n___________||_
|AHI            |               |                           |
|NI             |               |                           |
|OI             |               |                           |
|XI             |               |                           |
|AI             |               |                           |
_|________________|________________|____________________________|
|NR             |               |  move.l  4y(A5),D4        |
|OR             |               |  op.l   D4,4x(A5)         |
|XR             |               |                           |
_|A_R_______________|________________|____________________________|
|AM             |               |  address mode setup       |
|               |               |  move.l  4x(A5),D4        |
|               |               |  add.l  D4,addr           |
_|________________|________________|____________________________|
|AHM            |               |  address mode setup       |
|               |               |  move.w  addr,D4          |
|               |               |  LL:  move.l  D4,D5       |
|               |               |  ext.l   D5               |
|               |               |  add.l  4x(A5),D5         |
|               |               |  cas.w  D4,D5,addr        |
|               |               |  bne.b  LL:               |
_|________________|________________|__t_s_t_._l___D_5__________________|
|S              |               |  address mode setup       |
|               |               |  move.l  addr,D4          |
|               |               |  neg.l  D4                |
|               |               |  add.l  D4,4x(A5)         |
_|________________|________________|____________________________|
|SH             |               |  address mode setup       |
|               |               |  move.w addr,A0           |
|               |               |  move.l  A0,D4            |
|               |               |  neg.l  D4                |
_|________________|________________|__a_d_d_._l___D_4_,_4_x_(_A_5_)___________|
|SIS            |  [0<val<9]    |  addq.l  #-val,4x(A5)     |
|SHI            |  NO INDEX     |                           |
|SI             |               |                           |
_|________________|________________|____________________________|
|SIS            |  [|val|<128]  |  moveq.l  #-val,D4        |
|SHI            |  NO INDEX     |  add.l   D4,4x(A5)        |
_|S_I_______________|________________|____________________________|
|SIS            |  [|val|<128]  |  moveq.l  #-val,D4        |
|SHI            |  INDEXED      |  sub.l 4y(A5)             |
|SI             |               |  add.l D4,4x(A5)          |
_|________________|________________|____________________________|
|SHI            |  [|val|>127]  |  add.l  #-val,4x(A5)      |
_|S_I_______________|__N_O__I_N_D_E_X_______|____________________________|
|SHI            |  [|val|>127]  |  move.l  #-val,D4         |
|SI             |  INDEXED      |  sub.l   4y(A5),D4        |
_|________________|________________|____________________________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000056







NAD68 E.R.S.                                 August 27, 1990



_____________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n___________||_
|               |               |  add.l   D4,4x(A5)        |
_|________________|________________|____________________________|
|SR             |               |  move.l  4y(A5),D4        |
|               |               |  neg.l  D4                |
_|________________|________________|__a_d_d_._l___D_4_,_4_x_(_A_5_)___________|
|CL             |               |  address mode setup       |
|               |               |  move.l  4x(A5),D4        |
|               |               |  mov.l  addr,D5           |
|               |               |  neg.l  D5                |
|               |               |  add.l  D4,D5             |
_|________________|________________|____________________________|
|CLH            |               |  address mode setup       |
|               |               |  move.l 4x(A5)D4,         |
|               |               |  sub.l  A1,A1             |
|               |               |  sub.w  addr,D4           |
_|________________|________________|__a_d_d_._l___A_1_,_D_4_______________|
|CLHI           |  [0<val<9]    |  move.l  4x(A5),D4        |
|CLI            |               |  addq.l  #-val,D4         |
_|________________|________________|____________________________|
|CLHI           |  [val>= 0 or va|l<=m-o9v]e.l  4x(A5),D4        |
_|C_L_I______________|________________|__a_d_d_._l___#_-_v_a_l_,_D_4____________|
|CLHI           |  [|val| < 128]|  moveq.l  #-val,D4        |
|CLI            |  INDEXED      |  sub.l  4y(A5),D4         |
|               |               |  move.l  4x(A5),D5        |
|               |               |  add.l  D4,D5             |
_|________________|________________|____________________________|
|CLHI           |  [|val| > 127]|  move.l  #-val,D4         |
|CLI            |  INDEXED      |  sub.l  4y(A5),D4         |
|               |               |  move.l  4x(A5),D5        |
_|________________|________________|__a_d_d_._l___D_4_,_D_5_______________|
|CLR            |               |  move.l  4x(A5),D4        |
|               |               |  move.l  4y(A5),D5        |
|               |               |  neg.l  D5                |
|               |               |  add.l  D5,D4             |
_|________________|________________|____________________________|
|CLB            |               |  address mode setup       |
|               |               |  moveq.l  #0,D4           |
|               |               |  move.b 4x+3(A5),D4       |
|               |               |  moveq.l  #0,D5           |
|               |               |  move.b addr,D5           |
_|________________|________________|__c_m_p_._w___D_5_,_D_4_______________|
|C              |               |  address mode setup       |
|               |               |  move.l  4x(A5),D4        |
|               |               |  cmp.l  addr,D4           |
|               |               |  bvc.b L:                 |
|               |               |  eori  #$8,CCR            |
|               |               |  L:                       |
_|________________|________________|____________________________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000057







NAD68 E.R.S.                                 August 27, 1990



_____________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n___________||_
_|________________|________________|____________________________|
|CH             |               |  address mode setup       |
|               |               |  move.l  4x(A5),A1        |
|               |               |  cmp.w  addr,A1           |
|               |               |  bvc.b L:                 |
|               |               |  eori  #$8,CCR            |
_|________________|________________|__L_:_________________________|
|CHI            |  [0<val<9]    |  move.l  4x(A5),D4        |
|CI             |  NO INDEX     |  subq.l  #val,D4          |
|               |               |  bvc.b L:                 |
|               |               |  eori  #$8,CCR            |
|               |               |  L:                       |
_|________________|________________|____________________________|
|CHI            |  [val<0 or val>|8]cmp.l  #val,4x(A5)       |
|CI             |  NO INDEX     |  bvc.b  L:                |
|               |               |  eori  #$8,CCR            |
_|________________|________________|__L_:_________________________|
|CHI            |  [|val| < 128]|  moveq.l  #val,D4         |
|CI             |  INDEXED      |  add.l  4y(A5),D4         |
|               |               |  move.l  4x(A5),D5        |
|               |               |  cmp.l  D4,D5             |
|               |               |  bvc.b  LL:               |
|               |               |  eori  #$8,CCR            |
|               |               |  LL:                      |
_|________________|________________|____________________________|
|CHI            |  [|val| > 127]|  move.l  #val,D4          |
|CI             |  INDEXED      |  add.l  4y(A5),D4         |
|               |               |  move.l  4x(A5),D5        |
|               |               |  cmp.l  D4,D5             |
|               |               |  bvc.b  L:                |
|               |               |  eori  #$8,CCR            |
_|________________|________________|__L_:_________________________|
|CR             |               |  move.l  4x(A5),D4        |
|               |               |  cmp.l  4y(A5),D4         |
|               |               |  bvc.b L:                 |
|               |               |  eori  #$8,CCR            |
|               |               |  L:                       |
_|________________|________________|____________________________|
|THI            |  [|val|<128]  |  moveq.l  #val,D4         |
_|T_I_______________|__N_O__I_N_D_E_X_______|__a_n_d_._l___4_x_(_A_5_)_,_D_4___________|
|THI            |  [|val|<128]  |  moveq.l  #val,D4         |
|TI             |  INDEXED      |  add.l  4y(A5),D4         |
|               |               |  and.l  4x(A5),D4         |
_|________________|________________|____________________________|
|THI            |  [|val|>127]  |  move.l  #val,D4          |
_|T_I_______________|__N_O__I_N_D_E_X_______|__a_n_d_._l___4_x_(_A_5_)_,_D_4___________|
|THI            |  [|val|>127]  |  move.l  #val,D4          |
_|________________|________________|____________________________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000058







NAD68 E.R.S.                                 August 27, 1990



_____________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n___________||_
|TI             |  INDEXED      |  add.l 4y(A5),D4          |
|               |               |  and.l  4x(A5),D4         |
_|________________|________________|____________________________|
|ARAND          |               |  move.l  4x(A5),A0        |
|               |               |  addq.l  #2,A0            |
|               |               |  move.l  4x+4(A5),A1      |
|               |               |  addq.l  #2,A1            |
|               |               |  move.l  4y(A5),D4        |
|               |               |  lsr.l  #4,D4             |
|               |               |  L: move.w  -(A0),D5      |
|               |               |  and.w  -(A1),D5          |
|               |               |  bffo  D5{16:16},D6       |
|               |               |  dbne  D4,L:              |
|               |               |  lsl.l  #4,D4             |
|               |               |  or.l  D6,D4              |
|               |               |  ext.l  D4                |
|               |               |  move.l  A0,4x(A5)        |
|               |               |  move.l  A1,4x+4(A5)      |
|               |               |  move.l  D4,4y(A5)        |
_|________________|________________|__b_m_i_._b___s_k_i_p__2__N_A_D__b_y_t_e_s____|
|M              |               |  address mode setup       |
|               |               |  move  CRR,D4             |
|               |               |  move.l  4x+4(A5),D6      |
|               |               |  mulu.l addr,D5:D6        |
|               |               |  move.l D5,4x(A5)         |
|               |               |  move.l D6,4x+4(A5)       |
|               |               |  move D4,CCR              |
_|________________|________________|____________________________|
|MR             |               |  move  CCR,D4             |
|               |               |  move.l 4x+4(A5),D6       |
|               |               |  mulu.l 4y(A5),D5:D6      |
|               |               |  move.l  D5,4x(A5)        |
|               |               |  move.l  D6,4x+4(A5)      |
_|________________|________________|__m_o_v_e__D_4_,_C_C_R________________|
|MH             |               |  address mode setup       |
|               |               |  move  CCR,D4             |
|               |               |  move.w  4x+2(A5),D5      |
|               |               |  mulu.w  addr,D5          |
|               |               |  move.l  D5,4x(A5)        |
|               |               |  move  D4,CCR             |
_|________________|________________|____________________________|
|MHR            |               |  move CCR,D4              |
|               |               |  move.w 4x+2(A5),D5       |
|               |               |  mulu.w  4y+2(A5),D5      |
|               |               |  move.l  D5,4x(A5)        |
_|________________|________________|__m_o_v_e___D_4_,_C_C_R_______________|






Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000059







NAD68 E.R.S.                                 August 27, 1990



_____________________________________________________________
 Nad Instruction   Restrictions        68020 Instruction
__________________________________________________________________________________________________________________________

||

                                                            ||















































Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000060







NAD68 E.R.S.                                 August 27, 1990



_______________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n__________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n_____________||_
|D              |                |  address mode setup        |
|               |                |  move  CCR,D4              |
|               |                |  tst.l   addr              |
|               |                |  beq.b   L:                |
|               |                |  move.l  4x(A5),D5         |
|               |                |  move.l  4x+4(A5),D6       |
|               |                |  divu.l  addr,D5:D6        |
|               |                |  move.l  D5,4x(A5)         |
|               |                |  move.l  D6,4x+4(A5)       |
|               |                |  L:                        |
|               |                |  move  D4,CCR              |
_|________________|_________________|_____________________________|
|DR             |                |  move  CCR,D4              |
|               |                |  tst.l   4y(A5)            |
|               |                |  beq.b   L:                |
|               |                |  move.l  4x(A5),D5         |
|               |                |  move.l 4x+4(A5),D6        |
|               |                |  divu.l  4y(A5),D5:D6      |
|               |                |  move.l  D5,4x(A5)         |
|               |                |  move.l  D6,4x+4(A5)       |
|               |                |  L:                        |
_|________________|_________________|__m_o_v_e__D_4_,_C_C_R_________________|
|DH             |                |  address mode setup        |
|               |                |  move  CCR,D4              |
|               |                |  tst.l   addr              |
|               |                |  beq.b   L:                |
|               |                |  move.l  4x(A5),D5         |
|               |                |  divu.l  addr,D5           |
|               |                |  clr.l  D6                 |
|               |                |  move.w  D5,D6             |
|               |                |  clr.w  D5                 |
|               |                |  swap  D5                  |
|               |                |  move.l  D5,4x(A5)         |
|               |                |  move.l  D6,4x+4(A5)       |
|               |                |  L:                        |
|               |                |  move  D4,CCR              |
_|________________|_________________|_____________________________|
|DHR            |                |  move CCR,D4               |
|               |                |  tst.w   4y+2(A5)          |
|               |                |  beq.b   L:                |
|               |                |  move.l  4x(A5),D5         |
|               |                |  divu.w 4y+2(A5),D5        |
|               |                |  clr.l  D6                 |
|               |                |  move.w  D5,D6             |
|               |                |  clr.w  D5                 |
|               |                |  swap  D5                  |
|               |                |  move.l  D5,4x(A5)         |
_|________________|_________________|__m_o_v_e_._l___D_6_,_4_x_+_4_(_A_5_)_________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000061







NAD68 E.R.S.                                 August 27, 1990



_______________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n__________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n_____________||_
|               |                |  L:                        |
|               |                |  move  D4,CCR              |
_|________________|_________________|_____________________________|
|SLLS           |  [val<9]       |  move.l  4x(A5),D4         |
|SRLS           |                |  op.L  #val,D4             |
_|________________|_________________|__m_o_v_e_m_._l___D_4_,_4_x_(_A_5_)__________|
|SLLS           |  [val>8]       |  move.l  4x(A5),D4         |
|SRLS           |                |  moveq.l  #val,D5          |
|               |                |  op.l D5,D4                |
|               |                |  movem.l D4,4x(A5)         |
_|________________|_________________|_____________________________|
|SLL            |                |  address mode setup into D5|
|SRL            |                |  move.l  4x(A5),D4         |
|RLL            |                |  op.l    D5,D4             |
|RRL            |                |  movem.l D4,4x(A5)         |
_|S_R_A______________|_________________|_____________________________|
|SLHLS          |  [val<9]       |  move.w  4x+2(A5),D4       |
|SRHLS          |                |  op.w  #val,D4             |
|               |                |  movem.w  D4,4x+2(A5)      |
_|________________|_________________|_____________________________|
|SLHLS          |  [val>8]       |  move.w  4x+2(A5),D4       |
|SRHLS          |                |  moveq.l  #val,D5          |
|               |                |  op.w  D5,D4               |
_|________________|_________________|__m_o_v_e_m_._w__D_4_,_4_x_+_2_(_A_5_)_________|
|SLHL           |                |  address mode setup into D5|
|SRHL           |                |  move.w  4x+2(A5),D4       |
|               |                |  op.w  D5,D4               |
|               |                |  movem.w  D4,4x+2(A5)      |
_|________________|_________________|_____________________________|
|TS             |                |  address mode setup        |
_|________________|_________________|__b_f_s_e_t___a_d_d_r_{_0_:_3_2_}___________|
|TBT            |                |  address mode setup        |
|SBT            |                |  move.l  4x(A5),D4         |
|RBT            |                |  bpop  addr{D4:1}          |
|CBT            |                |  andi  #$4,CCR             |
_|________________|_________________|_____________________________|
|NOP            |                |  nop                       |
_|N_O_P_R_____________|_________________|_____________________________|
|JFS            |  NO INDEX      |  bra  addr                 |
|JBS            |                |                            |
|J              |                |                            |
_|________________|_________________|_____________________________|
|J              |  INDEXED       |  address mode setup        |
_|________________|_________________|__j_m_p___a_d_d_r___________________|
|JR             |                |  move.l  4x(A5),A0         |
|               |                |  jmp  (A0)                 |
_|________________|_________________|_____________________________|
_|J_E_F_S_____________|__N_O__I_N_D_E_X________|__b_c_c_._b___a_d_d_r_________________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000062







NAD68 E.R.S.                                 August 27, 1990



_______________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n__________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n_____________||_
|JEBS           |  |addr-.|<128  |                            |
|JE             |                |                            |
|JN             |                |                            |
|JNFS           |                |                            |
|JNBS           |                |                            |
|JGEFS          |                |                            |
|JGEBS          |                |                            |
|JGE            |                |                            |
|JLFS           |                |                            |
|JLBS           |                |                            |
|JL             |                |                            |
|JCFS           |                |                            |
|JCBS           |                |                            |
|JC             |                |                            |
|JNCFS          |                |                            |
|JNCBS          |                |                            |
|JNC            |                |                            |
_|________________|_________________|_____________________________|
|JE             |  NO INDEX      |  bcc.w  addr               |
|JN             |  |addr-*| < 32K|                            |
|JGE            |                |                            |
|JL             |                |                            |
|JC             |                |                            |
_|J_N_C______________|_________________|_____________________________|
|JE             |  NO INDEX      |  bcc.l  addr               |
|JN             |  |addr-*| > 32K|                            |
|JGE            |                |                            |
|JL             |                |                            |
|JC             |                |                            |
|JNC            |                |                            |
_|________________|_________________|_____________________________|
|JE             |  INDEXED       |  bcco.b  L:                |
|JN             |                |  address mode setup        |
|JGE            |                |  jmp  addr                 |
|JL             |                |  L:                        |
|JC             |                |                            |
_|J_N_C______________|_________________|_____________________________|
|JER            |                |  bcco.b  L:                |
|JNR            |                |  move.l  4x(A5),A0         |
|JGER           |                |  jmp  (A0)                 |
|JLR            |                |  L:                        |
|JCR            |                |                            |
|JNCR           |                |                            |
_|________________|_________________|_____________________________|
|JGFS           |  NO INDEX      |  bmi.b  L:                 |
|JGBS           |                |  bne  addr                 |
_|J_G_______________|_________________|__L_:__________________________|
_|________________|_________________|_____________________________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000063







NAD68 E.R.S.                                 August 27, 1990



_______________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n__________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n_____________||_
|JG             |  INDEXED       |  bmi.b  L:                 |
|               |                |  beq.b  L:                 |
|               |                |  address mode setup        |
|               |                |  jmp  addr                 |
|               |                |  L:                        |
_|________________|_________________|_____________________________|
|JGR            |                |  bmi.b  L:                 |
|               |                |  beq.b  L:                 |
|               |                |  move.l  4x(A5),A0         |
|               |                |  jmp  (A0)                 |
_|________________|_________________|__L_:__________________________|
|JLEFS          |  NO INDEX      |  bmi  addr                 |
|JLEBS          |                |  beq  addr                 |
|JLS            |                |                            |
|JLE            |                |                            |
_|________________|_________________|_____________________________|
|JLE            |  INDEXED       |  bmi.b  L:                 |
|               |                |  bne.b  M:                 |
|               |                |  L:  address mode setup    |
|               |                |  jmp  addr                 |
_|________________|_________________|__M_:__________________________|
|JLER           |                |  bmi.b  L:                 |
|               |                |  bne.b  M:                 |
|               |                |  L:  move.l 4x(A5),A0      |
|               |                |  jmp  (A0)                 |
|               |                |  M:                        |
_|________________|_________________|_____________________________|
|JAL            |  NO INDEX      |  lea  L:-*(PC),A0          |
|               |                |  movem.l  A0,4x(A5)        |
|               |                |  bra  addr                 |
_|________________|_________________|__L_:__________________________|
|JAL            |  INDEXED       |  address mode setup        |
|               |                |  lea  L:-*(PC),A1          |
|               |                |  movem.l  A1,4x(A5)        |
|               |                |  jump addr                 |
|               |                |  L:                        |
_|________________|_________________|_____________________________|
|JALR           |                |  move.l  4y(A5),A0         |
|               |                |  lea  L:-*(PC),A1          |
|               |                |  movem.l  A1,4x(A5)        |
|               |                |  jmp  (A0)                 |
_|________________|_________________|__L_:__________________________|
|JFFO           |                |  bfffo  4x(A5){0:32},D5    |
|               |                |  beq.b  L:                 |
|               |                |  move.l  D5,4x+4(A5)       |
|               |                |  bra.b  addr               |
|               |                |  L:                        |
_|________________|_________________|_____________________________|
_|J_F_F_O_H____________|_________________|__b_f_f_f_o___4_x_+_2_(_A_5_)_{_0_:_1_6_}_,_D_5____|



Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000064







NAD68 E.R.S.                                 August 27, 1990



_______________________________________________________________
_||_N__a__d____I__n__s__t__r__u__c__t__i__o__n__________R__e__s__t__r__i__c__t__i__o__n__s__________________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n_____________||_
|               |                |  beq.b  L:                 |
|               |                |  move.l  D5,4x+4(A5)       |
|               |                |  bra.b  addr               |
|               |                |  L:                        |
_|________________|_________________|_____________________________|
|UPSW           |                |  address mode setup        |
|               |                |  move.l  addr+4,A0         |
_|________________|_________________|__j_m_p___(_A_0_)___________________|
|SVC            |                |  T{                        |
|as specified in|ISIS-68K External| Spec                       |
|T}             |                |                            |
_|________________|_________________|_____________________________|








































Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000065







NAD68 E.R.S.                                 August 27, 1990



____________________________________________________________
_||___N__a__d____I__n__s__t__r__u__c__t__i__o__n______________R__e__s__t__r__i__c__t__i__o__n__s______________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n_____||_
| AND68L           |                 |   MOVEA.L           |
|                  |                 |   ADDQ.L            |
|                  |                 |   MOVEA.L           |
|                  |                 |   ADDQ.L            |
|                  |                 |   MOVE.L            |
|                  |                 |   LSR.W             |
|                  |                 |   _loop:            |
|                  |                 |   MOVE.L            |
|                  |                 |   AND.L             |
|                  |                 |   DBNE              |
|                  |                 |   BEQ.B             |
|                  |                 |   LSL.W             |
|                  |                 |   BFFFO             |
|                  |                 |   OR.B              |
|                  |                 |   MOVE.L            |
|                  |                 |   BRA.L             |
|                  |                 |   _end:             |
_|___________________|__________________|______________________|
| RTD68            |                 |   MOVEA.L           |
|                  |                 |   ADDQ.L            |
|                  |                 |   MOVEA.L           |
|                  |                 |   MOVE.L            |
|                  |                 |   SUBQ.L            |
|                  |                 |   MOVEQ.L           |
|                  |                 |   _loop:            |
|                  |                 |   MOVE.B            |
|                  |                 |   MOVE.W            |
|                  |                 |   AND.L             |
|                  |                 |   BEQ.B             |
|                  |                 |   MOVE.B            |
|                  |                 |   CMP.W             |
|                  |                 |   BLE.B             |
|                  |                 |   DBF               |
|                  |                 |   LEA.L             |
|                  |                 |   BRA.B             |
|                  |                 |   _x1:              |
|                  |                 |   LEA.L             |
|                  |                 |   BRA.B             |
|                  |                 |   _x2:              |
|                  |                 |   LEA.L             |
|                  |                 |   _exit:            |
|                  |                 |   SUBQ.L            |
|                  |                 |   _exit1:           |
|                  |                 |   MOVE.L            |
|                  |                 |   ADDQ.L            |
|                  |                 |   MOVE.L            |
|                  |                 |   MOVE.L            |
_|___________________|__________________|___M_O_V_E_._L______________|




Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000066







NAD68 E.R.S.                                 August 27, 1990



____________________________________________________________
_||___N__a__d____I__n__s__t__r__u__c__t__i__o__n______________R__e__s__t__r__i__c__t__i__o__n__s______________6__8__0__2__0____I__n__s__t__r__u__c__t__i__o__n_____||_
|                  |                 |   JSR               |
|                  |                 |   _done:            |
_|___________________|__________________|______________________|
| RMK68            |                 |   MOVEA.L           |
|                  |                 |   MOVEA.L           |
|                  |                 |   ADDQ.L            |
|                  |                 |   MOVE.L            |
|                  |                 |   SUBQ.L            |
|                  |                 |   MOVEQ.L           |
|                  |                 |   _loop:            |
|                  |                 |   MOVE.B            |
|                  |                 |   MOVE.B            |
|                  |                 |   MOVE.W            |
|                  |                 |   AND.L             |
|                  |                 |   BEQ.B             |
|                  |                 |   CMP.W             |
|                  |                 |   BLE.B             |
|                  |                 |   DBF               |
|                  |                 |   LEA.L             |
|                  |                 |   BRA.B             |
|                  |                 |   _x1:              |
|                  |                 |   LEA.L             |
|                  |                 |   BRA.B             |
|                  |                 |   _x2:              |
|                  |                 |   LEA.L             |
|                  |                 |   _exit:            |
|                  |                 |   ADDQ.L            |
|                  |                 |   MOVE.L            |
|                  |                 |   SUBQ.L            |
|                  |                 |   MOVE.L            |
|                  |                 |   MOVE.L            |
|                  |                 |   MOVE.L            |
|                  |                 |   JSR               |
_|___________________|__________________|_____d_o_n_e_:______________|


















Page 3-00000000000N0A0D060800A0s0s0e0m0b0l0y00L0a0n0g0u0a0g0e0000000000000000000000000000000000000000000000000000000000000000000067







NAD68 E.R.S.                                 August 27, 1990



                    4.  NAD68 Directives

4.1  Directives That Display Information

4.1.1  _N_U_M_B_E_R

The NUMBER directive causes an expression to be evaluated
and typed on the user's screen or the message file in the
current radix.

The complete syntax is:

     NUMBER  exp

where _e_x_p is an expression.

4.1.2  _R_E_M_A_R_K

The REMARK directive causes the assembler to type on the
user's terminal or the message file all of the characters
between the delimiter following the word "remark" (a blank
or tab) and the end of line character.  The string is
displayed at the time it is encountered by the assembler.
The character '%' is used to represent a carriage
return/line feed.

The complete syntax is:

     REMARK string

where _s_t_r_i_n_g is the string to be displayed.

4.1.3  _U_N

The UN directive causes all undefined symbols to be
displayed on the terminal or in the message file, including
symbols which have been declared global but not defined.

The complete syntax is:

     UN


4.2  Directives That Assign Values To Labels

4.2.1  _C_U_R_G_M_T

This directive assigns the current time in seconds since
00:00 1/1/74 GMT to a label.

The complete syntax is:



Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000068







NAD68 E.R.S.                                 August 27, 1990



     label CURGMT

where _l_a_b_e_l is a user defined label.

4.2.2  _E_Q

The EQ directive assigns the value of an expression to a
label.

The complete syntax is:

     label EQ exp

where _l_a_b_e_l is a user defined label and _e_x_p is an expres-
sion.

4.2.3  _E_R_R_C_N_T

The ERRCNT directive assigns  to a label the count of errors
recognized by the  assembler at the time the directive was
encountered.

The complete syntax is:

     label ERRCNT

where _l_a_b_e_l is a user defined label.

4.2.4  _L_I_N_E_N_O

This directive assigns the value of the current NAD listing
line number to a label.

The complete syntax is:

     label LINENO

where _l_a_b_e_l is a user defined label.

4.2.5  _N_A_D_V_E_R

This directive assigns the current version number of NAD68
to a label.

The complete syntax is:

     label NADVER

where _l_a_b_e_l is a user defined label.





Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000069







NAD68 E.R.S.                                 August 27, 1990



4.2.6  _T_A_R_G_E_T

This directive assigns a value to a label based upon the
target machine.  Current values are:

________________________
_|_t__a__r__g__e__t____m__a__c__h__i__n__e________v__a__l__u__e___|_
|Engine        |    1  |
_|_______________|________|
_|6_8_0_2_0___________|____2____|
|MAC-V         |    3  |
_|_______________|________|


The complete syntax is:

     label          TARGET

where _l_a_b_e_l is a user defined label.


4.2.7  _U_N_C_N_T

The UNCNT directive assigns the current number of undefined
symbols to a label.

The complete syntax is:

     label UNCNT

where _l_a_b_e_l is a user defined label.

4.3  Directives That Influence The Symbol Table

4.3.1  _F_O

This directive makes foreign all symbols which are local to
the specified module.  A foreign symbol is considered unde-
fined in the current module.  This prevents possible confu-
sion from locals in different modules that have the same
ascii mnemonics.

The complete syntax is:

     FO module_name

where _m_o_d_u_l_e__n_a_m_e is a user defined symbol which names a
module.






Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000070







NAD68 E.R.S.                                 August 27, 1990



4.3.2  _G_L

The GL directive marks a symbol table entry as global to all
modules.  The symbols may be defined in other files and
referenced by the current file or defined in the current
file and referenced elsewhere.  GL must be processed before
the global symbol is referenced or defined.  GL will not
change a normal module symbol to a global symbol.

The complete syntax is:

     GL  sym1,sym2,...,symn

where _s_y_m_1,_s_y_m_2,...,_s_y_m_n are user defined symbols.

4.3.3  _K_I_L_L

This directive causes symbols to be removed from the symbol
table. Any further reference to the symbols will return an
undefined.  KILLing symbols that are not currently defined
will not produce an error.  Unlike most symbols, macro names
must be KILLed before they can be redefined.

The complete syntax is:

     KILL sym1,sym2,... ,symn

where _s_y_m_1,_s_y_m_2,...,_s_y_m_n are user defined symbols.

4.3.4  _L_O

The LO directive causes symbols which have been defined in
another module to be available to the current module. Nor-
mally such symbols would be considered undefined.  There is
no limit to the number of times the user may issue the LO
directive.

The LO directive is not needed to reference global symbols.

The complete syntax is:

     LO module_name

where _m_o_d_u_l_e__n_a_m_e is a user defined symbol which names a
module.









Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000071







NAD68 E.R.S.                                 August 27, 1990



4.4  Directives That Influence The Program Counter

4.4.1  _B_N_D

The BND directive forces the program counter to the next
user specified boundary.  If the program counter is already
at such a boundary, it is not changed.

The complete syntax is:

     label BND exp

where _l_a_b_e_l is an optional user defined label and _e_x_p is an
expression whose value is a power of two.  If _l_a_b_e_l is
present, then it is assigned the value of _e_x_p.

4.4.2  _E_M

This directive ends the current module and causes the assem-
bler to type out the hex value of the beginning and ending
address of the module.  All undefined symbols are also
typed.

After the EM directive is processed, assembly continues in
the default (..MAIN) module until another MO directive is
encountered.

The complete syntax is:

     EM


4.4.3  _M_O

The MO directive defines the beginning of a module whose
name is specified by the user.  The user also defines the
starting program counter for the module.  All symbols
defined in the module are local to the module and distinct
from symbols defined in other modules.  The user may define
a maximum of 32d modules.  If no module is defined, the
default module ..MAIN is used.

The complete syntax is:

     MO exp,module_name

where _e_x_p is an expression which defines the starting pro-
gram counter for the module and _m_o_d_u_l_e__n_a_m_e is a user
defined symbol used to name the module.





Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000072







NAD68 E.R.S.                                 August 27, 1990



4.4.4  _O_R_G

This directive assigns to the program counter a value speci-
fied by the user.  If the ORG directive is not issued, the
program counter starts at zero.

If trying to ORG from the current segment to a location in
the other previously user-declared segment, NAD68 will
implicitly change the segment number to the new segment in
which the new location resides before assigning the PC to
that new value.

The complete syntax is:

     label ORG exp

where _l_a_b_e_l is an optional user defined label and _e_x_p is an
expression.  If _l_a_b_e_l is present, it is assigned the value
of _e_x_p

4.4.5  _S_E_G

The SEG directive caused the program counter to assume the
value it had when it left the specified segment.  If this is
the first time the segment has been accessed, the program
counter assumes the value of the start of the segment.

The complete syntax is:

     label SEG exp1,exp2

where _l_a_b_e_l is an optional user defined label, _e_x_p_1 is an
expression whose value is between 0 and 15d and _e_x_p_2 is an
optional expression which specifies the starting address for
the segment.  This address must be on a 64K boundary.  If
_e_x_p_2 is missing the segment starts at an address equal to
_e_x_p_1 shifted left by 16 bits.  If _l_a_b_e_l is present it will
be assigned the new value of the program counter.

4.5  Directives That Influence The Listing

4.5.1  _L_I_S_T

The LIST directive controls the format of the listing lines.

The following parameters are available:

     L    List NOLISTed lines as is.
          The program counter and hex code are not printed.
          Macro expansions are not printed (-X).
          "RE" blocks are listed only once (-R).



Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000073







NAD68 E.R.S.                                 August 27, 1990



     -L   NOLISTed lines are not printed.

     F    Lines contained in the negative branch of an IF
          statement are listed as is.
          The program counter and hex code are listed.
          Macro expansions are not printed (-X).
          "RE" blocks are listed only once (-R).

     -F   Lines contained in the negative branch of an IF
          statement are not listed.
          The program counter and hex code are not listed.

     X    Macro expansions, delimited by square brackets,
          are printed after the macro call.

     -X   Macro expansions are not printed.

     R    All generations of a repeat block are listed.

     -R   Repeat blocks are listed only once.

The default parameters are: L, F, X, and R.

Some options negate other options.  The user should be care-
ful about the order in which the options  are specified.

4.5.2  _N_O_L_I_S_T

The NOLIST directive turns off the generation of a listing.
This directive is over-ridden if the L parameter is speci-
fied on the LIST directive.

4.5.3  _N_O_T_T_L

The NOTTL directive cancels the current default title, caus-
ing listing of any further assemblies to not contain head-
ings.

4.5.4  _S_U_B_T_T_L

This directive causes a section break on the listing.  The
text appearing between the SUBTTL directive and the end of
the line becomes the new subtitle in the second line of the
listing header.  The maximum length for a subtitle is 24
characters less than the listing line.

The complete syntax is:

     SUBTTL string

where _s_t_r_i_n_g becomes the listing subtitle.



Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000074







NAD68 E.R.S.                                 August 27, 1990



4.5.5  _T_I_T_L_E

This directive creates a new title.  Since Unix NAD Analogue
and NAD68 only generates a pass one listing, this title is
not placed at the top of a listing.

The complete syntax is:

     TITLE string

where _s_t_r_i_n_g becomes the listing title.

4.6  Directives That Allocate Storage

4.6.1  _B_S

This directive allocates the number of bytes specified by
the user.

The complete syntax is:

     label BS exp

where _l_a_b_e_l is an optional user defined label and _e_x_p is an
expression which indicates the number of bytes to allocate.
If _l_a_b_e_l is present, it is assigned the value of the program
counter at the start of the storage allocation.

4.6.2  _H_S

The HS directive aligns the program counter to a halfword
boundary and allocates the  number of halfwords specified by
the user.

The complete syntax is:

     label HS exp

where _l_a_b_e_l is an optional user defined label and _e_x_p is an
expression which specifies how many halfwords to allocate.
If _l_a_b_e_l is present it is assigned the value of the program
counter after it has been aligned on a halfword boundary.

4.6.3  _W_S

The WS directive aligns the program counter to a word boun-
dary and allocates the  number of words specified by the
user.

The complete syntax is:




Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000075







NAD68 E.R.S.                                 August 27, 1990



     label WS exp

where _l_a_b_e_l is an optional user defined label and _e_x_p is an
expression which specifies how many words to allocate.  If
_l_a_b_e_l is present it is assigned the value of the program
counter after it has been aligned on a word boundary.

4.7  Directives That Allocate Data

4.7.1  _A_C

This directive allocates and initializes storage based on
an ascii string specified by the user.  Special characters
may be inserted into the string by inserting a full quote
(") followed by 2 hex digits that represent the 8 bits of
the special character.

The complete syntax is:

     label AC ascii_string

where _l_a_b_e_l is an optional user defined label and
_a_s_c_i_i__s_t_r_i_n_g is the string of ascii character to be stored.
If _l_a_b_e_l is present it is assigned the value of the program
counter at the beginning of the storage allocation.

4.7.2  _B_C

This directive allocates and initializes storage based on
the number of parameters the user defines.

The complete syntax is:

     label BC exp1,exp2,...,expn

where _l_a_b_e_l is an optional user defined label and
_e_x_p_1,_e_x_p_2,...,_e_x_p_n are expressions.  If _l_a_b_e_l is present it
is assigned the value of the program counter at the begin-
ning of the storage allocation.  Only the low order 8 bits
of an expression value are stored, the high order value bits
are ignored.

4.7.3  _H_C

This directive aligns the program counter on a halfword
boundary and then allocates and initializes storage based on
the number of parameters the user defines.

The complete syntax is:

     label HC exp1,exp2,...,expn



Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000076







NAD68 E.R.S.                                 August 27, 1990



where _l_a_b_e_l is an optional user defined label and
_e_x_p_1,_e_x_p_2,...,_e_x_p_n are expressions.  If _l_a_b_e_l is present it
is assigned the value of the program counter, after align-
ment, at the beginning of the storage allocation.  If the
value of an expression is greater than 0xFFFF, only the low
order 16 bits are stored.

4.7.4  _S_C

This directive allocates and initializes storage based on an
ascii string  specified by the user.  The first byte con-
tains a count of characters in the string.  The string
should not exceed 256 bytes.

The complete syntax is:

     label SC  ascii_string

where _l_a_b_e_l is an optional user defined label and
_a_s_c_i_i__s_t_r_i_n_g is a string of ascii characters to be placed in
storage.  If _l_a_b_e_l is present it is assigned the value of
the program counter at the beginning of the storage alloca-
tion.

4.7.5  _W_C

This directive aligns the program counter to a word boundary
and then allocates and initializes storage based on the
number of parameters the user defines.

The complete syntax is:

     label WC exp1,exp2,...,expn

where _l_a_b_e_l is an optional user defined label and
_e_x_p_1,_e_x_p_2,...,_e_x_p_n are expressions.  If _l_a_b_e_l is present it
is assigned the value of the program counter, after align-
ment, at the beginning of the storage allocation.

4.7.6  _X_C

This directive allocates and initializes storage based on
the number of parameters the user defines.  Hex digits are
stored starting at the high order nibble of the next avail-
able byte.

The complete syntax is:

     label XC hexstring

where _l_a_b_e_l is an optional user defined label and _h_e_x_s_t_r_i_n_g



Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000077







NAD68 E.R.S.                                 August 27, 1990



is a string of hex characters.  If _l_a_b_e_l is present it is
assigned the value of the program counter at the beginning
of the storage allocation.

4.8  Directives That Influence The Assembly Process

4.8.1  _E_I

The EI directive terminates the range of an IF statement.
It decrements the nested-if level by one.

The complete syntax is:

     EI


4.8.2  _E_L_S_E

This directive causes the text between the ELSE directive
and the next ELSE directive or EI directive to be assembled
only when the ELSE expression is greater than zero (TRUE).

The ELSE directive does not modify the nested-if level.

The complete syntax is:

     ELSE exp

where _e_x_p is an optional expression.  If _e_x_p is not present
it is assumed to be 1 (TRUE).

4.8.3  _E_N_D

This directive tells the assembler to stop assembling from
the current input file.

The complete syntax is:

     END


4.8.4  _E_R

This directive defines the end of a repeat block which was
started with an RE directive.  If the directive contains an
expression and the value of the expression is greater than
zero, the block is repeated.  If the directive does not con-
tain an expression, the expression associated with the RE
directive is used to control the repeat loop.

The complete syntax is:



Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000078







NAD68 E.R.S.                                 August 27, 1990



     ER exp

where _e_x_p is an expression.

4.8.5  _I_F

This directive causes the text between the IF expression and
the ELSE or EI directive to be assembled only when the IF
expression is greater than zero (TRUE).

The IF directive causes the nested-if level to be incre-
mented by one.  The nested-if level may not exceed four.

The complete syntax is:

     IF exp

where _e_x_p is an expression.

4.8.6  _M_A_C_R_O

This directive causes a macro to be stored for later expan-
sion.  The macro definition may contain a list of parameters
enclosed in parentheses.  The macro text is surrounded by
brackets and may occupy more than one line.

The complete syntax is:

     label MACRO (param_list) [text]

where _l_a_b_e_l is a user defined label which names the macro,
_p_a_r_a_m__l_i_s_t is a list of 0 to 16 parameters, and _t_e_x_t is a
series of NAD assembly statements and directives.

4.8.7  _Q_U_I_T

The QUIT directive causes the NAD68 processing to stop.  The
complete syntax is:

     QUIT  exp

where _e_x_p is an optional expression.  The expression is
evaluated and its value determines where the control returns
unless the -c option was used on the command line. IIf the
-c option is active, control returns to UNIX or CMF by
ignoring the value.

If its value is greater than zero, control returns to UNIX
or  CMF.  If the value is less than or equal to zero control
returns to the NAD68 command level with further input being
accepted from STDIN.



Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000079







NAD68 E.R.S.                                 August 27, 1990



If _e_x_p is omitted or undefined control returns to NAD68 com-
mand level with further input being accepted from STDIN.

4.8.8  _R_A

The RA directive sets the current radix to a value supplied
by the user.  This radix remains in effect until changed
with another RA directive.  The current radix may be over-
ridden by a statement level radix.

The default radix is hexadecimal.  Changes in the radix
cause changes in the evaluation of expressions.  For exam-
ple, the string 10 will evaluate to ten in decimal radix but
eight in octal radix.

The complete syntax is:

     RA exp

where _e_x_p is an expression.  If the value of the expression
is 0, the radix is set to hexadecimal.  The digits that make
up the expression are subject to the restrictions set forth
in the definition of a number, and to further restrictions
of the radix.

4.8.9  _R_E

The RE directive defines the beginning of a repeat block.
If it contains an expression, the expression determines how
many times the repeat block is assembled.  A value equal to
or less than zero causes the repeat block to be skipped.

Repeat block may be nested up to four levels.

The complete syntax is:

     label  RE  exp

where _l_a_b_e_l is an optional user defined label and _e_x_p is an
optional expression.

4.9  Directives That Are Available Only To NAD68

4.9.1  _I_6_8_O_N

The I68ON directive causes the user to be notified of inef-
ficient code generation.  A notice is written to the message
file, or STDERR, whenever it may be possible to generate
more efficient 68020 code by using another NAD instruction.

The decision to change the instruction is left to the



Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000080







NAD68 E.R.S.                                 August 27, 1990



programmer.

4.9.2  _I_6_8_O_F_F

This directive turns off checking for inefficient code gen-
eration.

4.9.3  _Q_6_8_O_N

The Q68ON directive informs the compiler that the user wants
notification of questionable code generation.  Notices,
which are listed in the NAD68 Messages section, are sent to
STDERR.

4.9.4  _Q_6_8_O_F_F

This directive turns off checking for questionable code gen-
eration.




































Page 4-00000000000000N0A0D0608000D0i0r0e0c0t0i0v0e0s0000000000000000000000000000000000000000000000000000000000000000000000081







NAD68 E.R.S.                                 August 27, 1990



                   5.  NAD68 File Formats

5.1  Command Files

Command files are in ascii format and may contain any valid
NAD68 command.  The format of these commands are described
in section 2.

5.2  Source Files

Source file are in ascii format.  These files may contain
NAD68 statements, directives, configuration macros, or
patches to a NAD68 memory image.  The format of NAD68 state-
ments is described in section 4.

5.3  Image Files

NAD68 creates its image file in e.out format.  The  follow-
ing sections describe the e.out file as created by NAD68.
For a description of all possible fields of an e.out file
see _N_P_E _U_s_e_r'_s _G_u_i_d_e.

5.3.1  _H_e_a_d_e_r

The header record is the first record of the image file.

5.3.1.1  _H_e_a_d_e_r__L_a_y_o_u_t

_______________________________________________________________
_|_________________________________________________H__e__a__d__e__r____L__a__y__o__u__t___________________________________________________|_
| s_magic |  s_subheader|     s_text   |  s_reloc |  s_symxref|
| u.long  |    u.long   |     u.long   |   u.long |   u.long  |
_|__________|______________|_______________|___________|____________|
|s_symxdef|    s_syms   |    s_string  |  s_macro |   s_state |
_|_u_._l_o_n_g____|____u_._l_o_n_g_____|_____u_._l_o_n_g_____|___u_._l_o_n_g___|___u_._l_o_n_g____|
|s_history|  s_entry (4)|              |          |           |
| u.long  |    u.long   |     u.long   |   u.long |   u.long  |
_|__________|______________|_______________|___________|____________|
|s_sources|    s_vers   |  s_filler (4)|          |           |
_|_u_._l_o_n_g____|____u_._l_o_n_g_____|_____u_._l_o_n_g_____|___u_._l_o_n_g___|___u_._l_o_n_g____|
|         |   xxxxxxxx  |    xxxxxxxx  |  xxxxxxxx|  xxxxxxxx |
| u.long  |   xxxxxxxx  |    xxxxxxxx  |  xxxxxxxx|  xxxxxxxx |
_|__________|______________|_______________|___________|____________|

5.3.1.1.1  _s_._m_a_g_i_c

This is a UNIX magic number.  It indicates the type of the
file.  In a NAD68 image file, this field may have the fol-
lowing value:





Page 5-0000000000000N0A0D0608000F0i0l0e00F0o0r0m0a0t0s000000000000000000000000000000000000000000000000000000000000000000000082







NAD68 E.R.S.                                 August 27, 1990



     TMAGIC    - value (0707)  this octal number indicates
               the file is in Tymnet object file format.

5.3.1.1.2  _s___s_u_b_h_e_a_d_e_r

Indicates the number of bytes in the file occupied by the
subheaders.

5.3.1.1.3  _s___t_e_x_t

Indicates the number of bytes in the file occupied by the
text.

5.3.1.1.4  _s___r_e_l_o_c

Not used by NAD68.

5.3.1.1.5  _s___s_y_m_x_r_e_f

Not used by NAD68.

5.3.1.1.6  _s___s_y_m_x_d_e_f

Not used by NAD68.

5.3.1.1.7  _s___s_y_m_s

Indicates the number of bytes in the file occupied by the
symbol table.

5.3.1.1.8  _s___s_t_r_i_n_g

Indicates the number of bytes in the file occupied by symbol
names.

5.3.1.1.9  _s___m_a_c_r_o

Indicates the number of bytes in the file occupied by a copy
of the macro definitions.

5.3.1.1.10  _s___s_t_a_t_e

Indicates the number of bytes in the file occupied by the
state table.

5.3.1.1.11  _s___h_i_s_t_o_r_y

Not used by NAD68.






Page 5-0000000000000N0A0D0608000F0i0l0e00F0o0r0m0a0t0s000000000000000000000000000000000000000000000000000000000000000000000083







NAD68 E.R.S.                                 August 27, 1990



5.3.1.1.12  _s___e_n_t_r_y

This four word array contains entry point addresses.

5.3.1.1.13  _s___s_o_u_r_c_e_s

This bit array contains information about the sources used
in producing the object code.  The following bits may be set
by NAD68:

     S_NAD     - 0x1, the source is NAD.

     S_68020   - 0x10, the text area contains 68020 object
               code.

     S_NADSYM  - 0x80000000, the symbol table contains NAD
               formated symbol information.
     Files containing these bits, S_C and  S_DUMP may be
     read by NAD68.

5.3.1.1.14  _s___v_e_r_s

This is the e.out version number, in case the structure is
modified later.

5.3.1.1.15  _s___f_i_l_l_e_r

These 4 words are available for future use.

5.3.2  _S_u_b_h_e_a_d_e_r

A subheader is created for each segment in the NAD68 source.

5.3.2.1  _O_f_f_s_e_t__t_o__s_u_b_h_e_a_d_e_r_s

The offset to the subheader is contained in E_SUBHEADOFF.
Since the header is a fixed length, this is a constant.

5.3.2.2  _S_u_b_h_e_a_d_e_r__L_a_y_o_u_t

The subheader area contains one or more of the following
structures:












Page 5-0000000000000N0A0D0608000F0i0l0e00F0o0r0m0a0t0s000000000000000000000000000000000000000000000000000000000000000000000084







NAD68 E.R.S.                                 August 27, 1990



_____________________________________________________________________
_|___________________________________________________S__u__b__h__e__a__d__e__r____L__a__y__o__u__t_______________________________________________________|_
|   s_type   |   s_number  |   s_textsize |  s_relocsize|  s_address|
|   u.long   |    u.long   |     u.long   |    u.long   |   u.long  |
_|_____________|______________|_______________|______________|____________|
| s_offtext  |  s_offreloc |  s_segrequest|   s_protect |  s_unused |
_|____i_n_t_______|______i_n_t______|______c_h_a_r______|_____c_h_a_r______|____s_h_o_r_t____|
|s_endaddress|  s_filler(9)|              |             |           |
|   u.long   |    u.long   |     u.long   |    u.long   |   u.long  |
_|_____________|______________|_______________|______________|____________|
|            |             |              |             |           |
_||___u_._l_o_n_g_____|____u_._l_o_n_g_____|_____u_._l_o_n_g_____|____u_._l_o_n_g_____|___u_._l_o_n_g____||

5.3.2.2.1  _s___t_y_p_e

This field contains information about the type of source
used in this text area.  The types which may exist are
defined in the Header record.

5.3.2.2.2  _s___n_u_m_b_e_r

This is the NAD segment number.

5.3.2.2.3  _s___t_e_x_t_s_i_z_e

The number of bytes in the file occupied by the text for
this area.

5.3.2.2.4  _s___r_e_l_o_c_s_i_z_e

Not used by NAD68.

5.3.2.2.5  _s___a_d_d_r_e_s_s

The absolute address in memory of the start of this area.

5.3.2.2.6  _s___o_f_f_t_e_x_t

The offset from the beginning of the file to the beginning
of the text for this area.

5.3.2.2.7  _s___o_f_f_r_e_l_o_c

Not used by NAD68.

5.3.2.2.8  _s___s_e_g_r_e_q_u_e_s_t

Only valid for NAD or NAD68 code.  Indicates if the segment
was implicitly or explicitly declared.





Page 5-0000000000000N0A0D0608000F0i0l0e00F0o0r0m0a0t0s000000000000000000000000000000000000000000000000000000000000000000000085







NAD68 E.R.S.                                 August 27, 1990



5.3.2.2.9  _s___p_r_o_t_e_c_t

Not used by NAD68.

5.3.2.2.10  _s___u_n_u_s_e_d

This part of a word is currently unused.

5.3.2.2.11  _s___e_n_d_a_d_d_r_e_s_s

The absolute address in memory of the end of this area. Only
valid for non-relocatable areas.

5.3.2.2.12  _s___f_i_l_l_e_r

These 9 words are currently unused.

5.3.3  _T_e_x_t

The text area contains the executable code and data.  The
separation of code and data into separate areas is the
responsibility of the user.  The text area may contain
uncompressed and compressed records in the following for-
mats:

5.3.3.1  _U_n_c_o_m_p_r_e_s_s_e_d__T_e_x_t__L_a_y_o_u_t

____________________________________________________________
_|___________________________________U__n__c__o__m__p__r__e__s__s__e__d____T__e__x__t____L__a__y__o__u__t_____________________________________|_
|  t_length    |     t_address     |     t_text(variable)  |
|    int       |        int        |           char        |
_|_______________|____________________|________________________|
|              |                   |     may contain from  |
|              |                   |     1 to 1016 char-   |
_||_______________|____________________|_____a_c_t_e_r_s______________||

5.3.3.1.1  _t___l_e_n_g_t_h_,__u_n_c_o_m_p_r_e_s_s_e_d

This indicates the length of the text record.  This length
includes the 8 bytes (2 integers) used for the length and
address fields.

5.3.3.1.2  _t___a_d_d_r_e_s_s_,__u_n_c_o_m_p_r_e_s_s_e_d

This indicates the memory address for the start of the text.









Page 5-0000000000000N0A0D0608000F0i0l0e00F0o0r0m0a0t0s000000000000000000000000000000000000000000000000000000000000000000000086







NAD68 E.R.S.                                 August 27, 1990



5.3.3.1.3  _t___t_e_x_t_,__u_n_c_o_m_p_r_e_s_s_e_d

Contains the bytes to be written to memory.  If t_length is
an odd number, the physical record is padded with one blank
in order to maintain even boundaries.

5.3.3.2  _C_o_m_p_r_e_s_s_e_d__T_e_x_t__L_a_y_o_u_t

____________________________________________________________
_|_____________________________________C__o__m__p__r__e__s__s__e__d____T__e__x__t____L__a__y__o__u__t_______________________________________|_
|   t_length      |      t_address     |       t_text(2)   |
|     int         |         int        |         char      |
_|__________________|_____________________|____________________|

5.3.3.2.1  _t___l_e_n_g_t_h_,__c_o_m_p_r_e_s_s_e_d

The leftmost bit is set to indicate that this is a compres-
sion record.  The remaining bits indicate the number of
times the t_text byte should be repeated.

5.3.3.2.2  _t___a_d_d_r_e_s_s_,__c_o_m_p_r_e_s_s_e_d

This indicates the memory address for the start of the text.

5.3.3.2.3  _t___t_e_x_t__c_o_m_p_r_e_s_s_e_d

Contains the byte to be repeated in memory.  The second byte
in this field is used to maintain an even byte boundary.

5.3.4  _S_y_m_b_o_l_s

This area contains NAD symbol table structures.

5.3.4.1  _N_A_D__S_y_m_b_o_l_s

5.3.4.1.1  _N_A_D__S_y_m_b_o_l__L_a_y_o_u_t

The NAD symbol table structure is called a nib_list and has
the following format:
____________________________________________________________
|                    NAD Symbol Layout                     |
_|______________________________________________________________________________________________________________________|_
| def  |  module |  strx |  union {val, nib_op, nib_list}  |
_|s_h_o_r_t___||__s_h_o_r_t____||__l_o_n_g___||__u_n_i_o_n__{_n_u_m_3_6_,__n_i_b___o_p_,__n_i_b___m_a_c_}___|


This structure describes the symbol table entry when it
resides in an e.out file.  It's appearance may differ in the
assembler.





Page 5-0000000000000N0A0D0608000F0i0l0e00F0o0r0m0a0t0s000000000000000000000000000000000000000000000000000000000000000000000087







NAD68 E.R.S.                                 August 27, 1990



5.3.4.1.2  _d_e_f

This is a bit field which  describes how the symbol was
defined.

     SYPRPM    - 0x1,

     SYPROP    - 0x2, proprietary symbol

     SYUNDF    - 0x8, the symbol is undefined

5.3.4.1.3  _m_o_d_u_l_e

The module number in which the symbol was defined.

5.3.4.1.4  _s_t_r_x

The offset in the string table of the symbol name.

5.3.4.1.5  _v_a_l

The 36-bit value or address of the symbol.

5.3.4.1.6  _n_i_b___o_p

The structure for defining opcodes.

____________________________________________________________
_|_____________________________________________n__i__b_____o__p____l__a__y__o__u__t_________________________________________________|_
|         optype              |              opval         |
|          long               |              long          |
_|______________________________|_____________________________|

5.3.4.1.6.1  _o_p_t_y_p_e

The type of opcode.  These values are detailed in the
description of the appropriate processor machine language.

5.3.4.1.6.2  _o_p_v_a_l

The hexadecimal value of the opcode.  These values are
detailed in the description of the appropriate processor
machine language.

5.3.4.1.7  _n_i_b___m_a_c

The structure for defining macros.







Page 5-0000000000000N0A0D0608000F0i0l0e00F0o0r0m0a0t0s000000000000000000000000000000000000000000000000000000000000000000000088







NAD68 E.R.S.                                 August 27, 1990



____________________________________________________________
_|___________________________________________n__i__b_____m__a__c____l__a__y__o__u__t_________________________________________________|_
|    size         |         arg        |        macrox     |
|    short        |        short       |         long      |
_|__________________|_____________________|____________________|

5.3.4.1.7.1  _s_i_z_e

The number of bytes in the macro.

5.3.4.1.7.2  _a_r_g

The number of arguments accepted by the macro.

5.3.4.1.7.3  _m_a_c_r_o_x

The offset within the string table of the macro source.

5.3.5  _S_t_r_i_n_g_s

The string table consists of a series of characters.  Each
string is preceded by it's length.
____________________________________________________________
|                   String Table Layout                    |
_|______________________________________________________________________________________________________________________|_
|          length               |             symbol       |
_|____________i_n_t__________________||_____________c_h_a_r_s__________|

5.3.6  _M_a_c_r_o_s

The macro table consists of a series of characters.  Each
string is preceded by it's length.

____________________________________________________________
_|_______________________________________M__a__c__r__o____T__a__b__l__e____L__a__y__o__u__t_____________________________________________|_
|          length                |            macro        |
|            int                 |            chars        |
_|_________________________________|__________________________|

5.4  Listing Files

Listings are generated with the -l option, the %A command,
or  by a combination of the ;A command and the ;( and ;)
commands.

The page dimensions used by NAD68 default to 56 lines and
120 columns per page.  This can be modified by using the ;%
command.

The listing header consists of the following two lines:

_P_a_g_e _s-_p                          _t_i_t_l_e                _N_A_D_6_8-_v._r _d_a_t_e _t_i_m_e


Page 5-0000000000000N0A0D0608000F0i0l0e00F0o0r0m0a0t0s000000000000000000000000000000000000000000000000000000000000000000000089







NAD68 E.R.S.                                 August 27, 1990



_f_i_l_e_n_a_m_e                         _s_u_b_t_i_t_l_e

Where:

     s         is the section number.  This starts at 1 and
               is increased 1 for each source file opened
               and each subtitle directive.

     p         is the page counter within a section.

     title     is the default title.  This title  is entered
               directly, not as part of a source file.  Only
               pass one listings are generated at this time;
               so only the default title is used on the
               listing.

     v         is the version number of NAD68.

     r         is the revision level of NAD68.

     date      is the date the listing was generated.

     time      is the time the listing was begun.

     filename  is the name of the source file most recently
               opened.

     subtitle  is a string specified by the most recent sub-
               title directive

The heading is followed by a blank line.  The remaining
space on the page is occupied by listing lines.

Listing lines may have up to 4 fields.  Columns 1-6 contain
the listing line number.  Columns 8-15 contain the program
counter.  Columns 17-30 contain the value of data and the
results of expressions evaluated for directives.  The copy
of the source line occupies the remainder of the line.

The information present on the listing page may vary,
depending on the use of the LIST/NOLIST directive.

If the user requests object code, the 68020 object code and
partial statements will be listed on the lines following the
NAD source statement.  They have the following format:

_6_8_0_2_0-_h_e_x    _p_a_r_t_i_a_l-_s_o_u_r_c_e

Where:





Page 5-0000000000000N0A0D0608000F0i0l0e00F0o0r0m0a0t0s000000000000000000000000000000000000000000000000000000000000000000000090







NAD68 E.R.S.                                 August 27, 1990



     68020-hex is the 68020 object code generated by the
               translator

     partial-source is a partial source listing of the 68020
               source line generated by the translator. The
               source listing will contain the results of
               the expression evaluation and will not copy
               the expression from the NAD source line.

There will be one logical listing line per physical listing
line unless the user has requested more than one logical
line per physical line via the -i option.

Page feeds can be forced by a control-L at the beginning of
a line.

5.5  Message Files

Message files contain ascii strings which would normally be
displayed on the user's terminal.  These include REMARK and
NUMBER statements  as well as any messages generated by the
assembler.

5.6  Temp Files



NAD68 creates temporary files in the user's directory to
contain the memory image during assembly and debugging.
These files contain only hexadecimal code and data.  The
file names are created by converting the host id and job id
to an alphanumeric string and concatenating the string 'SEG'
and the segment number.  These files have an extension of
'.tmp'.  The files are erased when NAD68 terminates nor-
mally.



















Page 5-0000000000000N0A0D0608000F0i0l0e00F0o0r0m0a0t0s000000000000000000000000000000000000000000000000000000000000000000000091







NAD68 E.R.S.                                 August 27, 1990



               6.  Exceptions and Differences

6.1  Differences Between NAD68 And NAD Version 2

NAD68 differs from NAD version 2 in the following ways:

  1.  It generates 68020 object code instead of engine
      object code Instructions sizes given for NAD do not
      apply to NAD68.

  2.  The -i option is available on the command line to
      allow multiple 68020 listing lines on a physical line.

  3.  NAD68 does not have a DDT interface, the Alfred
      Debugger must be used.

  4.  The UPSW instruction will only modify the location
      counter, not the condition codes.

  5.  The status changing instructions, LPSW, LPSWR, and
      EPSR, are not available.

  6.  The I/O instructions, CIO, SSR, OC, OCR, RDR, WD, and
      WDR, are not available.

  7.  The async microcode, SBOD, XMIT, SPM, and GCHAR, is
      not available.

  8.  Some bufferlet microcode, RTD1, RTD2, RMA1, and RMA2,
      is not available.

  9.  ORG changes segment number implicitly if necessary in
      NAD68.


6.2  Differences Between NAD68 And NAD Version 1

NAD68 differs from PDP/10 NAD in the following ways:

  1.  The LF command has been replaced by ~.

  2.  NAD68 accepts screen input in line mode, rather than
      character mode.  The carriage return must be pressed
      before any scanning of the NAD68 command starts.

  3.  In traditional UNIX fashion, NAD68 allows the user to
      specify options which override commands in the NAD
      command file.

  4.  NAD68 produces a pass 1 listing.  Object code printed
      on the listing will not have forward references



Page 6-000000000E0x0c0e0p0t0i0o0n0s00a0n0d00D0i0f0f0e0r0e0n0c0e0s000000000000000000000000000000000000000000000000000000000000000000092







NAD68 E.R.S.                                 August 27, 1990



      resolved.

  5.  NAD68 will accept UNIX formated file names.  If PDP-10
      formated file names are used, the CMF facility  or the
      -p option must be used.

  6.  A carriage return should not be entered between com-
      mands and their associated file names.  NAD68 does not
      prompt for file name on assembly and object file mani-
      pulation commands.

  7.  NAD68 does not creat BND files, any physical addresses
      specified in a command will be ignored.

  8.  NAD68 reads and writes complete symbol tables only.
      Any module specified with the %G or %P command will be
      ignored.

  9.  The '?' command is not available.  The user may edit
      the command line, backspace to delete the entire com-
      mand, before entering a CR/LF.

 10.  NAD68 error messages contain source and listing line
      numbers.

 11.  NAD68 cross-references may contain source or listing
      line numbers.  They may also contain both source and
      listing line numbers.


























Page 6-000000000E0x0c0e0p0t0i0o0n0s00a0n0d00D0i0f0f0e0r0e0n0c0e0s000000000000000000000000000000000000000000000000000000000000000000093







NAD68 E.R.S.                                 August 27, 1990



                     7.  NAD68 Messages

Arg must be a power of 2  - The argument to the BND direc-
                    tive is not a power of 2.


ASC not properly terminated  - The string associated with
                    the AC or SC directive was not ter-
                    minated with a backslash .


Assembler logic error  - This is  an undetermined assembler
                    malfunction.

Assembling into used memory  - The assembler has attempted
                    to place hex code into a memory location
                    that does not contain nulls.


Bad command argument  - An argument on the UNIX command line
                    is not recognized


Buffer overflow     - This is an assembler malfunction.  The
                    assembler has incremented past the end
                    of the input buffer.


Buffer underflow    - This is an assembler malfunction.  The
                    assembler has decremented beyond the
                    beginning of the input buffer.


Code Size Exceeds SVC Skip Return Byte Count The NAD
                    instructions following an SVC generates
                    more bytes of instructions that allowed
                    by the SVC skip return.  In this case
                    NAD68 will generate as many bytes as
                    needed by the NAD instruction.


Command not supported  - The user has issued a command that
                    is not yet available in NAD68.


End of assembly     - NAD68 has completed the assembly of
                    the current source file.


Error opening input file  - NAD68 was unable to open the
                    specified input file because either it



Page 7-0000000000000000N0A0D060800M0e0s0s0a0g0e0s00000000000000000000000000000000000000000000000000000000000000000000000094







NAD68 E.R.S.                                 August 27, 1990



                    is unable to find the file, the file is
                    locked, the user does not have permis-
                    sion to access the file, or an error
                    occurred during the open call.


Error writing image file  - An error occurred while writing
                    the image file.  This could be due to
                    insufficient disk space.

Expression incomplete or syntax error  - An expression, or
                    term within an expression, ends with an
                    operator or contains other improper syn-
                    tax.


File ended while scanning arguments in macro call. No )
                    found  - The end of the file was reached
                    before the end of the macro argument
                    list was found.


File ended while scanning macro definition. No [ or ] found
                     - The end of the file was reached
                    before the end of the macro definition
                    was found.


File missing all of requested data  - The user has
                    requested hex code from an image file
                    and the assembler is unable to find code
                    for the locations specified.


File missing some of requested data  - The user has
                    requested hex code from an image file
                    and the assembler is unable to find code
                    for all of the locations specified.


First character of statement illegal  - The first character
                    of a statement is not a label character,
                    blank,  comment delimiter, or end of
                    line marker.


Illegal character   - NAD68 does not recognize an input
                    character.






Page 7-0000000000000000N0A0D060800M0e0s0s0a0g0e0s00000000000000000000000000000000000000000000000000000000000000000000000095







NAD68 E.R.S.                                 August 27, 1990



Illegal expression  - NAD68 is unable to determine a value
                    for an expression because it contains
                    unrecognized or illegal syntax.


Illegal label terminator  - A label terminates with a char-
                    acter that is not a  :, ;, or end of
                    line marker.


Illegal list option  - An option to the LIST directive is
                    not recognized.


Illegal literal     - The user has defined a literal that is
                    not valid.


Image binary file not open  - The user has attempted to
                    write or read an image file that has not
                    been opened.


Improper Hex        - The arguments to the XC directive are
                    not properly formed.


Invalid argument to command  - NAD68 does not recognize an
                    argument to a command.


Invalid opcode      - The symbol in the opcode field is not
                    recognized as an opcode or macro.


Invalid origin field or origin not followed by a comma  -
                    The ORG directive is not correctly for-
                    mated.


Line length too large, default assumed  - The user has
                    attempted to set a larger listing line
                    length than currently allowed by NAD68.


Line length too small, default assumed  - The user has
                    attempted to set a smaller listing line
                    length than currently allowed by NAD68.






Page 7-0000000000000000N0A0D060800M0e0s0s0a0g0e0s00000000000000000000000000000000000000000000000000000000000000000000000096







NAD68 E.R.S.                                 August 27, 1990



Listing file failure  - An error was encountered trying to
                    open, write, or close the listing file.


Macro body too big  - The user has defined a macro that
                    exceeds the current macro size allowed
                    by NAD68.


Macro ends in repeat range  - The user has attempted to end
                    a macro definition within a RE/ER range.


Macro name in use   - A macro is being defined whose label
                    is currently in use by an existing
                    macro.


Message not in table  - This is an assembler malfunction.
                    The assembler has attempted to notify a
                    user of an error that does not exist in
                    the error message table.


Missing or invalid parameter  -  A parameter was expected
                    and was either not found or was not
                    accepted


Missing label field  - A label has not been defined for a
                    statement which requires a label.


Missing operand field  - NAD68 expect more operands that the
                    user supplied.


Misplaced unary operator  - A unary operator is being used
                    incorrectly.

Module name invalid  - The module name specified with the MO
                    directive is not allowed.


More ER statements than valid RE statements  - The assembler
                    has encountered more ER (end repeat)
                    directives that RE (repeat) directives.


NAD68 is out of memory  - NAD68's request to the operating
                    system for additional memory had been



Page 7-0000000000000000N0A0D060800M0e0s0s0a0g0e0s00000000000000000000000000000000000000000000000000000000000000000000000097







NAD68 E.R.S.                                 August 27, 1990



                    denied.  NAD68 is unable to continue.


Negative value in storage statement illegal  - The expres-
                    sion used to determine how much storage
                    to allocate has resolved to a negative
                    value.


No command filename specified  - The -c option has been used
                    on the command line without a command
                    file name.


No list filename specified  - The -l option has been used on
                    the command line without a listing file
                    name.


No xref filename specified  - The -x option has been used on
                    the command line without a cross refer-
                    ence file name.


Not enough preceding IF statements  - The assembler has
                    encountered more EI (end if) statements
                    than IF statements.


Only one TITLE per file allowed  - NAD68 had encountered
                    more than one TITLE directive in a
                    source file.


Opcode %x not found  - While disassembling an instruction,
                    NAD68 cannot find an opcode whose value
                    matches the hex character at the loca-
                    tion specified by the user.


Operand out of range  - The operand is beyond the range of
                    the instruction type being generated.


Operator not unary  - An operator, which is not a unary
                    operator, is being used  with only one
                    operand.


ORG beyond current segment: - The user has specified an
                    address to an ORG directive that sets



Page 7-0000000000000000N0A0D060800M0e0s0s0a0g0e0s00000000000000000000000000000000000000000000000000000000000000000000000098







NAD68 E.R.S.                                 August 27, 1990



                    the location counter outside the range
                    of the current segment.


Page length too large, default assumed  - The user has
                    attempted to set a larger page length
                    than is currently allowed by NAD68.


Page length too small, default assumed  - The user has
                    attempted to set a smaller page length
                    than currently allowed by NAD68.


QUIT directive, exiting NAD68 - The assembler has encoun-
                    tered a QUIT directive in the user's
                    source file which either contains an
                    argument whose value is greater than 0,
                    or  the NAD68 command line contained a
                    -c option.  Control is returned to UNIX
                    or CMF.


QUIT false, aborting assembly  - The assembler has encoun-
                    tered a QUIT directive in the user's
                    source file which contains an argument
                    whose value is less than or equal to
                    zero.  The assembly is aborted under
                    these cases and control returns to NAD68
                    interactive mode.


QUIT undefined, assuming false  - The assembler has encoun-
                    tered a QUIT directive in the user's
                    source file which contains an argument
                    whose value can not be determined.
                    NAD68 will assign a value of zero.


Radix violation     - A character is used in a numerical
                    string that is not valid under the
                    current radix.


Register field not between 0 and F  - The value located in
                    the register field does not contain a
                    valid register value.


Repeat range greater than 640 characters  - The number of
                    characters between the RE and ER



Page 7-0000000000000000N0A0D060800M0e0s0s0a0g0e0s00000000000000000000000000000000000000000000000000000000000000000000000099







NAD68 E.R.S.                                 August 27, 1990



                    directives exceeds 640, the current max-
                    imum for NAD68.


Segment Contains No 68020 Code - The user has  attempted to
                    read code from an image file which does
                    not contain 68020 object code.


Segment number out of range  - The SEG directive specifies a
                    segment number greater than 0xf.


Segment overlap     - Code generated for one segment over-
                    laps code generated for another segment.
                    Check the address values on the SEG
                    directive.


Segment Must Start At 64K Boundary - A SEG directive is
                    being used to specify a starting address
                    which is not at a 64K boundary.


Start Address of This Segment Had Been Defined - A SEG
                    directive has been encountered which
                    redefines the starting address of the
                    segment.  The new starting address is
                    ignored.


Statement sets pc out of bounds  - An attempt has been made
                    to set the pc to a location not address-
                    able by NAD68.


Supersede existing file? (Y or N)  - The user has requested
                    to open an existing file for output.
                    NAD68 requests confirmation before des-
                    troying the existing file.


Syntax error        - NAD68 is unable to determine the value
                    of a statement as it is constructed.


Syntax error in expression  - NAD68 is unable to determine
                    the value of an expression as it is con-
                    structed.





Page 7-0000000000000000N0A0D060800M0e0s0s0a0g0e0s00000000000000000000000000000000000000000000000000000000000000000000000100







NAD68 E.R.S.                                 August 27, 1990



TITLE too long, truncated  - The length of the title is
                    greater than the line length - 46.


Too many arguments in macro definition  - The macro defini-
                    tion declares more than 16 arguments,
                    the maximum currently allowed by NAD68.


Too many IFs. Nesting max = 36  - The user has attempted to
                    nest more than 36 if statement, the
                    current limit for NAD68.


Too many nested repeats. Max = 4 - The user has nested the
                    RE/ER pair to a level greater than 4,
                    the current maximum for NAD68.


Too many operands for opcode  - The statement contains more
                    operands than the opcode allows.


Unable to open command file  - NAD68 is unable to open the
                    command file whose name followed the -c
                    option on the command line; either the
                    file can not be found, is currently
                    locked, or the user does not have per-
                    mission to access the file.


Unable to open file  - NAD68 is unable to open the specified
                    file, either the file can not be found,
                    is currently locked, or the user does
                    not have permission to access the file.


Unable to open list file  - NAD68 is unable to open the file
                    whose name follows the -l option on the
                    command line; either the file can not be
                    found, is currently locked, or the user
                    does not have permission to access the
                    file.


Unable to open xref file  - NAD68 is unable to open the file
                    whose name followed the -x option on the
                    command line; either the file can not be
                    found, is currently locked, or the user
                    does not have permission to access the
                    file.



Page 7-0000000000000000N0A0D060800M0e0s0s0a0g0e0s00000000000000000000000000000000000000000000000000000000000000000000000101







NAD68 E.R.S.                                 August 27, 1990



Undefined expression  - The assembler is unable to determine
                    a value for an expression which contains
                    undefineds.  The expression is used in a
                    statement which does not allow undefined
                    values.


Undefined not allowed  - An undefined symbol is used in a
                    statement that does not allow for unde-
                    fined symbols.


Undefined opcode    - The symbol in the opcode field is not
                    recognized as an opcode or macro.


Unmatched IF statement  - The end of the file was reached
                    before an EI (end if) was found to ter-
                    minate the last IF statement.


Unmatched REPEAT statement  - The end of the file was
                    reached before an ER (end repeat) was
                    found to terminate the last RE (repeat)
                    statement.


36 modules in use. Limit exceeded.  - The user has defined
                    more than 36 modules, the maximum
                    currently allowed in NAD68.
























Page 7-0000000000000000N0A0D060800M0e0s0s0a0g0e0s00000000000000000000000000000000000000000000000000000000000000000000000102







NAD68 E.R.S.                                 August 27, 1990



                8.  Considerations in Coding

8.1  Use of Directives:

8.1.1  _O_R_G

The ORG directive functions as in NAD except that it might
change the segment number implicitly when trying to ORG from
current segment to a location which is in the other previ-
ously user-declared segement.  If the directive is used to
reserve space for future code, such as patches, the space
reserved should be increased.  Because there are multiple
68020 statement per NAD statement, more space is required
for 68020 object code.

The ORG directive is a frequent cause of the "segment over-
lap" warning.  This message is caused by ORGing to an
address before the start of the current segment or after the
start of another segment.

8.1.2  _S_E_G

The SEG directive functions as in NAD.  It has an additional
feature of allowing the user to specify the starting address
of the segment.  This address must be at a 64K boundary.
This directive is frequently used to separate code and data
areas, and to separate specialized code areas.

Because of the increased space required for 68020 code gen-
erated from NAD source, the user may find that existing
divisions do not allow sufficient space for code areas.

8.1.3  _L_I_S_T__F

Listing of the program counter and hex code will produce
even more paper than before.  The listing may be viewed on
line.  Saving listings will require much disk space and a
large load time for the UNIX editor.  I suggest using the
NOLIST command frequently.

8.2  SVC calls

If there is not sufficient informations on the NAD source
line to generate the equivalent 68020 calls, the programmer
may use the TARGET directive  to set a target processor
flag.  With conditional assembly based on this flag SVC
calls and equivalent 68020 calls can exist in the same
source file.

Not all SVCs available on the Engine are available on the
Turbo Engine.  Not all SVCs function the same on both



Page 8-00000000000C0o0n0s0i0d0e0r0a0t0i0o0n0s00i0n00C0o0d0i0n0g000000000000000000000000000000000000000000000000000000000000000000103







NAD68 E.R.S.                                 August 27, 1990



machines.  Check the _I_S_I_S-_6_8 _R_e_f_e_r_e_n_c_e _S_p_e_c_i_f_i_c_a_t_i_o_n for
more information on this topic.

8.3  Microcode

Microcode that is produced by user generated hex code (using
BC...) cannot be identified.

8.4  Addressing

The use of numbers or symbols which represent NAD instruc-
tions lengths should be avoided.  NAD68 will be unable to
determine the new address required.  The programmer will be
notified of these areas if the Q68ON directive is in effect.
The assembler will generate code as specified.

The NAD instructions most likely to use  instruction lengths
in expressions are the jump variations.  The cases I have
seen have been short jumps, less than 12 bytes.

8.5  Instruction Usage

The following section discussed the characteristics of NAD68
produced 68020 instructions.

8.5.1  _W_o_r_d_s_,__H_a_l_f_w_o_r_d_s_,__a_n_d__B_y_t_e_s

The smaller the  piece of memory addressed, the more code
generated by NAD68 to perform the operation.  This means
instructions which manipulate halfwords generate more code
than instructions which manipulate fullwords.  The execution
time on the 68020 also increases for this set of code.

The exception to this rule are the immediates and the shifts
which generate the same amount of code for all sizes of
operands.

8.5.2  _M_e_m_o_r_y__a_n_d__R_e_g_i_s_t_e_r_s

As much code is generated for a memory reference as for a
pseudo-engine register reference.  The time to execute this
code is equivalent.  Currently NAD registers are really in
memory and not registers at all.

8.5.3  _M_u_l_t_i_p_l_y_,__D_i_v_i_d_e__a_n_d__S_h_i_f_t

As is probably expected, shift is faster and generates less
code than divide or multiply.  The combination of shift and
subtract required as many bytes as a divide and could take
only 60% of the time.  In the case of halfwords, the combi-
nation of shift and subtract requires a little more code but



Page 8-00000000000C0o0n0s0i0d0e0r0a0t0i0o0n0s00i0n00C0o0d0i0n0g000000000000000000000000000000000000000000000000000000000000000000104







NAD68 E.R.S.                                 August 27, 1990



slightly less time.

8.6  Pseudo Registers

During execution of code generated by NAD68, the 68020
register A5 must contain the address of the area containing
the Engine pseudo  registers.  The initialization of A5 is
done in STRTLIB.














































Page 8-00000000000C0o0n0s0i0d0e0r0a0t0i0o0n0s00i0n00C0o0d0i0n0g000000000000000000000000000000000000000000000000000000000000000000105







NAD68 E.R.S.                                 August 27, 1990



                 9.   Sample NAD68 Programs

The following page contains a sample NAD68 program listing.
It demonstrates the use of some of the NAD68 features in a
fragment of NAD source code.

This piece of code will not execute in a Turbo Engine.

The A5 register has not been set up to contain the address
of the pseudo registers.












































Page 9-000000000000S0a0m0p0l0e00N0A0D060800P0r0o0g0r0a0m0s00000000000000000000000000000000000000000000000000000000000000000000106




 {3'I