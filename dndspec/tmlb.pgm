












                                 TTTTYYYYMMMMLLLLIIIIBBBB

                           PPPPrrrrooooggggrrrraaaammmmmmmmeeeerrrr''''ssss GGGGuuuuiiiiddddeeee
                               _V_e_r_s_i_o_n _2._0_3


                                Alex Ting

                             August 17, 1989


                                MMMMDDDDCCCC----TTTTYYYYMMMMNNNNEEEETTTT
                      NNNNeeeettttwwwwoooorrrrkkkk TTTTeeeecccchhhhnnnnoooollllooooggggyyyy DDDDeeeevvvveeeellllooooppppmmmmeeeennnntttt
           ____________________________________________________
         |                                                    |
         |  MMMMDDDDCCCC----TTTTYYYYMMMMNNNNEEEETTTT''''ssss pppprrrroooopppprrrriiiieeeettttaaaarrrryyyy rrrriiiigggghhhhttttssss aaaarrrreeee iiiinnnncccclllluuuuddddeeeedddd iiiinnnn   |
         |  tttthhhheeee iiiinnnnffffoooorrrrmmmmaaaattttiiiioooonnnn ddddiiiisssscccclllloooosssseeeedddd hhhheeeerrrreeeeiiiinnnn....  TTTThhhheeee rrrreeeecccciiiippppiiiieeeennnntttt,,,, |
         |  bbbbyyyy rrrreeeecccceeeeiiiivvvviiiinnnngggg tttthhhhiiiissss ddddooooccccuuuummmmeeeennnntttt,,,, aaaaggggrrrreeeeeeeessss tttthhhhaaaatttt nnnneeeeiiiitttthhhheeeerrrr   |
         |  tttthhhhiiiissss ddddooooccccuuuummmmeeeennnntttt nnnnoooorrrr tttthhhheeee iiiinnnnffffoooorrrrmmmmaaaattttiiiioooonnnn ddddiiiisssscccclllloooosssseeeedddd hhhheeeerrrreeeeiiiinnnn|
         |  nnnnoooorrrr aaaannnnyyyy ppppaaaarrrrtttt tttthhhheeeerrrreeeeooooffff sssshhhhaaaallllllll bbbbeeee rrrreeeepppprrrroooodddduuuucccceeeedddd oooorrrr       |
         |  ttttrrrraaaannnnssssffffeeeerrrrrrrreeeedddd ttttoooo ooootttthhhheeeerrrr ddddooooccccuuuummmmeeeennnnttttssss oooorrrr uuuusssseeeedddd oooorrrr         |
         |  ddddiiiisssscccclllloooosssseeeedddd ttttoooo ooootttthhhheeeerrrrssss ffffoooorrrr mmmmaaaannnnuuuuffffaaaaccccttttuuuurrrriiiinnnngggg oooorrrr aaaannnnyyyy ooootttthhhheeeerrrr|
         |  ppppuuuurrrrppppoooosssseeee eeeexxxxcccceeeepppptttt aaaassss ssssppppeeeecccciiiiffffiiiiccccaaaallllllllyyyy aaaauuuutttthhhhoooorrrriiiizzzzeeeedddd iiiinnnn      |
         | _w_wwwr_rrri_iiit_ttti_iiin_nnng_ggg_b_bbby_yyy_M_MMMD_DDDC_CCC-_---T_TTTY_YYYM_MMMN_NNNE_EEET_TTT._..._____________________________|
































       TYMLIB Programmer's Guide                    August 17, 1989



                             1.  IIIInnnnttttrrrroooodddduuuuccccttttiiiioooonnnn



       1.1  WWWWhhhhaaaatttt iiiissss TTTTYYYYMMMMLLLLIIIIBBBB????

       TYMNET Library (TTTTYYYYMMMMLLLLIIIIBBBB) is developed by the UNIX Systems
       Section as a package of C library network routines for the
       computers running UNIXr operating system. It uses a TYMNET
       XCOM interface, a TYMNET TYMCOM interface, or both, to pro-
       vide these computers convenient access to both private and
       public networks that are based on TYMNET technology.  It
       allows these UNIX hosts to reliably exchange packets of
       either ASCII or binary data with other systems on these net-
       works.

       This _G_u_i_d_e describes all of the TTTTYYYYMMMMLLLLIIIIBBBB routines.  It is
       intended for those C programmers who have access to the TTTTYYYYMMMM----
       LLLLIIIIBBBB package and would like to develop distributed systems
       with remote TYMNET hosts.  It is assumed that the programmer
       is familiar with TYMNET circuit protocols and host conven-
       tions on the remote systems, as well as UNIX system func-
       tions and C language.


       1.2  HHHHoooowwww ttttoooo uuuusssseeee TTTTYYYYMMMMLLLLIIIIBBBB????

       The TTTTYYYYMMMMLLLLIIIIBBBB is /_u_s_r/_t_y_m/_l_i_b/_l_i_b_t_y_m_n_e_t._a, which contains all
       functions described in this _G_u_i_d_e here.  These functions are
       automatically loaded as needed by the C compiler _c_c(1). The
       link editor searches this library under the "-ltymnet"
       option.

       NNNNooootttteeee::::                                                         |
       Many of the functions in TYMLIB call and/or refer to other    |
       functions and external variables described in this document   |
       and in UNIX Manual Section 2 (System Calls).  If a program    |
       inadvertently defines a function or external variable with    |
       the same name, the TYMLIB version of the function or exter-   |
       nal variable may not be loaded.  The _l_i_n_t(1) program checker  |
       reports name conflicts of this kind as 'multiple declara-     |
       tions' of the names in question.  Use of _l_i_n_t is highly       |
       recommended.



       __________

         * UNIX is a registered trademark of AT&T Bell
           Laboratories.




                               Introduction                Page 1-1







       TYMLIB Programmer's Guide                    August 17, 1989



       As with normal arguments, all return codes and values from
       TTTTYYYYMMMMLLLLIIIIBBBB functions are of type integer unless otherwise noted.
       Most of TTTTYYYYMMMMLLLLIIIIBBBB calls have one or more error returns.  An
       error condition is always indicated by a -1 return value;
       the individual descriptions specify the details.  An error
       number is also made available in the external variable
       _c_i_r__e_r_r, which is not cleared on successful calls.  Thus
       _c_i_r__e_r_r should be tested only after an error has occurred.

       The include file <<<<ttttyyyymmmm////ttttyyyymmmmnnnneeeetttt....hhhh>>>> contains definitions of all
       the TYMLIB errors and their names.  For the meanings of
       these errors, see the TYMLIB Error Summary, Appendix B.


       1.3  SSSSiiiiggggnnnnaaaallllssss uuuusssseeeedddd iiiinnnn TTTTYYYYMMMMLLLLIIIIBBBB

       TTTTYYYYMMMMLLLLIIIIBBBB always requests to receive and handle a _S_I_G_U_R_G signal
       when an urgent condition is present on a circuit.  This sig-
       nal may indicate that the circuit has been reset, the X.25
       interface has been restarted or interrupt data has been
       received.  (Note that the signal _S_I_G_U_R_G may have had an ori-
       gin somewhere other than the TTTTYYYYMMMMLLLLIIIIBBBB package.)  In addition,
       TTTTYYYYMMMMLLLLIIIIBBBB will also request to receive and handle a _S_I_P_I_P_E sig-
       nal when sending data to a circuit that may or may not have
       been zapped.  If a signal arrives during a TTTTYYYYMMMMLLLLIIIIBBBB call, TTTTYYYYMMMM----
       LLLLIIIIBBBB will execute special code to take care of the signal and
       return an error on such call.

       A more general explanation of signals may be found in UNIX
       documentation (e.g. SUN's UNIX Interface Overview, chapter
       4).























                               Introduction                Page 1-2







       TYMLIB Programmer's Guide                    August 17, 1989



                          2.  TTTTyyyymmmmnnnneeeetttt IIIInnnntttteeeerrrrffffaaaacccceeeessss



       2.1  XXXXCCCCOOOOMMMM vvvvssss TTTTYYYYMMMMCCCCOOOOMMMM

       The TYMNET XCOM interface provides a X.25 interface to
       access a network based on TYMNET technology.  TTTTYYYYMMMMLLLLIIIIBBBB commun-
       icates with XCOM using a Sunlink X.25 software package over
       RS-232-C or RS-449 ports. The Sunlink X.25 provides 19.2
       kbits/sec maximum transmission speed and up to 64 virtual
       circuits.

       The TYMNET TYMCOM provides a set of individual asynchronous
       line interfaces to an attached host computer.  TTTTYYYYMMMMLLLLIIIIBBBB com-
       municates with TYMCOM using the Systech MTI terminal driver
       over RS-232-C ports.  The maximum transmission speed is 4800
       bits/sec and the number of circuits available is limited to
       those being hardwired to a special TYMCOM slot.

       When a user tries to build a Tymnet circuit, TTTTYYYYMMMMLLLLIIIIBBBB checks
       in /_e_t_c/_t_y_m_l_i_b._c_o_n_f file to see whether a specified Tymnet
       interface is available, and if XCOM is the interface to be
       used, TTTTYYYYMMMMLLLLIIIIBBBB will also check in /_e_t_c/_t_y_m_l_i_b._x_c_o_m file to
       obtain certain XCOM Tymfile information.


       2.2  ggggeeeettttttttyyyymmmmoooopppptttt(((())))

       To find out which types of Tymnet interfaces are available
       on a system, call _g_e_t_t_y_m_o_p_t.

            _o_p_t = _g_e_t_t_y_m_o_p_t();
            _i_n_t _o_p_t;

       The returned _o_p_t is a bit array indicating which types of
       interfaces are available.  Bits are numbered starting at 0
       from the right.


                     _______________________________
                    |__b__bbbi__iiit__ttt__p__pppo__ooos__sssi__iiit__ttti__iiio__ooon__nnn______i__iiin__nnnt__ttte__eeer__rrrf__fffa__aaac__ccce__eee__t__ttty__yyyp__pppe__eee_|_
                    |      0      |  TYMCOM        |
                    |______________|_________________|
                    |______1________|__X_C_O_M____________|
                    |     2-30    |  reserved      |
                    |______________|_________________|







                            Tymnet Interfaces              Page 2-1







       TYMLIB Programmer's Guide                    August 17, 1989



       2.3  sssseeeettttttttyyyymmmmoooopppptttt(((())))

       To tell TTTTYYYYMMMMLLLLIIIIBBBB operations which type of Tymnet interface to
       be used, call _s_e_t_t_y_m_o_p_t.

            _e_r_r_o_r = _s_e_t_t_y_m_o_p_t(_o_p_t);
            _i_n_t _e_r_r_o_r, _o_p_t;

       The argument _o_p_t is a bit array specifying the type of
       interface to be used.  Bits are numbered starting at 0 from
       the right.


                     _______________________________
                    |__b__bbbi__iiit__ttt__p__pppo__ooos__sssi__iiit__ttti__iiio__ooon__nnn______i__iiin__nnnt__ttte__eeer__rrrf__fffa__aaac__ccce__eee__t__ttty__yyyp__pppe__eee_|_
                    |      0      |  Use TYMCOM    |
                    |______________|_________________|
                    |______1________|__U_s_e__X_C_O_M________|
                    |     2-30    |  reserved      |
                    |______________|_________________|


       _s_e_t_t_y_m_o_p_t returns 0 if the specified interface is available,
       and -1 if not.  If more than one bit is set in the argument
       _o_p_t, _s_e_t_t_y_m_o_p_t will also return a value of -1.

       NNNNooootttteeee::::
       By default, XCOM interface will be used whenever it is
       available.


       2.4  eeeerrrrrrrroooorrrrssss

       _s_e_t_t_y_m_o_p_t may return one of the following errors:

           TYM_INVAL(122)            Invalid argument: more than
                                     one bit is set in _o_p_t

           NO_TYMDEV(200)            No Tymnet interface available

           NO_TYMCOM(201)            No TYMCOM interface available

           NO_TYMX25(202)            No XCOM interface available

           NO_TYMFILE(210)           TYMLIB cannot open
                                     /etc/tymlib.conf, which may
                                     not have been installed.







                            Tymnet Interfaces              Page 2-2







       TYMLIB Programmer's Guide                    August 17, 1989



       2.5  eeeexxxxaaaammmmpppplllleeee

       The following code fragement shows how one might call _g_e_t_-
       _t_y_m_o_p_t and _s_e_t_t_y_m_o_p_t to determine which Tymnet interface
       should be used for a specific application:


              .........
            #include <tym/tymnet.h>
              .........
            #define ERROR                 -1
            #define TYMX25                0x000002
              .........

            {
                         int tymopt;

                         if ((tymopt = gettymopt()) == ERROR) {
                             /* An error occurred during the gettymopt */
                                      switch(cir_err) {
                                      case NO_TYMFILE:
                                           /* Cannot open /etc/tymlib.conf file */
                                      ........
                                      }
                                      return(ERROR);
                         }
                         if (tymopt & TYMX25) {
                             /* XCOM interface available */
                                      settymopt(TYMX25);
                                      ........
                         } else {
                             /* No XCOM interface available */
                                      ........
                         }
                         ........
            }


















                            Tymnet Interfaces              Page 2-3







       TYMLIB Programmer's Guide                    August 17, 1989



                       3.  CCCCrrrreeeeaaaattttiiiinnnngggg TTTTYYYYMMMMNNNNEEEETTTT CCCCiiiirrrrccccuuuuiiiittttssss

       The basic building block for communication through TTTTYYYYMMMMLLLLIIIIBBBB is
       the _c_i_r_c_u_i_t _d_e_s_c_r_i_p_t_o_r.  A _c_i_r_c_u_i_t _d_e_s_c_r_i_p_t_o_r is a small
       positive integer which may be used in later TTTTYYYYMMMMLLLLIIIIBBBB function
       calls to access a TYMNET network and transfer data.


       3.1  bbbbuuuuiiiillllddddcccciiiirrrr(((())))

       To build a normal circuit to a TYMNET host, call _b_u_i_l_d_c_i_r.

            _c_d = _b_u_i_l_d_c_i_r(_u_s_e_r_n_a_m_e, _p_a_s_s_w_o_r_d, _t_i_d)
            _i_n_t  _c_d, _t_i_d;
            _c_h_a_r *_u_s_e_r_n_a_m_e, *_p_a_s_s_w_o_r_d;

       The _u_s_e_r_n_a_m_e argument specifies the target host and consists
       of a username, and optionally, a ":host". (If the ":host" is
       omitted, the "home" system of the username is used as the
       target host.)  A leading dash (-) in a _u_s_e_r_n_a_m_e indicates a
       X.121 address.

       The _p_a_s_s_w_o_r_d argument is the password for the username. (If
       the username has no associated password, the _p_a_s_s_w_o_r_d argu-
       ment should be 0.)  The _t_i_d argument is the terminal iden-
       tifier (TID) code which is ignored in this version of
       library package.

       _b_u_i_l_d_c_i_r returns a circuit descriptor if the circuit is
       built to the target host, otherwise it returns -1 and the
       global variable _c_i_r__e_r_r indicates the reason for the
       failure.


       3.2  bbbbuuuuiiiillllddddaaaauuuuxxxx(((())))

       To build an auxiliary circuit to a TYMNET host, call _b_u_i_l_-
       _d_a_u_x.
       (However, it is not yet implemented at present time because
       of network security concern.)

            _c_d = _b_u_i_l_d_a_u_x(_u_s_e_r_n_a_m_e)
            _i_n_t _c_d;
            _c_h_a_r *_u_s_e_r_n_a_m_e;

       The _u_s_e_r_n_a_m_e argument specifies the target host and consists
       of a username, and optionally, a ":host". (If the ":host" is
       omitted, the "home" system of the username is used as
       target host.)  A leading dash (-) in a _u_s_e_r_n_a_m_e indicates a
       X.121 address.




                         Creating TYMNET Circuits          Page 3-1







       TYMLIB Programmer's Guide                    August 17, 1989



       _b_u_i_l_d_a_u_x returns a circuit descriptor if the circuit is
       built to the target host, otherwise it returns -1 and the
       global variable _c_i_r__e_r_r indicates the reason for the
       failure.


       3.3  ffffaaaakkkkeeeeaaaauuuuxxxx(((())))

       To request a normal circuit to be presented to the destina-
       tion host as an auxiliary circuit, call _f_a_k_e_a_u_x.

            _c_d = _f_a_k_e_a_u_x(_u_s_e_r_n_a_m_e, _p_a_s_s_w_o_r_d)
            _i_n_t _c_d;
            _c_h_a_r *_u_s_e_r_n_a_m_e, *_p_a_s_s_w_o_r_d;

       The _u_s_e_r_n_a_m_e argument specifies the target host and consists
       of a username, and optionally, a ":host". (If the ":host" is
       omitted, the "home" system of the username is used as the
       target host.)  A leading dash (-) in a _u_s_e_r_n_a_m_e indicates a
       X.121 address.

       The _p_a_s_s_w_o_r_d argument is the password for the username. (If
       the username has no associated password, the _p_a_s_s_w_o_r_d argu-
       ment should be 0.)

       _f_a_k_e_a_u_x returns a circuit descriptor if the circuit is built
       to the target host, otherwise it returns -1 and the global
       variable _c_i_r__e_r_r indicates the reason for the failure.


       3.4  ggggaaaatttteeeewwwwaaaayyyy(((())))

       To extend a TYMNET circuit from a gateway to another gateway
       or a host, call _g_a_t_e_w_a_y.

            _e_r_r_o_r = _g_a_t_e_w_a_y(_u_s_e_r_n_a_m_e, _p_a_s_s_w_o_r_d, _c_d)
            _i_n_t _e_r_r_o_r, _c_d;
            _c_h_a_r *_u_s_e_r_n_a_m_e, *_p_a_s_s_w_o_r_d;

       The _u_s_e_r_n_a_m_e argument specifies the target host and consists
       of a username, and optionally, a ":host". (If the ":host" is
       omitted, the "home" system of the username is used as the
       target host.)  The _p_a_s_s_w_o_r_d argument is the password for the
       username. (If the username has no associated password, the
       _p_a_s_s_w_o_r_d argument should be 0.)  The _c_d argument is the cir-
       cuit descriptor from an earlier _b_u_i_l_d_c_i_r, _b_u_i_l_d_a_u_x or _f_a_k_-
       _e_a_u_x call.

       _g_a_t_e_w_a_y returns 0 if the circuit is extended to the target
       host, otherwise it returns -1 and the global variable
       _c_i_r__e_r_r indicates the reason for the failure.



                         Creating TYMNET Circuits          Page 3-2







       TYMLIB Programmer's Guide                    August 17, 1989



       3.5  ttttyyyymmmmtttthhhhrrrruuuuppppuuuutttt(((())))

       The default throughput of a circuit is 9600 bps; however,
       the programmer can set the throughput for the circuit to be
       built, by using _t_y_m_t_h_r_u_p_u_t.

            _e_r_r_o_r = _t_y_m_t_h_r_u_p_u_t(_b_p_s)
            _i_n_t  _b_p_s;

       The argument _b_p_s is an integer having one of the following
       value:

             0       default throughput (9600 bps)

             7       1200 bps

             8       2400 bps

             9       4800 bps

           10        9600 bps

           11        19200 bps

       NNNNooootttteeee::::                                                         |
       When TYMLIB is using a X.25 interface, XCOM will translate    |
       the CCITT throughput class to one of the four TYMNET circuit  |
       throughput class:                                             |

       ____________________________________________________________  |
      |                                   TYMNET                  |  |
      |     CCITT                        Circuit                  |  |
      |   Throughput       CCITT        Throughput       TYMNET   |  |
      |__________C__l__a__s__s________________________B__P__S________________________C__l__a__s__s__________________________C__P__S___________|_  ||
      |       7       |    1200    |        01       |     160    |  |
      |________________|_____________|__________________|_____________|  |
      |_______8_________|____2_4_0_0______|________0_2_________|_____5_1_2______|  ||
      |       9       |    4800    |        02       |     512    |  |
      |________________|_____________|__________________|_____________|  |
      |_______1_0________|____9_6_0_0______|________0_3_________|____2_0_4_8______|  ||
      |       11      |    19600   |        03       |    2048    |  |
      |________________|_____________|__________________|_____________|  ||||||

       CCITT throughput classes are expressed in maximum bit-per-    |
       second (bps) transmission rates; TYMNET throughput classes    |
       are expressed in maximum character-per-second (cps)           |
       transmission rates.                                           |

       The TYMNET circuit speed is determined by the Supervisor and  |
       is limited by the physical constraints of the interface and   |
       the network.  For example, TYMNET limits the default          |
       throughput class on 4.8 kilobits-per-second (kbps)            |


                         Creating TYMNET Circuits          Page 3-3







       TYMLIB Programmer's Guide                    August 17, 1989



       interfaces to 4800 bps.





















































                         Creating TYMNET Circuits          Page 3-4







       TYMLIB Programmer's Guide                    August 17, 1989



       3.6  eeeerrrrrrrroooorrrrssss

       _b_u_i_l_d_c_i_r, _f_a_k_e_a_u_x and _g_a_t_e_w_a_y may return one of the follow-
       ing errors:

           B4_BADUSR(2)              The username is invalid.

           B4_BADPWD(3)              The password is invalid.

           B4_HOSTBUSY(11)           The host is not available.

           B4_NOACCESS(16)           The access is not permitted.

           B4_BADHOST(18)            The host number is invalid.

           TYM_BADCD(109)            The circuit descriptor is
                                     invalid for a _g_a_t_e_w_a_y call.

           TYM_AGAIN(111)            It indicates out of X.25
                                     ports. The maximum number of
                                     X.25 virtual circuits is 64.

           NO_TYMDEV(200)            TYMNET interface is not avail-
                                     able.






























                         Creating TYMNET Circuits          Page 3-5







       TYMLIB Programmer's Guide                    August 17, 1989



       3.7  XXXXCCCCOOOOMMMM EEEExxxxppppllllaaaaiiiinnnneeeedddd                                           |

       If TYMLIB is using a XCOM interface, a circuit between SUN    |
       host and XCOM interface will sometimes be built even if the   |
       Supervisor (SUP) did not build the circuit to the destina-    |
       tion host interface, say, because of incorrect password.      |
       This happens if the Talk To Supervisor (TKSUP) switch option  |
       of the PKTOPT macro in XCOM Tymfile is set, to allow the      |
       user three attempts to reenter the login string.  However,    |
       this is not part of standard X.25 protocol and SUNLink will   |
       return a successful connection message.  To determine         |
       whether the circuit has been built to the destination host    |
       or not, TYMLIB will peek at the incoming data and look for    |
       any SUP message, such as "error, type password". If it does,  |
       it will zap the circuit and return -1 with cir_err indicat-   |
       ing the cause.  If TYMLIB did not detect any data coming      |
       within a time limit, say 4 secs, it will assume the circuit   |
       has been built to the destination host and return a circuit   |
       descriptor to the caller.                                     |

       There are some shortcomings with this approach:               |

         +o It penalizes the "good" circuits by delaying the return   |
           from buildcir().                                          |

         +o It cannot just read the first message and assume this is  |
           a good circuit if the message is not one of the SUP mes-  |
           sages.  This is becuase, with TKSUP on, the XCOM will     |
           think the DTE is running as PAD and will from time to     |
           time send a PAD control message to SUN, such as "Set      |
           Parameters" or "Invitation to Clear".  SUNLink will in    |
           turn pass these messages as a Qualified data messages     |
           (with Q-bit set) to TYMLIB and these Q-messages may or    |
           may not come before any SUP message.  TYMLIB will skip a  |
           fixed number of times, say 10, over these messages and    |
           will assume a good circuit if no SUP message has come in  |
           between.                                                  |

         +o If the destination host sends back a message just like a  |
           SUP message, TYMLIB will erroneously assume that it       |
           comes from the SUP and therefore clear the circuit        |
           before return a -1 to the caller.                         |

       The following are some suggestions on how to better use       |
       buildcir():                                                   |

         1.  The user can use bldcir_prompt() to pass some HOST      |
             prompt messages, such as "C>" and "ID?", so buildcir()  |
             can use them together with SUP messages to check the    |
             status of a circuit in a more positive way.             |




                         Creating TYMNET Circuits          Page 3-6







       TYMLIB Programmer's Guide                    August 17, 1989



         2.  The user can use bldcir_parm() to set the timeout       |
             value and number of skips over data messages for        |
             buildcir().                                             |

         3.  The user can use bldcir_chk() to turn on or off the     |
             checking feature in buildcir(), which will return to    |
             the caller as soon as it returns from the SUNLink X.25  |
             connect() call, with the same status.  The user can     |
             then use tymread() to check the incoming data and look  |
             for an application-specific host prompt message and,    |
             if he cannot find it, he can also use net_error() to    |
             check for any SUP messages. The user can response to    |
             the incoming messages more intelligently, for example,  |
             reentering a login string via tymwrite() instead of     |
             zapping the old circuit and then trying to build a new  |
             circuit.                                                |






































                         Creating TYMNET Circuits          Page 3-7







       TYMLIB Programmer's Guide                    August 17, 1989



       3.8  eeeexxxxaaaammmmpppplllleeee

            #include <tym/tymnet.h>
               .......
            #define      NUMGATE    5           /* max number of gateways */
            #define      ERROR     -1
            #define      OK         0
            #define      TEXT       1

            {
                         char uname[80], passwd[80], netbuf[128];
                         char *gateways[NUMGATE];         /* gateway names */
                         int cd, gate, status, error, sz;

                         /*   initialize gateways[] and get gateways login strings   */
                            ........
                         cd = gate = 0;
                         /*   build circuit to gateways   */
                            ........
                         while (gate < NUMGATE && gateways[gate]) {
                                 if (!gate)
                                           status = cd = buildcir(gateways[gate],0,0);
                                 else
                                           status = gateway(gateways[gate],0,cd);
                                 if (status == ERROR) {
                                           ........
                                 }
                                 gate++;
                         }
                         if (!gate) {     /*   build circuit to host   */
                                 status = cd = buildcir(uname, passwd, 0);
                                 if (status == ERROR) {
                                           switch(cir_err) {
                                           case B4_BADUSR:
                                                .........
                                           case B4_BADPWD:
                                                .........
                                           }
                                 }
                         } else {         /*   extend cir to host   */
                                 status = gateway(uname, passwd, fd);
                                 if (status == ERROR) {
                                           ........
                                 }
                         }
                         .........
            }







                         Creating TYMNET Circuits          Page 3-8







       TYMLIB Programmer's Guide                    August 17, 1989



                            4.  RRRReeeecccceeeeiiiivvvviiiinnnngggg DDDDaaaattttaaaa



       4.1  ttttyyyymmmmrrrreeeeaaaadddd(((())))

       To read data from a TYMNET circuit, call _t_y_m_r_e_a_d.

            _e_r_r_o_r = _t_y_m_r_e_a_d(_c_d, _b_u_f, _n_b_y_t_e_s, _r_e_t_u_r_n__s_z)
            _i_n_t _e_r_r_o_r, _c_d, _n_b_y_t_e_s, *_r_e_t_u_r_n__s_z;
            _c_h_a_r *_b_u_f;

       _t_y_m_r_e_a_d attempts to read _n_b_y_t_e_s bytes of data from the cir-
       cuit referenced by the circuit descriptor _c_d to the buffer
       pointed to by _b_u_f.
       _r_e_t_u_r_n__s_z points to the variable which will hold the number
       of bytes actually read and placed in _b_u_f after _t_y_m_r_e_a_d
       returns.
       The default time limit for _t_y_m_r_e_a_d is 20 seconds.  You can
       use _s_e_t_t_i_m_e_o_u_t (see 4.4) to change the default value.

       _t_y_m_r_e_a_d has two modes which can be set by _s_e_t_m_o_d_e (see 4.3):

       bbbbiiiinnnnaaaarrrryyyy      The normal mode. In this mode all 8 bits are
                   passed through.  Input data will be transferred
                   from the circuit into _b_u_f until _n_b_y_t_e_s of data
                   are read, timed out or an error condition is
                   encountered.

       tttteeeexxxxtttt        In this mode the high order bits are masked off
                   (ANDed with 0177).  Input data will be
                   transferred from the circuit into _b_u_f until
                   _n_b_y_t_e_s-1 characters are read, a new-line charac-
                   ter is read and transferred into _b_u_f, timed out
                   or an error condition is encountered.  The
                   string is then terminated with a null character.

       _t_y_m_r_e_a_d returns 0 if _n_b_y_t_e of characters are read, or if it
       is in the text mode and a new-line character is read, other-
       wise it returns -1 and the global variable _c_i_r__e_r_r indicates
       the reason for the failure.


       4.2  wwwwaaaaiiiittttffffoooorrrr(((())))

       To wait for a specified ASCII string from a circuit, call
       _w_a_i_t_f_o_r.

            _e_r_r_o_r = _w_a_i_t_f_o_r(_p_a_t_t_e_r_n, _c_d)
            _i_n_t _e_r_r_o_r, _c_d;
            _c_h_a_r *_p_a_t_t_e_r_n;



                              Receiving Data               Page 4-1







       TYMLIB Programmer's Guide                    August 17, 1989



       The _p_a_t_t_e_r_n argument is a fixed string -- no regular expres-
       sion metacharacters are supported.  The _c_d argument is the
       circuit descriptor returned from an earlier _b_u_i_l_d_c_i_r, _b_u_i_l_-
       _d_a_u_x or _f_a_k_e_a_u_x call.
       The default time limit for _w_a_i_t_f_o_r is 20 seconds.  You can
       use _s_e_t_t_i_m_e_o_u_t (see 4.4) to change the default value.

       _w_a_i_t_f_o_r returns 0 if there is an exact match, otherwise it
       returns -1 and the global variable _c_i_r__e_r_r indicates the
       reason for the failure.

       NNNNooootttteeee::::
       _w_a_i_t_f_o_r needs an exact match and data coming before the pat-
       tern is discarded.


       4.3  sssseeeettttmmmmooooddddeeee(((())))

       To set the binary or text mode for _t_y_m_r_e_a_d, call _s_e_t_m_o_d_e.

            setmode(mode)
            int mode;

       The argument _m_o_d_e is an integer having one of the following
       value:

            0                set binary mode
            1                set text mode

       A value of 0, indicating success, is always returned.


       4.4  sssseeeettttttttiiiimmmmeeeeoooouuuutttt(((())))

       This routine allows a user to specify how long he wants to
       wait if there are time intervals when _n_o _d_a_t_a is coming over
       the circuit.

       To set a time limit for the _t_y_m_r_e_a_d and _w_a_i_t_f_o_r operations,
       call _s_e_t_t_i_m_e_o_u_t.

            _t_i_m_e = _s_e_t_t_i_m_e_o_u_t(_s_e_c_s)
            _i_n_t _t_i_m_e, _s_e_c_s;

       If _s_e_c_s is positive, it sets a new time limit for both _t_y_m_-
       _r_e_a_d and _w_a_i_t_f_o_r.  If _s_e_c_s is zero, it indicates no time
       limit, and if _s_e_c_s is negative, it leaves the time limit
       unchanged.

       The return value is the previous time limit.




                              Receiving Data               Page 4-2







       TYMLIB Programmer's Guide                    August 17, 1989



       NNNNooootttteeee::::
       The default value of time limit for both _t_y_m_r_e_a_d and _w_a_i_t_f_o_r
       is 20 seconds.


       4.5  eeeerrrrrrrroooorrrrssss

       _t_y_m_r_e_a_d and _w_a_i_t_f_o_r may return one of the following errors:

           TYM_ZAP(51)               The circuit was zapped during
                                     the call.

           TYM_INTR(104)             The call is interrupted by a
                                     signal.

           TYM_IO(105)               Some physical I/O error
                                     occurred.

           TYM_BADCD(109)            _c_d is not a valid circuit
                                     descriptor for receiving data.

           TYM_NOMEM(112)            _t_y_m_r_e_a_d attempts to save the
                                     unread data in a temporary
                                     buffer but _n_b_y_t_e_s size of
                                     memory could not be allocated
                                     from _m_a_l_l_o_c.

           TYM_BADADDR(114)          _b_u_f address is invalid; it is
                                     outside the process's allo-
                                     cated space.

           TYM_BLOCK(135)            No data is currently available
                                     on the circuit.

           TIM_EMPTY(206)            Time expires for _t_y_m_r_e_a_d and
                                     there is no data in _b_u_f.

           TIM_PARTIAL(207)          Time expires for _t_y_m_r_e_a_d and
                                     there is some data in _b_u_f.

           TIM_NOPAT(208)            Time expires for _w_a_i_t_f_o_r and
                                     the pattern is not found.



       4.6  eeeexxxxaaaammmmpppplllleeee








                              Receiving Data               Page 4-3







       TYMLIB Programmer's Guide                    August 17, 1989



               .......
            #include <tym/tymnet.h>
               .......
            #define      TEXT   1
               .......
            {
                         char netbuf[128];
                         int  error, sz;

                         setmode(TEXT);   /* text mode for tymread */
                         settimeout(5);   /* 5 seconds limit */











































                              Receiving Data               Page 4-4







       TYMLIB Programmer's Guide                    August 17, 1989



                         error = tymread(cd, netbuf, sizeof(netbuf), &sz);
                         switch(error) {
                         case 0:
                                  /* Normal return: data in netbuf to be processed */
                                  ...........
                         case -1:
                                  /* Timeout or an error occurred during the tymread */
                                  switch(cir_err) {
                                  case TYM_ZAP:          /* Circuit was zapped */
                                           ..........
                                  case TIM_EMPTY:        /* Timeout -- buffer empty */
                                  ..........
                                  case TIM_PARTIAL:      /* Timeout -- some data in buffer */
                                           ..........
                                  case TYM_BADCD:        /* cd is not a valid circuit descriptor */
                                           ..........
                                  default:               /* Other errors */
                                  ..........
                                  }
                                  break;
                         default:
                                  ..........
                         }

            }





























                              Receiving Data               Page 4-5







       TYMLIB Programmer's Guide                    August 17, 1989



                             5.  SSSSeeeennnnddddiiiinnnngggg DDDDaaaattttaaaa



       5.1  ttttyyyymmmmwwwwrrrriiiitttteeee(((())))

       To send data over a TYMNET circuit, call _t_y_m_w_r_i_t_e.

            _e_r_r_o_r = _t_y_m_w_r_i_t_e(_c_d, _b_u_f, _n_b_y_t_e_s)
            _i_n_t _e_r_r_o_r, _c_d, _n_b_y_t_e_s;
            _c_h_a_r *_b_u_f;

       _t_y_m_w_r_i_t_e attempts to write _n_b_y_t_e_s bytes of data to the cir-
       cuit referenced by the circuit descriptor _c_d from the buffer
       pointed to by _b_u_f.

       _t_y_m_w_r_i_t_e returns 0 if all _n_b_y_t_e_s of data are sent success-
       fully, otherwise it returns -1 and the global variable
       _c_i_r__e_r_r indicates the reason for the failure.

       If no buffer space is available at the circuit to hold the    |
       data to be transmitted, then _t_y_m_w_r_i_t_e normally blocks.  The   |
       _t_y_m_s_e_l_e_c_t (7) call may be used to determine when it is pos-   |
       sible to send more data.                                      |

       If a piece of data for which _t_y_m_w_r_i_t_e has buffer space can-   |
       not be successfully transmitted within a reasonable length    |
       of time, then _t_y_m_w_r_i_t_e will indicate an error with a -1       |
       return and with TIM_SEND (212) as the specific code in the    |
       global variable _c_i_r__e_r_r.  The default time limit for          |
       _t_y_m_w_r_i_t_e is 30 seconds.  You can use _w_r_i_t_e_t_i_m_e (see 5.2) to   |
       change the default value.  The TIM_SEND error implies noth-   |
       ing about how the data is packaged for transfer by TYMLIB.    |
       The program may ask its user to retry the operation when      |
       possible or, if it cannot cope with lost data, it should use  |
       a longer timeout value for tymwrite().

       In addition, if the TYMNET interface requests TYMLIB to do
       the local echoing, then _t_y_m_w_r_i_t_e() will save the output data
       for _t_y_m_r_e_a_d().  _T_y_m_w_r_i_t_e will return -1 and with TYM_NOMEM
       (112) as the specific code in _c_i_r__e_r_r, if it cannot allocate
       enough buffer space to store the output data.  You can use
       _t_y_m_e_c_h_o (see 5.3) to turn off the local echoing on a partic-
       ular circuit.










                               Sending Data                Page 5-1







       TYMLIB Programmer's Guide                    August 17, 1989



       5.2  wwwwrrrriiiitttteeeettttiiiimmmmeeee(((())))                                              |

       This routine allows a user to specify how long he wants to    |
       wait if _t_y_m_w_r_i_t_e is blocked.                                  |

       To set a time limit for the _t_y_m_w_r_i_t_e operations, call _w_r_i_t_e_-  |
       _t_i_m_e.                                                         |

            _t_i_m_e = _w_r_i_t_e_t_i_m_e(_s_e_c_s)                                   |
            _i_n_t _t_i_m_e, _s_e_c_s;                                          |

       If _s_e_c_s is positive, it sets a new time limit for _t_y_m_w_r_i_t_e.   |
       If _s_e_c_s is zero, it indicates no time limit, and if _s_e_c_s is   |
       negative, it leaves the time limit unchanged.                 |

       The return value is the previous time limit.                  |

       NNNNooootttteeee::::                                                         |
       The default value of time limit for _t_y_m_w_r_i_t_e is 30 seconds.


       5.3  ttttyyyymmmmeeeecccchhhhoooo(((())))

       _t_y_m_w_r_i_t_e by default will echo the data it sends out if the
       TYMNET interface requests it to do so.  To turn on or off
       the local echo mode in _t_y_m_w_r_i_t_e, call _t_y_m_e_c_h_o.

            tymecho(cd, echo)
            int cd, echo;

       The argument _c_d is the circuit descriptor of the circuit
       over which data is sent.  The argument _e_c_h_o is an integer
       having one of the following value:

           0         Do not want _t_y_m_w_r_i_t_e to do any local echo

           1         The default mode. _t_y_m_w_r_i_t_e will do the local
                     echoing if it is requested by the TYMNET
                     interface.

       A value of 0, indicating success, is always returned.


       5.4  eeeerrrrrrrroooorrrrssss

       _t_y_m_w_r_i_t_e may return one of the following errors:

           TYM_ZAP(51)               The circuit was zapped during
                                     the call.





                               Sending Data                Page 5-2







       TYMLIB Programmer's Guide                    August 17, 1989



           TYM_INTR(104)             The call is interrupted by a
                                     signal.

           TYM_IO(105)               Some physical I/O error
                                     occurred.

           TYM_BADCD(109)            _c_d is not a valid circuit
                                     descriptor for sending data.

           TYM_NOMEM(112)            In the local echo mode,
                                     _t_y_m_w_r_i_t_e() fails to allocate
                                     _n_b_y_t_e_s size of memory from the
                                     input buffer pool to save the
                                     data being sent.  There is a
                                     size limit of 1 Kbytes on the
                                     input buffer for each circuit.

           TYM_BADADDR(114)          _b_u_f address is invalid; it is
                                     outside the process's allo-
                                     cated space.

           TIM_SEND(212)             Time expires before _t_y_m_w_r_i_t_e
                                     can send all data.              |































                               Sending Data                Page 5-3







       TYMLIB Programmer's Guide                    August 17, 1989



       5.5  eeeexxxxaaaammmmpppplllleeee

               .......
            #include <tym/tymnet.h>
               .......
            {
                         char netbuf[128];
                         int  error;

                         error = tymwrite(cd, netbuf, sizeof(netbuf));
                         switch(error) {
                         case 0:
                                  /* Normal return: all data are sent successfully. */
                                           ...........
                         case -1:
                                  /* An error occurred during the tymwrite */
                                  switch(cir_err) {
                                  case TYM_ZAP:     /* Circuit was zapped */
                                           ..........
                                  case TYM_BADCD:   /* An invalid circuit descriptor */
                                  ..........
                                  default:          /* Other errors */
                                           ..........
                                  }
                             ..........
            }




























                               Sending Data                Page 5-4







       TYMLIB Programmer's Guide                    August 17, 1989



                      6.  CCCClllleeeeaaaarrrriiiinnnngggg aaaa TTTTYYYYMMMMNNNNEEEETTTT CCCCiiiirrrrccccuuuuiiiitttt



       6.1  zzzzaaaappppcccciiiirrrr(((())))

       To discontinue use of a circuit and all of the resources
       held by the circuit, call _z_a_p_c_i_r.

            _e_r_r_o_r = _z_a_p_c_i_r(_c_d)
            _i_n_t _c_d;

       _z_a_p_c_i_r zaps the TYMNET circuit specified by the circuit
       descriptor _c_d, releases all memory buffer allocated for _t_y_m_-
       _r_e_a_d on this circuit, and close the descriptor.

       All circuits are closed automatically on _e_x_i_t, but since
       there is a limit on the number of open circuits per process,
       the use of _z_a_p_c_i_r is necessary for programs that deal with
       many circuits.

       _z_a_p_c_i_r returns 0 if the operation succeeds, otherwise it
       returns -1 and the global variable _c_i_r__e_r_r indicates the
       reason for the failure.


       6.2  eeeerrrrrrrroooorrrrssss

       _z_a_p_c_i_r may return one of the following errors:

           TYM_NCLEARS(55)           Three clear request packets
                                     has been sent without receiv-
                                     ing a response.

           TYM_INTR(104)             The call is interrupted by a
                                     signal.

           TYM_BADCD(109)            _c_d is not an active circuit
                                     descriptor.















                        Clearing a TYMNET Circuit          Page 6-1







       TYMLIB Programmer's Guide                    August 17, 1989



                           7.  IIII////OOOO MMMMuuuullllttttiiiipppplllleeeexxxxiiiinnnngggg



       7.1  ttttyyyymmmmsssseeeelllleeeecccctttt(((())))

       One facility often used in developing applications is the
       ability to multiplex i/o requests among multiple circuits.
       This is done using the _t_y_m_s_e_l_e_c_t call:

            #_i_n_c_l_u_d_e <_s_y_s/_t_i_m_e._h>

            _n_c_d_s = _t_y_m_s_e_l_e_c_t(_w_i_d_t_h, _r_e_c_v_c_d_s, _s_e_n_d_c_d_s, _e_x_c_e_p_t_c_d_s,
            _t_i_m_e_o_u_t)
            _i_n_t _n_c_d_s, _w_i_d_t_h, *_r_e_c_v_c_d_s, *_s_e_n_d_c_d_s, *_e_x_c_e_p_t_c_d_s;
            _s_t_r_u_c_t _t_i_m_e_v_a_l *_t_i_m_e_o_u_t;

       The _t_y_m_s_e_l_e_c_t () call takes as arguments three bit masks,
       _r_e_c_v_c_d_s for the set of circuit descriptors for which the
       caller wishes to be able to read data on, _s_e_n_d_c_d_s for those
       descriptors to which data is to be written, and _e_x_c_e_p_t_c_d_s
       for which exceptional conditions are pending.  Bit masks are
       created by or-ing bits of the form 1<<cd.  That is, a cir-
       cuit descriptor _c_d is selected if a 1 is presented in the
       _c_d'th bit of the mask.  The parameter _w_i_d_t_h specifies the
       range of circuit descriptors (i.e. one plus the value of the
       largest descriptor) to be examined in a mask.  If the caller
       is not interested in certain conditions (i.e. recv, send, or
       exceptions), the corresponding argument to the _t_y_m_s_e_l_e_c_t
       should be a null pointer.

       A timeout value may be specified if the selection is not to
       last more than a predetermined period of time.  The struc-
       ture of _t_i_m_e_v_a_l is defined in <sys/time,h>:


                         struct timeval {
                            long      tv_sec;     /* seconds */
                            long      tv_usec;    /* and microseconds */
                         }

       If _t_i_m_e_o_u_t is a _s_t_r_u_c_t _t_i_m_e_v_a_l of 0 seconds, 0 microseconds,
       the selection takes the form of _p_o_l_l, returning immediately.
       If _t_i_m_e_o_u_t is a null pointer, the selection will block inde-
       finitely.  (To be more specific, a return takes place only
       when a descriptor is selectable, or when a signal is
       received by the caller, interrupting the system call).

       _t_y_m_s_e_l_e_c_t returns the total number of ready descriptors in
       all the bit masks, otherwise, it returns -1 and the global
       variable _c_i_r__e_r_r indicates the reason for the failure.  If



                             I/O Multiplexing              Page 7-1







       TYMLIB Programmer's Guide                    August 17, 1989



       the time limit expires _t_y_m_s_e_l_e_c_t returns -1.





















































                             I/O Multiplexing              Page 7-2







       TYMLIB Programmer's Guide                    August 17, 1989



       NNNNooootttteeee::::
       1.  _t_y_m_s_e_l_e_c_t should be used, instead _s_e_l_e_c_t, because it
       will check whether the temporary buffer contains data stored
       by previous _t_y_m_r_e_a_d and/or _t_y_m_w_r_i_t_e calls.

       2.  On return, _t_y_m_s_e_l_e_c_t replaces the given bit masks with
       masks consisting of those descriptors that are ready for the
       requested operation.  The bit masks are always modified on
       return, even if the call returns as the result of the
       timeout.


       7.2  eeeerrrrrrrroooorrrrssss

       _t_y_m_s_e_l_e_c_t may return one of the following errors:

           TYM_INTR(104)             The call is interrupted by a
                                     signal.

           TYM_BADCD(109)            One of the descriptor sets
                                     specified an invalid circuit
                                     descriptor.

           TYM_BADADDR(114)          One of the pointers referred
                                     to a non-existent portion of
                                     the address space.

           TYM_INVAL(122)            The specified time limit is
                                     unacceptable. It is negative
                                     or too large.

           TIM_NOTREADY(209)         The specified time limit
                                     expires.


       7.3  eeeexxxxaaaammmmpppplllleeee

       As an example, to receive data from two circuits, _c_d_1 and
       _c_d_2, as it is available from each and a one-second timeout,
       the following code may be used:














                             I/O Multiplexing              Page 7-3







       TYMLIB Programmer's Guide                    August 17, 1989



               ........
            #include <tym/tymnet.h>
            #include <sys/time.h>
               ........
            #define   CDRANGE             32
            #define   ERROR               -1
            #define   DATAREADY           1
               ........

            check_input()
            {
                         int     width, ncds, recvcds;
                         struct  timeval   timeout;









































                             I/O Multiplexing              Page 7-4







       TYMLIB Programmer's Guide                    August 17, 1989




                         width = CDRANGE;
                         recvcds |= 1 << cd1;
                         recvcds |= 1 << cd2;
                         timeout.tv_sec = 1;
                         timeout.tv_usec = 0;


                         ncds = tymselect(width, &recvcds, NULL, NULL, &timout);

                         if (ncds == ERROR) {
                             /* An error occurred during the tymselect or
                                the tymselect timed out
                             */
                                    switch(cir_err) {
                                    case TYM_INTR:     /* Interrupted by a signal */
                                         ......
                                         break;
                                    case TYM_BADCD:    /* Invalid circuit descriptor */
                                         ......
                                         break;
                                    case TIM_NOTREADY: /* Time limit expires */
                                         ......
                                         break;
                                    ..........
                                    }
                                    return(ERROR);
                         } else {
                                if (recvcds & (1 << cd1)) {
                                    /* Data is ready to be received from circuit #1. */
                                    ......
                                }
                                if (recvcds & (1 << cd2)) {
                                    /* Data is ready to be received from circuit #2. */
                                    ......
                                }
                                return(DATAREADY);
                         }
            }















                             I/O Multiplexing              Page 7-5







       TYMLIB Programmer's Guide                    August 17, 1989



                              8.  DDDDeeeebbbbuuuuggggggggiiiinnnngggg


       The following routines are provided to assist TTTTYYYYMMMMLLLLIIIIBBBB pro-
       grammers in debugging his/her applications.

       8.1  ttttyyyymmmmeeeerrrrrrrr(((())))

            _t_y_m_e_r_r()
            _i_n_t _c_i_r__e_r_r;

       _t_y_m_e_r_r returns a short error message to the calling program
       describing the last error encountered during a call to a
       TYMLIB function.  The error number is taken from the exter-
       nal variable _c_i_r__e_r_r, which is set when errors occur but not
       cleared when non-erroreous calls are made.  For the meanings
       of these errors, see the TYMLIB Error Summary, Appendix B.
       The meanings of TTTTYYYYMMMMLLLLIIIIBBBB errors are also defined in an array
       of the following data structure:
                 struct tym_msg {
                      int e_code;
                      char *e_msg;
                 };
                 struct  tym_msg  tym_msgs[] = {
                      { TYM_OK,       " No error "},
                      { B4_LOGIN,     " Please log in "},
                         ......
                      { -1,      0}
                 };



       8.2  ttttyyyymmmmlllloooogggg(((())))

            _t_y_m_l_o_g()

       _t_y_m_l_o_g opens an existing _t_y_m_l_i_b._l_o_g file for the trace and
       error messages from TTTTYYYYMMMMLLLLIIIIBBBB.  If the _t_y_m_l_i_b._l_o_g file does not
       exist or is not writable, it is not created or opened.


       8.3  ddddooooppppeeeennnn(((())))

            _d_o_p_e_n(_f_i_l_e, _m_o_d_e)
            _c_h_a_r *_f_i_l_e, *_m_o_d_e;

       _D_o_p_e_n opens an existing _f_i_l_e for debuging output; if the
       _f_i_l_e does not exist or is not writable, it is not created or
       opened.  _M_o_d_e may be "w" to overwrite the debugging file, or
       "a" to append to it.




                                Debugging                  Page 8-1







       TYMLIB Programmer's Guide                    August 17, 1989



       8.4  ddddpppprrrriiiinnnnttttffff(((()))) aaaannnndddd ddddppppuuuuttttcccc(((())))

            _d_p_r_i_n_t_f(_f_o_r_m_a_t,...)
            _c_h_a_r *_f_o_r_m_a_t;

            _d_p_u_t_c(_c)
            _c_h_a_r _c;

       _D_p_r_i_n_t_f and _d_p_u_t_c are similar to _p_r_i_n_t_f(3) and _p_u_t_c(3),
       except the output goes to the debugging file if one is open.


       8.5  ddddssssttttaaaammmmpppp(((())))

            _d_s_t_a_m_p(_m_e_s_s_a_g_e)
            _c_h_a_r *_m_e_s_s_a_g_e;

       _D_s_t_a_m_p is used to put a timestamp into the debugging file.
       It writes _m_s_g followed by the current date and time as for-
       matted by _c_t_i_m_e(3) onto the file.


       8.6  bbbbddddooooppppeeeennnn(((())))

            _b_d_o_p_e_n(_f_i_l_e, _m_o_d_e)
            _c_h_a_r *_f_i_l_e, *_m_o_d_e;

       _B_d_o_p_e_n opens an existing _f_i_l_e for saving data that are
       received from and sent to the circuit(s); if the _f_i_l_e does
       not exist or is not writable, it is not created or opened.
       _M_o_d_e may be "w" to overwrite the data file, or "a" to append
       to it.  NNNNooootttteeee::::
       The data saved by TTTTYYYYMMMMLLLLIIIIBBBB will be in ASCII.  You can use _o_d
       to display the file in octal, decimal or hex formats if
       necessary.


       8.7  bbbbddddssssttttaaaammmmpppp(((())))

            _b_d_s_t_a_m_p(_m_e_s_s_a_g_e)
            _c_h_a_r *_m_e_s_s_a_g_e;

       _B_d_s_t_a_m_p is used to put a timestamp into the existing data
       file which is opened by _b_d_o_p_e_n.  It writes _m_s_g followed by
       the current date and time as formatted by _c_t_i_m_e(3) onto the
       file.

       NNNNooootttteeee::::
       The current size limit of the debug files opened by _t_y_m_l_o_g,
       _d_o_p_e_n and _b_d_o_p_e_n is about 2,000 lines.  Earlier data will be
       discarded if a debug file gets too large.



                                Debugging                  Page 8-2







       TYMLIB Programmer's Guide                    August 17, 1989



                   AAAAppppppppeeeennnnddddiiiixxxx AAAA::::  TTTTYYYYMMMMLLLLIIIIBBBB FFFFuuuunnnnccccttttiiiioooonnnn SSSSuuuummmmmmmmaaaarrrryyyy


       This is a summary of all the TTTTYYYYMMMMLLLLIIIIBBBB functions mentioned in
       this manual. Each function appears in alphabetical order by
       name, and includes its normal format and arguments followed
       by a brief description of the function.  The number enclosed
       in braces {} indicate the paragraph or section in this
       manual where a complete explanation of each function may be
       found.


       _b_d_o_p_e_n      _b_d_o_p_e_n(_f_i_l_e, _m_o_d_e);
                   Open an existing file for TTTTYYYYMMMMLLLLIIIIBBBB to save circuit
                   data {8.6}

       _b_d_s_t_a_m_p     _b_d_s_t_a_m_p(_m_e_s_s_a_g_e);
                   Put a timestamp into the debug file opened by
                   _b_d_o_p_e_n {8.7}

       _b_u_i_l_d_a_u_x    _b_u_i_l_d_a_u_x(_u_s_e_r_n_a_m_e);
                   Build an auxiliary circuit {3.2}

       _b_u_i_l_d_c_i_r    _b_u_i_l_d_c_i_r(_u_s_e_r_n_a_m_e, _p_a_s_s_w_o_r_d, _t_i_d);
                   Build a normal circuit {3.1}

       _d_o_p_e_n       _d_o_p_e_n(_f_i_l_e, _m_o_d_e);
                   Open an existing file for user debugging output
                   {8.3}

       _d_p_r_i_n_t_f     _d_p_r_i_n_t_f(_f_o_r_m_a_t,...)
                   Place output onto the debug file opened by _d_o_p_e_n
                   {8.4}

       _d_p_u_t_c       _d_p_u_t_c(_c)
                   Place the character c onto the debug file opened
                   by _d_o_p_e_n {8.4}

       _d_s_t_a_m_p      _d_s_t_a_m_p(_m_e_s_s_a_g_e);
                   Put a timestamp into the debug file opened by
                   _d_o_p_e_n {8.5}

       _f_a_k_e_a_u_x     _f_a_k_e_a_u_x(_u_s_e_r_n_a_m_e, _p_a_s_s_w_o_r_d);
                   Present a normal circuit as an auxiliary circuit
                   {3.3}

       _g_a_t_e_w_a_y     _g_a_t_e_w_a_y(_u_s_e_r_n_a_m_e, _p_a_s_s_w_o_r_d, _c_d);
                   Extend a circuit to another gateway or host
                   {3.4}





                   Appendix A:  TYMLIB Function Summary    Page A-1







       TYMLIB Programmer's Guide                    August 17, 1989



       _g_e_t_t_y_m_o_p_t   _g_e_t_t_y_m_o_p_t();
                   Find which Tymnet interface is available {2.1}

       _s_e_t_m_o_d_e     _s_e_t_m_o_d_e(_m_o_d_e);
                   Set the binary or text mode for _t_y_m_r_e_a_d {4.3}

       _s_e_t_t_i_m_e_o_u_t  _s_e_t_t_i_m_e_o_u_t(_s_e_c_s);
                   Set time limit for _t_y_m_r_e_a_d and _w_a_i_t_f_o_r {4.4}

       _s_e_t_t_y_m_o_p_t   _s_e_t_t_y_m_o_p_t(_o_p_t);
                   Indicate which Tymnet interface to be used {2.2}

       _t_y_m_e_c_h_o     _t_y_m_e_c_h_o(_c_d, _e_c_h_o);
                   Turn on or off the local echo mode for _t_y_m_w_r_i_t_e
                   {5.3}

       _t_y_m_e_r_r      _t_y_m_e_r_r();
                   Get a short message describing the last error in
                   _c_i_r__e_r_r {8.1}

       _t_y_m_l_o_g      _t_y_m_l_o_g();
                   Open a debug file for the trace and error mes-
                   sages from TTTTYYYYMMMMLLLLIIIIBBBB {8.2}

       _t_y_m_r_e_a_d     _t_y_m_r_e_a_d(_c_d, _b_u_f, _n_b_y_t_e_s, _r_e_t_u_r_n__s_z);
                   Receive data from a circuit {4.1}

       _t_y_m_s_e_l_e_c_t   _t_y_m_s_e_l_e_c_t(_w_i_d_t_h, _r_e_a_d_c_d_s, _w_r_i_t_e_c_d_s, _e_x_c_e_p_t_c_d_s,
                   _t_i_m_e_o_u_t);
                   Multiplex i/o requests among multiple circuits
                   {7.1}

       _t_y_m_t_h_r_u_p_u_t  _t_y_m_t_h_r_u_p_u_t(_b_p_s);
                   Set the throughput for the circuit to be built
                   {3.5}

       _t_y_m_w_r_i_t_e    _t_y_m_w_r_i_t_e(_c_d, _b_u_f, _n_b_y_t_e_s);
                   Send data over a circuit {5.1}

       _w_a_i_t_f_o_r     _w_a_i_t_f_o_r(_p_a_t_t_e_r_n, _c_d);
                   Wait for a specified ASCII string from a circuit
                   {4.2}

       _w_r_i_t_e_t_i_m_e   _w_r_i_t_e_t_i_m_e(_s_e_c_s);
                   Set time limit for _t_y_m_w_r_i_t_e {5.2}

       _z_a_p_c_i_r      _z_a_p_c_i_r(_c_d);
                   Disconnect a circuit {6.1}






                   Appendix A:  TYMLIB Function Summary    Page A-2







       TYMLIB Programmer's Guide                    August 17, 1989



                    AAAAppppppppeeeennnnddddiiiixxxx BBBB::::  TTTTYYYYMMMMLLLLIIIIBBBB EEEErrrrrrrroooorrrr SSSSuuuummmmmmmmaaaarrrryyyy


       Each TYMLIB call description attempts to list all possible
       error numbers in the external variable _c_i_r__e_r_r.  The follow-
       ing is a complete list of the errors and their names as
       given in <ttttyyyymmmmnnnneeeetttt....hhhh>.


             0  TYM_OK               no error

             1  B4_LOGIN             please log in

             2  B4_BADUSR            error, type username

             3  B4_BADPWD            error, type password

             4  B4_NOUSR             username

             5  B4_NOPWD             password

             8  B4_ASKREP            please see your rep...

             9  B4_BADMUD            bad mud

           10  B4_CIRCBUSY           circuit busy

           11  B4_HOSTBUSY           host not avail...

           12  B4_NOPORT             host out of ports

           13  B4_HOSTDOWN           host down

           14  B4_HOSTSHUT           host shut

           15  B4_AGAIN              try again in 2 minutes

           16  B4_NOACESS            access not permitted

           17  B4_NOHOST             no host specified

           18  B4_BADHOST            bad host number

           19  B4_MUDERROR           mud error

           20-31                     _r_e_s_e_r_v_e_d

           32  B5_ISISUNABLE         ISIS unable to complete
                                     request





                    Appendix B:  TYMLIB Error Summary      Page B-1







       TYMLIB Programmer's Guide                    August 17, 1989



           33  B5_BADFORMAT          format error

           34  B5_BADUSR             bad user name

           35  B5_BADMUD             bad mud

           36  B5_SYSBUSY            system unavailable

           37  B5_BADLOAD            down-line load or dial-out
                                     failure

           38  B5_TIMEOUT            timeout

           39  B5_NOACCESS           access not permitted

           40  B5_NOPORT             out of origination ports

           41  B5_AGAIN              try again later

           42  B5_BADHOST            bad requesting-host number

           43  B5_HOSTDOWN           requesting-host not up on
                                     requesting-node

           44-50                     _r_e_s_e_r_v_e_d

           51  TYM_ZAP               The circuit was zapped during
                                     the call.

           52  TYM_INTDATA           An interrupt request packet
                                     has been received.

           53  TYM_VCRESET           The virtual circuit has been
                                     reset or the X.25 interface
                                     has been restarted.

           54  TYM_NRESETS           Three reset request packets
                                     has been sent without receiv-
                                     ing a response.

           55  TYM_NCLEARS           Three clear request packets
                                     has been sent without receiv-
                                     ing a response.

           56  TYM_MSGTOOLONG        A message exceeding the
                                     receiving buffer size (1k) has
                                     been received and data has
                                     been discarded.

           57  TYM_TEXTBUF           When calling tymread() in TEXT
                                     mode, the buffer size should



                    Appendix B:  TYMLIB Error Summary      Page B-2







       TYMLIB Programmer's Guide                    August 17, 1989



                                     be at least 2 bytes.

           58  TYM_REMBUSY           Remote host circuit buffer is
                                     full -- receive backpressure

           59  TYM_LOCBUSY           Local host circuit buffer is
                                     full -- send backpressure

           60  TYM_ALLBUSY           Both remote and local host
                                     circuit buffers are full!

           61-103                    _r_e_s_e_r_v_e_d

           104  TYM_INTR             It may indicate an urgent con-
                                     dition (such as virtual cir-
                                     cuit reset or interrupt data)
                                     present on a circuit or, an
                                     asynchronous signal (such as
                                     interrupt) occurred during a
                                     TYMLIB call and this signal
                                     may have had an origin some-
                                     where other than the TYMLIB
                                     package.

           105  TYM_IO               Some physical I/O error
                                     occurred.  This error may in
                                     some cases occur on a call
                                     following the one to which it
                                     actually applies.

           106-108                   _r_e_s_e_r_v_e_d

           109  TYM_BADCD            invalid circuit descriptor

           110                       _r_e_s_e_r_v_e_d

           111  TYM_AGAIN            out of X.25 ports

           112  TYM_NOMEM            During a _t_y_m_r_e_a_d() or
                                     _t_y_m_w_r_i_t_e(), TYMLIB asks for
                                     more buffer space than the
                                     system is able to supply.  For
                                     example, in a local echo mode,
                                     _t_y_m_w_r_i_t_e() will try to save
                                     the outgoing data into the
                                     input buffer to be processed
                                     later by a _t_y_m_r_e_a_d() call and
                                     there is an input buffer size
                                     limit for each circuit.





                    Appendix B:  TYMLIB Error Summary      Page B-3







       TYMLIB Programmer's Guide                    August 17, 1989



           113                       _r_e_s_e_r_v_e_d

           114  TYM_BADADDR          bad user buffer address

           115-121                   _r_e_s_e_r_v_e_d

           122  TYM_INVAL            A TYMLIB call was made with an
                                     invalid argument; for example,
                                     the circuit descriptor was
                                     negative.

           123-134                   _r_e_s_e_r_v_e_d

           135  TYM_BLOCK            no data were ready to be read
                                     or written

           136-137                   _r_e_s_e_r_v_e_d

           138  TYM_NOTX25           invalid circuit descriptor on
                                     X.25 interface

           139-149                   _r_e_s_e_r_v_e_d

           150  TYM_NET_DOWN         network is down

           151  TYM_NETUNREACH       network is unreachable

           152  TYM_NETRESET         network zapped circuit on
                                     reset

           153  TYM_CONNABORT        software caused circuit to be
                                     zapped

           154  TYM_HOSTRESET        circuit is zapped by the other
                                     host

           155  TYM_NOBUFS           no buffer space available

           156  TYM_ISCONN           circuit is already built

           157  TYM_NOTCONN          circuit is not built

           158  TYM_SHUTDOWN         can't send data after circuit
                                     is zapped

           159                       _r_e_s_e_r_v_e_d

           160  TYM_TIMEOUT          connection timed out

           161  TYM_REFUSED          connection refused




                    Appendix B:  TYMLIB Error Summary      Page B-4







       TYMLIB Programmer's Guide                    August 17, 1989



           162-163                   _r_e_s_e_r_v_e_d

           164  TYM_HOSTDOWN         host is down

           165  TYM_HOSTUNREACH      host is unreachable

           166-181                   _r_e_s_e_r_v_e_d

           182  TYM_FASTMSG          fast select messages on X.25
                                     interface

           183-199                   _r_e_s_e_r_v_e_d

           200  NO_TYMDEV            no Tymnet interface

           201  NO_TYMCOM            no Tymcom interface

           202  NO_TYMX25            no X.25 interface

           203  TYM_BUSY             Tymcom ports busy

           204  TYM_CON              Tymcom connection error

           205  CIR_LOST             Tymcom circuit lost ... hang-
                                     up signal received

           206  TIM_EMPTY            timeout ... buffer empty for
                                     _t_y_m_r_e_a_d call

           207  TIM_PARTIAL          timeout ... partial line for
                                     _t_y_m_r_e_a_d call

           208  TIM_NOPAT            timeout ... pattern not found
                                     for _w_a_i_t_f_o_r call

           209  TIM_NOTREADY         timeout ... no ready descrip-
                                     tor for _t_y_m_s_e_l_e_c_t call

           210  NO_TYMFILE           TYMLIB cannot open
                                     /etc/tymlib.conf file

           211  NO_XCOMFILE          TYMLIB cannot open
                                     /etc/tymlib.xcom file

           212  TIM_SEND             timeout ... for _t_y_m_w_r_i_t_e call

           213-251                   _r_e_s_e_r_v_e_d

           252  TYM_DATALOST         Data lost in network, recv
                                     black or gray ball




                    Appendix B:  TYMLIB Error Summary      Page B-5







       TYMLIB Programmer's Guide                    August 17, 1989



           253-271                   _r_e_s_e_r_v_e_d

           272  TYM_BUFZAP           XCOM buffer zap occured for
                                     this circuit.


















































                    Appendix B:  TYMLIB Error Summary      Page B-6







       TYMLIB Programmer's Guide                    August 17, 1989



                   AAAAppppppppeeeennnnddddiiiixxxx CCCC::::  AAAA SSSSaaaammmmpppplllleeee TTTTYYYYMMMMLLLLIIIIBBBB PPPPrrrrooooggggrrrraaaammmm



            /*
             *           This program will build a circuit only to a TYMCOM-X host and logout
             *           if it succeeds. It will prompt for username and password.
             *
             *           Compile: cc -O pdp10.c -ltymnet -o pdp10
             *
             *           Usage: pdp10 [-g gateway] host_number (e.g. pdp10 -g c 39)
             */

            #include <ctype.h>
            #include <errno.h>
            #include <sgtty.h>
            #include <signal.h>
            #include <stdio.h>
            #include <string.h>
            #include <sys/file.h>
            #include <sys/types.h>
            #include <tym/tymnet.h>

            #define      equal(s1, s2)    (!strcmp(s1, s2))
            #define      equaln(s1, s2)   (!strncmp(s1, s2, strlen(s2)))

            #define      EOT              4
            #define      ERROR            -1
            #define      MAXGAT           5/* max number of gateways */
            #define      MAXTM            10
            #define      NOHOST           0
            #define      NOSTR            ((char *)NULL)
            #define      PDP10            1
            #define      PLEN             64
            #define      TYMCOM           0x000001
            #define      TYMX25           0x000002

            extern       char             *sys_siglist[];

            char         *gateways[MAXGAT], netbuf[128], rmthost[32], passwd[80], uname[80],
                         *get_cirmsg(), *getlogin(), *getpass(), *index(), *malloc(),
                         *pname, *pwp = 0, *unp = 0, *tym_connect(),
                         *htname[] = { "not TYMCOM-X", "TYMCOM-X" };

            int          fd, gatenum, hosttype = NOHOST;

            main(argc, argv)
                         char             *argv[];
            {





                   Appendix C:  A Sample TYMLIB Program    Page C-1







       TYMLIB Programmer's Guide                    August 17, 1989



                         register char    *p, *q;
                                           interror, Had_data, i, stop(), sz, timect;

                         if (!isatty(0)) {
                                          fprintf(stderr, "%s: must be interactive0, pname);
                                          exit(1);
                         }

                         pname = argv[0];

                         cir_err = fd = gatenum = 0;
                         for (i = 0; i < MAXGAT; i++)
                                          gateways[i] = NULL;

                         argc--, argv++;
                         while (argc > 0 && **argv == '-') {
                                          for (p = *argv + 1; *p; p++)
                                          switch (*p) {

                                          case 'g':
                                          getgateways(&argc, &argv, gateways);
                                          break;
                                          default:
                                          fprintf(stderr, "%s: unknown option: %c0,
                                               pname, *p);
                                          exit(1);
                                          }
                                          argc--, argv++;
                         }
                         if (argc == 0) {
                                          fprintf(stderr, "usage: pdp10 [-g gateway] host_number0);
                                          exit(1);
                         }
                         argv--;
                         strcpy(rmthost, argv[1]);
                         ruserpass(&unp, &pwp);
                         strcpy(uname, unp);
                         strcpy(passwd, pwp);
                         if (p = index(uname, ':'))
                                          *p = ' ';
                         if (isnum(rmthost)) {
                                          strcat(uname, ":");
                                          strcat(uname, rmthost);
                         }

                         signal(SIGHUP, stop);
                         signal(SIGINT, stop);
                         signal(SIGQUIT, stop);






                   Appendix C:  A Sample TYMLIB Program    Page C-2







       TYMLIB Programmer's Guide                    August 17, 1989



                         settimeout(30);
                         setmode(1);      /* text mode for tymread */

                         if (p = tym_connect()) {
                                          q = get_cirmsg(cir_err);
                                          fprintf(stderr, "Couldn't build circuit to %s: %s0, p, q);
                                          exit(1);
                         }

                         Had_data = timect = 0;
                         settimeout(2);

            login:
                         cir_err = 0;
                         error  = tymread(fd, netbuf, sizeof(netbuf), &sz);
                         switch (error) {
                         case 0:
                                          if ((cir_err = net_error(netbuf)) > 0) {
                                          zapcir(fd);
                                          exit(1);
                                          }
                                          Had_data = 1;
                                          goto login;
                         case -1:
                                          switch (cir_err) {
                                          case CIR_LOST:
                                          case EIO + ERR_OFFSET:
                                          fprintf(stderr, "circuit lost.0);
                                          zapcir(fd);
                                          exit(1);
                                          case TIM_EMPTY:
                                          timect++;
                                          if (Had_data)
                                          break;
                                          else if (timect > MAXTM) {
                                          fprintf(stderr, "%s: timeout waiting for prompt from remote host.0,pname);
                                          zapcir(fd);
                                          exit(1);
                                          }
                                          goto login;
                                          case TIM_PARTIAL:
                                          if ((equal(netbuf, "proj code: "))
                                               || (equal(netbuf, "PROJECT CODE:."))
                                               || (equaln"(,ne1t)b;uf, "type job number")))
                                          teylmsweriitfe((fedq,ua"l(netbuf, "-") || equal(netbuf, ".")
                                               || equal(netbuf, "!")) {
                                          hosttype = PDP10;
                                          break;





                   Appendix C:  A Sample TYMLIB Program    Page C-3







       TYMLIB Programmer's Guide                    August 17, 1989



                                          } else if ((cir_err = net_error(netbuf)) > 0) {
                                          fprintf(stderr, "cir_err = %d0, cir_err);
                                          zapcir(fd);
                                          exit(1);
                                          }
                                          Had_data = 1;
                                          goto login;
                                          default:
                                          fprintf(stderr, "%s: error in transmission.0,pname);
                                          zapcir(fd);
                                          exit(1);
                                          }
                                          break;
                         default:
                                          fprintf(stderr, "%s: unexpected tymread response: %d.0,
                                                   pname, error);
                                          zapcir(fd);
                                          exit(1);
                         }
                         printf("0** Your remote host is %s! ***0, htname[hosttype]);
                         if (hosttype != NOHOST) {            ", 7);
                                          tsylmewerpi(t5e)(;fd, "logout
                         }
                         zapcir(fd);
                         exit(0);
            }

            /*
               GETGATEWAYS gets the gateway names from command line and puts them
               in gateways array.  When it returns, argc becomes the number of
               arguments not yet processed plus one and argv points to the last
               argument already processed.
            */

            getgateways(argcptr, argvptr, gateways)
                         int              *argcptr;/* pointer to argc */
                         char             ***argvptr;/* pointer to argv */
                         char             *gateways[];/* gateway names */
            {

                         if (!(*argvptr)[0][2]) {
                                          if (gatenum == MAXGAT) {
                                          fprintf(stderr, "Too many -g options. ");
                                          fprintf(stderr, "The max. number of -g is %d.0,
                                               MAXGAT);
                                          exit(1);
                                          }






                   Appendix C:  A Sample TYMLIB Program    Page C-4







       TYMLIB Programmer's Guide                    August 17, 1989



                                          gateways[gatenum] = (*argvptr)[1];
                                          gatenum++;
                                          (*argvptr)++;
                                          (*argcptr)--;
                         }  else {
                                          fprintf(stderr, "There should be a space between -g and gateway0);
                                          exit(1);
                         }
            }

            stop(sig)
            {
                         if (sig != SIGHUP)
                                          if (sig < NSIG)
                                          fprintf(stderr, "%s: %s -- aborted.0,
                                              pname, sys_siglist[sig]);
                                          else
                                          fprintf(stderr, "%s: signal %d -- aborted.0, pname, sig);
                         zapcir(fd);
                         exit(1);
            }

            isnum(str)
            char         *str;
            {
                         register char    *p = str;
                         register c;

                         while (c = *p++)
                                          if (!isdigit(c))
                                          return (0);
                         return(1);
            }

            ruserpass(aname, apass)
                         char **aname, **apass;
            {
                         char             *myname = getlogin();

                         *aname = malloc(16);
                         printf("Remote username: ");
                         fflush(stdout);
                         if (read(2, *aname, 16) <= 0)
                                          exit(1);
                         if ((*aname)[0] == '0)
                                          *aname = myname;
                         else
                                          if (index(*aname, '0))
                                          *index(*aname, '0) = 0;





                   Appendix C:  A Sample TYMLIB Program    Page C-5







       TYMLIB Programmer's Guide                    August 17, 1989



                         if (*aname && *apass == 0) {
                                          printf("Remote password: ");
                                          fflush(stdout);
                                          *apass = getpass("");
                         }
            }

            /* Modified to allow passwords > 8 chars */

            char *
            getpass(prompt)
                         char *prompt;
            {
                         struct sgttyb ttyb;
                         int flags;
                         register char *p;
                         register c;
                         FILE *fi;
                         static char pbuf[PLEN];
            #ifdef  SUN40
                         void (*sig)();
            #else
                         int (*signal())();
                         int (*sig)();
            #endif

                         if ((fi = fdopen(open("/dev/tty", 2), "r")) == NULL)
                                          fi = stdin;
                         else
                                          setbuf(fi, (char *)NULL);
                         sig = signal(SIGINT, SIG_IGN);
                         gtty(fileno(fi), &ttyb);
                         flags = ttyb.sg_flags;
                         ttyb.sg_flags &= ~ECHO;
                         stty(fileno(fi), &ttyb);
                         fprintf(stderr, "%s", prompt); fflush(stderr);
                         for (p=pbuf; (c = getc(fi))!='0 && c!=EOF;) {
                                          if (p < &pbuf[PLEN-1])
                                          *p++ = c;
                         }
                         *p = ' ';
                         fprintf(stderr, "0); fflush(stderr);
                         ttyb.sg_flags = flags;
                         stty(fileno(fi), &ttyb);
                         signal(SIGINT, sig);
                         if (fi != stdin)
                                          fclose(fi);
                         return(pbuf);
            }





                   Appendix C:  A Sample TYMLIB Program    Page C-6







       TYMLIB Programmer's Guide                    August 17, 1989



            char *
            tym_connect()
            {
                         int              error, i, tymopt;

                         cir_err = i = 0;

                         if ((tymopt = gettymopt()) == ERROR)
                                          return("No Tymnet interface available!0);
                         if (tymopt & TYMX25)
                                          settymopt(TYMX25);
                         else
                                          return("No XCOM interface available!0);

                         while (i < MAXGAT && gateways[i]) {/* build circuit to gateways */
                                          if (!i)
                                          fd = error = buildcir(gateways[i], 0, 0);
                                          else
                                          error = gateway(gateways[i], 0, fd);
                                          if (error < 0)
                                          return (gateways[i]);
                                          i++;
                         }
                         if (!i) {        /* originate circuit to host */
                                          if (isnum(rmthost))
                                          fd = buildcir(uname, passwd, 0);
                                          else
                                          fd = buildcir(rmthost, 0, 0);
                                          if (fd < 0)
                                          return (rmthost);
                         } else {         /* extend circuit to host */
                                          if (isnum(rmthost))
                                          error = gateway(uname, passwd, fd);
                                          else
                                          error = gateway(rmthost, 0, fd);
                                          if (error) {
                                          zapcir(fd);
                                          return (rmthost);
                                          }
                         }
                         return (NOSTR);
            }












                   Appendix C:  A Sample TYMLIB Program    Page C-7











                            TABLE OF CONTENTS



       1.  Introduction.........................................  3
           1.1  What is TYMLIB?.................................  1
           1.2  How to use TYMLIB?..............................  1
           1.3  Signals used in TYMLIB..........................  2

       2.  Tymnet Interfaces....................................  3
           2.1  XCOM vs TYMCOM..................................  1
           2.2  gettymopt().....................................  1
           2.3  settymopt().....................................  2
           2.4  errors..........................................  2
           2.5  example.........................................  3

       3.  Creating TYMNET Circuits.............................  4
           3.1  buildcir()......................................  1
           3.2  buildaux()......................................  1
           3.3  fakeaux().......................................  2
           3.4  gateway().......................................  2
           3.5  tymthruput()....................................  3
           3.6  errors..........................................  5
           3.7  XCOM Explained..................................  6
           3.8  example.........................................  8

       4.  Receiving Data.......................................  9
           4.1  tymread().......................................  1
           4.2  waitfor().......................................  1
           4.3  setmode().......................................  2
           4.4  settimeout()....................................  2
           4.5  errors..........................................  3
           4.6  example.........................................  3

       5.  Sending Data.........................................  6
           5.1  tymwrite()......................................  1
           5.2  writetime().....................................  2
           5.3  tymecho().......................................  2
           5.4  errors..........................................  2
           5.5  example.........................................  4

       6.  Clearing a TYMNET Circuit............................  5
           6.1  zapcir()........................................  1
           6.2  errors..........................................  1

       7.  I/O Multiplexing.....................................  2
           7.1  tymselect().....................................  1
           7.2  errors..........................................  3
           7.3  example.........................................  3

       8.  Debugging............................................  6



                                  - i -











           8.1  tymerr()........................................  1
           8.2  tymlog()........................................  1
           8.3  dopen().........................................  1
           8.4  dprintf() and dputc()...........................  2
           8.5  dstamp()........................................  2
           8.6  bdopen()........................................  2
           8.7  bdstamp().......................................  2

       Appendix A:  TYMLIB Function Summary.....................  3

       Appendix B:  TYMLIB Error Summary........................  3

       Appendix C:  A Sample TYMLIB Program.....................  7









































                                  - ii -




@