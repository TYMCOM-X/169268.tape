
      INTEGER DSEC,USEC,UCNT,
     1        MODEM(2),MODEML(2),DAY(3,7),DTIME(8),UTIME(8),
     2        CIR(3),BPS,FILE(5),H(16),OFILE(5),LINE(80),HOUR(25)

      DATA IPAGE/1H /
      DATA MODEM/1HM,1HU/
      DATA MODEML/5HMS   ,5H?????/
      DATA DAY/5HSUNDA,5HY  $ ,5H     ,5HMONDA,5HY  $ ,5H     ,
     1         5HTUESD,5HAY  $,5H     ,5HWEDNE,5HSDAY ,5H $   ,
     2         5HTHURS,5HDAY  ,5H$    ,5HFRIDA,5HY  $ ,5H     ,
     3         5HSATUR,5HDAY  ,5H$    /

      DATA H/1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,
     1       1HA,1HB,1HC,1HD,1HE,1HF/

      CALL DBSTRT(21,-1,22,-1,23,-1,24,-1,-4,0,-1,1)

C     GET START AND STOP TIME
      TYPE 410
410   FORMAT(' ENTER START-DATE AND END-DATE (M D Y M D Y):',$)
      ACCEPT 420,JMB,JDB,JYB,JME,JDE,JYE
420   FORMAT(6I)
      IF(JYB.NE.0)GOTO 430
      JYB=DTE(I)
      JYB=MOD(JYB,100)
430   IF(JME.NE.0)GOTO 435
      JME=JMB
      JDE=JDB
435   IF(JYB.LT.100)JYB=JYB+1900
      IF(JYE.EQ.0)JYE=JYB
      IF(JYE.LT.100)JYE=JYE+1900
      JTB=JULIAN(JMB,JDB,JYB,0,0,0)
      JTE=JULIAN(JME,JDE,JYE,23,59,59)
      JT=JTB

C     FETCH OUTPUT FILE NAME
      TYPE 310
310   FORMAT('+ENTER OUTPUT FILE NAME:',$)
      ACCEPT 320,OFILE
320   FORMAT(5A5)

C     OPEN OUTPUT FILE
      OPEN(21,OFILE,OUTPUT,SYMBOLIC)
      CALL SIMTTY(21)

C     OPEN X22 REFERENCE DATA BASES AND LOAD QUICK SELECTION FOR LINES
      CALL DBOPEN( 'TYMLIN.DMS','ACCESS','READONLY',
     1             'CMREGN.DMS','ACCESS','READONLY')
      CALL DBSET(1)
      CALL DBFIND('MODEM','EQ',1HD)
      CALL DBSRCH('BPS','EQ',56000)
      CALL LOADQS

C     START PRODUCING X22 DMI FILE:
C       LOADING SECTION
C               INPUT NEVLOY.MYY
C               OUTPUT CRNDMS.TMP
C               ALLOCATE 1000 TRUNCATE ATTEMPTS 10
C       
C       STRUCTURE SECTION
C               ATT NODE1 LEN 4  INTEGER
C               ATT LINE1 LEN 2  INTEGER 
C               ATT NODE2 LEN 4  INTEGER
C               ATT LINE2 LEN 2  INTEGER 
C               ATT DSEC  LEN 10 INTEGER
C               ATT USEC  LEN 10 INTEGER
C               FILLER 5        (ATT TYPE  LEN 5  INTEGER)
C               ATT NPLI  LEN 5  INTEGER 
C               ATT UCNT  LEN 4  INTEGER 
C               FILLER 4        (ATT PLID  LEN 4  INTEGER)
C               FILLER 1        (ATT RNODE LEN 1  INTEGER)

500   CALL MDYHMS(JT,JM,JD,JY,I,I,I)
      OPEN(23,'CRNDMD.TMP',OUTPUT,SYMBOLIC)
      WRITE(23,501)
501   FORMAT('LOADING SECTION')

C     SINGLE DAY INPUT, SET 'NEVLGY.MDD' AS INPUT FILE IN 'CRNDMD.TMP'
550   ENCODE(25,555,FILE)H(MOD(JY,10)+1),H(JM+1),H(JD/10+1),
     1                   H(MOD(JD,10)+1)
555   FORMAT('NEVLO',A1,'.',3A1,15X)
      WRITE(23,560)FILE(1),FILE(2)
560   FORMAT('        INPUT ',2A5)

C     COMPLETE 'CRNDMD.TMP'
570   WRITE(23,575)
575   FORMAT('        OUTPUT CRNDMS.TMP',/,
     1       '        ALLOCATE 1000 TRUNCATE ATTEMPTS 10',/,
     3       /,
     4       'STRUCTURE SECTION',/,
     5       '        ATT NODE1 LEN 4  INTEGER',/,
     6       '        ATT LINE1 LEN 2  INTEGER',/,
     7       '        ATT NODE2 LEN 4  INTEGER',/,
     8       '        ATT LINE2 LEN 2  INTEGER',/,
     9       '        ATT DSEC  LEN 10 INTEGER',/,
     A       '        ATT USEC  LEN 10 INTEGER',/,
     B       '        FILLER 5',/,
     C       '        ATT NPLI  LEN 5  INTEGER',/,
     D       '        ATT UCNT  LEN 4  INTEGER ',/,
     E       '        FILLER 4',/,
     F       '        FILLER 1')
      CLOSE(23)

C     LOAD 'CRNDMD.TMP' CREATING 'CRNDMS.TMP'

      CALL DBEXEC('LOAD CRNDMD.TMP ')

C     SORT BY NODE1,LINE1,NODE2,LINE2 AND COMBINE EVENTS WERE
C     UP/DOWN TIME IS LESS THAN 5 MINUTES.
      OPEN(22,'CRNDMI.TMP',OUTPUT,SYMBOLIC)
      CALL DBOPEN('NOCLOSE',
     1            'CRNDMS.TMP','ACCESS','READONLY')
      CALL DBSET(3)
      CALL DBFIND('ALL')
      CALL DBSORT('NODE1','LINE1','NODE2','LINE2','DSEC')

610   CALL DBGREC($690)
      CALL DBVAL('NODE1',NODE1,'LINE1',LINE1,
     1           'NODE2',NODE2,'LINE2',LINE2,
     2           'DSEC',DSEC,'USEC',USEC,
     3           'NPLI',NPLI,'UCNT',UCNT)
      IF(DSEC.EQ.0)GOTO 610

620   CALL DBGREC($650)
      CALL DBVAL('NODE1',N1,'LINE1',L1,
     1           'NODE2',N2,'LINE2',L2,
     2           'DSEC',NDSEC,'USEC',NUSEC,
     3           'NPLI',NNPLI,'UCNT',NUCNT)
      IF(NDSEC.EQ.0)GOTO 620
      IF(NODE1.NE.N1.OR.NODE2.NE.N2)GOTO 630
      IF(LINE1.NE.L1.OR.LINE2.NE.L2)GOTO 630
      IF(IABS(USEC-NDSEC).GT.300)GOTO 630
      USEC=NUSEC
      NPLI=NPLI+NNPLI
      UCNT=UCNT+NUCNT
      GOTO 620

630   IF(IFNDQS(NODE1,LINE1,NODE2,LINE2).EQ.0)GOTO 640
      IEUSKE=IEUSKE+1
      CALL LDESC(NODE1,LINE1,NODE2,LINE2,MTYPE,CIR,BPS)
      IF(MTYPE.NE.1HD)GOTO 640
      IF(BPS.NE.56000)GOTO 640
      IEUSKE=IEUSKE-1
      CALL RDESC(NODE1,NODE2,R1,R2)
      WRITE(22,635)NODE1,LINE1,NODE2,LINE2,DSEC,USEC,NPLI,UCNT,
     1             CIR,BPS,MTYPE,R1,R2
635   FORMAT(I4,I2,I4,I2,I10,I10,I5,I4,3A5,I7,A1,A1,A1)
640   NODE1=N1
      LINE1=L1
      NODE2=N2
      LINE2=L2
      DSEC=NDSEC
      USEC=NUSEC
      NPLI=NNPLI
      UCNT=NUCNT
      GOTO 620

650   IF(IFNDQS(NODE1,LINE1,NODE2,LINE2).EQ.0)GOTO 690
      IEUSKE=IEUSKE+1
      CALL LDESC(NODE1,LINE1,NODE2,LINE2,MTYPE,CIR,BPS)
      IF(MTYPE.NE.1HD)GOTO 690
      IEUSKE=IEUSKE-1
      CALL RDESC(NODE1,NODE2,R1,R2)
      WRITE(22,635)NODE1,LINE1,NODE2,LINE2,DSEC,USEC,NPLI,UCNT,
     1             CIR,BPS,MTYPE,R1,R2
690   CLOSE(22)
      CALL DBCLOS

C     LOAD CONSOLIDATED DATA BASE
      CALL DBEXEC('LOAD CRONLN.DMD ')


C     OPEN, SELECT ALL, AND SORT DATA BASE
      CALL DBOPEN('NOCLOSE',
     1            'CRNDMS.TMP','ACCESS','READONLY')
      CALL DBSET(3)
      CALL DBFIND('ALL')
      CALL DBSORT('DSEC','USEC','NODE1','NODE2')
      LDSEC=0

C     CREATE HEADING:
C
C DETAILED TYMNET LINK OUTAGES, MODEM=DIGITAL, BPS=56KB
C PERIOD: DAY  MM/DD/YY  (CONTINUE)
C
C   DOWN      UP      NODE     NODE            CIRCUIT              DOWN/UP
C   TIME     TIME    -LINE    -LINE     MODEM  NUMBER          NPLI   COUNT
C -------------------------------------------------------------------------
1000  WRITE(21,1010)IPAGE
1010  FORMAT(A1,'DETAILED TYMNET LINK OUTAGES, MODEM=DIGITAL',
     1       ', BPS=56KB')
      IPAGE=1H1
      L=0
      CALL COPYA5(LINE,L,1H$,'PERIOD: $')
      CALL COPYA5(LINE,L,1H$,DAY(1,MOD(JT/(24*3600)+2,7)+1))
      IF(JM/10.NE.0)LINE(L+1)=H(JM/10+1)
      IF(JM/10.EQ.0)LINE(L+1)=1H 
      LINE(L+2)=H(MOD(JM,10)+1)
      LINE(L+3)=1H/
      LINE(L+4)=H(JD/10+1)
      LINE(L+5)=H(MOD(JD,10)+1)
      LINE(L+6)=1H/
      LINE(L+7)=H(MOD(JY/10,10)+1)
      LINE(L+8)=H(MOD(JY,10)+1)
      L=L+8
      IF(LDSEC.NE.0)CALL COPYA5(LINE,L,1H$,'  (CONTINUED)$')
      WRITE(21,1020)(LINE(I),I=1,L)
1020  FORMAT(1H ,80A1)
      WRITE(21,1040)
1040  FORMAT(//,
     1       '   DOWN      UP      NODE     NODE            ',
     2       'CIRCUIT              DOWN/UP',/,
     3       '   TIME     TIME    -LINE    -LINE     MODEM  ',
     4       'NUMBER          NPLI   COUNT',/,
     5       ' -----------------------------------------------',
     6       '--------------------------')
      LINECT=7
      LDSEC=0

C     GET NEXT RECORD AND WATCH FOR TIME GAP OF 1 MINUTE
C     WRITE LINE OF FORMAT:
C
C HR:MN:SC HR:MN:SC  RNNNN-LL RNNNN-LL  MODEM  CIRCUIT........  NPLI.  UCNT.

1100  CALL DBGREC($2000)
      CALL DBVAL('NODE1',NODE1,'LINE1',LINE1,
     1           'NODE2',NODE2,'LINE2',LINE2,
     2           'DSEC',DSEC,'USEC',USEC,
     3           'NPLI',NPLI,'UCNT',UCNT,
     4           'MTYPE',MTYPE,'CIR',CIR,'BPS',BPS,
     5           'R1',R1,'R2',R2)

      IF(IABS(LDSEC-DSEC).LT.60)GOTO 1105
      IF(LDSEC.EQ.0)GOTO 1105
      WRITE(21,1102)
1102  FORMAT(1H )
      LINECT=LINECT+1
1105  LDSEC=DSEC

      N1=(NODE1/1000)*512+MOD(NODE1/100,10)*64+MOD(NODE1/10,10)*8
     1   +MOD(NODE1,10)

      L1=4H    
      IF(LINE1.LT.0)GOTO 1110
      CALL PUTC(1,L1,45)
      I=2
      IF(LINE1.GE.10)CALL PUTC(2,L1,49)
      IF(LINE1.GE.10)I=3
      CALL PUTC(I,L1,MOD(LINE1,10)+48)

1110  N2=(NODE2/1000)*512+MOD(NODE2/100,10)*64+MOD(NODE2/10,10)*8
     1   +MOD(NODE2,10)

      L2=4H    
      IF(LINE2.LT.0)GOTO 1120
      CALL PUTC(1,L2,45)
      I=2
      IF(LINE2.GE.10)CALL PUTC(2,L2,49)
      IF(LINE2.GE.10)I=3
      CALL PUTC(I,L2,MOD(LINE2,10)+48)

1120  DO 1125 I=1,2
      M=MODEML(I)
      IF(MTYPE.EQ.MODEM(I))GOTO 1130
1125  CONTINUE
      M=MTYPE
      CALL PUTC(2,M,45)
      I=MOD(BPS/10000,10)
      IF(I.EQ.0)GOTO 1127
      CALL PUTC(3,M,48+I)
      CALL PUTC(4,M,MOD(BPS/1000,10)+48)
      GOTO 1130
1127  CALL PUTC(3,M,MOD(BPS/1000,10)+48)
      CALL PUTC(4,M,46)
      CALL PUTC(5,M,MOD(BPS/100,10)+48)

1130  CALL MTIME(DSEC,DTIME)
      CALL MTIME(USEC,UTIME)

C     HISTOGRAPH OUTAGE HOUR
      HOUR(1)=HOUR(1)+1
      I=MOD(DSEC/3600,24)+2
      HOUR(I)=HOUR(I)+1

      WRITE(21,1810)DTIME,UTIME,R1,N1,L1,R2,N2,L2,M,CIR,NPLI,UCNT
1810  FORMAT(1H ,8A1,1X,8A1,2X,A1,O4,A4,A1,O4,A4,1X,A5,2X,3A5,I5,I8)
      LINECT=LINECT+1
      IF(LINECT.GT.55)GOTO 1000
      GOTO 1100

C     DONE WITH DAY, TRY NEXT
2000  CALL DBCLOS
      JT=JT+24*3600
      IF(JT.LT.JTE)GOTO 500

      CLOSE(21)
      TYPE 12340,IEUSKE
12340 FORMAT(I10)
      CALL PUTC(8,OFILE,72)
      CALL PUTC(9,OFILE,73)
      CALL PUTC(10,OFILE,83)
      OPEN(21,OFILE,OUTPUT,SYMBOLIC)
      WRITE(21,2200)HOUR(1),(I,HOUR(I+2),I=0,23)
2200  FORMAT(3X,I6,/,(I3,I6))
      CLOSE(21)
      CALL DBEND
      CALL NEXIT
      END


      SUBROUTINE MTIME(J,A1)
C     ----------------------
C     SUBROUTINE TO MAKE A1 ARRAY TO TIME FROM JULIAN SECONDS.
C
C     INPUT:    J      -JULIAN SECONDS.
C
C     OUTPUT:   A1     -8A1 ARRAY OF FORMAT: HR:MN:SC  IF J NON-ZERO
C                                            ????????  IF J ZERO

      INTEGER DATE(4),A1(8)
      IF(J.EQ.0)GOTO 10320
      CALL DTFRMT(J,DATE)
      DECODE(20,10310,DATE)A1
10310 FORMAT(12X,8A1)
      RETURN

10320 DO 10330 I=1,8
10330 A1(I)=1H?
      RETURN
      END


      SUBROUTINE COPYA5(A1,L,IDEL,A5)
C     -------------------------------
C     SUBROUTINE TO COPY AN A5 ARRAY TILL DELIMITER A1 CHAR 'IDEL'
C     INTO A1 ARRAY STARTING AT POSITION L+1, INCREMENT L.

      INTEGER A1(1),A5(1)
      ICA1=1H 
      DO 12010 I=1,80
      CALL GETC(I,A5,IC)
      CALL PUTC(1,ICA1,IC)
      IF(ICA1.EQ.IDEL)RETURN
      L=L+1
12010 A1(L)=ICA1
      RETURN
      END


      SUBROUTINE COPYTB(A1,L,A5,I)
C     ----------------------------
C     SUBROUTINE TO COPY AN A5 ARRAY INTO AN A1 ARRAY WITHOUT
C     TRAILING BLANKS.

      INTEGER A1(1),A5(1)
      DO 13010 J=I*5,1,-1
      CALL GETC(J,A5,IC)
      IF(IC.NE.32)GOTO 13020
13010 CONTINUE
      RETURN

13020 ICA1=1H 
      DO 13030 K=1,J
      CALL GETC(K,A5,IC)
      CALL PUTC(1,ICA1,IC)
      L=L+1
13030 A1(L)=ICA1
      RETURN
      END


      SUBROUTINE MAKE10(A1,L,NUM)
C     ---------------------------
C     SUBROUTINE TO OUTPUT INTO AN A1 ARRAY A DECIMAL NUMBER WITHOUT
C     LEADING ZEROES.
C       INPUT:  A1     -A1 ARRAY
C               L      -LAST POSITION IN A1 ARRAY USED
C               NUM    -NUM TO MAKE
C
C       OUTPUT: A1     -DECIMAL STORED
C               L      -UPDATED TO LAST CHAR USED.

      INTEGER A1(1)

      J=0
      IC=1H 
      DO 310 I=5,1,-1
      II=MOD(NUM/10**I,10)
      IF(II+J.EQ.0)GOTO 310
      L=L+1
      CALL PUTC(1,IC,II+48)
      A1(L)=IC
      J=1
310   CONTINUE

      L=L+1
      CALL PUTC(1,IC,MOD(NUM,10)+48)
      A1(L)=IC
      RETURN
      END


      SUBROUTINE LOADQS
C     -----------------
C     SUBROUTINE TO CREATE AN INCORE TABLE TO DETERMINE IF A NODE PAIR
C     IS A POSSIBLE CANDIDATE FOR A CRITERIA.
C
C     OUTPUT:   DATAQS -BIT ARRAY INITIALIZED FOR SELECTION CRITERIA.
C
C     NOTE:    RECORDS THAT ARE CANDIDATES MUST BE SELECTED PRIOR TO CALL.

      INTEGER FIND(6)

      INTEGER DATAQS,BITS
      COMMON /FQS/DATAQS(279),BITS
      DATA BITS/10007/

      DO 10410 I=1,(35+BITS)/36
10410 DATAQS(I)=0

10440 CALL DBGREC($10490)
      CALL DBVAL('NODE1',NODE1,'PORT1',LINE1,
     1           'NODE2',NODE2,'PORT2',LINE2)
      IF(NODE1.LT.NODE2)GOTO 10450
      K=MOD(IOR(LSH(NODE2,16),NODE1),BITS)
      GOTO 10460
10450 K=MOD(IOR(LSH(NODE1,16),NODE2),BITS)
10460 CALL SETBYT(DATAQS(K/36+1),MOD(K,36),1,1)

      IF(LINE1.LT.0)GOTO 10470
      K=MOD(IOR(LSH(NODE1,6),LINE1),BITS)
      CALL SETBYT(DATAQS(K/36+1),MOD(K,36),1,1)
10470 IF(LINE2.LT.0)GOTO 10480
      K=MOD(IOR(LSH(NODE2,6),LINE2),BITS)
      CALL SETBYT(DATAQS(K/36+1),MOD(K,36),1,1)
10480 CONTINUE
      GOTO 10440

10490 CONTINUE
      RETURN
      END


      FUNCTION IFNDQS(NODE1,LINE1,NODE2,LINE2)
C     ----------------------------
C     FUNCTION TO DETERMINE IF AN NODE PAIR IS A POSSIBLE CANDIDATE
C     FOR A SELECTION CRITERIA.
C
C     INPUT:    NODE1  -1ST NODE, DECIMAL VALUE FOR OCTAL.
C               NODE2  -2ND NODE, DECIMAL VALUE FOR OCTAL.  NODE2>NODE1.
C
C     OUTPUT:   0      -NOT CANDIDATE
C               1      -POSSIBLE CANDIDATE, DATA BASE MUST BE EXAMINED
C                       TO DETERMINE TRUTH.
C
C     NOTE:    DATASQ MUST BE LOADED BY 'LOADQS'

      INTEGER DATAQS,BITS
      COMMON /FQS/DATAQS(279),BITS

      K=MOD(IOR(LSH(NODE1,16),NODE2),BITS)
      CALL GETBYT(DATAQS(K/36+1),MOD(K,36),1,IFNDQS)
      IF(IFNDQS.EQ.1)RETURN
      IF(LINE1.LT.0)GOTO 10510
      K=MOD(IOR(LSH(NODE1,6),LINE1),BITS)
      CALL GETBYT(DATAQS(K/36+1),MOD(K,36),1,IFNDQS)
      IF(IFNDQS.EQ.1)RETURN
10510 IF(LINE2.LT.0)RETURN
      K=MOD(IOR(LSH(NODE2,6),LINE2),BITS)
      CALL GETBYT(DATAQS(K/36+1),MOD(K,36),1,IFNDQS)
      RETURN
      END
 