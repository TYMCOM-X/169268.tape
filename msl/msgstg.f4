*       ********** MSGSTG.FTF VER.1 J.JOELS AUGUST,1977 **********
*                  MODIFIED BY PENNY LAWSON, JULY, 1978
*                  MODIFIED BY J.JOELS,    OCT, 1978
*                     CODE NOW GIVES NODECODE AND PORT-
*                     CODE OF '98' TO RECORD ON AN
*                     AUXILLIARY CIRCUIT

*               THIS PROGRAM APPENDS THE DAILY MESSAGE SWITCHER
*               ACCOUNTING SESSION FILES TO A MONTH-TO-DATE
*               FILE, AND COMPUTES THE DAILY STORAGE FOR EACH USER.

        INTEGER DATA(19),DATE(2),FLEDMS(3),FLESTG(3),FLEERR(2)
     X  ,SCR(6),SCR2(2),NEWMO,USER(3),ACCT(3),ACODE(3)
     X  ,UCODE(3),ERRCNT,NUCNT,IARR(21),IARR2(16),TSTOR,DSTOR
     X  ,EFLAG,MONTBL(12),PNT1(8),PNT2(7),FLSTG2(2),IARR4(5)
     X  ,IARR5(5),FLECOD(3),BILLMO,IARR3(5),FLEMTH(3),IARR6(5)
     X  ,FLEBAC(3),FLEAPP(3)

        FLECOD(3)='     '
        FLESTG(3)='     '
        FLEMTH(3)='     '
        FLEDMS(3)='     '
        IARR3(4)='     '
        IARR3(5)=0
        IARR4(5)=0
        IARR5(5)=0

        DATA MONTBL/31,29,31,30,31,30,31,31,30,31,30,31/
        DATA PNT1/1,4,7,10,13,16,19,0/
        DATA PNT2/1,4,7,10,13,16,0/

        COMMON/A1/ACODE,UCODE,ACCT,USER,DATA

        CALL DBSTRT(5,-1,-1,1,-4,0,21,-1,22,-1)

*       ** INITIALIZE VARIABLES
       NEWMO=0
        ERRCNT=0
        ICOUNT=0
        NUCNT=0
        EFLAG=0

*       ** OPEN THE CONTROL FILE AND INPUT DATE TO PROCESS
       OPEN (21,'STG.CTL',INPUT,ERR=690)
       READ (21,100) DATE(1),DATE(2)
       CLOSE (21)

*      BUILD FILE NAMES
100    FORMAT (I5,I1)
110    FORMAT (I5)
111    FORMAT (5I1)
112    FORMAT (I1)
114    FORMAT (1HS,5I1,4H.DMS)
115     FORMAT (1HS,5I1,4H.ERR)
116     FORMAT (1HS,5I1,4H.BAC)
117     FORMAT (2HMS,4I1,1H.,2I1,1HC)
118     FORMAT (2HMS,4I1,1H.,2I1,1HB)


       ENCODE (5,110,L)DATE(1)
       DECODE (5,111,L) (SCR(I),I=1,5)
        ENCODE (1,112,L)DATE(2)
        DECODE (1,112,L)SCR(6)
       ENCODE (10,114,FLEDMS)(SCR(I),I=2,6)
        ENCODE (10,115,FLEERR) (SCR(I),I=2,6)
        ENCODE (10,116,FLEBAC) (SCR(I),I=2,6)
        ENCODE (10,117,FLECOD) (SCR(I),I=1,6)
        ENCODE (10,118,FLEAPP) (SCR(I),I=1,6)


*       ** ARRAY: FLEDMS - NOW CONTAINS THE NAME OF THE DAILY SESSION
*               FILE -- OUTPUT FILE--
*       ** ARRAY: FLEERR - NOW CONTAINS THE NAME OF THE ERROR FILE
*               -- OUTPUT FILE --
*       ** ARRAY: FLECOD - NOW CONTAINS THE NAME THE DAILY 'CODED'
*               FILE --INPUT FILE--


*       ** PLACE YEAR,DAY, AND MONTH INTO VARIABLES IYEAR,IDAY, & IMO
        IYEAR=SCR(1)*10+SCR(2)
        IDAY=SCR(5)*10+SCR(6)
        IMO=SCR(3)*10+SCR(4)

*       ** DETERMINE THE BILLING MONTH NUMBER. IF THE DAY TO PROCESS
*          IS IN THE LAST HALF OF A MONTH, THEN IT WILL BE BILLED IN
*          THE NEXT MONTH. SO, INCREMENT IMO BY 1 TO OBTAIN THE 
*          BILLING MONTH NUMBER.
        BILLMO=IMO
        IF (IDAY.GE.16) BILLMO=IMO+1
        IF (IDAY.NE.16) GO TO 150

*       ***** THIS IS THE 1ST DAY OF THE BILLING PERIOD.  SAVE THE
*             CURRENT STORAGE FILE AS A 1022 DATA BASE. (FILE
*               NAME FORMAT= STRAGE.##  WHERE ## IS THE 2-DIGIT
*               MONTH NUMBER.

*       ** AT THIS POINT BILLMO= THE BILLING MONTH # FOR THE NEW
*          MONTH- DECREMENT THIS # TO OBTAIN LAST MONTH'S # AND USE
*          THAT # TO BUILD THE FILE NAME FOR LAST MONTH'S STORAGE FILE.
        IMO2=BILLMO-1
        IF (IMO2.EQ.0) IMO2=12
        ENCODE (2,120,L)IMO2
120     FORMAT (I2)
        DECODE (2,121,L)(SCR2(I),I=1,2)
121     FORMAT (2I1)
        ENCODE (9,125,FLESTG)(SCR2(I),I=1,2)
125     FORMAT (7HSTRAGE.,2I1)

*       ** ARRAY: FLESTG NOW CONTAINS THE FILE NAME OF LAST MONTH'S
*          STORAGE FILE.


*       ** USE ARRAY: IARR3 - TO PASS THE DUMP COMMAND TO 1022
        IARR3(1)='DUMP '
        IARR3(2)=FLESTG(1)
        IARR3(3)=FLESTG(2)
        IARR3(4)='     '
        IARR3(5)=0

*       ** OPEN THE CURRENT STORAGE FILE AND USE THE 1022 DUMP
*          COMMAND TO CREATE LAST MONTH'S STORAGE FILE.
*          THEN KEY ALL FIELDS OF THE OLD STORAGE FILE.
        CALL DBOPEN ('STRAGE.DMS')
        CALL DBFIND ('ALL')
        CALL DBNREC(IREC)
        CALL DBEXEC (IARR3)
        CALL DBEXEC('RELEASE')
        CALL DBCLOS
        CALL DBOPEN(FLESTG)
        CALL DBEXEC ('KEY ALL')
        CALL DBCLOS

*       ** SET THE NEW MONTH FLAG TO BE USED LATER  TO CREATE
*          THE NEW MONTH-TO-DATE FILE
        NEWMO=1


*       OPEN SYMBOLIC OUTPUT FILES TO BE USED BY
*       THE 'ERROR' AND 'NEWUSR'  SUBROUTINES.  
*       ALSO, OPEN THE NEW DAILY CODED FILE FOR OUTPUT. (MS####.##B)
*       THIS FILE IS A COPY OF THE MS####.##C FILE EXCEPT FOR THE
*       NODE AND PORT CODES ON THE AUXILLIARY CIRCUITS, WHICH HAVE
*       BEEN CHANGED TO '98'. THIS FILE IS A TEMPORARY FILE AND WILL
*       BE DELETED BY THIS PROGRAM AFTER A SUCCESSFUL RUN.
150     OPEN (21,'NEWUSR.DAT',RANDIO)
        OPEN (22,FLEERR,OUTPUT)
        OPEN (24,FLEAPP,OUTPUT)

*       LOAD THE DAILY CODED FILE INTO 1022
*       TO DO THIS FIRST UPDATE THE MSG.DMD FILE WITH THE
*       APPROPRIATE DATE.
        OPEN (23,'MSG.DMD',RANDIO)
        WRITE (23#28,155)(SCR(I),I=1,6)
155     FORMAT (4I1,1H.,2I1,$)
        WRITE (23#48,154)(SCR(I),I=2,6)
154     FORMAT(5I1,$)
        CLOSE (23)

        CALL DBEXEC('LOAD MSG')

*       OPEN THE DAILY .DMS FILE AND THE STORAGE .DMS FILE
*       USE THE STORAGE CONTAINED IN THE LAST SESSION OF THE DAY
*       FOR EACH USER TO UPDATE THE STORAGE FIELD FOR THAT USER IN THE
*       STORAGE FILE.

*       OPEN THE FILES, SET THE CURRENT FILE TO THE DAILY FILE, 
*       SELECT ALL OF THE SESSIONS, AND SORT. CREATE BACK-UP STORAGE
*       FILE IN CASE THE PROGRAM IS DROPPED IN THE MIDDLE
*       AND HAS TO BE RE-STARTED.

*       **USE ARRAY:  IARR6 - TO PASS THE DUMP COMMAND TO 1022 TO CREATE
*       THE BACK-UP STORAGE FILE:  SYMMDD.BAC
        IARR6(1)='DUMP '
        IARR6(2)=FLEBAC(1)
        IARR6(3)=FLEBAC(2)
        IARR6(4)='     '
        IARR6(5)=0

        CALL DBOPEN(FLEDMS,'STRAGE.DMS')
        CALL DBSET(2)
        CALL DBFIND('ALL')
        CALL DBEXEC(IARR6)
        CALL DBEXEC('RELEASE')

        TYPE 160,FLEBAC(1),FLEBAC(2)
160     FORMAT (/,1X'BACK-UP FILE:  ',2A5)

        CALL DBSET(1)
        CALL DBFIND('ALL')
        CALL DBSORT('ACCTCODE','USERCODE','ENDDATE','ENDTIME')

*       SET ARRAYS 'ACCT', 'USER', 'IARR', AND 'IARR2' TO BLANKS.
*       ARRAYS 'ACCT' AND 'USER' ARE USED TO COMPARE THE ACCTCODE AND 
*       USERCODE OF EACH SESSION TO DETERMINE THE LAST SESSION
*       OF THE DAY FOR THAT USER.
*       ARRAYS 'IARR' AND 'IARR2' ARE USED TO PASS ARGUMENTS TO THE 
*       DBFIND AND DBCHNG ROUTINES RESPECTIVELY.

        DO 175 I=1,3
        ACCT(I)='     '
        USER(I)='     '
175     CONTINUE

        DO 176 I=1,21
        IARR(I)='     '
176     CONTINUE

        DO 177 I=1,16
        IARR2(I)='     '
177     CONTINUE


*       GET ONE RECORD FROM THE DAILY FILE, READ ACCTCODE VALUES
*       INTO ARRAY 'ACODE', READ USERCODE VALUES INTO ARRAY 'UCODE'.
        CALL DBGREC ($500)
        ICOUNT=ICOUNT+1
        CALL DBVAL(1,ACODE,2,UCODE)

*       THIS IS THE FIRST RECORD.  INITILIZE 'ACCT' AND 'USER' TO
*        THE VALUES THAT ACCTCODE AND USERCODE HAVE IN THIS RECORD.
        CALL SET
 180    CALL READ(EFLAG,ERRCNT,ICOUNT)
        IF (EFLAG.EQ.1) GO TO 200

*       CHECK TO SEE IF 'ACCT' OR 'USER' CHANGES, IF SO, GO AND UPDATE
*       STORAGE FILE. IF NOT, PROCESS NEXT RECORD.
        IF ((ACODE(1).NE.ACCT(1).OR.ACODE(2).NE.ACCT(2).OR.ACODE(3).
     XNE.ACCT(3))) GO TO 200
        IF ((UCODE(1).NE.USER(1).OR.UCODE(2).NE.USER(2).OR.UCODE(3).
     XNE.USER(3))) GO TO 200
        GO TO 180



*       SET CURRENT FILE TO STORAGE FILE. BUILD ACCTCODE AND USERCODE
*       INTO ARRAY: IARR TO PASS ARGUMENTS TO THE DBFIND COMMAND.
200     CALL DBSET(2)

        IARR(1)=1
        IARR(4)='EQ   '
        IARR(7)=ACCT(1)
        IARR(8)=ACCT(2)
        IARR(9)=ACCT(3)
        IARR(10)='AND  '
        IARR(13)=2
        IARR(16)='EQ   '
        IARR(19)=USER(1)
        IARR(20)=USER(2)
        IARR(21)=USER(3)

*       FIND THE SPECIFIED RECORD, IF FOUND UPDATE THE RECORD WITH
*       STORAGE DATA FROM DAILY FILE. IF RECORD NOT FOUND GO AND
*       ADD USER TO STORAGE FILE.
        CALL DBFIND('PNT.',PNT1,IARR)
        CALL DBNREC(IREC)
        IF (IREC.EQ.0) GO TO 300
        CALL DBCHNG('DAYSTOR',DATA(9))
        
*       SET CURRENT FILE BACK TO DAILY FILE, SET ACCT=ACODE, SET
*       USER=UCODE, AND THEN GO PROCESS ANOTHER RECORD.
        CALL DBSET(1)
        CALL SET
        IF (EFLAG.EQ.1) GO TO 500
        GO TO 180


*       BUILD ACCTCODE , USERCODE AND STORAGE INTO ARRAY: IARR2 TO
*       PASS ARGUMENTS TO THE DBADD COMMAND
300     IARR2(1)=1
        IARR2(4)=ACCT(1)
        IARR2(5)=ACCT(2)
        IARR2(6)=ACCT(3)
        IARR2(7)=2
        IARR2(10)=USER(1)
        IARR2(11)=USER(2)
        IARR2(12)=USER(3)
        IARR2(13)=3
        IARR2(16)=DATA(9)

*       ADD THE NEW USER TO THE STORAGE FILE. THEN, CALL NEWUSER
*       SUBROUTINE TO MAKE NOTE OF THE NEW USER IN THE 'NEWUSR.DAT' FILE
*       SET CURRENT FILE BACK TO THE DAILY FILE, SET ACCT=ACODE,
*       SET USER=UCODE, AND GO PROCESS ANOTHER RECORD.
        CALL DBADD('PNT.',PNT2,IARR2)
        CALL NEWUSR(NUCNT)
        CALL DBSET(1)
        CALL SET
        IF (EFLAG.EQ.1) GO TO 500
        GO TO 180

*       FINISHED PROCESSING ALL RECORDS FOR THIS DAY.  CLOSE NEW
*       USER FILE, ERROR FILE , DAILY CODED FILE, AND DAILY 1022 FILE.
500     CLOSE (21)
        CLOSE (22)
        CLOSE (24)
        CALL DBCLOS

*       CURRENT FILE IS NOW STORAGE FILE SINCE IT IS THE ONLY ONE
*       LEFT OPEN. SELECT ALL RECORDS, AND THEN, RECORD BY RECORD,
*       UPDATE TOTAL STORAGE WITH THE DAILY STORAGE.

        TYPE 505
505     FORMAT (/,1X,'****UPDATING TOTAL STORAGE****',//)

        CALL DBFIND('ALL')
        CALL DBNREC(IREC)
510     CALL DBGREC($550)
        CALL DBVAL(3,DSTOR,4,TSTOR)
        TSTOR=TSTOR+DSTOR

*       ** IF THIS IS THE 1ST DAY OF A NEW BILLING PERIOD - THEN
*          SET TOTAL STORAGE EQUAL TO THE DAILY STORAGE .
        IF (NEWMO.EQ.1) TSTOR=DSTOR
        CALL DBCHNG('TOTSTOR',TSTOR)
        GO TO 510

*       END OF PROCESSING. CLOSE THE STORAGE FILE.
550    CALL DBCLOS

*       OPEN THE MONTH TO DAY FILE AND APPEND THE DAILY FILE TO IT.

*       ** BUILD THE MONTH-TO-DATE FILE NAME INTO ARRAY: FLEMTH
        IF (BILLMO.EQ.13) BILLMO=1
        ENCODE (2,120,LL)BILLMO
        DECODE (2,121,LL)(SCR2(I),I=1,2)
        ENCODE (10,555,FLEMTH) (SCR2(I),I=1,2)
555     FORMAT (4HMACT,2I1,4H.DMS)

*       ** IF THIS IS 1ST DAY OF A NEW BILLING PERIOD GO AND CREATE
*          A NEW MONTH-TO-DATE FILE

        IARR5(1)='APPEN'
        IARR5(2)='D    '
        IARR5(3)=FLEAPP(1)
        IARR5(4)=FLEAPP(2)
        IARR5(5)=0

        IF (IDAY.EQ.16) GO TO 556
        CALL DBOPEN(FLEMTH)
        CALL DBEXEC(IARR5)
        GO TO 557

*       ** CREATE A NEW MONTH-TO-DATE FILE BY LOADING AN EMPTY FILE
*          CALLED NEWMON.DMI
556     OPEN (23,'NEWMON.DMD',RANDIO)
        WRITE (23#51,565)(SCR2(I),I=1,2)
565     FORMAT (2I1,$)
        CLOSE(23)

        CALL DBEXEC ('LOAD NEWMON.DMD')
        CALL DBOPEN(FLEMTH)
        CALL DBFIND('ALL')
        CALL DBDEL
        CALL DBEXEC(IARR5)

*       ** NOW - KEY FILEDS: ACCTCODE AND USERCODE - OF THE NEW
*          MONTH-TO-DATE FILE
        CALL DBEXEC('KEY ACCTCODE USERCODE')

*       ** PRINT TOTAL SESSIONS, TOTAL ERRORS, AND TOTAL NEW USERS
*          TO THE TERMINAL.
557     TYPE 560,DATE(1),DATE(2),ICOUNT,ERRCNT,NUCNT
560     FORMAT (//,5X,'-----',I5,I1,'-----',//,5X,'SESSIONS PROCESSED= '
     X,I5,/,5X,'NUMBER OF ERROR CODES= ',I5,/,5X,'NUMBER OF NEW USERS
     X=',I5,//)

*       ** INCREMENT VARIABLE: IDAY TO OBTAIN NEXT DATE TO PROCESS
        IDAY=IDAY+1
        IF (IDAY.LE.MONTBL(IMO)) GO TO 580
        IDAY=1
        IMO=IMO+1
        IF (IMO.LE.12) GO TO 580
        IMO=1
        IYEAR=IYEAR+1

*       ** OPEN THE CONTROL FILE AND OUTPUT THE NEXT DAY TO PROCESS
580     OPEN (21,'STG.CTL',OUTPUT)
        WRITE (21,590)IYEAR,IMO,IDAY
590     FORMAT (3I2)
        CLOSE (21)

        TYPE 595
595     FORMAT (/,1X,'CONTROL FILE UPDATED')
        GO TO 700

690     TYPE 695
695     FORMAT (/,1X,'UNABLE TO OPEN FILE: STG.CTL')


700     CALL DELET(FLEAPP,IERROR)
        IF (IERROR.LT.1.OR.IERROR.GT.9) GO TO 750
        TYPE 710,(FLEAPP(I),I=1,2),IERROR
710     FORMAT (1X,'UNABLE TO DELETE FILE: ',2A5,3X,'(ERROR #',I2,')')

750     END



*       ********************SUBROUTINE SET********************
*       THIS SUBROUTINE SETS THE VALUES OF ARRAYS 'USER' AND
*       'ACCT' TO THE VALUES OF ARRAYS 'UCODE' AND 'ACODE'
*       RESPECTIVELY.

        SUBROUTINE SET

        COMMON/A1/ACODE,UCODE,ACCT,USER,DATA

        INTEGER ACODE(3),UCODE(3),ACCT(3),USER(3),DATA(19)

        DO 100 I=1,3
        USER(I)=UCODE(I)
100     CONTINUE

        DO 200 I=1,3
        ACCT(I)=ACODE(I)
200     CONTINUE
        RETURN
        END

*       ********************SUBROUTINE READ********************
*       THIS SUBROUTINE READS THE INTEGER VALUES OF THE CURRENT
*       RECORD INTO THE ARRAY 'DATA'. THEN CHECKS FOR ERROR CODES.

        SUBROUTINE READ(EFLAG,ERRCNT,ICOUNT)

        COMMON/A1/ACODE,UCODE,ACCT,USER,DATA

        INTEGER ACODE(3),UCODE(3),ACCT(3),USER(3),DATA(19),EFLAG,
     X  ERRCNT

        DO 100 I=3,18

*       ** IF THIS IS TOTMIN FIELD, PLACE VALUE INTO A REAL VARIABLE
        IF (I.EQ.12) GO TO 95
        CALL DBVAL(I,DATA(I-2))
        GO TO 100

*       ** THIS IS THE TOTMIN FIELD
95      CALL DBVAL(I,TOTMIN)

100     CONTINUE

*       ** IF PORTCODE IS 99 AND ORIGNODE IS LT 1000, THEN THIS IS AN
*          AUXILLIARY CIRCUIT CHANGE THE NODECODE AND PORTCODE TO 98.

        IF (DATA(16).NE.99.OR.DATA(12).GE.1000.OR.DATA(12).LT.1)
     X GO TO 110
        DATA(15)=98
        DATA(16)=98


*       CHECK FOR BAD NODE OR PORT CODES.  WHEN FOUND CALL
*       'ERROR' SUBROUTINE, WHICH WILL MAKE NOTE OF THE ERROR IN AN
*       ERROR FILE. CONTINUE PROCESSING RECORD.

*       ** IF NODE CODE IS NOT A 1,2,4,7,OR 98, WRITE THE RECORD TO THE
*          ERROR FILE.
110     IF (DATA(15).EQ.1.OR.DATA(15).EQ.2.OR.DATA(15).EQ.4.OR.DATA(15)
     X .EQ.5.OR.DATA(15).EQ.6.OR.DATA(15).EQ.7.OR.DATA(15).EQ.98)
     X GO TO 120
        CALL ERROR(ERRCNT)
        GO TO 150

*       ** IF PORT CODE IS NOT EQUAL TO 1,2,3,4,5,6,7,8,OR 98 THEN, OUTPUT
*          THE RECORD TO THE ERROR FILE.
120     IF ( (DATA(16).LT.1) .OR. (DATA(16).GT.8.AND.DATA(16).LT.98)
     X  .OR. (DATA(16).GE.99) ) CALL ERROR(ERRCNT)

*       ** WRITE THIS RECORD TO THE NEW DAILY CODED FILE WHICH IS
*          TO BE APPENDED TO THE MONTH TO DATE FILE

150     WRITE (24,160)(ACODE(I),I=1,3),(UCODE(I),I=1,3),(DATA(I),I=1,9)
     X,TOTMIN,(DATA(I),I=11,16)
160     FORMAT (2(2A5,A2),4I6,2(I7,I5),I8,F9.3,I2,I4,I3,I8,2I2)

*       ** GET THE NEXT RECORD TO PROCESS
        CALL DBGREC($200)

*       ** INCREMENT RECORD COUNTER
        ICOUNT=ICOUNT+1

*       ** PLACE VALUE OF FIELDS ACCTCODE AND USERCODE INTO ARRAYS:
*          ACODE AND UCODE  RESPECTIVELY.
        CALL DBVAL(1,ACODE,2,UCODE)
        GO TO 300

200     EFLAG=1
300     RETURN
        END



*       ********************SUBROUTINE ERROR********************
*       THIS SUBROUTINE WRITES AN ERROR RECORD OUT TO THE ERROR
*       FILE 'MYMMDD.ERR'.

        SUBROUTINE ERROR(ERRCNT)

        COMMON/A1/ACODE,UCODE,ACCT,USER,DATA

        INTEGER ACODE(3),UCODE(3),DATA(19),ACCT(3),USER(3),ERRCNT

        WRITE (22,10)DATA(14),(ACODE(I),I=1,3),(UCODE(I),I=1,3),
     XDATA(12),DATA(13),DATA(15),DATA(16)
10      FORMAT(I8,1X,'#COM',2(1X,2A5,A2),I4,1X,I3,1X,I2,1X,I2,'.')

*       ** INCREMENT ERROR COUNTER
        ERRCNT=ERRCNT+1
        RETURN
        END


*       ********************SUBROUTINE NEWUSR********************
*       THIS SUBROUTINE WRITES NEW USER ACCOUNTCODE AND USERCODE
*       TO THE NEW USER FILE 'NEWUSR.DAT'.

        SUBROUTINE NEWUSR(NUCNT)

        COMMON/A1/ACODE,UCODE,ACCT,USER,DATA

        INTEGER ACODE(3),UCODE(3),ACCT(3),USER(3),DATA(19),NUCNT

*       ** SET FILE POSITION TO END-OF-FILE
        IS=SIZE(21)
        IS=IS+1
*       ** APPEND RECORD TO END OF FILE
        WRITE (21#IS,10)(ACCT(I),I=1,3),(USER(I),I=1,3),DATA(4)
10      FORMAT (2(1X,2A5,A2),1X,I6)

*       ** INCREMENT THE NEW USER COUNTER
        NUCNT=NUCNT+1
        RETURN
        END
 