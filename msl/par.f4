

*       ********** PAR.F4   VER.3 J.JOELS SEPT/1978************
*       ********** PAR = PORT ANALYSIS REPORT       ***********
*       THIS PROGRAM PRODUCES A REPORT WHICH CONTAINS THE FOLLOWING
*       INFORMATION ABOUT EVERY NODE-PORT PAIR IN THE NETWORK:
*               1. NUMBER OF SESSIONS FOR THE GIVEN 5 DAY PERIOD
*               2. NUMBER OF CONNECT MINUTES
*               3. NUMBER OF KILO CHARACTERS
*               4. AVGERAGE HOLDING TIME
*               5. NUMBER OF CHARACTERS PER SEC
*               6. THE TYPE OF PORT (FX,WATS,PUBLIC, OR PRIVATE)
*
*       THE FOLLOWING FILES ARE REQUIRED TO BE IN THE (NETCON)
*       DIRECTORY BEFORE THIS PROGRAM IS RUN.
*               1. A SNAPSHOT OF THE NETWORK TAKEN ON THE FIRST
*                  DAY OF THE 5 DAY PERIOD USING PROGRAM (ACCG1:30)
*                  PORLIS.
*               2. 5 DMD FILES: (A) PORLIS.DMD (B) PAR.DMD
*                  (C) PAR2.DMD (D) PARR1.DMD  (E) PARR2.DMD
*               3. PRINT.PAR
*               4. 2 DMC FILES: (A) PAR.DMC (B) PAR2.DMC

        INTEGER DNAME(3),SCR(6),FLEDMS(3),DAYNAM(4),TMPNAM(3)
     X  ,IARR(5),DMSNAM(3),IARR2(5),DATNAM(3),DATA(6,2000),PCODE
     X  ,MONTBL(12),LL(2),PHONE(6),TOTCNT,REPNAM(3),COM,PHASE
     X  ,SCR2(6),P2FLAG,P4DAY,P4FLAG,ADDNAM(5),RENNAM(5),PRTNAM(5)
     X  ,DCNT,OCNT,PRTCOD,PRTFLG,ENDFLG,NODCOD,DELNAM(3)

        DATA MONTBL/31,29,31,30,31,30,31,31,30,31,30,31/

        CALL DBSTRT(5,-1,-1,1,-4,0,21,-1,22,-1)

        IARR(1)='INIT '
        IARR(2)='1    '
        IARR(5)='     '

        NODE=0
        DCNT=0
        NULL=0

*       ********** INPUT: STARTUP TYPE (RUN OR RESTART) **********
*
75      TYPE 80
80      FORMAT (//,1X,'VERSION 2.0',///,1X,': ',$)
        ACCEPT 85,COM
85      FORMAT(A3)
        IF (COM.EQ.'RUN'.OR.COM.EQ.'RES') GO TO 90
        TYPE 86
86      FORMAT (/1X,'POSSIBLE COMMANDS ARE: RUN OR RESTART',/)
        GO TO 75

*       ********** INPUT: STARTING DATE AND PORTS  **********
*                  DATA BASE NAME
*

90      TYPE 100
100     FORMAT (1X,'INPUT: STARTING DATE (YYMMDD): ',$)
        ACCEPT 110,IYR,IMO,IDAY
110     FORMAT (3I2)

*       ** OPEN PAR2.DMC (FINAL REPORT GENERATOR) AND OUTPUT DATE RANGE

*       ** FIRST DETERMINE WHAT THE DATE IS 5 DAYS FROM THE DAY JUST
*          INPUT.
        IDAY2=IDAY
        IMO2=IMO
        IYR2=IYR

        DO 113 I=1,4
        IDAY2=IDAY2+1
        IF (IDAY2.LE.MONTBL(IMO2)) GO TO 113
        IDAY2=1
        IMO2=IMO2+1
        IF (IMO2.LE.12) GO TO 113
        IMO2=1
        IYR2=IYR2+1
113     CONTINUE

        OPEN (21,'PAR2.DMC',RANDIO)
        WRITE (21#157,115)IMO,IDAY,IYR,IMO2,IDAY2,IYR2
115     FORMAT (2(I2,'/'),I2,'-',2(I2,'/'),I2,$)
        CLOSE(21)

        TYPE 120
120     FORMAT (1X,'INPUT: PORTS DATA BASE NAME: ',$)
        ACCEPT 130,(DNAME(I),I=1,3)
130     FORMAT (3A5)

*       ** INPUT RUN

131     TYPE 132
132     FORMAT (1X,'INPUT: RUN NUMBER (1 OR 2): ',$)
        ACCEPT 133,IRUNUM
133     FORMAT (I1)
        IF (IRUNUM.NE.1.AND.IRUNUM.NE.2) GO TO 131


*       ********** INPUT: IF RESTARTING INPUT PHASE # TO **********
*                  RESTART WITH

        IF (COM.EQ.'RUN') GO TO 145
134     TYPE 135
135     FORMAT (1X,'ENTER PHASE # TO RESTART WITH: ',$)
        ACCEPT 136,PHASE
136     FORMAT (I1)
        IF (PHASE.GE.2.AND.PHASE.LE.7) GO TO 138
        TYPE 137
137     FORMAT (1X,'POSSIBLE PHASE NUMBERS ARE: 2,3,4,5,6,7: ',/)
        GO TO 134

*       ** INPUT: IF PHASE=2 INPUT LAST DATE COMPLETED

138     IF (PHASE.NE.2) GO TO 145
        TYPE 11111
11111   FORMAT (1X,'ANY DAYS COMPLETED IN PHASE 2? (Y OR N)',$)
        ACCEPT 11112,IANS
11112   FORMAT(A1)
        IF(IANS.EQ.'Y')GO TO 141
        COM=3HRUN
        GO TO 145
141     TYPE 139
139     FORMAT (1X,'ENTER LAST DATE COMPLETED IN PHASE 2: (YYMMDD): ',$)
        ACCEPT 110,ICYR,ICMO,ICDAY

145     ENCODE (6,150,LL)IYR,IMO,IDAY
        DECODE (6,151,LL)(SCR(I),I=1,6)
        ENCODE (9,152,FLEDMS)(SCR(I),I=3,4)
150     FORMAT (3I2)
151     FORMAT (6I1)
152     FORMAT (3HPAR,2I1,4H.DMS)


*       ** IF RESTARTING BRANCH TO APPROPRIATE PORTION
*          OF CODE.

        IF (PHASE.EQ.2)GO TO 20
        IF (COM.EQ.'RUN') GO TO 10
        GO TO (10,20,30,40,50,60,70),PHASE

*       **********  PHASE 1: LOAD THE SNAPSHOT FILE  **********
10      TYPE 155
155     FORMAT (//5X,'BEGINNING PHASE 1',/)

*       **OPEN PORLIS.DMD FILE AND UPDATE INPUT FILE WITH NAME
*       OF PORTS DATA BASE.  THIS DMD FILE WILL BE USED TO LOAD
*       THE PORTS DATA BASE INTO 1022.

        OPEN (21,'PORLIS.DMD',RANDIO)
        WRITE (21#24,160) (DNAME(I),I=1,2)
160     FORMAT(A5,A4,$)
        IPOS=POSITION(21)
        IPOS=IPOS+9
        WRITE (21#IPOS,162) (FLEDMS(I),I=1,2)
162     FORMAT (A5,A4)
        CLOSE(21)

*       **LOAD THE PORTS DATA BASE INTO 1022
        CALL DBEXEC('LOAD PORLIS.DMD')
        TYPE 170
170     FORMAT (5X,'PHASE 1 COMPLETED',/)


*       **********  PHASE 2:  CREATE 5 SYM FILES FROM 5  **********
*                   DAILY NETWORK STATISTICS FILES.
*                   CONTAINING ONLY FIELDS: ORIGNODE
*                   ORIGPORT, TOTMIN AND TOTALCHARS

20      TYPE 190
190     FORMAT (//5X,'BEGINNING PHASE 2',/)

        P2FLAG=0
        ITOT=0
        IDAY2=IDAY-1
        IMO2=IMO
        IYR2=IYR
        DO 250 I=1,5

*       ** STARTING WITH START DAY BUILD THE DAILY NETWORK FILE NAME
*          INTO ARRAY: DAYNAM. BUILD CORRESPONDING TMP FILE NAME
*          INTO ARRAY: TMPNAM

        IDAY2=IDAY2+1
        IF (IDAY2.LE.MONTBL(IMO)) GO TO 195
        IDAY2=1
        IMO2=IMO2+1
        IF (IMO2.LE.12) GO TO 195
        IMO2=1
        IYR2=IYR2+1

*       ** IF RESTARTING GO THROUGH LOOP WITHOUT PROCESSING A FILE
*          UNTIL IDAY2 = ICDAY (THE LAST DAY COMPLETED). THEN
*          START PORCESSING NEXT DAY.

195     IF (COM.EQ.'RUN') GO TO 200
        IF (P2FLAG.NE.0) GO TO 200
        IF (IDAY2.NE.ICDAY) GO TO 250
        P2FLAG=1
        GO TO 250

200     ENCODE (6,208,LL)IYR2,IMO2,IDAY2
208     FORMAT (3I2)
        DECODE (6,209,LL)(SCR2(L),L=1,6)
209     FORMAT (6I1)
        ENCODE (19,210,DAYNAM)(SCR2(L),L=1,6)
210     FORMAT (9H(NETSTAT),6I1,4H.DMS)
        ENCODE (9,211,TMPNAM)I
211     FORMAT (4HPARD,I1,4H.DAT)

*       ** BUILD COMMANDS INTO ARRAY: IARR  THAT WILL INITIALIZE DEVICE
*          1 TO THE CORRECT OUTPUT FILE.

        IARR(1)='INIT '
        IARR(2)='1    '
        IARR(3)=TMPNAM(1)
        IARR(4)=TMPNAM(2)
        IARR(5)='     '

*       ** OPEN THE DAILY NETWORK FILE, FIND ALL SESSIONS, INIT
*          DEVICE TO OUTPUT FILE, OUTPUT SESSIONS TO FILE IN NEW
*          FORMAT, RELEASE THE DEVICE, AND CLOSE THE DAILY NETSTAT
*          FILE

        CALL DBOPEN(DAYNAM)

*       ** DEPENDING ON RUN NUMBER SELECT THE CORRECT SET OF NODES

        IF (IRUNUM.EQ.2) GO TO 212
        CALL DBFIND('ORIGNODE','GE',1000,'AND','ORIGNODE','LE',1075)
        GO TO 213

212     CALL DBFIND('ORIGNODE','GE',1076)
213     CALL DBNREC(IREC)
        CALL DBEXEC(IARR)
        CALL DBEXEC('USE PRINT.PAR')
        CALL DBEXEC('RELEASE')
        CALL DBCLOS

        TYPE 220,IREC,(DAYNAM(L),L=1,4)
220     FORMAT(1X,I6,' SESSIONS PROCESSED FOR FILE: ',4A5/)
        ITOT=ITOT+IREC
250     CONTINUE

        TYPE 260,ITOT
260     FORMAT(//5X,'PHASE 2 COMPLETED'/5X,'PROCESSED ',I6,' SESSIONS'/)


*       ********** PHASE 3: LOAD FIRST DAILY FILE INTO **********
*                  1022 FILE: PORTS.DMS

30      TYPE 270
270     FORMAT (//5X,'BEGINNING PHASE 3',/)

        CALL DBEXEC ('LOAD PAR.DMD')
        COM='RUN'

        TYPE 275
275     FORMAT (//5X,'PHASE 3 COMPLETED',/)


*       ********** PHASE 4: APPEND THE REMAINING 4 DAILY **********
*                  FILES TO 1022 FILE: PORTS.DMS

40      TYPE 300
300     FORMAT (//5X,'BEGINNING PHASE 4',/)
303     IF (COM.EQ.'RES') GO TO 302

*       ** TO ENABLE CLEAN RESTARTS COPY THE FILE: PAR.DMS
*          TO A TEMPORARY FILE CALLED PAR.A1. APPEND THE SECOND DAYS
*          DATA TO THIS FILE. IF APPEND COMPLETES SUCCESSFULLY
*          RENAME PAR.A1 TO PAR.A2. THEN APPEND DAY 3 TO PAR.A2
*          ETC. ETC

        CALL DBOPEN ('PAR.DMS')
        CALL DBFIND('ALL')
        CALL DBEXEC('DUMP PAR.A1')
        CALL DBCLOS
302     P4FLAG=0

        DO 315 I=2,5


*       ** BUILD FILE NAME TO APPEND TO INTO ARRAY: ADDNAM

        I2=I-1
        ENCODE (6,301,ADDNAM)I2
301     FORMAT (5HPAR.A,I1)

*       ** IF RESTARTING TRY OPENING EACH POSSIBLE TEMPORARY
*          APPEND FILE NAME. IF OPEN IS SUCCESSFUL THEN START APPENDING
*          NEXT DAYS DATA TO THAT FILE. I.E IF PAR.A1
*          IS IN THE DIRECTORY THEN APPEND DAY 2'S DATA TO IT, AND 
*         CONTINUE FROM THERE.

        IF (COM.EQ.'RUN') GO TO 304
        IF (PHASE.NE.4) GO TO 304
        IF (P4FLAG.NE.0) GO TO 304
        OPEN (21,ADDNAM,INPUT,BINARY,ERR=315)
        CLOSE (21)
        P4FLAG=1

304     CALL DBOPEN(ADDNAM)
        ENCODE (10,211,DAYNAM)I

        IARR2(1)='APPEN'
        IARR2(2)='D    '
        IARR2(3)=DAYNAM(1)
        IARR2(4)=DAYNAM(2)

        CALL DBEXEC (IARR2)
        CALL DBCLOS

*       ** FOR DAYS 2-4 RENAME THE FILE JUST APPENDED
*          TO TO THE APPROPRIATE FILE NAME. IE. IF PORT.A1
*          HAS BEEN SUCCESSFULLY APPENDED TO, RENAME IT TO PAR.A2

        IF (I.EQ.5) GO TO 306
        ENCODE (8,301,RENNAM)I
        CALL RENAM(ADDNAM,RENNAM,IERROR)
        IF (IERROR.GE.1.AND.IERROR.LE.9) GO TO 307
        GO TO 310

*       ** IF THIS IS THE LAST DAY, DELETE PAR.DMS (WHICH 
*          CONTAINS ONLY THE FIRST DAYS DATA AND RENAME
*       PAR.A4 (WHICH NOW CONTAINS ALL 5 DAYS DATA) TO PAR.DMS

306     PRTNAM(1)='PAR.D'
        PRTNAM(2)='MS   '
        P4FLG=1

        CALL DELET(PRTNAM,IERROR)
        IF (IERROR.GE.1.AND.IERROR.LE.9) GO TO 307
        CALL RENAM(ADDNAM,PRTNAM,IERROR)
        IF(IERROR.GE.1.AND.IERROR.LE.9) GO TO 307
        GO TO 310

307     TYPE 308,(ADDNAM(L),L=1,2),IERROR
308     FORMAT (1X,'FATAL ERROR ON RENAMING OR DELETING FILE: ',
     X2A5,'  (ERROR # ',I1,')'/)
        GO TO 700

310     TYPE 311,(DAYNAM(L),L=1,2)
311     FORMAT (/1X,'FILE: ',2A5,' APPENDED'/)

315     CONTINUE

*       ** IF RESTARTING AND PRFLG = 0 AND YOU'VE REACHED THIS POINT
*          THEN NEED TO RESTART AT VERY BEGINNING OF PHASE 4.

        IF(P4FLG.NE.0) GO TO 317
        COM='RUN'
        GO TO 303


317     TYPE 320
320     FORMAT (//5X,'PHASE 4 COMPLETED',/)



*       ********** PHASE 5: USING 1022 COMMANDS FILE: PAR.DMC ********
*                  CREATE FILE: PAR.DAT WHICH CONTAINS SUMMARY
*                  INFORMATION ON EACH NODE-PORT PAIR

50      TYPE 350
350     FORMAT (//5X,'BEGINNING PHASE 5'/)

        CALL DBOPEN('PAR.DMS')
        CALL DBFIND('ALL')
        CALL DBNREC(IREC)

        IARR(3)='PAR.D'
        IARR(4)='AT   '

        CALL DBEXEC(IARR)
        CALL DBEXEC('USE PAR.DMC')
        CALL DBEXEC('RELEASE')
        CALL DBCLOS

        TYPE 360,IREC
360     FORMAT(//5X,'PHASE 5 COMPLETED'/5X,'PROCESSED ',I6,' SESSIONS'/)


*       ********** PHASE 6: USING 1022 DATA BASE: PORTXX **********
*                  (WHERE XX IS 2-DIGIT MONTH NUM) CREATE
*                  FILE : PAR2.DAT BY APPENDING THE PORTCODE 
*                  OBTAINED FROM PORTXX TO EACH NODE-PORT RECORD 
*                  IN FILE: PAR.DAT

60      TYPE 385
385     FORMAT (//5X,'BEGINNING PHASE 6',/)

        CALL DBOPEN(FLEDMS)
        OPEN (21,'PAR.DAT',INPUT)
        OPEN (22,'PAR2.DAT',OUTPUT)

390     DO 395 II=1,6
        DO 395 JJ=1,2000
395     DATA(II,JJ)=0

*       ** PROCESS RECORDS FROM 'PAR.DAT' FILE 2000 AT A TIME

400     READ (21,410,END=420) ((DATA(I,J),I=1,5),J=1,2000)
410     FORMAT (I4,I3,I6,2I10)

*       ** PROCESS A RECORD
420     ICNT=0

*       ** IF RECORD IS BLANK THEN REACHED END-OF-FILE. SET END FLAG.
        DO 450 J=1,2000
        IF (DATA(1,J).EQ.0.AND.DATA(2,J).EQ.0.AND.DATA(3,J).EQ.0)
     X GO TO 418
        ICNT=ICNT+1
        GO TO 419

418     ENDFLG=1

*       ** IF NODE NUMBER HAS CHANGED STAY HERE
419     IF (NODE.EQ.DATA(1,J)) GO TO 424

*       ** SINCE NODE NUMBER HAS CHANGED THEN ALL PORTS WITH TRAFFIC HAVE
*          BEEN PROCESSED. HOWEVER, THERE MAY BE VALID PORTS ON THIS
*          NODE WHICH ARE NOT BEING USED. IF THE PORT COUNT (DCNT) IS LESS
*          THAN OR EQUAL TO THE MAX. NUMBER OF PORTS ON THE NODE THEN SET
*          PRTFLG AND GO LOOK FOR THESE VALID PORTS WITH NO TRAFFIC.

        IF (DCNT.GT.MAXPRT-1) GO TO 421
        PRTFLG=1
        GO TO 424

*       ** ALL VALID PORTS (WITH OR WITHOUT TRAFFIC) HAVE BEEN PROCESSED
*          FOR THIS NODE. IF NOT END-OF-FILE INITALIZE SOME VARIABLES.

421     IF (ENDFLG.EQ.1) GO TO 460
        NODE=DATA(1,J)
        DCNT=0
        PRTFLG=0
         NONOD=0

*       ** GET RECORD FROM PORTS LIST FILE FOR THIS NODE AND GET VALUE OF
*          MAXIMUM NUMBER OF PORTS ON THIS NODE.
        CALL DBFIND ('NODNUM','EQ',NODE)
        CALL DBGREC($422)
        CALL DBVAL(3,MAXPRT)
        GO TO 424

422     TYPE 423,NODE
423     FORMAT (/,5X,'ERROR: NO ENTRY IN DATA BASE FOR NODE: ',I4)
        NONOD=1

*       ** DCNT=NUMBER OF CURRENT PORT ON THISS NODE. CONVERT THIS
*          NUMBER TO OCTAL SINCE PORT NUMBERS ARE OCTAL IN THE PORTS LIST
424     CALL CONVRT(DCNT,OCNT)
*       ** STAY HERE IF THERE WAS NO TRAFFIC FOR THIS PORT IN  THE 'PAR.DAT'
*          FILE
        IF (PRTFLG.EQ.1) GO TO 425
        IF (OCNT.EQ.DATA(2,J)) GO TO 429

*       ** IF THERE IS NO ENTRY IN THE DATA BASE FOR THE CURRENT NODE
*          THEN THERE IS OBVIOUSLY NO ENTRIES FOR ANY PORTS ON THAT NODE
*          THEREFORE, DON'T LOOK FOR AND VALID PORTS WITH NO TRAFFIC.
425     IF (NONOD.EQ.1) GO TO 428

*       ** FIND THE RECORD IN THE PORTS LIST FOR THIS NODE AND PORT.
*          GET THE NODE CODE, PORTCODE, PHONE NUMBER AND MODUM TYPE
        CALL DBFIND ('NODNUM','EQ',NODE,'AND','PORTNUM','EQ',OCNT)
        CALL DBGREC($426)
        CALL DBVAL('NODECODE',NODCOD,'PORTCODE',PRTCOD,'PHONENO',PHONE,
     X'MODUM',MODUM)

*       ** IF PORT IS CODED 'BAD' OR 'UNUSED' THROW IT OUT.
        IF (PRTCOD.EQ.7.OR.PRTCOD.EQ.8) GO TO 428
        GO TO 427

*       ** ERROR!! NO ENTRY IN PORT LIST FOR THIS NODE-PORT PAIR
426     TYPE 435,NODE,OCNT
        PRTCOD=99

*       ** OUTPUT WHAT INFO WE HAVE ON THIS PORT
427     WRITE (22,445)NODE,OCNT,NULL,NULL,NULL,PRTCOD,NODCOD,
     X(PHONE(I),I=1,6),MODUM

*       ** INCREMENT THE PORT COUNTER AND IF HAVEN'T EXCEEDED THE MAX
*          PORT ON THIS NODE THEN GO PROCESS THIS NEW PORT.
428     DCNT=DCNT+1
        IF (DCNT.LE.MAXPRT-1) GO TO 424
        IF (PRTFLG.EQ.1) GO TO 421
        PRTFLG=0
        IF (ENDFLG.EQ.1) GO TO 460
        GO TO 450

*       ** IF YOU'VE GOTTEN TO HERE THEN THERE IS TRAFFIC ON THIS PORT
*          FIND THE RECORD IN THE PORTS LIST FOR THIS NODE-PORT PAIR
*          AND GET VALUES FOR NODECODE,PORTCODE, PHONE, AND MODUM.

429     CALL DBFIND ('NODNUM','EQ',DATA(1,J),'AND','PORTNUM','EQ'
     X,DATA(2,J))
        CALL DBGREC($430)
        CALL DBVAL('NODECODE',NODCOD,'PORTCODE',DATA(6,J),'PHONENO',
     XPHONE,'MODUM',MODUM)
        GO TO 440

*       ** ERROR!! NO ENTRY IN PORT LIST FOR THIS NODE
430     TYPE 435,(DATA(I,J),I=1,2)
435     FORMAT (/,5X,'ERROR: NO ENTRY IN DATA BASE FOR NODE-PORT PAIR
     X: ',I4,'-',I3/)
        DATA(6,J)=99

*       ** OUTPUT ALL INFO ON THIS NODE-PORT PAIR, INCREMENT PORT COUNTER,
*          AND GO PRCESS ANOTHER PORT.
440     WRITE (22,445)(DATA(I,J),I=1,6),NODCOD,(PHONE(I),I=1,6),MODUM
445     FORMAT (I4,I3,I6,2I10,2I2,7A5)

        DCNT=DCNT+1

450     CONTINUE

*       **  FINISHED PROCESSING 2000 RECORDS OR REACHED END-OF-FILE
*       **  OUTPUT NUMBER OF SESSIONS PROCESSED AND IF NOT AT END-OF-FILE
*          GO ANDPROCESS ANOTHER 2000 SESSIONS.

460     TOTCNT=TOTCNT+ICNT
        TYPE 470,TOTCNT
470     FORMAT (/1X,'PROCESSED ',I6,' SESSIONS'/)
        IF (ENDFLG.EQ.1) GO TO 500
        GO TO 390

*       ** FINISHED!!
500     TYPE 510,TOTCNT
510     FORMAT(//5X,'PHASE 6 COMPLETED'/5X,'PROCESSED ',I6,' SESSIONS'/)

        CLOSE (21)
        CLOSE (22)
        CALL DBCLOS


*       ********** PHASE 7: CREATE THE FINAL REPORT. OUTPUT **********
*                  REPORT TO FILE NAME WITH FORMAT: PARXX.R##
*                  WHERE XX IS A 2-DIGIT MONTH NUMBER AND ## IS
*                  A TWO DIGIT RUN NUMBER

70      TYPE 540
540     FORMAT (//5X,'BEGINNING PHASE 7'/)

*       ** USING RUN NUMBER BUILD THE CORRECT REPORT NAME

        IF (IRUNUM.EQ.2) GO TO 555
        ENCODE (9,550,REPNAM)(SCR(I),I=3,4)
550     FORMAT (3HPAR,2I1,4H.R01)
        GO TO 557

555     ENCODE (9,556,REPNAM)(SCR(I),I=3,4)
556     FORMAT (3HPAR,2I1,4H.R02)


557     IARR(3)=REPNAM(1)
        IARR(4)=REPNAM(2)

        IF (IRUNUM.EQ.2) GO TO 558
        CALL DBEXEC('LOAD PARR1.DMD')
        CALL DBOPEN('PARR1')
        GO TO 559

558     CALL DBEXEC ('LOAD PARR2.DMD')
        CALL DBOPEN('PARR2')

559     CALL DBFIND('ALL')
        CALL DBEXEC(IARR)
        CALL DBEXEC('USE PAR2.DMC')
        CALL DBEXEC('RELEASE')
        CALL DBCLOS

        TYPE 560,(REPNAM(I),I=1,2)
560     FORMAT (//5X,'PHASE 7 COMPLETE'/5X,'FILE: ',2A5
     X,' NOW CONTAINS THE PORT REPORT'//)

*       ** NOW DELETE THE 'PARD#.DAT' FILES.

600     DO 630 I=1,5
        
*       ** BUILD THE FILE NAME TO DELETE
        ENCODE (9,610,DELNAM)I
610     FORMAT (4HPARD,I1,4H.DAT)

*       ** DELETE FILE
        CALL DELET(DELNAM,IERROR)

*       ** IF DELETE WAS SUCCESSFUL STAY HERE
        IF (IERROR.GE.1.AND.IERROR.LE.9) GO TO 620
        TYPE 615,(DELNAM(J),J=1,2)
615     FORMAT (1X,'FILE: ',2A5,' DELETED')
        GO TO 630

*       ** DELETE WAS UNSUCCESSFUL
620     TYPE 625,(DELNAM(J),J=1,2),IERROR
625     FORMAT (1X,'UNABLE TO DELETE FILE: ',2A5,5X,'(ERRORI2,')')

630     CONTINUE

700     CALL DBEND
        END

*       ***************SUBROUTINE CONVERT************************


*       THIS ROUTINE CONVERTS A DECIMAL NUMBER (4-DIGITS OR LESS)
*       INTO AN OCTAL NUMBER

        SUBROUTINE CONVRT(DEC,OCT)

        INTEGER DEC,OCT

        IA=DEC
        IB=IA/8
        IB2=MOD(IA,8)
        IC=IB/8
        IC2=MOD(IB,8)
        ID=IC/8
        ID2=MOD(IC,8)
        OCT=ID*1000+ID2*100+IC2*10+IB2
        RETURN
        END

  AXz