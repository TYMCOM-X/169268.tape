CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                    C
C                       SUBROUTINE: XRCIR                            C
C                                                                    C
C       THIS SUBROUTINE BUILDS AN AUXILIARY CIRCUIT TO XRAY.         C
C       PORT NUMBER IS PLACED INTO COMMON BLOCK: AUX.                C
C                                                                    C
C       FORMAT: CALL XRCIR(KERNAL,IERR)                              C
C       ARGUMENTS:                                                   C
C          KERNAL : VARIABLE CONATINING THE KERNAL NUMBER TO         C
C                   LOGIN TO.                                        C
C          IERR   : ERROR FLAG. SET TO 0 = NO ERROR. CIRCUIT BUILT.  C
C                   SET TO 1 = UNABLE TO BUILD CIRCUIT.              C
C                   SET TO 2 = BAD RESPONSE FROM XRAY DURING LOGIN   C
C                                                                    C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        SUBROUTINE XRCIR(KERNAL,IERR)

        IMPLICIT INTEGER(A-Z)

        DIMENSION XRAY(3),NOECHO(4)
        IERR=0


C PLACE THE PORT NUMBER INTO COMMON
        COMMON /AUX/PORT

C SET XRAY PROMPT CHARACTER TO GREATER THAN SIGN
        DATA PROMPT/62/

C SET UP COMMAND TO TURN OFF ECHO. COMMAND = LE
        DATA NOECHO/3,76,69,13/

C BUILD THE XRAY LOGIN STRING USING THE KERNAL
100     ENCODE (15,110,XRAY)KERNAL
110     FORMAT ('XRAY:',I5,';    ')

C BUILD THE AUXILIARY CIRCUIT TO XRAY
120     CALL FBCIR(XRAY,PORT,IERR2)

C IF ERROR RETURN IS NON ZERO, UNABLE TO BUILD CIRCUIT
125     IF (IERR2.EQ.0) GO TO 130
        IERR=1
        GO TO 900

C XRAY SHOULD GIVE THE NODE AND KERNAL NUMBER THE DATE AND THEN
C THE PROMPT.  LOOK FOR THE PROMPT.
130     CALL SCAN(PROMPT,RESLT1)
        IF (RESLT1.EQ.1) GO TO 140

C ERROR. BAD RESPONSE FROM XRAY
135     IERR=2
        GO TO 900


C TURN OFF ECHO
140     CALL SEND(NOECHO)

C LOOK FOR PROMPT
145     CALL SCAN(PROMPT,RESLT2)
        IF (RESLT2.EQ.1) GO TO 165

C ERROR. BAD RESPONSE FROM XRAY
150     IERR=2
        GO TO 900

C LOGIN COMPLETED
165     IERR=0

C RETURN
900     RETURN
        END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                    C
C                       SUBROUTINE: XRFOUT                           C
C                                                                    C
C       THIS SUBROUTINE WRITES THE OUTPUT FROM AN AUXILIARY CIRCUIT  C
C       ONTO A SPECIFIED FILE.                                       C
C                                                                    C
C       FORMAT: CALL XRFOUT(PROMPT,FILNUM,FPTR)                      C
C       ARGUMENTS:                                                   C
C          PROMPT : VARIABLE CONTAINING THE PROMPT CHARACTER WHICH   C
C                   SIGNALS END OF OUTPUT AND READINESS FOR NEXT     C
C                   COMMAND..                                        C
C          FILNUM : THE VARIABLE CONTAINING THE DISC DEVICE NUMBER   C
C                   TO WHICH THE OUTPUT IS TO BE WRITTEN.            C
C          FPTR  : VARIABLE IN WHICH THE NUMBER OF LINES WRITTEN TO  C
C                  THE FILE WILL BE RETURNED.                        C
C                                                                    C
C       ACCESSES:  COMMON/AUX/PORT                                   C
C                                                                    C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        SUBROUTINE XRFOUT(PROMPT,FILNUM,FPTR)

        IMPLICIT INTEGER(A-Z)

        DIMENSION LARRAY(80)

C GET THE AUXILIARY CIRCUIT PORT NUMBER
        COMMON/AUX/PORT

C INIT FILE POINTER
        FPTR=1

C GET A LINE OF OUTPUT
100     CALL XRGLIN(PROMPT,LARRAY,NUMCHR,IERR)

C CK IF ANY ERRORS
110     IF (IERR.EQ.0) GO TO 140

C CK IF END OF OUTPUT
115     IF (IERR.EQ.1) GO TO 175

C LINE EXCEEDS 80 CHARACTERS. PRINT WARNING
120     TYPE 121,FPTR
121     FORMAT (1X,'WARNING! LINE: ',I4,' TRUNCATED AT 80 CHARACTERS.'
     +  ,/)

C MAKE SURE OUTPUT AT LEAST ONE CHARACTER
140     IF (NUMCHR.EQ.0) NUMCHR=1

C APPEND TO OUTPUT FILE. GET SIZE OF FILE AND INCREMENT BY
C ONE TO GET CORRECT POSITION TO WRITE TO.
145     IPOS=SIZE(FILNUM)+1

C WRITE OUTPUT TO FILE
150     WRITE(FILNUM#IPOS,155)(LARRAY(I),I=1,NUMCHR)
155     FORMAT(80A1)

C INCREMENT FILE POINTER
160     FPTR=FPTR+1

C GO GET NEXT LINE
        GO TO 100

C END OF OUTPUT- RETURN
175     RETURN
        END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                    C
C                       SUBROUTINE: XRGLIN                           C
C                                                                    C
C       THIS SUBROUTINE GETS A LINE OF OUTPUT FROM AN AUXILIARY      C
C       CIRCUIT.  MAX LENGTH OF LINE = 80 CHARACTERS.                C
C                                                                    C
C       FORMAT: CALL XRGLIN(PROMPT,ARRAY,NUMCHR,IERR)                C
C       ARGUMENTS:                                                   C
C          PROMPT : VARIABLE CONTAINING THE PROMPT CHARACTER WHICH   C
C                   SIGNALS END OF OUTPUT AND READINESS FOR NEXT     C
C                   COMMAND.                                         C
C          ARRAY  : ARRAY IN WHICH THE OUTPUT LINE WILL BE RETURNED  C
C          NUMCHR : VARIABLE IN WHICH THE NUMBER OF CHARACTERS IN    C
C                   THE OUTPUT LINE IS RETURNED.                     C
C          IERR   : VARIABLE CONTAINING ERROR FLAG. IF SET TO 0 =    C
C                   NO ERROR. IF SET TO 1 = OVER 80 CHARACTERS IN    C
C                   OUTPUT LINE.                                     C
C                                                                    C
C       ACCESSES:   COMMON/AUX/PORT                                  C
C                                                                    C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        SUBROUTINE XRGLIN(PROMPT,ARRAY,NUMCHR,IERR)

        IMPLICIT INTEGER (A-Z)

        DIMENSION ARRAY(80)

        IERR=0

C GET THE AUXILIARY CIRCUIT PORT NUMBER
        COMMON /AUX/PORT

        DATA CR/13/,LF/10/

C INITIALIZE CHARACTER COUNTER
        NUMCHR=1

C INIT ARRAY
        DO 90 I=1,80
        ARRAY(I)=' '
90      CONTINUE


C WAIT FOR 1 SECOND BEFORE TRYING TO GET A CHARACTER
100     CALL WAIT(1.0)

C GET A CHARACTER
110     CALL GTCHAR(PORT,CHAR)

C IF NO CHAR, GO WAIT AND TRY AGAIN
115     IF (CHAR.LT.0) GO TO 100

C LOOK AT ONLY LAST 7 BITS. MASK ="177
120     CHAR=IAND(CHAR,127)

C CK IF WE'RE BACK TO THE PROMPT. (MEANS END OF OUTPUT)
130     IF (CHAR.NE.PROMPT) GO TO 140

C SET ERROR FLAG TO INDICATE END OF OUTPUT AND RETURN.
135     IERR=1
        GO TO 900

C AT END OF EACH LINE OF OUTPUT WE GET A CR,LF SEQUENCE.  IF THIS
C CHAR IS A LF WE'RE FINISHED.
140     IF (CHAR.NE.LF) GO TO 150

C DECREMENT NUMBER OF CHARACTERS BY 1 AND RETURN
145     NUMCHR=NUMCHR-1
        GO TO 900

C IF THIS CHARACTER IS A CARRIAGE RETURN, IGNORE IT AND LOOK AT NEXT 
C CHARACTER.
150     IF (CHAR.EQ.CR) GO TO 110

C LEFT SHIFT THIS CHAR 29 BITS
155     CHAR=LSH(CHAR,29)

C ADD 4 SPACES TO FILL IN WORD.  THIS MAKES COMPARISONS WITH OTHER
C CHARACTERS EASIER.
157     CHAR=IOR(CHAR,"1004020100)

C PUT CHAR INTO LINE ARRAY
160     ARRAY(NUMCHR)=CHAR

C INCREMENT CHARACTER COUNTER
165     NUMCHR=NUMCHR+1

C CK IF EXCEEDING SIZE OF ARRAY
        IF (NUMCHR.GT.80) GO TO 175

C GO GET NEXT CHAR
        GO TO 110

C ERROR. TOO MANY CHARACTERS IN LINE. EXCEEDING SIZE OF ARRAY
175     IERR=2

C FINISHD. RETURN
900     RETURN
        END

 