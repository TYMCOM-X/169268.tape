                                                               December 4, 1985







                      ***** *   * *   * *   * ***** *****
                        *    * *  ** ** **  * *       *  
                        *     *   * * * * * * ****    *  
                        *     *   *   * *  ** *       *  
                        *     *   *   * *   * *****   *  


                      ***** *   *  ***  ***** *   * *****
                      *     **  * *   *   *   **  * *    
                      ****  * * * *       *   * * * **** 
                      *     *  ** *  **   *   *  ** *    
                      ***** *   *  **** ***** *   * *****

                               REFERENCE MANUAL

         NOTICE:  INSTRUCTION TIMINGS WITH 2 DIGITS BEYOND THE DECIMAL
            POINT ARE ESTIMATES...THOSE WITH 3 DIGITS ARE MEASURED!


                                    TYMNET
                        NETWORK TECHNOLOGY DEVELOPMENT
                               December 4, 1985













     ====================================================================
     |   Tymnet,  Inc.'s  proprietary  rights  are  included  in  the   |
     |   information disclosed herein.   The recipient,  by receiving   |
     |   this document,  agrees  that neither this  document nor  the   |
     |   information  disclosed  herein nor any part thereof shall be   |
     |   reproduced or transferred to  other  documents  or  used  or   |
     |   disclosed  to  others  for  manufacturing  or  for any other   |
     |   purpose except  as  specifically authorized  in  writing  by   |
     |   Tymnet, Inc.                                                   |
     ====================================================================




                                     TYMNET Engine                   ENGINE.DOC
                                                               December 4, 1985







                                   TABLE OF CONTENTS

        Section                                                            Page



        1.   ENGINE--7/32 INCOMPATABILITIES                                   1


        2.   ENGINE DESCRIPTION                                               3
          2.1   INSTRUCTION FORMATS                                           3
             2.1.1    REGISTER TO REGISTER FORMAT (RR)                        4
             2.1.2    SHORT FORMAT (SF)                                       5
             2.1.3    REGISTER AND IMMEDIATE STORAGE (RI1, RI2)               6
             2.1.4    REGISTER AND INDEXED STORAGE (RX1,RX2,RX3)              6

          2.2   CONDITION CODE                                               10
             2.2.1    GREATER THAN, LESS THAN FLAGS                          10
             2.2.2    CARRY FLAG                                             11
             2.2.3    OVERFLOW                                               11

          2.3   PROGRAM STATUS WORD                                          11
             2.3.1    BIT 0 - WAIT BIT                                       12
             2.3.2    BIT 1 - IMMEDIATE INTERRUPT                            12
             2.3.3    BIT 2 - MACHINE MALFUNCTION                            13
             2.3.4    BIT 3 - TRACE ENABLE                                   13
             2.3.5    BIT 4 - ASYNC MICRO-INSTRUCTION ENABLE                 14
             2.3.6    BIT 5 - RELOCATION/PROTECTION ENABLE                   14
             2.3.7    BIT 6 - SYNC MICRO-CODED INTERRUPT ENABLE              15
             2.3.8    BIT 7 - PRIVILEGED MODE                                16
             2.3.9    BITS 8:11 - REGISTER SET SELECT                        16
             2.3.10   BITs 12:15 - CONDITION CODE                            17

          2.4   INTERRUPT HANDLING                                           17
             2.4.1    MACHINE MALFUNCTION                                    18
             2.4.2    ILLEGAL INSTRUCTION                                    18
             2.4.3    RELOCATION/PROTECTION (MAC)                            19
             2.4.4    SUPERVISORY CALL (SVC)                                 19
             2.4.5    I/O INTERRUPTS                                         20
             2.4.6    ENHANCED ASYNC TIMER INTERRUPTS                        20


        3.   The MAC -- Memory Access Controller                             22
          3.1   Absolute Address Space                                       22
          3.2   Virtual Address Space                                        22
          3.3   MAC Mapping                                                  23
          3.4   MAC LOCATIONS                                                24


                                     TYMNET Engine                   ENGINE.DOC
                                                               December 4, 1985


        4.   LOGICAL INSTRUCTIONS                                            25
          4.1   LOAD                                                         25
          4.2   LOAD Address                                                 26
          4.3   LOAD Halfword Logical                                        26
          4.4   LOAD Multiple                                                27
          4.5   LOAD Byte                                                    27
          4.6   EXCHANGE Halfword                                            28
          4.7   EXCHANGE Byte                                                28
          4.8   STORE                                                        29
          4.9   STORE Multiple                                               30
          4.10  STORE Byte                                                   30
          4.11  COPY                                                         31
          4.12  AND                                                          32
          4.13  OR                                                           32
          4.14  EXCLUSIVE OR                                                 33
          4.15  ARRAY-AND                                                    34
          4.16  TEST IMMEDIATE                                               35
          4.17  SHIFT Left Logical                                           35
          4.18  SHIFT Right Logical                                          36
          4.19  SHIFT Left Halfword Logical                                  36
          4.20  SHIFT Right Halfword Logical                                 37
          4.21  ROTATE Left Logical                                          38
          4.22  ROTATE Right Logical                                         38
          4.23  TEST and Set                                                 39
          4.24  TEST Bit                                                     40
          4.25  SET Bit                                                      40
          4.26  RESET Bit                                                    41
          4.27  COMPLEMENT Bit                                               41


        5.   JUMP INSTRUCTIONS                                               42
          5.1   JUMP on CONDITION                                            42
          5.2   JUMP and LINK                                                44
          5.3   JUMP on Find First One                                       45


        6.   ARITHMETIC INSTRUCTIONS                                         46
          6.1   ADD                                                          46
          6.2   ADD to Memory                                                47
          6.3   SUBTRACT                                                     48
          6.4   COMPARE Logical                                              49
          6.5   COMPARE Logical Byte                                         50
          6.6   COMPARE Algebraic                                            50
          6.7   MULTIPLY                                                     51
          6.8   MULTIPLY Halfword                                            52
          6.9   DIVIDE                                                       52
          6.10  DIVIDE Halfword                                              53
          6.11  SHIFT Right Arithmetic                                       53
          6.12  LOAD Halfword Register                                       54


        7.   STATUS SWITCHING INSTRUCTIONS                                   55
          7.1   LOAD Program Status Word                                     55

                                     TYMNET Engine                   ENGINE.DOC
                                                               December 4, 1985


          7.2   EXCHANGE Program Status Register                             56
          7.3   SUPERVISOR Call                                              56


        8.   I/O INSTRUCTIONS                                                57
          8.1   Console IO                                                   58
          8.2   Sense Status                                                 58
          8.3   Output Command                                               59
          8.4   Read Data                                                    59
          8.5   Write Data                                                   60


        9.   SPECIAL INSTRUCTIONS                                            61
          9.1   Async Microcode                                              61
             9.1.1    SBOD                                                   61
             9.1.2    XMIT                                                   62
             9.1.3    SPM                                                    62
             9.1.4    GCHAR                                                  62
          9.2   SYNC Microcode                                               62
             9.2.1    SCAN                                                   63
             9.2.2    ALIGN                                                  63
             9.2.3    CKSUM                                                  64
          9.3   Bufferlet Microcode                                          64
             9.3.1    GCI                                                    65
             9.3.2    WCI                                                    65
             9.3.3    CBCT                                                   66
             9.3.4    RTD1 and RTD2                                          66
             9.3.5    RMA1 and RMA2                                          67
             9.3.6    Buffer and Bufferlet Structure                         68


        10.  MICROPROGRAMMING THE ENGINE                                     69
          10.1  THE MICRO-ASSEMBLER                                          69
          10.2  The Microprogrammer's Guide to the Tymnet Engine             71
             10.2.1   Introduction                                           71
             10.2.2   The ALU                                                71
             10.2.3   Main Memory                                            72
                10.2.3.1    MDRs (Memory Data Registers)                     72
                10.2.3.2    IR (Instruction Register)                        72
                10.2.3.3    MC (Memory Address Register)                     72
                10.2.3.4    MAC control register                             72

             10.2.4   PC (Program Counter)                                   73
             10.2.5   Register Stack                                         73
             10.2.6   Working Register/Ext. Working Register                 74
             10.2.7   4-1 Multiplexer                                        74
             10.2.8   8-1 Multiplexer                                        74
             10.2.9   B-bus                                                  74
             10.2.10  Source                                                 75
             10.2.11  Destination                                            75
             10.2.12  Mapping Facility                                       75
                10.2.12.1   Opcode Decode [MAP]                              75
                10.2.12.2   Instruction Format Decode [RXADD]                76

                                     TYMNET Engine                   ENGINE.DOC
                                                               December 4, 1985


          10.3  Microcode Description for TYMNET-II ENGINE                   76
             10.3.1   CONST field                                            76
             10.3.2   BRANCH COND field                                      77
             10.3.3   ALU CONT field                                         77
                10.3.3.1    Opcode decode                                    78
                10.3.3.2    Address decode                                   78

             10.3.4   XWR XR CONT field                                      78
             10.3.5   B SOURCE field                                         79
             10.3.6   B DEST field                                           79
             10.3.7   MISC field                                             80
             10.3.8   ALU MUX CONT field                                     81
             10.3.9   PC MC field                                            82


                                     APPENDICES
                                     ==========


        I.   Buffers and Bufferlets                                          84
          I-1   Buffer Descriptors                                           84
          I-2   FLAGS Bit-array                                              85
          I-3   Bufferlets                                                   85
             I-3.1    Bufferlet Free-list                                    86


        II.  ASYNC Implementation                                            87
          II-1  Data Structures                                              87
             II-1.1   ASYNC Ring                                             87
                II-1.1.1    The ASYNC Frame                                  87

          II-2  Control Storage                                              90
          II-3  Timeout Storage                                              91
          II-4  Initialization                                               91
             II-4.1   Initialization for register set 1                      92
             II-4.2   Initialization for register set 2                      93
             II-4.3   Initialization for register set 3                      93
             II-4.4   Initialization for register set 4                      94
             II-4.5   Initialization for register set 0D                     94

          II-5  Definition of Terms                                          95
          II-6  Determination of ring size                                   96


        III. CONSOLE DISPLAYS for MICROCODE HALTS                            98


        IV.  DEVICE ADDRESSES FOR MULTIPLEXOR BUSS                           99


        V.   ENGINE MNEMONIC-OPCODE MAP                                     100



                                     TYMNET Engine                   ENGINE.DOC
                                                               December 4, 1985


        VI.  ENGINE FORMAT-OPCODE MAP                                       101


        VII. INSTRUCTION SUMMARY...ALPHABETICAL                             102


        VIII.   INSTRUCTION SUMMARY...NUMERIC                               107


                                      INDEX
                                      =====                                 111











































                                     TYMNET Engine                   ENGINE.DOC
        ENGINE--7/32 INCOMPATABILITIES                         December 4, 1985






                          1 -  ENGINE--7/32 INCOMPATABILITIES


             The following  incompatabilities between the  ENGINE and  the 7/32
        should be considered by anyone working on code which must be capable of
        operation on both the ENGINE, and  on the 7/32, or by anyone  using one
        manual for the alternate machine!

             1.   In  addition  to   the  floating  point  and   list  handling
        instructions, the following have been deleted:

                CRC12   CRC16   WBR     RBR     JXH
                JXLE    SRHA    SLHA    AL      WB
                RB      WH      RH      RD      SS
                SINT    SCP     TLATE   SLA     WHR
                RHR

             Notes:

             JXH R1,ALPHA can be replaced by:
                           AR R1,R1+1; CLR R1,R1+2; JG ALPHA

             JXLE R1,ALPHA can be replaced by:
                          AR R1,R1+1; CLR R1,R1+2; JLE ALPHA

             The use of JXH or JXLE is considered bad form.  There is usually a
        better way to do it.  The above substitutions are not optimal, but will
        avoid rewriting code.

             2.   The  overflow  flag  is set  to  0  following  all arithmetic
        instructions.  Only IO and PSW type intructions will turn it on.

             3.   The  console  is  no  longer  IO  device  1.   Use   the  CIO
        instruction.

             Example:  CIO i,j will output the low order 16 bits of  register i
        to the right of the console,  the low order 20 bits of register  i+1 to
        the rest of the  console, and then input the  low order 16 bits  of the
        switch register gister j.  CIO is not a privileged instruction.

             4.   The carry  flag is  reversed following  the  compare, compare
        logical,  and  subtract  instructions.   It  is  undefined   (often  1)
        following logical instructions.

             5.  LPSWR requires the location source to be specified as  well as
        the PSW source.  The NAD  assembler will normally take care of  this by
        assembling LPSWR 0 as LPSWR 1,0.



        1                            TYMNET Engine                   ENGINE.DOC
        ENGINE--7/32 INCOMPATABILITIES                         December 4, 1985


             6.   Multiply  and  divide  are  unsigned  operations.   The  long
        multiply will give a true 64 bit result.

             7.  LBR,  EXHR, STBR, LA,  and others will  now set  the condition
        code.

             8.  LA gives a full 32 bit result.

             9.  SVC allows the new PSW to specify which register set  will get
        the old PSW, address, and effective address in R13, R14, and R15.

             10.  Shift and  IO instructions now use  the RX format  instead of
        the I1 format.

             11.  The RX3 format no longer requires the first index field to be
        nonzero to use the second index field.

             12.  The  arithmetic interrupt,  system que  interrupt, autodriver
        channel, and PSW and register  save features (on power down)  have been
        deleted.

             13.  The PSW is only 16 bits long.  What used to be considered the
        first 16 bits are no longer referenced.

             14.  Register 3 is not set up with status on interrupt.  If status
        is desired, the user must issue a SSR.

             15.   The  bit  instructions address  halfwords,  not  bytes.  Bit
        arrays should begin on halfword boundaries.

             16.  The following instructions have been added:

                JFFO    JFFOH   UPSW





















        2                            TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985






                                2 -  ENGINE DESCRIPTION


             The  TYMNET ENGINE  is a  computer, developed  by TYMNET.   It was
        developed  to provide  a flexible  computer for  use in  the  growth of
        TYMNET.






                               2.1  INSTRUCTION FORMATS


             The TYMNET ENGINE uses  seven basic types of  instruction formats.
        The different  formats provide various  methods by which  the processor
        may access data to be used in an instruction.  Figure 1 illustrates the
        different  formats  and  should  be  refered  to  during  the following
        discussion.

                REGISTER TO REGISTER
                --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
        RR      |       OP      |   R1  |   R2  |
                ---------------------------------

                SHORT FORMAT
                --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
        SF      |       OP      |   R1  |   N   |
                ---------------------------------

                REGISTER AND INDEXED STORAGE 1
                --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
        RX1     |       OP      |   R1  |   X2  &
                ---------------------------------
                        --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
                        &0|0|            A2             |
                        ---------------------------------

                REGISTER AND INDEX STORAGE 2
                --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
        RX2     |       OP      |   R1  |   X2  &
                ---------------------------------
                        --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
                        &1|              D2             |
                        ---------------------------------




        3                            TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985



                REGISTER AND INDEXED STORAGE 3
                --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
        RX3     |       OP      |   R1  |   X2  &
                ---------------------------------
                        --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
                        &0|1|0|0|  X2'  |               &
                        ---------------------------------
                                --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
                                &               A2              |
                                ---------------------------------

                REGISTER AND HALFWORD IMMEDIATE
                --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
        RI1     |       OP      |   R1  |   X2  &
                ---------------------------------
                        --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
                        &               I2              |
                        ---------------------------------

                REGISTER AND FULLWORD IMMEDIATE
                --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
        RI2     |       OP      |   R1  |   X2  &
                ---------------------------------
                        --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
                        &            I2 (high)          &
                        ---------------------------------
                                --.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--
                                &            I2 (low)           |
                                ---------------------------------

                                FIGURE 1.





                    2.1.1  REGISTER TO REGISTER FORMAT (RR)

             In the register to register format, bits 0:7 specify the  op code,
        or the operation to be  performed.  Bits 8:11 contain the R1  field and
        bits 12:15  contain the  R2 field.   In most  cases, an  RR instruction
        performs the operation specified by  the op code with the  contents (32
        bits) of the general registers specified in the R1 and R2  fields.  The
        result is  placed in the  general register specified  in the  R1 field.
        Figure  2a illustrates  a  "load" instruction  in the  RR  format.  The
        assembler  notation appears  on  the right  side and  the  machine code
        appears on the left.  For the  machine code '0865', the '08' is  the op
        code for a load instruction,  RR format.  General register 6 is  in the
        R1 field and general register  5 is in the R2 field.   This instruction
        will take the contents of  general register 5 and load it  into general
        register 6.


        4                            TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985



                REGISTER TO REGISTER FORMAT (RR)

        example:

        0865            LR      R6,R5

                -----------------               -----------------
           R6   |   XXXX YYYY   |   <-----   R5 |   XXXX YYYY   |
                -----------------               -----------------

                                FIGURE 2a.





                    2.1.2  SHORT FORMAT (SF)

             In short  format instructions,  bits 0:7 specify  the op  code and
        bits 8:11 contain the R1 field.  Bits 12:15 contain a four bit quantity
        to be used as the second operand.  Figure 2b illustrates a short format
        instruction.   In  this example,  the  op code  '24'  specifies  a load
        instruction in  the SF  format.  '245E' directs  the processor  to load
        general register 5 with a hexidecimal quantity 'E'.  At  the completion
        of the instruction, register 5 will contain a 32 bit value '0000 000E'.

                SHORT FORM FORMAT (SF)

        example:

        245E            LIS     R5,14

                -----------------               -----------------
           R5   |   0000 000E   |   <--         | 2 | 4 | 5 | E |
                -----------------      \        -----------------
                                        \                     |
                                         ---------------------

                                FIGURE 2B.

             Both  the RR  and  SF format  instructions  are 16  bits  long and
        therefore require two memory byte locations.











        5                            TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


                    2.1.3  REGISTER AND IMMEDIATE STORAGE (RI1, RI2)

             Register and  immediate reference  (RI) type  instructions perform
        operations between a general register, an index register,  and either a
        16 or 32 bit  immediate value.  Bits 0:7  specify the op code  and bits
        8:11  specify a  general  register, R1.   Bits 12:15  specify  an index
        register (X2),  which can  be any general  register except  register 0.
        Bits 16:31 in RI1 format or  bits 16:47 in RI2 format contain  either a
        16 or  32 bit immediate  value (I2).  RI  instructions will  perform an
        operation between the contents  of a general register specified  in the
        R1 field (the first operand)  and the immediate value contained  in the
        I2 field plus the contents of the general register specified in  the X2
        field.   Figure 3  illustrates an  RI type  instruction.   The register
        specified  in the  X2 field  is added  to the  I2 field  to  obtain the
        effective  second operand.   For example,  the instruction  'C841 1234'
        will  load  register  4  with the  value  obtained  by  adding  the hex
        quantities '0000 1234'  and the contents of  general register 1.   If a
        '0' is specified in the X2 field, this indicates that no  indexing will
        take place.

                REGISTER AND IMMEDIATE STORAGE (RI1, RI2)

        example:

        C841 1234       LHI     R4,X'1234',R1

                ---------------------------------
                |  C8  | 4 | 1 |         1234   |
                ---------------------------------
                                        +
                                -----------------
                          R1    |   0000 EDCC   |
                                -----------------
                                        |
                                        V
                                -----------------
                          R4    |   0001 0000   |
                                -----------------

                                FIGURE 3.





                    2.1.4  REGISTER AND INDEXED STORAGE (RX1,RX2,RX3)

             RX  type  instructions  provide  a  means  of  operating  on  data
        contained in a general register  and data located at a  specific memory
        location.  Bits 0:7  specify the op code,  bits 8:11 specify  a general
        register, bits 12:15 specify  an index register, similar to  RI format.
        For an RX1 instruction,  bits 16 &17 must be "00".  Bits  18:31 specify


        6                            TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


        a 14  bit memory  address (A2).   The A2  field is  added to  the index
        register  (X2) to  obtain  an effective  memory address  of  the second
        operand.  From  this address  is obtained either  a byte,  halfword, or
        fullword,  depending on  the op  code.  This  quantity is  used  as the
        second operand.  In most cases, the result replaces the contents of the
        register specified  by R1.   An illustration of  an RX1  instruction is
        shown in figure 4.

                REGISTER AND INDEXED STORAGE (RX1)

        example:

        E641 1234       LA      R4,X'1234',R1

                ---------------------------------
                |  E6  | 4 | 1 |         1234   |
                ---------------------------------
                                        +
                                -----------------
                          R1    |   0000 3210   |
                                -----------------
                                        |
                                        V
                                -----------------
        (effective        R4    |   0000 4444   |
         address)               -----------------

                                FIGURE 4.

             RX3 instructions  are similar to  RX1 instructions except  that in
        RX3 format  there is  a provision  for using  a second  index register.
        Figure 5 illustrates the format for an RX3 type instruction.

             Bits 0:11  are the  same as  for an  RX1 instruction.   Bits 12:15
        specify the first (normal)  index register (X2).  Bits  16:19 determine
        the format and  must be '0100'  or a hex  '4'.  Bits 20:23  specify the
        second index  register (X2').   Bits 24:47 comprise  the 24  bit memory
        address  field  (A2).  Since  the  memory  system only  uses  a  20 bit
        address, the first digit of the A2 field should always be '0'.















        7                            TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985



                REGISTER AND INDEXED STORAGE (RX3)

        example:

        E641 4600 1234  LA      R4,X'1234',R1,R6

                ---------------.---------------.-----------------
                |  E6  | 4 | 1 | 4 | 6 |              00 1234   |
                -------------------------------------------------
                                                        +
                                                -----------------
                                          R1    |   0000 3210   |
                                                -----------------
                                                        +
                                                -----------------
                                          R6    |   0000 0F0F   |
                                                -----------------
                                                        |
                                                        V
                                                -----------------
        (effective address)               R4    |   0000 5353   |
                                                -----------------

                                FIGURE 5.

             The following is an example of an RX3 type instruction:

                   5851 4201 2344          L       5,X'12344'(1)(2)

             This instruction  is designed  to load general  register 5  with a
        fullword  (32  bits)  from  memory  address  '12344'  indexed  by index
        registers 1 and  2.  To calculate the  effective address of  the second
        operand, the memory  address in the A2  field (12344) must be  added to
        the contents of general register 1 and this result must be added to the
        contents of  general register 2.   The result of  this addition  is the
        location from which general register 5 is loaded.

             Although RX3 type  instructions provide for double  indexing, they
        are also used whenever the A2 field exceeds hex '3FFF'.  Since RX1 type
        instructions  only provide  for a  14 bit  address field,  any  RX type
        instruction with an A2 field  greater than '3FFF' (maximum value  in 14
        bits) must use RX3 format.

             RX2 format is also similar to RX1, but instead of an address field
        (A2),  RX2  utilizes  a   displacement  field  (D2).   RX2   format  is
        illustrated in figure 6.







        8                            TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985



                REGISTER AND INDEXED STORAGE (RX2)

        example:

        E641 9234       LA      R4,.+X'1234',R1

                ---------------------------------
                |  E6  | 4 | 1 |2|       1234   |
                ---------------------------------
                                        +
                                -----------------
                          R1    |   0000 3210   |
                                -----------------
                                        +
                                -----------------
                         (P)    |   0001 0800   |
                                -----------------
                                        |
                                        V
                                -----------------
        (effective        R4    |   0001 4C44   |
         address)               -----------------

                                FIGURE 6.

             Bits  0:15 of  RX2 format  are identical  to RX1.   RX2  format is
        signified by setting bit  16 equal to '1'.   Bits 17:31 make up  the 15
        bit displacement field.  The effective address of the second operand is
        calculated  by  adding  the  D2 field,  the  contents  of  the register
        specified by  X2, if  any, and  the incremented  value of  the location
        counter.  For example, if the instruction
                                       5850 8008

             was  located at  memory address  '100', the  processor  would load
        general register 5  with a fullword  from memory location  '10C'.  This
        location was found  by adding the D2  field, '0008' to  the incremented
        location counter, '104'.  The  location counter was incremented  by '4'
        since the  instruction is  4 bytes long.   The D2  field may  specify a
        positive displacement,  as in  the example, or  may specify  a negative
        displacement by using a negative number in the D2 field.

             RX1  and  RX2  instructions are  2  halfwords  long  and therefore
        require 4 memory byte locations.  RX3 instructions are 3 halfwords long
        and require 6 memory byte locations.









        9                            TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


                                  2.2  CONDITION CODE


             The condition code  is a register  embedded in the  program status
        word designed to give the programmer some information about the results
        of an instruction.  The  condition code consists of four  bits:  carry,
        overflow, greater than  zero, and less than  zero.  They are  the least
        significant four bits of the PSW.

                        PSW bit 12  13  14  15
                                 C   V   G   L

             Although the meaning of the condition code may vary  for different
        instructions, for the most part the bits have the following meaning.

               NOTE:   For those instructions where the  condition codes
                       are changed, ALL of the condition code  bits will
                       be affected.   Those marked with  an "X"  are not
                       left unchanged;  rather this indicates  that that
                       bit will be set to an arbitrary (but predictable,
                       within  a  specific   micro-code  implementation)
                       value.





                    2.2.1  GREATER THAN, LESS THAN FLAGS

             These two flags work in conjunction with each other, and  are used
        to indicate whether the result is greater than zero, less than zero, or
        equal to zero.

             To set the 'L'  flag, the processor examines the  most significant
        bit of  the result, known  as the sign  bit.  If this  bit is  set, the
        result  is a  negative number  and is  in two's  complement  form.  For
        example, the instruction:

                                    F820 FFFF FFEE

             will load register 2 with  a hex value X'FFFF FFEE'.  As  a result
        of this instruction, the 'L' flag will be set and the 'G' flag  will be
        reset since the  sign bit of the  result is set, indicating  a negative
        number in two's complement form.  The arithmetic value of the result is
        X'-12'.

             The 'G' flag will  set when the sign  bit of the result  is reset,
        and there is at least one  other bit in the register set,  indicating a
        non-zero result.  If neither the 'G'  flag or the 'L' flag is  set, the
        result is zero.  For  all arithmetic and logical instructions,  the 'G'
        and 'L' flags should never both be set at the same time.



        10                           TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


                    2.2.2  CARRY FLAG

             The carry flag sets whenever  the result of an operation  will not
        fit in a 32 bit register.  It is not necessarily an indication that the
        result  is incorrect.   It is  up to  the programmer  to  determine the
        meaning  of  the carry  flag,  depending on  the  instruction  that was
        executed.  As an example, the instructions:

                                2521            LCS     2,1
                                2531            LCS     3,1
                                0A23            AR      2,3

             will load register 2 and 3 each with a value X'FFFF FFFF' or a -1.
        When these two registers are added together, the result is X'FFFF FFFE'
        or  a -2  and  a carry  flag,  since there  was  a "carry"  out  of the
        register.  The complete  condition code would be  1001, or the  'C' and
        'L' (since the result is negative) flags set and the 'V' and  'G' flags
        reset.





                    2.2.3  OVERFLOW

             Unlike the INTERDATA 7/32, the overflow flag on the ENGINE  is not
        used   for   arithmetic   instructions.    Following   any   arithmetic
        instruction, this  flag is  set to zero.   It will,  however, set  as a
        result of an I/O or PSW type instruction.  For a PSW  type instruction,
        the 'V' flag is set or  reset depending on the new PSW that  is loaded.
        for I/O type instructions, the 'V' flag will set whenever a  false sync
        timeout on  the I/O  bus occurs.  A  false sync  timeout occurs  when a
        device is addressed on the I/O bus and it does not respond with "sync".

             Most  user  instructions  will  affect  the  condition  code.  The
        exceptions are multiply and divide,  ST, STH, STB, and CIO,  and "Jump"
        instructions.  For  a description  of condition  code settings  fo each
        instruction, consult the chapter appropriate to that instruction.






                               2.3  PROGRAM STATUS WORD


             The  program  status  word  (PSW) is  a  16  bit  register  on the
        ROM#&#I/O board  which describes the  state of the  machine at  a given
        time.  Different bits  in the PSW will  allow the machine to  handle or
        ignore certain occurances.   Figure 7 shows  the layout of  the program
        status register.


        11                           TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


                PROGRAM STATUS WORD

                --.-.-.-+-.-.-.-+-.-.-.-+-.-.-.--
                | | | | | |R| | | reg.  | | | | |
                |W|I|M|T|A|/|S|P|  set  |C|V|G|L|
                | | | | | |P| | |select | | | | |
                ---------------------------------

             PSW BIT

                 0      Wait bit
                 1      I/O Interrupt Enable
                 2      Machine Malfunction Interrupt Enable
                 3      Trace Bit
                 4      Async micro-instructions enable
                 5      Relocation/Protection Enable
                 6      Sync micro-coded interrupt enable
                 7      Privileged Mode
                8:11    Register Set Select (0 to F)
               12:15    Condition Code
                12      Carry Flag
                13      Overflow Flag
                14      Greater Than Zero Flag
                15      Less Than Zero Flag

                                FIGURE 7.





                    2.3.1  BIT 0 - WAIT BIT

             This bit,  when set,  will cause  the CPU  to halt  normal program
        exeution.  When the  CPU is executing  instruction, this bit  is reset.
        It will continue to execute instructions until a new PSW, with bit zero
        set, is loaded.





                    2.3.2  BIT 1 - IMMEDIATE INTERRUPT

             This bit in the PSW will cause the CPU to either handle  or ignore
        external interrupts from I/O devices.  If this bit is reset and  an I/O
        device attempts to  interrupt the processor,  the CPU will  ignore this
        interrupt and continue normal program execution.

             If this  bit is  set and an  I/O device  interrupts, the  CPU will
        acknowledge the  interrupt and obtain  the address of  the interrupting
        device.  The CPU will  then suspend normal program execution  and enter


        12                           TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


        an interrupt handling routine.  Interrupt handling will be discussed in
        more detail in the next section.

             Interrupts   are   divided   into   classes;    the   classes  are
        distinguished by the register-set in use:

        REG SET     INTS enabled:               Class (enhanced only)

          C-F       0, 1, 2                     2 -- All interrupts
          8-B       0, 1                        1 -- Enhanced Sync
          0-7       0                           0 -- Enhanced Async Timer





                    2.3.3  BIT 2 - MACHINE MALFUNCTION

             This bit, when set, will allow the CPU to recognize and respond to
        machine  malfunction  interrupts.  Machine  malfunction  interrupts can
        occur from either a power  restore or a memory parity error.   The type
        of  machine malfunction  that occurs  (either power  restore  or parity
        error) can be determined by  examining the condition code.  If  the 'G'
        flag is set in the condition  code (CC = 2), a memory parity  error has
        occurred.  When power is restored to the system, the condition  code is
        set to zero.

             If a machine malfunction interrupt  occurs, and PSW bit 2  is set,
        the processor will suspend normal program execution and enter a machine
        malfunction interrupt routine.   If PSW bit  2 is reset,  the processor
        will ignore the interrupt  and continue with normal  program execution.
        This  interrupt will  be discussed  in more  detail in  the  section on
        interrupt handling.





                    2.3.4  BIT 3 - TRACE ENABLE

             The trace bit is a  debugging tool for use by the  programmer.  It
        can be enabled by a 'UPSW'  (op code = D5) instruction, which is  not a
        privileged  instruction.  When  enabled,  it allows  the  programmer to
        enter a special subroutine after every (successful)  'Jump' instruction
        is executed.

             When the trace feature  is enabled and the processor  encounters a
        Jump instruction, while executing  the Jump a number of  things happen.
        The Jump  address is stored  in user memory  address X'14',  subject to
        relocation by the memory access controller.  The program status word at
        the time of the Jump is stored in user memory address X'10'.  The trace
        bit is turned off and a fullword pointer from user memory address X'18'


        13                           TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


        is loaded to the program counter.  This address is the beginning of the
        special subroutine.   The programmer may  use this subroutine  to check
        program conditions at the time of the Jump, store program addresses, or
        anything  else  which  may  be pertinent  to  proper  operation  of the
        program.  At the end of the subroutine, the programmer should execute a
        'UPSW'  instruction from user memory location X'10' to restore  the old
        PSW  and  Jump address,  reset  the  trace bit  and  continue  with the
        original program.  The next time a Jump instruction is encountered, the
        same procedure will repeat.

             In short, when trace is enabled, any successful Jump causes a trap
        to occur, under which tracing is disabled, and the PSD corresponding to
        the effective address  of the Jump (i.e.,  the addressed jumped  TO) is
        saved in memory for subsequent processing.

             The trace bit is a very useful tool in program debugging,  and its
        proper use by the programmer will allow for fast and easy program error
        detection and correction.





                    2.3.5  BIT 4 - ASYNC MICRO-INSTRUCTION ENABLE

             When this bit is  set, the special async  micro-coded instructions
        (SBOD,  XMIT,  SPM, and  GCHAR)  are enabled.   This  bit  is therefore
        effectively a "super-privileged" mode-enable bit.





                    2.3.6  BIT 5 - RELOCATION/PROTECTION ENABLE

             When this bit is set, all memory accesses (instruction fetch, data
        read, data write) are subject to the relocation and protection features
        of the  memory access  controller (MAC).   when this  bit is  reset, no
        relocation or protection is  provided, and the memory  address provided
        by the processor  or a dma device  will be the physical  memory address
        which is accessed.

             Bit  5, when  set,  will also  enable interrupts  from  the memory
        access  controller.   A  MAC interrupt  can  occur  from  write protect
        violations, execute protect violations, non-present addresses, or limit
        violations.  Operation of the MAC and MAC interrupts will  be discussed
        in the memory access controller section.







        14                           TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


                    2.3.7  BIT 6 - SYNC MICRO-CODED INTERRUPT ENABLE

             The Sync interrupts have  been micro-coded.  However, there  are a
        large  number of  codes  (such as  diagnostics, loaders)  which  do not
        recognize the existance of this micro-code;  it is desirable  to enable
        these interrupts only upon demand.  This bit is used for  this purpose.
        If the I/O Interrupts  are enabled, micro-coded interrupts  are enabled
        if  this  bit  is  set;   otherwise  interrupts  work  in   the  normal
        (conventional) fashion.

             The Sync card interrupts with device address 20-3F (20-5F if there
        exists an extra SYNC card);  2 addresses are used for each  line (input
        and output  interrupt independently).  There  may be provision  for 16d
        lines 32d if extra  card).  If microcoded SYNC interrupts  are enabled,
        then the microcode  references a "microcoded line  descriptor", located
        at location:

                                  LINE_NO*10d + 400x

             and of length 10d bytes.  It is of form:

                --------.-------.-------.--------
        MLDn    |         Input Pointer         |
                |-------.-------.-------.--------
                | Output index  |
                |-------.-------.-------.--------
                |       Output End Pointer      |
                ---------------------------------

             where:

           MLDn -- Microcoded Line Descriptor for line "n".
           Input Pointer -- a pointer to an input block of form:

                --------.--------
                |  index (RLP)  |
                |-------.-------|
                |     Input     |
                |     Ring      |
                |     Buffer    |
                |  (100x bytes  |
                |     long)     |
                -----------------

           Where index:
                On  input  interrupt,  the  data is  read  into  register  3 of
                   register set 0!
                Positive -- index into Input Ring Buffer, following.
                Negative -- conventional interrupt, PSW of 6200x.

           Output Index -- specifies one of 3 conditions:
                0 ---- conventional interrupt;


        15                           TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


                >0  ---- line  is marking...send  this many  more  HALFWORDS of
                   marks (all ones) to driver;
                <0 ----  line is  transmitting...this is  then a  negative byte
                   index, relative to:
           Output  End Address  -- The  address of  the first  byte  BEYOND the
               transmit area.





                    2.3.8  BIT 7 - PRIVILEGED MODE

             Certain  I/O   and  status   switching  instructions   are  called
        privileged instructions  and can  only be  executed by  the controlling
        program of  the system.  This  is to insure  that no user  program will
        inadvertently alter  the status  of the  machine.  The  control program
        usually executes with PSW bit 7 reset, allowing execution of privileged
        instructions, since it  is up to the  control program to  "control" the
        status of the machine and  its I/O devices.  When control is  passed to
        an  alternate  program  (user  program),  the  PSW  is  changed  by the
        controlling program,  setting bit  7.  This  inhibits the  user program
        from executing privileged instructions and possibly changing the status
        of  the  machine.   If  an attempt  is  made  to  execute  a priveleged
        instruction  when  PSW  bit  7 is  set,  it  is  considered  an illegal
        instruction and an illegal instruction interrupt is taken.

             The following is a list of privileged instructions:

              mnemonic            op code

                EPSR                    95
                LPSW                    C2
                LPSWR                   18
                WDR                     9A
                WD                      DA
                RDR                     9B
                SSR                     9D
                OC                      DE
                OCR                     9E





                    2.3.9  BITS 8:11 - REGISTER SET SELECT

             The TYMNET ENGINE employs 16 register sets, each set containing 16
        general registers of  32 bits each.  This  provides for a total  of 256
        fullword registers.  PSW bits 8:11 will select a register set (0:F) and
        allow access to the 16 general registers of that set.



        16                           TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


             Bits 8  & 9,  in conjunction with  bit 1,  also allow  or disallow
        different interrupt levels.  Interrupt levels and the meanings  of bits
        8 & 9 with regard to interrupts will be discussed in more detail in the
        section on interrupt handling.





                    2.3.10  BITs 12:15 - CONDITION CODE

             Bits 12:15 make up the condition code register.  This register was
        discussed in the previous section.  This portion of the PSW  is changed
        at the completion of most  user instructions to reflect the  results of
        the instruction.






                                2.4  INTERRUPT HANDLING


             An  interrupt  is  a  method used  by  the  system  to  notify the
        processor  that  something  has  happened  in  the  system  which needs
        processor  attention.   An  interrupt  is  not  necessarily   an  error
        condition, although many times it  is used to flag errors.  It  is also
        used, however,  to indicate  that an  I/O device  needs service  by the
        processor.

             The  TYMNET ENGINE  utilizes five  different types  of interrupts:
        machine malfunction, illegal instruction,  relocation/protection (MAC),
        supervisor call (SVC), and  I/O interrupts.  All involve a  "PSW swap".
        A PSW swap is a means which the system uses to store the program status
        word and  the program  counter either in  a register  or in  a specific
        memory location,  known as  dedicated memory,  and load  a new  PSW and
        program  counter from  a predetermined  location, again  either  from a
        register or a memory location.   What this procedure has the  effect of
        doing is to  cause the processor  to bring in a  new PSW to  handle the
        interrupt, and jump to  an appropriate interrupt handling  routine.  At
        the end of this routine,  the programmer will usually swap the  PSW and
        program counter again to return to the normal program flow.

             Each of the interrupts has a dedicated memory  location associated
        with  it.   These  locations  will  be  used  for  different functions,
        depending on the type of  interrupt.  A dedicated memory chart  for the
        ENGINE is shown in figure 8.  It should be noted that since the control
        program  handles all  interrupts, these  memory locations  are absolute
        addresses  not  subject to  MAC  relocation since  the  control program
        executes with the MAC turned off (PSW bit 5 reset).



        17                           TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985



                DEDICATED MEMORY ALLOCATION

         Hexadecimal
        Memory Address  Assignment

            20 - 27     Old PSW, Machine Malfunction Interrupt
            30 - 37     New PSW, Illegal Instruction Interrupt
            38 - 3F     New PSW, Machine Malfunction Interrupt

            90 - 97     New PSW, Relocation/Protection Interrupt

            98 - 9B     New PSW Status, Supervisory Call Interrupt
            9C - BB     New PSW Locations, Supervisory Call Interrupt

            D0 - 2CF    Interrupt Service Pointer Table
           300 - 3FF    Memory Access Controller

                                FIGURE 8.





                    2.4.1  MACHINE MALFUNCTION

             A  machine  malfunction interrupt  can  be caused  by  one  of the
        following: an early power failure (EPF) or a memory parity error.  When
        a  machine malfunction  occurs, if  PSW bit  2 is  set, a  PSW  swap is
        performed.  If bit  2 is reset, the  interrupt is ignored.  The  PSW at
        the time of  the interrupt is stored  at memory address  X'20-23'.  The
        program counter  is stored at  memory address X'24-27'.   A new  PSW is
        loaded  from memory  location X'38-3B'   and a  new program  counter is
        loaded from address X'3C-3F'.  This new program counter is the location
        of  a subroutine  to  find out  what  kind of  machine  malfunction has
        occurred and to process it, if possible.

             Currently, if the ENGINE  detects an early power fail,  the system
        will halt.  There are provisions, however, for allowing a subroutine to
        be executed when EPF is  detected.  At the present time,  however, this
        is not implemented.





                    2.4.2  ILLEGAL INSTRUCTION

             When  an  illegal  op code  is  detected,  an  illegal instruction
        interupt is generated.  When this interrupt is detected,  the processor
        loads a new PSW and new program counter from memory locations X'30-37'.
        The old PSW is stored in  register X'E' of the set selected by  the new


        18                           TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


        PSW.  The program  counter is stored in  register X'F' of the  new set.
        The processor will then halt if  the new PSW has the wait bit  set.  If
        the wait bit is reset, the processor will begin  executing instructions
        from the new address in the program counter.

             Unlike other interrupts,  an illegal instruction  interrupt cannot
        be disabled.  Since, when an illegal instruction occurs,  the processor
        does not know where the next instruction begins, normal processing must
        always be suspended and the interrupt handled.





                    2.4.3  RELOCATION/PROTECTION (MAC)

             A MAC interrupt is enabled whenever the MAC is turned on by having
        PSW  bit 5  set.  A  MAC interrupt  whenever a  bit in  the  MAC Status
        Register is set.  The MAC registers will be discussed below.

             When a  MAC interrupt occurs,  a new PSW  and Program  Counter are
        loaded from memory  address X'90-97' (absolute).   The old PSW  and old
        Program Counter are stored in  registers X'E' and X'F' in  the register
        set  specified  by  the  new PSW.   The  program  then  enters  the MAC
        interrupt service routine.  At this point the program usually reads the
        MAC Status Register to find the cause of the interrupt.





                    2.4.4  SUPERVISORY CALL (SVC)

             A SuperVisory Call is a user instruction (OP code: X'E1')  used to
        invoke a routine to perform some special service.

             Since there  are 16  different types  of SVC's,  there is  a table
        located in memory at  address X'9C-BB' which holds 16  halfwords.  Each
        of these halfwords is the address of an SVC service routine.

             When an  SVC instruction  is executed,  a new  PSW is  loaded from
        memory  address X'98-9B'.   The  old PSW  and old  Program  Counter are
        stored in  registers X'E' and  X'F' of  set 0.  The  R1 field  (0:F) is
        doubled and added to x'9C'.  This is the address of a  halfword pointer
        in the SVC service table.

             This half-word  pointer is  placed into  the Program  Counter, and
        execution proceeds from the new location.  At the completion of the SVC
        routine, an 'LPSWR' instruction from register X'E' will  return control
        to  the  invoking  program,  at  the  instruction  following   the  SVC
        originally executed.



        19                           TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


                    2.4.5  I/O INTERRUPTS

             I/O interupts are generated whenever an I/O device  needs service.
        Normally, an  I/O device  interrupts when  it is  ready to  accept more
        data, if the processor is writing to it, or when it has data to send to
        the processor, if the processor is reading from it.

             The ENGINE can handle up to 256 I/O devices, each device  having a
        unique number  X'00-FF'.  Since  each device is  different, there  is a
        different subroutine to handle each device.  Memory  location X'D0-2CF'
        is called the Interrupt Service Pointer Table.  This table contains 256
        halfword  entries,  each  entry  being  the  address  of   a  different
        subroutine.

             PSW bit 1, when set, allows device interrupts to be  recognized by
        the  processor.   When   a  device  interrupt  occurs,   the  processor
        acknowledges the interrupt.  This  has a two-fold purpose.   First, the
        interrupting device sends it's device number to the processor.  Second,
        the interrupt condition is cleared so it will not be serviced twice for
        the same interrupt.  Once  the process has obtained the  device number,
        the  PSW is  set  to X'2000',  disabling  any more  I/O  interrupts and
        selecting register set  0.  The processor then  stores the old  PSW and
        Program Counter into registers 0  and 1 of register set 0.   The device
        number of the interrupting device  is stored into register 2 of  set 0.
        The processor  then doubles the  device number and  adds it  to X'0D0'.
        This address now "points" to a halfword entry in the  Interrupt Service
        Pointer Table.  This halfword is loaded to the Program Counter, and the
        processor begins execution of  the service routine for  that particular
        device.  At the  end of the service  routine, a "LPSWR"  instruction to
        register  0 will  restore  the old  PSW  and Program  Counter  to their
        original values.

             The ENGINE may employ either one level of I/O interrupts (normal),
        or multiple levels  (Enhanced).  In enhanced ENGINES,  bits 8 and  9 of
        the PSW, while  still being used for  register set selection,  are also
        used,  in conjunction  with  bit 1,  for enabling  different  levels or
        classes  of  interrupt.   This  allows  more  efficient   servicing  of
        interrupts, and also allows the servicing of more than one interrupt at
        a time.





                    2.4.6  ENHANCED ASYNC TIMER INTERRUPTS

             When  the ENGINE  is ASYNC-enhanced,  the  normal timer-interrupts
        (70-75) are intercepted by the microcode, and are never seen by the CPU
        itself.   Since  these  have  also been  used  for  process  timing, an
        alternate timing mechanism is provided by the microcode, to permit this
        usage.

             The new mechanism uses register set "D":

        20                           TYMNET Engine                   ENGINE.DOC
        ENGINE DESCRIPTION                                     December 4, 1985


           REG E   Timer count (decrements by 1 for each async interrupt).
           REG F   address of routine to jump to when REG E is negative and:
                        ASYNC Interrupt, occuring when in Reg-set F, has just
                                caused REG E to go negative;
                                        -- OR --
                        LPSW or LPSWR exiting to Register-set F has just been
                                executed.















































        21                           TYMNET Engine                   ENGINE.DOC
        The MAC -- Memory Access Controller                    December 4, 1985






                       3 -  The MAC -- Memory Access Controller


             This chapter is intended to provide a general overview of the use,
        operation, and constraints related to the MAC

             (Memory Access Controller).






                              3.1  Absolute Address Space


             All references to addresses are in hexidecimal, of the  form XXXXX
        (an address is a BYTE reference, and is 20 bits long, or 5 hex digits).
        The  address  space,  for  the  purposes  of  this  discussion,  may be
        considered to  be formatted  into PAGES  of 256  bytes, and  an address
        PPPBB is a reference to byte  BB in page PPP.  When running  outside of
        the MAC operation  (as an interrupt routine  might do), a  reference to
        page PPP can refer to any  of 4096 pages, subject to the  actual memory
        physically present in the machine.

             This un-MAC'ed  address space is  the ABSOLUTE ADDRESS  SPACE, and
        corresponds to the real memory in one-to-one correspondance.






                              3.2  Virtual Address Space


             A process running under the MAC has a VIRTUAL ADDRESS SPACE, which
        is independent of the real absolute address space of the  machine.  All
        references  to virtual  address space  for a  process is  translated to
        absolute  address space  references by  the MAC  in a  mapping process,
        which also imposes access restrictions on the references.

             Two independent  processs may  have the  same virtual  address for
        independent references, but the MAC will sort these out, and  cause the
        references  to   be  to  different   real  addresses.    Likewise,  two
        independent processs may have different virtual addresses for  the same
        reference, and the  MAC will cause each  process to reference  the same
        real address.


        22                           TYMNET Engine                   ENGINE.DOC
        The MAC -- Memory Access Controller                    December 4, 1985


                                   3.3  MAC Mapping


             When running under the MAC, a reference address is of the form

             SPPBB,  where S  is a  reference  to one  of 16  SEGMENTS,  and PP
        references a page within that segment.

             In practice, the MAC is set up for a process before the process is
        run, by initializing  the MAC registers  (the MAC registers  are mapped
        into memory,  with MAC register  0 corresponding to  locations 300-303,
        etc).   Further discussion  is based  on a  properly set  MAC,  while a
        process is running.

             The MAC has a set  of 16 segment registers, or  DESCRIPTORS.  Each
        descriptor has a base page KKK and a page range LL, as well  as various
        sorts of protection status P, of form:

                ----.---+---.---+---.---+---.----
                | x |  LL   |    KKK    | P | x |
                ---------------------------------

             where "x" are fields unused by the MAC.

             The  program references  address  SPPBB:  the  MAC  intercepts the
        reference, and looks  up descriptor number  S.  Using descriptor  S, it
        performs two operations in parallel:  it computes absolute page # JJJ =
        PP + KKK; and it compares PP with LL--if PP > LL, the reference  is out
        of range,  and the  MAC traps the  program--otherwise it  may reference
        page JJJ (real address JJJBB).

             In addition to the above, the MAC makes some protection  checks on
        the operation to be performed.  If the segment is flagged  NOT PRESENT,
        the reference is illegal, and  the MAC traps the program.  If  the page
        is flagged NOT  EXECUTABLE, and this  is an instruction  reference, the
        MAC traps the program.  If the page is flagged NOT WRITE, and this is a
        write reference, the MAC traps the program.

             If all of  the above conditions  are satisfied, the  MAC completes
        the reference to byte BB, page JJJ.

             The MAC protection "P" has the 4-bit value:

                        ---------
                        |E|u|W|P|
                        ---------

             Where:

           E       Execution protected.
           u       Unused.
           W       Write protected.
           P       Presence...segment is not accessible if P=0.

        23                           TYMNET Engine                   ENGINE.DOC
        The MAC -- Memory Access Controller                    December 4, 1985


                                  3.4  MAC LOCATIONS


             The MAC  makes use  of absolute  locations 300-34F:   the specific
        usage is:

        Loc     Usage:

        300     MAC Register 0
        304     MAC Register 1
        308     MAC Register 2
        30C     MAC Register 3
        310     MAC Register 4
        314     MAC Register 5
        318     MAC Register 6
        31C     MAC Register 7
        320     MAC Register 8
        324     MAC Register 9
        328     MAC Register 10
        32C     MAC Register 11
        330     MAC Register 12
        334     MAC Register 13
        338     MAC Register 14
        33C     MAC Register 15
        340     MAC Status Register
        344     Last instruction fetch (Absolute address space)
        348     Parity-error Address (absolute)
        34C     Last instruction fetch (Virtual address space)


























        24                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985






                               4 -  LOGICAL INSTRUCTIONS


             The  set  of  logical   instructions  provide  a  means   for  the
        manipulation of binary data.  Many of the instructions grouped with the
        logical set may also be  used with in arithmetic and  other operations.
        These instructions include loads, stores, compares, and shifts.

             Halfword operands:

             Unless  otherwise  specified,  the  halfword  second  argument  is
        expanded to a fullword by propagating the most significant  bit through
        bits 0:15.  This fullword is then used as the operand.

             SF operands:

             The SF format instructions take the four bit number N,  and extend
        it to 32 bits by filling bits 0:27 with 0.




                                      4.1   LOAD


        NAD     Instruction                       Op-code  Time        Format

        L       Load                                 58   3.379         RX1
        L       Load                                 58   3.504         RX2
        L       Load                                 58   4.287         RX3
        LH      Load Halfword                        48   2.597         RX1
        LH      Load Halfword                        48   2.722         RX2
        LH      Load Halfword                        48   3.504         RX3
        LI      Load Immediate                       F8   2.472         RI2
        LHI     Load Halfword Immediate              C8   1.689         RI1
        LR      Load Register                        08   1.032         RR
        LIS     Load Immediate Short                 24   0.907         SF
        LCS     Load Complement Short                25   0.907         SF


                                       Operation

             The second operand replaces the contents of the register specified
        by R1.

             LCS takes the  two's complement of the  operand and loads  it into
        the  register  specified  by R1  (effectively,  sign-extends  the 4-bit
        number N to 32-bits -- as in LIS -- but then subtracts it from 0 before
        placing it in the register).

        25                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                    Condition Codes

        X000     operand is zero
        X001     operand is less than zero
        X010     operand is greater than zero




                                  4.2   LOAD Address


        NAD     Instruction                       Op-code  Time        Format

        LA      Load Address                         E6   2.065         RX1
        LA      Load Address                         E6   2.065         RX2
        LA      Load Address                         E6   2.847         RX3


                                       Operation

             The effective  address (a full  32 bit value)  is loaded  into the
        register specified by R1.


                                    Condition Codes

        X000     operand is zero
        X001     operand is less than zero
        X010     operand is greater than zero




                              4.3   LOAD Halfword Logical


        NAD     Instruction                       Op-code  Time        Format

        LHL     Load Halfword Logical                73   2.597         RX1
        LHL     Load Halfword Logical                73   2.722         RX2
        LHL     Load Halfword Logical                73   3.504         RX3


                                       Operation

             The halfword  second operand replaces  bits 16:31 of  the register
        specified by R1.  Bits 0:15 of the register specified by R1  are forced
        to zero.





        26                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                    Condition Codes

        X000     operand is zero
        X010     operand is greater than zero




                                  4.4   LOAD Multiple


        NAD     Instruction                       Op-code  Time        Format

        LM      Load Multiple                        D1   1.814+1.565*n RX1
        LM      Load Multiple                        D1   1.939+1.565*n RX2
        LM      Load Multiple                        D1   2.722+1.565*n RX2


                                       Operation

             n successive  registers, starting with  the register  specified by
        R1,  are loaded  from successive  memory locations,  starting  with the
        location  specified by  the effective  address of  the  second operand.
        Each register is loaded with a fullword from memory.  The process stops
        when register 15 has been loaded.

             The instructions are not interruptable.


                                    Condition Codes


             Condition codes are not affected.




                                    4.5   LOAD Byte


        NAD     Instruction                       Op-code  Time        Format

        LB      Load Byte                            D3   2.597         RX1
        LB      Load Byte                            D3   2.722         RX2
        LB      Load Byte                            D3   3.504         RX3
        LBR     Load Byte Register                   93   0.907         RR


                                       Operation

             The eight bit second  operand replaces the least  significant bits
        (bits  24:31)  of the  register  specified  by R1.   Bits  0:23  of the
        register are forced to zero.

        27                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                    Condition Codes

        X000     operand is zero
        X010     operand is greater than zero




                                4.6   EXCHANGE Halfword


        NAD     Instruction                       Op-code  Time        Format

        EXHR    EXchange Halfword Register           34   0.907         RR


                                       Operation

             Bits 0:15 of  the register specified by  R2 replace bits  16:31 of
        the register specified by R1.  Bits 16:31 of the register  specified by
        R2 replace bits 0:15 of the register specified by R1.

             if R1 equals R2,  the two halfwords contained within  the register
        are exchanged.


                                    Condition Codes

                 (32 bit operand):
        X000     operand is zero
        X001     operand is less than zero
        X010     operand is greater than zero




                                  4.7   EXCHANGE Byte


        NAD     Instruction                       Op-code  Time        Format

        EXBR    EXchange Byte Register               94   0.907         RR


                                       Operation

             The two eight  bit bytes contained in  bits 16:31 of  the register
        specified  by  R2 are  exchanged  and  loaded into  bits  16:31  of the
        register specified by  R1.  Bits 0:15 of  the register specified  by R1
        are unchanged.  The register specified by R2 is unchanged (unless equal
        to R1).

             R1 and R2 may specify the same register.

        28                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                    Condition Codes

                 (32 bit operand):
        X000     operand is zero
        X001     operand is less than zero
        X010     operand is greater than zero




                                      4.8   STORE


        NAD     Instruction                       Op-code  Time        Format

        ST      STore                                50   3.504         RX1
        ST      STore                                50   3.630         RX2
        ST      STore                                50   4.412         RX3
        STH     STore Halfword                       40   2.722         RX1
        STH     STore Halfword                       40   2.847         RX2
        STH     STore Halfword                       40   3.629         RX3


                                       Operation

             The 32 bit  contents of the register  specified by R1  replace the
        contents of the location specified by the effective address.

             Halfword store:

             Bits 16:31 of the register specified by R1 replace the contents of
        the memory location  specified by the  effective address of  the second
        operation.


                                    Condition Codes


             Condition codes are not affected.















        29                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                 4.9   STORE Multiple


        NAD     Instruction                       Op-code  Time        Format

        STM     STore Multiple                       D0   1.939+1.565*n RX1
        STM     STore Multiple                       D0   2.065+1.565*n RX2
        STM     STore Multiple                       D0   2.847+1.565*n RX3


                                       Operation

             THe  fullword contents  of registers,  starting with  the register
        specified by R1, replace  the contents of successive  memory locations,
        starting with the  location specified by  the effective address  of the
        second operand.  The process stops when register 15 has been stored.


                                    Condition Codes


             Condition codes are not affected.




                                   4.10   STORE Byte


        NAD     Instruction                       Op-code  Time        Format

        STB     STore Byte                           D2   3.505         RX1
        STB     STore Byte                           D2   3.603         RX2
        STB     STore Byte                           D2   4.412         RX3
        STBR    STore Byte Register                  92   0.907         RR


                                       Operation

             The  least significant  eight bits  (bits 24:31)  of  the register
        specified by R1 are stored in the second operand location.

             In the Store Byte Register instruction,  the eight bit quantity is
        stored in  bits 24:31 of  the register specified  by R2.  Bits  0:23 of
        that register are unchanged.

             STBR (only) sets the condition codes:
        X000     operand is equal to zero
        X010     operand is greater than zero





        30                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                      4.11   COPY


        NAD     Instruction                       Op-code  Time        Format

        COPY    COPY memory                          3F     ???         RR


                                       Operation

             The  instruction  copies  a  block of  memory  from  one  place to
        another.

             R1  specifies  the  address  of  the  last  source  halfword; R1+1
        specifies the address of the last destination halfword.

             CAUTION -- this instruction will ALWAYS access an additional half-
        word (this half-word is NOT copied) BEFORE the beginning of  the source
        block...if this block begins on  a segment boundary, this will  cause a
        reference to the LAST half-word of the previous segment, and  may cause
        a MAC violation!!  R2 specifies  the number of halfwords (minus  1!) to
        move, times 10x!

             The  instruction  is  interruptable, and  will  continue  from the
        interrupted point upon return from interrupt--this is  possible because
        (R2) is used to record how much of the copy has been performed.

                Example:

                LA      R3,SOURCE+0E    :address of source end to R1
                LA      R4,DESTIN+0E    :address of destination end to R1+1
                LHI     R1,70           :10*(number of HW's -1)
                COPY    R3,R1


                          THIS INSTRUCTION IS IMPLEMENTED IN
                     MICRO-CODE VERSION S-15 AND IT'S SUCCESSORS!

















        31                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                      4.12   AND


        NAD     Instruction                       Op-code  Time        Format

        N       aNd                                  54   3.379         RX1
        N       aNd                                  54   3.504         RX2
        N       aNd                                  54   4.287         RX3
        NH      aNd Halfword                         44   2.597         RX1
        NH      aNd Halfword                         44   2.722         RX2
        NH      aNd Halfword                         44   3.504         RX3
        NI      aNd Immediate                        F4   2.472         RI2
        NHI     aNd Halfword Immediate               C4   1.689         RI1
        NR      aNd Register                         04   1.032         RR


                                       Operation

             The logical product of the 32 bit second operand and  the contents
        of the register  specified by R1 replace  the contents of  the register
        specified by R1.  The 32 bit product is formed on a bit-by-bit basis.


                                    Condition Codes

        X000     result is zero
        X001     less than zero (bit 0 is 1)
        X010     greater than zero




                                       4.13   OR


        NAD     Instruction                       Op-code  Time        Format

        O       Or word                              56   3.379         RX1
        O       Or word                              56   3.505         RX2
        O       Or word                              56   4.287         RX3
        OH      Or Halfword                          46   2.597         RX1
        OH      Or Halfword                          46   2.722         RX2
        OH      Or Halfword                          46   3.505         RX3
        OI      Or Immediate                         F6   2.472         RI2
        OHI     Or Halfword Immediate                C6   1.690         RI1
        OR      Or Register                          06   1.032         RR


                                       Operation

             The logical sum of the  32 bit second operand and the  contents of
        the  register specified  by R1  replaces the  contents of  the register
        specified by R1.  The sum is formed on a bit-by-bit basis.

        32                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                    Condition Codes

        X000     result is zero
        X001     less than zero (bit 0 is 1)
        X010     greater than zero




                                  4.14   EXCLUSIVE OR


        NAD     Instruction                       Op-code  Time        Format

        X       eXlusive or                          57   3.379         RX1
        X       eXlusive or                          57   3.504         RX2
        X       eXlusive or                          57   4.287         RX3
        XH      eXclusive or Halfword                47   2.597         RX1
        XH      eXclusive or Halfword                47   2.722         RX2
        XH      eXclusive or Halfword                47   3.504         RX3
        XI      eXlusive or Immediate                F7   2.472         RI2
        XHI     eXclusive or Halfword Immediate      C7   1.689         RI1
        XR      eXlusive or Register                 07   1.032         RR


                                       Operation

             The  logical  difference of  the  32 bit  second  operand  and the
        contents of the register specified  by R1 replaces the contents  of the
        register specified by R1.  The 32 bit difference is formed on a bit-by-
        bit basis.


                                    Condition Codes

        X000     result is zero
        X001     less than zero (bit 0 is 1)
        X010     greater than zero
















        33                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                   4.15   ARRAY-AND


        NAD     Instruction                       Op-code  Time        Format

        ARAND   ARray AND                            3E     ???         RR


                                       Operation

             The  logical  "AND"  of  two  bit  arrays  is  performed,  and the
        instruction returns the "highest" bit number which is set in the result
        ("highest" means the left-most  bit in the highest halfword  found;  if
        there are several  bits which qualify  in this halfword,  the left-most
        one is found -- this is not really the "highest").

             If no bits fall through the sieve, the instruction performs a skip
        (+2) return;  else a normal return is performed.

             R1 is  to contain the  address of the  last halfword in  the first
        array;  R1+1 is  to contain  the address  of the  last halfword  in the
        second array.  R2 is to contain the number of bits minus 1 to scan.

             On success (normal return) in finding the bit set, R2 contains the
        number of the "highest" bit set in common in both arrays.

             On any return,  R1 and R1+1 are  also updated to reflect  the last
        halfword examined in each array.

                Example:

                LA      R7,A1+4         :end of array 1 into (R1)
                LA      R8,A2+4         :end of array 2 into (R1+1)
                LHI     R3,2F           :number of bits (-1) to test
                HC      3E73            :: ARAND R7,R3 ::
                JFS     HIT             Jump to process if bits matched
                NOP                     :skip return to here if no bits matched

                . . . .

        HIT     NOP                     :target of above jump


                          THIS INSTRUCTION IS IMPLEMENTED IN
                     MICRO-CODE VERSION S-15 AND IT'S SUCCESSORS!









        34                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                 4.16   TEST IMMEDIATE


        NAD     Instruction                       Op-code  Time        Format

        TI      Test Immediate                       F3   2.472         RI2
        THI     Test Halfword Immediate              C3   1.690         RI1


                                       Operation

             Each  bit  of  the  second operand  is  logically  ANDed  with the
        corresponding  bit of  register specified  by R1.   Neither  operand is
        changed, but the condition-code reflects the result.


                                    Condition Codes

        X000     result is zero
        X001     less than zero (bit 0 is 1)
        X010     greater than zero




                               4.17   SHIFT Left Logical


        NAD     Instruction                       Op-code  Time        Format

        SLL     Shift Left Logical                   ED   2.190 (0)     RX1
        SLL     Shift Left Logical                   ED   2.441+.125*n  RX1
        SLLS    Shift Left Logical Short             11   1.533 (0)     SF
        SLLS    Shift Left Logical Short             11   1.657+.125*n  SF


                                       Operation

             The first operand, the  contents of the register specified  by R1,
        is shifted left the number  of places specified by the  second operand.
        Bits shifted out  of position 0 are  shifted through the carry  flag of
        the condition codes and then lost.  The last bit shifted remains in the
        carry flag.  Zeros are shifted into position 31.

               NOTE:   In the RX1  instruction form, the  shift-count is
                       specified  by the  low 7-bits  of  the effective-
                       address  (rather than  the location  specified by
                       the effective-address).






        35                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                              4.18   SHIFT Right Logical


        NAD     Instruction                       Op-code  Time        Format

        SRL     Shift Right Logical                  EC   2.190 (0)     RX1
        SRL     Shift Right Logical                  EC   2.411+.125*n  RX1
        SRLS    Shift Right Logical Short            10   1.533 (0)     SF
        SRLS    Shift Right Logical Short            10   1.657+.125*n  SF


                                       Operation

             The first operand, the  contents of the register specified  by R1,
        is shifted right the number of places specified by the  second operand.
        Bits shifted out of position 31 are shifted through the carry  flag and
        then lost.  The last bit shifted remains in the carry flag.   Zeros are
        shifted into position 0.

               NOTE:   In the RX1  instruction form, the  shift-count is
                       specified  by the  low 7-bits  of  the effective-
                       address  (rather than  the location  specified by
                       the effective-address).




                          4.19   SHIFT Left Halfword Logical


        NAD     Instruction                       Op-code  Time        Format

        SLHL    Shift Left Halfword Logical          CD   2.190 (0)     RX1
        SLHL    Shift Left Halfword Logical          CD   2.691+.125*n  RX1
        SLHLS   Shift Left Halfword Logical Short    91   1.533 (0)     SF
        SLHLS   Shift Left Halfword Logical Short    91   1.909+.125*n  SF


                                       Operation

             Bits 16:31 of  the register specified by  R1 are shifted  left the
        number of places specified by the second operand.  Bits shifted  out of
        position 16 are shifted through the carry clag and lost.  The  last bit
        shifted remains in  the carry flag.   Zeros are shifted  into positions
        31.  Bits 0:15 of the first operand remain unchanged.


                                    Condition Codes

        X000     result is zero
        X001     result is less than zero
        X010     result is greater than zero


        36                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


               NOTE:   In the RX1  instruction form, the  shift-count is
                       specified  by the  low 7-bits  of  the effective-
                       address  (rather than  the location  specified by
                       the effective-address).




                          4.20   SHIFT Right Halfword Logical


        NAD     Instruction                       Op-code  Time        Format

        SRHL    Shift Right Halfword Logical         CC   2.190 (0)     RX1
        SRHL    Shift Right Halfword Logical         CC   2.691+.125*n  RX1
        SRHLS   Shift Right Halfword Logical Short   90   1.533 (0)     SF
        SRHLS   Shift Right Halfword Logical Short   90   1.909+.125*n  SF


                                       Operation

             Bits 16:31 of the register  specified by R1 are shifted  right the
        number of places specified by the second operand.  Bits shifted  out of
        position 31 are shifted through the carry flag and lost.  The  last bit
        shifted remains in the carry flag.  Zeros are shifted into position 16.
        Bits 0:15 of the first operand remain unchanged.


                                    Condition Codes

        X000     result is zero
        X001     result is less than zero
        X010     result is greater than zero

               NOTE:   In the RX1  instruction form, the  shift-count is
                       specified  by the  low 7-bits  of  the effective-
                       address  (rather than  the location  specified by
                       the effective-address).
















        37                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                              4.21   ROTATE Left Logical


        NAD     Instruction                       Op-code  Time        Format

        RLL     Rotate Left Logical                  EB   2.190 (0)     RX1
        RLL     Rotate Left Logical                  EB   2.441+.125*n  RX1


                                       Operation

             The 32 bit first  operand, contained in the register  specified by
        R1, is shifted left, end  around, the number of positions  specified by
        the second operand.   Bits shifted out of  position 0 are  shifted into
        position 31.


                                    Condition Codes

        X000     result is zero
        X001     result is less than zero
        X010     result is greater than zero

               NOTE:   In the RX1  instruction form, the  shift-count is
                       specified  by the  low 7-bits  of  the effective-
                       address  (rather than  the location  specified by
                       the effective-address).




                              4.22   ROTATE Right Logical


        NAD     Instruction                       Op-code  Time        Format

        RRL     Rotate Right Logical                 EA   2.190 (0)     RX1
        RRL     Rotate Right Logical                 EA   2.441+.125*n  RX1


                                       Operation

             The 32 bit first  operand, contained in the register  specified by
        R1, is shifted right, end around, the number of positions  specified by
        the second operand.  Bits shifted  out of position 31 are  shifted into
        position 0.








        38                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                    Condition Codes

        X000     result is zero
        X001     result is less than zero
        X010     result is greater than zero

               NOTE:   In the RX1  instruction form, the  shift-count is
                       specified  by the  low 7-bits  of  the effective-
                       address  (rather than  the location  specified by
                       the effective-address).

               NOTE   All  shift  and  rotate  instructions  require  an
                       additional n*0.125,  where n is  the low  order 7
                       bits of the shift count.




                                  4.23   TEST and Set


        NAD     Instruction                       Op-code  Time        Format

        TS      Test and Set                         E0   3.285         RX1
        TS      Test and Set                         E0   3.411         RX2
        TS      Test and Set                         E0   4.193         RX3


                                       Operation

             The halfword second operand is read from memory, and, on  the same
        cycle, 0FFFF is written back.  The condition code reflects the original
        value of the memory cell (at the time of the memory read).


                                    Condition Codes

        X000     cell contained zero
        X001     cell was negative
        X010     cell was greater than zero














        39                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                    4.24   TEST Bit


        NAD     Instruction                       Op-code  Time        Format

        TBT     Test BiT                             74   2.973         RX1
        TBT     Test BiT                             74   3.098         RX2
        TBT     Test BiT                             74   3.880         RX3


                                       Operation

             The second  operand address points  to a bit  array starting  on a
        halfword boundary.  The value contained in the register specified by R1
        is the bit displacement into the array.  The bit is located and tested.
        The test does not change the bit.


                                    Condition Codes

        X000     tested bit is zero
        X010     tested bit is one




                                    4.25   SET Bit


        NAD     Instruction                       Op-code  Time        Format

        SBT     Set BiT                              75   3.755         RX1
        SBT     Set BiT                              75   3.880         RX2
        SBT     Set BiT                              75   4.662         RX3


                                       Operation

             The second  operand address points  to a bit  array starting  on a
        halfword boundary.  The value contained in the register specified by R1
        is the bit displacement into the array.  The bit is located  and forced
        to one.


                                    Condition Codes

        X000     previous state of bit was zero
        X010     previous state of bit was one






        40                           TYMNET Engine                   ENGINE.DOC
        LOGICAL INSTRUCTIONS                                   December 4, 1985


                                   4.26   RESET Bit


        NAD     Instruction                       Op-code  Time        Format

        RBT     Reset BiT                            76   3.755         RX1
        RBT     Reset BiT                            76   3.880         RX2
        RBT     Reset BiT                            76   4.662         RX3


                                       Operation

             The second  operand address points  to a bit  array starting  on a
        halfword boundary.  The value contained in the register specified by R1
        is the bit displacement into the array.  The bit is located  and forced
        to zero.


                                    Condition Codes

        X000     previous state of bit was zero
        X010     previous state of bit was one




                                 4.27   COMPLEMENT Bit


        NAD     Instruction                       Op-code  Time        Format

        CBT     Complement BiT                       77   3.880         RX1
        CBT     Complement BiT                       77   4.005         RX2
        CBT     Complement BiT                       77   4.788         RX3


                                       Operation

             The second  operand address points  to a bit  array starting  on a
        halfword boundary.  The value contained in the register specified by R1
        is  the  bit displacement  into  the  array.  The  bit  is  located and
        complemented.


                                    Condition Codes

        X000     previous state of bit was zero
        X010     previous state of bit was one






        41                           TYMNET Engine                   ENGINE.DOC
        JUMP INSTRUCTIONS                                      December 4, 1985






                                5 -  JUMP INSTRUCTIONS


             In normal operation,  the CPU executes instructions  in sequential
        order.  The Jump instructions  allow this sequential mode  of operation
        to  be  varied,  so  that  programs  can  loop,  transfer   control  to
        subroutines,  or  make  decisions  based  on  the  results  of previous
        operations.

             NOTE...The times  quoted are  for UNSUCCESSFUL  jumps;  successful
        jumps require an additional 0.25 microseconds.




                                5.1   JUMP on CONDITION


        NAD     Instruction                       Op-code  Time        Format

        JF      Jump on False condition              43M  1.815         RX1
        JF      Jump on False condition              43M  1.815         RX2
        JF      Jump on False condition              43M  2.25          RX3
        JFR     Jump on False condition Register     03M  1.283         RR
        JFBS    Jump False Backward Short            22M  1.157         SF
        JFFS    Jump False Forward Short             23M  1.157         SF
        JT      Jump on True condition               42M  1.815         RX1
        JT      Jump on True condition               42M  1.815         RX2
        JT      Jump on True condition               42M  2.25          RX3
        JTR     Jump on True condition Register      02M  1.283         RR
        JTBS    Jump True Backward Short             20M  1.157         SF
        JTFS    Jump True Forward Short              21M  1.157         SF


                                       Operation

             Jump on FALSE condition:

             The condition code  of the Program Status  Word is tested  for the
        conditions specified in  the mask field,  M.  If ALL  conditions tested
        are  found to  be false,  a jump  is executed  to the  second operation
        location.  If  any of the  conditions tested is  found to be  true, the
        next sequential instruction is executed.

             Jump on TRUE condition:

             The condition code  of the Program Status  Word is tested  for the
        conditions specified in  the mask field,  M.  If ANY  conditions tested


        42                           TYMNET Engine                   ENGINE.DOC
        JUMP INSTRUCTIONS                                      December 4, 1985


        are  found to  be true,  a  jump is  executed to  the  second operation
        location.  If all of the  conditions tested are found to be  false, the
        next sequential instruction is executed.

             In the RR  format, the jump address  is contained in  the register
        specified by R2.

             In the SF format, the N field contains the number of  HALFWORDS to
        be added or subtracted from the current Location Counter to  obtain the
        jump address.


                                    Condition Codes


             Condition codes are not affected.

             Several NAD mnemonics have been defined for convenience:

        NAD     Instruction                       Op-code  Time        Format

        NOP     No OPeration                         420  1.815         RX1
        NOP     No OPeration                         420  1.815         RX2
        NOP     No OPeration                         420  2.25          RX3
        NOPR    No OPeration Register                020  0.909         RR

        J       Jump                                 430  1.815         RX1
        J       Jump                                 430  1.815         RX2
        J       Jump                                 430  2.25          RX3
        JR      Jump Register                        030  1.283         RR
        JBS     Jump Backward Short                  220  1.157         SF
        JFS     Jump Forward Short                   230  1.157         SF

        JE      Jump Equal                           433  1.815         RX1
        JE      Jump Equal                           433  1.815         RX2
        JE      Jump Equal                           433  2.25          RX3
        JER     Jump Equal Register                  033  1.283         RR
        JEBS    Jump Equal Backward Short            223  1.157         SF
        JEFS    Jump Equal Forward Short             233  1.157         SF

        JN      Jump Not equal                       423  1.815         RX1
        JN      Jump Not equal                       423  1.815         RX2
        JN      Jump Not equal                       423  2.25          RX3
        JNR     Jump Not equal Register              023  1.283         RR
        JNBS    Jump Not equal Backward Short        203  1.157         SF
        JNFS    Jump Not equal Forward Short         213  1.157         SF

        JG      Jump Greater                         422  1.815         RX1
        JG      Jump Greater                         422  1.815         RX2
        JG      Jump Greater                         422  2.25          RX3
        JGR     Jump Greater Register                022  1.283         RR
        JGBS    Jump Greater Backward Short          202  1.157         SF
        JGFS    Jump Greater Forward Short           212  1.157         SF

        43                           TYMNET Engine                   ENGINE.DOC
        JUMP INSTRUCTIONS                                      December 4, 1985


        JGE     Jump Greater Equal                   431  1.815         RX1
        JGE     Jump Greater Equal                   431  1.815         RX2
        JGE     Jump Greater Equal                   431  2.25          RX3
        JGER    Jump Greater Equal Register          031  1.283         RR
        JGEBS   Jump Greater Equal Backward Short    221  1.157         SF
        JGEFS   Jump Greater Equal Forward Short     231  1.157         SF

        JLE     Jump Less Equal                      432  1.815         RX1
        JLE     Jump Less Equal                      432  1.815         RX2
        JLE     Jump Less Equal                      431  2.25          RX3
        JLER    Jump Less Equal Register             032  1.283         RR
        JLEBS   Jump Less Equal Backward Short       222  1.157         SF
        JLEFS   Jump Less Equal Forward Short        232  1.157         SF

        JL      Jump Less                            421  1.815         RX1
        JL      Jump Less                            421  1.815         RX2
        JL      Jump Less                            421  2.25          RX3
        JLR     Jump Less Register                   021  1.283         RR
        JLBS    Jump Less Backward Short             201  1.157         SF
        JLFS    Jump Less Forward Short              211  1.157         SF

        JC      Jump Carry                           428  1.815         RX1
        JC      Jump Carry                           428  1.815         RX2
        JC      Jump Carry                           428  2.25          RX3
        JCR     Jump Carry Register                  028  1.283         RR
        JCBS    Jump Carry Backward Short            208  1.157         SF
        JCFS    Jump Carry Forward Short             218  1.157         SF

        JNC     Jump No Carry                        438  1.815         RX1
        JNC     Jump No Carry                        438  1.815         RX2
        JNC     Jump No Carry                        438  2.25          RX3
        JNCR    Jump No Carry Register               038  1.283         RR
        JNCBS   Jump No Carry Backward Short         228  1.157         SF
        JNCFS   Jump No Carry Forward Short          228  1.157         SF




                                  5.2   JUMP and LINK


        NAD     Instruction                       Op-code  Time        Format

        JAL     Jump And Link                        41   1.815         RX1
        JAL     Jump And Link                        41   1.815         RX2
        JAL     Jump And Link                        41   2.25          RX3
        JALR    Jump And Link Register               01   1.283         RR


                                       Operation

             The address  of the  next sequential instruction  is saved  in the


        44                           TYMNET Engine                   ENGINE.DOC
        JUMP INSTRUCTIONS                                      December 4, 1985


        register specified by R1, and  a branch is taken to the  second operand
        address.

             The branch address is obtained before the register specified by R1
        is changed.




                             5.3   JUMP on Find First One


        NAD     Instruction                       Op-code  Time        Format

        JFFO    Jump Find First One                  31   1.533 R=0     SF
        JFFO    Jump Find First One                  31   1.659 (Bit 0) SF
        JFFO    Jump Find First One                  31   1.503+.125*n  SF
        JFFOH   Jump Find First One Halfword         33   1.544 R=0     SF
        JFFOH   Jump Find First One Halfword         33   1.659 (Bit 0) SF
        JFFOH   Jump Find First One Halfword         33   1.503+.125*n  SF


                                       Operation

             The register specified is examined to determine if it is zero.  If
        so,  the  next  sequential  instruction  is  executed.   If  not, these
        instructions are equivalent to a  JFS, and the NUMBER of  the left-most
        ONE is placed into register  R+1.  The left-most bit is  numbered zero,
        the next is numbered 1, etc.

             JFFO operates on the full, 32-bit register specified.

             JFFOH  operates  on  the  right-most  16  bits  of   the  register
        specified.  It numbers register bit 16d as number 0, etc.




















        45                           TYMNET Engine                   ENGINE.DOC
        ARITHMETIC INSTRUCTIONS                                December 4, 1985






                             6 -  ARITHMETIC INSTRUCTIONS


             The fixed point arithmetic instructions provide a complete  set of
        operations for calculating addresses and indexes, for counting, and for
        general purpose fixed point arithmetic.

             The  fixed  point  instructions include  both  full-  and halfword
        operations.  Fullword operations take place between the contents of two
        general registers, or between the contents of a general register  and a
        fullword  stored  in  memory,  or between  the  contents  of  a general
        register and a fullword obtained from the instruction stream.

             Halfword  operations are  like  fullword, except  that  before the
        halfword operand is used, it  is expanded to a fullword  by propagating
        the most  significant bit (sign  bit) into the  high order bits  of the
        fullword.




                                       6.1   ADD


        NAD     Instruction                       Op-code  Time        Format

        A       Add                                  5A   3.379         RX1
        A       Add                                  5A   3.504         RX2
        A       Add                                  5A   4.287         RX3
        AH      Add Halfword                         4A   2.597         RX1
        AH      Add Halfword                         4A   2.722         RX2
        AH      Add Halfword                         4A   3.504         RX3
        AI      Add Immediate                        FA   2.472         RI2
        AHI     Add Halfword Immediate               CA   1.690         RI1
        AR      Add Register                         0A   1.032         RR
        AIS     Add Immediate Short                  26   0.907         SF


                                       Operation

             The second operand is  added algebraically to the contents  of the
        register specified by R1.  The results of this 32 bit addition replaces
        the contents of the register specified by R1.

             The  second operand  for the  add immediate  short  instruction is
        obtained by expanding the four bit data field, N, to a 32  bit fullword
        by forcing the high order bits to zero.



        46                           TYMNET Engine                   ENGINE.DOC
        ARITHMETIC INSTRUCTIONS                                December 4, 1985


                                    Condition Codes

        0000     equal to zero
        0001     less than zero
        0010     greater than zero




                                  6.2   ADD to Memory


        NAD     Instruction                       Op-code  Time        Format

        AM      Add to Memory                        51   5.445         RX1
        AM      Add to Memory                        51   5.570         RX2
        AM      Add to Memory                        51   6.353         RX3
        AHM     Add Halfword to Memory               61   3.629         RX1
        AHM     Add Halfword to Memory               61   3.755         RX2
        AHM     Add Halfword to Memory               61   4.537         RX3


                                       Operation

             The second operand is  added algebraically to the contents  of the
        register specified by  R1.  The result  replaces the second  operand in
        memory.  The content of R1 is not changed.


                                    Condition Codes

        X000     equal to zero
        X001     less than to zero
        X010     greater than to zero

             NOTE:  The  AHM instruction on  the ENGINE contains  a bug  in all
        versions of the microcode.  The bug may cause incorrect  condition code
        settings under certain conditions.

             The condition code settings are based on the 32-bit  algebraic sum
        of  the  contents of  R1,  and the  16-bit  operand with  the  sign bit
        extended to bits  0-15.  THEY ARE NOT  BASED ON THE HALFWORD  RESULT IN
        MEMORY!

             The following examples illustrate the difference:

        REGISTER  OPERAND  RESULT        CONDITION CODE:
                                         is   should be
                                        CVGL    CVGL
        00000001   7FFF     8000        0010    0001
        FFFFFFFF   8000     7FFF        1001    1010
        0000FFFF   0001     0000        0010    1000


        47                           TYMNET Engine                   ENGINE.DOC
        ARITHMETIC INSTRUCTIONS                                December 4, 1985


             Please be aware of this anomoly if it affects your code.

             One  additional  note:  The  carry-bit  is specified  as  a "don't
        care".  In fact,  the carry-bit is set  according to the result  of the
        aforementioned instruction operation and can be used  accordingly (e.g.
        to determine when the result has overflowed 16 bits).




                                    6.3   SUBTRACT


        NAD     Instruction                       Op-code  Time        Format

        S       Subtract                             5B   3.379         RX1
        S       Subtract                             5B   3.504         RX2
        S       Subtract                             5B   4.287         RX3
        SH      Subtract Halfword                    4B   2.597         RX1
        SH      Subtract Halfword                    4B   2.722         RX2
        SH      Subtract Halfword                    4B   3.504         RX3
        SI      Subtract Immediate                   FB   2.472         RI2
        SHI     Subtract Halfword Immediate          CB   1.689         RI1
        SR      Subtract Register                    0B   1.032         RR
        SIS     Subtract Immediate Short             27   0.907         SF


                                       Operation

             The second operand  is subtracted algebraically from  the contents
        of the register specified by  R1.  The result replaces the  contents of
        the register specified by R1.


                                    Condition Codes

        X000     equal to zero
        X001     less than to zero
        X010     greater than to zero















        48                           TYMNET Engine                   ENGINE.DOC
        ARITHMETIC INSTRUCTIONS                                December 4, 1985


                                 6.4   COMPARE Logical


        NAD     Instruction                       Op-code  Time        Format

        CL      Compare Logical                      55   3.379         RX1
        CL      Compare Logical                      55   3.504         RX2
        CL      Compare Logical                      55   4.287         RX3
        CLH     Compare Logical Halfword             45   2.597         RX1
        CLH     Compare Logical Halfword             45   2.722         RX2
        CLH     Compare Logical Halfword             45   3.504         RX3
        CLI     Compare Logical Immediate            F5   2.472         RI2
        CLHI    Compare Logical Halfword Immediate   C5   1.690         RI1
        CLR     Compare Logical Register             05   1.032         RR


                                       Operation

             The first operand, the  contents of the register specified  by R1,
        is compared to the second  operand, by subtracting the second  from the
        first.  The result is indicated by the Condition Code setting.  Neither
        operand is changed.

             Compare  Logical produces  the same  condition codes  as subtract.
        The G and L bits are as would be expected when subtracting  two 31-bit,
        signed numbers.   The C bit  has the significance  of a  carry occuring
        during  the  subtract  (which   is  implemented  in  the   hardware  as
        complement-second argument and then add).


                                    Condition Codes

        X000     operands are the same
        X001     first operand is algebraically less than second
        X010     first operand is algebraically greater than second
        10XX     first operand is logically greater than or equal to second
        00XX     first operand is logically less than second

           NOTE:  The  ONLY  difference  between the  Compare  Logical  and the
               corresponding Compare instructions  is the C flag!   Exactly the
               same (signed)  arithmetic processing is  performed upon  the two
               operands.  Thus,  the JG  and JL instructions  may not  give the
               correct result,  based upon  the conventional  interpretation of
               "compare logical";  xFFFFFFFF  is always "less"  than x7FFFFFFF.
               JC or JNC should be used instead if a true "logical"  compare is
               being performed.








        49                           TYMNET Engine                   ENGINE.DOC
        ARITHMETIC INSTRUCTIONS                                December 4, 1985


                              6.5   COMPARE Logical Byte


        NAD     Instruction                       Op-code  Time        Format

        CLB     Compare Logical Byte                 D4   2.597         RX1
        CLB     Compare Logical Byte                 D4   2.722         RX2
        CLB     Compare Logical Byte                 D4   3.504         RX3


                                       Operation

             The  byte  quantity,  contained  in  bits  24:31  of  the register
        specified  by R1,  is  compared with  the second  operand.   (Two 8-bit
        numbers,  zero-filled  to  form 32-bit  arguments,  are  compared.) The
        result is indicated by the Condition Code setting.  Neither  operand is
        changed.


                                    Condition Codes

        X000     operands are equal
        X001     first operand is less than second
        X010     first operand is greater than second




                                6.6   COMPARE Algebraic


        NAD     Instruction                       Op-code  Time        Format

        C       Compare                              59   3.379         RX1
        C       Compare                              59   3.504         RX2
        C       Compare                              59   4.287         RX3
        CH      Compare Halfword                     49   2.597         RX1
        CH      Compare Halfword                     49   2.722         RX2
        CH      Compare Halfword                     49   3.504         RX3
        CI      Compare Immediate                    F9   2.472         RI2
        CHI     Compare Halfword Immediate           C9   1.690         RI1
        CR      Compare Register                     09   1.126         RR


                                       Operation

             The first operand, contained  in the register specified by  R1, is
        compared algebraically to the second operand.  The result  is indicated
        by  the  Condition  Code  setting.  The  C  flag  has  no significance.
        Neither operand is changed.




        50                           TYMNET Engine                   ENGINE.DOC
        ARITHMETIC INSTRUCTIONS                                December 4, 1985


                                    Condition Codes

        X000     operands are equal
        X001     first operand less than second
        X010     first operand greater than second

             NOTE...These instructions  are like  compare logical,  except that
        positive  numbers are  always greater  than negative  numbers.  Compare
        logical is faster.

             If   the  result   of  subtracting   the  two   operands   is  not
        arithmetically correct, due  to overflow, as  for instance when  one of
        the operands is  00000001 and the other  operand is 80000000,  then the
        condition code will  differ (the G and  L flags will be  opposite) from
        that of the compare logical.




                                    6.7   MULTIPLY


        NAD     Instruction                       Op-code  Time        Format

        M       Multiply                             5C   16.773        RX1
        M       Multiply                             5C   16.899        RX2
        M       Multiply                             5C   17.681        RX3
        MR      Multiply Register                    1C   14.082        RR


                                       Operation

             The fullword first operand, contained in the register specified by
        R1+1, is multiplied by the fullword second operand.  the 64  bit result
        is stored in the registers specified by R1 and R1+1.


                                    Condition Codes


             Condition codes are not affected.

             NOTE...Multiply and divide use unsigned absolute arithmetic.

             R1+1 is computed from R1 modulo 16d.  Thus if R1 is  register 15d,
        then R1+1 is register 0.








        51                           TYMNET Engine                   ENGINE.DOC
        ARITHMETIC INSTRUCTIONS                                December 4, 1985


                                6.8   MULTIPLY Halfword


        NAD     Instruction                       Op-code  Time        Format

        MH      Multiply Halfword                    4C   10.233        RX1
        MH      Multiply Halfword                    4C   10.358        RX2
        MH      Multiply Halfword                    4C   11.140        RX3
        MHR     Multiply Halfword Register           0C   8.198         RR


                                       Operation

             The  first  operand,  contained  in  bits  16:31  of  the register
        specified by R1 is multiplied by the 16 bit second operand.  The 32 bit
        result replaces the contents of the register specified by R1.


                                    Condition Codes


             Condition codes are not affected.




                                     6.9   DIVIDE


        NAD     Instruction                       Op-code  Time        Format

        D       Divide                               5D   25.599        RX1
        D       Divide                               5D   25.723        RX2
        D       Divide                               5D   26.505        RX3
        DR      Divide Register                      1D   25.724        RR


                                       Operation

             The 64 bit operand contained in the registers specified by  R1 and
        R1+1 are divided by the fullword divisor.  The 32 bit  signed remainder
        replaces the  contents of  the register  specified by  R1.  The  32 bit
        quotient replaces the contents of register R1+1.


                                    Condition Codes


             Condition codes are not affected.





        52                           TYMNET Engine                   ENGINE.DOC
        ARITHMETIC INSTRUCTIONS                                December 4, 1985


                                6.10   DIVIDE Halfword


        NAD     Instruction                       Op-code  Time        Format

        DH      Divide Halfword                      4D   15.365        RX1
        DH      Divide Halfword                      4D   15.490        RX2
        DH      Divide Halfword                      4D   16.273        RX3
        DHR     Divide Halfword Register             0D   12.204        RR


                                       Operation

             The 32 bit divident contained  in the register specified by  R1 is
        divided by a 16 bit divisor taken from memory or from bits 16:31 of the
        register  specified by  R2.   The 16  bit  remainder is  expanded  to a
        fullword by progagating the sign bit through bits 0:15 and is stored in
        the register  specified by R1.   The 16 bit  quotient is expanded  to a
        fullword by propagating the sign bit through bits 0:15 and is stored in
        the register specified by R1+1.

             R1+1 is computed from R1 modulo 16d.  Thus if R1 is  register 15d,
        then R1+1 is register 0.


                                    Condition Codes


             Condition codes are not affected.




                             6.11   SHIFT Right Arithmetic


        NAD     Instruction                       Op-code  Time        Format

        SRA     Shift Right Arithmetic               EE   2.190 (0)     RI1
        SRA     Shift Right Arithmetic               EE   2.441+.125*n  RI1


                                       Operation

             The contents of the register  specified by R1 is shifted  right by
        the number  of places specified  by the second  operand.  The  sign bit
        (bit 0) remains  unchanged, and is propagated  right as many  places as
        are specified by the second  operand.  Bits shifted out of  position 31
        are shifted  through the  carry flag  and lost.   The last  bit shifted
        remains in the carry flag.




        53                           TYMNET Engine                   ENGINE.DOC
        ARITHMETIC INSTRUCTIONS                                December 4, 1985


                                    Condition Codes

        X000     equal to zero
        X001     less than zero
        X010     greater than zero




                             6.12   LOAD Halfword Register


        NAD     Instruction                       Op-code  Time        Format

        LHR     Load Halfword Register               12   1.158         RR
        CHVR    Convert Halfword Value Register      12   1.158         RR


                                       Operation

             The  halfword  second  operand,  (bits  16:31)  of   the  register
        specified by  R2, is expanded  to a fullword  by sign-extending  bit 16
        through  bits 0:15,  and  then replaces  the contents  of  the register
        specified by R1.

             CHVR is an obsolete mnemonic for the LHR instruction.


                                    Condition Codes

        X000     equal to zero
        X001     less than zero
        X010     greater than zero





















        54                           TYMNET Engine                   ENGINE.DOC
        STATUS SWITCHING INSTRUCTIONS                          December 4, 1985






                          7 -  STATUS SWITCHING INSTRUCTIONS


             The Status-Switching instructions provide for software  control of
        the  interrupt structure  of the  system.  They  also allow  user level
        programs to  communicate with control  software.  All  status switching
        instructions, with the exception of the SVC and UPSW  instructions, are
        privileged  instructions.   Because  of  this,  all  interrupt handling
        routines must run in the supervisor mode.




                            7.1   LOAD Program Status Word


        NAD     Instruction                       Op-code  Time        Format

        LPSW    Load Program Status Word             C2   4.662         RX1
        LPSW    Load Program Status Word             C2   4.66          RX2
        LPSW    Load Program Status Word             C2   4.50          RX3
        UPSW    User Program Status Word             D5   4.66          RX1
        UPSW    User Program Status Word             D5   4.66          RX2
        UPSW    User Program Status Word             D5   4.50          RX3
        LPSWR   Load Program Status Word Register    18   0.75          RR


                                       Operation

             The 64 bit second operand becomes the current program status word.

             UPSW works  like LPSW, except  that not all  of the fields  of the
        target  PSD  are loaded.   In  particular, only  those  bits  masked by
        x'100F'  ("trace" bit,  condition  codes) in  the PSW  may  be changed.
        Other bits will remain unchanged.

             For the  LPSWR instruction,  it should  be noted  that the  64 bit
        second operand is obtained from  the registers specified by R1  and R2,
        where the address  portion comes from (R1),  and the PSW  portion comes
        from (R2).


                                    Condition Codes


             determined by the new PSW.




        55                           TYMNET Engine                   ENGINE.DOC
        STATUS SWITCHING INSTRUCTIONS                          December 4, 1985


                        7.2   EXCHANGE Program Status Register


        NAD     Instruction                       Op-code  Time        Format

        EPSR    Exchange Program Status Register     95   0.75          RR


                                       Operation

             Bits 0:31 of the current program status word replace  the contents
        of  the  register  specified  by  R1.   The  contents  of  the register
        specified by R2 replace bits  0:31 of the current program  status word.
        If R1 = R2, bits 0:31  of the current PSW are copied into  the register
        specified by R1, but otherwise remain unchanged.


                                    Condition Codes


             Determined by the new status.




                                 7.3   SUPERVISOR Call


        NAD     Instruction                       Op-code  Time        Format

        SVC     SuperVisor Call                      E1   3.75          RX2
        SVC     SuperVisor Call                      E1   3.75          RX1
        SVC     SuperVisor Call                      E1   4.50          RX3


                                       Operation

             THe address of the  second operand replaces bits 8:31  of register
        13 of register set  0.  Bits 0:7 of  this register are forced  to zero.
        The current program status  word replaces the contents of  registers 14
        and 15 of register set 0.  The fullword quantity located at  X'00098 in
        memory replaces bits 0:31 of the current PSW.  The R1 field  is doubled
        and added to X'0009C.  The halfword quantity located at this address is
        expanded to 32  bits by filling bits  0:15 with zeros, and  becomes the
        current location counter.


                                    Condition Codes


             Determined by the new PSW.



        56                           TYMNET Engine                   ENGINE.DOC
        I/O INSTRUCTIONS                                       December 4, 1985






                                 8 -  I/O INSTRUCTIONS


             The I/O  instructions use  the Register to  Register (RR)  and the
        Register and Indexed Storage (RX) instruction formats.

             ALL CPU  operands are 16-bit  quantities, even if  certain devices
        only use 8-bit quantities.   Thus, status and commands are  both 16-bit
        quantities.

             In particular, device address  is a 16-bit quantity,  even though,
        by  convention,  only  the  low-order  (rightmost)  8-bits  address the
        specific device (certain devices  may address subdevices via  the high-
        order bits).

             For the RX instructions, The half-word operand is fetched from the
        half-word  of  memory  specified  (the  low-order  bit  of  address  is
        ignored).   Then, if  the low-order  bit of  memory is  off  (even byte
        address), the half-word of data  has the left and right  bytes swapped,
        and the resulting  operand is output.   This permits the  addressing of
        bytes  in memory  for the  use of  byte-oriented devices.   The  way to
        remember this  rule is that  the byte addressed  is transmitted  as the
        right-most byte of  the 16-bit operand.  (If  one wishes to  transmit a
        half-word  from   a  halfword  boundary,   with  the   same  left-right
        relationship as  appears in memory,  one should address  the right-most
        byte:  ie, the half-word address + 1!)

             Since I/O  devices tend to  be connected to  interrupts, it  is as
        well to discuss them briefly  here.  There is an I/O  interrupt vector,
        starting at location 0D0.   The low-order 8-bits of the  device address
        presented with  the interrupt is  taken by the  CPU, doubled,  added to
        0D0, and the resulting half-word  operand address is used to  fetch the
        (half-word) interrupt  routine address.  At  the same time,  control is
        transfered  to  register set  0,  the interrupted  PSD  is  placed into
        registers 0  and 1,  and the  device-address is  placed in  register 2,
        interrupting to the address specified.

             NOTE...Unlike the Interdata, register 3 is NOT set up  with status
        on I/O  interrupts.  If status  is desired, the  user MUST issue  a SSR
        instruction!

             Following most I/O instructions, the V flag in the  Condition Code
        indicates an instruction timeout.  This means that the  instruction was
        not completed,  either because the  device did not  respond at  all, or
        because it responded incorrectly.

             In the Sense Status instruction, the V flag can also  mean examine
        status.   To  distinguish  between these  two  conditions,  the program


        57                           TYMNET Engine                   ENGINE.DOC
        I/O INSTRUCTIONS                                       December 4, 1985


        should test Bits 0:3  of the device status.   If all of these  bits are
        zero, device timeout has occured.


                                    Condition Codes

        0100     timeout has occured
        XXXX     normal response




                                   8.1   Console IO


        NAD     Instruction                       Op-code  Time        Format

        CIO     Console IO                           99   1.00          RR


                                       Operation

             The low-order 16 bits of  the register specified by R1  are placed
        into the low-order  (right) 16 bits of  the display.  The  low-order 20
        bits of the next register (R1+1) are placed into the  high-order (left)
        20 bits of the display.  The 16 bit switch register is then  input, and
        placed into the register specified by R2.


                                    Condition Codes


             The conditions codes are not affected by this instruction.




                                  8.2   Sense Status


        NAD     Instruction                       Op-code  Time        Format

        SSR     Sense Status Register                9D   1.00          RR


                                       Operation

             Bits  16:31 of  the register  specified by  R1 contain  the device
        address.  The device  is addressed and the  device status is  placed in
        R2.  The Condition Code is set equal to the rightmost four bits  of the
        device status.  The first operand is unchanged.

             This is a privileged instruction.

        58                           TYMNET Engine                   ENGINE.DOC
        I/O INSTRUCTIONS                                       December 4, 1985


                                    Condition Codes


             Bits 4:7 of the device status are copied into the  Condition Code.
        See the appropriate device manual for a description of this status.




                                 8.3   Output Command


        NAD     Instruction                       Op-code  Time        Format

        OC      Output Command                       DE   1.00          RX1
        OC      Output Command                       DE   1.00          RX2
        OC      Output Command                       DE   2.00          RX3
        OCR     Output Command Register              9E   1.00          RR


                                       Operation

             Bits  16:31 of  the register  specified by  R1 contain  the device
        address.  The device  is addressed and  the command half-word  from the
        second operand location to the device.  Neither operand is changed.

             These are privileged instructions.


                                    Condition Codes

        0100     Instruction timeout
        0000     Operation successful




                                    8.4   Read Data


        NAD     Instruction                       Op-code  Time        Format

        RDR     Read Data                            9B   1.00          RR


                                       Operation

             Bits  16:31 of  the register  specified by  R1 contain  the device
        address.   The  device  is addressed  and  responds  by  transmitting a
        sixteen-bit data  quantity.  This  quantity is  placed in  the register
        specified by R2.  Bits 0:15 of R2 are forced to zero.

             This is a privileged instruction.

        59                           TYMNET Engine                   ENGINE.DOC
        I/O INSTRUCTIONS                                       December 4, 1985


                                    Condition Codes

        0000     Operation Successful
        0100     Instruction timeout




                                   8.5   Write Data


        NAD     Instruction                       Op-code  Time        Format

        WD      Write Data                           DA   2.25          RX1
        WD      Write Data                           DA   2.25          RX2
        WD      Write Data                           DA   3.00          RX3
        WDR     Write Data Register                  9A   0.75          RR


                                       Operation

             Bits  16:31 of  the register  specified by  R1 contain  the device
        address.  The device is addressed the processor transmits a sixteen-bit
        data  quantity,  from  the  second  operand  location,  to  the device.
        Neither operand is changed.

             For  the  RX  format  instructions,  the  16-bit  halfword  at the
        effective address  is output.   If the effective  address is  EVEN, THE
        LEFT AND RIGHT BYTE OF  THAT HALFWORD ARE SWAPPED BEFORE  OUTPUT!  This
        insures that the specific byte addressed will be output in  the correct
        format  for  byte (8-bit  data)  devices.  It  also  requires  that the
        programmer  transfering  a  16-bit quantity  from  memory  to  a device
        address the ODD (right-most) byte of that half-word!

             For  the  RR format  instruction,  the low-order  16  bits  of the
        register specified by R2 are output.

             This is a privileged instruction.


                                    Condition Codes

        0000     Operation Successful
        0100     Instruction timeout










        60                           TYMNET Engine                   ENGINE.DOC
        SPECIAL INSTRUCTIONS                                   December 4, 1985






                               9 -  SPECIAL INSTRUCTIONS


             This chapter  describes the special,  TYMNET-oriented instructions
        implemented in the ENGINE microcode.




                                 9.1   Async Microcode


        NAD     Instruction                       Op-code  Time        Format

        SBOD    Start Baud                           13     ???         RR
        XMIT    Start Baud Output                    14     ???         RR
        SPM     Start Baud TID                       15     ???         RR
        GCHAR   Start Baud Input                     16     ???         RR


                                       Operation

               NOTE:   This set  of instructions  is illegal  unless the
                       "ASYNC microcode  enable" PSW bit  (Bit 4  of the
                       PSW) is enabled!





                    9.1.1  SBOD

             SBOD  performs the  start-baud  scanner function.   Expects  R2 to
        contain the MAC'ed address of  a bit array with bits  set corresponding
        to ports with output pending.  This instruction does a normal return if
        no  input or  output pending;   a skip  (^4) if  a start-baud  has been
        detected;   skip-2 (^8)  if an  output port  requires service.   In the
        latter two cases, registers  RP and RP2 (0E and  0D) will be set  up to
        reflect the port discovered.











        61                           TYMNET Engine                   ENGINE.DOC
        SPECIAL INSTRUCTIONS                                   December 4, 1985


                    9.1.2  XMIT

             XMIT places output character into the ring.  Expects  registers RP
        (0E) and RP2 (0D)  to be set up.  The character is output from register
        0, and register 2 contains the output baud rate index for this port.





                    9.1.3  SPM

             SPM  Performs  the  Terminal  Identification  function.   SPM will
        perform a normal  return if more than  36 samples of spacing  state are
        detected: else it will perform a skip (^2) return;  then the  number of
        samples of spacing state is contained in the register specified by R1.





                    9.1.4  GCHAR

             GCHAR gets input  character.  Expects registers  RP and RP2  to be
        set up.  It expects that the register specified by R2 contain the input
        baud rate index.  The data  character is returned in register  0.  THis
        instruction will  perform a normal  return for normal  data characters;
        it performs a skip (^4) return if it detects a break character (no stop
        baud) on input.

               NOTE:   Critical to  proper ASYNC Microcode  operation is
                       the correct  initialization of the  registers and
                       data  structures  involved.   See   the  appendix
                       "ASYNC Implementation" for a discussion  of these
                       requirements.




                                 9.2   SYNC Microcode


        NAD     Instruction                       Op-code  Time        Format

        SCAN    Scan Sync input                      35     ???         RR
        ALIGN   Align Sync input                     36     ???         RR
        CKSUM   Checksum Sync input                  37     ???         RR


                         THESE INSTRUCTIONS ARE IMPLEMENTED IN
                     MICRO-CODE VERSION S-15 AND IT'S SUCCESSORS!



        62                           TYMNET Engine                   ENGINE.DOC
        SPECIAL INSTRUCTIONS                                   December 4, 1985


                                       Operation





                    9.2.1  SCAN

             SCAN scans through the SYNC input data looking for data other than
        marking  state (all  ones).  Expects  the register  specified by  R2 to
        contain  the address  of  the input  ring  to scan  (100x  bytes long).
        Expects the register specified by R1 to contain the lead  pointer (RLP,
        index),  and R1+1  to  contain the  trailing pointer  (RTP,  index).  A
        normal return is made if  non-marking data is encountered in  the input
        ring, and a  skip return (+2) if  not.  The instruction  stops scanning
        when  the trailing  pointer  is less  than  10x bytes  behind  the lead
        pointer.

        EXAMPLE:

                LA      9,BUFFER                :address of input ring
                LHL     7,RLP                   :lead pointer
                LHL     8,RTP                   :trailing pointer
                SCAN    7,9
                JFS     HIT                     :non-skip return for hit
        NOHIT   EQ      .                       :no-hit return
                ...
        HIT     EQ      .                       :success routine





                    9.2.2  ALIGN

             ALIGN gets data  from the SYNC input  ring, shifts it  for correct
        alignment, and stores  it in the  designated buffer (input  sector) for
        RTD.  Both vertical and diagonal checksums are computed in the process.
        The register specified  by R1 contains the  start address of  the input
        ring.  R2 is  to contain the trailing  pointer (RTP, index)  BEYOND the
        first word of the input packet.

             ALIGN also requires the following specific registers to be set up:

           1       no. of halfwords to move
           3       first halfword of input data
           5       vertical checksum (initialize to 0)
           7       diagonal checksum (initialize to 0)
           8       Address of input sector where aligned data is to  be stored.
               (If negative, no store takes place).
           10d      alignment shift  factor  (complement: no.  bits-1  to shift
               right)


        63                           TYMNET Engine                   ENGINE.DOC
        SPECIAL INSTRUCTIONS                                   December 4, 1985


                    9.2.3  CKSUM

             CKSUM  computes  the  vertical  and  diagonal  checksums  for  the
        designated  area  (up  to  10000x  bytes  long).   The  instruction now
        refetches itself  (every 40x bytes)  to permit interrupts.   It expects
        the register specified  by R2 to contain  the current start  address of
        the  data, and  Register 0  to contain  the negative  byte  count.  The
        vertical checksum is returned in the register specified by R1,  and the
        diagonal checksum in  R1+1.  Both R0 and  the register specified  by R2
        are updated on the refetch, and thus MAY not contain the initial values
        after  execution.   This  feature  was added  in  version  S.18  of the
        microcode;  programs which expected those registers to remain unchanged
        must be modified.

             If  the negative  byte count  is  odd, or  is greater  than  0, an
        illegal instruction interrupt  occurs.  Versions of microcode  prior to
        S.18 resulted in an illegal instruction if the count was greater than 0
        or specified more than 80x (128d) bytes.

             Both  checksums  MUST  be  initialized  by  the   software  BEFORE
        executing the CKSUM instruction.




                               9.3   Bufferlet Microcode


        NAD     Instruction                       Op-code  Time        Format

        **GCI   Get Character Input                  38     ???         ???
        **WCI   Write Character Input                39     ???         ???
        **CBCT  Compute BCT                          3A     ???         ???
        **RTD1  RTD Copy 1                           3B     ???         ???
        **RTD2  RTD Copy 2                           3C     ???         ???
        **RMA1  RMAKE Copy 1                         0E     ???         ???
        **RMA2  RMAKE Copy 2                         0F     ???         ???


                         THESE INSTRUCTIONS ARE IMPLEMENTED IN
                     MICRO-CODE VERSION S-15 AND IT'S SUCCESSORS!


                                       Operation










        64                           TYMNET Engine                   ENGINE.DOC
        SPECIAL INSTRUCTIONS                                   December 4, 1985


                    9.3.1  GCI

             GCI Gets a character from  the specified buffer and returns  it in
        the  register  specified  by  R1.  Register  3  will  then  contain BB.
        Expects the register specified by R2 to contain the buffer no. times 4.
        The  instruction is  followed by  5 halfwords  of data,  containing the
        information:

        GCIINS  HC      3801                    :**GCI instruction
                HC      4*NBUF                  :size of BB storage (BE-BB)
                HC      ERROR-GCIINS            :error address (on empty
                                                : buffer, bad buffer index)
                HC      BB/4                    :address of BB storage/4
                HC      NEXT-GCIINS             :Empty Bufferlet Address
                HC      LAST-GCIINS             :Empty Buffer Address

             where:

             ERROR, NEXT, and LAST are addresses of routines to  handle errors,
        freeing of  bufferlets, and emptying  of buffers,  respectively.  These
        addresses are all specified as RELATIVE to the GCI instruction!

             The word array  BE (length =  NBUF words) FOLLOWS  IMMEDIATELY the
        word array BB (length = NBUF words).

             The address  of BB  is divided by  4, to  allow references  to any
        address within the first 256K of Address Space.





                    9.3.2  WCI

             WCI Writes a character  to the specified buffer from  the register
        specified by R1.

             Expects the  register specified  by R2 to  contain the  buffer no.
        times  4.   The  instruction  is  followed  by  5  halfwords  of  data,
        containing the information:

        WCIINS  HC      3901                    :**WCI instruction
                HC      4*NBUF                  :size of BB storage (BE-BB)
                HC      ERROR-WCIINS            :error addr. (bad buf. index)
                HC      BE/4                    :address of BE storage/4
                HC      NEXT-WCIINS             :Full Bufferlet Address
                HC      FIRST-WCIINS            :Empty Buffer Addr. (1st time)

             where:

             ERROR, NEXT, and FIRST are addresses of routines to handle errors,
        filling  of  bufferlets,  and using  of  buffers,  respectively.  These
        addresses are all specified as RELATIVE to the WCI instruction!

        65                           TYMNET Engine                   ENGINE.DOC
        SPECIAL INSTRUCTIONS                                   December 4, 1985


             The word array BE has length = NBUF words.

             The address  of BE  is divided by  4, to  allow references  to any
        address within the first 256K of Address Space.





                    9.3.3  CBCT

             CBCT Computes the exact size  (BCT) of a buffer and returns  it in
        the register specified by R1.  Expects the register specified by  R2 to
        contain  the buffer  no. times  4.  The  instruction is  followed  by 2
        halfwords of data, containing the information:

                HC      3A04                    :**CBCT instruction (r4
                                                :       has buffer no.)
                HC      BB/4                    :address of BB storage/4
                HC      4*NBUF                  :size of BB

             Requires the arrays to be defined in the exact order specified:

        BB      WS      NBUF                    :Full-word BB array
        BE      WS      NBUF                    :Full-word BE array
        BF      WS      NBUF                    :Full-word BF array - consists
        BCT     EQ      BF+2                    : of Half-word BF | BCT values
                                                : (interleaved arrays)





                    9.3.4  RTD1 and RTD2

             These  perform the  RTD  function of  copying data  from  an input
        logical record  to the  appropriate buffer.   R1 is  used as  a scratch
        register  by the  microcode,  and may,  on occasion,  contain  the last
        character.  R2 is expected to  contain the byte count of  characters to
        move.  In addition,  register 12 is assumed  to contain the  address of
        the logical record, and register 3 is BE (address of the last character
        input).

             The  3B opcode  (RTD1)  is used  for  the initial  entry  into the
        microcode,  and is  followed immediately  by the  the 3C  opcode (RTD2)
        which is used to return to the microcode.

             The RTD2 instruction is followed by 5 halfwords:






        66                           TYMNET Engine                   ENGINE.DOC
        SPECIAL INSTRUCTIONS                                   December 4, 1985



        RTD     HC      3B02                    :**RTD1
        RTDRTN  HC      3C02                    :**RTD2
                HC      NEXT-RTDRTN             :to get next bufferlet
                                                :  (continue at RTDRTN)
                HC      CHAR0-RTDRTN            :to handle char 0
                HC      CHAR1-RTDRTN            :to handle char 1
                HC      CHAR2-RTDRTN            :to handle char 2
                HC      CHAR3-RTDRTN            :to handle char 3

             Each of these character handlers should return to RTD  to continue
        execution.  Each  address is a  displacement from the  RTD2 instruction
        itself.  When  any of the  special character handlers  (CHAR0-CHAR3) is
        called, the character  has already been stored  but the byte  count has
        not been decremented or tested.  These operations should be  done PRIOR
        to resuming control at RTD.  (Also, store last character if count = 0.)

             It is up to the software to handle character pairs.





                    9.3.5  RMA1 and RMA2

             These perform the  RMAKE function of  copying data from  an output
        buffer to a logical  record.  R1 is used  as a scratch register  by the
        microcode,  and  should  be initialized  to  the  current  half-word of
        packet-buffer  (upper half),  and  the current  half-word  of bufferlet
        (lower half).  R2 is expected  to contain the byte count  of characters
        to move.  In addition, register 12 is assumed to contain the address of
        the logical record-1, and register  3 is BB (address of  next character
        to be output).

             The  0E opcode  (RMA1)  is used  for  the initial  entry  into the
        microcode,  and is  followed immediately  by the  the 0F  opcode (RMA2)
        which is used to return to the microcode.

             The RMA2 instruction is followed by 5 halfwords:

        RMAKE   HC      0E02                    :**RMA1
        RMRTN   HC      0F02                    :**RMA2
                HC      NEXT-RMRTN              :to return a bufferlet,
                                                :  get next one.
                                                :  (continue at RMRTN)
                HC      CHAR0-RMRTN             :to handle char 0
                HC      CHAR1-RMRTN             :to handle char 1
                HC      CHAR2-RMRTN             :to handle char 2
                HC      CHAR3-RMRTN             :to handle char 3

             Each  of  these  character  handlers  should  return  to  RMAKE to
        continue  execution.   Each address  is  a displacement  from  the RMA2
        instruction itself.

        67                           TYMNET Engine                   ENGINE.DOC
        SPECIAL INSTRUCTIONS                                   December 4, 1985


                    9.3.6  Buffer and Bufferlet Structure

             It is assumed that the following data structures have been set up:

                                  BUFFER DESCRIPTORS

        BB      WS      NBUF                    :pointers to "Buffer Begin"
        BE      WS      NBUF                    :pointers to "Buffer End"

             Each bufferlet has the form:

                --------.-------.-------.--------
                |       | char storage  |       |
                |-------.-------.-------.-------|
                |       |       |       |       |
                |-------.-------.-------.-------|
                |       |       |       |       |
                |-------.-------.-------.-------|
                |       |       | next buflet # |
                ---------------------------------

             The bufferlet  storage is required  to begin at  a multiple  of 16
        bytes;  The first  halfword in this space  is then (normally)  the free
        list (list of unused  bufferlets) header.  Thus the first  bufferlet is
        numbered "1",  starts at FREE+2,  and its pointer  is at  FREE+10.  The
        next bufferlet is numbered "2",  starts at FREE+12, and its  pointer is
        at FREE+20...etc.

             In use,  BB (and BE)  are indexed via  the buffer  index (4*buffer
        number),  and contain  a pointer  to the  next byte  to be  emptied (or
        filled).  If that  buffer is empty, the  pointers are also  zeroed out.
        The exhaustion of a bufferlet is recognized by the low-order 4  bits of
        the  character  address  going to  zero,  causing  full/empty bufferlet
        traps.  In all cases, the "next buflet no" field contains the NUMBER of
        the next bufferlet associated with this character stream.



















        68                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985






                           10 -  MICROPROGRAMMING THE ENGINE


             This  chapter  describes several  facets  of  microprogramming the
        ENGINE.






                               10.1  THE MICRO-ASSEMBLER


             The   microcode   assembler   refered   to   may   be   found   in
        (LTYMES:10)@MASS.

             Input consists  of successive  lines of  micro-instruction source.
        There are 4 elements which may appear in column 1:

           1.  ":"...designates a comment line;
           2.  "#"...followed by a hexadecimal number causes re-origin  to that
               address;
           3.  " "...(blank) line of code;
           4.  Alphanumeric text...a symbol name to be assigned to  the current
               micro-location.

             The  source  input consists  of  9 different  fields,  ordered and
        seperated by  commas.  These fields  correspond to  specific functions,
        although they may interact.

             The fields may  contain "tokens":  hexadecimal  constants, defined
        symbols, or "wired-in" symbols.  Multiple symbols may be used  within a
        field;  they  may be  "or"-ed together  by using  the symbol  "+".  The
        assembler will generate a diagnostic if an attempt is made to set a bit
        twice (eg, 1+1).

             Null fields (",,") are allowed, and (generally) force  zero value.
        Fields terminate with the first occurance of blank (" "), tab,  or C/R.
        Anything else is comments.

             Trailing null fields may be left off...thus:
                                        1,,2,,3

             is equivalent to:
                                   1,0,2,0,3,0,0,0,0

             The assembler generates output listings;  These contain the source


        69                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


        to the right side, seperated from the object code listing (on the left)
        by a ":".  The left-most  field is the microcode location.   The object
        code is also broken up into 9 corresponding fields.

                Sample (actual Engine microcode):

                                      ::Microcode starts here on power up
        000  0005 0 25 0 4 D 10 800 0 :      5,,B,,CNST,IOBUS,RESMAC addr. d5
        001  0080 0 00 0 4 E 20 800 0 :      ADRS,,,,CNST,IOCNTL,RESPAR r/Par.
        002  FF00 0 40 0 4 4 40 800 0 :      0FF00,,,,CNST,LDMAC+CNCNTL,RESPDN

             The "wired in" symbols  may be applied to specific  fields.  These
        are:

                                micro-assembler fields

                BRANCH  ALU     XWR WR  B       B               ALU MUX
        CONST   COND    CONT    CONT    SOURCE  DEST    MISC    CONT    PC MC
        ******  ******  ******  ******  ******  ******  ******  ******  ******
        ADRS    TRUE    RXADD   XWR     MDR     LDMAC   RESMAC  INDEX   INCPC
        DA      XWR31   MAP     WR      PSW     CNCNTL  RESPAR  L00     LOADPC
        DR      WR31    INTRPT  RLWR    CONSOL  PSW     RSCATN  XWR0    INCMC
        SR      CATN    AEXRB   RRWR    CNST    IOCNTL  RSEPDN  WR0     LOADMC
        CMD     SNGL    B       SLWR    IOBUS   MDR     FLAGS   L02
        TACK0   YDCARY  AB      SRWR    YS2     IOBUS   INCYD   BUS0
        TACK1   PSW7    AORB    SRLONG  YS      CONSOL  DECYD   SIGN0
        TACK2   G       A       ASRWR   ALU     YD      MACREQ  SL00
        SRG     WR0     APLUSB  RLLONG  MDRA            MAPSEL  L22
        SHL     CARRY   AMIN1   LRWR                    REGWRT  XWR2
        SHR     SYNC    APLUS1  RLRWR                   MREG    WR2
        LB      MC11    AMINB   XWRWR                   YS      L20
        LA      PSW6            SLLWR                   YD      L23
                PSW3            SRLWR                   SX      BUS2
                PSW4            LLWR                            SL22
                                                                LATCH
                                                                WR
                                                                PC
                                                                MASK
                                                                L33
                                                                XWR3
                                                                WR3
                                                                L32
                                                                L31
                                                                BUS3
                                                                SL33









        70                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


                10.2  The Microprogrammer's Guide to the Tymnet Engine

                                     D. E. Grimes
                            Last Revision:  8 February 1979





                    10.2.1  Introduction

             This   document   describes  the   objects   manipulated   by  the
        microprogram and their interaction.  The ALU repertoire and  the format
        of the microinstructions are described in detail in other documents.

             Normally,  a microinstruction  is fetched  and executed  every 125
        ns., although the  microprogram can halt  itself until a  (main) memory
        operation  is  complete.  The  microinstruction  word is  64  bits wide
        (numbered from 0 on  the left to 63  on the right), and  the addressing
        structure accommodates  up to  4K words.   The word  is divided  into a
        number of fields, each of which controls a separate operation;   thus a
        single  microinstruction  can  cause the  simultaneous  execution  of a
        number of  operations.  Some  fields cause  their operation  during the
        same microcycle in which  the microinstruction is fetched;   others are
        latched  and cause  their operation  during the  next  microcycle.  The
        former will be  referred to as  "immediate", the latter  as "deferred".
        Mnemonics for  field contents  that are built  into the  assembler will
        appear within square brackets in capitals, as [LDMAC, immediate].





                    10.2.2  The ALU

             The Engine  is built around  a 32-bit ALU  (Arithmetic-Logic Unit)
        based on the 74S181 chip, whose repertoire is described elsewhere.  The
        ALU function is selected by the following microinstruction  fields (all
        are deferred):
            bit 22      mode control
            bit 23      Carry In complement
            bits 24-27  S0-S3, in that order.

             Assembler mnemonics are  defined for the commonly  used operations
        (e.g., [APLUSB]);  alternatively, a hexadecimal constant can be used.

             The A and B  inputs to the ALU  come from the 4-1  multiplexer and
        the 8-1 multiplexer, respectively.   The ALU output can be  directed to
        any or all of the following:  XWR, WR, PC, MC, or B-bus.





        71                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


                    10.2.3  Main Memory

             The  microprogram  accesses  main  memory  through  the  following
        registers:



        10.2.3.1  MDRs (Memory Data Registers)

             There are  two independent 16-bit  Memory Data Registers,  one for
        fetches and  one for  stores.  Both  are connected  to the  B-bus.  The
        fetch MDR  can be  selected as  the source,  and the  store MDR  as the
        destination, of data transfers on that bus.



        10.2.3.2  IR (Instruction Register)

             If  a particular  bit  (the one  corresponding  to bit  12  of the
        microinstruction  word) in  the MAC  control register  is set,  the MAC
        loads the fetched halfword into the 16-bit IR instead of the fetch MDR.
        The IR makes the opcode and mask fields available to the  mapping proms
        and the Yd and Ys (destination and source register fields) available to
        the B-bus.



        10.2.3.3  MC (Memory Address Register)

             This 20-bit register contains the main memory address at which the
        read or write is to take place.   Bit 19 is forced to zero, so  the MDR
        always contains  bytes numbered 2*n  and 2*n+1.  The  MC can  be loaded
        from the ALU output (controlled by bit 63 of the  microinstruction word
        [LOADMC, immediate]) or incremented by two (bit 62 [INCMC, immediate]).



        10.2.3.4  MAC control register

             This  5-bit  register  selects  the  direction,   relocation,  and
        validity checking  for the transfer.   It is loaded  under microprogram
        control  (bit  36  [LDMAC,  immediate])  and  retains  its  value until
        reloaded.  Typical settings are:
                X'19    relocated instruction fetch, load IR
                        {used to fetch first halfword of instruction}
                X'11    relocated instruction fetch
                        {used to fetch subsequent halfwords of instruction}
                X'10    relocated data fetch
                X'14    relocated data store

             The actual data transfer is triggered by a particular code in bits
        40-43 of  the microinstruction  word [MACREQ,  occurs during  middle of


        72                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


        cycle].  Note that MC must be stable for 1.5 cycles and MAC control for
        0.5  cycles  before  starting the  transfer.   The  pattern  for memory
        transfers is therefore:
            {load MDR if this is a write}
            load MC
            load MAC control register and start transfer.





                    10.2.4  PC (Program Counter)

             This 20-bit register can be loaded from the ALU output (controlled
        by microinstruction bit 61  [LOADPC, immediate]) or incremented  by two
        (bit 60 [INCPC, immediate]).  The PC can, in turn, be gated through the
        4-1 multiplexer to  the A input  of the ALU.  Note  that the PC  has no
        direct connection to main memory;  to address the next  instruction the
        contents of the PC must be copied through the ALU to the MC.





                    10.2.5  Register Stack

             The  register stack  contains the  16 sets  of  16 general-purpose
        registers (32 bits wide).  The set  in use is selected by bits  8-11 of
        the  PSW; the  particular register  within that  set is  selected under
        control of bits 46-47  of the microinstruction word.  The  direction of
        transfer is selected  by bit 45  of the microinstruction  word [REGWRT,
        deferred]:  if bit 45 is set, WR is copied into the  selected register;
        if  bit 45  is reset,  the selected  register is  copied into  a 32-bit
        register called the  Latch.  If register zero  from any stack  is being
        read, and bit  48 [INDEX, deferred]  of the microinstruction  is reset,
        Latch inputs  to the 8-1  multiplexer are replaced  by zero  during the
        next  cycle;   this prevents  the  use  of register  zero  as  an index
        register.  The contents of the  Latch, in turn, can be directed  to the
        4-1 multiplexer or to the 8-1 multiplexer in several  variations.  Note
        that a register  read or write occurs  every microcycle;  if  the Latch
        should contain the contents of some register in cycle n,  therefore, it
        must be loaded in cycle n-1 (and not earlier).












        73                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


                    10.2.6  Working Register/Ext. Working Register

             These 32-bit working registers are controlled by bits 28-31 of the
        microinstruction  word.  Either  or  both can  be loaded  from  the ALU
        output.  WR can be rotated  or shifted, either alone or  in combination
        with XWR.   Bits shifted out  of WR pass  through the Carry  flag.  The
        contents  of  WR  can  be  directed  to  the  register  stack,  the 4-1
        multiplexer,  or  the  8-1  multiplexer  in  several  variations.   The
        contents  of XWR  can be  directed to  the 8-1  multiplexer  in several
        variations.





                    10.2.7  4-1 Multiplexer

             The 4-1 multiplexer selects the  A input to the ALU  under control
        of bits 52 and 56  of the microinstruction word (deferred).   Inputs to
        the multiplexer are PC, WR,  Latch, and a Mask which is  the complement
        of 2^(15-n),  where n is  the rightmost  4 bits of  the Latch  (this is
        useful in implementing the bit manipulation instructions).





                    10.2.8  8-1 Multiplexer

             The 8-1  multiplexer selects  the B  input to  the ALU.   The left
        halfword, the third  byte, and the  fourth byte of  the B input  can be
        selected independently under control of bits 49-51, 53-55, and 57-59 of
        the microinstruction word, respectively (all are deferred).   Inputs to
        the multiplexer are Latch, XWR, WR, B-bus, sign extension of B-bus, and
        Latch right-shifted three places (the latter is useful  in implementing
        the bit manipulation instructions).





                    10.2.9  B-bus

             This 16-bit bus is used for a variety of data transfers:










        74                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


                    10.2.10  Source

             The B-bus source is selected by bits 32-35 of the microinstruction
        word (deferred).  The source may be null, MDR, the PSW, the  console, a
        16-bit constant contained in the microinstruction, the I/O bus,  the YS
        field from the  IR, twice the YS  field (useful in  imple-menting short
        jumps), the ALU, or the  MDR with bit 1 propagated leftward  (useful in
        effective address calculation).  Note that when the B-bus is  to affect
        the  left  half  of  the  ALU, the  source  must  be  specified  in two
        successive microcycles to stabilize the bus.





                    10.2.11  Destination

             The  content  of  the  B-bus  is  always  available  to   the  8-1
        multiplexer.   It may  also be  directed to  another  destination under
        control of  bits 37-39  of the  microinstruction word  (deferred).  The
        destination  may be  null, the  MDR, the  PSW, the  console  or console
        control, the I/O bus or I/O control, or the YD field of the IR.





                    10.2.12  Mapping Facility

             The Engine can decode  opcodes and instruction format  fields into
        microprogram addresses.  The decoding is requested by setting  bits 16-
        19 of the microinstruction word (branch control, immediate) to 1 [TRUE]
        to cause a branch, and  bits 20-21 (branch select, immediate)  to [MAP]
        or [RXADD] according to the type of decoding required:



        10.2.12.1  Opcode Decode [MAP]

             The 8-bit opcode field of IR selects a 16-bit word from  a mapping
        PROM which determines the branch address as follows:
                address bits 0-8, 10, 11 <- prom bits 0-8, 10, 11
                address bit 9 depends on prom bits 14 and 15 and result of test
                (this is the mechanism for implementing conditional jumps).

             If bit 44 [MAPSEL, deferred] of the previous  microinstruction was
        set, this is the first decode; otherwise, the second.







        75                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


        10.2.12.2  Instruction Format Decode [RXADD]

             The branch address is computed as follows:
                address bits 0-8:  same as previous microinstruction
                address bit 9:  always 1
                address bits 10-11:  bits 0-1 of MDR (format bits).

             The effect is as follows:
                loc X'nn2:      {microinstruction requesting decode}
                loc X'nn4:      {RX1 format causes a branch to here}
                loc X'nn5:      {RX3 format causes a branch to here}
                loc X'nn6:      {RX2 format causes a branch to here . . .}
                loc X'nn7:      {. . . or here}






                   10.3  Microcode Description for TYMNET-II ENGINE


                                      LaRoy Tymes
                                 last update: 12/10/78

             Bits are numbered left to right.  An "*" means that the  bit(s) is
        used as soon  as it is fetched  from the prom [immediate].   Other bits
        are latched and used on the next microstep.





                    10.3.1  CONST field


           0*      Stops clock if memory operation is in progress, until memory
               read cycle is done.

           0-15    Constant source for the B bus.

           3       Sometimes used as parity bit (parity odd).

           4-15*   microcode branch address

           11-15*  source for MAC control register

           12-15   Register stack select if microcode specifies register.






        76                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


                    10.3.2  BRANCH COND field


           16-19*   Test  select  for  branching  control.   Determines whether
               counter counts or loads:

           0000 always false
           0001 always true (TRUE)
           0010 XWR31 (XWR31)
           0011 WR31 (WR31)
           0100 console attention (CATN)
           0101 single (set from console) (SNGL)
           0110 YD carry:  false if YD=F and YD+1 specified, else true (YDCARY)
           0111 PSW7 (PSW7)
           1000 G flag:  means WR has positive number in it (G)
           1001 WR0:  sign bit of WR (WR0)
           1010 carry:  normally set from ALU, sometimes from WR (CARRY)
           1011 sync from backplane, made true by acknowledging device (SYNC)
           1100 MC bit 11 (bit 19 always 0, MC increments by 2) (MC11)
           1101 PSW6 (PSW6)
           1110 PSW3 (PSW3)
           1111 PSW4 (PSW4)





                    10.3.3  ALU CONT field


           20-21*  branch select

           00 address obtained from 4-15 of microcode instruction
           01 address decode for RX1, RX2, and RX3 (RXADD)
           10 map from opcode decode (MAP)
           11 interrupt vector (INTRPT)

             Note:  if map select  (bit 44) of previous microinstruction  is 1,
        the GS term, which is 1 if an interrupt is pending, will be substituted
        for bit 21.  This is for selecting interrupt vector in place  of opcode
        decode map.

                interrupt address:
           000000100000 not used
           000001100000 early power down (highest priority)
           000010100000 console attention
           000011100000 core memory parity error
           000100100000 MAC interrupt
           000101100000 ATN0 (highest priority IO, enabled by PSW1)
           000110100000 ATN1 (enabled by PSW1 and PSW8)
           000111100000 ATN2 (enabled by PSW1, PSW8, and PSW9; can interrupt
                              while CPU is in Register Set 0C, 0D, 0E, or 0F)


        77                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


        10.3.3.1  Opcode decode

             Address comes from  mapping proms which are  indexed by 8  bits of
        opcode in the instruction register and map select.  The map select line
        is the  most significant  bit of  the address  into the  mapping proms.
        There are 2 mapping  proms, 0 and 1.   Prom 0 generates the  leftmost 8
        bits of the microcode address in  the obvious way.  Bit 0 of prom  1 is
        bit 8 of the microcode address.  Bit  2 goes to bit 10.  Bit 3  goes to
        bit 11.  If bits 6 and 7 are both 0, bit 9 of the microcode  address is
        1.  If they are both 1, bit 9 is 0.  If bit 6 is 0 and 7 is 1, bit 9 is
        the  complement of  the  branch condition,  else  bit 9  is  the branch
        condition.  The remaining bits are not used.



        10.3.3.2  Address decode

             Bits 0-8 are the same as the previous microinstruction.

             Bit 9 is always a 1.

             Bits 10 and 11 are taken  from bits 0 and 1 of the  MDR (actually,
        they come straight from the MAC to avoid propogation delay  through the
        MDR).


           21      Alternate parity bit (see bit 3).

           22      MDCNTL for 181 ALU.

           23      Carry in complement for 181 ALU.

           24-27   ALS0-ALS3 for 181 ALU.





                    10.3.4  XWR XR CONT field


           28-31   WR and XWR control.

           0000 null
           0001 load XWR (XWR)
           0010 load WR (WR)
           0011 rotate WR left (RLWR)
           0100 rotate WR right (RRWR)
           0101 shift WR left (SLWR)
           0110 shift WR right (SRWR)
           0111 shift XWR-WR right (SRLONG)
           1000 arithmetic shift WR right (WR0 to WR0) (ASRWR)
           1001 rotate XWR-WR left (RLLONG)

        78                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


           1010 load right half of WR (LRWR)
           1011 rotate left right half of WR (RLRWR)
           1100 load XWR and WR (XWRWR)
           1101 shift left left half of WR (SLLWR)
           1110 shift right left half of WR (SRLWR)
           1111 load left half of WR (LLWR)

           Note: the carry  flag is loaded  from WR0 when  the left half  of WR
               moves left, and from WR31 when the left half of WR moves right.





                    10.3.5  B SOURCE field


           32-35   B bus source:

           0000 null
           0001 MDR
           0010 PSW
           0011 console
           0100 constant:  bits 0-15 of microinstruction
           0101 IO bus
           0110 YS*2
           0111 YS
           1000 ALU
           1001 MDRA
           1010 through 1111 null

           Note: when using any  B bus source and  when this data is  to affect
               the left half  of the ALU,  the same B  bus source must  also be
               specified on the previous microstep in order to stabilize  the B
               bus early in the microstep.





                    10.3.6  B DEST field


           36*      Load  MAC control  from  11-15: 11  low  forces nonrelocate
               (overrides PSW5), 12  causes instruction register to  be loaded,
               13 is high for write, low for read, 14 is test and set, 15 tells
               MAC that this is an instruction fetch (used for  validity test).
               Allow at least one cycle after changing bit 12 (and PSW5) before
               making MAC request.

           37-39   B bus destination (note: the 8-1 MUX is independent  of this
               field):


        79                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


           000 null
           001 MDR
           010 PSW
           011 console
           100 console control
           101 IO bus
           110 IO control
           111 YD counter in instruction register

           Notes:  Two consecutive loads of IO control are not allowed.


           YD loading must be specified once cycle earlier than the others.


           For IO control, bit 8 is ADRS, 9 DA, 10 DR, 11 SR, 12 CMD, 13 TACK0,
               14 TACK1, 15 TACK2.


           For console control, 1 to SRG, 3 to SHL, 4 to SHR, 6 to LB, and 7 to
               LA.


           When using SRG, SHL, or  SHR, allow two extra cycles for  console to
               settle before using console as B bus source.





                    10.3.7  MISC field


           40-43   Miscellaneous control:

           0000 null
           0001 reset MAC interrupt
           0010 reset memory parity error
           0011 reset console attention
           0100 reset early power down
           0101 store flags into PSW
             carry from carry flag, G from WR, L from WR0, overflow is 0
           0110 increment YD (at end of cycle)
           0111 decrement YD
           1000 memory request (made during middle of cycle)
           1001 through 1111 not used

           Note: before making memory request, mc must be stable 1.5 cycles and
               MAC control for 0.5 cycles.

           44      Map select:  Selects first opcode decode  mapping, completes
               loading of instruction  register, and controls selection  of bit
               21.

        80                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


           45      Register write enable.

           46-47   Register select for stack:

           00 YS
           01 YD
           10 SX
           11 microcode 12-15 (MREG)





                    10.3.8  ALU MUX CONT field


           48      Register zero select override: Active low, normally  high if
               register xxxx0000 is read from  stack on one cycle, causes  0 to
               be substituted for bits 51,  55, and 59 on next cycle.   Used to
               prevent user register 0 being used as an index register.

           49-51   Left half of 8-1 MUX for B input to ALU:

           000 0
           001 left half of latch (L00)
           010 XWR (XWR0)
           011 WR (WR0)
           100 right half of latch (L02)
           101 B bus (BUS0)
           110 sign extension of B bus (SIGN0)
           111 3 zeroes followed by 0-12 of latch (SL00)

           52      First bit for 4-1 MUX (see bit 56).

           53-55   Bits 16-23 of 8-1 MUX:

           000 0
           001 16-23 of latch (L22)
           010 XWR (XWR2)
           011 WR (WR2)
           100 0-7 of latch (L23)
           110 B bus (BUS2)
           111 13-20 of latch (SL22)

           56      Second bit of 4-1 MUX for a input to 181 ALU.

           00 complement of mask determined by bits 28-31 of latch (MASK)
           01 latch (LATCH)
           10 WR (WR)
           11 PC (PC)

           57-59   Bits 24-31 of 8-1 MUX:


        81                           TYMNET Engine                   ENGINE.DOC
        MICROPROGRAMMING THE ENGINE                            December 4, 1985


           000 0
           001 24-31 of latch (L33)
           010 XWR (XWR3)
           011 WR (WR3)
           100 16-23 of latch (L32)
           101 8-15 of latch (L31)
           110 B bus (BUS3)
           111 21-28 of latch (SL33)





                    10.3.9  PC MC field


           60*     Increment PC (by 2) (INCPC).

           61*     Load PC [LOADPC].

           62*     Increment MC (by 2) [INCMC].

           63*     Load MC [LOADMC].































        82                           TYMNET Engine                   ENGINE.DOC
                                                               December 4, 1985



























                      *   ****  ****  ***** *   * ****  ***** *   *
                     * *  *   * *   * *     **  * *   *   *    * * 
                    ***** ****  ****  ****  * * * *   *   *     *  
                    *   * *     *     *     *  ** *   *   *    * * 
                    *   * *     *     ***** *   * ****  ***** *   *
























        83                           TYMNET Engine                   ENGINE.DOC
        Buffers and Bufferlets                                 December 4, 1985






                         APPENDIX I.   Buffers and Bufferlets



             Everything you always wanted to know about buffers and bufferlets,
        as related to the microcoded bufferlet instructions.






                                I-1  Buffer Descriptors


             This  section  concerns buffer  Descriptor  layout  (NOTE:  Buffer
        index = buffer number * 4):

        Label     Fullword Storage

                +----+----+----+----+
        BB      |   buffer #0       |           Buffer start address points
                |----+----+----+----|           to first character in buffer
                |   buffer #1       |           [empty pointer].
                |----+----+----+----|
                |   buffer #NBUF-1  |
                +----+----+----+----+

                +----+----+----+----+
        BE =    |   buffer #0       |           Buffer end address points
         BB +   |----+----+----+----|           to last character in buffer
         4*NBUF |   buffer #1       |           [fill pointer].
                |----+----+----+----|
                |   buffer #NBUF-1  |
                +----+----+----+----+

                +----+----+----+----+
        BF =    |  BF #0  | BCT #0  |           Buffer flag points to corres-
         BE +   |----+----|----+----|           ponding attention bit in FLAGS
         4*NBUF |  BF #1  | BCT #1  |           array [halfword].
                |----+----|----+----|
        BCT =   |  BF  #NBUF-1 BCT  |           Buffer count is the number of
         BF +   +----+----+----+----+           chars currently in the buffer
         2                                      [halfword].






        84                           TYMNET Engine                   ENGINE.DOC
        Buffers and Bufferlets                                 December 4, 1985


                                 I-2  FLAGS Bit-array


             The FLAGS array is user defined:

                +----+----+----+----+
        FLAGS   |bit array of length|           A flag bit indicates data
                +----+----+----+----+           present in the corresponding
                | corresponding to  |           buffer.
                +----+----+----+----+
                | max buffer flag   |
                +----+----+----+----+
                | value             |
                +----+----+----+----+






                                    I-3  Bufferlets


             The following section describes bufferlets:

        Address Halfword Storage   (16 bytes per bufferlet * NBFLET)

        BUFERS  +--------+--------+
        xxxx0   | Free List head  |     List heads and links are bufferlet
                +--------+--------+ --- number
        xxxx2   | char 1 | char 2 |  :  Bufferlet #'s range from 1 to NBFLET
                |--------|--------|  :
        xxxx4   | char 3 | char 4 |  :  Address of next 
                |--------|--------|  :  bufferlet LINK  =  BUFERS + (LINK * 16)
        xxxx6   | char 5 | char 6 |  :  
                |--------|--------|  :  Hex LINK addresses always end with a 0
        xxxx8   | char 7 | char 8 |  :
                |--------|--------|  : {bufferlet #1}
        xxxxA   | char 9 | char 10|  :
                |--------|--------|  :
        xxxxC   | char 11| char 12|  :
                |--------|--------|  :
        xxxxE   | char 13| char 14|  :
                |--------+--------|  :
        xxxx0   |      LINK       |  :
                +--------+--------+ ---
        xxxx2   | char 1 | char 2 |  :
                |--------|--------|  :
                |       etc       |  : {bufferlet #2}





        85                           TYMNET Engine                   ENGINE.DOC
        Buffers and Bufferlets                                 December 4, 1985


                    I-3.1  Bufferlet Free-list

             Those bufferlets not in use are linked together in a "Free-list":
                                         +------+      +------+      +------+
                                         | data |      | data |      | data |
                +--------+--------+      +------+      +------+      +------+
        BUFERS  | Free list head  | ---> | LINK | ---> | LINK | ---> |LINK=0| 
                +--------+--------+  A   +------+      +------+      +------+
                                     |  bufferlet 1  bufferlet n-1  bufferlet n
                                     |
                                     |
                        Bufferlets are removed and replaced
                        at the top of the free list.









































        86                           TYMNET Engine                   ENGINE.DOC
        ASYNC Implementation                                   December 4, 1985






                          APPENDIX II.   ASYNC Implementation



             This  appendix   describes  the  data-structures   and  parameters
        associated with ASYNC in the ENGINE.






                                 II-1  Data Structures


             There are three major  data (variable) areas used for  ASYNC:  The
        ASYNC RING, the ASYNC CONTROL, and the TIMEOUT storage.





                    II-1.1  ASYNC Ring

             The ASYNC  RING consists of  a number of  FRAMES, the  number used
        being sufficient  to contain  both input and  output information  for a
        character at  the slowest character-rate,  plus some  "guard-frames" to
        prevent data-overrun.



        II-1.1.1  The ASYNC Frame

             A frame (F) is in  turn partitioned into six equal parts,  each of
        which  corresponds to  one of  the "70"-series  interrupt clock-phases.
        Each part in turn contains  one half-word for each group of  (16) ASYNC
        ports, for a total of 12 bytes per frame, per ASYNC group.

             The areas are numbered  0 to 5, corresponding to  the clock-phases
        and interrupts x70 to x75.










        87                           TYMNET Engine                   ENGINE.DOC
        ASYNC Implementation                                   December 4, 1985



                           Time relationships of ASYNC Ring

                                       +
                              +++++++++++++++++++
                          ++++                   ++++
                       ++++                         ++++
                     +++                               +++
                   +++                                   +++
                 ++                                         ++
                ++                                           ++
               ++                                             ++
              ++   data area for                               ++
             +   subsequent output                               +
            ++                                                   **
           ++                                                     **
           +                                                       *
          ++                                                       **
          +                                                         *
          +                                                         *
          +                                                         *
          =  <---RGX                   X                            *
          -                                                         *
          -                                                         *
          -                                                         *
          --                                                       **
           -                                                       *
           --                                                     **
            --                                                   **
             -                                                   *
              --  data already                                 **
               --    input                                    **
                --                                           **
                 --                                         --  <---SBX
                   ---                                   ---
                     ---         Direction             ---
                       ----       ======>           ----
                          ----                   ----
                              -------------------
                                       -

             Where:

           +  Successive frames  which will  pass RGX in  the future,  and into
               which  the transmitter  is currently  capable of  placing output
               characters.
           -  Successive  frames which  have already  passed RGX  (but  not yet
               passed SBX).
           *  Frames in limbo...already examined  at SBX, but not yet  in range
               of the transmitter.
           X  The "center" of rotation of the ASYNC Ring's circular buffer.



        88                           TYMNET Engine                   ENGINE.DOC
        ASYNC Implementation                                   December 4, 1985


             The  operation  is  as  follows:   The  ring  "rotates"  (counter-
        clockwise),  being "ratcheted"  by one  frame for  each full  clock (6-
        phase) cycle, passing successive  frames "=" under the  RGX "read/write
        head".  As each frame passes RGX, the existing data ("+") is  output to
        that port-group, and replaced by  new data ("-") input from  that port-
        group.

             At the occurance of  an interrupt, the appropriate  operations are
        performed for the corresponding frame area:

           Phase   Activity:
             0  Output to group, then input from group
             1  Input from group
             2  Input from group
             3  Output to group, then input from group
             4  Input from group
             5  Input from group, update TAM (i) then advance to next frame and
               "tick" the clock

             Data has  different representations in  the input ("-",  Past) and
        the output ("+", Future) areas:  On the input side, each frame contains
        six successive  samples of  input;  On output,  however, the  only data
        inserted into the ring  marks the data "transitions" (0-1,  1-0).  This
        permits the placing of an output character with no more than ten (worst
        case) memory references.   An image of the  output data is  retained by
        the micro-code, and Exclusive-Or'ed  with the data from  memory.  Also,
        output  occurs ONLY  during  the 0-th  and  3-rd phases  of  the clock,
        thereby permitting  operation at  a baud--rate which  is 2x  the clock-
        rate.

               NOTE:   If  for  some  reason  the  ASYNC  interrupts are
                       disabled for too  long, a phase-0 or  3 interrupt
                       may be missed.  If there was a transition in that
                       frame,  all subsequent  output for  the afflicted
                       ports will be COMPLEMENTED!  Also, if  phase-5 is
                       missed,  the  entire  frame  will  be re-emitted;
                       however,  since  the  frame  now  contains  input
                       (rather  than  output)  data,  this  will  causes
                       "glitches" on each port, and any port which input
                       a  state-transition between  phase-0 and  -3 will
                       also be complemented!

             SBOD  is executed  periodically by  the code.   It performs  up to
        three seperate functions (in order):

           1.  Examine the  frame currently under  SBX for input  detected.  If


        (i) TAM -- Transmitter_Active_Mask:  a bit-array which  specifies which
        ports are  enabled for  output.  When  sufficient characters  have been
        placed in the  ASYNC ring (up to  four characters at the  highest baud-
        rate), TAM is turned off;   after a period of time dependent  upon that
        ports baud-rate and character-width, TAM is turned on again.

        89                           TYMNET Engine                   ENGINE.DOC
        ASYNC Implementation                                   December 4, 1985


               any  is found,  that port-number  is returned  with  the "input"
               return.
           2.  Else  advance SBX  (clockwise) until  it is  within  one (lowest
               baud-rate) character-time  worth of samples  from RGX.   If not,
               repeat  1.
           3.  Once SBX is caught up to the offset from RGX, then  determine if
               there is any output pending for ports with TAM enabled.   If so,
               one such port number  is returned with the "output"  return.  If
               not, SBOD exits with the "done" return.






                                 II-2  Control Storage


             The control storage consists of exactly 256d words of storage.  It
        is used to control SBA (i).

             The implementation is  as a pair  of linear, half-word  arrays, of
        256d half-words each.

             The first array is a control-ring where each hw  entry corresponds
        to  F/3, or  two ASYNC-phase  interrupts.  The  current index  into the
        control ring is found in R4 of register-set 1, and is incremented  by 2
        each time SBX is incremented by F/3.  It is used to link together lists
        of ports  which need  SBA turned back  on (at  that time).   Each entry
        contains a pointer into the second array.

               NOTE:   The  size  (256 entries)  and  usage  (3 entries/
                       frame) of this array constrains the SLOWEST input
                       baud-rate  to be  less  than 512  samples,  or 85
                       frames.   This  length  includes  the start-baud,
                       data-bauds,   and   the   stop-baud.    For  3600
                       interupts/second, the slowest baud-rate character
                       may  not be  longer than  142 ms  duration,  or a
                       minimum  of  7  characters/second.   This  scales
                       appropriately  for  other  than  3600 interrupts/
                       second.

             The second array is a 256d hw array indexed by port  number.  Each
        entry contains the number of the next port in the list.  The end of the
        list is indicated by the MSB (sign, 8000x) bit of the entry being set.



        (i) SBA -- Start_Baud_Active:  a bit-array which specifies  which ports
        are  enabled  for input.   When  an input  character  is  detected, the
        corresponding  bit  of SBA  is  turned  off;  after  a  period  of time
        dependent upon that ports baud-rate and character-width, SBA  is turned
        on again.

        90                           TYMNET Engine                   ENGINE.DOC
        ASYNC Implementation                                   December 4, 1985


                                 II-3  Timeout Storage


             The linear half-word array  LCTIME is indexed by port  number, and
        is used to  retain the "time"  of the last  output-character completion
        for the particular port.  The  actual contents of this halfword  is the
        offset, from the  beginning of the ring,  until the time that  the next
        character can  be placed into  the ring (which  occurs at  intervals of
        F5).

             Whenever XMIT is executed to place a character into the  ring, the
        current value  of LCTIME  for this  port is  compared with  the current
        value of RGX5 (the current value of RGX, forced to the next multiple of
        5 frames),  as well as  with RGX5+F5, and  with RGX5+F5+F5.  If  any of
        these matches occur, the character is placed beginning at the specified
        value of LCTIME, else at  RGX5.  LCTIME is then updated to  reflect the
        new time-of-character-end, and if  this time exceeds RGX5 by  more than
        3*F5, the TAM bit  for that port is turned  off, and a bit  is inserted
        into the  appropriate phase 5  cell of the  preceeding frame  to insure
        that TAM will be turned back on when RGX passes that frame.

               NOTE:  Because  LCTIME is  an array  of  half-words, this
                       constrains  the ASYNC-ring  to be  less  than 64K
                       bytes long.






                                 II-4  Initialization


             The ASYNC  microcode performs a  number of  specialized operations
        associated with ASYNC input and output.  It also causes the "70"-series
        interrupts to be serviced automatically, without any memory references,
        EVEN IF NO ASYNC IS IMPLEMENTED!  As a result, it is critical  that the
        initialization be performed correctly, to prevent run-away.

             The microcode assumes the use of register sets 1, 2, 3, 4, and 0D.
        These registers should be initialized to the following usage:













        91                           TYMNET Engine                   ENGINE.DOC
        ASYNC Implementation                                   December 4, 1985







                    II-4.1  Initialization for register set 1

                                        :R0     PSW Save
                                        :R1     Working
                                        :R2     Port-number
                                        :R3     Offset                  <a>
        IREG1   WC      0               :R4     Control Index           <b>
                WC      AS.CTL          :R5     Control Address         <c>
                WC      4               :R6     5COUNT                  <d>
                WC      -AS.SIZ+F/6     :R7     SBX                     <e>
                WC      -AS.SIZ+F/6     :R8     RGX1                    <f>
                WC      OFFSET          :R9     RGX                     <g>
                HC      F/6,2*F/6       :R10    1/6 | 2/6 Frame \
                HC      3*F/6,4*F/6     :R11    3/6 | 4/6 Frame  =      <h>
                HC      5*F/6,F         :R12    5/6 | 6/6 Frame /
                WC      AS.SIZ          :R13    Size of ASYNC Ring
                WC      AS.ERN          :R14    Address of END_of_ASYNC_ring
                IF      NASYNG                                          <i>
                HC      LAREG,ADA       :R15    YD Init|Address Init
                ELSE
                HC      8010,ADA        :R15    Sign-bit set if no ASYNC
                EI

           NOTES:

           <a> Index of start-baud found by SBOD (used by GCHAR, SPM).
           <b> Index into Control-ring.
           <c> Address  of Control-ring  (used  to turn  SBA back  on  by SBOD,
               GCHAR).
           <d> Counts from 4 to -1 (used by RING5 to detect every 5th frame).
           <e> Start_Baud_Index, incremented by 2/6 F in SBOD.
           <f> Trails RGX by longest char, upper limit for SBX.
           <g> Ring_Interrupt_Index, incremented by F in RNG5.
           <h> Offsets  for  individual  areas in  the  frame.   Two half-words
               packed per register.  Each offset indicates the  first half-word
               AFTER the corresponding area.
           <i> The left-half of this  register specifies the first  register of
               register set 3  (or 4) which  is to be  used, for the  number of
               groups active.  It should be  set to register 16d, and  have the
               high-order bit  on, if  the machine  contains microcode,  but no
               ASYNC is in use.








        92                           TYMNET Engine                   ENGINE.DOC
        ASYNC Implementation                                   December 4, 1985


                    II-4.2  Initialization for register set 2

                                        :R0     PSW Save
                                        :R1     Working
                                        :R2     Port Number
                                        :R3     Working
                                        :R4     Working
        IREG2   WC      -F              :R5     RGX                     <a>
                WC      -F              :R6     RGI                     <b>
                WC      AS.ERN          :R7     Address of END_of_ASYNC_Ring
                WC      0               :R8     F5 Count                <c>
                WC      OFFSET+F5-F/6   :R9     RGX5                    <d>
                WC      LAREG           :R10    YDINIT                  <e>
                WC      RCHAR           :R11    Receive_Char_Width      <f>
                WC      XLNGTH          :R12    Transmit_Char_width     <g>
                WC      AS.SIZ          :R13    Ring size
                HC      4*F5,F5         :R14    4*F5 | F5
                WC      AS.LCT          :R15    AS.LCT                  <h>

           NOTES:
           <a> Index  to  Clear  ring behind  SBOD,  incremented  by  TIKMEM in
               XCLEAR.
           <b> Upper limit for RGI, Incremented by TIKMEM in RNG5.
           <c> Used by XMIT1 w/LCTIME  for char-start, incremented by  F5 every
               5-th RNG5.
           <d> Index where output chars can begin, incremented by F5  every 5th
               RNG5.
           <e> First SBA/TAM Register.
           <f>,<g> These parameters are not referenced (and may thus be left to
               any arbitrary value) if ASYNC is not in use.
           <h> Address of LCTIME array.





                    II-4.3  Initialization for register set 3

        :       Register set 3 contains the SBA/TAM Arrays
        :       Each register corresponds to one group:  SBA|TAM
        :       Each register in register set 3 holds the SBA|TAM data for
        :       16 ports in the format SSSSTTTT, where SSSS is the SBA data,
        :       and TTTT is the corresponding TAM information.
        IREG3   RE      10;     WC      0000FFFF;       ER










        93                           TYMNET Engine                   ENGINE.DOC
        ASYNC Implementation                                   December 4, 1985


                    II-4.4  Initialization for register set 4

        :       Each register corresponds to one group:  OUT DATA
        IREG4   RE      10;     WC      0000FFFF;       ER





                    II-4.5  Initialization for register set 0D

                                        :R0
                                        :R1
                                        :R2
                                        :R3
                                        :R4
                                        :R5
                                        :R6
                                        :R7
                                        :R8
                                        :R9
                                        :R10
                                        :R11
                                        :R12
                                        :R13
                WC      WAIT            :R14    Ticks until interrupt   <a>
                WC      TIME            :R15    Interrupt Address       <b>

           NOTES:

           <a> This register counts down by 1 every RNG5 time.
           <b> The address of the interrupt-routine.
               Usage:   When  R14 is  negative,  .AND. a  PSW  is  loaded which
               switches context  to Register-set xF,  then (and only  then) the
               newly-loaded  PSW is  saved  in R0-R1  of register  set  xD, and
               control  is  transfered  (again  in  register  set  xD)  to  the
               interrupt routine address specified by R15.

















        94                           TYMNET Engine                   ENGINE.DOC
        ASYNC Implementation                                   December 4, 1985








                               II-5  Definition of Terms


        RP      EQ      $A 14           : Current port index
        RP2     EQ      $A 13           : twice current port index
                IF      NASYNG-8                                        <a>
        ADA     EQ      0C1             : ASYNC Device-address
                ELSE
        ADA     EQ      91              : ASYNC Device-address
                EI
        LAREG   EQ      10-NASYNG       : Lowest ASYNC register used
        F       EQ      $A 12*NASYNG    : Frame-size (bytes)            <b>
        OFFSET  EQ      -AS.SIZ+$A53*F  : Displacement between SBX and RGX
        F5      EQ      5*F
        AS.CTL  WS      100             : Control Storage               <c>
        AS.LCT  HS      100             : Timeout Storage
        AS.SIZ  EQ      $A(53+60)*F+30*F5 : Size of the ring (bytes)
        AS.RNG  BS      AS.SIZ          : Ring Storage
        AS.ERN  WS      0               : End_of_Ring

           NOTES:

           <a> If there are  4 (or less) ASYNC  cards, the cards  are addressed
               with the first card having device address 91;  if there are more
               than 4  cards, it  becomes necessary to  address the  first card
               with address 0C1.
           <b> For each  frame of  ASYNC data,  it is  necessary to  allocate 6
               half-words of space for each group of 16 ASYNC ports.
           <c> This storage must  be allocated (with  these sizes, and  in this
               order) for the microcode to access.  It should be initialized as
               follows:

        AS.CTL  to  AS.RNG+$A53*F-1             all bits on;
        AS.RNG+$A53*F  to AS.ERN-1              all bits off.














        95                           TYMNET Engine                   ENGINE.DOC
        ASYNC Implementation                                   December 4, 1985



             Furthermore,  the following  tables  (16 half-words  each,  in the
        order specified) need be provided if ASYNC is active (the  given values
        correspond to  "vanilla" 1200-baud support;   other values  and entries
        would be required for other service):

        :       PARAMETERS (all numbers are decimal)

        :       CPS:    10     15    30    40    60    120   30    14.7  30/10

        :       Transmit-width
        Q       EQ      F/2             : Q is 1/1200th of a second
        XLNGTH  HC      120*Q, 80*Q, 40*Q, 30*Q, 20*Q, 10*Q, 40*Q, 90*Q, 120*Q
                HS      7               : pad out to 16 entries

        :       Baud Widths
        Q       EQ      F/2             : Q is 1/1200th of a second
        BLNGTH  HC      11*Q,  8*Q,  4*Q,  3*Q,  2*Q,  1*Q,  4*Q,  9*Q,  24*Q
                HS      7               : pad out to 16 entries

        :       Center Length ( = 1.5 baud-width...distance from beginning of
        :                                          Start-Baud to center of
        :                                          first data-baud)
        Q       EQ      F/6             : Q is 1/3600th of a second
        CLNGTH  HC      15*Q, 12*Q,  6*Q,  4*Q,  3*Q,  1*Q,   6*Q, 14*Q, 36*Q
                HS      7               : pad out to 16 entries

        :       Receiver character-length in 2*1800 units
        RCHAR   HC      312,   228,  114,  86,   56,   28,   114,  230,  0
                HS      7               : pad out to 16 entries






                           II-6  Determination of ring size


             On occasion, it may become necessary to determine the maximum size
        of the ASYNC ring.

             The ring is made up of three components:

           1.  Input area:   this area must  contain sufficient frames  for the
               maximum length character (equivalent to the maximum of the RCHAR
               list, adjusted to frame-size).
           2.  Output area:  This area  must contain sufficient frames  for the
               maximum output length (the maximum of the XLNGTH list, including
               BREAK).
           3.  Guard  area:   This is  the  most complicated  case.   It should
               contain a term related to the fact that a character may begin up


        96                           TYMNET Engine                   ENGINE.DOC
        ASYNC Implementation                                   December 4, 1985


               to 3*F5 frames from the current RGX5, and thus almost  4*F5 from
               the current RGX.   Furthermore, because of the  possibility that
               RGX  may  advance between  the  execution of  SBOD  and  XMIT, a
               further allowance must be made for this factor.  Since this will
               depend upon  the local environment  (e.g. possible  dismissal of
               code due  to interrupts,  etc., and  to the  speed at  which the
               interrupts are running), no hard and fast rule may  be provided.
               It should, however, be  as large as feasible (subject  to memory
               requirements, and the 64K ring-size limit imposed by LCTIME).

             If the ring is too  small, one obvious symptom will  be occasional
        cases of ring over-run;  XMIT can occasionally place  output characters
        such  that  the end-of-character  can  "pass" SBOD.   Symptoms  such as
        inverted data and/or "locked-TAM" may then appear on random ports.








































        97                           TYMNET Engine                   ENGINE.DOC
        CONSOLE DISPLAYS for MICROCODE HALTS                   December 4, 1985






                 APPENDIX III.   CONSOLE DISPLAYS for MICROCODE HALTS



             The  engine microcode  may, for  a variety  of reasons,  cause the
        machine to halt, and display status information on the front  panel, of
        form:

                                  0|0 x x x|D E A D|

             "xxx" is the status;  in general, it corresponds to  the microcode
        instruction address -- review  of the microcode may  provide additional
        information.

           xxx     Reason:

           01A     Illegal second decode of an instruction.
           020     Unused interrupt 0 became active.
           060     Power-down interrupt.
           100     No response to device address during boot.
           160     ATN0 interrupt (if no enhanced async or sync).
           1A0     ATN1 interrupt (if no enhanced sync).
           1A8     Sync signal active when it should be inactive.
           1E9     No sync response to RACK0 for ATN2.
           2xx     Bad device status during boot:  xx = status.
           608     No sync response to RACK0 for ATN1 (enhanced sync).
           610     Level 1 interrupt device no. out of range (enhanced sync).

             In addition, the console may also display:

                                  0|D E A D|0 B A D|

             This signifies console operator error!

















        98                           TYMNET Engine                   ENGINE.DOC
        DEVICE ADDRESSES FOR MULTIPLEXOR BUSS                  December 4, 1985






                 APPENDIX IV.   DEVICE ADDRESSES FOR MULTIPLEXOR BUSS



             The  multiplexor  buss  may  have  up  to  256  different  devices
        attached.  These  devices are each  assigned an address;   the standard
        address assignments are:

            02      TTY board.
            04      Temperature sensor.
            05      Loader storage unit.
            06      Loader storage unit control.
            08      WWVB interface (Extinct hardware).
            09      Super-clock.
            20-3F   Synchronous board number 1.
            40-5F   Synchronous board number 2.
            BF      Used for control functions in first sync card.
            FF      Used for control functions in second sync card.
            70-75   3600 interrupter.
            77      Laggard   software  receives   this  interrupt   when  3600
                    interrupts disabled too long.
            78-7F   Memory (Note...requires address FF78-FF7F!).
            80-83   SIO Mother-boards.
            60-67   CDC printer interfaces.
            91-AF   These addresses  reserved for async  I/O.  The 2  low order
                    bits are never both  zero.  The 1200 baud ports  use addrs.
                    91,95 for Data  In and Out, 92,96  for DSR In and  DTR Out,
                    93,97 Carrier In, BSY  Out on VADIC modems.  93,97  for 202
                    modems are Reverse Channel and Request to Send.
            F0      SELCH (selector channel).
            B6      Disc controller.
            C6,C7   Disc 0.
            D6,D7   Disc 1.
            E6,E7   Disc 2.
            F6,F7   Disc 3.
            C1-FF   These addresses  reserved for micro-coded  (enhanced) async
                    I/O.  The 2 low order bits are never both zero.   The first
                    port group uses addr. C1 for Data In and Out, C2 for DSR In
                    and DTR Out,  C3 Carrier In, BSY  Out on VADIC  modems.  C3
                    for 202 modems are Reverse Channel and Request to Send.










        99                           TYMNET Engine                   ENGINE.DOC
        ENGINE MNEMONIC-OPCODE MAP                             December 4, 1985






                       APPENDIX V.   ENGINE MNEMONIC-OPCODE MAP



             The map is generated for op-code "xy".

              x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xA  xB  xC  xD  xE  xF
             ----.---.---.---.---.---.---.---.---.---.---.---.---.---.---.----
          0y |   JALR|JTR|JFR|NR |CLR|OR |XR |LR |CR |AR |SR |MHR|DHR|   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          1y SRLSSLLS|LHRSBODXMIT|SPMGCHARDIALPSWRTIO|   |   |MR |DR |   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          2y JTBSJTFSJFBSJFFS|LIS|LCS|AIS|SIS|   |   |   |   |   |   |   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          3y |   JFFO   JFFOHEXHR|   |   |   |   |   |   |   |   |   |A N|COP|
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          4y |STH|JAL|JT |JF |NH |CLH|OH |XH |LH |CH |AH |SH |MH |DH |   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          5y |ST |AM |   |   | N |CL | O | X | L | C | A | S | M | D |   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          6y |   |AHM|   |   |   |   |   |   |   |   |   |   |   |   |   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          7y |   |   |   |LHL|TBT|SBT|RBT|CBT|   |   |   |   |   |   |   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          8y |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          9y SRHLSSLHLSSTBRLBREXBREPSR   |   |   |CIO|WDR|RDR|   |SSR|OCR|   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          Ay |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          By |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          Cy |   |   LPSW|THI|NHICLHI|OHI|XHI|LHI|CHI|AHI|SHISRHLSLHL|   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          Dy |STM|LM |STB|LB |CLB|UPSW   |   |   |   |WD |   |   |   |OC |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          Ey |TS |SVC|   |   |   |   |LA |   |   |   |RRL|RLL|SRL|SLL|SRA|   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          Fy |   |   |   |TI |NI |CLI|OI |XI |LI |CI |AI |SI |   |   |   |   |
             -----------------------------------------------------------------










        100                          TYMNET Engine                   ENGINE.DOC
        ENGINE FORMAT-OPCODE MAP                               December 4, 1985






                        APPENDIX VI.   ENGINE FORMAT-OPCODE MAP



             The map is generated for op-code "xy".

              x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xA  xB  xC  xD  xE  xF
             ----=====================================================---.----
          0y |   I                         R                         I   |   |
             |========   =====================   =============       I---+---|
          1y I       I   I         ?         I   I ? I   |   I       I   |   |
             I       =====================================---=========---+---|
          2y I               SF              I   |   |   |   |   |   |   |   |
             |====   =====   =================---+---+---+---+---+---========|
          3y |   I   I   I   I R I   |   |   |   |   |   |   |   |   | ? | R |
             |===============================================================|
          4y I                                                       I   |   |
             I       =========               X                       I---+---|
          5y I       I   |   I                                       I   |   |
             |====   I---+---=========================================---+---|
          6y |   I   I   |   |   |   |   |   |   |   |   |   |   |   |   |   |
             |---=====---=====================---+---+---+---+---+---+---+---|
          7y |   |   |   I        X          I   |   |   |   |   |   |   |   |
             |---+---+---=====================---+---+---+---+---+---+---+---|
          8y |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
             |========================---+---+---+---=========---=========---|
          9y I  SF   I       R       I   |   |   I     R     I   I   R   I   |
             |========================---+---+---+---=========---=========---|
          Ay |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
             |---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---|
          By |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
             |---+---=================================================---+---|
          Cy |   |   I   I                RI1                I  SF   I   |   |
             |========   =================================================---|
          Dy I           X           I   |   |   |   I   I   |   |   I   I   |
             I       =====================---+---+---I   =============   I---|
          Ey I       I   |   |   |   I X I   |   |   I         X         I   |
             |========---=================================================---|
          Fy |   |   |   I                 RI2               I   |   |   |   |
             ------------=====================================----------------

                Where "X" is RX1, RX2, or RX3 format;
                and "R" is RR format.







        101                          TYMNET Engine                   ENGINE.DOC
        INSTRUCTION SUMMARY...ALPHABETICAL                     December 4, 1985






                  APPENDIX VII.   INSTRUCTION SUMMARY...ALPHABETICAL


        Instruction                           Op-code NAD     Timing       PAGE

        Add                                      5A  A       3.379           46
        Add Halfword                             4A  AH      2.597           46
        Add Halfword Immediate                   CA  AHI     1.690           46
        Add Halfword to Memory                   61  AHM     3.629           47
        Add Immediate                            FA  AI      2.472           46
        Add Immediate Short                      26  AIS     0.907           46
        Add Register                             0A  AR      1.032           46
        Add to Memory                            51  AM      5.445           47
        Align Sync input                         36  ALIGN     ???           62
        aNd                                      54  N       3.379           32
        aNd                                      54  N       3.504           32
        aNd                                      54  N       4.287           32
        aNd Halfword                             44  NH      2.597           32
        aNd Halfword                             44  NH      2.722           32
        aNd Halfword                             44  NH      3.504           32
        aNd Halfword Immediate                   C4  NHI     1.689           32
        aNd Immediate                            F4  NI      2.472           32
        aNd Register                             04  NR      1.032           32
        ARray AND                                3E  ARAND     ???           34

        Checksum Sync input                      37  CKSUM     ???           62
        Compare                                  59  C       3.379           50
        Compare Halfword                         49  CH      2.597           50
        Compare Halfword Immediate               C9  CHI     1.690           50
        Compare Immediate                        F9  CI      2.472           50
        Compare Logical                          55  CL      3.379           49
        Compare Logical Byte                     D4  CLB     2.597           50
        Compare Logical Halfword                 45  CLH     2.597           49
        Compare Logical Halfword Immediate       C5  CLHI    1.690           49
        Compare Logical Immediate                F5  CLI     2.472           49
        Compare Logical Register                 05  CLR     1.032           49
        Compare Register                         09  CR      1.126           50
        Complement BiT                           77  CBT     3.880           41
        Complement BiT                           77  CBT     4.005           41
        Complement BiT                           77  CBT     4.788           41
        Compute BCT                              3A  **CBCT    ???           64
        Console IO                               99  CIO     1.00            58
        Convert Halfword Value Register          12  CHVR    1.158           54
        COPY memory                              3F  COPY      ???           31

        Divide                                   5D  D       25.599          52
        Divide Halfword                          4D  DH      15.365          53
        Divide Halfword Register                 0D  DHR     12.204          53
        Divide Register                          1D  DR      25.724          52

        102                          TYMNET Engine                   ENGINE.DOC
        INSTRUCTION SUMMARY...ALPHABETICAL                     December 4, 1985


        EXchange Byte Register                   94  EXBR    0.907           28
        EXchange Halfword Register               34  EXHR    0.907           28
        Exchange Program Status Register         95  EPSR    0.75            56
        eXclusive or Halfword                    47  XH      2.597           33
        eXclusive or Halfword                    47  XH      2.722           33
        eXclusive or Halfword                    47  XH      3.504           33
        eXclusive or Halfword Immediate          C7  XHI     1.689           33
        eXlusive or                              57  X       3.379           33
        eXlusive or                              57  X       3.504           33
        eXlusive or                              57  X       4.287           33
        eXlusive or Immediate                    F7  XI      2.472           33
        eXlusive or Register                     07  XR      1.032           33

        Get Character Input                      38  **GCI     ???           64

        Jump                                     430 J       1.815           43
        Jump And Link                            41  JAL     1.815           44
        Jump And Link Register                   01  JALR    1.283           44
        Jump Backward Short                      220 JBS     1.157           43
        Jump Carry                               428 JC      1.815           44
        Jump Carry Backward Short                208 JCBS    1.157           44
        Jump Carry Forward Short                 218 JCFS    1.157           44
        Jump Carry Register                      028 JCR     1.283           44
        Jump Equal                               433 JE      1.815           43
        Jump Equal Backward Short                223 JEBS    1.157           43
        Jump Equal Forward Short                 233 JEFS    1.157           43
        Jump Equal Register                      033 JER     1.283           43
        Jump False Backward Short                22M JFBS    1.157           42
        Jump False Forward Short                 23M JFFS    1.157           42
        Jump Find First One                      31  JFFO    1.533 R=0       45
        Jump Find First One Halfword             33  JFFOH   1.544 R=0       45
        Jump Forward Short                       230 JFS     1.157           43
        Jump Greater                             422 JG      1.815           43
        Jump Greater Backward Short              202 JGBS    1.157           43
        Jump Greater Equal                       431 JGE     1.815           44
        Jump Greater Equal Backward Short        221 JGEBS   1.157           44
        Jump Greater Equal Forward Short         231 JGEFS   1.157           44
        Jump Greater Equal Register              031 JGER    1.283           44
        Jump Greater Forward Short               212 JGFS    1.157           44
        Jump Greater Register                    022 JGR     1.283           43
        Jump Less                                421 JL      1.815           44
        Jump Less Backward Short                 201 JLBS    1.157           44
        Jump Less Equal                          432 JLE     1.815           44
        Jump Less Equal Backward Short           222 JLEBS   1.157           44
        Jump Less Equal Forward Short            232 JLEFS   1.157           44
        Jump Less Equal Register                 032 JLER    1.283           44
        Jump Less Forward Short                  211 JLFS    1.157           44
        Jump Less Register                       021 JLR     1.283           44
        Jump No Carry                            438 JNC     1.815           44
        Jump No Carry Backward Short             228 JNCBS   1.157           44
        Jump No Carry Forward Short              228 JNCFS   1.157           44
        Jump No Carry Register                   038 JNCR    1.283           44
        Jump Not equal                           423 JN      1.815           43

        103                          TYMNET Engine                   ENGINE.DOC
        INSTRUCTION SUMMARY...ALPHABETICAL                     December 4, 1985


        Jump Not equal Backward Short            203 JNBS    1.157           43
        Jump Not equal Forward Short             213 JNFS    1.157           43
        Jump Not equal Register                  023 JNR     1.283           43
        Jump on False condition                  43M JF      1.815           42
        Jump on False condition Register         03M JFR     1.283           42
        Jump on True condition                   42M JT      1.815           42
        Jump on True condition Register          02M JTR     1.283           42
        Jump Register                            030 JR      1.283           43
        Jump True Backward Short                 20M JTBS    1.157           42
        Jump True Forward Short                  21M JTFS    1.157           42

        Load                                     58  L       3.379           25
        Load                                     58  L       3.504           25
        Load                                     58  L       4.287           25
        Load Address                             E6  LA      2.065           26
        Load Address                             E6  LA      2.065           26
        Load Address                             E6  LA      2.847           26
        Load Byte                                D3  LB      2.597           27
        Load Byte                                D3  LB      2.722           27
        Load Byte                                D3  LB      3.504           27
        Load Byte Register                       93  LBR     0.907           27
        Load Complement Short                    25  LCS     0.907           25
        Load Halfword                            48  LH      2.597           25
        Load Halfword                            48  LH      2.722           25
        Load Halfword                            48  LH      3.504           25
        Load Halfword Immediate                  C8  LHI     1.689           25
        Load Halfword Logical                    73  LHL     2.597           26
        Load Halfword Logical                    73  LHL     2.722           26
        Load Halfword Logical                    73  LHL     3.504           26
        Load Halfword Register                   12  LHR     1.158           54
        Load Immediate                           F8  LI      2.472           25
        Load Immediate Short                     24  LIS     0.907           25
        Load Multiple                            D1  LM      1.814+1.565*n   27
        Load Multiple                            D1  LM      1.939+1.565*n   27
        Load Program Status Word                 C2  LPSW    4.662           55
        Load Program Status Word Register        18  LPSWR   0.75            55
        Load Register                            08  LR      1.032           25

        Multiply                                 5C  M       16.773          51
        Multiply Halfword                        4C  MH      10.233          52
        Multiply Halfword Register               0C  MHR     8.198           52
        Multiply Register                        1C  MR      14.082          51

        No OPeration                             420 NOP     1.815           43
        No OPeration Register                    020 NOPR    0.909           43

        Or Halfword                              46  OH      2.597           32
        Or Halfword                              46  OH      2.722           32
        Or Halfword                              46  OH      3.505           32
        Or Halfword Immediate                    C6  OHI     1.690           32
        Or Immediate                             F6  OI      2.472           32
        Or Register                              06  OR      1.032           32
        Or word                                  56  O       3.379           32

        104                          TYMNET Engine                   ENGINE.DOC
        INSTRUCTION SUMMARY...ALPHABETICAL                     December 4, 1985


        Or word                                  56  O       3.505           32
        Or word                                  56  O       4.287           32
        Output Command                           DE  OC      1.00            59
        Output Command Register                  9E  OCR     1.00            59

        Read Data                                9B  RDR     1.00            59
        Reset BiT                                76  RBT     3.755           41
        Reset BiT                                76  RBT     3.880           41
        Reset BiT                                76  RBT     4.662           41
        RMAKE Copy 1                             0E  **RMA1    ???           64
        RMAKE Copy 2                             0F  **RMA2    ???           64
        Rotate Left Logical                      EB  RLL     2.190 (0)       38
        Rotate Right Logical                     EA  RRL     2.190 (0)       38
        RTD Copy 1                               3B  **RTD1    ???           64
        RTD Copy 2                               3C  **RTD2    ???           64

        Scan Sync input                          35  SCAN      ???           62
        Sense Status Register                    9D  SSR     1.00            58
        Set BiT                                  75  SBT     3.755           40
        Set BiT                                  75  SBT     3.880           40
        Set BiT                                  75  SBT     4.662           40
        Shift Left Halfword Logical              CD  SLHL    2.190 (0)       36
        Shift Left Halfword Logical Short        91  SLHLS   1.533 (0)       36
        Shift Left Logical                       ED  SLL     2.190 (0)       35
        Shift Left Logical Short                 11  SLLS    1.533 (0)       35
        Shift Right Arithmetic                   EE  SRA     2.190 (0)       53
        Shift Right Halfword Logical             CC  SRHL    2.190 (0)       37
        Shift Right Halfword Logical Short       90  SRHLS   1.533 (0)       37
        Shift Right Logical                      EC  SRL     2.190 (0)       36
        Shift Right Logical Short                10  SRLS    1.533 (0)       36
        Start Baud                               13  SBOD      ???           61
        Start Baud Input                         16  GCHAR     ???           61
        Start Baud Output                        14  XMIT      ???           61
        Start Baud TID                           15  SPM       ???           61
        STore                                    50  ST      3.504           29
        STore                                    50  ST      3.630           29
        STore                                    50  ST      4.412           29
        STore Byte                               D2  STB     3.505           30
        STore Byte                               D2  STB     3.603           30
        STore Byte                               D2  STB     4.412           30
        STore Byte Register                      92  STBR    0.907           30
        STore Halfword                           40  STH     2.722           29
        STore Halfword                           40  STH     2.847           29
        STore Halfword                           40  STH     3.629           29
        STore Multiple                           D0  STM     1.939+1.565*n   30
        STore Multiple                           D0  STM     2.065+1.565*n   30
        STore Multiple                           D0  STM     2.847+1.565*n   30
        Subtract                                 5B  S       3.379           48
        Subtract Halfword                        4B  SH      2.597           48
        Subtract Halfword Immediate              CB  SHI     1.689           48
        Subtract Immediate                       FB  SI      2.472           48
        Subtract Immediate Short                 27  SIS     0.907           48
        Subtract Register                        0B  SR      1.032           48

        105                          TYMNET Engine                   ENGINE.DOC
        INSTRUCTION SUMMARY...ALPHABETICAL                     December 4, 1985


        SuperVisor Call                          E1  SVC     3.75            56

        Test and Set                             E0  TS      3.285           39
        Test and Set                             E0  TS      3.411           39
        Test and Set                             E0  TS      4.193           39
        Test BiT                                 74  TBT     2.973           40
        Test BiT                                 74  TBT     3.098           40
        Test BiT                                 74  TBT     3.880           40
        Test Halfword Immediate                  C3  THI     1.690           35
        Test Immediate                           F3  TI      2.472           35

        User Program Status Word                 D5  UPSW    4.66            55

        Write Character Input                    39  **WCI     ???           64
        Write Data                               DA  WD      2.25            60
        Write Data Register                      9A  WDR     0.75            60

             **  These instruction mnemonics are not known to NAD.




































        106                          TYMNET Engine                   ENGINE.DOC
        INSTRUCTION SUMMARY...NUMERIC                          December 4, 1985






                    APPENDIX VIII.   INSTRUCTION SUMMARY...NUMERIC


        Op-code  NAD       Instruction                                     PAGE


        01       JALR      Jump And Link Register                            44
        020      NOPR      No OPeration Register                             43
        021      JLR       Jump Less Register                                44
        022      JGR       Jump Greater Register                             43
        023      JNR       Jump Not equal Register                           43
        028      JCR       Jump Carry Register                               44
        02M      JTR       Jump on True condition Register                   42
        030      JR        Jump Register                                     43
        031      JGER      Jump Greater Equal Register                       44
        032      JLER      Jump Less Equal Register                          44
        033      JER       Jump Equal Register                               43
        038      JNCR      Jump No Carry Register                            44
        03M      JFR       Jump on False condition Register                  42
        04       NR        aNd Register                                      32
        05       CLR       Compare Logical Register                          49
        06       OR        Or Register                                       32
        07       XR        eXlusive or Register                              33
        08       LR        Load Register                                     25
        09       CR        Compare Register                                  50
        0A       AR        Add Register                                      46
        0B       SR        Subtract Register                                 48
        0C       MHR       Multiply Halfword Register                        52
        0D       DHR       Divide Halfword Register                          53
        0E       **RMA1    RMAKE Copy 1                                      64
        0F       **RMA2    RMAKE Copy 2                                      64

        10       SRLS      Shift Right Logical Short                         36
        11       SLLS      Shift Left Logical Short                          35
        12       LHR       Load Halfword Register                            54
        13       SBOD      Start Baud                                        61
        14       XMIT      Start Baud Output                                 61
        15       SPM       Start Baud TID                                    61
        16       GCHAR     Start Baud Input                                  61
        18       LPSWR     Load Program Status Word Register                 55
        1C       MR        Multiply Register                                 51
        1D       DR        Divide Register                                   52

        201      JLBS      Jump Less Backward Short                          44
        202      JGBS      Jump Greater Backward Short                       43
        203      JNBS      Jump Not equal Backward Short                     43
        208      JCBS      Jump Carry Backward Short                         44
        20M      JTBS      Jump True Backward Short                          42
        211      JLFS      Jump Less Forward Short                           44

        107                          TYMNET Engine                   ENGINE.DOC
        INSTRUCTION SUMMARY...NUMERIC                          December 4, 1985


        212      JGFS      Jump Greater Forward Short                        44
        213      JNFS      Jump Not equal Forward Short                      43
        218      JCFS      Jump Carry Forward Short                          44
        21M      JTFS      Jump True Forward Short                           42
        220      JBS       Jump Backward Short                               43
        221      JGEBS     Jump Greater Equal Backward Short                 44
        222      JLEBS     Jump Less Equal Backward Short                    44
        223      JEBS      Jump Equal Backward Short                         43
        228      JNCBS     Jump No Carry Backward Short                      44
        22M      JFBS      Jump False Backward Short                         42
        230      JFS       Jump Forward Short                                43
        231      JGEFS     Jump Greater Equal Forward Short                  44
        232      JLEFS     Jump Less Equal Forward Short                     44
        233      JEFS      Jump Equal Forward Short                          43
        23M      JFFS      Jump False Forward Short                          42
        24       LIS       Load Immediate Short                              25
        25       LCS       Load Complement Short                             25
        26       AIS       Add Immediate Short                               46
        27       SIS       Subtract Immediate Short                          48

        31       JFFO      Jump Find First One                               45
        33       JFFOH     Jump Find First One Halfword                      45
        34       EXHR      EXchange Halfword Register                        28
        35       SCAN      Scan Sync input                                   62
        36       ALIGN     Align Sync input                                  62
        37       CKSUM     Checksum Sync input                               62
        38       **GCI     Get Character Input                               64
        39       **WCI     Write Character Input                             64
        3A       **CBCT    Compute BCT                                       64
        3B       **RTD1    RTD Copy 1                                        64
        3C       **RTD2    RTD Copy 2                                        64
        3E       ARAND     ARray AND                                         34
        3F       COPY      COPY memory                                       31

        40       STH       STore Halfword                                    29
        41       JAL       Jump And Link                                     44
        420      NOP       No OPeration                                      43
        421      JL        Jump Less                                         44
        422      JG        Jump Greater                                      43
        423      JN        Jump Not equal                                    43
        428      JC        Jump Carry                                        44
        42M      JT        Jump on True condition                            42
        430      J         Jump                                              43
        431      JGE       Jump Greater Equal                                44
        432      JLE       Jump Less Equal                                   44
        433      JE        Jump Equal                                        43
        438      JNC       Jump No Carry                                     44
        43M      JF        Jump on False condition                           42
        44       NH        aNd Halfword                                      32
        45       CLH       Compare Logical Halfword                          49
        46       OH        Or Halfword                                       32
        47       XH        eXclusive or Halfword                             33
        48       LH        Load Halfword                                     25

        108                          TYMNET Engine                   ENGINE.DOC
        INSTRUCTION SUMMARY...NUMERIC                          December 4, 1985


        49       CH        Compare Halfword                                  50
        4A       AH        Add Halfword                                      46
        4B       SH        Subtract Halfword                                 48
        4C       MH        Multiply Halfword                                 52
        4D       DH        Divide Halfword                                   53

        50       ST        STore                                             29
        51       AM        Add to Memory                                     47
        54       N         aNd                                               32
        55       CL        Compare Logical                                   49
        56       O         Or word                                           32
        57       X         eXlusive or                                       33
        58       L         Load                                              25
        59       C         Compare                                           50
        5A       A         Add                                               46
        5B       S         Subtract                                          48
        5C       M         Multiply                                          51
        5D       D         Divide                                            52

        61       AHM       Add Halfword to Memory                            47

        73       LHL       Load Halfword Logical                             26
        74       TBT       Test BiT                                          40
        75       SBT       Set BiT                                           40
        76       RBT       Reset BiT                                         41
        77       CBT       Complement BiT                                    41

        90       SRHLS     Shift Right Halfword Logical Short                37
        91       SLHLS     Shift Left Halfword Logical Short                 36
        92       STBR      STore Byte Register                               30
        93       LBR       Load Byte Register                                27
        94       EXBR      EXchange Byte Register                            28
        95       EPSR      Exchange Program Status Register                  56
        99       CIO       Console IO                                        58
        9A       WDR       Write Data Register                               60
        9B       RDR       Read Data                                         59
        9D       SSR       Sense Status Register                             58
        9E       OCR       Output Command Register                           59

        C2       LPSW      Load Program Status Word                          55
        C3       THI       Test Halfword Immediate                           35
        C4       NHI       aNd Halfword Immediate                            32
        C5       CLHI      Compare Logical Halfword Immediate                49
        C6       OHI       Or Halfword Immediate                             32
        C7       XHI       eXclusive or Halfword Immediate                   33
        C8       LHI       Load Halfword Immediate                           25
        C9       CHI       Compare Halfword Immediate                        50
        CA       AHI       Add Halfword Immediate                            46
        CB       SHI       Subtract Halfword Immediate                       48
        CC       SRHL      Shift Right Halfword Logical                      37
        CD       SLHL      Shift Left Halfword Logical                       36

        D0       STM       STore Multiple                                    30

        109                          TYMNET Engine                   ENGINE.DOC
        INSTRUCTION SUMMARY...NUMERIC                          December 4, 1985


        D1       LM        Load Multiple                                     27
        D2       STB       STore Byte                                        30
        D3       LB        Load Byte                                         27
        D4       CLB       Compare Logical Byte                              50
        D5       UPSW      User Program Status Word                          55
        DA       WD        Write Data                                        60
        DE       OC        Output Command                                    59

        E0       TS        Test and Set                                      39
        E1       SVC       SuperVisor Call                                   56
        E6       LA        Load Address                                      26
        EA       RRL       Rotate Right Logical                              38
        EB       RLL       Rotate Left Logical                               38
        EC       SRL       Shift Right Logical                               36
        ED       SLL       Shift Left Logical                                35
        EE       SRA       Shift Right Arithmetic                            53

        F3       TI        Test Immediate                                    35
        F4       NI        aNd Immediate                                     32
        F5       CLI       Compare Logical Immediate                         49
        F6       OI        Or Immediate                                      32
        F7       XI        eXlusive or Immediate                             33
        F8       LI        Load Immediate                                    25
        F9       CI        Compare Immediate                                 50
        FA       AI        Add Immediate                                     46
        FB       SI        Subtract Immediate                                48

             **  These instruction mnemonics are not known to NAD.


























        110                          TYMNET Engine                   ENGINE.DOC
        INDEX                                                  December 4, 1985


                                         INDEX

        absolute address space  22            SLA (obsolete instruction)  1
        address space  22                     SLHA (obsolete instruction)  1
        AL (obsolete instruction)  1          SPM  14
                                              SRHA (obsolete instruction)  1
                                              SS (obsolete instruction)  1
        Buffer and Bufferlet
           Structure  68
        bufferlet  68                         TLATE (obsolete instruction)  1
                                              TRACE  12, 13@
                                              TYMNET  61
        condition code  10
        CRC12 (obsolete instruction)  1
        CRC16 (obsolete instruction)  1       virtual address space  22


        EHANCED INTERRUPTS  13                WB (obsolete instruction)  1
        ENHANCED ASYNC TIMER                  WBR (obsolete instruction)  1
           INTERRUPTS  20                     WH (obsolete instruction)  1
                                              WHR (obsolete instruction)  1

        GCHAR  14
                                              X2  6, 7
                                              X2'  7
        JXH (obsolete instruction)  1         XMIT  14
        JXLE (obsolete instruction)  1


        MAC  22
        MAC protection  23
        MAC registers  23
        Memory Access Controller  22
        microcode  61
        microcode assembler  69
        MICROCODE HALTS  98
        microcoded line descriptor  15


        R1  4, 5, 6, 7
        R2  4
        RB (obsolete instruction)  1
        RBR (obsolete instruction)  1
        RD (obsolete instruction)  1
        RH (obsolete instruction)  1
        RHR (obsolete instruction)  1


        SBOD  14
        SCP (obsolete instruction)  1
        Segment  23
        segment registers  23
        SINT (obsolete instruction)  1

        111                          TYMNET Engine                   ENGINE.DOC
~ W