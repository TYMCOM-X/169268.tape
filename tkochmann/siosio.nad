

	RA      0
        GL      FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,DISMISS
        GL      R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
        GL      SEG0,SEG1,SEG2,SEG3
        GL      CRAT,CRSHCT,CRSTOP
        GL      IRSIZE,ORSIZE,CNTRL,ENTRY,IRING
        GL      ORING,FPANEL
        GL      CRASH
        GL      OCS,OCM,OBS,LOOK,GETCH,GETH,GETW,FLUSH,ELIR,SPACE,ROOM,SLOR
        GL      PUTCH,PUTH,PUTW,ELODR,ELOR,CRASHC
        GL      CPOINT,CFROM,CRREG,ENTRY,START
        GL      NODEX,SLOTNO,ENGINE,VERREV,HOSTS,PORTS,A.DATA,A.CODE
        GL      A.BDAT,A.RING,A.BUFF
	GL	DSTART,DS.ELL,DS.ILL,DS.ERR,DS.DLM
	GL	DS.TOK,DS.NUM,DS.EXI,DS.QUI,DS.GCH,DS.CUC,DS.DEL
:
:       SVC EQUATES
:
SYS     EQ      2		:SYSTEM SVC'S
CFGD    EQ      1		:CONNECT FOREGROUND
QUERY   EQ      8000		:QUERY ATTRIBUTES
IO      EQ      3		:I/O SVC'S
CMB     EQ      90               :CONNECT MOTHER BOARD CHANNEL
FMBI    EQ      0A0           :FORCE MOTHER BOARD INPUT
FMBO    EQ      0B0           :FORCE MOTHER BOARD OUTPUT
DISLU	EQ	$A 35		:DISCONNECT LOGICAL UNIT
KIO	EQ	0D		:KIO SVC'S
TTYOUT	EQ	0B		:TTY OUTPUT SVC
FAST	EQ	1		:FAST DISMISS

        SEG     A.DATA
REGSAV  WS      10		:REGISTER SAVE AREA
ATTINF  BS      3		:ATTRIBUTE INFO AREA
OLDSTS  BS      1               :STORAGE FOR OLD SIO CKSUM ERR COUNT
STRTIM  WS      20              :TEST START TIME IN SECONDS
STPTIM  WS      20              :TEST STOP TIME FROM SLOWC
RECCT	WS	20		:RECORD COUNT
DUPREC	WS	20		:RECORD ERROR COUNT
TOTBIT	WS	20		:TOTAL BIT COUNT
SIOBAD  WS      20              :SIO DETECTED BAD RECORD COUNT
FPANEL  HS      1               :FRONT PANEL CONTENTS
TESTLU	HC	0FFFF		:TEST LOGICAL UNIT
GOTEST	HS	1		:TEST ACTIVE FLAG
PATSEL	HC	0		:TEST PATTERN SELECTED
RECLEN	HS	1		:REMAINING BYTES IN RECORD
STOPED	HS	1		:ERROR CODE
RTMSG	SC	/RUN TIME:  ########.  LINE SPEED= ###### BPS."8D"8A/
CTMSG   SC      /BLOCKS TRANSMITTED: ########"8D"8A/
CT1MSG	SC	/DUPLICATE RECORDS:  ######## - ##%./
CTAMSG	SC	/HDLC CRC ERRORS:    ########"8D"8A/
CT2MSG	SC	/BITS TRANSMITTED:   ########"8D"8A/
	BC	0		:TERMINATE OUTPUT STRING
LUMSG	SC	/LOGICAL UNIT/
SIOLIN	SC	/ IS SIO LINE/
NSIMSG	SC	/ IS NOT AN SIO LINE!!"8D"8A/
RUNMSG	SC	/TEST IS RUNNING"8D"8A/
SLMSG   SC      / SIO LINE/
MBMSG	SC	/ MOTHER BOARD/
STPMSG	SC	/TEST IS STOPPED"8D"8A/
NODATA	SC	/NO DATA FOR /
NOPAT	SC	/NO DATA PATTERN SELECTED"8D"8A/
BADPAT	SC	/INVALID DATA PATTERN"8D"8A/
ENPAT	SC	/ENTER HALFWORD DATA PATTERN  /
NOLUMS	SC	/NO LOGICAL UNIT SELECTED/
PATMSG	SC	/DATA PATTERN /
P2047	SC	/2047"8D"8A/
PALT	SC	/ALTERNATING BIT"8D"8A/
PUSER	SC	/USER SELECTED /
CRMSG	SC	/ SLOT CRASH--COUNT=##, CODE=##"8D"8A/
INTMSG	SC	/SIO INTERRUPT CODE ##, ######## AGO"8D"8A/
CRLF	SC	/"8D"8A/
BDBITS	BC	0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4  :# OF BITS IN ERROR COMPARED
:		0 1 2 3 4 5 6 7 8 9 A B C D E F  TO TEST PATTERN.
:
	SEG	A.BUFF		:SIO DATA AREA
:
	BND	10		:FORCE QUAD WORD BOUNDARY
OUTBUF	HC	100		:BYTE COUNT OF OUTPUT RECORD
	RE	100		:MAKE BUFFER
	BC	0FF
	ER
:
:	SIO OUTPUT CHANNEL COMMAND PROGRAM
:
	BND	100		:SO SIO MICROCODE DOESN'T GRIPE
		:FIRST FIVE COMMANDS ARE JUST TO SET UP THE SIO
SIOSET	WC	30018		:RESET CHANNEL
	WC	31420		:SET SDLC SYNC MODE, RESET EXT STATUS
	WC	31100		:DISABLE RX/TX INTERRUPTS
	WC	303D8		:SET 8-BIT RX, HUNT PHASE,RX CRC
	WC	305EB		:RAISE DTR, RTS, SET 8-BIT TX, TX CRC, TX ON
	WC	3877E		:PUT SDLC SYNC FLAG IN WR7
	WC	313D9		:SET 8-BIT RX, HUNT PHASE,RX CRC, RX ON
	WC	0		:STOP AFTER WE SET IT UP
	BND	10		:FORCE QUAD WORD BOUNDARY FOR SIO
Q	EQ	0
	RE	10		:DO THIS 10 TIMES TO MAKE 10 OUTPUT COMMANDS
SIOUT|Q| HC	1
	HC	OUTBUF/10
Q	EQ	Q+1
	ER
SIOJMP	HC	0,SIOUT0/10	:AND STOP CHAINING HERRE
	BND	10		:FORCE QUAD WORD BOUNDARY
SIOIN	WC	308A3		:SET INPUT BUFFER SIZE
	HC	1,INBUF/10	:INPUT TO BUFFER
	HC	2,SIOIN/10	:JUMP BACK TO BEGINNING JUST IN CASE
:
:	SIO INPUT BUFFER.  BUFFER SIZE HAS BEEN CALCULATED TO ALLOW 16 100
:	HEX BYTE LONG RECORDS TO BE PUT IN IT BY THE SIO.
:
	BND	10		:FORCE QUAD WORD BOUNDARY
INBUF   HS      0
        RE      1146
        BC      0FF
        ER
	BND	10
SIOSTS	HS	3		:WHERE TO PUT SIO STATUS
	BND	10
ENDBUF	EQ	.		:LABEL TO TELL SIO WHERE TO STOP
:
:	NOW FOR THE BACKGROUND CODE
:
	SEG	A.CODE
START	EQ	.		:HERE'S WHERE WE START
:
:	R0=SCRATCHPAD
:	R1=INDEX TO BYTE COUNTS
:	R2=INDEX INTO BUFFERS FOR ERROR CHECKING
:	R3=TEST LOGICAL UNIT NUMBER SHIFTED LEFT 2.
:	R4,R5=SCRATCH PADS
:	R6=LINK REGISTER
:	R7=CONSTANT OF ONE FOR INCREMENTING
:	R8=SCRATCH
:	R9-R13=SCRATCH PADS FOR ERRCHK ROUTINE
:	R14=INDICATOR FOR BAD BLOCKS
:
	LIS	R1,0
	LIS	R2,0		:SET INDICES TO 0
	LIS	R7,1		:SET INCREMENT FOR COUNTERS
	STH	R1,FPANEL	:ZERO FRONT PANEL DISPLAY
BGWAIT	SVC	DISMISS,1	:WAIT A SECOND
	LHL	R0,GOTEST	:GET TEST ACTIVE FLAG
	JEBS	BGWAIT		:TEST NOT ACTIVE, GO BACK TO SLEEP
	LHL	R3,TESTLU	:TEST IS ACTIVE, GET LU TO BE TESTED
	SLLS	R3,2		:TIMES 4, FOR INDEX TO FULL WORD TABLES
	JAL	R6,CLINBF	:CLEAN UP THE INPUT BUFFER
	LA	R0,FOREGD	:GET FOREGROUND'S ADDRESS
	SVC	SYS,CFGD	:AND START IT UP
BGMAIN	SVC	DISMISS		:WAIT FOR NEXT TIME SLICE
	LHL	R0,GOTEST	:TEST STILL ACTIVE?
	JE	STTEST		:NO, GO STOP THE TEST
MANLOP	LH	R4,INBUF,R1,	:GET BYTE COUNT
	JL	BGMAIN		:LESS THAN ZERO MEANS NO NEW DATA.
	LI	R5,0F000BABA	:FLAG TO INDICATE RECORD ALREADY CHECKED.
	C	R5,INBUF+2,R1,	:HAS IT BEEN
	JNFS	MNLOP1		:NO, SKIP 
	AM      R7,DUPREC,R3	:INCREMENT COUNT OF DUPLICATE RECORDS
MNLOP1	AM	R7,RECCT,R3	:INCREMENT TOTAL BLOCKS RECEIVED
	ST	R5,INBUF+2,R1,	:FLAG RECORD AS ALREADY CHECKED.
	LCS	R5,1		:MAKE A -1
	STH	R5,INBUF,R1,    :AND STORE IT AS THE NEW BYTE COUNT
	AR	R1,R4		:ADD CURRENT BYTE COUNT TO INDEX
	AIS	R1,3		:AND THE LENGTH HALFWORD
	nhi	r1,-2
	SLLS	R4,3		:MAKE BYTE COUNT BIT COUNT
	AM      R4,TOTBIT,R3    :INCREMENT TOTAL BITS RECEIVED
	CLHI	R1,0F1E		:HAVE WE GONE ALL THE WAY THROUGH THE BUFFER?
	JL	MANLOP		:NO, REPEAT
        LIS	R1,0		:YES, ZERO OUT BUFFER INDEX
	J	MANLOP		:AND GO BACK TO BEGINNING
STTEST	L	R4,SLOWC,,	:GET TIME
	ST	R4,STPTIM,R3	:STORE IT AS STOP TIME FOR THIS TEST
	LIS	R0,0		:MAKE A ZERO
	STH	R0,FPANEL	:ZERO FRONT PANEL DISPLAY
	SVC	SYS,CFGD	:HALT FOREGROUND
	J	START		:AND WAIT FOR A NEW TEST TO START.
:
:	FOREGROUND CODE
:
FOREGD	EQ	.		:START EXECUTION HERE
	JAL	R6,SETSIO	:SET UP SIO OUTPUT COMMANDS
	LHL	R1,TESTLU,,	:GET NUMBER OF LOGICAL UNIT TO TEST
	LA	R2,OUTBUF,,	:GET LOW ADDRESS FOR M.B. TO ACCESS
	LA	R3,ENDBUF,,	:HIGH ADDRESS FOR M.B.
	LA	R4,SIOSTS,,	:SIO STATUS ADDRESS
	SVC	IO,CMB+R1	:CONNECT MOTHER BOARD
	JAL	R15,MBOOPS	:SVC FAILED, DIE HORRIBLY
	SVC	DISMISS,1	:WAIT A SECOND FOR COMMANDS TO GET PROCESSED
	LA	R2,SIOSET,,	:ADDRESS OF OUTPUT CHANNEL COMMAND PROGRAM
	SVC	IO,FMBO+R1	:FORCE MOTHER BOARD OUTPUT
	JAL	R15,MBOOPS	:SVC FAILED, DIE
	SVC	DISMISS,1	:WAIT FOR COMMANDS TO GET PROCESSED
	LA	R2,SIOIN,,	:GET ADDRESS OF INPUT CHANNEL COMMAND PROGRAM
	SVC	IO,FMBI+R1	:FORCE MOTHER BOARD INPUT
	JAL	R15,MBOOPS	:SVC FAILED, DIE
	SVC	DISMISS,1	:WAIT A SECOND FOR COMMANDS TO GET PROCESSED
	LA	R2,SIOUT0,,	:ADDRESS OF OUTPUT CHANNEL COMMAND PROGRAM
	SVC	IO,FMBO+R1	:FORCE MOTHER BOARD OUTPUT
	JAL	R15,MBOOPS	:SVC FAILED, DIE
	LHL     R3,TESTLU
        SLLS    R3,2
	L	R4,STPTIM,R3	:GET STOP TIME FOR TEST
	S	R4,STRTIM,R3	:AND SUBTRACT START TIME FROM IT
	L	R5,SLOWC,,	:GET REAL TIME
	SR	R5,R4		:SUBTRACT ANY PREVIOUS RUN TIME FROM IT
	ST	R5,STRTIM,R3	:AND STORE THE RESULT AS THE NEW START TIME
FGMAIN	SVC	FAST		:GO AWAY, FORGETTING ALL OUR REGISTERS
	lhl	r0,sioutf,,
	sis	r0,1
	jefs	chksts
	jal	r6,setsio
	lhl	r1,testlu,,
	la	r2,siout0,,
	svc	io,fmbO+r1
	jal	r15,mboops
:	LHL	R0,SIOUT4,,	:GET 4TH OUTPUT COMMAND
:	SIS	R0,1		:FIND OUT IF IT'S STILL A VIRGIN
:	JEFS	CHK12		:YES, SKIP
:	JAL	R6,SETSIO	:NO, RESET ALL OUTPUT COMMANDS
:CHK12	LHL	R0,SIOUTC,,	:GET 12TH OUTPUT COMMAND
:	SIS	R0,1		:FIND OUT IF IT'S STILL A VIRGIN
:	JEFS	CHKSTS		:YES, SKIP
:	JAL	R6,SETSIO	:NO, RESET ALL OUTPUT COMMANDS
CHKSTS	LB	R1,OLDSTS,,	:GET OLD SIO CKSUM ERR COUNT
	LB	R0,SIOSTS+3,,	:GET NEW HDLC CKSUM ERR COUNT
	LR	R2,R0		:COPY DATA
	SR	R0,R1		:SUBTRACT OLD FROM NEW
	JNFS	FGD3		:DIFFERENT ERROR COUNTS, DO SOMETHING
	J	FGMAIN
FGD3	AHI	R0,100		:GET DIFFERENCE BETWEEN OLD AND NEW COUNTS
	NHI	R0,0FF		:WRAPS FOR NEGATIVE RESULTS
	LHL	R1,TESTLU	:GET TEST LOGICAL UNIT
	SLLS	R1,2		:TIMES 4
	AM	R0,SIOBAD,R1	:STORE DIFFERENCE IN SIOBAD COUNTER.
	STB	R2,OLDSTS	:AND STORE ERROR COUNT.
	J	FGMAIN		:YES, GO BACK AND WAIT
:
:	ROUTINE TO RESET SIO OUTPUT COMMANDS
:	USES R11, AND R6 (LINK)
:
SETSIO	LIS	R11,1		:OUTPUT COMMAND
Q	EQ	0
	RE	10		:MAKE 10 OF THESE
	STH	R11,SIOUT|Q|,,
Q	EQ	Q+1
	ER
	JR	R6		:RETURN
:
:	ROUTINE TO CLEAR INPUT BUFFERS, PUT -1 IN ALL BYTE COUNTS
:	USES	R11 AND R6(LINK)
:
CLINBF	LCS	R11,1		:MAKE A -1
Q	EQ	0
	RE	10		:DO IT 10 TIMES
	STH	R11,INBUF+Q,,
Q	EQ	Q+102
	ER
	LIS	R11,0C
	LIS	R0,0
CLBF1	ST	R0,SIOSTS,R11,	:CLEAR OUT SIO STATUS AREA TOO
	SIS	R11,4
	JGBS	CLBF1
	JR	R6		:RETURN
:	CRASH RETURNS
:
:	GENERIC FAILURE RETURN ROUTINE FOR SIO SVC'S.  CRASH CODE DEPENDS UPONJ:	VALUE RETURNED IN R1 AFTER SVC FAILS.
:
MBOOPS	LR	R10,R1		:GET SVC FAILURE CODE
	EXHR	R10,R10		:MOVE IT TO LOW HALFWORD
	NHI	R10,7FFF	:KNOCK OFF HI ORDER NOISE
	SIS	R10,1
	JNFS	MBOOP2		:INVALID REGISTER CRASH?
BREGCR	JAL	R10,CRASH
	HC	0
	BC	4*0F,0D1	:REGISTER >12 SPECIFIED IN SVC (IMPOSSIBLE).
MBOOP2	SIS	R10,1
	JNFS	MBOOP3
ILUNCR	JAL	R10,CRASH
	HC	0
	BC	4*0F,0D2	:ILLEGAL LOGICAL UNIT SPECIFIED.
				:THIS SHOULD BE CAUGHT BY EITHER DDT OR THE 
				:FOREGROUND.  MACHINE VERY ILL.
MBOOP3	SIS	R10,1
	JNFS	MBOOP4
MBSYCR	JAL	R10,CRASH
	HC	0
	BC	4*0F,0D3	:MOTHER BOARD BUSY FOR 40 MICROSECONDS.
MBOOP4	SIS	R10,1
	JNFS	MBOOP5
MBUNCR	JAL	R10,CRASH
	HC	0
	BC	4*0F,0D4	:MOTHER BOARD UNAVAILABLE.
MBOOP5	SIS	R10,1
	JNFS	MBHUH
ILADCR	JAL	R10,CRASH
	HC	0
	BC	4*0F,0D5	:ILLEGAL ADDRESS IN SVC(INCOMPOSSIBLE)
MBHUH	JAL	R10,CRASH
	HC	0
	BC	4*0F,0D6	:SOME OTHER RETURN VALUE THAN DOCUMENTED
:
:	I/O QUERY SVC FAILURE IN FOREGROUND
IOQCRH	JAL	R10,CRASH
	HC	0
	BC	4*0F,0D7
:
:	DEFINE DDT CODE
:
	SEG	A.DATA
HLPMSG	SC	/SELECT ONE OF THE FOLLOWING COMMANDS."8D"8A"8A/
       	SC	/EXIt    - LOG OFF"8D"8A/
	SC	/Quit    - QUIT BACK TO DDT"8D"8A/
	SC	/Display - DISPLAY STATUS OF TEST"8D"8A/
	SC	/Help    - PRINT THIS LIST"8D"8A/
	SC	/PATtern - SELECT TEST PATTERN TO BE OUTPUT."8D"8A/
	SC	/           1 - 2047 PATTERN"8D"8A/
	SC	/           2 - ALTERNATING BIT PATTERN"8D"8A/
	SC	/           3 - USER-SUPPLIED HALFWORD DATA PATTERN"8D"8A/
	SC	/Reset   - RESET ALL COUNTS"8D"8A/
	SC	/SELect  - SELECT A LOGICAL UNIT"8D"8A/
	SC	/STArt   - START TEST"8D"8A/
	SC	/STOp    - STOP TEST"8D"8A/
	SC	/"8D"8A/
	SC	/LOGICAL UNIT NUMBERS ARE IN DECIMAL,"8D"8A/
	SC	/COUNTS ARE IN HEX, AND PERCENTS ARE IN DECIMAL"8D"8A/
	BC	0		:USED TO TERMINATE OUTPUT
	BND	2
UNKMSG	AC	/UNKNOWN /
CBPS	WC	$A 2640,5280,7920,10560,15840,18260,21120,31680,42240,52800,66360
RBPS	WC	$A 2400,4800,7200,9600,14400,16600,19200,28800,38400,48000,56000
:
:	FIRST THE MACRO CALLS
:
	SEG	A.CODE
	DS.CMD(STOP,STPTST)
	DS.CMD(STO,STPTST)
	DS.CMD(START,STRTST)
	DS.CMD(STAR,STRTST)
	DS.CMD(STA,STRTST)
	DS.CMD(SELECT,SELLU)
	DS.CMD(SELEC,SELLU)
	DS.CMD(SELE,SELLU)
	DS.CMD(SEL,SELLU)
	DS.CMD(RESET,RESCNT)
	DS.CMD(RESE,RESCNT)
	DS.CMD(RES,RESCNT)
	DS.CMD(RE,RESCNT)
	DS.CMD(R,RESCNT)
        DS.CMD(DISPLAY,DISPLAY)
        DS.CMD(DISPLA,DISPLAY)
        DS.CMD(DISPL,DISPLAY)
        DS.CMD(DISP,DISPLAY)
        DS.CMD(DIS,DISPLAY)
        DS.CMD(DI,DISPLAY)
        DS.CMD(D,DISPLAY)
	DS.CMD(?,HLPCMD)
	DS.CMD(H,HLPCMD)
	DS.CMD(HE,HLPCMD)
	DS.CMD(HEL,HLPCMD)
	DS.CMD(HELP,HLPCMD)
	DS.CMD(PATTERN,SELPAT)
	DS.CMD(PATTER,SELPAT)
	DS.CMD(PATTE,SELPAT)
	DS.CMD(PATT,SELPAT)
	DS.CMD(PAT,SELPAT)
:
:	NOW THE CODE
:
:
:		OUTSTR
:General purpose string output routine for DDT ?STAT commands.
:Outputs a series of SC's until it finds a zero byte.
:It expects to find one or more SC's defined one after the other, with a
:zero byte as a terminator.
:Register usage:
:		R4 -- Address of first SC. (clobbered on return)
:		R5 -- Scratch pad.
:		R6 -- Link Register.
:
OUTSTR	LB	R5,0,R4		:GET LENGTH OF MESSAGE
	JER	R6		:IF ZERO THEN RETURN
	SVC	TTYOUT,0,R4	:SEND THE MESSAGE
	AR	R4,R5		:ADD IN THE LENGTH
	AIS	R4,1		:PLUS ONE
	JBS	OUTSTR		:GO LOOK FOR MORE MESSAGES
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:        This routine checks to see if the slot has crashed with
:        anything other than a manual restart or power fail code and
:        if so, prints out a message containing the count and latest
:        code
:
:Routine CrashCheck;
:if CRAT[2] > 1 then outstr("Slot Crash--Count=",CRAT[0],"Code=",CRAT[2]);
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	LINK ON R7,USE R0-R6
CRSHCK	LHL	R2,CRAT+2		:if CRAT[2]
	CLHI	R2,1			:>1
	JLE	CRSHC1			:then
	LA	R1,CRMSG+$A29		:get address to put code
	LHI	R0,0250			:hex radix, 2 digits 0 fill
	JAL	R6,OUTNUM		:put it in message
	LHL	R2,CRAT			:get count
	LHI	R0,0250		:hex radix, 2 digits 0 fill
	LA	R1,CRMSG+$A20		:get where to put it
	JAL	R6,OUTNUM		:put it in message
	SVC	TTYOUT,CRMSG		:output the message
CRSHC1	J	DSTART			:and return
:	STOP COMMAND
:
STPTST	LH	R0,TESTLU	:LOAD THE TEST LOGICAL UNIT
	SVC	SYS,DISLU	:DISCONNECT THE LOGICAL UNIT
	NOP
	LIS	R0,0		:HALT THE FOREGROUND
	STH	R0,GOTEST
	J	CRSHCK		:GO LOOK FOR NEXT COMMAND
:
:	START COMMAND
:
STRTST	LH	R0,TESTLU	:GET TEST L.U. NUMBER
	JGEFS	OKSTR1		:IF LU# .GE. 0 THEN OK TO START
	SVC	TTYOUT,NOLUMS	:OTHERWISE, GRIPE
	J	CRSHCK		:AND GO BACK TO COMMAND PROMPT
OKSTR1	LH	R0,PATSEL	:DID HE SELECT A TEST PATTERN?
	JNFS	OKSTRT		:YES, START
	SVC	TTYOUT,NOPAT	:OTHERWISE, GRIPE
	J	CRSHCK		:AND GO BACK TO COMMAND PROMPT
OKSTRT	LIS	R0,1
	STH	R0,GOTEST	:START THE FOREGROUND
	J	CRSHCK		:GO LOOK FOR NEXT COMMAND
:
:	SELECT COMMAND
:
SELLU   LIS	R4,0A		:SET RADIX FOR NUMERIC INPUT
	JAL	R5,DS.NUM	:GO GET THE NUMBER
	LR	R6,R0		:COPY THE VALUE INTO R6
	LH      R8,GOTEST       :FIND OUT IF A TEST IS RUNNING
        JEFS    OKSEL           :IF NOT THEN FINE
        SVC     TTYOUT,RUNMSG   :OTHERWISE GRIPE
        J       CRSHCK          :AND GET NEW COMMAND
OKSEL	LA	R1,ATTINF	:LOAD THE ADDRESS OF THE ATTRIBUTE BUFFER
	LIS	R2,3		:REQUEST 3 BYTES
	SVC	IO,QUERY!R0,,	:QUERY THE LOGICAL UNIT
	JAL	R15,IOQCRH	:CRASH
	LB	R1,ATTINF	:GET DEVICE TYPE
	CLHI	R1,4		:SIO LINE?
	JN	NOTSIO		:NOT AN SIO LINE, BITCH
	STH	R6,TESTLU	:STORE LOGICAL UNIT NUMBER
	LB	R2,ATTINF+1	:GET LINE NUMBER
	LB	R3,ATTINF+2	:GET MOTHER BOARD DEVICE ADDRESS
	NHI	R3,0F		:ELIMINATE HIGH-ORDER NIBBLE
	SVC	TTYOUT,LUMSG	:SEND LOGICAL UNIT MESSAGE
	LR	R0,R6		:GET LOGICAL UNIT NUMBER
	LHI	R1,032A		:3 DIGITS,BLANK FILL,DECIMAL
	SVC	KIO,0A		:SEND THE NUMBER
	SVC	TTYOUT,SIOLIN	:SEND SIO LINE MESSAGE
	LR	R0,R2		:GET THE LINE NUMBER
	SVC	KIO,0A		:SEND THE NUMBER
	SVC	TTYOUT,MBMSG	:SEND MOTHER BOARD MESSAGE
	LR	R0,R3		:GET SIO BOARD NUMBER
	SVC	KIO,0A		:SEND IT
	SVC	TTYOUT,CRLF	:SEND CR AND LF
	J	CRSHCK		:GO LOOK FOR NEXT COMMAND
NOTSIO	SVC	TTYOUT,LUMSG	:SEND LOGICAL UNIT MESSAGE
	LR	R0,R6		:GET LOGICAL UNIT NUMBER
	LHI	R1,032A		:3 DIGITS,BLANK FILL,DECIMAL
	SVC	KIO,0A		:SEND THE NUMBER
	SVC	TTYOUT,NSIMSG	:SEND NOT AN SIO LINE MESSAGE
	LCS	R0,1
	STH	R0,TESTLU	:SET TEST LU TO -1 SO START CMD BITCHES.
	LHI	R0,0BEEF
	STH	R0,FPANEL	:MAKE FRONT PANEL BEEF
	J	CRSHCK		:GO LOOK FOR NEXT COMMAND
:
:	RESET COMMAND
:
RESCNT	LIS	R9,0
        LH      R10,TESTLU      :GET TEST LU NUMBER
        JGEFS   OKRES           :IF G.E. 0 THEN OK
        SVC     TTYOUT,NOLUMS   :BITCH
        J       CRSHCK          :AND GET NEXT COMMAND
OKRES   SLLS    R10,2           :MULT BY 4 FOR FULL WORD OFFSET
        ST      R9,TOTBIT,R10
        ST      R9,RECCT,R10
        ST      R9,DUPREC,R10
	ST	R9,SIOBAD,R10
        L       R9,SLOWC,,      :GET SLOWC TO RESET START AND STOP TIME 
        ST      R9,STRTIM,R10   :AND RESET IT FOR THIS TEST
        ST      R9,STPTIM,R10   :AND RESET IT FOR THIS TEST
	J	CRSHCK		:GO LOOK FOR NEXT COMMAND
:
:	DISPLAY COMMAND
:
DISPLAY	LH	R10,TESTLU	:GET TEST LU NUMBER
	JGEFS	DIS1		:IF NOT NEGATIVE, OK
	SVC	TTYOUT,NOLUMS	:GRIPE
	J	CRSHCK		: AND GET NEW COMMAND
DIS1	LHI	R0,0850		:8 DIGITS,ZERO FILL,HEX RADIX
        SLLS    R10,2           :MULT BY 4 FOR FULL WORD OFFSET
	LA	R1,CTMSG+15	:GET ADDRESS FIELD
	L	R2,RECCT,R10	:GET TOTAL BLOCKS RECIEVED
	JNFS	DIS2		:IF NON-ZERO, SKIP
	SVC	TTYOUT,NODATA	:GRIPE ABOUT NO DATA
	J	DISPLU		:AND PRINT LOGICAL UNIT AND TEST STATUS
DIS2	JAL	R6,OUTNUM	:CONVERT IT
	LHI	R0,0850		:8 DIGITS,ZERO FILL,HEX RADIX
	LA	R1,CT1MSG+15	:GET ADDRESS FIELD
	L	R2,DUPREC,R10	:GET ERROR BLOCKS RECIEVED
	JAL	R6,OUTNUM	:CONVERT IT
	LHI	R0,0850		:8 DIGITS,ZERO FILL,HEX RADIX
	LA	R1,CT2MSG+15	:GET ADDRESS FIELD
	L	R2,TOTBIT,R10	:GET TOTAL BITS RECIEVED
	JAL	R6,OUTNUM	:CONVERT IT
	LHI	R0,0850		:8 DIGITS,ZERO FILL,HEX RADIX
	LA	R1,CTAMSG+15	:GET ADDRESS FIELD
	L	R2,SIOBAD,R10	:GET TOTAL BITS RECIEVED
	JAL	R6,OUTNUM	:CONVERT IT
	LHI	R0,022A		:2 DIGITS,BLANK FILL,DECIMAL RADIX
	LA	R1,CT1MSG+20	:GET ADDRESS FIELD
	L	R3,DUPREC,R10	:GET ERROR BLOCKS RECIEVED
	LHI	R4,$A 100
	MR	R2,R4		:CALCULATE PERCENTAGE
	L	R4,RECCT,R10	:GET TOTAL BLOCKS RECIEVED
	DR	R2,R4
	LR	R2,R3		:SWITCH REGISTERS AROUND
	JAL	R6,OUTNUM	:CONVERT IT
	L	R2,STRTIM,R10	:GET TEST START TIME
	LHL	R3,GOTEST	:IS TEST RUNNING?
	JEFS	DTIM		:NO, SKIP TO GETTING STOP TIME
	L	R3,SLOWC,,	:GET SLOWC FOR CURRENT TIME
	JFS	DTIM1
DTIM	L	R3,STPTIM,R10	:GET STOP TIME FOR THIS TEST
DTIM1	SR	R3,R2		:GET RUN TIME FOR TEST
	CLHI	R3,0A		:MORE THAN 10 SEOCNDS?
	JGFS	DTIM2		:YES, SKIP ALL THIS STUFF
	LA	R4,CTMSG	:GET ADDRESS OF MESSAGE WITHOUT RUN TIME
	JAL	R6,OUTSTR	:AND PRINT IT
	J	DISPLU		:THEN GO TO DISPLAY LOGICAL UNIT SECTION
DTIM2	LA	R5,RTMSG+0C	:GET ADDRESS OF RUN TIME MESSAGE
	LIS	R4,8		:8 CHARACTER WIDE TIME STAMP
	JAL	R6,TMSTMP	:PUT TIME STAMP IN MESSAGE
	LIS	R1,0		:MAKE HIGH-ORDER REGISTER 0
	L	R2,TOTBIT,R10	:GET TOTAL BITS RECEIVED
	DR	R1,R3		:DIVIDE BY RUN TIME (QUOTIENT IN R2)
	LIS	R3,0		:ZERO THE COUNTER
DSPD	CL	R2,CBPS,R3PARE AGAINST CHECK TABLE
	JGFS	DSPD1		:IF GREATER THAN CHECK VALUE, SKIP
	LA	R1,RTMSG+23	:GET ADDRESS OF LINE SPEED MESSAGE
	L	R2,RBPS,R3	:GET "REAL" BPS VALUE
	LHI	R0,62A		:SIX DECIMAL DIGITS, BLANK FILL
	JAL	R6,OUTNUM	:PUT IT IN THE MESSAGE
	LA	R4,RTMSG	:GET THE ADDRESS OF THE WHOLE MESSAGE
	JAL	R6,OUTSTR	:AND WRITE IT
	J	DISPLU
DSPD1	AIS	R3,4		:BUMP COUNTER
	CLHI	R3,2C		:HAVE WE FOUND THE END OF THE TABLE?
	JL	DSPD		:NO, REPEAT
	LIS	R1,0		:MAKE HIGH-ORDER REGISTER 0
	LHI	R3,$A 100	:GET A ROUNDING FACTOR
	DR	R1,R3		:DIVIDE BPS BY ROUNDING FACTOR(QUOTIENT IN R2)
	MR	R1,R3		:AND MULTIPLY IT AGAIN
	LA	R1,RTMSG+23	:GET ADDRESS OF LINE SPEED MESSAGE
	LHI	R0,62A		:SIX DIGITS, DECIMAL, BLANK FILL
	JAL	R6,OUTNUM	:PUT IT IN THE MESSAGE
	LA	R4,RTMSG	:LOAD THE ADDRESS OF THE COUNT MESSAGE
	JAL	R6,OUTSTR	:PRINT IT
DISPLU	SVC	TTYOUT,LUMSG	:PRINT "LOGICAL UNIT"
	LHL	R0,TESTLU	:GET LOGICAL UNIT NUMBER
	LHI	R1,032A		:3 DIGITS,BLANK FILL, DECIMAL
	SVC	KIO,0A		:PRINT IT
	SVC	TTYOUT,SLMSG	:PRINT "SIO LINE"
	LB	R0,ATTINF+1	:GET LINE NUMBER
	SVC	KIO,0A		:PRINT IT
	SVC	TTYOUT,MBMSG	:PRINT "MOTHER BOARD"
	LB	R0,ATTINF+2	:GET MB ADDRESS
	NHI	R0,0F		:REMOVE HIGH NIBBLE
	SVC	KIO,0A		:PRINT IT
	SVC	TTYOUT,CRLF	:SEND CRLF COMBO
	SVC	TTYOUT,PATMSG	:PRINT "TEST PATTERN"
	LH	R0,PATSEL	:GET PATTERN SELECTION
        JNFS    DISP0           :AT LEAST THEY'VE SELECTED A PATTERN
        SVC     TTYOUT,NOPAT    :NO PATTERN SELECTED, TELL THEM
        J       DISR
DISP0	CLHI	R0,1
	JNFS	DISP1		:NOT 2047
	SVC	TTYOUT,P2047	:PRINT "2047"
	J	DISR		:JUMP TO RUN STATE DISPLAY
DISP1	CLHI	R0,2
	JNFS	DISP2		:NOT ALT EITHER
	SVC	TTYOUT,PALT	:PRINT "ALT"
	JFS	DISR		:JUMP TO RUN STATE DISPLAY
DISP2	SVC	TTYOUT,PUSER	:PRINT "USER SELECTED PATTERN"
	LHL	R0,OUTBUF+2,,	:GET PATTERN
	LHI	R1,0450		:4 DIGIT HEX RADIX ZERO FILL
	SVC	KIO,0A		:PRINT IT
	SVC	TTYOUT,CRLF	:FOLLOWED BY CRLF
DISR	LH	R2,SIOSTS+8,,	: GET INTERRUPT STATUS
	JE	NOPROB		: NO INTERUPT
	SRHLS	R2,$A12		: PUT CODE IN LO NIBBLE
	LHI	R0,22A		: 2 DIGITS, DECIMAL, BLANK FILL
	LA	R1,INTMSG+$A20	: ADDRESS
	JAL	R6,OUTNUM	: STUFF IT IN
	LA	R5,INTMSG+$A24	:  ADDRESS OF TIME STAMP
	L	R2,FASTC,,	: GET CURRENT TIME
	S	R2,SIOSTS+0A,,	: MINUS TIME OF INTERRUPT
        LHI	R4,$A600	: FASTC DIVISOR
	DR	R2,R4
	LIS	R4,8		: 8 CHARACTER TIME STAMP
	JAL	R6,TMSTMP	: PUT IT IN
	SVC	TTYOUT,INTMSG	: DISPLAY MESSAGE
	LIS	R0,0
	STH	R0,GOTEST	:STOP THE TEST
NOPROB	LH	R0,GOTEST	:FIND OUT IF TEST IS RUNNING
	JNFS	DISR1		:IF YES, SKIP
	SVC	TTYOUT,STPMSG	:INDICATE TEST STOPPED
	J	CRSHCK		:ALL DONE, GET NEXT COMMAND
DISR1	SVC	TTYOUT,RUNMSG	:INDICATE TEST RUNNING
	J	CRSHCK		:ALL DONE, GET NEXT COMMAND
:
:	HELP COMMAND
:
HLPCMD	LA	R4,HLPMSG	:LOAD THE ADDRESS OF THE HELP MESSAGE
	JAL	R6,OUTSTR	:PRINT IT
	J	CRSHCK		:AND GO BACK FOR NEXT COMMAND
:
:	PATTERN COMMAND
:
SELPAT	LIS	R4,0A		:SET INPUT RADIX TO DECIMAL
	JAL	R5,DS.NUM	:GET NUMBER
	LH	R8,GOTEST	:CHECK IF TEST RUNNING
	JEFS	SLPAT1		:GOOD, NO TEST RUNNING
	SVC	TTYOUT,RUNMSG	:BITCH IF USER RUNNING A TEST ALREADY
	J 	CRSHCK		:AND GET NEXT COMMAND
SLPAT1	CLHI	R0,1		:2047 PATTERN?
	JE	G2047		:IF SO, GO GENERATE IT
	CLHI	R0,2		:ALTERNATING BIT PATTERN?
	JE	GNALT		:IF SO, GO MAKE IT
	CLHI	R0,3		:USER SELECTED PATTERN?
	JEFS	USPAT		:IF SO, GO GET IT
	SVC	TTYOUT,BADPAT	:BAD PATTERN, BITCH
	J	CRSHCK		:GET NEXT COMMAND
:USER SUPPLIED PATTERN
USPAT	STH	R0,PATSEL	:STORE THE PATTERN SELECTION FOR LATER
	SVC	TTYOUT,ENPAT	:ASK HIM TO TYPE PATTERN
	LHI	R4,10		:SET INPUT RADIX TO HEX
	JAL	R5,DS.NUM	:GO GET THE PATTERN
	LR	R1,R0		:COPY IT
	CLI	R0,0FFFF	:SEE IF TOO BIG
	JLEFS	USPAT1		:IF NOT, THEN KEEP GOING
	SVC	TTYOUT,BADPAT	:OTHERWISE, BITCH
	J	CRSHCK		:AND GET A NEW COMMAND
USPAT1	EXHR	R1,R1		:MOVE HALFWORD TO HIGH POSITION
	OR	R0,R1		:MAKE A FULL WORD
	LIS	R1,2		:SET INDEX TO BEGINNING OF BUFFER
USPAT2	ST	R0,OUTBUF,R1,	:STORE INTO BUFFER
	AIS	R1,4		:INCREMENT INDEX
	CHI	R1,102		:ARE WE DONE?
	JLBS	USPAT2		:IF NOT, DO IT AGAIN
	J	CRSHCK		:OTHERWISE, GET A NEW COMMAND
G2047	STH	R0,PATSEL	:STORE PATTERN SELECTED FOR LATER USE
	LI	R3,0A6600000	:LOAD INITIAL PATTERN
	LHI	R5,10		:SET INDEX PAST SYNC PATTERN
G2047A	LIS	R4,0		:CLEAR BIT MASK
	RBT	R5,OUTBUF,,	:RESET CURRENT BIT
	SLLS	R3,1		:SHIFT PATTERN TO GET HIGH-BIT INTO CARRY
	JNCFS	G2047B		:IF HIGH ORDER BIT IS 0, SKIP
	SBT	R5,OUTBUF,,	:ELSE SET THE CURRENT BIT
	LI	R4,40000000	:SET HIGH ORDER BIT MASK
G2047B	XR	R4,R3
	SLLS	R4,2		:GET RESULT INTO CARRY BIT
	JNCFS	G2047C		:IF 0, THEN SKIP
	OI	R3,00200000	:ELSE SET NEW LOW-ORDER BIT
G2047C	AIS	R5,1		:BUMP BIT INDEX
	CHI	R5,810		:ARE WE DONE?
	JN	G2047A		:NO, DO IT AGAIN
	J	CRSHCK		:YES, GET NEXT COMMAND
GNALT	STH	R0,PATSEL	:STORE PATTERN SELECTED FOR LATER USE
	LIS	R2,2		:SET INDEX TO FIRST H/W PAST SYNC PATTERN
	LI	R3,55555555	:GET DATA PATTERN
GNALT1	ST	R3,OUTBUF,R2,	:SHOVE IT IN
	AIS	R2,4		:INCREMENT INDEX FOR NEXT FULL WORD
	CHI	R2,102		:CHECK TO SEE IF OUTBUF HAS BEEN FILLED
	JLBS	GNALT1		:IF NOT, LOOP
	J	CRSHCK		:ALL DONE, GET NEXT COMMAND
        END
'2+2‚