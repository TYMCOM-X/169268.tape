
	SUBTTL	ASYNC

:		  *    **** *   * *   *  ***
:		 * *  *      * *  **  * *   *
:		*****  ***    *   * * * *
:		*   *     *   *   *  ** *   *
:		*   * ****    *   *   *  ***

: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source  code  listing  constitutes  the proprietary   **
: **  property of MDC-TYMNET.  The recipient, by receiving this   **
: **  program listing, agrees that neither this listing nor the   **
: **  information disclosed herein nor any part thereof shall be  **
: **  reproduced or transferred to other documents or used or dis-**
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by MDC-TYMNET. **
: ******************************************************************

::#####################################################################
::
::	MODULE:		A S Y N C
::
::	INTRODUCTORY REMARKS:
::
::	The Standalone CONSAT is a hybrid product consisting of the
::	environment-independent CONSAT code (which is common to both
::	standalone and ISIS configurations) and the node code which
::	incorporates the environment-dependent portion of the CONSAT
::	under the SOLOCS switch.  In the following comments, the terms
::	"CONSAT" and "CONSAT proper" refer to the environment-independent
::	part of the code.  Everything else is ours.
::
::	The ASYNC module contains the bulk of the environment-dependent 
::	code for the Standalone CONSAT.  Unfortunately and unavoidably,
::	there are SOLOCS-switched bits and pieces of code scattered
::	throughout other modules.  Our code performs two general types
::	of functions:
::
::		1) Scheduling and calling the async periodic processes
::			(interrupt-level processing is handled entirely by
::			the microcode), and
::
::		2) Interfacing between the CONSAT proper and the 
::			environment-dependent functions of the node code
::			(e.g., circuit-building and -teardown, WCI/GCI,
::			hardware drivers).
::
::	The CONSAT proper performs all the high-level logical functions
::	associated with virtual-terminal support in a Tymsat, as well
::	as such special capabilities as PVC, MPVC, LISA, and port-addres-
::	sability.  Very little of our code knows or cares about these
::	things.  Typically, the sequence for performing a specific
::	function (e.g., outputting a character from a buffer to a 
::	terminal) goes something like this:
::	
::		1) Our code (in this case the async polling process)
::			determines that a character is in the buffer and
::			the terminal (i.e., the async ring) is ready to
::			receive it.
::
::		2) We call the CONSAT output processor which has been
::			assigned to the port by the CONSAT proper (based on
::			virtual characteristics of the port which we know
::			nothing about).
::
::		3) The CONSAT output processor does what ever it has to
::			for the type of terminal involved and eventually calls
::			one or more of our interface routines -- e.g., GETCHR
::			to fetch a character from a buffer, APUTCH to put the
::			character into the async ring.
::
::		4) The CONSAT eventually exits back to the caller (us),
::			and so life goes on.
::
::	A few points about this interaction, some of which may be self-
::	evident:
::
::		1) The CONSAT never directly calls a regular node code
::		routine (e.g., GCI).  It will only call one of the 
::		special interface routines in ASYNC (e.g., GETCHR)
::		which in turn do the calls to the appropriate
::		node code functions.  All passing of data in these
::		exchanges is done through registers, and our code
::		must obey the rules set by the caller (the CONSAT).
::		Needless to say, the CONSAT never accesses our privi-
::		leged code directly.  All SVC calls are ours.
::
::		2) Data passes transparently as far as our code is
::		concerned.  Any code translation required is done
::		by the CONSAT and we couldn't care less.  Control
::		codes (virtual-terminal codes, network control
::		characters) are our responsibility.  The CONSAT
::		has its own set of 1-byte control codes called
::		"signals".  These signals are the only control codes
::		the CONSAT will send to or accept from us.  Therefore,
::		we have to perform the necessary translation in both
::		directions (see PUTSIG and GETCHR).  Usually these
::		translations are fairly simple (1-to-1) but there
::		are annoying exceptions.
::
::		3) Most of what we and the CONSAT need to know about an
::		active port is contained in or accessible through 
::		the port-table (.PTABL).  The port-table begins at
::		PTBASE (currently 40000x in our environment), but it
::		may be moved if necessary by redefining PTBASE since
::		the CONSAT knows to look there for it.  Other variable
::		data symbols which are referenced by the CONSAT must be
::		assembled at or below 3FFFx (SEG0) since the CONSAT uses
::		the RX1 instruction format whenever possible.  This is why
::		our SEG0 storage allocations are split between the EQUATE
::		and DATA modules.  The CONSAT assembles its SEG0 area
::		between EQUATE and DATA, and we do a check in ASYNC to
::		make sure it hasn't assembled past the limit (see LOWSG0).
::
::	Register conventions (and names) peculiar to the CONSAT:
::		R1 (RBC) - character register
::		R2 (RBP) - buffer index register
::		R7 (RCH) - link register 
::		R8 (RBF) - link register 
::		R10 (RLINK) - polling process/port filter link register
::		R12 (RPI) - pointer to port descriptor
::		R13 (RP2, PN2) - 2 * port number
::		R14 (RP, PN) - port number
::
::	The following permuter-table/attention-flag-arrays are used
::	by the CONSAT and ASYNC:
::		ASYTAB/ASYFLG - Point to the async ports.  ASYZFL=40x.
::		TPTTAB/TOPORT - Same as ASYTAB/ASYFLG (CONSAT's name
::			for them.
::		ALMTAB/ALMFLG - Point to the virtual login port.  This
::			is an arbitrary channel number assigned to a 
::			port in login mode.  The supervisor uses this
::			number, rather than the actual port number, to
::			process circuit-building requests.  This enables
::			us to send a new login for a port without having
::			to wait for and existing circuit to that port to
::			be completely zapped.  Used in conjunction with
::			ANITAB/ANIFLG.  ALMZFL=ASYZFL + # of async ports.
::		ANITAB/ANIFLG - Point to virtual login port (input side--
::			i.e., toward the supervisor via LOGGER).  Used
::			in conjunction with ALMTAB/ALMFLG to process
::			logins.  ANIZLF=ANIZFL + # of login ports.
::		GLGTAB/GOLOG  - Used by the CONSAT for ports in login mode
::			to flag ports which are ready to transmit login data.
::			GLGZFL=ANIZFL + # of login ports.
::		TLGTAB/TOLOG - Used by CONSAT to connect ports to its login
::			process.  TLGZFL=GLGZFL + # of login ports.
::
::	The ASYNC module is divided into several sections:
::		1) Variable data storage areas (segments 0 and 4),
::		2) Fixed data (tables) (segment 1),
::		3) Initialization and periodic logic, and
::		4) Interface routines, which for the most part
::			are called only by the CONSAT proper.
::
::	You will find the following assembly switches scattered
::	throughout the following code:
::
::		SOLOCS:	SOLO CONSAT assembled.  I.e., everything
::			in ASYNC and bits and pieces of code in 
::			other modules.
::		NUMPRN:	Number of (high-speed) printers, for code
::			relating to printer support only.
::		NSPORT: Number of SIO async ports (not yet supported).
::		PVC:	PVC ports assembled.
::		MPVC:	Multiplexed PVC support.
::		BAUDR:	Code for maximum async terminal speed supported
::			(2 = 4800 baud, 0 = 1200 baud).
::		LOWSPD:	50 BAUDOT support (only if BAUDR=0).
::
::	Finally, a word about maintaining and modifying SOLOCS code.
::	Since the CONSAT proper is developed and maintained by another
::	group, it is going to be important to synchronize changes made
::	to the CONSAT proper with changes made to our code.  It is
::	fervently to be hoped that most enhancements to the CONSAT will
::	be downwardly compatible with our code, but we won't always
::	be so lucky.  Every new release of the CONSAT will have to be
::	tested and certified for compatibility with our code and will
::	require a new release of our code, even if we make no changes.
::	This because, even though it's a hybrid, the Standalone CONSAT
::	will be a separate product with its own identity (i.e., product
::	ID and version number).
::
::#####################################################################

	IF	1-KILLIT	:To assemble or not to assemble, that is the ?

	IF	SOLOCS	:This switch governs everything in ASYNC.

:	The following controls which versions of the CONSAT we allow
:	ourselves to be assembled with.
CS.V0	EQ	$A 304	:standard consat source for Q2, 84
CS.V1	EQ	$A 305	:betatest version to address MPVC assembly error
CS.V2	EQ	$A 400	:consat pad version
CS.NVN	EQ	3	:NUMBER OF VALID CONSAT VERSIONS(for 5.07)###jhl

	if	1-labtst	:allow only the versions in our list
	IF	(\CS.VER)&(\CS.REV)
Q	EQ	0
CS.VER	EQ	CS.VER*$A100+CS.REV
CSV.OK	EQ	0
	RE	CS.NVN

	IF	((CS.VER-CS.V|Q|)&7FFFFFFF)	:test for inequality
	ELSE	:not ((CS.VER-CS.V|Q|)&7FFFFFFF):equality
CSV.OK	EQ	1
	EI	:((CS.VER-CS.V|Q|)&7FFFFFFF)

Q	EQ	Q+1
	ER

	else	:labtst
	IF	CS.VER-CS.V0	:allow any version beyond our lowest
CSV.OK	EQ	1
	ELSE	:CS.VER =< CS.V0	:disallow only the old versions
	EI	:test on CS.VER
	ei	:labtst

	IF	1-CSV.OK
KILLIT	EQ	1
	REMARK	%VERSION 
	NUMBER	$A CS.VER
	REMARK	 OF THE CONSAT HAS NOT BEEN CERTIFIED FOR %
	REMARK	THIS VERSION OF T-II NODE CODE.%
	EI
	EI

	ENDMO.(CONSAT)	:Gather memory utilization stats for preceding
			:CONSAT modules. A kludge. Since we can't do this
			:for individual CONSAT modules, we do it here
			:for the lot of them.

	BEGMO.(ASYNC)	:Init memory stats for ASYNC.

	SUBTTL	ASYNC (VARIABLE DATA AREAS)::*

RBP	EQ	2	:Register definition. Necessary because CONSAT
			:kills RBP, then GL's it.

:Kill some symbols which were GL'd by CONSAT but aren't used in SOLO.
	KILL	TAM,A.DAT

	SEG.(0)		:Variable data storage
			:We are now somewhere in SEG0 below 3FFF (we hope).

LOWSG0	HS	0	:End of segment 0 area used by CONSAT proper,
			:must be less than 4000x, else kill assembly.
	IF	1-KILLIT
	KILLER(.-3FFE)	:Set KILLIT if true.
	IF	KILLIT
	REMARK	%!!!SOLO CONSAT assembly too large.
	REMARK	%!!!Please contact T-II Node Code Unit for advice.%
	EI	:KILLIT
	EI	:1-KILLIT

	ORG	NCS0ND	:Go back to where node code left off in SEG0.

:	undistinguished (RX3 addressed) data area for solo consat

ESTSRC	HS	1		:cell for noting if we came from PSTATE###jhl
ESTPST	EQ	1		:bit set in R5 if called from PSTATE
F.FLSH	HS	1		:bit array for printer ports to force flush
P.FLSH	HS	1		:bit array for printer ports to flush
ASPFLG	HS	NPGRP		:Working copy of ASYFLG for async polling
				:loop (ASYPOL) ###LSH

	IF	SCBSYO
BUSY.T	HS	1		:temp storage to reset serviced bits
	EI	:SCBSYO
	IF	TELEX
BKCBSV	WS	1
BRKTHD	EQ	18		:number of breaks to keep on hand (tune this)
	EI	:TELEX
	IF	NMPVC
SUBSTB	HS	(NANIPT+0F)/10	:bit for each login channel.
				:Set when MPVC subport begins to login
				:through pseudo port.  This is the
				:abandoned login channel.
SBB	WS	2*NCIRCS
LOGRST	HS	NGRP		:save space for LOGING while M.MUX runs
M.ACSV	WS	10		:SAVE AREA FOR M.SACT
ASNPUT	HS	NMPVC		:PHYSICAL PORT # FOR PSEUDO PORT
MPINVC	WS	NMPVC		:SESSION INVOICE NUMBER
	EI	:NMPVC

	IF	NUMPRN		:only if printer
	DEFAULT(PRBFSZ,96)
PBFPN	HS	NUMPRN
PRBFFR	HS	(NUMPRN*PRBFSZ)/2
PFLSAV	HS	2
SAVER9	HS	NUMPRN*2
	EI	:NUMPRN

ENDZRO	WS	0	:End of CONSAT seg0 storage that should be 
			:initialized to 0.  ***Must be WS -- see XIZASY.

	LO	DATA	:CONSAT's data module
:	GL	LOGING

	SUBTTL	ASYNC (FIXED TABLES AND ARRAYS)::*

	SEG.(A.CODE)	:CONSAT code segment (SEG1)

ABRT	HS	0	:CONSAT ABORT MACRO JAL'S HERE ON R10
	CRASH.(.CSCRS)

::*	.PTP.:	Port Table Pointers
::		A HW entry for each async port, points to the port's
::		entry in .PTABL (PTBASE offset).

.PTP.	HS	0
Q	EQ	0
	RE	NPORT			:For each port
	HC	Q*.PTLEN+(.PTABL-PTBASE)
Q	EQ	Q+1
	ER	:NPORT

::*	VIDG:	Baud rate index table
::	=============================
::		A byte table of baud-rate idices (HO nibble is input,
::		LO  nibble is output) which is used by AGETIB to set up
::		a port's IBRATE and OBRATE based on the rate at which the
::		TID is received.  The VIDG table varies depending on the
::		value of BAUDR (0=1200 baud max., 2=4800 baud max.).
::		Table elements range from 00 to AA.  Invalid rates are
::		marked with FF.  The baud-rate indices derived from this
::		table are used by the async microcode to clock bits to and
::		from the terminal.
::

	IF	BAUDR-1			:4800 baud max
VIDG	BC	0BB			:4800 
	BC	0AA,0AA			:2400
	BC	55,55			:1200
	BC	0FF,0FF,0FF,0FF
	BC	0FF,0FF,0FF,0FF,0FF
	BC	22,22,22		:300
	BC	0FF,0FF,0FF,0FF,0FF
	BC	0FF,0FF,0FF,0FF,0FF
	BC	0FF,0FF,0FF,0FF,0FF
	BC	0FF,0FF,0FF,0FF

	ELSE		:not 4800 baud
	IF	BAUDR	:2400 baud max (not commonly used)
VIDG	BC	0AA			:2400 
	BC	55,55			:1200
	BC	0FF,0FF,0FF
	BC	22,22,22		:300
	BC	0FF,0FF,0FF,0FF,0FF
	BC	0FF,0FF,0FF,0FF,0FF
	BC	0FF,0FF,0FF,0FF,0FF
	BC	0FF,0FF,0FF,0FF,0FF
	BC	0FF,0FF,0FF,0FF,0FF

	ELSE		:Not 4800 and not 2400 baud
VIDG	BC	55,55			:1200 baud
	BC	22,22,22		:3,4, or 5 sample for 300 baud
	BC	0FF,0FF
	BC	77,77,77		:14.7 CPS
	BC	0FF,0FF,0FF,0FF
	BC	11,11,11		:15 CPS
	BC	0FF,0FF,0FF,0FF
	BC	0FF,0FF,0FF,0FF
	BC	0FF,0FF,0FF,0FF
	BC	0,0,0,0,0,0,0		:10 CPS
	BC	0FF

:	Character length mask for async receiver		###jhl###wjl
BTCHAR	BC	0FF,0FF,0FF,0FF,0FF,0FF,0FF,03F	:index 07 is 134.5 baud 2741
	BC	0FF,0FF,0FF,0FF,0FF,01F,0FF,0FF	:index 0D is 50 baud BAUDOT
	EI	:BAUDR
	EI	:BAUDR-1

::*	SPED.A: valid-SPEeD-indices-for-Async-ports array
::	=================================================
::		A bit array (different for each value of BAUDR)
::		which flags valid async port speed indices (a set bit
::		means the corresponding speed index is valid).  This
::		array gets copied into A.SPED at initialization for
::		use by the CONSAT proper.
::
SPED.A	HS	0		:Bit array flags valid port speed indices
	IF	BAUDR-1		:4800 BAUD
	HC	2CF0		:VALID INDICES = 2,4,5,8,9,A,B
	ELSE	:NOT 4800 BAUD
	IF	BAUDR		:2400 BAUD
	HC	28E0		:VALID INDICES = 2,4,8,9,A
	ELSE	:NOT 2400 BAUD
	IF	LOWSPD		:LOWSPEED
	HC	0FFC7		:VALID INDICES = 0,1,2,3,4,5,6,7,8,9,B,C,D
	ELSE	:NOT LOWSPEED	:1200 BAUD
	HC	0FFC0		:VALID INDICES = 0,1,2,3,4,5,6,7,8,9
	EI	:LOWSPD
	EI	:BAUDR
	EI	:BAUDR-1

	HC	0,0,0		:Padding???


::*	CONSIG: CONsat-SIGnal table	CONSAT to NETWORK translator
::	===========================
::		A HW table indexed by CONSAT signal number, yields
::		the corresponding network character pair (in reverse-
::		byte order).  E.g., a 01FB (break begin) is stored in
::		the table as 0FB01.  This just to save us an EXBR when
::		translating.  If the HO byte of the table entry is 0,
::		the signal translates to a single byte rather than a
::		pair (e.g., 0006 = 06 = red ball).
::		When the CONSAT proper calls PUTSIG, we use this table
::		to translate the CONSAT signal number into something
::		we understand before putting it into a buffer.
::		A table entry of 0 means the signal is not legal
::		for PUTSIG and we will crash.
::
CONSIG	HS	0		:CONSAT SIGNAL NUMBER
	HC	0		:00 - ENTER TID MODE (ILLEGAL)
	HC	0		:01 - BAUD RATE DETECTED (ILLEGAL)
	HC	0FB01		:02 - BREAK BEGIN
	HC	0FA01		:03 - BREAK END
	HC	0		:04 - ENTER DATA MODE
	HC	0		:05 - DISCONNECT
	HC	0		:06 - SET DELAY
	HC	0		:07 - REPEAT DATA CHARACTER
	HC	00007		:08 - ENTER DEM (NOT A PAIR)
	HC	00004		:09 - LEAVE DEM (NOT A PAIR)
	HC	0F001		:0A - HANG
	HC	0F101		:0B - SUPER-HANG
	HC	00103		:0C - ZAPPER
	HC	00803		:0D - GOBBLER
	HC	00006		:0E - RED BALL (NOT A PAIR)
	HC	00005		:0F - GREEN BALL (NOT A PAIR)
	HC	0FE01		:10 - ORANGE BALL
	HC	0FF01		:11 - YELLOW BALL
	HC	0FC01		:12 - GREY BALL
	HC	0FD01		:13 - BLACK BALL
	HC	0F201		:14 - ENTER TRANSPARENCY
	HC	0F301		:15 - LEAVE TRANSPARENCY
	HC	0F401		:16 - ENTER AODM
	HC	0F501		:17 - LEAVE AODM
	IF	TELEX
	HC	0F601		:18 - SIIX	###wjl
	HC	0F701		:19 - TIIX	###wjl
	ELSE
	HC	0,0
	EI	:TELEX
	HC	0,0,0,0,0,0	:1A-1F - RESERVED
:	FIELD PARAMETERS
	HC	03001,09301	:20-21 - SET/QUERY INPUT BAUD RATE
	HC	08001,09801	:22-23 - SET/QUERY OUTPUT BAUD RATE
	HC	07001,09701	:24-25 - SET/QUERY PARAMETER A
	HC	06001,09601	:26-27 - SET/QUERY PARAMETER B
	HC	05001,09501	:28-29 - SET/QUERY PARAMETER C
	HC	04001,09401	:2A-2B - SET/QUERY PARAMETER D
	HC	0,0,0,0		:2C-2F - RESERVED
:	BIT PARAMETERS
	HC	0C001,0A001	:30-31 - SET/QUERY ECHO CONTROL
	HC	0C201,0A201	:32-33 - SET/QUERY ECHO CONTROL-I
	HC	0D001,0B001	:34-35 - SET/QUERY ECHO CONTROL-H
	HC	0C401,0A401	:36-37 - SET/QUERY ECHO LF ON CR
	HC	0C601,0A601	:38-39 - SET/QUERY ECHO CR/RUB ON LF
	HC	0CE01,0AE01	:3A-3B - SET/QUERY CR DELAY
	HC	0CA01,0AA01	:3C-3D - SET/QUERY PARITY
	HC	0C801,0A801	:3E-3F - SET/QUERY HALF DUPLEX
	HC	0CC01,0AC01	:40-41 - SET/QUERY X-ENABLE
	HC	0D201,0B201	:42-43 - SET/QUERY REVERSE X-ENABLE
	HC	0D401,0B401	:44-45 - SET/QUERY KATAKANA
	HC	0D601,0B601	:46-47 - SET/QUERY TERMINATE-OUTPUT-ON-BREAK
	HC	0D801,0B801	:48-49 - SET/QUERY ECHO-ESC
	HC	0DA01,0BA01	:4A-4B - SET/QUERY Q-MODE
	HC	0,0,0,0		:4C-4F - RESERVED
 
::*	SIGDAT: consat-SIGnals-associated-DATa array
::	============================================
::		A bit array indexed by CONSAT signal number.  Some CONSAT
::		signals have associated data which are passed separately.
::		This data must be ORed into the LO byte of the corresponding
::		01-character-pair during translation.  SIGDAT tells us
::		whether to expect additional data for a given signal.
::
SIGDAT	HC	$2 0100001100000000	:1-bits correspond to CONSAT
	HC	$2 0000000000000000	:signal numbers which have
	HC	$2 1010101010101010	:additional data (passed to
	HC	$2 1010101010101010	:PUTSIG in R1).
	HC	$2 1010101010101010


::*	PFXSIG: PreFiX-code-to-consat-SIGnal translation table
::	=================================================
::	NETWORK to CONSAT translator
::		A HW table indexed by
::		the 2nd byte of a 01-character-pair, yields the CONSAT
::		signal number (HO byte) and associated data (if any, LO
::		byte).  A table entry of 0 means the signal is illegal
::		and we will crash.  A table entry of -1 means the signal
::		cannot be translated 1-to-1 into a CONSAT signal and
::		special handling is required (i.e., it must be translated
::		into 2 or more CONSAT signals).  The latter is a pain
::		in the algorithm, but there are still hosts in the network
::		which use obsolete 01-prefix codes.  See CPEEK1 and GETCH1
::		for useage.
::
PFXSIG	HS	0
	RE	10
	HC	0FFFF		:0100 thru 010F are obsolete signals
	ER			:which must be translated into other
				:01-pairs.
	RE	10
	if	0		:don't crash on obsolete pairs--ignore them
	HC	0		:0110 thru 011F???
	else	:0
	HC	0FFFF		:CR delay and input baud rate (obsolete)
				:(refer to TYMNET circuit protocol
				:document -- appendix I).###jhl
	ei	:0
	ER

	RE	10
	HC	0		:0120 thru 012F??? (unused)
	ER

	HC	2000,2001,2002,2003,2004,2005,2006,2007 :30-3F - SET INPUT
	HC	2008,2009,200A,200B,200C,200D,200E,200F :	BAUD RATE
	HC	2A00,2A01,2A02,2A03,2A04,2A05,2A06,2A07 :40-4F - SET
	HC	2A08,2A09,2A0A,2A0B,2A0C,2A0D,2A0E,2A0F :	PARAMETER D
	HC	2800,2801,2802,2803,2804,2805,2806,2807 :50-5F - SET
	HC	2808,2809,280A,280B,280C,280D,280E,280F :	PARAMETER C
	HC	2600,2601,2602,2603,2604,2605,2606,2607 :60-6F - SET
	HC	2608,2609,260A,260B,260C,260D,260E,260F :	PARAMETER B
	HC	2400,2401,2402,2403,2404,2405,2406,2407 :70-7F - SET
	HC	2408,2409,240A,240B,240C,240D,240E,240F :	PARAMETER A
	HC	2200,2201,2202,2203,2204,2205,2206,2207 :80-8F - SET OUTPUT
	HC	2208,2209,220A,220B,220C,220D,220E,220F :	BAUD RATE
	HC	0000,0000,0000,2100,2B00,2900,2700,2500 :90-9F - QUERY FIELD
	HC	2300,0000,0000,0000,0000,0000,0000,0000 :	PARAMETERS
	HC	3100,3100,3300,3300,3700,3700,3900,3900 :A0-BF - QUERY BIT
	HC	3F00,3F00,3D00,3D00,4100,4100,3B00,3B00 :	PARAMETERS
	HC	3500,3500,4300,4300,4500,4500,4700,4700 :
	HC	4900,4900,4B00,4B00,0000,0000,0000,0000 :
	HC	3000,3001,3200,3201,3600,3601,3800,3801 :C0-DF - SET BIT
	HC	3E00,3E01,3C00,3C01,4000,4001,3A00,3A01 :	PARAMETERS
	HC	3400,3401,4200,4201,4400,4401,4600,4601 :
	HC	4800,4801,4B00,4B01,0000,0000,0000,0000 :
	HC	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0		:E0-EF - ILLEGAL
	HC	0A00		:F0 - HANG
	HC	0B00		:F1 - SUPER HANG
	HC	1400		:F2 - ENTER TRANSPARENCY
	HC	1500		:F3 - LEAVE TRANSPARENCY
	HC	1600		:F4 - ENTER AODM
	HC	1700		:F5 - LEAVE AODM
	IF	TELEX		:###wjl
	HC	1800		:F6 - SIIX
	HC	1900		:F7 - TIIX
	ELSE
	HC	0000
	HC	0000
	EI	:TELEX
	HC	0000		:F8 - ENTER NETWORK COMPRESASION
	HC	0000		:F9 - LEAVE NETWORK COMPRESSION
	HC	0300		:FA - BREAK END
	HC	0200		:FB - BREAK BEGIN
	HC	1200		:FC - GREY BALL
	HC	1300		:FD - BLACK BALL
	HC	1000		:FE - ORANGE BALL
	HC	1100		:FF - YELLOW BALL


	SUBTTL	ASYNC (INITIALIZATION AND PERIODIC CODE)::*

::*	XIZASY:	Xray-InitialiZation-of-ASYnc
::	====================================
::	Called by: XRAY 'IZ' command.
::	Returns:	To [R10].
::	Reg Usage: Various. Expects nothing. Returns nothing. Clobbers many.
::	Calls:	See IZASYN below.
::		The XRAY 'IZ' command initializes the async stuff on a
::		machine -- in effect "crashing" the CONSAT without
::		crashing the node code.  Here we zero out the part of SEG0
::		that belongs to the CONSAT, then fall through to IZASYN.
::		Use of the IZ command should be considered a last resort
::		in trying to clear up an async problem.  The 'HP" (Hang
::		Port) command should be used to deal with individual ports
::		which may have achieved undocumented states.
::
XIZASY	HS	0	:Entry point for initialization by XRAY 'IZ'
	LHI	R1,(ENDZRO-BEGZER-4)	:Range of CONSAT seg 0 storage
	LIS	R0,0		:to be 0ed.
XIZAS0	ST	R0,BEGZER,R1	:We can do it a FW at a time to save time.
	SIS	R1,4		:
	JGEBS	XIZAS0		:

::*	IZASYN:	InitialiZe-ASYNc
::	========================
::	Called by: G250MZ (first iteration of quarter-second logic).
::			Also, fall through from XIZASY.
::	Returns:	To [R10].
::	Reg Usage: Various. Expects nothing. Returns nothing. Clobbers many.
::	Calls:	OOS(R6), SVC13(initialize async ring), SNDRTS(R8), PVCIZ
::			(R0)
::		Initializes everything associated with async.  Called from
::		node initialization.  We also fall through to here from
::		XIZASY.  Initialization includes clearing some memory,
::		copying some stuff (text-strings and bit arrays) from
::		protected to unprotected memory, initializing some cells
::		to their non-zero default values, initializing the async
::		ring and microcode parameters (SVC13), etc.
::

IZASYN	HS	0	:Entry point for initialization by node code.
	IF	1-NOSEG		:INIT IN NODE INIT##AL
	LHI	R1,S4SIZE-4	:Since node initialization does not 0 out
	LIS	R0,0		:seg4, we do it here.
IZASY0	HS	0	:Top of loop
	ST	R0,SEG4,R1,	:Do it in FW's (save time because this
	SIS	R1,4		:could be happening while node is running).
	JGEBS	IZASY0
	EI	:1-NOSEG##AL

	HS	0	:Copy PLI message from seg1 into CONSAT seg0.

:	IULMSG is 128 bytes, but ULMSG can be as long as 256 bytes.
:	This seems like it can cause problems on PLI msg from TMCS if
:	reset is received., e.g we'd copy from area beyond.  see PLIMSG.

:	IF	LACOMB
:	LI	R3,IULMSG+ULMSIZ-2	:source
:	LI	R4,ULMSG+ULMSIZ-2	:destination
:	LHI	R1,((ULMSIZ/2)-1)*10	:# hw's-1 * 10
:	ELSE	:normal case
	LI	R3,IULMSG+7E	:Source (msg area is 80x bytes)
	LI	R4,ULMSG+7E	:Destination
	LHI	R1,3F0		:(40 HW'S-1) * 10
:	EI	:LACOMB
	COPY	R3,R1		:copy R1 hw's from R3 to R4

MS00	EQ	MS0+8		:Relative pointer to where port number should
				:be stuffed.
SCULMS	EQ	ULMSG		:resolves earlier global in SWITCH###jhl
ULMEND	EQ	MS0-2		:address of last HW of ULMSG area###jhl
IULMND	EQ	IULMSG+ULMSIZ-2	:address of last HW of IULMSG area ###jhl

	HS	0	:Set up NPI message at MS0
			:Format is "-nnnn-ppp-" where nnnn is octal node no.
			:and ppp is octal port no.
:	LI	R0,8D0A2D00	:"CR.LF.-.0"
	LI	R0,(80+ASCCR)^18+ASCLF^10+ASCDSH^8+00	:###jhl
	ST	R0,MS0
	STB	R0,MS0+0C	:String terminator = 0
	EXBR	R0,R0		:"-"
	STB	R0,MS0+7
	STB	R0,MS0+0B
	LI	R0,MACHNM	:Node number
	LA	R3,MS0+3
	LIS	R4,4
	JAL	R6,OOS		:handy CONSAT subroutine output octal string

	HS	0	:Set up A.SPED from SPED.A (valid port speeds)
	LM	R14,SPED.A	:From seg1 
	STM	R14,A.SPED	:to seg0

	SVC	0F,SV.IZA	:Init the async ring (SVC 0F,13)

	HS	0	:Initialize various bit arrays to 1's
	IF	NUMPRN
	TS	P.FLSH,,	:SET PRINTER SERVICE FLAGS OFF (=1)
	TS	F.FLSH,,	:FORCED FLUSH FLAGS AS WELL
	EI	:NUMPRN
:	(re)initialize the ASYNC max time for the NS display ###jhl
	L	R2,FASTC,,	:get current system time
	ST	R2,FASTCX,,	:make our first reference time now
	LIS	R2,0		:and make our first max time = 0
	STH	R2,FASTCH,,	:###jhl
	LHI	R2,(NAGRP-1)*2	:R2 will be our HW index
IZAS0	HS	0	:Top of loop
	TS	ASYACP,R2, 	:Mark all async ports available
	TS	DSR,R2		:DSR OFF
	TS	RTS,R2		:RTS OFF
	TS	HANGWT,R2	:HANG ALL PORTS???
	IF	SCBSYO
	LIS	R3,0
	STH	R3,BUSY.A,R2,	:reset the bits to all off
	LHL	R3,BUSY.C,R2,	:get halfword of bit array of busyable ports
IZAS02	JFFOH	R3,IZAS04	:move set bits to BUSY.A
	JFS	IZAS08		:leave loop when finished the halfword
IZAS04	SBT	R4,BUSY.A,R2,	:set the bit in active array
	STH	R3,BUSY.T,,	:store the halfword to reset the bit
	RBT	R4,BUSY.T,,	:reset it
	LHL	R3,BUSY.T,,	:get it back
	JBS	IZAS02		:and look for another
IZAS08	EI	:SCBSYO

	IF	PCNDSW
	TS	PERCON,R2	:INITIALIZE FOR PORT NOT CONNECTED
	EI	:PCNDSW

	IF	PVC	:SOME SPECIAL THINGS FOR PVC??? (NOHANG, TATBIN)

	EI	:PVC

	SIS	R2,2		:DECREMENT INDEX
	JGE	IZAS0		:UNTIL DONE

	LHI	PN2,(2*NAPORT)-2:NOW SET UP TO INIT SOME HW ARRAYS

	IF	PVC
	LR	PN,PN2		:NEED PORT NO. FOR PVC TEST
	SRLS	PN,1		:
	EI	:PVC

	IF	NMPVC
	JAL	R0,MPINIT,,	:INIT MPVC
	EI	:NMPVC

IZAS2	HS	0	:Now initialize some other stuff, port-by-port
	LHL	R2,.PTP.,PN2	:Pointer to port's table entry
	AI	R2,PTBASE	:Port table is in another segment
	LHI	R1,VERROR-SEG1	:SBA should be off, but just in case
	STH	R1,.VBSTA,R2,	:store in the port table###jhl
	LCS	R1,1		:Set port buffer pointers to -1
	ST	R1,.FTBUF,R2	:
	ST	R1,.TTBUF,R2	:
	ST	R1,.LGBUF,R2	:
	ST	R1,.ALBUF,R2	:
IZAS3	SIS	PN2,2		:DECREMENT INDEX
	JGE	IZAS2		:AND CONTINUE TILL DONE

:??? 	IF HD202
:???	L	R2,HD202M
:???	ST	R2,RTS,,
:???	EI :HD202

	JAL	R8,SNDRTS	:OUTPUT RTS TO ALL PORTS

	IF PVC
	JAL	R0,PVCIZ,,	:INITIALIZE PVC MODULE
	EI :PVC

	JR	R10		:RETURN


	IF	SCBSYO
::*	A.BUSY:	Async-port-BUSY processing
::	==================================
::		Runs every 4 seconds.  Checks for busy-able ports
::		and manipulates RTS appropriately (RTS = RTS .OR. BUSY.A).
::	LINKSON	R10
::	EXPECTS	NONE
::	RETURNS	NONE
::	CALLS	SVC15
::	CLOBBRS	R1,R2,R14(PN)

A.BUSY	HS	0		:
	LHI	R1,(NAGRP-1)*2	:START WITH LAST PORT GROUP--SVC NEEDS PORT
				:GROUP * 2 IN R1
A.BSY0	LHL	R2,BUSY.A,R1	:GET ATTENTION FLAGS FOR BUSY
A.BSY	JFFOH	R2,A.BSY1	:FOUND ONE
	SIS	R1,2		:NEXT GROUP
	JGEBS	A.BSY0		:IF ANY
	JR	R10		:ELSE RETURN

A.BSY1	HS	0		:FOUND A PORT THAT NEEDS BUSY SERVICE
	LR	PN,R1		:CALCULATE PORT NUMBER--HW OFFSET FIRST
	SLLS	PN,3		:EIGHT BITS TO THE BYTE
	AR	PN,R3		:ADD IN THE GROUP PORT NUMBER
	RBT	PN,BUSY.A	:RESET ATTENTION BIT--WE'VE NOTICED IT
	RBT	PN,RTS		:ASSUME RTS TO BE SET UP
	TBT	PN,BUSY.H	:CHECK WHICH WAY IT SHOULD BE SET
	JNFS	A.BSY2		:UP
	SBT	PN,RTS		:RTS DOWN
A.BSY2	HS	0
	LHL	R2,BUSY.A,R1	:ANY MORE IN THIS GROUP?
	JN	A.BSY		:YES, GO DO
	LHL	R2,RTS,R1	:GET RTS FOR THIS PORT GROUP
	SVC	0F,SV.RTS	:R1 ALREADY HAS 2*PORT GROUP--OUTPUT RTS
	J	A.BSY0		:AND BACK TO THE TOP
	EI	:SCBSYO


::*	HANGAN:	HANG-and-ANswer processing
::	==================================
::	Called by: Half-second logic.
::	Returns:	Via J HANRET.
::	Reg Usage: Excepts nothing. Returns nothing. Clobbers many.
::	Calls:	SVC17(input CP), SVC16(input DSR), AHNGAN(R0), SVC14(output
::			DTR)
::	This is the environment-dependent portion of ASYNC HANG/ANSWER.
::	It runs every so often off the half-second logic.  It performs the 
::	following sequence of functions:
::		1) Inputs CP for all ports and stores the samples in
::			the appropriate CPSAMP slot,
::		2) Inputs DSR for all ports and updates NEWDSR,
::		3) Calls the CONSAT Hang/Answer process to compute
::			state changes (the CONSAT may in turn call routines
::			to hang or answer ports as appropriate),
::		4) Outputs DTR to all ports,
::		5) Returns to the half-second logic from whence it
::			was called.
::
	SEG.(0)
HAC	HS	1		::HANG/ANSWER CURSOR POINTS TO CURRENT
	SEG.(1)			:CP SLOT

HANGAN	HS	0	:Enter here

	IF	MPCCHK		:###LSH
	L	R1,FASTC,,
	ST	R1,HNGNB
	LIS	R1,0
	STH	R1,HNGNF
	EI	:MPCCHK

	LHL	R3,HAC,,	:GET HANG/ANSWER CURSOR
	SHI	R3,NAGRP*2	:cycle down through the groups, wordly
	JGEFS	HA00
	LHI	R3,NAGRP*6	:max is 8 groups (256 ports)
HA00	HS	0
	STH	R3,HAC,,	:store new cursor in repository
	LIS	W20,0		:INIT GROUP
	LIS	W4,0		:START WITH PORT GROUP A

:	First job is to sample DSR and CP from all async ports.
HA1	HS	0	:Top of hang/answer loop
	LR	R1,W4		:GET GROUP INDEX FOR SVC
	SVC	0F,SV.CP	:INPUT 1ST 16 CP SAMPLES FOR THIS GROUP

:	IF	PCNDSW		:PERMANENT CONNECT DEBUG OPTION
:	NH	R2,PERCON,W4,	:TOGGLE PERCON FLAG FOR THIS PORT IF WE EVER
:				SEE CARRIER, AND KEEP HIM CONNECTED
:	STH	R2,PERCON,W4,
:	EI	:PCNDSW

	STH	R2,CPSAMP,W4,R3	:REMEMBER... ZERO MEANS .TRUE. !!
	AIS	R1,2		:ADVANCE GROUP INDEX FOR NEXT 16 PORTS
	SVC	0F,SV.CP	:INPUT Carrier Present

:	IF	PCNDSW
:	NH	R2,PERCON+2,W4,	:IF EVER CONNECTED, ALWAYS CONNECTED
:	STH	R2,PERCON+2,W4,
:	EI	:PCNDSW

:	(ASYNC CARD FORCES US TO DO THIS A HALFWORD AT A TIME)

	STH	R2,CPSAMP+2,W4,R3	:NOW HAVE ALL 32 CP SIGS FROM CARD
	LR	R1,W4		:GROUP INDEX FOR SVC
	SVC	0F,SV.PSR	:READ 1ST 16 DSR SAMPLES FOR THIS GROUP
	LR	WDSR,R2		:SAVE 1ST 16 DSR SAMPLES
	AIS	R1,2		:NEXT GROUP INDEX
	SVC	0F,SV.PSR	:INPUT DSR
	EXHR	WDSR,WDSR
	OR	WDSR,R2		:MERGE 2ND 16 DSR SAMPLES WITH 1ST

	ST	WDSR,NEWDSR,W4	:update the DSR bit array with new info

	AIS	W4,4		:increment W4 index
	AHI	W20,20		:increment W20 index
	CLHI	W20,NAPORT	:compare with max value
	JL	HA1		:if less than max do next ring group

:	Next respond to current state of signals
	LO	CONSAT
	JAL	R0,AHNGAN	:go do CONSAT HANG/ANSWER
	FO	CONSAT

:	Finally we output DTR  to all ports.

HANDTR	HS	0	:Output DTR to all ports
	LIS	W20,0		:INIT GROUP
	LIS	W4,0		:START WITH PORT GROUP A

HADTR1	HS	0	:Top of output-DTR loop
	L	WDTR,DTR,W4	::GET DTR AS COMPUTED BY AHNGAN
	LR	R1,W4		:GROUP INDEX FOR SVC
	EXHR	R2,WDTR		:R2 = DATA TO OUTPUT (1ST 16 PORTS)
	SVC	0F,SV.DTR	:OUTPUT DTR (SVC 0F,14)
	AIS	R1,2		:ADVANCE GROUP INDEX
	LR	R2,WDTR		:DATA FOR 2ND 16 PORTS
	SVC	0F,SV.DTR	:OUTPUT DTR

	AIS	W4,4
	AHI	W20,20
	CLHI	W20,NAPORT
	JL	HADTR1		:NEXT RING GROUP

	IF	MPCCHK		:###LSH
	L	R1,FASTC,,
	S	R1,HNGNB	:GET TIME PERIOD
	LH	R3,HNGNF
	CHI	R3,1
	JE	MPCK1
	CHI	R3,2
	JE	MPCK2
	ST	R1,HNGNNO	:IDLE
	J	MPCK3
MPCK1	ST	R1,HNGNAN	:ANSWER
	J	MPCK3
MPCK2	ST	R1,HNGNHN	:HANG
MPCK3	HS	0
	EI	:MPCCHK
	
	
	J	HANRET,,	:RETURN TO 500 MS ROUTINE

	SUBTTL	ASYNC (ASYNC PORT POLLING PROCESS)::*

::*	ASYPOL:	ASYnc-POLling process
::	=============================
::	Called by: EXEC (highest priority in SQUEUE)
::	Returns:	Via dismiss to EXEC.
::	Reg Usage: Expects nothing. Returns nothing. Clobbers everything.
::	Calls:	Various transmitter and receiver filters and ADLYMR (R10),
::		SVC1A (printer output).
::		Runs as often as possible (it's scheduled every 8.33 ms).
::		The highest priority process in the node code (always
::		excepting buffer-zaps) because we don't want to the async
::		input ring to wrap.  (RNGWRP is the time, in ms, it takes
::		the async ring to wrap.)
::
::		ASYPOL services ports for input/output, then services
::		printer ports for output (see FLUSHP).  RLINK (R10) is the
::		high-level link register -- i.e., when we can't think of 
::		anything better to do, we JR RLINK.  Alternatively, the
::		CONSAT may return us to VRET or XRET to continue as usual,
::		or to VDEF or XDEF (to defer further I/O on the port just
::		serviced).  When output is called for, we jump to the port's
::		active transmitter filter (.XSTAT).  When input is indicated
::		we go to .VSTAT.  These are usually port filters in the
::		CONSAT proper.  The principal exception is when a port is
::		in delay mode, in which case we are sent to ADLYMR in our
::		code.
::
::		The decision to do I/O on a port is made by the async micro-
::		code when we use the SBOD instruction.  The only parameter
::		passed to SBOD is the location of the async port buffer flag
::		array (actually we point to a copy of ASYFLG called ASPFLG).
::		SBOD causes the microcode to scan the async ring for input
::		start-bauds (assembled characters) and for ports which have
::		both their TAM (Transmit-Active-Mask) and attention bits set.
::		In the former case (input available), SBOD gives us a skip +4
::		return.  In the latter (output available and enabled) it gives
::		us a skip +8 return.  In both cases, the microcode sets up
::		R14 (port number) and R13 (port number * 2) of set F.  (The
::		microcode uses register sets 1-4 to do its thing. R13 and R14
::		are the only set F registers affected.)  If SBOD finds nothing
::		to do, it gives us a straight return and we go on our way.
::		A note about output: SBOD will keep returning us to output for
::		a port as long as data is available and TAM is set--i.e., we
::		may output more than one character to a port per SBOD cycle.
::		To defer further output for a port, it is necessary to reset
::		its attention bit (hence the use of ASPFLG rather than 
::		ASYFLG).  This is what happens when a return is made to XDEF.
::		By the same token, it is never safe to try to do more than
::		one output (XMIT instruction) per SBOD cycle because we can't
::		easily determine the state of the port's TAM bit.  Attempting
::		to output to a port whose TAM bit is off will result in an
::		illegal instruction interrupt on the XMIT. (See ADELAY for
::		the consequences of this feature.)
::
::		Async SIO I/O is handled separately.
::	
::
ASYPOL	HS	0	:Enter here

	IF	MPCCHK					###LSH
	L	R1,FASTC,,
	ST	R1,ASYPB
	LIS	R0,0
	STH	R0,ASYPF
	EI	:MPCCHK

	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)	:start CPUTIL for async poller
	CPUTNM(ASYPOL)		:define ASYPOL CPUTIL entry
	EI	:DB.CPU

	LIS	R0,1
	AHM	R0,ASYCNT,,	:INCREMENT COUNT OF ASYNC RUNS
				:SEE IF HIGH-WATER MARK FOR INTERVAL
				:BETWEEN ASYNC EXECUTIONS EXCEEDED
	L	R1,FASTC,,	:GET CURRENT TIME
	S	R1,FASTCX,,	:MINUS LAST TIME WE WERE HERE
	CLH	R1,FASTCH,,	:NEW HIGH?
	JLE	ASYPO1		:NO					###wjl
	STH	R1,FASTCH,,	:YES - SAVE NEW HIGH-WATER INTERVAL TIME

:	CHECK FOR ASYNC RING WRAP
	CLHI	R1,RNWRFC	:compare with async ring wrap time (FASTC)#wjl
	JL	ASYPO1		:no wrap				###wjl

:	ASYNC RING WRAP - MAKE SUP REPORT AND CRYPTO LOG ENTRY		###wjl
	LHI	R0,NR.ARW	:indicate ASYNC RING WRAP		###wjl
	STH	R0,SUPMBF	:in Sup Message Buffer HW0		###wjl
	STH	R1,SUPMBF+2	:include MAX (FASTC) in HW1		###wjl
	LHI	R1,RNWRFC	:include WRAP (FASTC)			###wjl
	STH	R1,SUPMBF+4	:in HW2					###wjl
	JAL	R10,SUP12,,	:send message to Sup and Crypto		###wjl

:	SAVE PROCESS HIGH-WATER MARKS IF DESIRED			###wjl
	IF	SWITIM		:SWITCH MAX PROCESS TIME debug switch	###wjl
	LHI	R1,1F*2		:max number of processes * 2		###wjl
ASYPHW	L	R2,PROHWM,R1,R1	:process high-water mark		###wjl
	STH	R2,PSVHWM,R1,	:save it				###wjl
	SIS	R1,2		:decrement index			###wjl
	JGEBS	ASYPHW		:loop back if more			###wjl
	EI	:SWITIM		:					###wjl

:	CRASH IF DESIRED	:					###wjl
	DEFAULT(ARWCRH,0)	:Tymfile parameter			###wjl
	IF	ARWCRH		:					###wjl
	CRASH.(.ASYRW)		:ASYNC RING WRAP			###wjl
	EI	:ARWCRH		:					###wjl

ASYPO1	HS	0	:Done with bookkeeping, let's get on with it
	LHI	R1,NAGRP*2	:The async microcode needs to know which
ASYPO2	HS	0		:ports have output pending (i.e., data in
	LHL	R0,ASYFLG,R1,	:their buffers).  We can't just use the
	STH	R0,ASPFLG,R1,	:ASYFLG attention flag array because we may
	SIS	R1,2		:have to defer output for a port before its
	JGEBS	ASYPO2		:buffer is depleted.  So we copy ASYFLG to
				:a working array, ASPFLG, which we can fiddle
				:with to our hearts' content without fear of
				:losing an attention bit.

	IF	NUMPRN		:If there are printer ports on our CONSAT, we
	LHL	R0,ASPFLG,,	:have to service them separately if they have
	NH	R0,P.FLSH,,	:data waiting to be flushed to a printer. A
	STH	R0,ASPFLG,,	:printer port is always in either printer or
	EI	:NUMPRN		:or terminal mode, never both.  This code
				:masks out ports in printer mode from the
				:async polling process.


VRET	HS	0	:CONSAT returns here from input processing
XRET	HS	0	:CONSAT returns here from output processing

ASYN1	HS	0	:Top of async polling loop
	LA	R8,ASPFLG,,	:This is our working copy of the buffer 
				:flags for async ports.  The microcode
				:uses it (see SBOD below) to determine
				:which ports to service for output.
	SBOD	0,R8	:Microcode start baud scanner. Scans the async ring
			:looking for inout start bauds, and scans ASPFLG and
			:microcode TAM for matching 1-bits (i.e., output data
			:available and output enabled).  If nothing is found,
			:does a straight return.  If input found, returns +4.
			:If output found, returns +8.  If I/O found, PN(R14)
			:and PN2(R13) are set up.
	J	ASYEXT		:(immed) No more to do
	J	ASYINP		:(+4) Go service input

ASYOUT	HS	0		:(+8) Service port for output

	IF	MPCCHK
	TS	ASYPF
	EI	:MPCCHK

	LHL	R12,.PTP.,PN2	:GET PORT'S PORT-TABLE POINTER.
	AI	R12,PTBASE
	L	R2,.TTBUF,R12	:TO-TERMINAL BUFFER POINTER
	L	R5,.XSTAT,R12	:OUTPUT STATE
	JALR	RLINK,R5	:DISPATCH
	TBT	PN,ASYFLG	:See if we've exhausted output
	JN	ASYN1		:no, go on and do SBOD again
XDEF	HS	0	:CONSAT brings us here if output deferred
	RBT	PN,ASPFLG,,	:NO MORE DATA FOR OUTPUT--turn off this port
	J	ASYN1		:DONE WITH OUTPUT, GO HANDLE NEXT PORT

ASYINP	HS	0		::INPUT FROM PORT

	IF	MPCCHK
	TS	ASYPF
	EI	:MPCCHK

	LHL	R12,.PTP.,PN2	:PORT-TABLE POINTER
	AI	R12,PTBASE
	L	R2,.FTBUF,R12	:FROM-TERMINAL BUFFER POINTER
	L	R5,.VSTAT,R12	:INPUT STATE
	JALR	RLINK,R5	:DISPATCH
VDEF	HS	0	:CONSAT returns here to defer input
	J	ASYN1		:CONTINUE WITH ASYNC PROCESS.

ASYEXT	HS	0	:Done with regular async

	IF	NMPVC	:now service MPVC pseudo port ouput.###jhl
	LHI	RPOL,((.MPORT+NMPVC)/10)*2	:index into ASYFLG
MPVS10	LHL	R13,ASYFLG,RPOL		:read flags for pseudo ports
	JFFOH	R13,MPSRVC		:pseudo port requires DMUX service
	SIS	RPOL,2			:back through the halfwords
	CLHI	RPOL,(.MPORT/10)*2	:but stay out of async or SIO
	JGEBS	MPVS10			:check all the halfwords
	J	MPVSXT			:move with a feeling of completeness

MPSRVC	HS	0

	IF	MPCCHK
	TS	ASYPF
	EI	:MPCCHK

	LR	R13,RPOL		:compute real port #--start w/ index
	SLLS	R13,3			:eight bits per byte
	AR	R14,R13			:add on the index into the halfword
	LR	R13,R14			:set up for M.DMX
	AR	R13,R13			:port number times two
	LHL	R12,.PTP.,R13		:get port's port-table pointer
	AI	R12,PTBASE
	L	R5,.XSTAT,R12		:transmit state should be M.DMX
	JALR	RLINK,R5		:M.DMX rets to XRET. anything else...?
	J	XRET	:(or ASYEXT?)	:give async another shot
MPVSXT	EI	:NMPVC

	IF	NUMPRN	:Now service printer output

::*	FLUSHP:	FLUSH-Printer-output
::	============================
::	Called by: Part of ASYPOL.
::	Returns:	See ASYPOL.
::	Reg Usage: Various.
::	Calls:	SVC1A(printer output).
::
::		This is part of the async polling loop (ASYPOL), but
::		printer output is handled separately.  Ports with printer 
::		output pending (P.FLSH array) are masked out of the SBOD 
::		cycle and are serviced after regular async I/O is processed.
::		This is because printer output is done from an intermediate
::		buffer (PRBFFR) which is filled by PCHAR.  When the contents
::		of a port's printer buffer are ready to be flushed to the
::		printer, the port's bit gets set in P.FLSH, which serves as
::		as our attention flag array for this process.  (P.FLSH is
::		only a HW, of which only the HO nibble is used since only
::		ports 0-3 may be printer ports.)  Printer output is done
::		via SVC1A.  If the SVC fails (detected by checking the
::		printer status returned in R2), the P.FLSH bit is left on,
::		and we'll try again next time.  If the port's bit in F.FLSH
::		is set (indicating a forced flush -- i.e., finish up output
::		whether successful or not), the SVC will give an output
::		complete status in R2 regardless of the actual status of
::		the printer.
::	
::		Notes: SVC1A runs in register set F, with the MAC disabled,
::		but with interrupts enabled (outputting a long line to the
::		printer can take a while).  Also, the in P.FLSH and F.FLSH
::		bit arrays, 0 means yes, 1 means no. 
::
FLUSHP	HS	0		:CHECK PRINTER PORTS FOR FLUSHING
	LCS	R13,1		:Because 0-bit means yes
	XH	R13,P.FLSH,,	:GET FLUSH SERVICE ARRAY
FLUSH1	JFFOH	R13,FLUSH0
	EI	:NUMPRN

	L	R1,FASTC,,	:GET CURRENT TIME
	ST	R1,FASTCX,,	:TODAY IS TOMORROW'S YESTERDAY

	IF	MPCCHK
	S	R1,ASYPB
	LH	R0,ASYPF
	JEFS	MPCK4
	AM	R1,ASYPIO	:TOTAL TIME FOR ASYPOL I/O LOGIC
	J	MPCK5
MPCK4	AM	R1,ASYPNO	:TOTAL TIME FOR ASYPOL IDLE LOGIC
MPCK5	HS	0
	EI	:MPCCHK

	J	EXDISM,,	:BACK TO EXEC LOOP

	IF	NUMPRN
FLUSH0	HS	0		:FLUSH A PRINTER, PORT NUMBER IN R14(PN)
	XH	R13,HWMSK,PN,PN	:TURN OFF THIS BIT
	LHL	R9,PBFPN,PN,PN	:R9=POINTER TO BUFFER
	SVC	0F,SV.PRT	:Printer output SVC 0F,1A
	LR	R2,R2		:CHECK PRINTER STATUS. 0 MEANS OK.
	JN	FLUSH1		:NEXT PORT
	SBT	PN,F.FLSH,,	:MARK FORCED FLUSH OFF
	SBT	PN,P.FLSH,,	:MARK FLUSH OFF
	J	FLUSH1

	EI	:NUMPRN

HWMSK	HS	0
Q	EQ	8000
QQ	EQ	0
	RE	10
	HC	Q^-QQ		:8000, 4000, 2000, ETC.
QQ	EQ	QQ+1
	ER

	SUBTTL	ASYNC (ASYNC PORT LOGIN OUTPUT PROCESS)::*

::*	ASYLOU:	ASYnc-Login-OUtput processing
::	=====================================
::	Called by: SWITCH exec loop.
::	Returns:	Via J ALORET.
::	Reg Usage: Various.
::	Calls:	GCI(R8), WCI(R8), ZAPV(R9), LSTAT/XLSTAT(R10), CBCLR(R8),
::			BFCOPY(R9), RFCBUF(R8), CRYPTO(R8)
::		Moves data from login output buffers to to-terminal
::		buffers of ports in login mode, based on ANIFLG (attention
::		flags for login output buffers.  Checks for various
::		control codes (e.g., zappers, needle eyes) and acts
::		on them if appropriate.  Communication between the
::		network and a port in login mode is accomplished thru
::		a pair of permuter tables, ALMTAB and ANITAB.  Both
::		are indexed by the login-port number which is arbit-
::		rarily assigned to a port in login mode and bears no
::		necessary relation to the port's port number.  The
::		ANITAB entry for a port is it's login input (.ALBUF)
::		buffer index.  The ALMTAB entry is the to-terminal
::		(.TTBUF) buffer index.
::
::		ASYLOU intercepts and acts on 02- and 03-character-pairs.
::		All other control codes are passed unchanged to the
::		terminal output buffer.  A 02- is illegal and crashes us.
::		Of the 03-pairs, most are illegal and will crash us.  The
::		good ones are:
::		1) Zapper (01-03) -- which cause us to zap the node
::			code's half of the circuit (between ANITAB
::			and LOGGER, then pass the zapper on to the
::			port.
::		2) Needle Eye (11) -- which cause us to disconnect
::			the port from the login process and connect it to
::			the new circuit, in the process copying any
::			typed-ahead data from the old input buffer to
::			the new one.
::		3) Message-for-terminal-in-login-mode (12), login-
::			error (13), and no-sup (14) -- all of which cause
::			us to call the CONSAT's login status handler (LSTAT
::			or XLSTAT) with the appropriate (CONSAT-defined)
::			status code.
::	
	SEG.(0)
ASYSAV	WS	1
	SEG.(1)

ASYLOU	HS	0	:Enter here

	IF	MPCCHK				:###LSH
	L	R2,FASTC,,
	ST	R2,ASYLB
	LIS	R2,0
	STH	R2,ASYLF
	EI	:MPCCHK

	LHI	R13,NANIPT/8-4	:Init group index (FW) - # of login ports
	JFS	ASYL00

ASYLO0	HS	0	:Top of loop
	L	R13,ASYSAV,,	:Should find safe register to avoid this

ASYL00	HS	0	:Start here
	L	R2,ANIFLG,R13	:Attention flag array pointing toward ports
	JFFO	R2,ASYLO1	:Find a port with data in login output buffer

	SIS	R13,4		:Next group
	JGEBS	ASYL00		:If there are any more
	J	ASYLEX		:Else return		###LSH

ASYLO1	HS	0	:Got an ANI port with data 

	ST	R13,ASYSAV,,	:R13 gets clobbered somewhere along the line
	LR	R5,R13		:Compute ANITAB relative channel# = R13*8+R3
	SLLS	R5,3		:
	AR	R5,R3		:now have offset into ANITAB
	LHL	R10,ANITAB,R5,R5:This is .ALBUF

	IF	LNFDBG		:###LSH		DEBUGGER
	ST	R4,REGST,,
	JAL	R4,ASLDB1,,
	GL	ASLDB1
	L	R4,REGST,,
	EI	:LNFDBG


	NHI	R10,-4		:Strip speed bits
	JGFS	ASYLO2		:If it's there, continue
	
	CRASH.(.ASLO0)		:Invalid ANITAB entry

ASYLO2	HS	0	:Got good .ALBUF in R10
	TBT	R5,LOGSTB,,	:test for msg bound for hung port
	GL	LOGSTB
	JN	ASLHNG		:ignore data until zap ack recv'd
				:(then free the channel)
	LHL	R11,ALMTAB,R5,R5:This is .TTBUF
	NHI	R11,-4		:Strip speed bits
	JGFS	ASLO2A		:OK

	CRASH.(.ASLO2)		:Bad ALMTAB entry

ASLO2A	HS	0	:Got good .TTBUF in R11
	IF	NMPVC	:check for timeout msg to abandoned login channel
	TBT	R5,SUBSTB,,	:did CIRDSC set this bit? (subport login stub)
	JN	ASYMPC		:if yes, then look for timeout
	EI	:NMPVC
	LH	PN,BF,R11,	:Get the BF of the to-terminal buffer
	JL	ASYLCR		:BF is "DEAD", crash
	SHI	PN,ASYZFL	:Async port offset = R10 = async port#
	LR	PN2,PN		:And PN2
	AR	PN2,PN2
	LHL	RPI,.PTP.,PN2	:Port table pointer
	AI	RPI,PTBASE

	IF	LNFDBG		:###LSH   DEBUGGER
	ST	R4,REGST,,
	JAL	R4,ASLDB2,,
	GL	ASLDB2
	L	R4,REGST,,
	EI	:LNFDBG

	C	R11,.TTBUF,RPI	:Make sure it matches
	JEFS	ASYLO3		:All OK

ASYLCR	CRASH.(.ASLO1)		:mismatch between ALMTAB and port table
	
ASYLO3	HS	0		:ALM and ANI entries correspond

	AIS	R10,4		:login output buffer (.ALBUF+4)

	IF	LNFDBG		:###LSH	DEBUGGER
	ST	R4,REGST,,
	LR	R2,R10		:(.ALBUF+4)
	JAL	R4,ASLDB3,,
	GL	ASLDB3
	L	R4,REGST,,
	EI	:LNFDBG		

ASYLO5	LR	R2,R10		:read in from node code
	JAL	R8,GCI,,	:Get a character
	CLHI	R1,3		:Control?
	JLEFS	ASYLO7		:Yes, go process

ASYLO6	HS	0	:Data character for port in login
	LR	R2,R11		:To-terminal buffer
	JAL	R8,WCI,,	:Write data character to buffer
	LHL	R2,BCT,R10,	:Any more data for this port?
	JG	ASYLO5		:Yes, go get it

	J	ASYLO0		:Done with this port, go to next
	
ASYLO7	HS	0	:Control code for port in login mode
	LHL	R8,ASYDSP,R1,R1	:Dispatch on code
	J	SEG1,R8,,	:

ASYDSP	HS	0		:Dispatch vector for control charactersn
	HC	ASYC0-SEG1	:Escape
	HC	ASYC1-SEG1	:01- pair
	HC	ASYC2-SEG1	:02 (illegal)
	HC	ASYC3-SEG1	:03- pair


ASYLEX	HS	0		:EXIT AND RETURN		:###LSH

	IF	MPCCHK						:###LSH
	L	R5,FASTC,,
	S	R5,ASYLB
	LH	R10,ASYLF
	JEFS	MPCK12
	ST	R5,ASYLYS
	J	MPCK13
MPCK12	ST	R5,ASYLNO
MPCK13	HS	0
	EI	:MPCCHK

	J	ALORET,,	:RETURN			:###LSH


ASYC0	HS	0	:Handle escaped data or
ASYC1	HS	0	:Prefix code (port filter will handle)
	LR	R2,R11		:To-terminal buffer
	JAL	R8,WCI,,	:Write 00 or 01
	LR	R2,R10		:Login output buffer
	JAL	R8,GCI,,	:Get 2nd char.
	J	ASYLO6		:And go write it

ASYC2	HS	0	:02 to login port (should not happen)

	CRASH.(.ASC20)		:Illegal character (02) to port in login mode

ASYC3	HS	0	:03- pair to port in login mode
	JAL	R8,GCI,,	:Get 2nd char of 03-pair from .ALBUF+4
	CLHI	R1,AS3PSZ	:max valid value###jhl
	JLFS	ASYC30		:OK

ASYCRH	CRASH.(.ASC30)		:Illegal 03-pair to port in login mode

ASYC30	LHL	R8,ASYC3V,R1,R1	:Get appropriate dispatch vector
	J	SEG1,R8,,	:and go handle

ASYC3V	HS	0	:Dispatch table - 2nd character of 03-pair
	HC	ASYCRH-SEG1	:00 - illegal
	HC	ASY301-SEG1	:01 - hard zapper
	HC	ASY302-SEG1	:02 - soft zapper (same as hard zapper)
	HC	ASY303-SEG1	:03 - non-gobbling zapper
	HC	ASYCRH-SEG1	:04 - illegal
	HC	ASYCRH-SEG1	:05 - illegal
	HC	ASYCRH-SEG1	:06 - illegal
	HC	ASYCRH-SEG1	:07 - illegal
	HC	ASYCRH-SEG1	:08 - illegal
	HC	ASYCRH-SEG1	:09 - illegal
	HC	ASYCRH-SEG1	:0A - illegal
	HC	ASYCRH-SEG1	:0B - illegal
	HC	ASYCRH-SEG1	:0C - illegal
	HC	ASYCRH-SEG1	:0D - illegal
	HC	ASYCRH-SEG1	:0E - illegal
	HC	ASYCRH-SEG1	:0F - illegal
	HC	ASYCRH-SEG1	:10 - illegal
	HC	ASY311-SEG1	:11 - needle eye
	HC	ASY312-SEG1	:12 - message for terminal in login mode
	HC	ASY313-SEG1	:13 - login error
	HC	ASY314-SEG1	:14 - no supe
AS3PSZ	EQ	((.-ASYC3V)/2)	:max valid value

:*****************************************************************

ASY301	HS	0	:Hard zapper or
ASY302	HS	0	:soft zapper
	:###LSH  CHANGES BEGIN HERE
	L	R2,.FTBUF,RPI,	:CLEAR FROM-TERMINAL BUFFER
	JAL	RCH,EMPTY
	L	R2,.TTBUF,RPI,	:CLEAR TO-TERMINAL BUFFER
	JAL	RCH,EMPTY

ASY303	HS	0	:Non-Gobbling zapper
	LCS	R9,4		:LOGON ABORTED
	JAL	RLINK,XLSTAT	:
	:###LSH CHANGES END HERE

	J	ASYLO0		:Next port
	
:*****************************************************************

	IF	NPAPRT
ASY310	HS	0	:got a needle - for addressable host

:use code from PRTADR.NAD that reads in the needle.

	J	ASYLO0
	EI	:NPAPRT


:*****************************************************************

ASY311	HS	0	:Needle eye - we've got a go ahead to build a
			:requested circuit.
:	On entry, R10 = new .ALBUF+4 (assigned from LEP09), e.g. node code
:	(login) output buffer,  R11 = .TTBUF, e.g. async output buffer
	JAL	R8,CBCLR,,	:Clear login output buffer of any junk.
	LHL	R6,BF,R11,	:To-terminal buffer's BF
	STH	R6,BF,R10,	:BECOMES NODE CODE OP BUFFER'S BF
	LIS	R0,0		:ZERO OUT TO-TERMINAL BUFFER'S BF
	STH	R0,BF,R11,	:	TO PREVENT BFCOPY FROM CLEARING
				:	ASYFLG WHEN ASYNC OP BUFFER IS EMPTY
	JAL	R9,BFCOPY	:COPY ASYNC OUTPUT BUFFER TO NODE CODE
				:OUTPUT BUFFER
	SIS	R10,4		:NODE CODE INPUT BUFFER
	SIS	R11,4		:ASYNC INPUT BUFFER (.FTBUF)
	LR	R6,R6		:TO-TERMINAL BF - IF ZERO, ZAPPER WAITING
	JE	AS0311		:	IN INPUT BUFFER

	STH	R10,IOTAB,R6,R6	:MAKE P-TABLE ENTRY - ASYNC PORT NOW POINTS
				:	TO NODE CODE IP BUFFER
AS0311	HS	0
	JAL	R9,BFCOPY	:COPY ASYNC IP BUFFER TO NODE CODE IP BUFFER
	LIS	R0,0
	STH	R0,ANITAB,CHN,CHN	:CLEAR ANITAB ENTRY
	STH	R0,ALMTAB,CHN,CHN	:CLEAR ALMTAB ENTRY.
:???	STH	R0,CKTKEY,CHN,CHN	:CLEAR CIRCUIT BUILDING KEY
	SBT	CHN,ANIACP,,	:MARK LOGIN CHANNEL AVAILABLE
	SBT	CHN,ALMACP,,
	LR	R2,R11		:OLD ASYNC INPUT BUFFER (.FTBUF)
	JAL	R8,RFCBUF,,	:RETURN OLD ASYNC BUFFER PAIR
	LIS	R1,1
	AHM	R1,ALOCNT,,	:INCREMENT NEEDLE EYE COUNT FOR OBSERVATION

	SHI	R6,ASYZFL	:R6 IS NOW ASYNC PORT NUMBER
	RBT	R6,LOGING
	RBT	R6,NEWLOG
	IF	NMPVC
	RBT	R6,MPCLOG
	EI	:NMPVC
	LHL	R6,.PTP.,R6,R6	:GET PORT-TABLE POINTER
	AI	R6,PTBASE
	ST	R10,.FTBUF,R6	:SET FROM-TERMINAL BUFFER
	AIS	R10,4		:TO-TERMINAL BUFFER
	ST	R10,.TTBUF,R6	:SET IT IN PORT-TABLE
	SIS	R10,4		:RESTORE FROM-TERMINAL BUFFER

	L	R2,.LGBUF,R6	:RETURN LOGIN BUFFER
	JAL	R8,RFCBUF,,
	LCS	R0,1
	ST	R0,.LGBUF,R6	:RESET PORT TABLE FIELDS
	ST	R0,.ALBUF,R6	:recall .ALBUF will be .FTBUF/.TTBUF

	EXHR	R0,CHN		:PORT# TO HO HW OF R0
	OH	R0,BF,R10,	:COMBINE NODE CODE CHANNEL#
	JAL	R8,CRYPTO,,	:
	HC	CRYE3D		:NEEDLE EYE MSG TO CRYPTO

	J	ASYLO0		:NEXT CHANNEL


:
:	LEP0D translates TILM messages in the following way
:		0D10 -->	xxx01000 string (sent by sup)
:		0D13-1E -->	xxx01000 string (gen'ed based on type)
:		0D08-0D, 0D11-12	sent straight
:

ASY312	HS	0	:Message for terminal in login mode
	JAL	R8,GCI,,	:Get message code in R1
	LHL	R0,BF,R11,	:To-terminal buffer's BF
	JE	ASYLO0		:Zapper must have just come from port

	IF	NMPVC		:M.DMX heeds only zappers, gblrs, and balls
	CLHI	PN,.MPORT	:check for MPVC pseudo port
	JL	AS312M		:if not, translate normally
	THI	R1,10		:test for the bad news bit
	JNFS	AS312N		:if set, send a zapper
:	we want PLI (type 9) to become a zapper, too.
	LR	R9,R1		:save code in R9 to send on, if need be
	NHI	R1,1F		:strip flag bits
	CLHI	R1,9		:is it a PLEASE LOG IN?
	JEFS	AS312N		:if so one login failed
	SIS	R9,8		:otherwise, treat it as it really is
	J	AS312B		:service via LSTAT
:	send zapper
AS312N	LR	R2,R11		:get .TTBUF
	LHI	R1,0103		:write in the zapper, a byte at a time
	JAL	R8,WCI,,	:first the 03
	EXBR	R1,R1		:then the 01
	JAL	R8,WCI,,	:M.DMX will read out (GETCHR translates)
	J	ASYLO0

AS312M	EI	:NMPVC		:###jhl
	THI	R1,10		:If this bit is set, it's hang or superhang
	JE	AS312A		:else it's in 08-0D range.  Shift and send.

	LR	R2,R11		:get .TTBUF  ###LSH
	LR	R7,R1		:got some kind of hang--save hang byte
	LIS	R1,01		:WE'RE GOING TO MAKE THIS A HANG PAIR
	JAL	R8,WCI,,	:WRITE THE 01
	LR	R1,R7		:GET THE HANG CHAR. BACK
	OHI	R1,0F0		:THIS RIGAMAROLE CONVERTS 11 TO F0
	SIS	R1,1		:AND 12 TO F1
	JAL	R8,WCI,,	:WRITE IT IN
	NHI	R7,0E0		:ANY SPECIAL BITS WITH HANG CHARACTER?
	JE	ASYLO0		:NO, BACK TO TOP
	LR	R9,R7		:GET SPECIAL BITS ONLY
	JFS	AS312B		

AS312A	HS	0
	LR	R9,R1		:GET STATUS BYTE TO R9 FOR LSTAT
	SIS	R9,8		:GET RID OF OFFSET
:::	JE	ASYLO0		:IF 0 DON'T BOTHER
AS312B	JAL	RLINK,LSTAT	:SEND STATUS TO CONSAT
	J	ASYLO0		:NEXT


:*****************************************************************
:	LOGGER found no supervisor or recent takeover (LOGZAP).
:	Hang the port and send a zapper back to the node code.
:	The code byte following the 0313 is an 8, if from LOGZAP.

ASY313	HS	0		:LOGIN ERROR (LOGON ABORTED...)
	JAL	R8,GCI,,	:GET ERROR CODE
	NHI	R1,7		:LOOK AT 3 LO BITS ONLY
	JEFS	AS0313		:ONLY 0 CODE OK

	CRASH.(.ASY30)

AS0313	HS	0
:	LR	PN,CHN		:SET UP PORT#
:	JAL	R9,SETPN2	:SET UP PN2,RPI,RPB(OP)
	LCS	R9,4		:-4 = LOGON ABORTED TO CONSAT
	JAL	RLINK,XLSTAT	:logon aborted to port.
:	TEXT sends hangs to the port, and XASCI acts upon hang by
:	setting the HANGWT bit.  Hang and answer logic then does a
:	DT.PRT, which will send a zapper to the node code if the login
:	buffers are attached to the port.
	J	ASYLO0		:NEXT


:*****************************************************************
:	It is not clear that this message will ever be sent.  There is
:	a double use of the 0314 pair if it is, as a buffer delay
:	timing pair (COMET, which should at any rate only be sent over
:	passthrough circuits) and in the present context.

ASY314	HS	0		:NO PATH AVAILABLE
:	LR	PN,CHN		:PORT#
:	JAL	R9,SETPN2	:SET UP PN2,RPI,RPB
	LCS	R9,3		:-3 = NO PATH TO CONSAT
	JAL	RLINK,XLSTAT	:NO PATH AVAIL...TO PORT

	J	ASYLO0		:NEXT


:	Got data for a channel whose .FTBUF/.TTBUF structures have been
:	torn down.  Rather than crash, we should ignore all such data
:	until login zapper confirmation causes LEP0F to remove the stub.

ASLHNG	HS	0
	LR	R2,R10		:get .ALBUF into R2
	AIS	R2,4		:.ALBUF+4 is the buffer with data###jhl
	JAL	R8,CBCLR,,	:clear out the buffer
	J	ASYLO0		:and exit

:*****************************************************************
	IF	NMPVC	:###jhl
:	Check for TILM msg trying to time out an MPVC subport which
:	sent the TID to the sup, but sent its username to the
:	transaction switch over the MPVC pseudo port channel.  We
:	don't want to hang such a port, only to clean up the
:	straggling bits of thwarted login structure.
:	Reasons to tear down the login structure are--a zapper, a login
:	error message (0313 pair from LOGZAP), or a hang-superhang from
:	PLS SEE REP logic (INFLGT timeout in LOGGER).
:
:	R5	= 	relative ANI channel number
:	R10	=	.ALBUF
:	R11	=	.TTBUF
:		:###LSH  CHANGES BEGIN HERE

ASYMPC	HS	0

	IF	MPCCHK
	L	R8,FASTC,,
	ST	R8,ASYMB
	TS	ASYLF
	EI	:MPCCHK

	IF	LNFDBG		:###LSH		DEBUGGER
	ST	R4,REGST,,
	JAL	R4,ASMDB1,,
	GL	ASMDB1
	L	R4,REGST
	EI	:LNFDBG

	LR	R2,R10		:get .ALBUF
	AIS	R2,4		:.ALBUF+4

	IF	LNFDBG
	ST	R4,REGST,,
	JAL	R4,ASMDB2,,
	GL	ASMDB2
	L	R4,REGST,,
	EI	:LNFDBG

ASYMP2	LHL	R3,BCT,R2,	:--is there any data ?
	JLE	ASYMEX		:no, exit to service next port	  ###LSH

	JAL	R8,GCI,,	:read the character
	CLHI	R1,3		:03-pair ?
	JE	ASYMP4		:check it out if it is
	JL	ASYMP8		:handle other pairs carefully
	J	ASYMP2		:ignore any other data

		:###LSH  CHANGES END HERE

ASYMP8	HS	0
	JAL	R8,GCI,,	:get second character
	J	ASYMP2		:go get more, if more there is
:				:###LSH

ASYMP4	HS	0		:we have an 03-pair

	JAL	R8,GCI,,	:get second char of pair
	CLHI	R1,TILIM&0FF	:we want TILM msg--0312 pair
	JN	ASYM10		:check for zapper
	JAL	R8,GCI,,	:check for hang (031211)
	CLHI	R1,11
	JN	ASYMP2		:wait for a hang or a zapper ###LSH
	JFS	ASYMP5
ASYM10	CLHI	R1,ZAPPH&0FF	:second char of 0301 (zapper) pair?
	JEFS	ASYMP5		:
	CLHI	R1,LOGRR&0FF	:LOGZAP sends 0313 pair
	JN	ASYMP2		:###LSH

:	subport login circuit timed out--clean up .ALBUF and associated
:	ANI channel structures.
ASYMP5	LR	R2,R10		:get .ALBUF
	JAL	R8,RFCBUF,,	:return .ALBUF
	ST	R6,ASMSSV,,	:STORE REGISTER
	LIS	R6,0		:###LSH
	STH	R6,ANITAB,R5,R5	:CLEAR PERMUTER TABLE ###LSH
	LR	R6,R2		:.ALBUF ###LSH
	JAL	R9,LOGCLR,,	:REMOVE FROM LOGGER LIST ###LSH
	L	R6,ASMSSV,,	:RESTORE REGISTER
	SBT	R5,ANIACP,,	:free the ANI channel--SBT CHN,ANIACP
	RBT	R5,SUBSTB,,	:turn it off for ASYLOU to use again
:
:	:CHANGES BEGIN HERE   ###LSH
:	:TO FIX BC63, 5463,  6C63  CRASHES PROBLEMS
	LHL	PN,BF,R11,	:ABS. ASY PORT #
	SHI	PN,ASYZFL	:REL. ASY PORT #
	JL	ASYMEX		:CHECK IF IN THE RANGE OF ASY.
	CLHI	PN,NPORT
	JGE	ASYMEX
	LR	PN2,PN
	AR	PN2,PN2
	LHL	RPI,.PTP.,PN2
	AI	RPI,PTBASE	:POINTER TO PORT TABLE
	C	R10,.ALBUF,RPI	:MAKE SURE IT MATCHES
	JNFS	ASYMEX		:NO
	LCS	R3,1
	ST	R3,.ALBUF,RPI	:RESET PORT TABLE (.ALBUF)

ASYMEX	HS	0		:EXIT TO SERVICE THE NEXT PORT   ###LSH

:	:CHANGES END HERE  ###LSH

	IF	MPCCHK						:###LSH
	L	R8,FASTC,,
	S	R8,ASYMB
	ST	R8,ASYMYS
	EI	:MPCCHK

	J	ASYLO0		:service next port

	EI	:NMPVC


::*	BFCOPY:	BuFfer-COPY routine
::	===========================
::	Called by: ASYLOU when connecting a port to a newly built circuit.
::	Returns:	[R9].
::	Reg Usage: Expects R11(source buffer index), R10(destination buffer
::			index). Clobbers R2, R8, R1.
::	Calls:	GCI(R8), WCI(R8).
::		Copies data from one buffer to another--specifically, from
::		the input buffer of a port that was in login mode to the
::		buffer assigned to the new circuit.
::
BFCOPY	HS	0
	LHL	R1,BCT,R11,	:Is it empty?
	JER	R9		:Yes

	LR	R2,R11		:Source buffer
	JAL	R8,GCI,,	:Get a character
	LR	R2,R10		:Destination buffer
	JAL	R8,WCI,,	:Write a character
	JBS	BFCOPY		:As many times as necessary

::*	TYQSEC:	Tymsat-Quarter-SECond logic
::	===================================
::	Called by: G250MS(EXEC), quarter-second logic.
::	Returns:	Dismisses to EXEC.
::	Reg Usage: Clobbers various.
::	Calls:	GBTIME(CONSAT).
::		Runs every so often.  Does green-ball processing to try to
::		get ports out of DEM.
::
TYQSEC	HS	0
	LIS	R2,1
	AM	R2,QSECC,,	:Count of executions
	J	GBTIME,,	:Which dismisses to EXEC

	SUBTTL	ASYNC (Environment Dependent CONSAT ROUTINES)::
::
::	THIS SECTION CONTAINS THE ENVIRONMENT-DEPENDENT ROUTINES THAT
::	ARE CALLED BY THE CONSAT.  MODIFY WITH GREAT CARE AND ATTENTION
::	TO WHAT THE CONSAT CODE REQUIRES AND EXPECTS.
::

::*	A.ANS:	Async-ANSwer-port routine
::	=================================
::	Called by: CONSAT Hang/Answer when a port needs to be answered.
::	Returns:	Via [R10].
::	Reg Usage: Expects RPI(R12), PN(R14).
::	Calls:	CRYPTO(R8)
::		Called by CONSAT when a port is answered.  Informs CRYPTO
::		of port answered (CRYE3F, Status=1).
::
A.ANS	HS	0
	LR	R0,PN
	OI	R0,10000	:STATUS=1 (ANSWERED)
	JAL	R8,CRYPTO,,
	HC	CRYE3F		:PORT ANSWERED
	JR	RLINK



::*	IZ.PRT:	InitialiZe-async-PoRT
::	=============================
::	Called by: CONSAT Hang/Answer when a port is answered.
::	Returns:	Via [R10].
::	Reg Usage: Expects RPI(R12), PN(R14). Clobbers R0, R2, R5, R8, R9.
::	Calls:	SVC18(enable async port), GFCBUF(R8), CRQHCR(R9)
::	Links On:  RLINK(R10)
::		Enables the port (SVC18).  Grabs a fresh pair of buffers and
::		assigns them to the port for I/O.  Builds a half-circuit from
::		the port to the buffer-pair.  
::

IZ.PRT	HS	0

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,IZPDB1,,
	GL	IZPDB1
	L	R4,REGST,,
	EI	:LNFDBG		


	IF	NMPVC
	CLHI	PN,.MPORT	:is this an MPVC pseudo port?
:	the SVC doesn't check, but it may not mind.
	JL	IZ.PR4		:enable-async-SVC call if not
:	otherwise, take this opportunity to notify the crypto log

	LHL	R4,.TERMT,RPI,	:TID FOR PSEUDO PORT (MAKE SENSE ??)
	JAL	R9,A.VID	:enter TID rcv'd in crypto log
	JFS	IZ.PR5		:don't set up async microcode for pseudo port
IZ.PR4	EI	:NMPVC
	SVC	0F,SV.ESY	:ENABLE ASYNC PORT (SVC 0F,18)

IZ.PR5	JAL	R8,GFCBUF,,	:GET FRESH BUFFER PAIR (LOWER ONE IN R2)
	J	GFCERR		:immed. return - out of buffers!	###wjl
	LR	CHN,PN		:+4 return - ok				###wjl
	AHI	CHN,ASYZFL	:ABSOLUTE CHANNEL NO.
	JAL	R9,CRQHCR,,	:BUILD HALF-CIRCUIT FROM BUFFER TO PORT
	ST	R2,.FTBUF,RPI,	:LOWER ONE WILL BE FROM-TERMINAL
	XHI	R2,4		:FLIP TO HIGHER ONE
	ST	R2,.TTBUF,RPI,	:HIGHER ONE WILL BE TO-TERMINAL
	LIS	R0,1
	AHM	R0,IZITUP,PN,PN :COUNT OF TIMES PORT HAS BEEN UP

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,IZPDB2,,
	GL	IZPDB2
	L	R4,REGST,,
	EI	:LNFDBG		

	JR	RLINK		:RETURN

GFCERR	J	OP8463,,	:error, out of buffers!			###wjl

::*	A.DSC:	Async-port-DiSConnect
::	=============================
::	Called by: CONSAT Hang/Answer when a port is hung to disconnect it.
::	Returns:	Via [R8].
::	Reg Usage: Expects RPI(R12), PN(R14).
::	Calls:	Nada.
::		Sets the port's .VBSTA to VCLSBA, which will cause
::		the port to be disabled if any input is received on it.
::
A.DSC	HS	0
:???	LCS	R0,1		:DECREMENT COUNT
:???	AHM	R0,HNPORT,,	:OF ACTIVE PORTS
:???	SBT	PN,RTS,,	:
	LA	R0,VCLSBA,,	:
	ST	R0,.VSTAT,RPI	:SET SBA OFF
	JR	R8

::*	A.IBR:	Async-set-Input-Baud-Rate routine
::	=========================================
::	Called by: CONSAT, to set IBR for a port.
::	returns:	Via [R8].
::	Reg Usage: Nada.
::	Calls:	Nicht.
::		Currently a do-nothing routine.  The CONSAT has done 
::		everything that is necessary before calling A.IBR.
::		In the ISIS environment, a message is sent to ISIS via
::		the slot-to-ISIS async ring.
::
:	DO-NOTHING ROUTINE. CONSAT DOES EVERYTHING NEEDED FOR SOLO CODE
:	BEFORE CALLING A.IBR.  :**: MARKS CODE THAT MUST BE INCLUDED
:	IF WE EVER ALLOW CHANGING OF 2400/4800 IBR'S.

A.IBR	HS	0
:**:	LB	R1,BRMAP,R1	:TRANSLATE IBR INDEX
:**:	STB	R1,IBRATE,PN	:STORE IT AWAY
	JR	R8		:RETURN

::*	A.OBR:	Async-set-Output-Baud-Rate
::	==================================
::	Called by: CONSAT, to set OBR for a port.
::	returns:	Via [R8].
::	Reg Usage: Nada.
::	Calls:	Nicht.
::		Currently a do-nothing routine.  The CONSAT has done 
::		everything that is necessary before calling A.OBR.
::		In the ISIS environment, a message is sent to ISIS via
::		the slot-to-ISIS async ring.
::
:	DO-NOTHING ROUTINE. CONSAT DOES EVERYTHING NEEDED FOR SOLO CODE
:	BEFORE CALLING A.OBR.  :**: MARKS CODE THAT MUST BE INCLUDED
:	IF WE EVER ALLOW CHANGING OF 2400/4800 OBR'S.

A.OBR	HS	0
:**:	LB	R1,BRMAP,R1	:TRANSLATE IBR INDEX
:**:	STB	R1,OBRATE,PN	:STORE IT AWAY
	JR	R8		:RETURN


	IF	TELEX

::	SET/RESET OUTPUT BAUD RATE FOR TELEX EMIT BREAK	###wjl
:	-----------------------------------------------
SBRATE	HS	0
	GETPTP(RPI,PN,PN)
	LI	R2,XTLXBK	:change xmit state to output break
	ST	R2,.XSTAT,RPI
	JR	R8

RBRATE	HS	0
	ST	R8,SAVRET,,	:SAVE RETURN,R8 CLOBBERED IN EMTBRK
	GETPTP(RPI,PN,PN)	:COMPUTE RPI
	LI	R2,XTELX	:change xmit state to xmit TELEX
	ST	R2,.XSTAT,RPI
	L	R2,.TTBUF,RPI	:BUFFER INDEX IN R2 TO EMPTY
	JAL	R7,MTYBRK	:empty buffer of breaks--preserve signals
	L	R8,SAVRET,,	:GET RETURN
	JR	R8

::	TELEX transmit break state routine (.XSTAT)
:	alternates with XTELX.

XTLXBK	HS	0
	JAL	RCH,GETCHR		:get character
	LO	TELEX
	J	XSIG.T			:normal return...its a signal
	FO	TELEX
	JAL	RCH,APUTBR		:output break character
	JR	RLINK			:and return

::	LOAD BREAK CHARACTER FOR TELEX EMIT BREAK	###wjl
:	-----------------------------------------
A.BRK	HS	0
	ST	RBF,SAVRET,,	:R8 CLOBBERED IN PUTCHR
	LIS	RBC,0		:TELEX WANTS 0 FOR BREAK
	L	R2,.TTBUF,RPI	:TO-TERMINAL BUFFER POINTER
	JAL	RCH,PUTCHR
	L	RBF,SAVRET,,	:GET RETURN
	JR	RBF

::	COUNT BYTES OF BREAK IN .TTBUF FOR TELEX EMIT BREAK ###wjl
:	---------------------------------------------------
BRKCBC	HS	0
	GETPTP(RPI,RP,RP)	:COMPUTE RPI
	L	R2,.TTBUF,RPI	:TO-TERMINAL BUFFER POINTER
	JAL	R8,CBCCT,,	:BYTE COUNT RETURNED IN R1
	ST	R1,BKCBSV,,
BRKCB0	CHI	R1,BRKTHD	:ARE THERE ENOUGH?
	JGER	R9		:YES!  RETURN

	JAL	RBF,A.BRK	:NO - PUT ONE IN
	L	R1,BKCBSV,,
	AIS	R1,1		:INCREMENT COUNT
	ST	R1,BKCBSV,,
	JBS	BRKCB0		:CHECK AGAIN

::	EMPTY BREAK CHARS FROM .TTBUF UPON CHANGE TO DATA STATE ###jhl
:	--------------------------------------------------------------
:	this routine removes escaped zeros from the buffer pointed to
:	by R2, and drops them on the floor.
:	expects R2 (preserved).  Uses R0, R1, R3, R4, R8.
:	links on R7.

MTYBRK	HS	0
	LHI	R1,0FF		:this marks last char in buffer
	JAL	R8,WCI,,	:write in our finish marker
MTYB10	JAL	R8,GCI,,	:read out char from head of buffer
	CLHI	R1,3		:is it a network pair?
	JLEFS	MTYB20		:if so, go to pair handler
	CLHI	R1,0FF		:is it our end marker
	JER	R7		:if so, our job is finished
	JAL	R8,WCI,,	:otherwise, write it back in 
	JBS	MTYB10		:and continue checking

MTYB20	LR	R1,R1		:let's see what it is
	JEFS	MTYB30		:it's an escaped pair
	JAL	R8,WCI,,	:write all other pairs back into buffer
	JAL	R8,GCI,,	:get second char of pair
	JAL	R8,WCI,,	:follow the leader
	J	MTYB10		:and continue checking
	
MTYB30	JAL	R8,GCI,,	:read second char of escaped pair
	LR	R4,R1		:is escaped char a zero?
	JE	MTYB10		:yes--don't rewrite it
	LIS	R1,0		:recreate the escape
	JAL	R8,WCI,,	:write escape back in
	LR	R1,R4		:restore the escaped character
	JAL	R8,WCI,,	:write it back in
	J	MTYB10		:and continue checking


	EI	:TELEX


A.RS.D	HS	0
	JFS	A.RS.D
A.RS.U	HS	0
	JFS	A.RS.U


::*	A.TID:	Async-set-TID-mode routine
::	==================================
::	Called by: CONSAT, to set a port to look-for-TID-mode.
::	returns:	Via [R8].
::	Reg Usage: Expects RPI(R12). Clobbers R1.
::	Calls:	Nothing.
::		Sets the port's .VBSTA pointer to AGETIB, which will look
::		for a TID input and report the TID and IBR when a good one
::		is found.
::
A.TID	HS	0
	LHI	R1,AGETIB-SEG1	:SET VBAUD STATE TO SEND IBR AND TID
	STH	R1,.VBSTA,RPI,	:
	JR	R8		:RETURN

::*	A.VID:	Async-receiVed-tID routine
::	==================================
::	Called by: CONSAT, when a valid TID has been reported.
::	returns:	Via [R9].
::	Reg Usage: Expects PN(R14), R4(index for TID).  Clobbers R0, R8.
::	Calls:	CRYPTO(R8).
::		Reports TID received on new port to CRYPTO (CRYE3C).
::		Otherwise, a do-nothing routine.  In the ISIS environment,
::		sets the port to data mode, which we have done automatically
::		when the TID was received and reported by AGETIB.
::
A.VID	HS	0
	LB	R8,VID.ID,R4,	:this byte is CCT			###wjl
	NHI	R8,3F		:remove HO bits from table entry	###wjl
	EXHR	R0,PN		:SET UP CRYPTO MESSAGE
	OR	R0,R8		:###wjl
	JAL	R8,CRYPTO,,
	HC	CRYE3C		:CRYPTO MSG - TID RECV'D. PORT, TID.
	IF	PVC
:	if PVC port, somebody better set up .VBSTA for TID-rcv'ed state
	TBT	PN,PVCARY	:in case we're here from AVID3
	JER	R9		:return if not PVC port
	LHI	R0,AGETCR-SEG1	:get data char state
	STH	R0,.VBSTA,RPI	:store in port table
	EI	:PVC
	JR	R9		:RETURN

::*	ADELAY:	Async-DELAY-generator routine
::	=====================================
::	Called by: CONSAT, to output a delay to a port.
::	returns:	Links on R7.  If [R5]>0, R7 is saved in .LRSAVE and we
::			return to the polling loop via RLINK(R10).  After all 
::		delay has been output, we recover R7 and return to the
::		original caller.
::	Reg Usage: Expects PN(R14), PN2(R13),RPI(R12), R5(delay count).
::			Clobbers R1.
::	Calls:	Nicht.
::
::	Called by CONSAT to generate a delay of [R5] 1/30-second
::	intervals.  If [R5]>0, ADELAY does the set-up for transmitting
::	the delay, but doesn't actually send it.  Instead, it sets
::	the port's transmit vector to ADLYMR and the delay is actually
::	transmitted on the next pass thru the polling loop.  The 
::	reason for this is that the CONSAT may call ADELAY immediately
::	after APTUCHing a character into the async output ring.  An
::	attempt to output the delay immediately, before the SBOD has
::	run again, may cause an illegal instruction on the XMIT 
::	instruction.  The .MARGE cell (HOB) of the port descriptor is
::	used to save the current count of remaining delay units to be
::	output.
::
ADELYG	HS	0	::Enter here to leave LOB of .MARGE alone.
	LR	R5,R5		:Any delay requested?
	JER	R7		:No, just return.
	STB	R5,.MARGE,RPI	:Save delay count
	JFS	ADELA0

ADELAY	HS	0		:ENTER HERE ON FIRST PASS
	EXBR	R5,R5		:ANY DELAY REQUESTED? move it up a byte.
	JER	R7		:NO, RETURN
	STH	R5,.MARGE,RPI	:Save delay count and 0 LOB.
ADELA0	HS	0
	L	R1,.XSTAT,R12	:CURRENT X-MIT FILTER
	IF	1-BAUDR		:only necessary on 1200 baud CONSATs	###wjl
	CLI	R1,ADLYMR	:check state to avoid looping		###wjl
	JEFS	ADELA1		:already in delay state, don't save it	###wjl
	EI	:1-BAUDR
	ST	R1,.XSAVE,RPI	:BACK IT UP
	LA	R1,ADLYMR	:NEW XMIT FILTER
	ST	R1,.XSTAT,R12	:RETURNS US TO TOP FOR NEXT ROUND OF DELAY
ADELA1	HS	0		:###wjl
	ST	R7,.LRSAV,R12	:SAVE OUR LINK REGISTER
	JR	RLINK		:RETURN TO POLLER

::*	ADLYMR:	Async-DELaY-MoRe-to-transmit
::	====================================
::	Called by: ASYPOL, for ports in delay mode, via .VBSTA.
::	returns:	To polling loop (RLINK) if more delay, else recovers
::			R7 and returns to original ADELAY caller.
::	Reg Usage: Expects RPI(R12), PN2(R13). Clobbers R1, R2, R5, R7, R0.
::	Calls:	Nada.
::	We come here for ports which have been set up by ADELAY.
::	The port's .MARGE holds the count of remaining 1/30 second
::	delay units to be transmitted.  In a 4800 baud CONSAT,
::	delay must be transmitted 1 unit at a time .  In a
::	1200 baud CONSAT we can save some overhead by transmitting
::	3 units (1/10 second) at a time if appropriate.  The amount
::	of delay transmitted is determined by the value in R2, which
::	ordinarily holds the port's OBR index for the XMIT instruc-
::	tion.  For 1/30 second delay, LIS R2,0F.  For 1/10 second
::	delay, LIS R2,0E.
::
ADLYMR	HS	0		:ENTER HERE ON SUBSEQUENT PASSES
	LB	R5,.MARGE,RPI	:GET REMAINING DELAY COUNT
	JGFS	ADLYM1		:IF ANY

ADLYDN	HS	0		:ALL DONE WITH DELAYS
	L	R1,.XSAVE,RPI	:RESTORE XMIT VECTOR
	ST	R1,.XSTAT,R12	:
	L	R7,.LRSAV,R12	:RESTORE LINK REGISTER
	JR	R7		:RETURN TO ORIGINAL CALLER

ADLYM1	HS	0		:SEND SOME DELAY
	LIS	R0,0		:NEEDED BELOW BY XMIT INSTRUCTION

	if	baudr-1	:special treatment for 4800 baud
:	Entry in TCHAR table at 4800 has same entry in 0F index as in 0E
:	index -- 1/30 second.  This could maybe be changed.

	else	:1200 baud
	CLHI	R5,3		:if more than 3, send chunks of 1/10 sec
	JLEFS	ADEL30		:from 3 on down, send 1/30 sec
	SIS	R5,3		:dec counter for 1/10 sec used
	STB	R5,.MARGE,RPI	:store updated delay count
	LIS	R2,0F		:generate 1/10 sec delay
	JFS	ADELXM		:go to XMIT instruction
	ei	:baudr-1

ADEL30	SIS	R5,1
	STB	R5,.MARGE,RPI	:SEND 1/30 SEC MORE DELAY AND COME BACK
	LIS	R2,0E		:GENERATE 1/30 SEC DELAY
ADELXM	XMIT	0,0		:SEND DELAY
	JR	RLINK		:AND EXIT TO POLLER


::*	AGETCH: Async-GET-CHaracter-from-async-ring
::	===========================================
::	Called by: CONSAT, to input a character (or something) from a port.
::	returns:   R7.  Skip +4 return if input is data, else (signal input)
::		straight return.  May return to poller (RLINK) if neither.
::	Reg Usage: Expects PN(R14), PN2(R13), RPI(R12). Clobbers R0, R1, R3,
::		R5, R6.  Returns R1(data character) or R5 (signal number).
::	Calls:	Appropriate input routine (see below).
::		AGETCH dispatches to one of the following routines (pointed
::		to by .VBSTA in the port descriptor):
::		1) AGETTI/AGETCR -- look for data character (may be
::			TID).  Returns character or break-begin signal.
::			Sets .VBSTA to AGETBR or leaves it as is.
::		2) AGETIB -- report input baud rate.  Returns TIBSIG
::			in R5.  Sets .VBSTA to AGETTI if valid baud rate
::			detected, else leaves it as is.
::		3) AGETBR -- port was last in breaking state.  Returns
::			to poller (via RLINK) if still breaking.  Else 
::			returns break-end signal in R5.  Sets .VBSTA to
::			AGETCR or leaves it as is.
::		4) VERROR -- got input start baud on disabled port.
::			Reports error to Probe and Crypto.  Leaves .VBSTA
::			unchanged.  This is the initial state for all ports.
::			When a port is answered, .VBSTA is set to AGETIB.
::		5) VCLSBA -- port has been hung, do disable SVC.
::			Sets .VBSTA to VERROR (any further input after
::			disable is an error).
::
AGETCH	HS	0
	LHL	R5,.VBSTA,RPI,	:GET THE PORT'S VBAUD STATE VECTOR
	J	SEG1,R5,,		:GO DO IT

AGETTI	HS	0		:GET A TID CHARACTER
AGETCR	HS	0		:GO GET A DATA CHARACTER
	LB	R3,IBRATE,PN,	:GET THE PORT'S IBR
	GCHAR	0,R3		:GET A CHAR FROM ASYNC RING
	J	AGETC0		:GOT ONE				###wjl
:	...microcode assumes eight bits, 2741 characters are six bits,	###wjl
:	BAUDOT characters are five bits...				###wjl
	IF	1-BAUDR		:only on 1200 baud CONSATs		###wjl
	LB	R3,BTCHAR,R3,	:get bit mask for character length
	LR	R1,R0		:work on data in R1
	NR	R1,R3		:strip char to proper length
	JNFS	AGETC0		:anything left is data
	EI	:1-BAUDR	:###wjl
	IF	TELEX		:###wjl
	TBT	PN,TLXP,,	:probably not needed ###jhl
	JEFS	AGTC10
	RBT	PN,FWDPTH,,
AGTC10  HS	0
	EI	:TELEX		:must really be breaking
	LHI	R5,AGETBR-SEG1	:NEW VBAUD STATE VECTOR (BREAKING)
	STH	R5,.VBSTA,RPI,	:
	LIS	R5,2		:BBSIG = 2 (BEGIN BREAK)
	JR	R7		:STRAIGHT RETURN (SIGNAL)

AGETC0	HS	0		:GOT A CHARACTER (R0)
	LIS	R3,1		:INCREMENT COUNT OF CHAR'S INPUT
	AM	R3,CTASYI,,	:
:	MINH(R4,CPSIN)		:COUNT CHAR'S INPUT
	LR	R1,R0		:CONSAT WANTS THE CHAR IN R1
	IF	TELEX		:probably not needed ###jhl
	TBT	PN,TLXP,,
	JEFS	AGTC20
	SBT	PN,FWDPTH,,
AGTC20  EI	:TELEX
	J	4,R7		:SKIP RETURN (DATA)

AGETNS	HS	0		:GOT NOISE FROM SPM
	LIS	R3,0		:LOWEST BAUD RATE
	GCHAR	0,R3		:EAT A CHARACTER'S WORTH
	NOP			:NORMAL RETURN (BREAK)
	J	4,R7		:SKIP RETURN CAUSES IT TO BE IGNORED, LEAVE
				:.VBSTA AS IS SO WE'LL TRY AGAIN.

AGETIB	HS	0		:ASYNC PORT IN TID MODE
	SPM	R6,0		:DETERMINE LENGTH OF START BAUD, RETURN WITH
				:R6 = INDEX FOR VIDG TABLE.
	JBS	AGETNS		:STRAIGHT RETURN = NOISE
	LB	R1,VIDG+$A36,R6	:MAP PULSE WIDTH INTO BRATE
:???	LB	R1,BRMAP,R1	:TRANSLATE???
	NHI	R1,0F
:	STB	R1,IBRATE,PN,	:SET IBRATE
:	STB	R1,OBRATE,PN,	:SET OBRATE
	LHI	R5,AGETTI-SEG1	:SET .VBSTA TO REPORT TID CHAR.
	STH	R5,.VBSTA,RPI,	:
	LIS	R5,1		:TIBSIG = 1 TO CONSAT
	JR	R7		:STRAIGHT RETURN FOR CONTROL SIGNAL

AGETBR	HS	0		:PORT WAS LAST IN BREAKING STATE
	LB	R3,IBRATE,PN,	:GET PORT'S BAUD RATE INDEX
	GCHAR	0,R3		:TRY TO GET A CHARACTER
	JFS	AGETB0		:GOT A CHARACTER
	NOPR			:PADDING
	IF	TELEX		:probably not needed ###jhl
	TBT	PN,TLXP,,
	JEFS	AGTB10
	RBT	PN,FWDPTH,,
AGTB10  EI	:TELEX
	JR	RLINK		:STILL IN BREAKING STATE - DON'T GO BACK
				:TO CALLER, INSTEAD TO POLLING PROCESS

AGETB0	HS	0		:JUST ENDED BREAKING STATE, DISCARD CHAR IN R0
	LHI	R5,AGETCR-SEG1	:NEW VBAUD STATE VECTOR (GET DATA CHAR)
	STH	R5,.VBSTA,RPI,	:
	LIS	R5,3		:BESIG = 3 (BREAK END SIGNAL)
	IF	TELEX	:probably not needed###jhl
	TBT	PN,TLXP,,
	JEFS	AGTB20
	SBT	PN,FWDPTH,,
AGTB20  EI	:TELEX
	JR	R7		:STRAIGHT RETURN

VERROR	HS	0		:GOT VBAUD HIT ON PORT NOT YET ANSWERED
				:PROBABLE HARDWARE FAULT
	LHI	R0,NR.SBR	:MESSAGE TYPE 25
	STH	R0,SUPMBF	:STORE FOR SUPE
	LI	R0,(NACARD^10)+80008000,PN	:NO. ASYNC CARDS AND PORT#
	ST	R0,SUPMBF+2	:SAVE FOR SUPE
	LR	R7,RLINK	:SAVE LINK REGISTER
	JAL	R10,SUP12,,	:REPORT TO SUPE AND XRAY
	SVC	0F,SV.DSY	:DISABLE ASYNC PORT
	JR	R7		:RETURN TO POLLER

VCLSBA	HS	0		:TURN OFF SBA FOR HUNG PORT
	SVC	0F,SV.DSY	:DISABLE ASYNC PORT (SVC 0F,19)
	LHI	R0,VERROR-SEG1	:SET NEW .VBSTA POINTER
	STH	R0,.VBSTA,RPI,	:IF THIS HAPPENS AGAIN, IT'S AN ERROR
	JR	RLINK		:EXIT TO POLLER RATHER THAN CALLER

::*	APUTCH:	Async-PUT-CHaracter-to-async-ring
::	=========================================
::	Called by: CONSAT, to put a character to a port. 
::	returns:	Via [R7].
::	Reg Usage: Expects PN(R14), PN2(R13), R1(data character). Clobbers
::			R0, R2.
::	Calls:	Nothing.
::		Gets the port's OBR to R2, loads the character into R0,
::		does an XMIT.
::
APUTCH	HS	0
	LIS	R2,1		:COUNT CHAR'S OUT
	AM	R2,CTASYO,,
:	MINH(RBF,CPSOUT)	:COUNT OUTPUT CHARACTERS
	LR	R0,R1		:GET CHAR TO R0
	IF	TELEX	:addresses the case that we just changed state
			:from output break to data state, and there may
			:be some breaks left over.  EMPTYing the
			:buffer had the nasty effect of losing any
			:signals that were waiting to be read. ###jhl
	NHI	R1,1F		:check for null character with E0 bits set
	JNFS	APTC10		:check on nulls for TELEX ports
	TBT	PN,TLXP,,	:nulls to async ports are OK
	JEFS	APTC10
	JR	R7		:no nulls to TELEX ports in data state
APTC10	EI	:TELEX
	LB	R2,OBRATE,PN	:GET OBR FOR PORT MUST BE IN R2
	XMIT	0,0		:PUT CHAR TO ASYNC RING
	JR	R7		:RETURN

	IF	TELEX

:	routine to output a break to an async terminal.  Uses index of
:	0A as the output break (null character) speed.  Used only in
:	the TELEX environment for 50 baud BAUDOT terminals.

APUTBR	HS	0
	LHI	R2,BRKNDX	:get OBR for BREAK--must be in R2
	LR	R0,R1		:GET CHAR TO R0
	XMIT	0,0		:PUT CHAR TO ASYNC RING
	JR	R7		:RETURN

	EI	:TELEX


::*	DT.PRT: DeTach-async-PoRT
::	=========================
::	Called by: CONSAT Hang/Answer when a port is hung.
::	returns:	Via [RLINK].
::	Reg Usage: Expects PN(R14), RPI(R12). Clobbers many.
::	Calls:	CRYPTO(R8), EMPTY(R7), RFCBUF(R8), ZAPHRD(R9)
::		Reports port hung to Crypto, zaps any circuit connected
::		to the port, returns all the port's buffers to the pool,
::		reinitializes the port descriptor.
::

DT.PRT	HS	0		:CALLED FROM HANG-AND-ANSWER ONLY WHEN A PORT
				:GOES HUNG
	IF	NUMPRN		:###jhl
PRNTRG	EQ	0F		:halfword of bits for P.FLSH and F.FLSH
	CLHI	PN,PRNTRG	:could this be a printer port? 	###jhl
	JGFS	DT.PR5		:don't set bit if beyond the halfword
	SBT	PN,P.FLSH,,	:set flush bits so output goes to port
	SBT	PN,F.FLSH,,	:else can achieve non-interactive state
DT.PR5	EI	:NUMPRN		:###jhl

	LR	R0,PN		:STATUS (HO HW OF R0)=0 (HUNG)
	JAL	R8,CRYPTO,,
	HC	CRYE3F		:PORT STATUS

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R1,RGST,,
	JAL	R4,DTPDB1,,
	GL	DTPDB1
	LIS	R1,0		:CASE # 0
	JAL	R4,DPCAS,,
	GL	DPCAS
	L	R4,REGST,,
	L	R1,RGST,,
	EI	:LNFDBG		

	L	R2BE,.FTBUF,RPI	:HAD PORT BEEN ANSWERED?

:****	case 0 -- no buffers assigned to port. just return.
	JLE	DTPEXT		:NO, JUST RETURN ###LSH

	TBT	PN,C.ACP	:SEE IF TID HAS BEEN RCVD (AVID3)
	JN	DTPTID		:YES, CONTINUE

:****	case 1 -- port answered, but no TID entered yet.
	XHI	R2,4		:flip to .TTBUF
	LHL	R3,BF,R2,	:get BF of .TTBUF (set up via IZ.PRT)
	LIS	R0,0
	STH	R0,IOTAB,R3,R3	:clear permuter table entry
	XHI	R2,4		:flip back to .FTBUF
	JAL	R8,RFCBUF,,	:TID not yet rcvd, return .FTBUF/.TTBUF pair

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R1,RGST,,
	LIS	R1,1		:CASE # 1
	JAL	R4,DPCAS,,
	L	R4,REGST,,
	L	R1,RGST,,
	EI	:LNFDBG		

	J	DTCPFT		:clear port table (.ftbuf,.ttbuf), and exit

:	got the TID.  Was port in login mode?
DTPTID	HS	0
	RBT	PN,LOGING	:IN LOGIN MODE?
	JE	DTPNLN		:NO

:****	case 2 -- TID received and port in login mode.

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R1,RGST,,
	LIS	R1,5		:CASE # 5
	JAL	R4,DPCAS,,
	L	R4,REGST,,
	L	R1,RGST,,
	EI	:LNFDBG	

	LHL	R3,BF+4,R2,	:get BF of .TTBUF (set up via IZ.PRT)
	LIS	R0,0
	STH	R0,IOTAB,R3,R3	:clear permuter table entry
	JAL	R8,RFCBUF,,	:return the .FTBUF/.TTBUF pair
	L	R2,.LGBUF,RPI
	JAL	R8,RFCBUF,,	:return .LGBUF
	L	R2,.ALBUF,RPI	:get index of .ALBUF

				:**** case 5 -- TID received and port in
				:login mode, but either .ALBUF <= 0, or
				:BF of .ALBUF is DEAD (negative).

	JLE	DTCPLA		:must not zap if .albuf is'nt there.
				:clear port table (.lgbuf,.albuf,.ftbuf,
				:.ttbuf), and exit.

:	The following check is for the case that we build an internal
:	circuit, as to XRAY, but get OUT OF XRAY SLOTS from INTHST.
:	The ensuing ZAPX by INTHST DEADs the buffer, and a reset after
:	it causes a 5463 crash.###jhl

	LH	R8,BF,R2,	:check BF of .ALBUF
	JL	DTPLCL		:must not zap if BF is DEAD
				:clear logger list, clear port table
				:(.lgbuf,.albuf,.ftbuf,.ttbuf), and exit.

	LHL	R8,BF+4,R2,	:get BF of .ALBUF+4--ANI channel
	SHI	R8,ANIZFL	:relative offset into ANIFLG-length array
	SBT	R8,LOGSTB,,	:so ASYLOU won't crash on outstanding data

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R1,RGST,,
	LIS	R1,2		:case #2
	JAL	R4,DPCAS,,
	L	R4,REGST,,
	L	R1,RGST,,
	EI	:LNFDBG		

	JAL	R9,ZAPHRD,,	:.ALBUF is set up, send zapper down
	J	DTCPLA		:clear port table (.lgbuf,.albuf,.ftbuf,
				:.ttbuf), and exit


:	Port not in login mode.  Does a built circuit lead from it?
DTPNLN	HS	0
	LHL	R8,BF,R2,	:check for circuit built via BF of .FTBUF
	CLHI	R8,TLGZFL+(NPGRP+1)/2*20	:BF in TOLOG range
						:means circuit not built yet
	JGE	DTPBLT		:circuit is built, OK to ZAPHRD
	CLHI	R8,TLGZFL	:be sure it's not INTHST channel
	JL	DTPBLT		:circuit is built, OK to ZAPHRD

:****	case 3 -- port not in login mode, but here from LGNSUP.
:	BF is in the range of TOLOG

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R1,RGST,,
	LIS	R1,3		:CASE # 3
	JAL	R4,DPCAS,,
	L	R4,REGST,,
	L	R1,RGST,,
	EI	:LNFDBG

	XHI	R2,4		:flip to .TTBUF
	LHL	R3,BF,R2,	:get BF of .TTBUF (set up via IZ.PRT)
	LIS	R0,0
	STH	R0,IOTAB,R3,R3	:clear permuter table entry
	XHI	R2,4		:flip back to .FTBUF
	JAL	R8,RFCBUF,,	:return the .FTBUF pair
	J	DTCPFT		:clear port table (.ftbuf,.ttbuf), and exit.

:****	case 4 -- not in login mode and circuit has been built.
:	BF is in the range of LNKFLG or equal to 0 in the case of
:	MPVC sub port.
DTPBLT	JAL	R9,ZAPHRD,,	:zap the hell out of it

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R1,RGST,,
	LIS	R1,4		:CASE # 4
	JAL	R4,DPCAS,,
	L	R4,REGST,,
	L	R1,RGST,,
	EI	:LNFDBG		

	J	DTCPFT		:clear port table (.ftbuf,.ttbuf), and exit.


DTPLCL	LR	R6,R2		:jump here to skip ZAPHRD.
	JAL	R9,LOGCLR,,	:remove .albuf from logger list

DTCPLA	HS	0		:clear port table (.lgbuf, and .albuf)
	LCS	R1,1		
	ST	R1,.LGBUF,RPI
	ST	R1,.ALBUF,RPI
DTCPFT	LCS	R1,1
	ST	R1,.FTBUF,RPI	:clear port table (.ftbuf, and .ttbuf)
	ST	R1,.TTBUF,RPI
	SBT	PN,ASYACP,,	:declare the port not in use

DTPEXT	HS	0

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,DTPDB2,,
	GL	DTPDB2
	L	R4,REGST,,
	EI	:LNFDBG		

	JR	RLINK		:AND RETURN


::*	CIRDIS: CIRcuit-DISconnect
::	==========================
::	Called by: CONSAT to disconnect a circuit from a port.
::	returns:	Via IZ.PRT to [RLINK], or via [RLINK] for MPVC
::			pseudo port.
::	Reg Usage: Expects RPI(R12), PN(R14), PN2(R13). Clobbers R2, R9.
::	Calls:	ZAPHRD(R9), IZ.PRT.
::		Zaps the existing circuit, then goes to IZ.PRT to set up
::		for new login.
::
::	###LSH   THIS ROUTINE HAS BEEN REWRITTEN BY LOUISA HSU
::
CIRDIS	HS	0

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R3,RGST,,
	JAL	R4,CRDDB1,,
	GL	CRDDB1
	LIS	R3,0		:CASE # 0
	JAL	R4,CRCAS,,
	GL	CRCAS
	L	R4,REGST,,
	L	R3,RGST,,
	EI	:LNFDBG		

	L	R2,.FTBUF,RPI,	:HAD PORT BEEN ANSWERED ?

:****	case 0 -- The port is not answered, no buffers assigned to the
:		  port yet, just return
	JLE	CRDEXT		:NO, JUST RETURN

	TBT	PN,C.ACP	:SEE IF TID HAS BEEN RECEIVED (AVID3)
	JN	CRDTID		:YES, CONTINUE

:****	case 1 -- Port answered, but no TID entered yet

	IF	NMPVC						###LSH
	CLHI	PN,.MPORT	:IS THIS AN MPVC PSEUDO PORT ?  ###LSH
	JL	CIRDS8		:IF NOT, DO'NT NEED CLEAR IOTAB ###LSH
	LHL	R3,BF+4,R2,	:OTHERWISE, CLEAR IOTAB 	###LSH
	LIS	R0,0		:		    		###LSH
	STH	R0,IOTAB,R3,R3	:CLEAR ASYTAB ENTRY 		###LSH
	EI	:NMPVC						###LSH
CIRDS8	JAL	R8,RFCBUF,,	:RETURN .FTBUF/.TTBUF	PAIR

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R3,RGST,,
	LIS	R3,1		:CASE # 1
	JAL	R4,CRCAS,,
	L	R4,REGST,,
	L	R3,RGST,,
	EI	:LNFDBG		

	J	CRCPFT		:clear port table (.ftbuf .ttbuf) and
				:exit, if it is MPVC pseudo port.
				:Otherwise, rebuild from async ring.

:	got the TID, Was port in login mode ?
CRDTID	RBT	PN,LOGING	:IN LOGIN MODE?
	JE	CRDNLN		:NO

:****	case 2 -- TID received, and port is still in login mode

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R3,RGST,,
	LIS 	R3,5 		:CASE # 5
	JAL	R4,CRCAS,,
	L	R4,REGST,,
	L	R3,RGST,,
	EI	:LNFDBG		

	IF	NMPVC		:				###LSH
	CLHI	PN,.MPORT	:IS THIS AN MPVC PSEUDO PORT ?  ###LSH
	JL	CIRDS9		:IF NOT, DO'NT NEED CLEAR IOTAB ###LSH
	LHL	R3,BF+4,R2,	:OTHERWISE, CLEAR IOTAB ENTRY   ###LSH
	LIS	R0,0		:				###LSH
	STH	R0,IOTAB,R3,R3	:CLEAR ASYTAB ENTRY		###LSH
	EI	:NMPVC						###LSH
CIRDS9	JAL	R8,RFCBUF,,	:RETURN THE .FTBUF/.TTBUF PAIR
	L	R2,.LGBUF,RPI,	:RETURN THE .LGBUF
	JAL	R8,RFCBUF,,
	L	R2,.ALBUF,RPI,	:deal with .ALBUF

				:**** case 5 -- TID received and port in
				:login mode, but either .ALBUF <= 0, or
				:BF of .ALBUF is DEAD (negative).

	JLE	CRCPLA		:don't ZAPHRD if .ALBUF is'nt there
				:clear port table (.lgbuf, .albuf) 
				:first, and then 
				:also clear port table (.ftbuf,.ttbuf),
				:and exit if it is MPVC pseudo port.
				:Otherwise, rebuild from async ring.

	LH	R8,BF,R2,	:BF of .ALBUF :###LSH

	JL	CRDLCL		:DON'T ZAPHRD if BF of .ALBUF DEAD
				:clear .albuf from logger list.
				:clear port table (.lgbuf, .albuf) 
				:first, and then 
				:also clear port table (.ftbuf,.ttbuf),
				:and exit if it is MPVC pseudo port.
				:Otherwise, rebuild from async ring.

	LHL	R8,BF+4,R2,	:get BF of .ALBUF+4 (ANI channel) ###LSH
	SHI	R8,ANIZFL	:relative ANI channel #  ###LSH
	SBT	R8,LOGSTB,,	:so ASYLOU won't crash on outstanding

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R3,RGST,,
	LIS	R3,2		:CASE # 2
	JAL	R4,CRCAS,,
	GL	CRCAS
	L	R4,REGST,,
	L	R3,RGST,,
	EI	:LNFDBG		
	
	JAL	R9,ZAPHRD,,	:send zapper down
	J	CRCPLA		:clear port table (.lgbuf,.albuf)
				:first, and then 
				:also clear port table (.ftbuf,.ttbuf),
				:and exit if it is MPVC pseudo port.
				:Otherwise, rebuild from async ring.

:	the port was not in login mode
CRDNLN	HS	0
	LHL	R8,BF,R2,	:CHECK IF CIRCUIT IS BUILT OR NOT
	CLHI	R8,LNKZFL	:IF BF IS IN LINK CHANNEL RANGE
	JGE	CRDBLT		:circuit is built, then OK to ZAPHRD

:****	case 3 -- the port was not in login mode,but BF is not in 
:		  link range. 
:			(In the case of MPVC sub-port, BF = TOMPVC  ?)

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R3,RGST,,
	LIS	R3,3		:CASE # 3
	JAL	R4,CRCAS,,
	L	R4,REGST,,
	L	R3,RGST,,
	EI	:LNFDBG		

	JAL	R8,RFCBUF,,	:return .ftbuf pair
	J	CRCPFT		:clear port table (.ftbuf .ttbuf) and
				:exit, if it is MPVC pseudo port.
				:Otherwise, rebuild from async ring.

:****	case 4 -- not in login mode and circuit has been built.
:	BF is in  the range of LNK.
CRDBLT	JAL	R9,ZAPHRD,,	:send zapper down
	
	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R3,RGST,,
	LIS	R3,4		:CASE # 4
	JAL	R4,CRCAS,,
	L	R4,REGST,,
	L	R3,RGST,,
	EI	:LNFDBG		

	J	CRCPFT		:clear port table (.ftbuf .ttbuf) and
				:exit, if it is MPVC pseudo port.
				:Otherwise, rebuild from async ring.



CRDRBD	HS	0

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,CRDDB2,,
	GL	CRDDB2
	L	R4,REGST,,
	EI	:LNFDBG		

	J	IZ.PRT		:and rebuild in from async ring

CRDLCL	HS	0		:###LSH
	ST	R6,CRDSAV,,	:SAVE REGISTER
	ST	R9,CRDSSV,,
	LR	R6,R2		:###LSH
	JAL	R9,LOGCLR,,	:REMOVE FROM LOGGER LIST ###LSH
	L	R6,CRDSAV,,
	L	R9,CRDSSV,,

CRCPLA	LCS	R2,1
	ST	R2,.LGBUF,RPI,	:clear port table (.lgbuf, and .albuf)
	ST	R2,.ALBUF,RPI,	:clear port table (.ftubf, and .ttbuf)
CRCPFT	HS	0		:###LSH
	IF	NMPVC
	CLHI	PN,.MPORT	:is this an mpvc pseudo port
	JL	CRDRBD		:if not, OK to reinit
	LCS	R2,1		:otherwise, update port table
	ST	R2,.FTBUF,RPI,
	ST	R2,.TTBUF,RPI,
	SBT	PN,ASYACP,,	:declare port available ###LSH
       ELSE         :only MPVCs want to fall through thus if no MPVCS  ###sdw
        J       CRDRBD  :then you always need to get back your buffers 1/20/87
	EI	:NMPVC

CRDEXT	HS	0

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,CRDDB2,,
	L	R4,REGST,,
	EI	:LNFDBG		

	JR	RLINK		:return






:	:CIRDSC is called from MPSCAN to zap the part of the login
:	circuit for the MPVC sub-port originating from logon
:	processing routines up to LGGO.	The BF of .FTBUF has just been
:	changed to point to the MPVC pseudo-port, and we want the
:	actual logon to be handled by the MPVC pseudo-port itself.
:	We leave .LGBUF there, because M.MUX must send the subport
:	username to the transaction switch, and we leave .ALBUF there
:	for the node code to time out its logon attempt (recall
:	that ESTPRT has already written HST0, TID to .ALBUF).
:	Note--it may be better, if possible, to get rid of .ALBUF at
:	MPSCAN time, by LOGCLR, clearing the timeout entry, and
:	RFCBUFing .ALBUF.  For now, this works.
:	We must see that ASYLOU doesn't zap the circuit with the
:	PLS SEE REP msg, but this requires fixing ASYLOU to handle
:	data for a port whose BF is pointing to TOMPVC.
:	calls:	niente
:	Links:	R10(RLINK)
:	Uses:	R0, R2, R3
:	Assumes:	RPI(R12) for MPVC subport

	IF	NMPVC

CIRDSC	HS	0		:###jhl
 	L	R2,.ALBUF,RPI,	:get buffer which points to logger
	LHL	R3,BF+4,R2,	:BF of .ALBUF+4 is absolute ANI channel
	SHI	R3,ANIZFL	:subtract base offset into ALMTAB
	SBT	R3,SUBSTB,,	:tell ASYLOU this login stuff is abandoned
	JR	RLINK		:and return

	EI	:NMPVC


::*	CPEEK:	Character-Peek routine
::	==============================
::	Called by: CONSAT to find out if there is a signal at the front
::			of a buffer.
::	returns:	[R7] if data or nothing, [R7]+4 if signal.
::	Reg Usage: Expects RBP(R2).  Returns R1(signal number if signal).
::			Clobbers R1, R8.
::	Calls:	PCIS(R8), PCI(R8)
::		Peeks into the specified buffer.  If the buffer is empty
::		(or unused) or the peeked byte(s) is data, gives a straight
::		return.  If we find a control code, we translate it into
::		a CONSAT signal (in R1) and do a skip+4 return.  There are
::		times when the CONSAT might ordinarily defer processing of
::		further output to a port unless there is a zapper or 
::		pending.  This is how it finds out.
::
CPKDIS	HS	0		:DISPATCH TABLE FOR CONTROL CHARACTERS
				:DETECTED IN BUFFER BY CPEEK.
	HC	CPEEK0-SEG1	:00 (ESCAPE)
	HC	CPEEK1-SEG1	:01 (PREFIX)
	HC	CPEEK2-SEG1	:02 (GOBBLER - ILLEGAL)
	HC	CPEEK3-SEG1	:03
	HC	CPEEK4-SEG1	:04
	HC	CPEEK5-SEG1	:05
	HC	CPEEK6-SEG1	:06
	HC	CPEEK7-SEG1	:07

CPEEK	HS	0
	LH	R1,BF,R2,	:BUFFER ASSIGNED?
	JLR	R7		:NO, STRAIGHT RETURN.

	LHL	R1,BCT,R2,	:BUFFER EMPTY?
	JER	R7		:YES, RETURN

	JAL	R8,PCIS,,	:PEEK AT A CHARACTER
	THI	R1,0FFF8	:TYMNET CHAR?
	JNR	R7		:NO, DATA, RETURN

	LHL	R1,CPKDIS,R1,R1	:GET POINTER TO APPROPRIATE ROUTINE
	J	SEG1,R1,		:AND GO DO IT

CPEEK0	HS	0		:ESCAPE (00) DETECTED
	JR	R7		:ESCAPED DATA, RETURN

CPEEK1	HS	0		:PREFIX (01) DETECTED
	JAL	R8,PCI,,	:GET 2ND CHARACTER
	LB	R1,PFXSIG,R1,R1	:TRANSLATE TO CONSAT SIGNAL NO.
	JN	4,R7		:SKIP RETURN, OK IF NON-0
	J	CPKCR		:INVALID SIGNAL, DISREGARD IT.

CPEEK2	HS	0		:T-I GOBBLER (ILLEGAL)
	HC	0		:02 ILLEGAL, CRASH

CPEEK3	HS	0		:TRANSLATE 03-PAIR
	JAL	R8,PCI,,	:GET SECOND CHARACTER
	CLHI	R1,1		:01?
	JEFS	CPK301		:GO DO ZAPPER

	CLHI	R1,3		:03?
	JEFS	CPK301		:NON-GOBBLING ZAPPER, TREAT AS ZAPPER

	CLHI	R1,8		:08?
	JEFS	CPK308		:GO DO GOBBLER

	HC	0		:ALL ELSE ILLEGAL, CRASH

CPK301	HS	0
	LIS	R1,0C		:ZAPPER SIGNAL
	J	4,R7		:AND RETURN STRAIGHT
	
CPK308	HS	0
	LIS	R1,0D		:GOBBLER SIGNAL
	J	4,R7

CPEEK4	HS	0
	LIS	R1,9		:LEAVE DEM SIGNAL
	J	4,R7		:AND STRAIGHT RETURN

CPEEK5	HS	0
	LIS	R1,0F		:GREEN BALL SIGNAL
	J	4,R7

CPEEK6	HS	0
	LIS	R1,0E		:RED BALL SIGNAL
	J	4,R7

CPEEK7	HS	0
	LIS	R1,8		:ENTER DEM SIGNAL
	J	4,R7

				:###LSH
CPKCR	HS	0		:GOT INVLAID PREFIX CODE, DISREGARD IT.
	LH	R0,BF,R2,	:OUTGOING CHANNEL NUMBER
	JAL	R8,CRYPTO,,
	HC	CRYE78		:UNRECOGNIZED SIGNAL RECEIVED
	J	ASYPOL

::*	EMPTY:	EMPTY-buffer
::	====================
::	Called by: CONSAT, to empty a buffer.
::	returns:	Via [R7].
::	Reg Usage: Expects RBP(R2). Clobbers R8.
::	Calls:	CBCLR(R8).
::		Does a CBCLR of the specified buffer if appropriate.
::
EMPTY	HS	0

	IF	BFSDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,EMTDB1,,
	GL	EMTDB1
	L	R4,REGST,,
	EI	:BFSDBG	

	LR	RBP,RBP		:Buffer assigned yet?
	JLR	R7
	LH	R8,BF,RBP,	:Is BF DEAD already ?	###LSH
	JL	EMTCRH		:CRASH			###LSH
	LH	R8,BCT,RBP,	:Any data in it?
	JLER	R7		:No.
	JAL	R8,CBCLR,,	:DOES THE EMPTYING
	JR	R7		:RETURN

EMTCRH	CRASH.(.EMTR0)		:EMPTY A DEAD BUFFER



::*	ESTPRT: ESTablish-async-PoRT
::	============================
::	Called by: CONSAT, when a TID is received for a new port or an 
::			existing port is zapped.
::	Returns:	Via CIRBLT or XLSTAT to poller (RLINK).
::	Reg Usage: Expects RPI(R12), PN(R14).  Clobbers R5, R2, R1,
::			R8, R0,	R9.
::	Calls:	GFCBUF(R8), LOGIN(R8), WHWI(R9), WCI(R8), RSTACP(R8)
::		Assigns a login channel number (from ASYNXT) to the port.
::		This is done by finding the next sequential channel number
::		in the range of login channels for which both ANITAB and
::		ALMTAB entries are free, and which was last used no less
::		than a minute previously.  This assures that we don't reuse
::		a login port number which the supervisor may think is still
::		in use.  If no channel is available, we tell the CONSAT
::		"no path available...".
::
::		We connect the port to the login process, assign some
::		buffers for login processing (1 for use by the CONSAT, a
::		pair for our own use), then JAL to LOGIN to set up for the
::		login string.  LOGIN gives us a straight return if there
::		is no supervisor and we so inform the CONSAT via XLSTAT.
::		Otherwise, we return to the CONSAT via CIRBLT so it can
::		finish setting up for the login. 
::


ESTPRT	HS	0
	NHI	R5,ESTPST	:test the bit
	JEFS	ESTP10		:branch if we came from elsewhere
	TS	ESTSRC,,	:set cell neg if from PSTATE
	JFS	ESTP20
ESTP10	STH	R5,ESTSRC,,	:else zero out the cell
ESTP20	HS	0
	SBT	PN,C.ACP,,	:Make sure we show TID received		###wjl
	LHL	CHN,ASYNXT,,	:Find next available ANITAB entry
	LR	R2,CHN		:Save CHN to avoid endless looping!	###wjl
ESTPR0	SIS	CHN,1		:We search from the bottom up
	JGEFS	ESTPR1		:No wrap
	LHI	CHN,NANIPT-1	:Total number of ANITAB entries
ESTPR1	HS	0
	CR	R2,CHN		:Have we checked them all?		###wjl
	JE	ESTDIS		:Yes, go disconnect the circuit		###wjl
	STH	CHN,ASYNXT,,	:Update next available port
	TBT	CHN,ALMACP,,	:Is this one available?
	JEBS	ESTPR0		:No
	TBT	CHN,ANIACP,,	:CHECK NODE CODE SIDE
	JE	ESTPR0		:NOT AVAILABLE

	IF	NMPVC
	CLHI	PN,.MPORT	:NMPVC pseudo port can try to call ESTPRT
	JLFS	ESTNM4		:without having FTBUF/TTBUF set up.
	L	R2,.FTBUF,RPI	:(see ZAPPER and CIRDIS).  This check
	JLR	RLINK		:avoids problems from that case.###jhl
	JFS	ESTNM8
ESTNM4	EI	:NMPVC
	L	R2,.FTBUF,RPI	:GET FROM-TERMINAL BUFFER
ESTNM8	LHI	R1,TLGZFL,PN	:POINT IT TO LOGGER
	STH	R1,BF,R2,	:
	XHI	R2,4		:TO-TERMINAL BUFFER
	STH	R2,ALMTAB,CHN,CHN :GET LOGIN DATA FROM NODE VIA ANITAB
:	set up .LGBUF
ESTP30	JAL	R8,GFCBUF,,	:GET A FREE BUFFER PAIR - R2 = BUFFER INDEX
	J	GFCERR		:immed. return - out of buffers!	###wjl
	ST	R2,.LGBUF,RPI	:+4, ok - POINT TO THIS BUFFER FOR LOGIN DATA
ESTP40	LHI	R1,GLGZFL,PN
	STH	R1,BF,R2,	:BF of .LGBUF is GOLOG channel
:	set up .ALBUF
	JAL	R8,GFCBUF,,	:GET ANOTHER BUFFER PAIR
	J	GFCERR		:immed. return - out of buffers!	###wjl
	ST	R2BE,.ALBUF,RPI	:+4 return - ok, store in the port table
	IF 	TELEX
	TBT	PN,TLXP,,	:is it a TELEX port?
	JEFS	ESTPR2		:won't be IIX unless it's TELEX
	OHI	R2BE,IIXLOG	:set low order bit so LOGGER knows
ESTPR2	EI	:TELEX	
	STH	R2BE,ANITAB,CHN,CHN	:store in the IOTAB
	IF	TELEX
	NHI	R2BE,0FFFC	:get rid of any stray bits from above
	EI	:TELEX
	LHL	R1,.TERMT,RPI	:TERMINAL TYPE POINTER
	LB	R0,VID.ID,R1,	:GET TID FOR LOGIN
	XHI	R2BO,4		:THE OTHER BUFFER POINTS BACK TO THE PORT
	LHI	R1,ANIZFL,CHN
	STH	R1,BF,R2BO,	:BF of .ALBUF+4 is abs port number
	XHI	R2BE,4		:point to .ALBUF again

	IF	LNFDBG		:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,ESPDB1,,
	GL	ESPDB1
	L	R4,REGST,,
	EI	:LNFDBG

	AHI	CHN,ANIZFL	:LOGIN WANTS ABSOLUTE CHANNEL NUMBER
	JAL	R8,LOGIN,,
	J	LGNSUP		:NO SUPR
:	skip return if all is well
	LHI	R1,8000+HST0	:DEPOSIT HOST # IN .ALBUF
	JAL	R9,WHWI,,
	LB	R1,LOGTID,,	:GET TID TO R1 (SAVED AT LOGTID BY LOGIN)
	JAL	R8,WCI,,	:WRITE IT

	LR	R1,CHN		:absolute ANI channel number is in CHN###jhl
	JAL	R8,RSTACP	:MARK ANI PORT IN USE
	SHI	R1,ANIZFL	:relative ANI channel ###LSH
	RBT	R1,LOGSTB,,	:make sure ASYLOU works ###LSH
	IF	NMPVC
	RBT	R1,SUBSTB,,	:make sure ASYLOU works ###LSH
	EI	:NMPVC
	LH	R8,ESTSRC,,	:check our entry cell
	JL	CIRPVC		:terminate without circling to PSTATE
	J	CIRBLT,,	:otherwise go CIRBLT --> PSTATE

:	No Login channel available					###wjl
ESTDIS	RBT	PN,C.ACP,,	:Reset and pretend Tid not received	###wjl
	L	R2,.TTBUF,RPI	:Get To-Terminal Buffer index		###wjl
	JLR	RLINK		:If buffer not there, return		###wjl
	LHI	R1,ZAPPH	:Write Zapper in TTBUF			###wjl
	EXBR	R1,R1		:and pretend Zapper comes from host.	###wjl
	JAL	R8,WCI,,	:ZAPPER routine will call CIRDIS to	###wjl
	EXBR	R1,R1		:disconnect current circuit and then	###wjl
	JAL	R8,WCI,,	:call ESTPRT again to try to		###wjl
	JR	RLINK		:reinitialize this port again.		###wjl
	
LGNSUP	HS	0
:	LOGIN called ZAPHRD, so let's clear port table entries, return
:	.LGBUF, and hang the port with a code=-3 to XLSTAT.
	L	R2,.LGBUF,RPI	:don't lose this before we return it
	LCS	R0,1		:###jhl
	ST	R0,.ALBUF,RPI	:clear out the port table entries
	ST	R0,.LGBUF,RPI	:this is case 3 for DT.PRT
	JAL	R8,RFCBUF,,	:return the .LGBUF
	LCS	R9,3		:"NO PATH AVAIL.." code
	LH	R8,ESTSRC,,	:check our entry cell
	JL	TEXT		:terminate without circling to PSTATE
	J	XLSTAT

:	This was CIRBLT, from the CONSAT environment-independent
:	portion, but it is duplicated here because we need to control
:	its termination.  ###jhl

CIRPVC	HS	0
	IF	NPAPRT
	TBT	RP,AD.PRT	:is this an addressible port?
	JEFS	CIRPV1		:no
	TBT	RP,LIMBO	:yes...is it in limbo?
	JER	RLINK		:no...don't say anything
CIRPV1	EI	:NPAPRT
	L	RBP,.LGBUF,RPI	:clear logon-buffer
	JAL	RCH,EMPTY,,	:empty buffer
	TBT	RP,HAFDUX	:is this half-duplex port?
	JEFS	CIRPV3		:no
	LIS	RBC,8		:yes...output ^H
	JAL	RCH,PUTCHR,,	:...into logon-buffer
CIRPV3	SBT	RP,LOGER	:Init Logger variables
	SBT	RP,LOGING
	SBT	RP,UNAME	:initially in user-name mode
	TBT	RP,NEWLOG	:first or subsequent invocation?
	JEFS	CIRPV5		:subsequent...
	L	RBP,.TTBUF,RPI	:To-terminal buffer-pointer
	TBT	RP,NPIPRT,,	:new port...
	JNFS	CIRPV5		:skip if shouldn't output NPID
	LA	R6,ULMSG	:yes...
	JAL	R9,MSG		:output common message
	JAL	R9,MSG0		:	followed by NPID
CIRPV5	JR	RLINK		:return to PSTATE



::*	GETCHR:	GET-CHaRacter-from-buffer
::	=================================
::	Called by: CONSAT, to get a character (or control signal) from
::			a buffer.
::	returns:	[R7] if signal, [R7]+4 if data.
::	Reg Usage: Expects RBP(R2). Returns R1(data byte or signal associated
::			data), R5(signal number if signal). Clobbers several.
::	Calls:	GCI(R8)
::		Gets a character (or pair) from the specified buffer.  If it
::		is data, returns the character in R1 with a skip+4 return.
::		If it is a control code, translates it (via the appropriate
::		table) into a CONSAT signal.  Returns the signal number in
::		R5, the associated data (if any) in R1, and does a straight
::		return.  Translating network control codes into CONSAT sig-
::		nals is generally straight-forward, except for some obsolete
::		prefix (01-pair) codes which have to be translated into
::		several non-obsolete codes which are then stuffed back into
::		the buffer for one-by-one retrieval.
::
C01OBS	HC	01C0,01C2,01C6,01C4

GCHDIS	HS	0		:DISPATCH TABLE FOR 00-07 CHARACTERS
				:DETECTED IN BUFFER
	HC	GETCH0-SEG1	:ESCAPE (00)
	HC	GETCH1-SEG1	:01-PREFIX
	HC	GETCH2-SEG1	:02 (TI GOBBLER)
	HC	GETCH3-SEG1	:03-PAIR
	HC	GETCH4-SEG1	:04 (LEAVE DEM)
	HC	GETCH5-SEG1	:05 (GREEN BALL)
	HC	GETCH6-SEG1	:06 (RED BALL)
	HC	GETCH7-SEG1	:07 (ENTER DEM)

GETCHR	HS	0


	IF	AIODBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,GTCDB1,,
	GL	GTCDB1
	L	R4,REGST,,
	EI	:AIODBG		

	LR	R2,R2	:###LSH CHANGES BEGIN HERE
	JGE	GTCHX		:BUFFER # IS NOT NEGATIVE, GO AHEAD
				:ELSE
GCHBF0	CRASH.(.GCBF0)		:GETCHR NEGATIVE BUFFER #, CRASH

GTCHX	HS	0
	CHI	R2,4
	JGFS	GTCH0		:VALID BUFFER NUMBER, GO AHEAD
				:ELSE,
GCHBF1	CRASH.(.GCBF1)		:GETCHR BUFFER 0, CRASH 

GTCH0	HS	0
	LHL	R8,BF,R2,	:SEE IF BF IS RIGHT
	JGEFS	GTCH1		:BF IS RIGHT,  GO AHEAD
				:ELSE
GCHBF2	CRASH.(.GCBF2)		:GETCHR BF OF BUFFER DEAD, CRASH

GTCH1	HS	0		:EVERYTHING IS OK, GO AHEAD
			:###LSH	CHANGES END HERE

	JAL	R8,GCI,,	:GET A CHARACTER

	IF	AIODBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,GTCDB2,,
	GL	GTCDB2
	L	R4,REGST,,
	EI	:AIODBG		

	THI	R1,0FFF8	:CONTROL (00-07)?
	JN	4,R7		:NO, SKIP RETURN WITH DATA IN R1.

	LHL	R1,GCHDIS,R1,R1	:GET POINTER TO APPROPRIATE ROUTINE
	J	SEG1,R1,		:AND GO DO IT

GETCH0	HS	0		:ESCAPE (00) DETECTED
	JAL	R8,GCI,,	:GET ESCAPED DATA CHARACTER

	IF	AIODBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,GTCDB2,,
	L	R4,REGST,,
	EI	:AIODBG		

	J	4,R7		:AND SKIP RETURN WITH DATA IN R1.

GETCH1	HS	0		:PREFIX (01) DETECTED
	JAL	R8,GCI,,	:GET 2ND CHARACTER

	IF	AIODBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,GTCDB3,,
	GL	GTCDB3
	L	R4,REGST,,
	EI	:AIODBG		

	LH	R5,PFXSIG,R1,R1	:TRANSLATE TO CONSAT SIGNAL NO.
	JE	GCHRCR		:INVALID SIGNAL, DISREGARD IT.
	JLFS	GCHR1X		:NOT EASILY TRANSLATED
	LBR	R1,R5		:VALUE IS 2ND BYTE
	SRHLS	R5,8		:1ST BYTE ONLY
	J	GCHEXT		:STRAIGHT RETURN	:###LSH

	GL	C01OBS,WCD

	if	0	:###jhl
GCHR1X	HS	0		:WE'VE RECEIVED A 01-PAIR THAT DOES NOT EASILY
				:(1-TO-1) TRANSLATE INTO A CONSAT SIGNAL.
	THI	R1,0F0		:IS IT A 01-0X?
	JN	GCHR1Y		:NO
				:WE'VE RECEIVED AN OBSOLETE 01-PAIR (01::0x)
				:WHICH MUST BE TRANSLATED INTO 4 01-PAIRS --
				:01::C4 + 1-BIT OF x
				:01::C6 + 2-BIT OF x
				:01::C2 + 4-BIT OF x
				:01::C0 + 8-BIT OF x
	LR	R5,R1		:PRESERVE R1
	LIS	R6,6
GCHR1Z	NHI	R1,1
	OH	R1,C01OBS,R6	:
	JAL	R8,WCD,,	:PREFIX 2ND BYTE
	EXBR	R1,R1		:SWAP
	JAL	R8,WCD,,	:PREFIX 01
	SIS	R6,2
	JL	GETCHR		:DONE, BACK TO THE TOP
	SRHLS	R5,1
	LR	R1,R5
	J	GCHR1Z		:NEXT ONE
	else	:1	:###jhl

:	we've received an obsolete 01-pair which must be translated into
:	several current 01-pairs (see CIRCUIT PROTOCOL Appendix I.)
:	Use similar approach to that used in DISPI--DSITMC.  Make use of
:	a table of mask, shift, and translate values to step through the
:	fields of the obsolete message.

GCHR1X	LR	R5,R1		:save second byte
	SRHLS	R1,4		:dispatch on hi-order 4 bits
	CLHI	R1,GC1MAX	:confirm 010x or 011x only
	JGE	GCHR1Y		:crash if out of range
	LB	R6,GC108,R1	:R6 is offset to translator values
GC1OBG	LB	R1,GC180,R6	:R1 is (maybe) mask of interesting bits
	THI	R1,80		:80 is our end-marker
	JN	GETCHR		:back to the top. Else it's a mask.
:	note--above test must be changed if any four bit masks are used
	NR	R1,R5		:mask off what we want--it's right justified
	LB	R8,GC180+1,R6	:R8 is shift count for R5
	SRHL	R5,0,R8		:shift R5 into readiness for next pass
	OH	R1,GC180+2,R6	:R1 is new 01-pair--prefix it back in buffer
	JAL	R8,WCD,,	:prefix second byte first
	EXBR	R1,R1		:swap
	JAL	R8,WCD,,	:prefix the 01 into the buffer
	AIS	R6,4		:increment to next entry
	J	GC1OBG		:and repeat

GC180	HC	101,01C0,101,01C2,101,01C6,101,01C4,8000 :for 010x pairs
GC181	HC	703,0130,101,01CE,8000			:for 011x pairs
GC108	BC	GC180-GC180,GC181-GC180
GC1MAX	EQ	2		:number of table entries
	ei	:0		:###jhl

GCHR1Y	HS	0		:			###LSH
	CRASH.(.GTCR1)		:BAD NEGATIVE VALUE IN PFXSIG TABLE

GETCH2	HS	0		:T-I GOBBLER (ILLEGAL)
	CRASH.(.GTCR2)		:02 ILLEGAL, CRASH	###LSH

GETCH3	HS	0		:TRANSLATE 03-PAIR
	JAL	R8,GCI,,	:GET SECOND CHARACTER

	IF	AIODBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,GTCDB2,,
	L	R4,REGST,,
	EI	:AIODBG		

	CLHI	R1,1		:01? (Hard Zapper)
	JE	GET301		:GO DO ZAPPER

	CLHI	R1,2		:02? (Soft Zapper)	###LSH
	JE	GET301		:GO DO ZAPPER

	CLHI	R1,3		:03? (Non-Gobbling Zapper)###wjl ###LSH
	JE	GET301		:Go do Zapper

	CLHI	R1,8		:08?
	JE	GET308		:GO DO GOBBLER

GTCER3	HS	0		:			###LSH
	CRASH.(.GTCR3)		:INVALID 03 PAIR, CRASH

GET301	HS	0
	LIS	R5,0C		:ZAPPER SIGNAL
	J	GCHEXT		:STRAIGHT RETURN
	
GET308	HS	0
	LIS	R5,0D		:GOBBLER SIGNAL
	J	GCHEXT		:STRAIGHT RETURN

GETCH4	HS	0
	LIS	R5,9		:LEAVE DEM SIGNAL
	J	GCHEXT		:STRAIGHT RETURN

GETCH5	HS	0
	LIS	R5,0F		:GREEN BALL SIGNAL
	J	GCHEXT		:STRAIGHT RETURN

GETCH6	HS	0
	LIS	R5,0E		:RED BALL SIGNAL
	J	GCHEXT		:STRAIGHT RETURN

GETCH7	HS	0
	LIS	R5,8		:ENTER DEM SIGNAL

GCHEXT	HS	0

	IF	AIODBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,GTCDB4,,
	GL	GTCDB4
	L	R4,REGST,,
	EI	:AIODBG		

GCHEXT	JR	R7		:STRAIGHT RETURN  ###LSH


				::###LSH
GCHRCR	HS	0		:GOT INVLAID PREFIX CODE, DISREGARD IT.
	LH	R0,BF,R2,	:OUTGOING CHANNEL NUMBER
	JAL	R8,CRYPTO,,
	HC	CRYE78		:UNRECOGNIZED SIGNAL RECEIVED
	J	ASYPOL
	

	IF	NMPVC	:MPVC ONLY

::*	IGCSCN:	INITIALIZE BUFFER SCAN (SET UP SBB)
::	Called by: 	MPSCAN to back up the BB ptr  by 1
::	returns:	skip is good, normal is buffer empty
::	Reg Usage: 
::	Calls:		niente
::	LINKS ON: R8(RBF)
::	EXPECTS: R2(RBP)
::	RETURNS: R1(RBC = 0 OR BB-1)
::		NORMAL RETURN IF BUFFER EMPTY, ELSE SKIP-4
::

IGCSCN	HS	0
	L	RBC,BB,RBP,	:GET CURRENT BB POINTER
	JER	RBF		:STRAIGHT RETURN, BUFFER EMPTY
	SIS	RBC,1		:BACK IT UP BY 1
	ST	RBC,SBB,RBP,	:SAVE THIS POINTER-1
	J	4,RBF		:SKIP RETURN, DATA IN BUFFER

::*	GCSCN:	SCAN BUFFER.
::	Called by: 
::	returns:	
::	Reg Usage: 
::	Calls:	
::	LINKS ON: R8(RBF)
::	EXPECTS: R2(RBP)
::	RETURNS: R1(RBC = DATA CHAR IF ANY)
::		NORMAL RETURN IF NO DATA, ELSE SKIP-4 WITH CHAR IN R1
::
GCSCN	HS	0
	L	RBC,SBB,RBP,	:GET POINTER TO LAST CHARACTER SCANNED
	C	RBC,BE,RBP,	:END OF BUFFER?
	JER	RBF		:NORMAL RETURN, BUFFER EMPTY

	AIS	RBC,1		:BUMP SCAN POINTER
	THI	RBC,CBSZ-1	:END OF BUFFERLET?
	JNFS	GCSCN1		:NO, CONTINUE

	LHL	RBC,0,RBC	:GET LINK POINTER TO NEXT BUFFERLET
	SLLS	RBC,CBSZL	:FIND NEXT BUFFERLET
	AI	RBC,CHRBUF	:ABSOLUTE ADDRESS
GCSCN1	HS	0
	ST	RBC,SBB,RBP,	:UPDATE LAST CHARACTER SCANNED POINTER
	LB	RBC,0,RBC	:GET THE CHARACTER
	J	4,RBF		:SKIP RETURN WITH DATA IN R1

:	This routine is called from the quarter second
:	logic, immediately after servicing M.MUX.  It compares the
:	saved array LOGRST (state of LOGING array before calling
:	M.MUX) with the current state of LOGING.  If a bit has gone
:	down, then we take this opportunity to return the no longer
:	needed .LGBUF to the free buffer pool, since it means that
:	M.MUX has removed the MPVC subport user name from the buffer
:	and sent it along the mux channel.  The aesthetics of this
:	technique are not beyond reproach, but the alternative
:	is to lose buffers.
:	returns to 	CSDISM
:	clobbers	R0, R1, R2, R3, R8, R9, R11
:	calls		RFCBUF (maybe)

MPVCLN	HS	0

	IF	MPCCHK				:###LSH
	L	R0,FASTC,,
	ST	R0,MPLNB
	LIS	R0,0
	STH	R0,MPLNF
	EI	:MPCCHK

	LHI	R11,(NGRP-1)*2	:hw index into arrays
MPCLN2	LHL	R0,LOGING,R11,	:get hw of current array
	XH	R0,LOGRST,R11,	:reduce to changed bits
	JFFOH	R0,MPCLN4	:act on each bit that has gone down
	SIS	R11,2		:if none changed, or all serviced
	JGEBS	MPCLN2		:go on to the next halfword
	J	MPCLEX		:when array inspected, return.	###LSH

MPCLN4	HS	0

	IF	MPCCHK				:###LSH
	TS	MPLNF
	EI	:MPCCHK

	RBT	R1,LOGRST,R11,	:turn off noticed bits
:	Note--assumes only possible change is down.  Possible danger.
	LR	R0,R11		:work on R11
	SLLS	R0,3		:eight bits to the byte
	AR	R1,R0		:relative port number is in R1
	GETPTP(R9,R1,R1)	:get port table pointer into R9
	L	R2,.LGBUF,R9	:get the buffer
	JAL	R8,RFCBUF,,	:and return it to the free pool
:	clobbers R0, R1, R3.
	LCS	R1,1		:neg out the port table entry
	ST	R1,.LGBUF,R9	:it is now truly gone
	J	MPCLN2		:then go look for more such ports

MPCLEX	HS	0		:EXIT AND RETURN	###LSH

	IF	MPCCHK					:###LSH
	L	R0,FASTC,,
	S	R0,MPLNB
	LH	R1,MPLNF
	JEFS	MPCK10
	ST	R0,MPLNYS
	J	MPCK11
MPCK10	ST	R0,MPLNNO
MPCK11	HS	0
	EI	:MPCCHK

	J	CSDISM,,	:when array inspected, return to G250MS


:	save LOGING array for comparison in MPVCLN
:	called from G250MS.  Links on R10.  Clobbers R0 and R1.
MPVCST	HS	0

	IF	MPCCHK
	L	R0,FASTC,,
	ST	R0,MPSTB
	EI	:MPCCHK

	LHI	R1,(NGRP-1)*2	:move LOGING hw at a time to LOGRST
MPVST4	LHL	R0,LOGING,R1,	:this is so we can find gone down bits
	STH	R0,LOGRST,R1,	:resulting from M.MUX sending subport
	SIS	R1,2		:usernames over the mux channel
	JGEBS	MPVST4

	IF	MPCCHK				:###LSH
	L	R0,FASTC,,
	S	R0,MPSTB
	ST	R0,MPSTYS
	EI	:MPCCHK

	JR	R10		:return to quarter second logic 



:	MPVC ACCOUNTING

M.ACCT	HS	0
	LHI	PN,.MPORT	:START WITH FIRST MPVC PORT
M.ACT1	TBT	PN,ASYACP,,	:IF ACTIVE
	JEFS	M.ACT3		:GO DO IT(was JNFS)###jhl
M.ACT2	AIS	PN,1		:NEXT ONE
	CLHI	PN,.MPORT+NMPVC	:are we up to last MPVC port yet?
	JLBS	M.ACT1		:loop until all around
	J	CSDISM,,	:the dismiss

M.ACT3	HS	0
	LR	PN2,PN		:set up port number times 2
	AR	PN2,PN2
	L	RLINK,MPVCFO-(4*.MPORT),PN2,PN2	:SET FORMAT TBLE POINTER
	LHL	R9,MP.VAR,RLINK	:SET VARIABLE AREA POINTER
	JAL	R5,M.SACT	:SEND ACCOUNTING
	J	M.ACT2		:CONTINUE

M.SACT	HS	0	:SEND MPVC ACCOUNTING
	LHL	R0,ASYTAB,PN2,	:CONNECTED?
	JER	R5		:NO, ABORT
	STM	R0,M.ACSV,,	:SAVE ALL REGISTERS
: SEND THE SESSION INVOICE NUMBER FIRST
: ###GT
	LHI	R5,89		:ACCOUNTING MSG
	LHI	R1,-.MPORT,PN	:'RELATIVE' PSEUDO PORT NUMBER
	AR 	R1,R1
	L	R0,MPINVC,R1,R1	:GET A FULL WORD OF INVOICE NUMBER
	OI	R0,70000000	:MAKE UP ACCOUNTING MESSAGE
	ST	R0,SUPMBF,,
	LIS	R1,4		:FLAG FOR TYMSAT SOURCE
	LIS	R6,2		:MSG HW LENGTH FOR SUP14
	JAL	R10,SUP14,,	:SEND IT OFF
	LHI	R5,89		:ACCOUNTING MSG CODE FOR SUP14
	LHL	R0,MPV.LP,R9	:LOGON PORTS
	OI	R0,0E0100000	:COMBINE WITH ACCOUNTING MSG TYPE
	ST	R0,SUPMBF,,
	LIS	R1,4		:FLAG INDICATES TYMSAT SOURCE TO SUP14
	LIS	R6,2		:MSG HW LENGTH FOR SUP14
	JAL	R10,SUP14,,	:SEND IT
	L	R9,M.ACSV+4*9,,	:SUP14 CLOBBERS R9 AMONG OTHERS
	L	R0,MPV.PS,R9	:PORT SECONDS
	AHI	R0,$A 30	:we should round up###jhl
	LHI	R1,$A 60
	DHR	R0,R1		:CONVERT TO PORT MINUTES
	LI	R0,0E0110000,R1	:COMBINE WITH MESSAGE TYPE
	ST	R0,SUPMBF,,
	LHI	R5,89		:ACCOUNTING MESG TYPE
	LIS	R1,4		:FLAG INDICATES TYMSAT SOURCE TO SUP14###jhl
	LIS	R6,2		:MSG HW LENGTH
	JAL	R10,SUP14,,	:SEND IT
	LM	R0,M.ACSV,,	:RESTORE ALL REGISTERS
:	Accounting data should be cumulative###jhl
	if	0	:###jhl
	LIS	R0,0
	STH	R0,MPV.LP,R9	:CLEAR ACCOUNTING DATA
	ST	R0,MPV.PS,R9	:
	ei	:0	:###jhl
	JR	R5

	EI	:NMPVC


	IF	NUMPRN		:ONLY IF PRINTER

::*	PMULT:	Print-MULTiple-characters
::	=================================
::	Called by: CONSAT, to put several copies of a character into a
::			printer buffer.
::	returns:	[R7] if compression count was 0, else returns [R7]+4.
::	Reg Usage: Expects R6(compression count), R1(character to print),
::			PN(R14).  Clobbers several???.
::	Calls:	PCHAR(R8).
::		Puts [R6] copies of the character in R1 into the specified
::		port's printer buffer--i.e., calls PCHAR [R6] times.
::

PMULT	HS	0		:PRINT MULTIPLE CHARACTERS
	CLHI	R6,1		:R6=NO. OF CHARACTERS TO PRINT
	JLR	RCH		:NONE, RETURN
	JE	PMULTX		:ONLY ONE, SKIP
	CLHI	RBC,0A0		:BLANKS?
	JE	PMULT1		:YES, GO ON TO BLANKS

:	NON-BLANK CHARACTER COMPRESSION
	JAL	RBF,PCHAR	:PRINT THE CHAR.
	NOP	0		:DON'T CARE WHAT KIND OF RETURN
	SIS	R6,1		:BUMP COUNT DOWN
	LHI	R1,40,R6	:COMPRESSION COUNT
	SHI	R6,3F		:MORE THAN THIS?
	JLE	PMULT3		:NO, ONE PASS ONLY
	LHI	R1,7F		:MUST DO IT IN 2 PASSES
	LHI	R6,40,R6	:COUNT FOR 2ND PASS
	J	PMULT2		:GO DO IT

PMULT1	HS	0		:BLANK COMPRESSION
	LR	R1,R6		:COUNT TO R1
	SHI	R6,3F		:MORE THAN 1 PASS?
	JLEFS	PMULT3		:NO, JUST ONE
	AIS	R6,1		:MORE THAN 40 BLANKS
	LHI	R1,3F		:THIS MANY ON FIRST PASS
	
PMULT2	HS	0		:COMPRESSION FIRST PASS
	JAL	RBF,PCHAR	:SEND CHAR IN R1
	NOP	0		:DON'T CARE
	LR	R1,R6		:THIS MUCH MORE

PMULT3	HS	0		:REST OF COMPRESSION
	JAL	RBF,PCHAR	:SEND IT
	NOP	0		:DON'T CARE
	J	4,RCH		:???

PMULTX	HS	0
	LR	RBF,RCH		:TRANSFER RETURN AND FALL THRU
::*	PCHAR:	Print-a-CHARacter
::	=========================
::	Called by: CONSAT or PMULT, to put a character into a printer
::			buffer.
::	returns:	[R8] if printer buffer still available, [R8]+4 if
::			buffer ready to be flushed.
::	Reg Usage: R1(character to be put), PN(R14).
::	Calls:	PFLSH0.
::		Puts a character into the specified printer buffer.
::		If the character is an EOL (00), or if the printer buffer
::		gets filled up, falls through to PFLSH0, where the buffer
::		is marked for flushing and we do a skip+4 return.  Else
::		we do a straight return to indicate the buffer is still
::		available.  The actual flushing of the printer buffer is
::		done in the polling loop (see FLUSHP).  The printer buffer
::		is PRBFSZ bytes long, of which the first HW is used to hold
::		the count of bytes currently in the buffer.
::
::		A note about data in the printer buffer:  The printer
::		output SVC(1A) expects all data bytes to have their 80 bit
::		set.  A byte value of 00 is an EOL and causes the contents
::		of the buffer to be flushed to the printer.  A value in the
::		range 01-3F is interpreted as a command to print that many
::		spaces.  A value of 41-7F is interpreted as a command to
::		print the previous character (that many - 40) times.  A value
::		of 40 is interpreted as a form-feed command.
::	

	SEG	1
PCHAR	HS	0		:???
	LHL	R3,0,R9		:GET CURSOR
	STB	RBC,2,R9,R3	:STORE CHARACTER IN OUTPUT BUFFER
	AIS	R3,1		:BUMP CURSOR
	STH	R3,0,R9		:SAVE CURSOR
	LR	RBC,RBC		:0 MEANS EOL
	JEFS	PFLSH0		:FLUSH BUFFER TO PRINTER
:	CLHI	R3,PRBFSZ-3	:BUFFER FULL?
				:TO FIX PRINTER 0641 CRASH ###LSH
	CLHI	R3,PRBFSZ-4	:BUFFER FULL?		   ###LSH
				:LEAVE ONE MORE SPACE	   ###LSH
	JLER	RBF		:NOT YET
	JFS	PFLSH0
::*	PFLUSH:	force-Printer-Flush
::	=====================
::	Called by: CONSAT, to force flushing of a printer buffer.
::	returns:	[R8] if nothing to flush, [R8]+4 if flushed.
::	Reg Usage: Expects PN(R14), R9(pointer to buffer)
::	Calls:	Nada.
::		If the printer buffer is empty, we do a straight return.
::		Else, we mark the printer buffer for forced flush in
::		FLUSHP by resetting the port's bit in F.FLSH.  This causes
::		the printer output SVC(1A) to try to flush the buffer and
::		simply give up if it fails.  R9 is set up by SETPRN, which
::		must be called before PFLUSH is called.
::
::		PCHAR falls thru to PFLSH0 below, where the printer is
::		marked for regular flush (P.FLSH).  In this case, the
::		printer output SVC will try to flush the buffer, and to
::		keep trying until it succeeds or is force-flushed.
::

PFLUSH	HS	0		:ENTER HERE IF EXPLICITLY CALLED
	LHL	R3,0,R9		:BUFFER EMPTY?
	JER	RBF		:YES, JUST PROCEED
	RBT	PN,F.FLSH,,	:MARK FOR FORCED FLUSH
PFLSH0	HS	0
	RBT	PN,P.FLSH,,	:MARK FOR REGULAR FLUSH

:	CHANGES BEGIN HERE			###LSH
:	TO FIX PRINTER 0641 CRASH PROBLEM

	SVC	0F,SV.PRT	:OUTPUT DATA FROM PRINTER BUFFER TO
				:PRINTER PORT.
	GL	PBFPN
	LHL	R9,PBFPN,PN2,	:RESTORE BUFFER POINTER
	LR	R2,R2		:CHECK STATUS REGISTER SEE IF IT'S DONE
	JN	4,RBF		:NO, PRINTER IS NOT READY, LEFT P.FLSH
				:0 (ON),  FLUSHP ROUTINE WILL TRY AGAIN.
	SBT	PN,P.FLSH,,	:YES, IT IS DONE, TURN P.FLSH OFF.
	J	4,RBF		:SKIP RETURN TO JUMP TO XDEF IN ASYPOL
				:TO DEFER THIS PORT AND HANDLE NEXT
				:PORT.
:	LIS	R0,0					
:	LIS	R2,0F
:	XMIT	0,0
:	J	4,RBF
:
:	CHANGES END HERE			###LSH


::*	PINIT:	Printer-initialize
::	==========================
::	Called by: CONSAT, when a port goes into printer mode.
::	returns:	Via [R7].
::	Reg Usage: Expects PN(R14).
::	Calls:	Nada.
::		Initializes a specific printer port--i.e., assigns a
::		printer buffer to it.
::
PINIT	HS	0		:???
	LHI	R4,PRBFSZ
	MHR	R4,PN
	AI	R4,PRBFFR	:###jhl
:	AHI	R4,PRBFFR	:problem if PRBFFR > 7FFF###jhl
	STH	R4,PBFPN,PN2,
	LIS	R3,0
	STH	R3,0,R4
	JR	RCH

::*	SETPRN:	SET-up-for-PRiNter-output
::	=================================
::	Called by: CONSAT, to see if a printer buffer is available.
::	returns:	[R8] if buffer is available, [R8]+4 if not.
::	Reg Usage: Expects PN2(R13).  Returns R9(pointer to printer
::		buffer, if available).
::	Calls:	Nada.
::		Checks to see if the specified printer buffer is available
::		for PCHAR--i.e., sees whether it is marked for flush. If
::		so, returns the buffer's address in R9 with a straight return.
::		Else does a skip return.
::
SETPRN	HS	0
	TBT	PN,P.FLSH,,	:Remember, 0-bit means flush scheduled
	JE	4,RBF
	LHL	R9,PBFPN,PN2,	:THIS PRINTER'S BUFFER AREA
	JR	RBF		:NOT AVAIL., SKIP RETURN

INITP	HS	0

	EI	:NUMPRN

::*	PUTCHR:	PUT-CHaRacter-to-buffer
::	===============================
::	Called by: CONSAT, to put a character into a buffer.
::	returns:	Via R7.
::	Reg Usage: Expects R1(character), R2(buffer index). Clobbers R5, R8.
::	Calls:	WCI(R8).
::		Puts the specified character into the specified buffer,
::		escaping if necessary.
::
PUTCHR	HS	0

	IF	AIODBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,PTCDB1,,
	GL	PTCDB1
	L	R4,REGST,,
	EI	:AIODBG		

	LR	R2,R2
	JLR	R7
			:###LSH  CHANGES BEGIN HERE
	CHI	R2,4
	JGFS	PTCH0		:GO TO CHECK BF
				:ELSE
PCHBF1	CRASH.(.PCBF1)		:PUTCHR	BUFFER 0, CRASH

PTCH0	HS	0
	LHL	R8,BF,R2,	:SEE IF BF IS RIGHT
	JGEFS	PTCH1		:BF IS RIGHT, GO AHEAD
				:ELSE
PCHBF2	CRASH.(.PCBF2)		:PUTCHR BF OF BUFFER DEAD, CRASH

PTCH1	HS	0		:EVERYTHING IS OK, GO AHEAD
			:###LSH CHANGES END HERE

	CLHI	R1,7		:NEED TO ESCAPE?
	JGFS	PUTCH1		:NO, JUST WRITE IT.
	LBR	R5,R1		:SAVE CHARACTER
	LIS	R1,0		:ESCAPE
	JAL	R8,WCI,,	:SEND IT
	LBR	R1,R5		:RESTORE CHARACTER
PUTCH1	JAL	R8,WCI,,	:SEND IT
	JR	R7		:RETURN

::*	PUTSIG:	PUT-SIGnal-to-buffer
::	============================
::	Called by: CONSAT, to put a signal into a buffer.
::	returns:	Via R7.
::	Reg Usage: Expects R2(buffer index), R4(signal number), R1(associated
::		data, if any).  Clobbers R5, R1, R8.
::	Calls:	WCI(R8).
::		Translates the CONSAT signal in R4 into the corresponding
::		network control code, ORs in the data in R1 if appropriate,
::		and puts the resulting character or pair into the specified
::		buffer.  We crash on an invalid signal number.  SIGDAT is a
::		bit array which tells us whether R1 is relevant.
::

PUTSIG	HS	0

	IF	AIODBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	ST	R8,RGST,,
	LR	R8,R4		:R8=R4=CONSAT SIGNAL
	JAL	R4,PTSDB1,,
	GL	PTSDB1
	L	R4,REGST,,
	L	R8,RGST,,
	EI	:AIODBG		

	LR	R2,R2
	JLR	R7
			:###LSH  CHANGES BEGIN HERE
	CHI	R2,4
	JGFS	PTSG0		:GO TO CHECK BF

PSGBF1	CRASH.(.PSBF1)		:PUTSIG BUFFER 0, CRASH

PTSG0	HS	0
	LHL	R8,BF,R2,	:SEE IF BF IS RIGHT
	JGEFS	PTSG1		:BF IS RIGHT, GO AHEAD
				:ELSE
PSGBF2	CRASH.(.PSBF2)		:PUTSIG BF OF BUFFER DEAD, CRASH

PTSG1	HS	0		:EVERYTHING IS OK, GO AHEAD
			:###LSH  CHANGES END HERE

	LR	R5,R1		:MOVE POSSIBLE ASSOCIATED VALUE TO R5
	LO	SIGNAL
	CLHI	R4,MAXSIG	:MAKE SURE SIGNAL NUMBER IS IN RANGE
	FO	SIGNAL
	JGE	PSGER		:NO, DISREGARD IT.	###LSH

	LHL	R1,CONSIG,R4,R4	:GET MAPPED NETWORK CHARACTER PAIR
	JE	PSGER		:INVALID SIGNAL, DISREGARD IT.  ###LSH

	TBT	R4,SIGDAT	:IF SIGDAT BIT IS 1 FOR SIGNAL NUMBER, THEN
				:R1 CONTAINS ADDITIONAL DATA
	JEFS	PSIG00		:NO ADDITIONAL DATA
	SLLS	R5,8		:CONROL BYTES ARE REVERSED, MOVE VALUE UP.
	OR	R1,R5		:MERGE CONTROL PAIR WITH VALUE
PSIG00	HS	0

	IF	AIODBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,PTSDB2,,
	GL	PTSDB2
	L	R4,REGST,,
	EI	:AIODBG		

	JAL	R8,WCI,,	:WRITE OUT THE FIRST BYTE
	SRLS	R1,8		:SHIFT NEXT BYTE DOWN
	JER	R7		:IF IT'S 0, THIS WAS JUST ONE CHARACTER
	JAL	R8,WCI,,	:WRITE IT OUT
	JR	R7		:RETURN

PSGER	HS	0		:###LSH
	LH	R0,BF,R2,	:OUTGOING CHANNEL NUMBER
	JAL	R8,CRYPTO,,
	HC	CRYE78		:UNRECOGNIZED SIGNAL RECEIVED
	J	ASYPOL



 IF NSPORT	:SIO PORTS ONLY

::*	Q.SANS:	INITIALIZE NEW SIO ASYNC PORT
::	Called by: 
::	returns:	
::	Reg Usage: 
::	Calls:	
::	LINKS ON: R10(RLINK)
::	EXPECTS: R14(PN),R6(OFFSET TO COMMAND AREA, RELATIVE TO SIO PORT 0)
::	CLOBBERS: R4,R5
::
Q.SANS	HS	0		:???

	JR	RLINK		:RETURN

 EI :NSPORT



::*	SNDLOG:	SeND-LOGin-string
::	=========================
::	Called by: CONSAT login process to flush login buffers
::	returns:	To ALIRET(SWITCH).
::	Reg Usage: Expects nothing. Returns nothing.
::	Calls:	GETCHR(R7), LOGCHR(R11), MSG(R9), EMPTY(R7).
::		The CONSAT's login process (LGGO) runs off the SWITCH exec 
::		loop.  After it is through transfering data from terminal
::		input buffers to login buffers (.LGBUF), it comes here.
::		We process buffers which have login data (GOLOG) and are
::		marked to be flushed (FL.LOG).  We ignore data from ports
::		which we think are not in login mode, and we will hang a
::		port which has sent us a too-long login string.
::
::		.LGBUF is used by the CONSAT to accumulate login data
::		from the from-terminal buffer.  When it encounters a
::		terminator (CR or semi-:) in the string, or when the
::		number of characters accumulated reaches the limit (55d),
::		the port is marked for login flush.  We transfer the data
::		to .ALBUF so it can be processed by our LOGGER.  We then
::		perform the same checks again--which redundancy should be
::		eliminated some time if possible.
::	

SNDLOG	HS	0
				:###LSH
				:EVERY TIME ONLY SCAN 16 PORTS AND THEN
				:YIELD TO EXEC.
	LHL	R0,GOLOG,RPOL	:GOLOG FLAGS LOGIN BUFFERS WITH DATA
	NH	R0,FL.LOG,RPOL	:FL.LOG FLAGS BUFFERS READY TO BE FLUSHED
	JFFOH	R0,SNDLG2	:FIND A PORT NEED TO BE PROCESSED.
	J	ALIRET,,	:YIELD, AFTER HAVE SCANED 16 PORTS.
				:###LSH

SNDLG2	HS	0
	LR	PN,RPOL		:COMPUTE PORT #
	SLLS	PN,3		:GROUP INDEX
	AR	PN,R1		:INTRA-GROUP OFFSET
	LR	PN2,PN		:COMPUTE PN2
	AR	PN2,PN2		:JUST SO
	GETPTP(RPI,PN,PN)	:COMPUTE RPI
	RBT	PN,FL.LOG	:CANCEL FLUSH FLAG

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,SNDDB1,,
	GL	SNDDB1
	L	R2,.LGBUF,RPI,	:.LGBUF
	JAL	R4,SNDDB2,,
	GL	SNDDB2
	L	R4,REGST,,
	EI	:LNFDBG		



SNDLG3	HS	0
	TBT	PN,GOLOG	:READY TO GO?
	JNFS	SNDL3A
	J	SNDLOG		:NEXT PORT		:###LSH

SNDL3A	L	R2,.LGBUF,RPI	:GET LOGIN BUFFER
	JAL	RCH,GETCHR	:GET NEXT CHARACTER
				:				###LSH
SNDSIG	J	SNDER0		:STRAIGHT RETURN, GET A SIGNAL, CRASH
				:SKIP +4 RETURN, GET A CHARACTER, OK
	L	R2,.ALBUF,RPI	:GET .ALBUF
	JLE	SNDL3D		:IF .ALBUF IS NOT THERE, 	###LSH
				:TOSS DATA, CONTINUE	

	ST	R11,RPOLSV,,
	JAL	R11,LOGCHR,,	:GO PUT THIS CHARACTER

	J	SNDL3B		: immed return--port not in login mode
	J	SNDL3C		: +4 return--login buffer full

SNDL3B	L	R11,RPOLSV,,	: +8 return--that's good
SNDL3D	L	R2,.LGBUF,RPI	:BACK TO .LGBUF
	J	SNDLG3		:CONTINUE

SNDL3C	HS	0		:LOGIN BUFFER OVERFLOW

	IF	LNFDBG		:####LSH	DEBUGGER
	ST	R4,REGST,,
	JAL	R4,SNDDB3,,
	GL	SNDDB3
	L	R4,REGST,,
	EI	:LNFDBG		

	L	R2,.TTBUF,RPI
	LA	R6,TUMANY
	JAL	R9,MSG,,
	LA	R6,TUMAN1
	JAL	R9,MSG,,
	L	R2,.ALBUF,RPI
	JAL	R7,EMPTY
	L	R2,.LGBUF,RPI
	JAL	R7,EMPTY
	RBT	PN,LOGER
	L	R11,RPOLSV,,
	J	SNDLG3

SNDER0	CRASH.(.SNDR0)		:SNDLOG GET A SIGNAL FROM .LGBUF


TUMANY	AC	/"01"F1"0D"0Atoo many login characters"0D"0A"00/
TUMAN1	AC	/please see your representative"0D"0Aif you are having trouble logging in"01"F0"00/





:	The following routines added to resolve insertions in the
:	CONSAT 3.02 to fix the DOW-JONES break problem.  I've
:	commented out the routines themselves, since these are the
:	ISIS routines 
	
:	Clear Async rings
:	----- ----- -----
:	R6	link

A.CLR	HS	0
:	L	R2,AR.FT,RP2,RP2	:get input ring
:	RBT	RP,DQDAT		:no data present
:	LCS	R1,1			:clear async input ring
:	STH	R1,AR.BCT,R2		:clear count
:	LIS	R1,AR.IC		:init cursors
:	STB	R1,AR.FC,R2
:	STB	R1,AR.EC,R2
	JR	R6

:	Routine used by ISIS consat to clear output ring at
:	initialization, etc.  SOLO consat takes this opportunity in the
:	TELEX case (from T.INIT) to be sure we don't stick in receive
:	break state upon reinit, and hence fail to notice start of
:	break from the TELEX terminal. ###jhl (may be over safe.)

A.CLRO	HS	0
	IF	TELEX
	TBT	PN,TLXP,,	:is this a TELEX port?
	JEFS	A.CLR01		:it's not a concern if not
	LHI	R5,AGETCR-SEG1	:reset receive substate to get data
	STH	R5,.VBSTA,RPI	:insure we see start of break
A.CLR01	EI	:TELEX
	JR	R6
	
:	Stop async output -- received ^S
:	RP	port number
:	R0	link register

ASTOP	HS	0
:	RBT	RP,QDDAT		:tell ISIS no data to output
:	JER	R0			:return, if already no data
:	SBT	RP,OUTMSK		:keep record, if data to output
	JR	R0			:and return

:	Resume async output -- received ^Q
:	RP	port number
:	R0	link register

ARSUM	HS	0
:	RBT	RP,OUTMSK		:was there data to output
:	JER	R0			:if not return
:	SBT	RP,QDDAT		:tell ISIS data to output
	JR	R0			:and return
	
	IF	NMPVC

:	M.ASNP - routine picks up physical port number of port that
:	initiated building of the MPVC port and reports that as the
:	physical port number for the MPVC port.
:	R0	link register
:	R1	physical subport number
:	RP	MPVC logical port number

M.ASNP	HS	0
	LHI	R6,-.MPORT,RP		:get 'RELATIVE' pseudo port number
	STH	R1,ASNPUT,R6,R6		:store physical port number
	JR	R0			:and return

	EI	:NMPVC

	SUBTTL	ASYNC (UTILITY ROUTINES)

::*	RSTACP:	Marks a port active.
::	Called by: ESTSRC
::	returns:	
::	Reg Usage: 
::	Calls:	

RSTACP	HS	0
	RBT	R1,ACP,,	:declare channel active (zero)
	LCS	R0,1
	SR	R0,R1
	RBT	R0,ACP,,	:set the negative part of the array, too
	JR	R8

::*	SNDRTS:	SeND-RTS-to-async-ports
::	===============================
::	Called by: 
::	returns:	
::	Reg Usage: 
::	Calls:	

SNDRTS	HS	0
	LHI	R1,(NAGRP-1)*2	:point to last group
SNDRT1	LHL	R2,RTS,R1,	:get 16 bits of RTS array
	SVC	0F,SV.RTS	:output 16 bits of RTS
	SIS	R1,2		:step to previous halfword
	JGEBS	SNDRT1		:loop until array used up
	JR	R8

::*	SETPN2:	SETS UP R13(PN2), R12(RPI), AND R2(RBP = .TTBUF) BASED
::		ON PORT# IN PN.
::	Called by: 
::	returns:	
::	Reg Usage: 
::	Calls:	
::	LINKS ON - R9
::	EXPECTS - R14(PN)
::	RETURNS - R13(PN2),R12(RPI),R2(RBP=.TTBUF)
::
SETPN2	HS	0
	LR	PN2,PN		:SET UP PN2
	AR	PN2,PN2		:PORT#*2
	LHL	RPI,.PTP.,PN2	:PORT TABLE POINTER
	AI	RPI,PTBASE
	LHL	RBP,.FTBUF+2,RPI:TO-TERMINAL BUFFER
	
	JR	R9		:RETURN

::*	WCB:
::	====
::	LINKS ON - R5

WCB	HS	0
	JAL	R8,WCD,,
	JR	R5

:	SUBTTL	ASYNC (PORT TABLE)::

:	SEG.(4)		:SEG4 DATA

:	Now define the space for the port descriptors
:.PTABL	DFST.(HS,(NPORT*.PTLEN/2),CSBASE)
::	***END ASYNC

	SUBTTL	CONSAT -- SIO PROCESSES

	IF	0	:until async SIO implemented
	IF	NSPORT

:		 **** *****  ***
:		*       *   *   *
:		 ***    *   *   *
:		    *   *   *   *
:		****  *****  ***

:	Initialize new port
:	RLINK -	Link register
:	RP -	port number
:	R6 -	Offset for command area (relative to SIO port 0)
:	R4, R5 not preserved
Q.SANS	SBT	RP,DQDAT		:force service
	LB	R4,LUNSIO,RP		:Set logical unit
	LA	R5,ICMSIO,R6		:point to command area
	SVC	IO,0A0+R4		:and start it
	JAL	R15,SABORT
	JR	RLINK			:Then exit

:		SIO Initialization
:		--- --------------
:	Initialize the SIO programs
:	Find all SIO channels that are available
SINIT	LM	R12,S.HNG		:Get the disconnect routine
	STM	R12,HNGSIO
	LM	R12,S.ENA		:Get the enable routine
	STM	R12,ENASIO
	LM	R12,S.ASCI		:Get the ASCII initial routine
	STM	R12,SAVSIO
	IF	BAUDY
	LM	R12,S.BADO		:same for BAUDOT
	STM	R12,SAVSIB
	EI	:BAUDY
	LI	R14,00051113		:make the XONENA program
	STM	R14,XONSIO
	LI	R14,0005FFFF		:make XOFF program
	STM	R14,XOFSIO
SINIT1	LHI	RP,.SPORT		:make a pointer into the SIO ports
	LCS	R1,1			:R1 is the LUN to be queried
	LIS	R3,3			:Query 3-bytes of info
SINIT2	AIS	R1,1			:For next unit
	LA	R2,LUNSIO,RP		:Address of Query
	SVC	IO,8000+R1,,		:Get the attributes for this unit
	JAL	R15,SABORT
	LB	R5,0,R2			:get the type
	CLHI	R5,4			:is it a SIO channel?
	JN	SINIT3			:no
	STB	R1,0,R2			:Store the LUN number
	LB	R5,1,R2			:get device address
	LB	R6,2,R2			:get channel number
	SLLS	R5,4			:pack together
	OR	R5,R6			:...device|channel
	NHI	R5,0FF
	OHI	R5,400			: (0.4.d.c)
	STH	R5,ASNPUT,RP,RP		:save for accounting ports
	SBT	RP,GOTSIO		:Set channel available
	SBT	RP,HANGWT		:and start with soft-hang
	SBT	RP,RLA			:...and answered
	LR	R5,R1			:prepare for connect
	LA	R6,LOWSIO		:low limit
	LA	R7,HIHSIO		:High limit
	LHI	R4,-.SPORT,RP		:convert RP to SIO-port index
	SLLS	R4,5			:make 8-word index
	LA	R8,STASIO,R4		:and set status-address
	LA	R9,DQDAT*8,RP,		:make a bit pointer with bit
					:addressing, and add SIO offset
	SVC	IO,90+R5		:connect
	JAL	R15,SABORT

:	Now initialize the input program for this channel
	LIS	R6,0
	SVC	IO,0B0+R5		:reset channel
	JAL	R15,SABORT
	LA	R6,ENASIO		:set RS true
	SVC	IO,0B0+R5
	JAL	R15,SABORT
	AIS	RP,1			:for next channel
	CLHI	RP,.SPORT+NSPORT	:Done?
	JL	SINIT2			:Try next unit
	JR	R0			:done...exit

SINIT3	CLHI	R5,0FE			:is this all the LUN?
	JN	SINIT2			:no
	TS	CERR			:yes...CONFIGURATION ERROR
	JLR	R0			:already have one...exit
	AHI	RP,3000-.SPORT		:display 3|0|0|port
	STH	RP,FPANEL
	JR	R0			:done

SABORT	ABORT(R15,0F3)			:SIO SVC failure

	EI	:NSPORT

:	CONSAT VARIABLES WHICH ARE INITIALIZED TO ZERO ARE BOUNDED BY THE 
:	SYMBOLS 'BEGZRO' AND 'ENDZRO' -- THEY ARE:
:	COMMON: RLA, LOGER, LOGING, UNAME, LGECHO, NEWLOG, GOLOG,
:		TOLOG, TOPORT, P.DONE, MPVC.C, Q.MODE, HAFDUX, ECHO,
:		ECTLI, ECTLH, E.ESC, ECR.LF, ELF.CR, PARITY, TOSING,
:		TSNBRK, CRDE, ASYNC, ASCII, XONENA, XONOUT, YONENA,
:		RXON, NBO, DEM, TBOA, TBOB, GBO, TIDTO, TIDTO1, BRK,
:		BRKTO, BRKTO1, MARGE, LASTCH, IBRATE, OBRATE, PAR.A,
:		PAR.B, PAR.C, PAR.D, XMTF, ATTN, RTS, HANGWT, ULMSG,
:		MS0, 
:	IF PVC: PVCSTD, TATBIN, PVCBAS, PVCUN, PVCPW, PVCRET, 
:	IF NMPVC: TOMPVC, MPV.CI, MPV.T1, MPV.T2, MPV.T3, MPV.T4,
:		MPVVx, 
:	IF NAPORT: BUSY.H, BUSY.A, DTR, DSR, NEWDSR, CP, CPSAMP,
:		A.SPED, AHATMP, QRET
:	IF NUMPRN: KTKANA, PRTACT
:	IF .2HD: TRNCH,
:	
IZAS10	HS	0		:INITIALIZE VARIABLES TO -1
	LHI	R1,ENDONE-BEGONE-4	:RANGE OF STORAGE...
	LCS	R0,1		:...TO BE SET TO -1
IZAS11	ST	R0,BEGONE,R1	:A FW AT A TIME
	SIS	R1,4		:NEXT
	JGEBS	IZAS11		:UNTIL DONE

	EI	:0	:async SIO


	EI	:SOLOCS

	ENDMO.(ASYNC)
	EI	:1-KILLIT
	KILMSG(ASYNC)
:	******NOTHING PAST THIS POINT*****

	SUBTTL XRAY

:			*   *  ****     *   *   *
:			 * *   *   *   * *   * *
:			  *    ****   *****   *
:			 * *   *  *   *   *   *
:			*   *  *   *  *   *   *

::#####################################################################
::
::	MODULE:		XRAY
::
::	FUNCTION:	TYMNET-II NODE OPERATIONS MONITOR
::
::	REGISTER CONVENTIONS:
::		KX  = R11	:pointer to linK descriptor (Xray)
::		XD  = R15	:pointer to Xray user block Descriptor
::	ROUTINES:
::		XRAY command table
::		XRYSCH:  Scheduler
::		Utility routines for scheduling remote XRAY
::		Main command loop
::		Commands
::		Utility routines
::
::#####################################################################

	IF	1-KILLIT		:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.

	IF	SOLOCS
	LO	DATA
	EI	:SOLOCS

:	XRSZLV switch provides three major assembly size level for XRAY.
:	XRSZLV=1:  ND,NS,KD,KS,PQ,DC,CO			
:	XRSZLV=2:  1 AND GP,CD,CL,CM,SM,BZ,TL/TN/TM,AC,QC,TC/TD/TE/TA,
:		DB/DD/DE/DL/PM,WM,PQ,R,RS,SA,SY,IS,IR,HS
:	XRSZLV=3:  1,2 AND ALL OTHER COMMANDS (DEFAULT)

:	>>CRYPTOGRAM values now defined in DATA for structured reference<<
:	>>SRESER - Symbol Reserved area moved to end of SEGD (FIN)<<

	SEG	0D			:XRAY RUNS IN SEGD

	ORG	SEGD			:virtual segments defined in SHARE
::*********************************************************************
::
::	BIT ARRAYS:	CRYPRY:/CRYPDF:
::	FUNCTION:	CRYPTO MESSAGE PRIORITY BIT ARRAYS
::
::*********************************************************************

	IF 	PRIMSG
CRYPRY	HS	0	:EACH BIT SET FOR A PRIORITY MSG. ON (MSG# 0-7FH)
	HC	$2 0000001000000000,0000000100011000 (0-1FH)
	HC	$2 0000001100000000,1000000001000000 (20H-3FH)
	HC	$2 0000000000000000,0000100000000000 (40H-5FH)
	HC	$2 0000000000000000,0000000000000000 (60H-7FH)
	HC	0,0,0,0,0,0,0,0 (RESERVED TILL 0FFH)
CRYPRE	HS	0 :DEFAULT PRIORITY CRYPTO. MSGS:06,17,1B,1C,26,27,30,39,54
CRYPDF	HS	0 :DEFAULT BIT SET FOR A PRIORITY MSG. ON (MSG# 0-7FH)
	HC	$2 0000001000000000,0000000100011000 (0-1FH)
	HC	$2 0000001100000000,1000000001000000 (20H-3FH)
	HC	$2 0000000000000000,0000100000000000 (40H-5FH)
	HC	$2 0000000000000000,0000000000000000 (60H-7FH)
	HC	0,0,0,0,0,0,0,0 (RESERVED TILL 0FFH)
CRYPDE	HS	0
	EI	:PRIMSG
:	HC	$2 00010000,10000000,00001000,00000100,00000011
:	HC	$2 01100000,11010011,11000000,00000000,00000000
:	HC	$2 10011011,00000110,11011000,11001100,00000000
:	HC	0,0,0,0,0
	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	BIT ARRAY:	SHCRYP:
::	FUNCTION:	DEFAULT ENABLE/DISABLE OF CRYPTO MESSAGES
::
::*********************************************************************

:	REDEFINE SOME SYMBOLS FOR CONVENIENCE
Q	EQ	0
	RE	10
CRYE|Q|	EQ	CRYE0|Q|
Q	EQ	Q+1
	ER

:	DEFINE BIT ARRAY BASED ON BIT 4 OF CRYEXX (0=> DISPLAY, 1=> NO DISPLAY)
:	AND ALSO ON BASIS OF TYME-FILE OPTIONS
QINDEX  EQ      0
QVALUE  EQ      0
SHCRYP	HS	0		:BEGINNING OF CRYPTO-ENABLE BIT ARRAY
	RE	73		:DO FOR 128 POSSIBLE CRYPTO MESSAGES
QQ	EQ	0		:DEFAULT TO DISPLAY ON
	IF	\CE|QINDEX|	:IF THERE IS A TYMFILE OVER-RIDE
QQ	EQ	0		:ENABLE THE MESSAGE
	ELSE
	IF	\CD|QINDEX|	:IF THERE IS A TYMFILE SHUT
QQ	EQ	1		:DISABLE THE MESSAGE
	ELSE
	IF	CRYE|QINDEX|&800:IF NEITHER, GO WITH DEFAULT
QQ	EQ	1		:IF BIT 4 = 1, DON'T DISPLAY
	EI
	EI
	EI
QVALUE	EQ	QVALUE*2+QQ		:SET THE CORRESPONDING BIT IN THE ARRAY
QINDEX	EQ	QINDEX+1		:ADVANCE INDEX TO NEXT CRYPTO MESSAGE
	IF	QINDEX&0F
	ELSE
	HC	QVALUE			:ELSE ENTER ONE HW OF THE BIT ARRAY
QVALUE	EQ	0			:AND CLEAR THE TEMPORARY VALUE
	EI
	ER

::*********************************************************************
::
::	BIT ARRAY:	MOCRYP:
::	FUNCTION:	PERMITS CRYPTO MESSAGES TO BE DYNAMICALLY
::	ENABLED AND DISABLED WITH AN X-RAY COMMAND. THIS INFO IS STORED
::	IN BIT 5 OF CRYE-XX (1=>CAN BE MODIFIED, 0=>CANNOT BE MODIFIED)
::
::*********************************************************************

QINDEX	EQ	0
QVALUD	EQ	0
MOCRYP	HS	0
	RE	72
QQ	EQ	0			:DEFAULT TO CANNOT BE MODIFIED
	IF	CRYE|QINDEX|&400	:PICK OUT BIT 5
QQ	EQ	1
	EI
QVALUE	EQ	QVALUE*2+QQ
QINDEX	EQ	QINDEX+1
	IF	QINDEX&0F
	ELSE
	HC	QVALUE
QVALUE	EQ	0
	EI	:QINDEX&0F
	ER

	EI	:(XRSZLV-1)		:##AL

ADBOOT	EQ	5A			:vector address for boot

	IF	ISIS
XSG1WA	EQ	10007		:ISIS SVC MASK GIVES XRAY SEG1 WRITE ACCESS
XSG1WP	EQ	10005		:ISIS SVC MASK RESTORES SEG1 WRITE PROTECT
XSGDWA	EQ	0D0007		:ISIS SVC MASK GIVES XRAY SEGD WRITE ACCESS
XSGDWP	EQ	0D0005		:ISIS SVC MASK RESTORES SEGD WRITE PROTECT
	EI	:ISIS

	IF 	(1-ISIS)
TRPCMD	SVC	0F,SV.TRP	:store this command where you poise a trap
	EI	:(1-ISIS)

XINDDT	HS	1
XOUDDT	HC	100		:DATA AREAS FOR ISIS DDT-DRIVEN XRAY

::*********************************************************************
::
::	TABLE:		CHKDAT:
::	FUNCTION:	DETERMINE VALIDITY OF USER-SUPPLIED ADDRESS
::
::*********************************************************************

CHKDAT	WS	0
	IF	ISIS
SEGASZ	EQ	0
	ELSE	:NOT ISIS
SEGASZ	EQ	10000
	EI	:ISIS

	WC	S0SZ-1,S1SZ-1,S2SZ-1
	WC	S3SZ-1,S4SZ-1,S5SZ-1,S6SZ-1,S7SZ-1
	WC	S8SZ-1,S9SZ-1,SEGASZ-1,SBSZ-1
        if      super
        wc      (ss4siz+ss5siz)!0ff
        else
        wc      scsz-1
        ei      :super
	WC	SDSZ-1,SESZ-1
	GL	SBSZ,S6SZ,SCSZ,S7SZ,S3SZ,S8SZ,S4SZ,S9SZ,S5SZ
	GL	S0SZ,S1SZ,S2SZ,SDSZ,SESZ

	IF ISIS
	WC	SESZ
	ELSE	:NOT ISIS
	WC	0
	EI	:ISIS
	HC	0

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	CRYPTOGRAMS:
::
::*********************************************************************

	NOLIST

CRYM00	DEFASC(00: CRASH - TYPE= ,HH,ADDRESS= ,HH,,HH)
CRYM01	DEFASC(01: LINK UP   - KN= ,BD,NEIG= ,O5)
CRYM02	DEFASC(02: LINK DOWN - KN= ,BD,NEIG= ,O5)
CRYM03	DEFASC(03: LINK ERR (NO P.T.) - KN = ,BD,NEIG= ,O5)
CRYM04	DEFASC(04: LINE DETACHED - REASON= ,BH,LN= ,BD,NEIG= ,O5)
CRYM05	DEFASC(05: TAKEOVER - SUPERVISOR= ,BH)
CRYM06	DEFASC(06: SUP STOP)
CRYM07	DEFASC(07: SUP CRQ LOST - SUPERVISOR= ,BH)
CRYM08	DEFASC(08: CRQ GOBBLED NEEDLE - CHAR PAIR= ,HH,NEIG= ,O5)
CRYM09	DEFASC(09: ZAP ON UNASSIGNED CHANNEL - CHAN= ,HH,NEIG= ,O5)
CRYM0A	DEFASC(0A: NO NEIGHBOR - NEIG= ,O5)
CRYM0B	DEFASC(0B: CRQ BUILT - PORTS= ,HH,,HH)
CRYM0C	DEFASC(0C: CRQ ZAP   - PORTS= ,HH,,HH)
CRYM0D	DEFASC(0D: NO HOST - HOST#= ,D5)				:###CWC
CRYM0E	DEFASC(0E: NEEDLE ZAPPED - CHAN= ,HH,NEIG= ,O5)
CRYM0F	DEFASC(0F: CRQ TIMEOUT - CHANNEL = ,HH)
CRYM10	DEFASC(10: CHAN IN USE - LIFETIME= ,HH,ABS CHAN= ,HH)
CRYM11	DEFASC(11: REBUILD REQ - CHAN= ,HH,HSEQN= ,HH,,HH)
CRYM12	DEFASC(12: REB COMPLETE - CHN= ,HH,HSEQN= ,HH,,HH)
CRYM13	DEFASC(13: BAD REBUILD INVOICE NUMBER - ,HH,,HH)		:###wjl
CRYM14	DEFASC(14: REB DATA LOST. CHAN= ,HH)
CRYM15	DEFASC(15: HOST STAT - STATUS= ,BH,HOST= ,D5)			:###CWC
CRYM16	DEFASC(16: LINE ATTACHED - NLAT= ,BD,LN= ,BD,NEIG= ,O5)
CRYM17	DEFASC(17: NO COMMAND PORTS - INVOICE#= ,HH,,HH)
CRYM18	DEFASC(18: EARLY ZAPPER - CHAN= ,HH,NEIG= ,O5)
CRYM19	DEFASC(19: OUT OF CHANNELS - NEIG= ,O5)
CRYM1A	DEFASC(1A: NEEDLE POINT GARBAGE - FIRST 2 BYTES= ,HH)
CRYM1B	DEFASC(1B: NO KERNEL PORTS)
CRYM1C	DEFASC(1C: OUT OF DISPATCHER PORTS - NDP= ,HD,HOST=,D5)		:###CWC
CRYM1D	DEFASC(1D: SIO INT. - STAT= ,BH,CCODE= ,BH,LN= ,BD,NEIG= ,O5)	:###al
CRYM1E	DEFASC(1E: 4 SEC'S WITH NO REC'S RECVD - LN= ,BD,NEIG= ,O5)
CRYM1F	DEFASC(1F: NON-GOBBLING ZAPPER - NEIG= ,O5)			:###wjl
CRYM20	DEFASC(20: LINE SUSPENDED - SEC'S= ,HD,LN= ,BD,NEIG= ,O5)
CRYM21	DEFASC(21: LINK SHRINK - NCHN= ,HD, NEIG= ,O5)
CRYM22	DEFASC(22: LINK BUBBLE - NCHN= ,HD, NEIG= ,O5)
CRYM23	DEFASC(23: INV LOGGER ENTRY - BUFFER= ,HH,BF= ,HH)		:###TZ
CRYM24	DEFASC(24: SUP DATA ON UNASSIGNED CHN - CHAN= ,HH)
CRYM25	DEFASC(25: SUP ZAP ON UNASSIGNED CHN - CHAN= ,HH)
CRYM26	DEFASC(26: INV MACHNM ON CMD CIRCUIT - ERR CNT= ,HD,NODE= ,O5)
CRYM27	DEFASC(27: INV CMD ON CMD CIRCUIT - COMMAND= ,HH,ERR CNT= ,HD)
CRYM28	DEFASC(28: DATA ON UNASSIGNED CHANNEL - CHAN= ,HH,NEIG= ,O5)
CRYM29	DEFASC(29: NEEDLE ON ASSIGNED CHANNEL - CHAN= ,HH,NEIG= ,O5)
CRYM2A	DEFASC(2A: INV. 03 CHARACTER PAIR - CHAR= ,BH,CHAN= ,HH)
CRYM2B	DEFASC(2B: INT HOST CRQ TIMEOUT - CHAN= ,HH)
CRYM2C	DEFASC(2C: NEW DWL CHN - CHAN= ,HH,LN= ,BD)
CRYM2D	DEFASC(2D: DWL LINE ZAP - REASON= ,BH,LN= ,BD)
CRYM2E	DEFASC(2E: OUT OF INTERNAL HOST PORTS)
CRYM2F	DEFASC(2F: ISIS HOST OUT OF PORTS - INVOICE#= ,HH,,HH)
CRYM30	DEFASC(30: SYNC SCAN ERROR - LINE*2= ,BD,OFFSET= ,HH)
CRYM31	DEFASC(31: NETDGN CALLING ERROR)
CRYM32	DEFASC(32: SIO BUFFER CNT ERR - LINE*2= ,BD,COUNT= ,HH)
CRYM33	DEFASC(33: M-BOARD TIMEOUT - LINE= ,BD,REASON= ,BH)
CRYM34	DEFASC(34: CIRCUIT ERRORS - LEP= ,HD,CRQ= ,HD)
CRYM35	DEFASC(35: CIRCUIT INCONSISTENCIES - MAGNITUDE= ,HH,COUNT= ,HD)
CRYM36	DEFASC(36: LINK OVERLOADED - COUNT= ,HH,NEIG= ,O5)		:###OAS
CRYM37	DEFASC(37: LINK SATURATED - COUNT= ,HH,NEIG= ,O5)		:###OAS
CRYM38	DEFASC(38: ILC BUF ZERO - NEIG= ,O5)
CRYM39	DEFASC(39: LINK SNIP - TYPE=,HH,NEIG=,O5)
CRYM3A	DEFASC(3A: SIO CARD BUSY - CMD= ,HH)
CRYM3B	DEFASC(3B: SIO RING INTERRUPT - STATUS= ,HH)
CRYM3C	DEFASC(3C: TID RECEIVED - PORT= ,HO,CCT= ,BD)			:###wjl
CRYM3D	DEFASC(3D: NEEDLE EYE RECEIVED - PORT= ,HO,CHAN= ,HH)
CRYM3E	DEFASC(3E: "87"87"87BCKTAL ERROR - CHAN= ,HH,PORT= ,HO)
CRYM3F	DEFASC(3F: ASYNC PORT STATUS - STATUS= ,HD,PORT= ,HO)
CRYM40	DEFASC(40: TOT PKTS - RECD= ,HH,SENT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM41	DEFASC(41: BAD BORI. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM42	DEFASC(42: BAD ACK. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM43	DEFASC(43: BAD RECORD NUMBER. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM44	DEFASC(44: BAD CHECKSUM. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM45	DEFASC(45: RE-XMISSIONS REC'D. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM46	DEFASC(46: RE-XMISSIONS SENT. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM47	DEFASC(47: 4-SECOND GAPS. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM48	DEFASC(48: CROSSTALK. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM49	DEFASC(49: SPACING ON INPUT. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM4A	DEFASC(4A: HDLC CKSM ERRORS. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM4B	DEFASC(4B: HDLC ABORTS. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM4C	DEFASC(4C: UNTAKER - NEIG= ,O5)
CRYM4D	DEFASC(4D: CIRCUITS ZAPPED= ,HD,KN= ,BD,NEIG= ,O5)
CRYM4E	DEFASC(4E: CMD CTS  ZAPPED= ,HD,KN= ,BD,NEIG= ,O5)
CRYM4F	DEFASC(4F: ASYNC RING WRAP. MAX= ,HH,WRAP= ,HH)			:###wjl
CRYM50	DEFASC(50: BAD INT. HOST FUNCTION. VALUE = ,HH)
CRYM51	DEFASC(51: LINK FROZEN - NEIG= ,O5)
CRYM52	DEFASC(52: LINK THAWED - NEIG= ,O5)
CRYM53	DEFASC(53: BAD SIO REC LENGTH - LN= ,BD,NEIG= ,O5)

	IF	EXPSEC
CRYM54	DEFASC(54: XRAY AUDIT - TYPE= ,HH,NAME= ,HH,,HH,,HH)
	ELSE	:EXPSEC
CRYM54	DEFASC(54: XRAY COMMAND AUDIT - TYPE= ,HH)
	EI	:EXPSEC

CRYM55	DEFASC(55: SIO LINE TIMEOUT ON OUTPUT. MSEC= ,HD,LN= ,BD)
CRYM56	DEFASC(56: RECOVERY FROM MAC ERROR AT ADDRESS  1,HH)
CRYM57	DEFASC(57: DMA TIMEOUT. MAC STATUS= ,HH)
CRYM58	DEFASC(58: REPORT LIMIT EXCEEDED - SLOT= ,BD,LIMIT= ,HD)
CRYM59	DEFASC(59: DATA ON DISABLED ASYNC PORT. PN= ,HO)
CRYM5A	DEFASC(5A: CIRCUIT LIMIT EXCEEDED - SLOT= ,BD, HOST= ,D5)	:###CWC
CRYM5B	DEFASC(5B: INVALID HOST FOR RESTRICTED NODE - SLOT= ,BD,HOST= ,D5) :###CWC
CRYM5C	DEFASC(5C: INV. 03-PAIR ON T-I CMD CIRCUIT - DATA= ,HH, NEIG= ,O5)
CRYM5D	DEFASC(5D: INV. LENGTH ON T-I SUP RECORD - DATA= ,HH, NEIG= ,O5)
CRYM5E	DEFASC(5E: INV. 03-PAIR ON CMD CIRCUIT - DATA= ,HH)
CRYM5F	DEFASC(5F: CHAN IN USE - REL CHAN= ,HH,NEIG= ,O5)
CRYM60	DEFASC(60: BUFFER ZAP - COUNT= ,HH,CHAN= ,HH,BUFFER= ,HH)
CRYM61	DEFASC(61: SLOT OUT OF PORTS - NBR PORTS= ,HD,HOST= ,D5)	:###CWC
CRYM62	DEFASC(62: IMPOSTER HOST - SLOTS= ,HH,HOST= ,D5)		:###CWC
CRYM63	DEFASC(63: SQA ERROR - DIF= ,HH,PORT= ,HH)
CRYM64	DEFASC(64: KERNEL FAILED TO ZAP PORT - KERNEL PORT = ,HH)
CRYM65	DEFASC(65: SQFIX - CHN= ,HH,NET= ,HH,VALUE= ,HH,,HH)
CRYM66	DEFASC(66: SQACK - CHN= ,HH,HW SEQN= ,HH,HSEQN= ,HH,,HH)
CRYM67	DEFASC(67: REB NEEDLE - SENDING= ,HH,,HH,WANT= ,HH,,HH)
CRYM68	DEFASC(68: NO PERMUTER TABLES FOR NEW LINK - LN= ,BD,NEIG= ,O5)
CRYM69	DEFASC(69: NO LINK FOR NEW LINE - LN= ,BD,NEIG= ,O5)
CRYM6A	DEFASC(6A: CHAN STATUS - CHN= ,HH,HSEQN= ,HH,,HH)
CRYM6B	DEFASC(6B: REBUILD DISABLED ON CHAN= ,HH)
CRYM6C	DEFASC(6C: EARLY REBUILD NEEDLE. CHAN= ,HH)
CRYM6D	DEFASC(6D: INTERCEPT ABANDONED--NO STUB FOR INVOICE= ,HH,,HH)
CRYM6E	DEFASC(6E: CHAN STATUS - XSEQN= ,HH,,HH,VSEQN= ,HH,,HH)
CRYM6F	DEFASC(6F: SQF SENT - CHN= ,HH,XSEQN= ,HH,,HH)
CRYM70	DEFASC(70: SIO MBOARD ERROR - LINE= ,BD,NEIG= ,O5)  		:###OAS
CRYM71	DEFASC(71: WILDCARD - ADDRESS= ,HH,,HH,HW2= ,HH,HW3= ,HH)
CRYM72	DEFASC(72: SIO PORT UNAVAILABLE - LINE= ,BD)			:###OAS
CRYM73	DEFASC(73: BAD ZAP FROM ISIS - REASON = ,BH)			:###GT
CRYM74	DEFASC(74: TAKEOVER RESP. ERR - #NBRS= ,HH,NALINK= ,HH)		:###AL
CRYM75	DEFASC(75: NETID MISMATCH - LINE= ,BD,NETID= ,HH)		:###wjl
CRYM76	DEFASC(76: WSIZ MATCH DOWN - LINE= ,BD,WSIZ= ,HD)		:###wjl
CRYM77	DEFASC(77: XRAY NETID CHANGE - LINE= ,BD,NETID= ,HH)		:###wjl
CRYM78	DEFASC(78: UNRECOGNIZED SIGNAL RECEIVED - OUTGOING CHN = ,HH)	:###LSH
CRYM79	DEFASC(79: STARLINK REMOTE RESET FAILURE - LN= ,BD,NEIG= ,O5)	:###EV
CRYM7A	DEFASC(7A: STAR REMOTE NBR# MISMATCH - KEY= ,HH,,HH,NEIG= ,O5)	:###AL
CRYM7B	DEFASC(7B: SIO INIT SOFTWARE TIMEOUT - LN= ,BD)			:###wjl
CRYM7C	DEFASC(7C: NODE IN NETWK RECVED BOOT CMD FROM - NEIG= ,O5)	:###AL
CRYM7D	DEFASC(7D: NO REC'S RECVD FOR ,BD,SEC'S  LN= ,BD,NEIG= ,O5)	:###AL
	EI	:(XRSZLV-1)						:##AL


::*********************************************************************
::
::	ASCII MESSAGES:
::
::*********************************************************************

ASCXRY	SC	/"0D"0AX-RAY"0D"0A/
ASCNOD	SC	/NODE : /
ASCHST	SC	/"0D"0AHOST : /
ASCTIM	SC	/"0D"0ATIME : /
ASC02	SC	/"0D"0A??/
ASPRMT	SC	/"0D"0A>/
ASCCAR	SC	/"0D"00/
ASC3SP	SC	/   /
ASC6SP	SC	/      /	:
ASCSLH	SC	.\  .
ASCOER	SC	/ *ODD"0A"0D/
ASWRER	SC	/ADDRESS NOT ON HW OR FW BOUNDARY"0D"0A/
ASCZIP	SC	/ZIP"0D"0A/
ASCZAP	SC	/ ZAP? /
ASCPF	SC	/"0D"0A**PWR FAILURE/
ASCCRH	SC	/"0D"0A**CRASH  /
ASCERT	SC	/"0D"0A**ILL INST  /
ASCMCR	SC	/"0D"0A**MAC ERR  /
DMAERR	SC	/"0D"0A**DMA TIMEOUT/
ASCMMR	SC	/"0D"0A**PARITY ERR  /
ASCHLT	SC	/"0D"0A**HALT/
ASCRUN	SC	/"0D"0A**RUN"0D"0A/
ASCXER	SC	/"0D"0A**XRAY ERROR"0D"0A/
BADRDX	SC	/"07"0D"0A**BAD RADIX/
BADCON	SC	/"0D"0ACOMMAND NOT AVAILABLE IN THIS CONFIGURATION/
ASMCER	SC	/"07"0D"0A**BAD ADDRESS"0D"0A/
AUMG3	SC	/"0D"0ANEED THREE ARGUMENTS/			:###AL
SSMSG1	SC	/"0D"0AWRONG LINE NUMBER/			:###LSH
	IF	STRHUB
KYMSG	SC	/"0D"0AOUT OF FREE STAR XLINK/			:###AL
KYMSG2	SC	/"0D"0AKEY OR NBR ALREADY EXISTS ON THIS STAR LINE/
RKMSG	SC	/"0D"0AKEY IS NOT ON THIS STAR LINE/
RKMSG1	SC	/"0D"0ANO THIS FUNCTION WHEN LINK IS UP/	:###AL
RKMSG2	SC	/"0D"0ANEIGHBOR NUMBER NOT MATCHED/
NDSMSG	EQ	SSMSG1
CFMSG1	EQ	SSMSG1
CFMSG2	EQ	RKMSG2
CFMSG3	EQ	RKMSG1
:NDSMSG	SC	/"0D"0ANEED A STARLINE NUMBER/			:###AL
NDSMG1	SC	/"0D"0ASTARLINE IS DOWN/			:###AL
:CFMSG1	SC	/"0D"0ATHIS IS NOT A STAR LINE/			:###LSH
:CFMSG2	SC	/"0D"0AWRONG NEIGHBOR NUMBER/			:###LSH
:CFMSG3	SC	/"0D"0AACTIVE LINK, CAN'T CLEAR IT/		:###LSH
	EI	:STRHUB
ASCTRP	SC	/"0D"0ATRAP  /
PRFILL	SC	/"0ABYTE FILL: /
PRTINT	SC	/"0ARATE (0-7): /
PRNODE	SC	/"0AT-II NODE LIST: /
PRPRTY	SC	/"0APRIORITY: /
DERMSG	SC	/OUT OF INT HST CHAN OR INDEX ALREADY IN USE"0A"0D/
ASPWER	SC	/"0ANOT AUTHORIZED/
ASCOMU	SC	/  BUSY"0A"0D/

XNDHD0	SC	/"0D"0A"0ACRASH STATUS:  COUNT    TYPE    ADDRESS"0D"0A/
	IF	T2GATE			:##AL
XNDHD1	SC	/"0D"0A"0AGWNODE   HNHOST   INHOST    VERSION   H-WARE   S-WARE  SUPR   MEMORY"0D"0A/  :###CWC
	ELSE	:NOT T2GATE
XNDHD1	SC	/"0D"0A"0ANODE   KHOST   VERSION   H-WARE   S-WARE  SUPR   MEMORY"0D"0A/	:###CWC
	EI	:T2GATE
	IF	SOLOCS
XNDHD2  SC      /KB"0D"0A"0APORTS  PASSTHRUS  ALNK  TLNK  XLNK   LINES  SYNC  SIO  ASYNC "0D"0A/
	ELSE	STRHUB		:###wjl
XNDHD2	SC	/KB"0D"0A"0APORTS  PASSTHRUS  ALNK  TLNK  XLNK  SLNK  STXK   LINES  SYNC  SIO   STAR"0D"0A/
	ELSE	:NEITHER SOLOCS NOR STRHUB
XNDHD2	SC	/KB"0D"0A"0APORTS  PASSTHRUS  ALNK  TLNK  XLNK   LINES  SYNC  SIO"0D"0A/
	EI	:SOLOCS AND STRHUB
XNDHD3	SC	/    NODE LAST CAME UP AT /
XNDHD5	SC	/"0A"0D"0ANODE FIRST CAME UP AT /
XNDHD6	SC	/"0A"0D"0ALAST CRASH:     TIME       CC   TYPE  PSW   ADDRESS"0A"0D            /
	IF	STRHUB		:###wjl
XNDHD4	SC	+"0D"0A"0A**LINE**  ***--LINK--****            LINK         LINK                    "0D"0ANO. TYPE  NEIG   NO. TYPE    STATUS  WSIZ  SPEED  CRQS  TIME ATT/DET  ERRATE"0D"0A+
XNDRST	SC	/ RESET   /		:STARLINK IN RESET STATE ##AL
	ELSE	:NOT STRHUB 
XNDHD4	SC	+"0D"0A"0A**LINE**  ***--LINK--****    LINE    LINK  LINE   LINK  LINE          LINE"0D"0ANO. TYPE  NEIG   NO. TYPE    STATUS  WSIZ  SPEED  CRQS  TIME ATT/DET  ERRATE"0D"0A+
	EI	:STRHUB
NONEIG	SC	/                   UNUSED/	:
XDWLDS	SC	/                   DWLOAD/
XDWLBR	SC	/ DWLOAD  /
XNDLUP	SC	/ UP      /
XNDLOT	SC	/ *DOWN*  /
XNDSUS	SC	/ *SUSP*  /
XNDLUN	SC	/UNUSED/
XNDTKD	SC	/TII /:
XNDXKD	SC	/XLNK/:
XNDMLL	SC	/-M /
XNDHSY	SC	/SYNC  /
	IF	SILINS
XNDHSI	SC	/SIO   /
	EI	:SILINS
	IF	STRHUB!STRRMT		:###wjl
XNDHST	SC	/STAR  /		:###wjl
	EI	:STRHUB
ASTER1	SC	/  *    /
ASTER2	SC	/  **   /
ASTER3	SC	/  ***  /
ASTER4	SC	/  **** /
	SC	/  **** /
XNDER0	SC	/    /
XNDER1	SC	/*   /
XNDER2	SC	/**  /
XNDER3	SC	/*** /
XNDER4	SC	/***S*/
XNDWDN	SC	/"0D"0ATIILNK NEIGHBORS DOWN - /

	IF	SIORNG
XSRM1	SC	/"0D"0ASIO RING INTERFACE /
XSRM2	SC	/UP"0D"0A/
XSRM3	SC	/DOWN"0D"0A/
XSRM4	SC	/TIMED-OUT ON /
XSRM5	SC	/COMMAND"0D"0A/
XSRM6	SC	/"0D"0ASIO RING INITIALIZED"0D"0A/
XSRM7	SC	/"0D"0ASIO RING INTERFACE INITIALIZED"0D"0A/
XSRM8	SC	/AWAITING LOAD"0D"0A/
XSRM9	SC	/LOADING"0D"0A/
	EI	:SIORNG

XKSM01	SC	/"0D"0A"0ALOGICAL LINK CHARACTERS/
XKSM02	SC	/"0D"0APHYSICAL LINK CHARACTERS/
XKSM03	SC	/"0D"0A    CPS IN : /
XKSM04	SC	/"0D"0A    CPS OUT: /
XKSM05	SC	/HWM : /
XKSM06	SC	/"0D"0APACKET OVERHEAD/
XKSM07	SC	/"0D"0A    IN : /
XKSM08	SC	/    OUT : /
XKSM09	SC	/"0D"0ABANDWIDTH UTILIZATION/
XKSM12	SC	?"0D"0APACKET STATISTICS"0D"0A    PACKETS/SEC : ?
XKSM10	SC	/"0D"0AOVERLOAD COUNT   SATURATED COUNT   BACKLOG COUNT   PACKETS MADE   IDLE CALLS"0D"0A      /
XKSM13	SC	?"0D"0A    RECORDS/PACKET : ?	:###JHL FOR REL 5.02
XKSM14	SC	/   AVERAGE SIZE : /
XKSM15	SC	/"0D"0ALINK DELAY (MS)"0D"0A    IN QUEUE    RTEAR    BUFFER   OUT QUEUE   XMIT     TOTAL"0D"0A      /
XKSM16	SC	/BYTES/
XKSM17	SC	+"0D"0A"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0  MARKING"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0REXMISSIONS"A0"A0"A0"A0XMISSIONS+
XKSM18	SC	+"0D"0ALINE +
	IF	STRHUB		:##AL FOR STRLNK
XKS18A	SC	+"0D"0ASTAR LINK +
	EI
XKSM20	SC	+:    +
XKSM19	SC	/"0D"0A"0ALINK : /
XKSM22	SC	?"0D"0ACHAR/SEC PER CIRCUIT"0D"0A    IN : ?
XKSM23	SC	/  OUT : /
XKSM24	SC	/ CIRCUITS : /
XKSM25	SC	/ STATISTICS CLEARED/

XSTHD1	SC	/"0D"0AEXCT  EXLW  EXHW  EDHW  EEHW  SYHW  NEHW  NECT  MPRT  MPAS  MLNK"0D"0A/
XSTHD2	SC	/"0D"0A RMK XCT  RMK NMK  PACKETS"0D"0A/
XSTHD3	SC	/"0D"0A"0ANODE LINKS' TOTAL LOGICAL CPS RATES/		:###wjl
XSTHDB	SC	/"0D"0A"0ANODE LINKS' TOTAL PHYSICAL CPS RATES/		:###wjl
XSTHD4	SC	/"0D"0A"0AAVERAGE ASYNC TIME (MS) : /
XSTHD5	SC	/    MAX : /
XSTHD6	SC	/    WRAP : /
XSTHD7	SC	/"0D"0A"0ACODE DELAY    H-WARE DELAY     TOTAL       EFFICIENCY"0D"0A    /
XSTHD8	SC	/"0D"0A  CPSO     CPSI     HWMO     HWMI"0D"0A/
	IF	SOLOCS
XSTHD9	SC	/"0D"0A"0AASYNC CPS RATES/
	IF	NUMPRN
XSTHDA	SC	/"0D"0A"0APRINTER CPS RATES/
	EI	:NUMPRN
	EI	:SOLOCS
        if      super
xsthdc  sc      /"0a"0d"0aSUP RING CPS RATES/
        ei      :super
        if      nku
xsthdd  sc      /"0d"0a"0aKIO RINGS CPS/
        ei      :nku
XISHD1	SC	/"0D"0AIRCC  ORCC  ICHN  ICON  OHST  ILLG  IDSM  ODSM"0D"0A/
XIRHD1	SC	/"0D"0ATO ISIS:        FROM ISIS:"0D"0AFILL  EMPTY     FILL  EMPTY"0D"0ANODE  ISIS      ISIS  NODE"0D"0A/

XTLMS1	SC	/"0D"0ATRACE LINK: /
XTNMS1	SC	/"0D"0ATRACE LINE: /

NEIMS1	SC	+NODE  TPBO  NLWS  SPNM  NCHN  ISEC  NRTR  AMSK"0D"0A+
NEIMS2	SC	+"0D"0AOSEC  NRMK  NRXM  LRT   LAS   LRM   LAR   NAS "0D"0A+
NEIMS3	SC	+"0D"0ABNOD  CHN0  B.PT  E.PT  ACHN  VERS  LINES"0D"0A+
XBTMSG	SC	/"0D"0A"0A**ERROR AT 5A**"0D"0A/
DLDMS0	SC	/"0A**** TIME, AVE1, AVE2 AND DATA FIELDS ARE DECIMAL MS ****"0D/
DLDMS1	SC 	/"0A"0ATIME  CPS   STAT  FLAG  HWF   PTR   AVE1  AVE2"0D"0A/
DLDMS2	SC	/"0ANODES : /
DLDMS3	SC	/"0D"0A"0ADATA  :"0D"0A/
	IF	SOLOCS
XSTMS0	SC	/"0D"0A"0APROCESS: ASYNC SYLVR Q-SEC H-SEC SPIDR SWICH LINKR DWLIN SOURC X-RAY 1SEC"0D"0APERCENT: /
	ELSE
XSTMS0	SC	/"0D"0A"0APROCESS: SYLVR H-SEC SPIDR SWICH LINKR DWLIN SOURC X-RAY 1SEC"0D"0APERCENT: /
	EI	:SOLOCS
XSTMS1	SC	/"0D"0AMAX(MS): /
	IF	SWITIM
XSTMS3	SC	/"0D"0A"0APROCESS: LEP   CRQ   LOGGR INTHS ASYLO LGGO  DETCR"0D"0AMAX(MS): /
	EI	:SWITIM	###wjl

	IF	2-XRYTMC	:###wjl
	IF	TSTSZE
XTSFOR	SC	/"0D"0A"0A EVENT     LINE  HEAD  ACK   RECN     FASTC"0D"0A"0A/
XTSBAK	SC	/"0D"0A"0A EVENT     VA1   VA2   VA3   VA4      FASTC"0D"0A"0A/
XTSMSG	AC	/ZERO BIT/
	AC	/RESET   /
	AC	/DUMMYREC/
	AC	/CKSM ERR/
	AC	/BAD ACK /
	AC	/REXMISSN/
	AC	/BAD RECN/
	AC	/GOOD REC/
	AC	/RAW DATA/
	IF	NAKCOD
	AC	/NAK  REC/	:THE 9TH MSG FOR FORGROUND TRACE	###AL
	EI
TSNBTO	EQ	.-XTSMSG		:BEGINNNG OF BACKGROUND TEXT
	AC	/PKT MADE/
	AC	/PKT TORN/
	AC	/DETACH  /
	AC	/ATTACH  /
	AC	/ERROR!!!ERROR!!!ERROR!!!/
	EI      :TSTSZE
	EI	:2-XRYTMC ###wjl

TSPBAK	HS	1			:SAVE AREA FOR TMF/TMB POINTER

XDXN	HS	0		:POINT (XD) TO X-USER BLOCKS BY SLOT NO.
Q	EQ	XUBLK
TTYXD	EQ	XUBLK
	RE	NXUBLK
	if	alhub
	WC	Q			:XHBLK MOVED OUT FROM SEG0 	###AL
	else
	HC	Q
	ei
Q	EQ	Q+XUBSZ
	ER
	SYAD(XDXN  )			:ADD XDXN TO XRAY SYMBOL TABLE

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	TABLE:		CRYMTB
::	FUNCTION:	CRYPTO MESSAGE TABLE
::
::*********************************************************************

CRYMTB	HC	CRYM00-SEGD,CRYM01-SEGD,CRYM02-SEGD,CRYM03-SEGD
	HC	CRYM04-SEGD,CRYM05-SEGD,CRYM06-SEGD,CRYM07-SEGD
	HC	CRYM08-SEGD,CRYM09-SEGD,CRYM0A-SEGD,CRYM0B-SEGD
	HC	CRYM0C-SEGD,CRYM0D-SEGD,CRYM0E-SEGD,CRYM0F-SEGD
	HC	CRYM10-SEGD,CRYM11-SEGD,CRYM12-SEGD,CRYM13-SEGD
	HC	CRYM14-SEGD,CRYM15-SEGD,CRYM16-SEGD,CRYM17-SEGD
	HC	CRYM18-SEGD,CRYM19-SEGD,CRYM1A-SEGD,CRYM1B-SEGD
	HC	CRYM1C-SEGD,CRYM1D-SEGD,CRYM1E-SEGD,CRYM1F-SEGD
	HC	CRYM20-SEGD,CRYM21-SEGD,CRYM22-SEGD,CRYM23-SEGD
	HC	CRYM24-SEGD,CRYM25-SEGD,CRYM26-SEGD,CRYM27-SEGD
	HC	CRYM28-SEGD,CRYM29-SEGD,CRYM2A-SEGD,CRYM2B-SEGD
	HC	CRYM2C-SEGD,CRYM2D-SEGD,CRYM2E-SEGD,CRYM2F-SEGD
	HC	CRYM30-SEGD,CRYM31-SEGD,CRYM32-SEGD,CRYM33-SEGD
	HC	CRYM34-SEGD,CRYM35-SEGD,CRYM36-SEGD,CRYM37-SEGD
	HC	CRYM38-SEGD,CRYM39-SEGD,CRYM3A-SEGD,CRYM3B-SEGD
	HC	CRYM3C-SEGD,CRYM3D-SEGD,CRYM3E-SEGD,CRYM3F-SEGD
	HC	CRYM40-SEGD
	HC	CRYM41-SEGD,CRYM42-SEGD,CRYM43-SEGD,CRYM44-SEGD
	HC	CRYM45-SEGD,CRYM46-SEGD,CRYM47-SEGD,CRYM48-SEGD
	HC	CRYM49-SEGD,CRYM4A-SEGD,CRYM4B-SEGD,CRYM4C-SEGD
	HC	CRYM4D-SEGD,CRYM4E-SEGD,CRYM4F-SEGD,CRYM50-SEGD
	HC	CRYM51-SEGD,CRYM52-SEGD,CRYM53-SEGD,CRYM54-SEGD
	HC	CRYM55-SEGD,CRYM56-SEGD,CRYM57-SEGD,CRYM58-SEGD
	HC	CRYM59-SEGD,CRYM5A-SEGD,CRYM5B-SEGD,CRYM5C-SEGD
	HC	CRYM5D-SEGD,CRYM5E-SEGD,CRYM5F-SEGD,CRYM60-SEGD
	HC	CRYM61-SEGD,CRYM62-SEGD,CRYM63-SEGD,CRYM64-SEGD
	HC	CRYM65-SEGD,CRYM66-SEGD,CRYM67-SEGD,CRYM68-SEGD
	HC	CRYM69-SEGD,CRYM6A-SEGD,CRYM6B-SEGD,CRYM6C-SEGD
	HC	CRYM6D-SEGD,CRYM6E-SEGD,CRYM6F-SEGD,CRYM70-SEGD	:###OAS
	HC	CRYM71-SEGD,CRYM72-SEGD,CRYM73-SEGD,CRYM74-SEGD :###OAS###AL
	HC	CRYM75-SEGD,CRYM76-SEGD,CRYM77-SEGD,CRYM78-SEGD :###LSH###wjl
	HC	CRYM79-SEGD,CRYM7A-SEGD,CRYM7B-SEGD		:###ev ##AL#wjl
	HC	CRYM7C-SEGD,CRYM7D-SEGD				:###AL

	LIST

CRYMTZ	EQ	.-CRYMTB-2		:SIZE OF TABLE - 2
	EI	:(XRSZLV-1)		:##AL

:	LINK DESCRIPTOR SAVE AREA FOR 'KS'QUERY
        WS      0
XKSSKD  EQ      .-KS.PCO       	:ENABLE REFERENCE WITH KD EQUATES
        WS      (KSSZ+3)/4      :LINK DESCRIPTOR SAVE AREA FOR 'KS' QUERY
XKSZFG	HS	1		:KS STATS ZERO FLAG (FOR KS NGHBR# Z)	###OAS

XLUPFL  HS      1
TDMODE	HS	1		:CONTROLS ASCII/HEX OUTPUT MODE IN TD COMMAND
TDESFL	HS	1			:ESCAPE FLIPPER FOR TD, TE COMMANDS
XDLTMP  HS      1
XTDXCT  HS      1               	:EXECUTION COUNT FOR TD, PROTECTS
					: AGAINST FATAL LOOP
XTDFLG  HS      1               	:FLAG TELLS IF XRAY IS IN TD INST

XTSSAV  WC      0FFFF               	:SAME FOR TM INSTRUCTION 	###AL

XCRSAV  HS      5               	:SAVE AREA FOR COMMAND CLOBBERED BY SC
XCRADD  WS      1               	:SAVE AREA FOR CRASH ADDRESS
RWADDR  HS      1
SYMASC  WS      2
LASTCL  WS      1               	:ADDR OF LAST CELL OPENED

TRMASK  HS      TRRSIZ/10       	:BIT ARRAY TO MASK TRC DATA

XABSSV	WS	1			:SAVE AREA FOR MISC ABS MEMORY STUFF
TRABSV	WS	1			:SAVE AREA FOR TRAP STUFF FROM ABSOLUTE

::*********************************************************************
::
::	TABLE:		HSPEED
::	FUNCTION:	CONVERTS LINE'S BAUDRT VALUE INTO HUMAN-READABLE FORM
::
::*********************************************************************

:	THE VALUES ARE CONVERTED AS FOLLOWS:
:	BAUDRT   HSPEED
:	0	 BLANKS (FOR TIILNK DOWN LINES)
:	1	 2.4
:	2	 4.8
:	3	 7.2
:	4 - 5	 9.6
:	6 - 7	 14.4
:	8 - B	 19.2
:	C - F	 28.8
:	10 - 13	 38.4
:	14 - 16	 48
:	17 - 1E	 56
:	1F	 MS

	IF	2-XRYTMC		:###wjl

HSPEED	HS	0

	NOLIST

	RE	1
	SC	/      "00/
	ER
	RE	1
	SC	/2.4   "00/
	ER
	RE	1
	SC	/4.8   "00/
	ER
	RE	1
	SC	/7.2   "00/
	ER
	RE	2
	SC	/9.6   "00/
	ER
	RE	2
	SC	/14.4  "00/
	ER
	RE	4
	SC	/19.2  "00/
	ER
	RE	4
	SC	/28.8  "00/
	ER
	RE	4
	SC	/38.4  "00/
	ER
	RE	3
	SC	/48    "00/
	ER
	RE	8
	SC	/56    "00/
	ER
	SC	/MS    "00/

	LIST

	EI	:2-XRYTMC ###wjl

	IF	(XRSZLV)		:##AL
::*********************************************************************
::
::	TABLE:		KSPCPS
::	FUNCTION:	DERIVE MAXIMUM CHARACTERS PER SECOND BASED ON
::			LINK SPEED VALUE IN 'KSPD' LINK DESCRIPTOR FIELD.
::
::*********************************************************************

:	EACH FW ENTRY CONSISTS OF A HW ENTRY GIVING LINK SPEED IN CPS AND
:	A HW ENTRY GIVING SPEED IN CHAR/FASTC. THE LATTER IS USED IN THE
:	MTRFIC ROUTINE

KSPCPS	WS	0
KSPCPF	EQ	KSPCPS+2		:CHARACTERS/FASTC
	RA	0A			:DECIMAL RADIX
Q	EQ	0
	RE	22		:FIRST 22 ENTRIES SPEED IS 2400 * KSPD VALUE
	HC	Q*2400/8
	HC	(Q*4)/8
Q	EQ	Q+1
	ER
	RE	9			:NEXT 9 AS 56 KB...
	HC	56000/8
	HC	12			:56 KBPS IS ABOUT 12 CHAR/FASTC
	ER
	HC	100000/8		:CALL MS 100KB
	HC	21			:21 CHAR/FASTC =>100.8KB

	RA	0			:RESTORE HEX RADIX

	EI	:(XRSZLV)		:##AL

	SUBTTL	XRAY (XRAY command table)

::*********************************************************************
::
::	TABLE:		COMTBL
::	FUNCTION:	XRAY COMMAND TABLE
::
::*********************************************************************

:	XCOMP. macro defaults to not audited, not read-own-args,
:	regular prompt.

DFXCM.	MACRO(NAME,MNEM,POWER,ARG1,ARG2,ARG3)[
	AC	/MNEM/
	HC	NAME-SEGD
	KILL	Q1.,Q2.,Q3.
Q1.`ARG1 EQ	0
Q2.`ARG2 EQ	0
Q3.`ARG3 EQ	0
.QQ.	EQ	0
	IF	1-\Q1.
.QQ.	EQ	.QQ.!ARG1
	EI
	IF	1-\Q2.
.QQ.	EQ	.QQ.!ARG2
	EI
	IF	1-\Q3.
.QQ.	EQ	.QQ.!ARG3
	EI
	HC	.QQ.
	KILL	Q.
Q.`POWER EQ	0
	IF	\Q.
	HC	1
	ELSE
	HC	POWER
	EI
	]

X.PWR	EQ	0			:requires power 1
X.NPWR	EQ	1			:non-privileged
X.SPWR	EQ	0FFFF			:SUPER-PRIVILEGED
X.RAR	EQ	1			:reads own args
X.AUD	EQ	2			:AUDIT TYPE COMMAND
X.EXPR	EQ	4			:CLOSE WITH BANNER AND TIMESTAMP

:	XRYTMC switch provides three major assembly possibilities for XRAY.
:	1)  XRAY			:XRYTMC=0
:	2)  XRAY+NTCN/XRAY		:XRYTMC=1
:	3)  Reduced XRAY+NTCN/XRAY	:XRYTMC=2


COMTBL	WS	0			:COMMANDS AND THEIR ADRESSES
	IF	(XRSZLV-1)		:XRSZLV DEFAULT=3##AL
	DFXCM.(XTYPE,R ,X.NPWR,X.RAR)	:READ
	DFXCM.(READS,RS,X.NPWR,X.RAR)	:READ SYMBOLIC
	DFXCM.(DISADR,SA,X.NPWR,X.RAR)	:DISPLAY SYMBOL ADDRESS
	DFXCM.(GETPWR,GP,X.NPWR,X.RAR)
	EI	:(XRSZLV-1)		:##AL
	IF	(XRSZLV-2)		:##AL
	DFXCM.(WRITES,WS,X.NPWR,X.RAR,X.AUD)	:WRITE SYMBOLIC, DOES ITS OWN
						:SECURITY CHECK.
	DFXCM.(CHNBFL,CB,X.PWR,X.RAR)	:CHAIN THROUGH BUFFERLETS 	###wjl
	DFXCM.(XRMTCH,MA,X.PWR,X.EXPR)	:FIND MATCH IN MEMORY
	DFXCM.(XSIOST,SS,X.NPWR)	:DISPLAY SIO LINE STATUS	###wjl
	DFXCM.(SETTRP,ST,X.SPWR)	:SET TRAP
	DFXCM.(REMTRP,RT,X.SPWR)	:REMOVE TRAP
	DFXCM.(DISTRP,DT,X.NPWR,X.EXPR)	:DISPLAY TRAPS
	DFXCM.(WRITE,W ,X.SPWR,X.AUD)	:WRITE HALFWORD
	DFXCM.(WRITEF,WF,X.SPWR,X.AUD)	:WRITE FULLWORD
	DFXCM.(REGIST,RR,X.NPWR,X.EXPR)	:READ CRASH REGISTERS
	DFXCM.(XDCOCT,DO,X.NPWR)	:CONVERT DECIMAL TO OCTAL	###OAS
	DFXCM.(XOCDEC,OD,X.NPWR)	:CONVERT OCTAL TO DECIMAL	###OAS
	DFXCM.(XHXOCT,HO,X.NPWR)	:CONVERT HEX TO OCTAL
	DFXCM.(XOCHEX,OH,X.NPWR)	:CONVERT OCTAL TO HEX
	DFXCM.(XDCHEX,DH,X.NPWR)	:CONVERT DECIMAL TO HEX
	DFXCM.(XHXDEC,HD,X.NPWR)	:CONVERT HEX TO DECIMAL
	DFXCM.(XLECHO,LE,X.NPWR)	:SET LOCAL ECHO
	DFXCM.(XRECHO,RE,X.NPWR)	:SET REMOTE ECHO
	DFXCM.(SETCRS,SC,X.SPWR,X.EXPR)	:SET CRASH
	DFXCM.(SETBP,SB,X.SPWR,X.EXPR)	:SET BREAKPOINT
	DFXCM.(REMCRS,RC,X.SPWR)	:REMOVE CRASH OR BREAKPOINT
	DFXCM.(XPATCH,PA,X.SPWR)	:PATCH???
	DFXCM.(XRDBUF,RB,X.PWR,X.EXPR)	:READ BUFFER			###OAS
	DFXCM.(XWRBUF,WB,X.SPWR,X.EXPR)	:WRITE BUFFER

	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl	
	DFXCM.(XTRACE,TR,X.SPWR)	:SET TRACER ON/OFF FOR SPECIFIED RANGE
	DFXCM.(TYPTRC,TT,X.NPWR,X.EXPR)	:DISPLAY UPSW TRACE TABLE
	EI	:DB.TRC

	IF	ISIS
	DFXCM.(DRINGS,DR,X.PWR)		:DUMP DISPATCHER RINGS		###wjl
	DFXCM.(DSRNGS,DS,X.PWR)		:DUMP SAVED RINGS		###wjl
	 IF	.PROF.
	DFXCM.(PROFILE,PR,X.NPWR,X.RAR)	: PROFILE			###JOK
	 EI	: .PROF.
	EI	:ISIS

	IF	1-ISIS
	DFXCM.(STATUS,PS,X.NPWR)	:DISPLAY PSD
	DFXCM.(XBOOT,BT,X.PWR,X.AUD)	:GO TO BOOT
	DFXCM.(PRCEED,G ,X.SPWR)	:EXECUTE FROM ADDRESS OR ILL INST
	DFXCM.(GOBKPT,GB,X.SPWR)	:EXECUTE FROM BREAKPOINT
	DFXCM.(KHALT,HT,X.SPWR,X.AUD)	:HALT NODE CODE
	DFXCM.(WFABS,WA,X.SPWR,X.AUD)	:WRITE FW TO ABSOLUTE MEMORY
	 IF	ZITEL			:FOR ZITEL TRACE/STOP
	DFXCM.(XTRCBF,TS,X.SPWR,X.AUD)	:trigger on rd.wrt,ftch
	 EI	:ZITEL
	EI	:1-ISIS

	IF 	SOLOCS
	DFXCM.(XASYMC,MC,X.SPWR,X.AUD)	:FIDDLE WITH ASYNC MICROCODE PARAM'S
	EI 	:SOLOCS

	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	DFXCM.(XSSRN,SP,X.SPWR,X.AUD,X.EXPR)	:SIO RING TRACE		###OAS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	IF	BFLTMR			:###jhl
	DFXCM.(XBDSET,BD,X.PWR)		:set buffer delay timing method
	EI	:BFLTMR

	IF	EXPSEC
	DFXCM.(XGGMOD,XG,X.NPWR,X.AUD,X.EXPR)	:DISPLAY, MODIFY XRAY 
				:GOODGUY LIST, DOES IT'S OWN SECURITY
	EI	:EXPSEC

	IF	NDREAD
	DFXCM.(XNDLRD,NR,X.PWR,X.EXPR)	:read last needle orig in node
	EI	:NDREAD

	IF	XRESET				:###wjl
	DFXCM.(XNID,NI,X.SPWR,X.RAR,X.AUD)	:allow neighbor with 
	EI	:XRESET				:different NETID

	IF	SILINS
	DFXCM.(RSSILN,SI,X.SPWR,X.AUD)	:Initialize an SIO line.	###LSH
	IF	STRHUB
	DFXCM.(RMXKEY,RK,X.SPWR,X.AUD) :Tymstr LN & KEY removing ##AL
	DFXCM.(XLKKEY,IK,X.SPWR,X.AUD) :Tymstr xlink LN & INSERT KEY ##AL
	DFXCM.(CLLKFG,CF,X.SPWR,X.AUD) :Clear Tymstar link flag ###LSH
	DFXCM.(NDSTAR,SL,X.NPWR,X.EXPR) :STAR LINE STATUS DISPLAY ##AL
	IF	RBTHUB:WILL BE STRHUB
	DFXCM.(RBTNBR,BN,X.SPWR,X.AUD) :TYMSTAR REMOTE BOOT THE NEIGHBOR###AL
	EI
	EI	:STRHUB
	EI	:SILINS
	EI	:(XRSZLV-2)		:##AL

        if      super
        dfxcm.(xrysw,SW,x.npwr,x.expr)  :display sup traffic
        dfxcm.(xrdj,DJ,x.pwr,x.expr)    :display sup data
        ei
        if      nku
        dfxcm.(xrykw,KW,x.npwr,x.expr)
        ei      :nku                    :display kio traffic
	IF	2-XRYTMC	:**************************************
	IF	(XRSZLV)		:LOWEST LEVEL COMMANDS##AL
	DFXCM.(PTCQRY,PQ,X.NPWR)	:DISPLAY PATCH HISTORY TABLE	###OAS
	DFXCM.(XNEIGB,KD,X.NPWR,X.EXPR)	:DISPLAY LINK DESCRIPTOR
	DFXCM.(XCROPT,CO,X.NPWR,X.EXPR)	:DISPLAY/SET CRSH OPTION	###OAS
	DFXCM.(XSTATS,NS,X.NPWR,X.EXPR)	:DISPLAY NODE STATISTICS
	DFXCM.(XDCRSH,DC,X.NPWR,X.RAR,X.EXPR)	:DISPLAY CRASH TABLE DATA
	DFXCM.(XND,ND,X.NPWR,X.EXPR)	:NODE SNAP
	DFXCM.(XKS,KS,X.NPWR,X.EXPR)	:LINK STATISTICS
	EI	:(XRSZLV)
	IF	(XRSZLV-1)		:2ND LEVEL COMMANDS##AL
	DFXCM.(XWRMSG,WM,X.NPWR,X.RAR)	:WARNING MESSAGE
	DFXCM.(SETMES,SM,X.SPWR,X.AUD,X.RAR) :ENABLE/DISABLE CRYPTO MSGS###OAS
	DFXCM.(XRYPFM,PM,X.PWR)		:DO PERFORMANCE MONITORING ON CHAN
	DFXCM.(XCRMOD,CD,X.NPWR,X.EXPR)	:SET CRYPTO DISPLAY MODE
	DFXCM.(CRYLST,CL,X.NPWR,X.EXPR)	:DISPLAY CRYPTO LOG
	DFXCM.(SYMBAD,SY,X.NPWR,X.RAR)	:DISPLAY SYMBOL ADDRESSES
	DFXCM.(CRYMSG,CM,X.NPWR,X.RAR,X.EXPR)	:DISPLAY CRYPTO MSGS BY TYPE
	DFXCM.(XCHTRC,TC,X.PWR)		:SET CHANNEL DATA TRACE
	DFXCM.(TRCDAT,TD,X.NPWR,X.EXPR)	:DISPLAY CHANNEL TRACE DATA
	DFXCM.(TRCDES,TE,X.NPWR,X.EXPR)	:DISPLAY CHANNEL TRACE DATA W/ ESCAPES
	DFXCM.(TRCASC,TA,X.NPWR,X.EXPR)	:DISPLAY CHANNEL TRACE DATA ASCII
	DFXCM.(XLUPBK,DL,X.SPWR)	:CYCLOTRON
	DFXCM.(DBEGIN,DB,X.NPWR)	:BEGIN DELAY MEASUREMENT
	DFXCM.(DLYEND,DE,X.NPWR)	:END DELAY MEASUREMENT
	DFXCM.(DLDATA,DD,X.NPWR,X.EXPR)	:DISPLAY DELAY MEASUREMENT DATA
	DFXCM.(XBRZAP,BZ,X.PWR,X.AUD,X.EXPR)	:BORI ZAP A LINK
	DFXCM.(QRYCHN,QC,X.NPWR,X.EXPR)	:QUERY CHANNEL
	DFXCM.(XACHAN,AC,X.NPWR,X.EXPR)	:DISPLAY ACTIVE CHANNELS	###OAS

	IF	1-T2GATE
	DFXCM.(HSTDS,HS,X.NPWR,X.EXPR)	:DISPLAY EXPANDED HOST INFO	###OAS
	EI	:1-T2GATE

	IF	TSTSZE
	DFXCM.(XTLINK,TL,X.NPWR)	:TRACE LINK
	DFXCM.(XTSDAT,TM,X.NPWR)	:DISPLAY TRACE LINK DATA
	DFXCM.(XTLINE,TN,X.NPWR)	:TRACE UNASSIGNED LINE		###OAS
	EI	:TSTSZE

	IF	ISIS
	DFXCM.(ISSTAT,IS,X.NPWR)	:ISIS STATUS
	DFXCM.(ISRING,IR,X.NPWR)	:DISPLAY ISIS RING POINTERS
	EI	:ISIS

	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:ALL OTHER COMMANDS LEVEL ##AL
	DFXCM.(XBUFLT,BS,X.NPWR,X.EXPR)	:DISPLAY BUFFERLET USE HISTOGRAMS
	DFXCM.(XBGLST,BG,X.NPWR,X.AUD)	:MODIFY BADGUY LIST
					:SUPPLIES IT'S OWN SECURITY	###OAS

	IF	1-ISIS			:###wjl	
	IF	ZITEL
	DFXCM.(QMEM,QE,X.NPWR,X.EXPR)	:DISPLAY SEMI-MEM ERROR LOGS
	EI	:ZITEL
	EI	:1-ISIS	###wjl

	IF	DB.CPU
	DFXCM.(XCPUT,CU,X.SPWR)		:MEASURE CPU UTILIZATION
	EI	:DB.CPU

	IF	1-ISIS
	DFXCM.(XRSTRT,SN,X.SPWR,X.AUD)	:RESTART NODE CODE
	DFXCM.(RDREGS,RG,X.NPWR)	:READ SPECIFIED REGISTER SET
	DFXCM.(RDABS,RA,X.NPWR,X.RAR)	:READ ABSOLUTE MEMORY
	EI	:1-ISIS

	IF 	SOLOCS
	DFXCM.(XAZASY,AZ,X.NPWR,X.EXPR)	:INITIALIZE ASYNC STATS
	DFXCM.(XHANGP,HP,X.PWR,X.AUD,X.EXPR)	:HANG ASYNC PORT
	DFXCM.(XASYNC,AS,X.NPWR,X.EXPR)	:DISPLAY ASYNC PORT STATUS
	IF	0			:remove for version 6		###wjl
	DFXCM.(XASYIZ,IZ,X.PWR,X.AUD)	:INITIALIZE ASYNC
	EI	:0
	IF	PVC			:
	DFXCM.(PVXRAY,PV,X.NPWR)	:PVC configuration query
	EI	:PVC
	IF	SCBSYO
	DFXCM.(XBSYDS,QB,X.PWR)		:query busy ports array
	DFXCM.(XBSYPT,BP,X.PWR)		:busy or unbusy an async port
	EI	:SCBSYO
	EI 	:SOLOCS

	IF	SIORNG			:SR checks its own security	###OAS
	DFXCM.(XSR,SR,X.NPWR,X.EXPR)	:SIO RING STATUS
	EI	:SIORNG


	IF	PRIMSG
	DFXCM.(SETPRI,AP,X.PWR,X.AUD,X.RAR) :EN/DISA CRYPTO priority MSGS##AL
	DFXCM.(CRYLTP,CP,X.NPWR,X.EXPR)	:DISPLAY CRYPTO priority LOG	###al
	EI	:PRIMSG


	EI	:(XRSZLV-2)		:##AL

	ELSE	:(NOT)2-XRYTMC**********:TMCS/XRAY COMMANDS ###wjl ****

	DFXCM.(IXND,ND,X.NPWR,X.RAR)		; GL IXND	:ND
	DFXCM.(IXNS,NS,X.NPWR,X.RAR)		; GL IXNS	:NS
	DFXCM.(IXNSZ,NZ,X.NPWR,X.RAR)		; GL IXNSZ	:NSZ
	DFXCM.(IXBG,BG,X.NPWR,X.RAR)		; GL IXBG	:BG
	DFXCM.(IXWM1,WD,X.NPWR,X.RAR)		; GL IXWM1	:WM1
	DFXCM.(IXTC,TC,X.PWR,X.RAR)		; GL IXTC	:TC
	DFXCM.(IXBS,BS,X.NPWR,X.RAR)		; GL IXBS	:BS
	DFXCM.(IXDC,DC,X.NPWR,X.RAR)		; GL IXDC	:DC
	DFXCM.(IXDCS,DU,X.NPWR,X.RAR)		; GL IXDCS	:DCS
	DFXCM.(IXDCD,DA,X.NPWR,X.RAR)		; GL IXDCD	:DCD
	DFXCM.(IXCO,CO,X.NPWR,X.RAR)		; GL IXCO	:CO
	DFXCM.(IXKD,KD,X.NPWR,X.RAR)		; GL IXKD	:KD #
	DFXCM.(IXKS,KS,X.NPWR,X.RAR)		; GL IXKS	:KS #
	DFXCM.(IXAC,AC,X.NPWR,X.RAR)		; GL IXAC	:AC # #
	DFXCM.(IXQC,QC,X.NPWR,X.RAR)		; GL IXQC	:QC #
	DFXCM.(IXQC2,QR,X.NPWR,X.RAR)		; GL IXQC2	:QC # #
	DFXCM.(IXQC1U,QU,X.NPWR,X.RAR)		; GL IXQC1U	:QC # U
	DFXCM.(IXQC2U,QW,X.NPWR,X.RAR)		; GL IXQC2U	:QC # # U
	DFXCM.(IXPM,PM,X.PWR,X.RAR)		; GL IXPM	:PM #
:	DFXCM.(IXRD,RD,X.PWR,X.RAR)		; GL IXRD	:R #
:	DFXCM.(IXRDC,RN,X.PWR,X.RAR)		; GL IXRDC	:R # #
:	DFXCM.(IXRS,RS,X.PWR,X.RAR)		; GL IXRS	:RS <s>
	DFXCM.(IXRSC,RU,X.PWR,X.RAR)		; GL IXRSC	:RS <s> #
	DFXCM.(IXTD,TD,X.SPWR,X.RAR)		; GL IXTD	:TD,TE,TA
	DFXCM.(IXTDC,TG,X.SPWR,X.RAR)		; GL IXTDC	:TD #
	DFXCM.(IXTDI,TI,X.SPWR,X.RAR)		; GL IXTDI	:TD I
	DFXCM.(IXTDCI,TJ,X.SPWR,X.RAR)		; GL IXTDCI	:TD # I
	DFXCM.(IXTDO,TO,X.SPWR,X.RAR)		; GL IXTDO	:TD O
	DFXCM.(IXTDCO,TP,X.SPWR,X.RAR)		; GL IXTDCO	:TD # O
	DFXCM.(IXCL,CL,X.NPWR,X.RAR)		; GL IXCL	:CL
	DFXCM.(IXCLC,CC,X.NPWR,X.RAR)		; GL IXCLC	:CL #
	DFXCM.(IXCLH,CR,X.NPWR,X.RAR)		; GL IXCLH	:CL # H
	DFXCM.(IXCLM,CT,X.NPWR,X.RAR)		; GL IXCLM	:CL # M
	DFXCM.(IXCM,CM,X.NPWR,X.RAR)		; GL IXCM	:CM #
	DFXCM.(IXDD,DD,X.NPWR,X.RAR)		; GL IXDD	:DD
	DFXCM.(IXDDX,DX,X.NPWR,X.RAR)		; GL IXDDX	:DD #
	DFXCM.(IXBSZ,BC,X.NPWR,X.RAR)		; GL IXBSZ	:BSZ
	DFXCM.(IXBZ,BZ,X.PWR,X.RAR,X.AUD)	; GL IXBZ	:BZ #
	DFXCM.(IXTC1,TH,X.SPWR,X.RAR)		; GL IXTC1	:TC # 1
	DFXCM.(IXSM1,SE,X.PWR,X.RAR)		; GL IXSM1	:SM # 1
	DFXCM.(IXBGI,BI,X.PWR,X.RAR,X.AUD)	; GL IXBGI	:BG # I
	DFXCM.(IXWM0,WZ,X.NPWR,X.RAR)		; GL IXWM0	:WM0
	DFXCM.(IXDE,DE,X.PWR,X.RAR)		; GL IXDE	:DE
	DFXCM.(IXDEX,DF,X.PWR,X.RAR)		; GL IXDEX	:DE #
	DFXCM.(IXTC0,TQ,X.PWR,X.RAR)		; GL IXTC0	:TC # 0
	DFXCM.(IXKSZ,KZ,X.NPWR,X.RAR)		; GL IXKSZ	:KS # Z
	DFXCM.(IXSM0,SD,X.PWR,X.RAR)		; GL IXSM0	:SM # 0
	DFXCM.(IXBGR,BR,X.PWR,X.RAR,X.AUD)	; GL IXBGR	:BG # R
	DFXCM.(IXDL,DL,X.SPWR,X.RAR)		; GL IXDL	:DL
	DFXCM.(IXDLX,DM,X.SPWR,X.RAR)		; GL IXDLX	:DL #
	DFXCM.(IXWM,WM,X.NPWR,X.RAR)		; GL IXWM	:WM
	DFXCM.(IXDB,DB,X.PWR,X.RAR)		; GL IXDB	:DB
	DFXCM.(IXDBX,DG,X.PWR,X.RAR)		; GL IXDBX	:DB #
	DFXCM.(IXDBR,DJ,X.PWR,X.RAR)		; GL IXDBR	:DB R
	DFXCM.(IXDBXR,DK,X.PWR,X.RAR)		; GL IXDBXR	:DB # R
:	DFXCM.(IXWS,WS,X.NPWR,X.RAR)		; GL IXWS	:WS
	DFXCM.(IXSY,SY,X.SPWR,X.RAR)		; GL IXSY	:SY <s>
	DFXCM.(IXCDY,CY,X.NPWR,X.RAR)		; GL IXCDY	:CD Y
	DFXCM.(IXCDN,CN,X.NPWR,X.RAR)		; GL IXCDN	:CD N
	DFXCM.(IXCOH,CH,X.PWR,X.RAR)		; GL IXCOH	:CO <hh>
	DFXCM.(IXCOS,CS,X.PWR,X.RAR)		; GL IXCOS	:CO <ss>
	DFXCM.(IXCMH,CE,X.NPWR,X.RAR)		; GL IXCMH	:CM # # H
	DFXCM.(IXCMM,CA,X.NPWR,X.RAR)		; GL IXCMM	:CM # # M
	DFXCM.(IXSM,SM,X.PWR,X.RAR)		; GL IXSM	:SM
	DFXCM.(IXDLR,DN,X.SPWR,X.RAR)		; GL IXDLR	:DL R
	DFXCM.(IXDLXR,DP,X.SPWR,X.RAR)		; GL IXDLXR	:DL # R
	DFXCM.(IXPQ,PQ,X.NPWR,X.RAR)		; GL IXPQ	:PQ

:	DISPLAY EXPANDED HOST INFORMATION
	DFXCM.(IXHS,HS,X.NPWR,X.RAR)		; GL IXHS	:HS
	DFXCM.(IXHSH,HH,X.NPWR,X.RAR)		; GL IXHSH	:HS # H
	DFXCM.(IXHSU,HU,X.NPWR,X.RAR)		; GL IXHSU	:HS U
	DFXCM.(IXHSS,HL,X.NPWR,X.RAR)		; GL IXHSS	:HS # S

	IF	TSTSZE			:Disabled with NTLV Option in TYMFILE
	DFXCM.(IXTL,TL,X.NPWR,X.RAR)		; GL IXTL	:TL
	DFXCM.(IXTMF,TF,X.NPWR,X.RAR)		; GL IXTMF	:TM F
	DFXCM.(IXTMB,TB,X.NPWR,X.RAR)		; GL IXTMB	:TM B
	DFXCM.(IXTN,TN,X.NPWR,X.RAR)		; GL IXTN	:TN
	DFXCM.(IXTLN,TK,X.NPWR,X.RAR)		; GL IXTLN	:TL #
	DFXCM.(IXTNL,TU,X.NPWR,X.RAR)		; GL IXTNL	:TN #
	DFXCM.(IXTL0,TE,X.NPWR,X.RAR)		; GL IXTL0	:TL 0
	DFXCM.(IXTNF,TZ,X.NPWR,X.RAR)		; GL IXTNF	:TN FFFF
	EI	:TSTSZE

	IF	1-ISIS			:###wjl
	IF	ZITEL
	DFXCM.(IXQE,QE,X.NPWR,X.RAR)		; GL IXQE	:QE
	EI	:ZITEL
	EI	:1-ISIS	###wjl

	IF	DB.CPU			:Set at assembly time
	DFXCM.(IXCU,CU,X.PWR,X.RAR)		; GL IXCU	:CU
	DFXCM.(IXCUN,CW,X.PWR,X.RAR)		; GL IXCUN	:CU #
	EI	:DB.CPU

	IF	1-ISIS
	DFXCM.(IXRA,RA,X.PWR,X.RAR)		; GL IXRA	:RA #
	DFXCM.(IXRAC,RO,X.PWR,X.RAR)		; GL IXRAC	:RA # #
	DFXCM.(IXRG,RG,X.PWR,X.RAR)		; GL IXRG	:RG #
	DFXCM.(IXSN,SN,X.SPWR,X.RAR,X.AUD)	; GL IXSN	:SN
	EI	:1-ISIS

	IF	ISIS
	DFXCM.(IXIS,IS,X.NPWR,X.RAR)		; GL IXIS	:IS
	DFXCM.(IXIR,IR,X.NPWR,X.RAR)		; GL IXIR	:IR
	EI	:ISIS

	IF	SOLOCS
	DFXCM.(IXAS,AS,X.NPWR,X.RAR)		; GL IXAS	:AS
	DFXCM.(IXASN,AP,X.NPWR,X.RAR)		; GL IXASN	:AS #
	DFXCM.(IXASR,AR,X.NPWR,X.RAR)		; GL IXASR	:AS # #
	DFXCM.(IXASU,AU,X.NPWR,X.RAR)		; GL IXASU	:AS U
	DFXCM.(IXASNU,AV,X.NPWR,X.RAR)		; GL IXASNU	:AS # U
	DFXCM.(IXASRU,AW,X.NPWR,X.RAR)		; GL IXASRU	:AS # # U
	IF	0	:remove for version 6
	DFXCM.(IXIZ,IZ,X.SPWR,X.RAR,X.AUD)	; GL IXIZ	:IZ
	EI	:0
	DFXCM.(IXAZ,AZ,X.NPWR,X.RAR)		; GL IXAZ	:AZ
	DFXCM.(IXHP,HP,X.SPWR,X.RAR,X.AUD)	; GL IXHP	:HP #
	IF	SCBSYO
	DFXCM.(IXBP,BP,X.NPWR,X.RAR)		; GL IXBP	:BP
	DFXCM.(IXBP1,BB,X.PWR,X.RAR,X.AUD)	; GL IXBP1	:BP # 1
	DFXCM.(IXBP0,BU,X.PWR,X.RAR,X.AUD)	; GL IXBP0	:BP # 0
	EI	:SCBSYO
	EI	:SOLOCS

	IF	PVC
	DFXCM.(IXPV,PV,X.NPWR,X.RAR)		; GL IXPV	:PV
	DFXCM.(IXPVN,PP,X.NPWR,X.RAR)		; GL IXPVN	:PV #
	EI	:PVC

	IF	SIORNG
	DFXCM.(IXSR,SR,X.PWR,X.RAR)		; GL IXSR	:SR
	DFXCM.(IXSR1,SU,X.SPWR,X.RAR)		; GL IXSR1	:SR 1
	DFXCM.(IXSR2,SW,X.SPWR,X.RAR)		; GL IXSR2	:SR 2
	EI	:SIORNG

	EI	:2-XRYTMC**********************************************


	IF	LNFDBG 	:**********************************************
	DFXCM.(LGXRDB,LG,X.SPWR)	:DISPLAY PORT LOGON/LOGOFF HISTORY RING
	GL	LGXRDB
	EI	:LNFDBG

	IF	CBZDBG
	DFXCM.(CZXRDB,CZ,X.SPWR)	:DISPLAY CIRCUIT BUILDING/ZAPPING
	GL	CZXRDB
	EI	:CBZDBG		 HISTORY RING

	IF	BFSDBG
	DFXCM.(BFXRDB,BF,X.SPWR)	:DISPLAY BUFFER STRUCTURE HISTORY RING
	GL	BFXRDB
	EI	:BFSDBG

	IF	LPGDBG
	DFXCM.(LLXRDB,LL,X.SPWR)	:DISPLAY NODE CODE -SUPERVISOR
	GL	LLXRDB
	EI	:LPGDBG		 COMMUNICATION HISTORY RING

	IF	AIODBG
	IF	SOLOCS
	DFXCM.(ADXRDB,AD,X.SPWR)	:DISPLAY ASYNC INPUT/OUTPUT HISTORY
	GL	ADXRDB
	EI	:SOLOCS
	EI	:AIODBG	

	IF	DBGON	
	DFXCM.(THXRDB,TH,X.SPWR,X.AUD)	:TURN ON/OFF HISTORY TRACE
	GL	THXRDB
	EI	:DBGON	**********************************************


XNCMND	EQ	(.-COMTBL)/8		:TOTAL NUMBER OF XRAY COMMANDS

	SUBTTL	XRAY (Scheduler)

::*********************************************************************
::
::	PROCESS:	XRYSCH:
::	FUNCTION:	SCHEDULER FOR REMOTE XRAY USER
::	SCHEDULED:	On demand by G500MS if XRAY has trap output to dump,
::	on demand by any calls to output real-time CRYPTO messages to a 
::	remote XRAY user, and on demand by INTHST requesting processing
::	of remote XRAY data.
::	YIELDS:		Between long processing loops in XRAY code,
::	during performance measurment calculations and between every
::	160 characters output by XRAY.  After yielding XRYSCH is re-
::	scheduled on a 125 MS periodic basis.
::	DISMISSES:	To the EXEC loop if no command data, if all output
::	is complete and no more input is available.
::	CALLS:		JAL	R11,XWRITE
::			JAL	R11,XPRTKT
::
::*********************************************************************

:	THE CURRENT USER PC IS STORED AT XRYADR. XRYSCH VERIFIES THAT
:	XRAY IS IN REMOTE MODE BEFORE TRANSFERING CONTROL. FOR AN ISIS
:	MACHINE THIS MEANS INTXRF > 0.	ADDITIONALLY FOR SOLO, XRYTTY
:	MUST BE = 1.

XRYSCH	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(XRYSCH)			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU
	LIS	R0,0
	STH	R0,XRYRUN		:CLEAR XRAY RUN FLAG IN CASE IT WAS SET
	LHI	R0,01F-PXRAY
	RBT	R0,T125MS
XRYSC0	LHL	R0,XQUEC,,		:GET CURRENT XRAY USER QUESER QUEUE
	NHI	R0,7FFF			:IN CASE TTY XRAY GOT SCHEDULED
	JFFOH	R0,XRYSC1		:GO DO IT TO IT
	JFS	XRYSC2
XRYSC1	if	alhub
	SLLS	R1,1			:2*R1
	L	XD,XDXN,R1,R1		:XUBLK POINTER BY FULLWORD	###AL
	SRLS	R1,1			:RESUME R1
	else
	LHL	XD,XDXN,R1,R1		:XUBLK POINTER
	ei
	JAL	R11,XWRITE		:GIVE XRAY WRITE ACCESS TO SEGD
	L	R0,XRYADR,XD		:GET USER PC
	JR	R0			:AND DISPATCH
XRYSC2	LHL	R0,XQUEM,,		:NO ONE IN CURRENT QUEUE, SO GET
	JE	EXDISM,,		:MASTER QUEUE
	STH	R0,XQUEC,,		:AND MAKE IT CURRENT
	LIS	R0,0			:ZERO OUT MASTER QUEUE
	STH	R0,XQUEM,,		:
	J	XRYSC0			:TRY AGAIN

XRYDIS	HS	0
	ST	R0,XRYADR,XD		:SAVE USER PC
	LHL	XN,XUSLTN,XD		:XRAY USER SLOT NUMBER
	RBT	XN,XQUEC,,		:TAKE OUT OF QUEUECURRENT
	JAL	R11,XPRTKT		:RESTORE SEGD WRITE PROTECT
	LHL	R0,XQUEC,,
	OH	R0,XQUEM,,
	JE	EXDISM,,
	JFS	XRYYL1

XRYYLD	HS	0
	ST	R0,XRYADR,XD		:SAVE USER PC
	LHL	R0,XUSLTN,XD		:XRAY USER SLOT NO.
	RBT	R0,XQUEC,,		:TAKE OUT OF QUEUECURRENT
	SBT	R0,XQUEM,,		:RESCHEDULE IN QUEUEMASTER
	JAL	R11,XPRTKT		:RESTORE SEGD WRITE PROTECT
XRYYL1	LHI	R0,1F-PXRAY		:RESCHEDULE XRAY IN 1/8 SEC
	SBT	R0,T125MS		:BY SETTING APPROPRIATE TIMEOUT BIT
	J	EXDISM,,		:DISMISS

	SUBTTL	XRAY (Utility routines for scheduling remote XRAY)

::*********************************************************************
::
::	SUBROUTINE:	XRYMOD:
::	FUNCTION:	Determine XRAY mode
::	CALLING SEQ:	JAL	R0,XRYMOD
::	RETURNS:	IMMEDIATE RETURN IF IN TTY MODE
::			+8 RETURN IF IN REMOTE MODE
::
::**********************************************************************

XRYMOD	HS	0
	CI	XD,TTYXD
	JER	R0			:YES, IMMEDIATE RETURN
	AIS	R0,8
	JR	R0			:REMOTE USER IN REMOTE MODE--+8 RETURN

::*********************************************************************
::
::	SUBROUTINE:	XWRITE:
::	FUNCTION:	Give XRAY write access
::	CALLING SEQ:	JAL	R11,XWRITE
::
::*********************************************************************

XWRITE	HS	0
	IF	ISIS
	LI	R0,XSG1WA		:ISIS SVC FOR WRITE ENABLE
	SVC	SYS,11
	LI	R0,XSGDWA		:NEED SEGD WRITE ENABLE ALSO
	SVC	SYS,11
	ELSE	:NOT ISIS
	SVC	0F,SV.WEN		:SOLO SVC FOR MAC CHANGE
	EI	:ISIS
	JR	R11			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	XPRTKT:
::	FUNCTION:	Restore write protect
::	CALLING SEQ:	JAL	R11,XPRTKT
::
::*********************************************************************

XPRTKT	HS	0
	IF	ISIS
	LI	R0,XSG1WP		:ISIS SVC FOR WRITE PROTECT
	SVC	SYS,11
	LI	R0,XSGDWP		:ALSO RESTORE SEGD WRITE PROTECT
	SVC	SYS,11
	ELSE	:NOT ISIS
	SVC	0F,SV.WOF		:SOLO SVC FOR MAC CHANGE
	EI	:ISIS
	JR	R11			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	XCLEAN:
::	FUNCTION:	CLEANS UP X-RAY STATUS FOLLOWING ^C OR LOGOUT
::	CALLING SEQ:	JAL	R11,XCLEAN
::
::*********************************************************************

XCLEAN	HS	0
	CLH	XD,XWMCIU
	JNFS	XCLEA9
	LIS	R0,0
	STH	R0,XWMCIU
XCLEA9	HS	0
	IF	1-ISIS
	C	XD,XRACIU		:DOING RA?
	JNFS	XCLEA0			:NO
	LIS	R0,0
	ST	R0,XRACIU
	EI	:1-ISIS
XCLEA0	C	XD,XKSCIU		:IN MIDDLE OF KS?
	JNFS	XCLEA1			:NO
	LIS	R0,0
	ST	R0,XKSCIU		:KS COMMAND NOT IN USE ANY MORE
XCLEA1	TS	XTDFLG			:IN MIDDLE OF TD INST WHEN ^C STRUCK?
	JLFS	XCLEA7			:NO
	LHI	R0,208			:YES
	STH	R0,CHRTRC,,		:RE-ENABLE TRACE
XCLEA7	HS	0
	IF	TSTSZE
	L	R0,XTSSAV		:IN TM INST WHEN ^C STRUCK?	###OAS
	CI	R0,0FFFF		:IF IT'S INIT VALUE		###AL
	JE	XCLEA8			:NO				###wjl
	STH	R0,TSLINE		:YES, RESTORE TSLINE		###OAS
	EXHR	R0,R0			:AND				###OAS
	STH	R0,TSLINK		:RESTORE TSLINK TO REENABLE TSN
	LI	R0,0FFFF		:INIT TO 0FFFF			###AL
	ST	R0,XTSSAV		:AND CLEAR OUT XTSSAV SO WE DONT REPEAT
	EI	:TSTSZE			:###OAS

XCLEA8	HS	0
	IF	XRYTMC			:###wjl
	LIS	R0,0
	ST	R0,IIXNTC,XD,		:clear TMCS/XRAY flags
	EI	:XRYTMC

	JR	R11			:RETURN TO CALLER

	SUBTTL	XRAY (Main command loop)

::*********************************************************************
::
::	MAIN COMMAND LOOP:	XLOOP:
::	ENTRY POINTS:	XRCRLF/XRPRMT/XPRMPT
::			XRAY	:SHEDULED BY SOLO CONTEXT SWITCHER OR ISIS DDT
::			XRAYIS	:REMOTE USER LOGGING IN OR TYPING ^C
::
::*********************************************************************

XRCRLF	HS	0
	JAL	R7,TYPCRL,,
XRPRMT	HS	0
XPRMPT	HS	0
	L	R11,XPRTTP,XD
	JE	XNRPRT
	JR	R11

:	ENTRY POINT - XRAY SCHEDULED BY SOLO CONTEXT SWITCHER OR ISIS DDT

XRAY	HS	0
	IF	ISIS
	LI	R0,XSG1WA		:ISIS SVC FOR SEG1 WRITE ENABLE
	TS	XBREAK,,		:TEMPORARILY SUSPEND CRYPTO OUTPUT
	SVC	SYS,11
	LI	R0,XSGDWA
	SVC	SYS,11			:ALLOW WRITES TO SEGD ALSO
	EI	:ISIS
	LI	XD,TTYXD		:POINTER TO SPECIAL USER BLOCK

:	ENTRY POINT - REMOTE XRAY USER LOGGING IN OR TYPING ^C

XRAYIS	HS	0
	JALMAC(TYPASI)
	IF	T2GATE
	SC	/"0D"0A**GATEWAY OPERATION MANAGER** /
	ELSE	:NOT T2GATE
	SC	/"0D"0A**X-RAY** /
	EI	:T2GATE##AL
	JALMAC(TYPASI)
	SC	/NODE: /
	LHI	R3,MACHNM		:GET NODE NUMBER IN HEX		###SHM
	JAL	R9,HEXOCT,,		:CONVERT TO OCTAL		###SHM
	JAL 	R9,TYP5CH,,     	:TYPE 5 OCTAL DIGIT NODE #	###SHM
	JALMAC(TYPASI)
	SC	/HOST: /
	LHI	R3,HST0			:get kernel host number		###wjl
	JAL	R9,TYP5DD,,		:type it in decimal 		###CWC
	JALMAC(TYPASI)
	SC	/TIME: /
	JAL	R9,GMTCAL,,
	L	R2,GMTNOW,,
	JAL	R9,GMTCNV,,
	IF	(XRSZLV-1)		:##AL
	LHL	R0,CRYPRI		:CLEAR CRYPTO BUFFER
	STH	R0,CRYPTU,XD
        LIS     R0,1                    :init auto crypto off  ###sdw
        STH     R0,CRYMOD,XD
	EI	:(XRSZLV-1)		:##AL
	IF	(XRSZLV-2)		:##AL
	IF	PRIMSG
	LHL	R0,CRYPPI		:CLEAR CRYPTO priority BUFFER	###al
	STH	R0,CRYPPU,XD		:				###al
	EI	:PRIMSG
	EI	:(XRSZLV-2)		:##AL
	LHI	R0,$A8*4		:INITIALIZE TO 8 ARGUMENTS MAX
	STH	R0,ARGMAX,XD
	JAL	R11,XCLEAN		:DO CLEANUP
	IF	(XRSZLV-1)		:##AL
	LHL	R0,XUINTH,XD
	RBT	R0,XWMFLG,,
	JEFS	COMCLR
	LB	R0,XWMSGB
	JEFS	COMCLR
	JAL	R5,XWMDIS
	EI	:(XRSZLV-1)		:##AL

COMCLR	HS	0
	LIS	R0,0			:RESTORE SIMPLE PROMPT JUST IN CASE
	ST	R0,XPRTTP,XD		:	SO WE DON'T GET TWO HEADERS
	LHL	R0,XRYPTF,XD		:CLEAR INPUT RING
	STH	R0,XRYPTE,XD
	IF	1-ISIS
	CI	XD,TTYXD		:TEST FOR TTY USER
	JN	XRPRMT			:NO
COMC02	SVC	0F,SV.RTY		:CLEAR TTY INPUT BUFFER
	J	COMC01			:.+6
	JBS	COMC02			:.-8
	EI	:1-ISIS
COMC01	J	XRPRMT

XEXPRT	HS	0
	JALMAC(TYPASI)
	IF	T2GATE			:##AL
	SC	/"0D"0A**GATEWAY OPERATION MANAGER** /
	ELSE	:NOT T2GATE
	SC	/"0D"0A**X-RAY** /
	EI	:T2GATE
	JALMAC(TYPASI)
	SC	/NODE: /
	LHI	R3,MACHNM		:GET NODE NUMBER IN HEX		###SHM
	JAL	R9,HEXOCT,,		:CONVERT TO OCTAL		###SHM
	JAL 	R9,TYP5CH,,     	:TYPE 5 OCTAL DIGIT NODE #	###SHM
	JALMAC(TYPASI)
	SC	/HOST: /
	LHI	R3,HST0			:get kernel host number		###wjl
	JAL	R9,TYP5DD,,		:type it in decimal		###CWC
	JALMAC(TYPASI)
	SC	/TIME: /
	JAL	R9,GMTCAL,,
	L	R2,GMTNOW,,
	JAL	R9,GMTCNV,,

XNRPRT	LA	R2,ASPRMT		:TYPE PROMPT
	JAL	R7,TYPASC,,
	LIS	R0,0
	ST	R0,XPRTTP,XD		:RESTORE NORMAL PROMPT

:	MAIN COMMAND LOOP - XRAY LOOPS HERE UNTIL IT RECEIVES A
:	COMMAND TO EXECUTE OR IS RESTARTED

XLOOP	HS	0
	IF	1-ISIS
	IF	ZITEL
	LHL	R1,TRCFLG,,		:is there MAC trace data waiting?
	JN	XTRDSP			:output trace data to user
XLOOPM	HS	0
	EI	:ZITEL
	LA	R1,TRPFLG-2
	SVC	0F,SV.RAB
	NI	R1,0FFFF
	LR	R4,R1
	ELSE	:NOT SOLO (1-ISIS)
	IF	(XRSZLV-2)		:##AL
	LHL	R4,TRPFLG,,		:HAVE ANY TRAPS COME IN?
	EI	:(XRSZLV-2)		:##AL
	EI	:1-ISIS
	IF	(XRSZLV-2)		:##AL
	JN	TRPDOR			:YES, DISPLAY TRAPS
	EI	:(XRSZLV-2)		:##AL

XLOOP0	HS	0
	IF	(XRSZLV-1)		:##AL
	LHL	0,CRYPRI		:TEST FOR CRYPTO...GET IN-POINTER
	CI	XD,TTYXD		:TTY USER?
	JNFS	XLOOPZ			:NO
	LHL	R2,XBREAK,,		:YES, IS CRYPTO SUSPENDED DUE TO BREAK?
	JNFS	XLOOPY			:YES, SUPPRESS CRYPTO
XLOOPZ	LHL	R1,CRYMOD,XD		:ARE WE AUTOMATICALLY DISPLAYING?
	JEFS	XLOOPA			:YES
XLOOPY	STH	R0,CRYPTU,XD		:NO, DON'T LET THEM PILE UP
	IF	(XRSZLV-2)		:##AL
	IF	PRIMSG
	LHL	R2,CRYPPI		:TEST FOR CRYPTO...GET IN-POINTER##al
	STH	R2,CRYPPU,XD		:NO PILE UP			###AL
	EI	:PRIMSG
	EI	:(XRSZLV-2)		:##AL

XLOOPA	CLH	R0,CRYPTU,XD		:ANY CRYPTO MESSAGES?
	JE	XLOOP2			:NONE CAME IN
	JAL	R7,TYPCRL,,		:LOOK PRETTY
	LCS	R14,4			:OUTPUT MESSAGES ONE AT A TIME
	LCS	R12,1			:ENABLE ALL MESSAGES
	JAL	R8,XCRYPT		:OUTPUT CRYPTO MESSAGES
	CI	XD,TTYXD		:TTY USER?
	JE	XLOOP3			:YES
	LHL	R0,CRYPTU,XD		:REMOTE USER...
	CLH	R0,CRYPRI		:HAVE WE TYPED ALL MESSAGES?
	JEFS	XLOOP3			:YES
	TS	XRYRUN			:NO, RESCHEDULE IN 1 SECOND
	LHL	R0,XUSLTN,XD		:GET THIS USER'S SLOT #
	SBT	R0,XQUEM,,		:SET THIS USER IN MASTER QUEUE

XLOOP3	LA	R2,ASPRMT
	JAL	R7,TYPASC,,		:TYPE PROMPT
	EI	:(XRSZLV-1)		:##AL

XLOOP2	HS	0
     IF  0      :don't auto print crypto priority log since anything in
                :priority log is also in the normal log so why do it twice?
                :###sdw
	IF	(XRSZLV-2)		:##AL
	IF	PRIMSG
	LHL	R1,CRYPPI		:TEST FOR CRYPTO...GET IN-POINTER##al
	CLH	R1,CRYPPU,XD		:ANY CRYPTO PRIORITY MSG?	###AL
	JE	XLP2			:NONE				###AL
	JAL	R7,TYPCRL,,		:LOOK PRETTY
	LCS	R14,4			:OUTPUT MESSAGES ONE AT A TIME
	LCS	R12,1			:ENABLE ALL MESSAGES
	JAL	R8,XCRPPT		:OUTPUT priority CRYPTO MESSAGES###al
	CI	XD,TTYXD		:TTY USER?
	JE	XLP3			:YES
	LHL	R0,CRYPPU,XD		:REMOTE USER...			###al
	CLH	R0,CRYPPI		:HAVE WE TYPED ALL priority msgs?##al
	JEFS	XLP3			:YES
	TS	XRYRUN			:NO, RESCHEDULE IN 1 SECOND
	LHL	R0,XUSLTN,XD		:GET THIS USER'S SLOT #
	SBT	R0,XQUEM,,		:SET THIS USER IN MASTER QUEUE

XLP3	LA	R2,ASPRMT
	JAL	R7,TYPASC,,		:TYPE PROMPT
XLP2	HS	0
	EI	:PRIMSG
	EI	:(XRSZLV-2)		:##AL
      EI  :0 no auto print crypto log   ###sdw
	IF	1-ISIS			:ON A SOLO MACHINE THE PRIVILEGED CODE
	LA	R1,ANHALT-2
	SVC	0F,SV.RAB
	LHR	R1,R1
	JG	XERINT			:IF IT HAS HALTED THE NODE CODE
	EI	:1-ISIS

	JAL	R13,XRYTST,,		:IS THERE DATA IN TTY BUFF?
	JFS	XRYGET			:YES, GET COMMAND AND ARGUMENTS

XLOOP1	HS	0
	CI	XD,TTYXD		:TTY USER?
	JNFS	XLOOP4			:NO
	IF	ISIS
	SVC	DISMIS,1		:ISIS DISMISS FOR 1 SEC
	ELSE	:NOT ISIS
	SVC	0F,SV.DSM		:SOLO DISMISS TO CONTEXT SWITCHER
	EI	:ISIS
	J	XLOOP			:REPEAT WHEN RESCHEDULED
XLOOP4	JAL	R0,XRYDIS		:REMOTE DISMISS
	J	XLOOP

XRYGET	JAL	R9,RDCOMD,,		:RETURNS COMMAND IN R0		###jhl

COMDSP	HS	0
	LH	R5,XPOWER,XD		:THIS USER'S ACCESS POWER	###TZ
	LHI	R14,XNCMND*8
COMDS1	SIS	R14,8
	JL	COMECR
	LHL	R2,COMTBL,R14		:IS THIS THE COMMAND?
	CR	R0,R2
	JNBS	COMDS1			:NO, TRY NEXT ONE
:	GOT THE RIGHT COMMAND
	LR	R5,R5			:SUPER POWER?			###TZ
	JLFS	COMDS6			:YES, USER CAN DO ANYTHING	###TZ
	CLH	R5,COMTBL+6,R14		:IS THIS USER AUTHORIZED?
	JG	XPWERR			:NO, TELL HIM SO
COMDS6	LIS	R5,0E			:TEST '2' BIT			###TZ
	TBT	R5,COMTBL+4,R14		:AUDIT TYPE COMMAND?
	JE	XAUSKP			:NO, SKIP OVER

	IF	EXPSEC
	LHL	R8,XUNAME,XD		:GET USER'S INDEX INTO GGLIST
	L	R5,XRAYGG+XGGNAM+2,R8,	:GET CHARS 3,4,5,6 OF USERNAME
	ST	R5,CRYSBF		:FOR CRYPTO MESSAGE
	EXHR	R0,R0			:MOVE COMMAND TYPE TO HO HW
	LHL	R5,XRAYGG+XGGNAM,R8,	:AND COMBINE
	AR	R0,R5			:WITH CHARS 1,2 OF USERNAME
	EI	:EXPSEC

	JAL	R8,CRYPTO,,		:R0 CONVENIENTLY HOLDS THE COMMAND
	HC	CRYE54			:TYPE = COMMAND AUDIT
XAUSKP	HS	0
	LIS	R0,0			:assume regular prompt
	LIS	R5,0D			:test '4' bit
	TBT	R5,COMTBL+4,R14
	JEFS	COMDS5
	LI	R0,XEXPRT		:expanded prompt
COMDS5	HS	0
	ST	R0,XPRTTP,XD		:end of command return address
	CLHI	R1,ASCCR+80		:DID USER CLOSE WITH <CR>?
	JE	COMDS3			:YES, PRESUME HE KNOWS WHAT HE DO
	LIS	R5,0F			:TEST '1' BIT
	TBT	R5,COMTBL+4,R14		:DEFAULT ARGUMENT CALL?
	JN	COMDS2			:NO, COMMAND WILL READ ITS OWN ARGS
	JAL	R9,RDARGS,,		:YES, READ THE ARGUMENTS	###jhl
COMDS3	LR	R8,R1			:SAVE LAST CHAR THAT USER TYPED
	JAL	R7,TYPCRL,,		:TYPE CR-LF
	LR	R1,R8			:RECOVER LAST CHAR USER TYPED
COMDS2	LHL	R14,COMTBL+2,R14	:GET THE ADDRESS
	J	SEGD,R14,,		:AND DISPATCH

XPWERR	JAL	R13,XRYIN,,		:WAIT FOR CR
	NHI	R1,ASC7BT		:mask to seven bits
	SIS	R1,ASCCR		:is it a <cr>?
	JNBS	XPWERR
XPWER1	HS	0		:ENTRY POINT THAT DOESN'T WAIT FOR CR###OAS
	LA	R2,ASPWER		:INFORM USER
	JAL	R7,TYPASC,,
	J	COMCLR			:AND RETURN TO TOP

XCOMIU	LA	R2,ASCOMU		:COMMAND IN USE
	JAL	R7,TYPASC,,
	J	COMCLR

COMECR	JAL	R13,XRYIN,,		:WAIT FOR <CR> TO INDICATE TERMINATION
	NHI	R1,ASC7BT		:STRIP OFF HOB
	SIS	R1,ASCCR		:CR?
	JNBS	COMECR			:NO,KEEP LOOPING
COMERR	LA	R2,ASC02		:INVALID COMMAND, TYPE ??
	JAL	R7,TYPASC,,
	J	XRCRLF,,			

:	SOLO CODE JUMPS HERE ON MAC OR ILLEGAL INSTRUCTION CAUSED IN XRAY
:	note error to TTY port and dismiss local XRAY

XERROR	HS	0
	LI	XD,TTYXD		:set up for TTY user
	LA	2,ASCXER		:point to string "XRAY ERROR"
	JAL	7,TYPASC,,		:output to user
	L	R3,CRSHAD,,		:get the crash address		###jhl
	JAL	R9,TYPFW,,		:and output to local user	###jhl
	J	XRPRMT

	SUBTTL	XRAY (Read, Write - WM, W , WF, RG, RA, WA, R , CB)

	IF	XRYMES			:IF XRAY MESSAGE PROVIDED IN TYMFILE
					:FILL IN CONFIGURED MESSAGE
XWMSGB	XRYMS0				:(SEE XRYMSG/XRYMS0 MACROS)
	ELSE	:XRYMES			:ELSE, NO MESSAGE PROVIDED IN TYMFILE
XWMSGB	BS	1
	BC	0D,0A			:LEADING CR/LF
	EI	:XRYMES

	ORG	XWMSGB+47		:LEAVE 44 FOR MESSAGE BUFFER
XWMSGT	WS	1			:XRAY WARNING MESSAGE TIME
XWMCIU	HS	1			:COMMAND IN USE FLAG

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	XWRMSG:	WM
::	FUNCTION:	XRAY WARNING MESSAGE
::	INPUT:		WM<cr> - PROMPTS FOR MESSAGE
::			WM1 - DISPLAYS WARNING MESSAGE BUFFER
::			WM0 - ERASES WARNING MESSAGE BUFFER
::
::*********************************************************************

MXWMSG	EQ	40			:max warning msg length

	IF	2-XRYTMC		:###wjl

XWRMSG	HS	0
	JAL	R13,XRYIN,,
	CLHI	R1,ASCCR		:CARRIAGE RETURN?
	JN	XWRM00			:NO

	LB	R2,XWMSGB		:MAKE SURE BUFFER IS EMPTY
	JE	XWRM01			:OK

	JALMAC(TYPASI)
	SC	/"0D"0AMESSAGE BUFFER IN USE"0D"0A/
XWRM02	HS	0
	LB	R2,XWMSGB		:ANYTHING THERE?
	JE	XRPRMT
	JAL	R5,XWMDIS
	J	XRPRMT

	EI	:2-XRYTMC ###wjl

XWMDIS	HS	0
	LA	R2,XWMSGB
	JALMAC(TYPASC)			:DISPLAY CURRENT MESSAGE
	JALMAC(TYPASI)
	SC	/"0D"0AMESSAGE ENTERED: /
	L	R2,XWMSGT		:AND MESSAGE TIME
	JEFS	XWMDS9
	ST	R2,GMTNOW,,
	JAL	R9,GMTCNV,,		:###jhl
	JR	R5
XWMDS9	JALMAC(TYPASI)		:INDICATE MESSAGE ENTERED AT ASSEMBLY TIME
	SC	/AT ASSEMBLY TIME/
	JR	R5

	IF	2-XRYTMC		:###wjl

XWRM00	HS	0		:USER WANTS TO DISPLAY OR CLEAR MESSAGE BUFFER
	NHI	R1,ASC7BT		:STRIP PARITY
	CLHI	R1,ASCONE		:'1' = DISPLAY MESSAGE?
	JE	XWRM02			:YES

	CLHI	R1,ASCZRO		:'0' = CLEAR MESSAGE BUFFER?
	JN	COMERR

XWRM03	HS	0
	LIS	R1,0			:ZERO OUT MESSAGE BUFFER COUNT
	STB	R1,XWMSGB
	JALMAC(TYPASI)
	SC	/"0D"0AMESSAGE BUFFER CLEARED"0D"0A/
	J	XRPRMT

XWRM01	HS	0
	LHL	R2,XWMCIU
	JE	XWRM11
	JALMAC(TYPASI)
	SC	/"0D"0ABUSY"0D"0A/
	J	XRPRMT
XWRM11	HS	0
	STH	XD,XWMCIU
	JALMAC(TYPASI)
	SC	/"0D"0AENTER MESSAGE (<60 BYTES):"0D"0A/
	LIS	R5,2			:INIT MESSAGE LENGTH COUNT
XWRM10	JAL	R13,XRYIN,,
	NHI	R1,ASC7BT		:STRIP PARITY
	CLHI	R1,ASCCR		:<CR>?
	JE	XWRM04			:YES

	CLHI	R5,40
	JLE	XWRM12

	JALMAC(TYPASI)
	SC	/"0D"0AMESSAGE TOO LONG - TYPE <CR>"0D"0A/
	J	XWRM10

XWRM12	HS	0
	STB	R1,XWMSGB+3,R5		:STORE CHAR. IN MESSAGE BUFFER
	AIS	R5,1			:INC. MSG LENGTH COUNT
	J	XWRM10

XWRM04	HS	0
	CLHI	R5,MXWMSG
	JLEFS	XWRM41
	LIS	R1,0
	STH	R1,XWMCIU
	J	XWRM03

XWRM41	HS	0
	LIS	R1,0D
	STB	R1,XWMSGB+3,R5
	LIS	R1,0A
	STB	R1,XWMSGB+4,R5
	AIS	R5,2
	STB	R5,XWMSGB

	JAL	R9,GMTCAL,,
	L	R2,GMTNOW,,
	ST	R2,XWMSGT

	LIS	R0,0
	STH	R0,XWMCIU

	J	XRPRMT

	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	WRITE:	W
::	FUNCTION:	SIMILAR TO OPEN
::	INPUT:		VALUE1 = STARTING ADDRESS
::			VALUE1+4 = BYTE COUNT (OPTIONAL, DEFAULT = 2)
::
::*********************************************************************

WRITE	HS	0
	LHL	R2,ARGCT,XD
	JE	COMERR			:NO ZERO ARGUMENTS
	LIS	R12,0
	CLHI	R2,8
	JG	COMERR			:OR MORE THAN 2
	JL	WRITE5			:SINGLE ARGUMENT IS ADDRESS
	L	R12,VALUE1+4,XD		:SECOND VALUE IS COUNT

WRITE5	L	R11,VALUE1,XD		:ADDRESS
	THI	R11,1			:ONLY EVEN ADDRESSES
	JN	WRERR
WRITE4	LR	R3,R11
	JAL	R9,CHKMAC		:GET MAC APPROVAL
	J	CHKMA1			:ERROR IF IMMEDIATE RETURN
	JAL	R9,TYPADD,,		:TYP OUT ADDRESS
	LHL	R3,0,R11
	JAL	R9,TYPHW,,
	JAL	R9,RDARGS,,		:GET NEW VALUE
	CLHI	R2,4
	JG	COMERR			:0 OR 1 ARGUMENT ONLY
	JE	WRITE2			:1 ARG
	CLHI	R1,ASCBSL
	JE	WRITE3			: '\'
	CLHI	R1,ASCFSL		: '/'
	JEFS	WRITE3
	CLHI	R1,ASCCR
	JN	COMERR
	JAL	R7,TYPCRL,,		:A CR EXITS US
	J	XRPRMT
WRITE2	STH	R3,0,R11		:STORE THE VALUE
WRITE3	JAL	R7,TYPCRL,,		:CR-LF
	AIS	R11,2
	SIS	R12,2			:DECREMENT COUNT
	JG	WRITE4			:SOME LEFT
	J	XRPRMT

::*********************************************************************
::
::	COMMAND:	WRITEF:	WF
::	FUNCTION:	WRITES A FULLWORD INTO MEMORY
::			IDENTICAL TO WRITE EXCEPT THAT A FW IS WRITTEN
::
::*********************************************************************

WRITEF	HS	0
	LHL	R2,ARGCT,XD
	JE	COMERR			:NO ZERO ARGUMENTS
	LIS	R12,0
	CLHI	R2,8
	JG	COMERR			:OR MORE THAN 2
	JL	WRITF5			:SINGLE ARGUMENT IS ADDRESS
	L	R12,VALUE1+4,XD		:SECOND VALUE IS COUNT

WRITF5	L	R11,VALUE1,XD		:ADDRESS
	THI	R11,1			:ONLY EVEN ADDRESSES
	JN	WRERR
WRITF4	LR	R3,R11
	JAL	R9,CHKMAC		:GET MAC APPROVAL
	J	CHKMA1			:ERROR IF IMMEDIATE RETURN
	JAL	R9,TYPADD,,		:TYP OUT ADDRESS
	L	R3,0,R11	
	JAL	R9,TYPFW,,
	JAL	R9,RDARGS,,		:GET NEW VALUE IN R3
	CLHI	R2,4
	JG	COMERR			:0 OR 1 ARGUMENT ONLY
	JE	WRITF2			:1 ARG
	CLHI	R1,ASCBSL
	JE	WRITF3			: '\'
	CLHI	R1,ASCFSL		: '/'
	JEFS	WRITF3
	CLHI	R1,ASCCR
	JN	COMERR
	JAL	R7,TYPCRL,,		:A CR EXITS US
	J	XRPRMT
WRITF2	ST	R3,0,R11		:STORE THE VALUE
WRITF3	JAL	R7,TYPCRL,,		:CR-LF
	AIS	R11,4
	SIS	R12,4			:DECREMENT COUNT
	JG	WRITF4			:SOME LEFT
	J	XRPRMT

::*********************************************************************
::
::	COMMAND:	RDREGS:	RG
::	FUNCTION:	Read Register Set <n>
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl
	IF	1-ISIS

RDREGS	HS	0
	L	R0,VALUE1,XD		:GET REQUESTED REGISTER SET
	NHI	R0,0F			:CUT IT DOWN TO SIZE
	SVC	0F,SV.SAS		:WRITE CONTENTS TO ABSSAV
	JAL	R7,TYPCRL,,		:crlf for new line	###jhl
	LIS	R1,0			:storage area index
	LIS	R2,2			:print out 2 lines
	LIS	R10,8			:	of 8 regs each
RDRG50	L	R3,ABSSAV,R1,		:read the register
	STH	R1,XRSAVE,XD		:save index from TYPFW
	STH	R2,XRSAVE+4,XD		:save end marker from TYPFW
	JAL	R9,TYPFW,,		:output to the screen
	LH	R1,XRSAVE,XD		:restore index from TYPFW
	LH	R2,XRSAVE+4,XD		:restore end marker from TYPFW
	SIS	R10,1			:eight regs on this line yet?
	JG	RDRG55			:no crlf if not
	STH	R1,XRSAVE,XD
	JAL	R7,TYPCRL,,		:crlf for new line
	SIS	R2,1			:have we done 2 lines yet?
	JLE	RDRG57			:if yes, go on out of here
	LHL	R1,XRSAVE,XD		:restore register index
	LIS	R10,8			:restore line cursor
RDRG55	AIS	R1,4			:point to the next register
	J	RDRG50			:loop for next register
RDRG57	J	XRCRLF,,			:###jhl

	EI	:1-ISIS
	EI	:2-XRYTMC ###wjl

::*********************************************************************
::
::	COMMAND:	RDABS:	RA
::	FUNCTION:	Read and display specified number of bytes from
::			specified absolute memory location
::
::*********************************************************************

	IF	1-ISIS

	GL	ENDNOD
XRACIU	WS	1

	IF	2-XRYTMC		:###wjl

RDABS	HS	0
	LHI	R2,2*4			:only 2 arguments max
	STH	R2,ARGMAX,XD
	JAL	R9,RDARGS,,		:get the start address and byte count
	LHI	R11,10			:default to 16d bytes
	LHL	R2,ARGCT,XD		:number of arg's entered
	JE	COMERR,,			:must have at least 1

	L	R10,VALUE1,XD		:first arg is address
	THI	R10,1			:must be even
	JN	WRERR			:no good

	CLHI	R2,4			:second arg entered?
	JEFS	RDABS0			:no

	CLHI	R2,8			:more than 2 args entered?
	JN	COMERR,,			:yes, error

	L	R11,VALUE1+4,XD		:2nd arg is byte count

RDABS0	HS	0
	LHL	R2,XRACIU+2		:make sure command not in use
	JN	XCOMIU			:command in use, tell user

	ST	XD,XRACIU		:mark command in use
	JAL	R7,TYPCRL,,
RDABS5	HS	0
	CI	R10,ENDNOD-10		:###wjl
	JLFS	RDABS1			:ok

	LIS	R0,0
	ST	R0,XRACIU		:mark RA command no longer in use
	J	CHKMA1			:complain

RDABS1	HS	0
	LR	R3,R10			:address to R3
	JAL	R9,TYPADD,,		:TYP OUT ADDRESS
	LIS	R5,8			:8 HW's per line
RDABS2	HS	0
	LR	R1,R10
	SVC	0F,SV.RAB
	EXHR	R3,R1
	JAL	R9,TYPHW,,		:type it
	EXHR	R3,R3
	JAL	R9,TYPHW,,
	SIS	R11,4			:2 more bytes of requested number
	JLE	RDABS9			:done

RDABS3	HS	0	
	AIS	R10,4
	SIS	R5,2			:1 more HW done this line
	JG	RDABS2			:more for this line

	JAL	R7,TYPCRL,,		:next line
	J	RDABS5			:do next 10x bytes		###wjl

RDABS9	HS	0
	LIS	R0,0
	ST	R0,XRACIU		:mark RA command no longer in use
	J	XRCRLF			:done

	EI	:2-XRYTMC ###wjl
	EI	:1-ISIS

::*********************************************************************
::
::	COMMAND:	WFABS:	WA
::	FUNCTION:	Write FW to Absolute Memory
::
::*********************************************************************

	IF	1-ISIS

WFABS	HS	0
	LHL	R2,ARGCT,XD		:SINGLE ARGUMENT EXPECTED
	JE	COMERR
	CLHI	R2,4
	JG	COMERR,,
	
	L	R11,VALUE1,XD		:ADDRESS ARGUMENT
	THI	R11,1			:MUST BE EVEN
	JN	WRERR			:ELSE COMPLAIN
	
	CI	R11,ENDNOD-40		:CAN'T BE GREATER THAN AVAILABLE MEMORY
	JG	CHKMA1			:IF SO, COMPLAIN
	
	LR	R3,R11
	JAL	R9,TYPADD,,		:TYP OUT ADDRESS
	
	LR	R1,R11
	SVC	0F,SV.RAB

	LR	R3,R1
	JAL	R9,TYPFW,,
	
	JAL	R9,RDARGS,,		:GET VALUE INTO R3
	CLHI	R2,4
	JG	COMERR
	JE	WFABS1

	CLHI	R1,ASCCR		:<CR>?
	JN	COMERR,,
	
	JAL	R7,TYPCRL,,
	J	XRPRMT

WFABS1	HS	0
	SVC	0F,SV.WFA	:WRITE FW VALUE IN R3 INTO ABS ADDRESS IN R11
	J	XRPRMT
	EI	:1-ISIS
	EI	:(XRSZLV-2)		:##AL

	IF	(XRSZLV-1)		:##AL
WRERR	LA	R2,ASWRER		:THIS ENTRY MOVED TO THIS LEVEL
	JAL	R7,TYPASC,,
	J	XRPRMT
::*********************************************************************
::
::	COMMAND:	XTYPE:/TYPE:	R
::	FUNCTION:	TYPE BLOCK OF STORAGE AS 8 HW PER LINE
::			PRECEEDED BY ADDRESS
::	INPUT:		VALUE1=STARTING ADDRESS
::			VALUE1+4=BYTE COUNT (OPTIONAL,DEFAULT=16)
::
::*********************************************************************

XTYPE	HS	0
	LHI	R2,$A2*4		:2 ARGUMENTS MAX
	STH	R2,ARGMAX,XD		:TAKE 2 ARGUMENTS MAX
	JAL	R9,RDARGS,,

TYPE	HS	0
	JAL	R12,TYPE0
	J	XRCRLF

::*********************************************************************
::
::	SUBROUTINE:	TYPE0:
::	CALLING SEQ:	JAL	R12,TYPE0
::
::*********************************************************************

TYPE0	HS	0
	LHI	R11,10			:DEFAULT TO 16 BYTES
	LHL	R2,ARGCT,XD		:TAKES 0,1, OR 2 ARGUMENTS
	JE	TYPE1
	L	R0,VALUE1,XD		:FIRST ARGUMENT IS ADDRESS
	ST	R0,LASTCL
	CLHI	R2,4
	JEFS	TYPE1			:ONE ARGUMENT (ADDRESS)
	CLHI	R2,8
	JN	COMERR,,
	L	R11,VALUE1+4,XD		:SECOND ARG IS COUNT
TYPE1	L	R10,LASTCL
	THI	R10,1			:MUST BE EVEN ADDR
	JN	WRERR

	JAL	R7,TYPCRL,,

TYPE2	LR	R3,R10			:TYPE ADDRESS
	JAL	R9,TYPADD,,		:TYP OUT ADDRESS
	LIS	R5,8			:EIGHT HW PER LINE
TYPE5	LR	R3,R10
	JAL	R9,CHKMAC
	J	CHKMA1			:ADDRESS OUT OF RANGE, REJECT!
	LHL	R3,0,R10		:TYPE H-WORD
	IF	WHEREE
	JAL	R9,TYPHWD,,
	ELSE
	JAL	R9,TYPHW,,
	EI	:WHEREE
	AIS	R10,2
	SIS	R11,2			:DECREMENT BYTE COUNT
	JLE	TYPE3			:ALL DONE
	SIS	R5,1
	JG	TYPE5			:NOT DONE WITH PRESENT LINE YET
	JAL	R7,TYPCRL,,		:DONE WITH THIS LINE - TYPE CR-LF

	J	TYPE2			:AND MOVE ON TO NEXT LINE

TYPE3	ST	R10,LASTCL
	JR	R12			:RETURN
	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	CHNBFL:	CB
::	FUNCTION:	Chain Through Bufferlets
::			Type as 8 HW Line Preceeded by	Address	 ###wjl
::
::*********************************************************************

CHNBFL	HS	0
	LHI	R2,$A2*4		:2 ARGUMENTS
	STH	R2,ARGMAX,XD		:MAXIMUM
	JAL	R9,RDARGS,,		:GO READ ARGUMENTS
	LHL	R2,ARGCT,XD		:TAKES 2 ARGUMENTS
	CLHI	R2,8			:CHECK FOR THEM
	JN	COMERR			:IF NOT GO TYPE ??
	L	R10,VALUE1,XD		:FIRST ARGUMENT IS BUFFERLET NUMBER
	SLLS	R10,CBSZL		:CALCULATE BUFFERLET
	AI	R10,CHRBUF		:ADDRESS
	L	R11,VALUE1+4,XD		:2ND ARG IS CNT OF BFFRLTS TO BE CHND
	JAL	R7,TYPCRL,,		:GO TYPE CR/LF
CHNBF2	LR	R3,R10			:(TYPADD NEEDS ADDRESS IN R3)
	JAL	R9,TYPADD,,		:GO TYPE BUFFERLET ADDRESS
	LIS	R5,8			:8 HW/LINE
CHNBF4	LR	R3,R10			:(CHKMAC NEEDS ADDRESS IN R3, TOO)
	JAL	R9,CHKMAC		:SKIP RETURN IF ADDRESS IS OK
	J	CHKMA1			:ADDRESS OUT OF RANGE!  ERROR MESSAGE
	LHL	R3,0,R10		:(TYPHW NEEDS HW IN R3)
	JAL	R9,TYPHW,,		:GO TYPE H-WORD
	AIS	R10,2			:INCREMENT ADDRESS
	SIS	R5,1			:DECREMENT H-WORD COUNT
	JG	CHNBF4			:NOT DONE WITH PRESENT LINE YET
	JAL	R7,TYPCRL,,		:DONE WITH THIS LINE - GO TYPE CR/LF
	SIS	R11,1			:DECREMENT COUNT OF BUFFERLETS
	JLE	XRCRLF			:ALL DONE - RETURN WITH CR/LF

	LR	R10,R3			:CALCULATE NEXT BUFFERLET ADDRESS
	SLLS	R10,CBSZL		:FROM BUFFERLET NUMBER
	AI	R10,CHRBUF		:IN LAST HW
	J	CHNBF2			:AND MOVE ON TO NEXT LINE

	EI	:(XRSZLV-2)		:##AL

::*********************************************************************
::
::	SUBROUTINE:	CHKMAC:
::	FUNCTION:	CHECK WITH MAC BEFORE DOING MEMORY REFERENCE
::	CALLING SEQ:	JAL	R9,CHKMAC
::	INPUT:		R3 =	POTENTIAL ADDRESS
::	DESTROYED:	R0, R4
::	RETURNS:	SKIP RETURNS IF ADDRESS IS OK, ELSE DIRECT RETURN
::
::*********************************************************************

CHKMAC	HS	0
	LR	R4,R3			:move address to work register
	EXHR	R4,R4			:exchange seg # and seg offset hw's
	NI	R4,0FFFF		:ISOLATE SEGMENT NUMBER
	CLHI	R4,0F			:MAX SEG. NUMBER IS 15
	JGR	R9			:straight (error) return if TOO BIG
	LR	R0,R3			:move address to work register
	NI	R0,0FFFF		:ISOLATE PAGE NUMBER
	SLLS	R4,2			:FORM FW OFFSET
	C	R0,CHKDAT,R4,		:COMPARE AGAINST ALLOWABLE SEG. SIZE
	JLE	4,R9			:skip return if ADDRESS IS OK
	JR	R9			:straight return if ADDRESS IS NOT OK

CHKMA1	LA	R2,ASMCER
	JAL	R7,TYPASC,,		:TYPE OUT ERROR MESSAGE
	J	XPRMPT,,

	SUBTTL	XRAY (PVC ports status - PV)

::*********************************************************************
::
::	COMMAND:	PVXRAY:	PV
::	FUNCTION:	RETRIEVE AND DISPLAY PVC PARAMTERS FOR ALL OR SPECIFIED
::	PVC PORTS. 3 HW'S EACH ENTRY = 1ST IS 1-VALUE PARAMETER
::					2ND IS LABEL IF 0
::					3RD IS LABEL IF 1
::*********************************************************************

	IF	2-XRYTMC		:###wjl
	IF	PVC
	LO	PVC
PVXRAY	HS	0
 	LR	R2,R2			:NO. ARG'S
	JE	PVXRA3			:IS 0
	L	R3,VALUE1,XD		:GET ARG IN OCTAL
	JAL	R9,OCTHXR,,		:CONVERT TO HEX IN R3
	CHI	R3,NPORT-1		:VALID PORT NO.?
	JG	COMERRS			:NO
	TBT	R3,PVCARY,,		:PVC PORT?
	JE	COMERR			:NO
	LR	PN,R3			:SET UP PN
	JAL	R8,PVXDIS		:GO DISPLAY PARAMS
	J	XPRMPT			:ALL DONE
PVXRA3	LIS	R12,0			:TO KEEP TRACK OF NO. OF GROUPS
PVXRA2	L	R10,PVCARY,R12,		:GET THE BIT ARRAY FOR PVC PORTS
PVXRA0	JFFO	R10,PVXRA1		:FIND NO. OF 1ST PVC PORT
	AIS	R12,4			:NO MORE IN THIS GROUP SO CHECK NEXT
	CHI	R12,(NPORT+1F)/20*4	:IS THERE A NEXT GROUP?
	JLBS	PVXRA2			:YES, GO GET IT
	J	XPRMPT			:ALL DONE
PVXRA1	LR	PN,R11			:PORT NO. FOR PVXDIS
	LR	R0,R12			:copy R12 to work with it
	ST	R12,XRSAVE+4,XD		:preserve R12--word index
	ST	R10,XRSAVE,XD		:preserve R10--service-bit array
	RBT	R11,XRSAVE,XD		:service each port only once
	SLLS	R0,3			:convert 4 bytes to 32 bits
	AR	PN,R0			:set up PN(R14) with port number
	JAL	R8,PVXDIS		:GO DISPLAY PARAMETERS
	L	R10,XRSAVE,XD		:restore R10
	L	R12,XRSAVE+4,XD		:restore R12
	J	PVXRA0			:NEXT PVC PORT

::*********************************************************************
::
::	SUBROUTINE:	PVXDIS:
::	FUNCTION:	ROUTINE TO DISPLAY PVC PARAMETERS
::	CALLING SEQ:	JAL	R8,PVXDIS
::
::*********************************************************************

PVXDIS	HS	0
	LA	R2,PTPORT		:'PORT'
	JAL	R7,TYPASC,,
	LR	R3,PN
	JAL	R9,TYPHWD,,		:PORT NO. IN DECIMAL
	LA	R2,PTLPRN		:'('
	JAL	R7,TYPASC,,
	LR	R3,PN
	JAL	R9,HEXOCT,,
	JAL	R9,TYPHNS,,		:PORT NO. IN OCTAL
	LA	R2,PTRPRN		:')'
	JAL	R7,TYPASC,,
:	get PVC parameters for port no. PN
:	Maybe this should be a subroutine in ASYNC ###jhl
	LHL	R12,.PTP.,PN,PN		:read HW offset
	AI	R12,PTBASE		:add in the base offset
	L	R3,.PVCX,R12		:pick up the PVC flag word
	LR	R5,R3			:R5 FOR TESTS BELOW-R3 W/B CREMATED
	THI	R3,POAID		:TEST FOR AID BIT
	JE	PVXD10			:NO AID
	LA	R2,PTAID		:'AID  TID'
	JAL	R7,TYPASC,,		:DISPLAY
	SRL	R3,TS			:EXTRACT TID (leftmost 8 bits)
	CLHI	R3,18		:TID's greater than 18x added later - don't
	JGFS	PVXD20		: conform to original numbering scheme###wjl
	JAL	R9,HEXOCT,,		:CONVERT TO OCTAL
	JAL	R9,TYPBYT,,		:DISPLAY
	JFS	PVXD20
PVXD10	LA	R2,PTNAID		:'NOAID		'
	JAL	R7,TYPASC,,		:DISPLAY
PVXD20	THI	R5,POALO		:TEST FOR ALO BIT
	JE	PVXD30			:NOALO
	LA	R2,PTALO		:'ALO'
	JAL	R7,TYPASC,,		:DISPLAY
	THI	R5,POPCO		:PCO OR SLO?
	JEFS	PVXD22			:NOT PCO, M/B SLO
	LA	R2,PTPCO		:'PCO'
	JFS	PVXD24
PVXD22	LA	R2,PTSLO		:'SLO'
PVXD24	JAL	R7,TYPASC,,		:DISPLAY
PVXD30	JAL	R7,TYPCRL,,		:DO IT
	JAL	R7,TYP2SP,,		:INDENT 2 SPACES

	LIS	R6,0			:INITIAL TABLE INDEX
PVXD40	LH	R3,PVXDTB,R6		:GET PARM MASK
	JL	PVXD46			:FINISH WITH A CRLF
	NR	R3,R5			:TEST BIT IN PARAM ARRAY
	JEFS	PVXD42			:BIT WAS 0
	LIS	R4,4			:BIT WAS 1 - 2ND HW
	JFS	PVXD44
PVXD42	LIS	R4,2			:BIT WAS 0 - 1ST HW
PVXD44	LA	R2,PVXDTB		:BEGINNING OF TABLE
	LHL	R3,PVXDTB,R6,R4		:DISPLACEMENT OF LABEL FROM PVXDTB+2
	AR	R2,R3			:ADDRESS OF LABEL IN R2
	JAL	R7,TYPASC,,		:TYP LABEL
	AIS	R6,6			:INCR TABLE INDEX
	J	PVXD40

PVXD46	CLHI	PN,.MPORT		:check for MPVC pseudo port
	JLFS	PVXD48			:if not, just get out
	LA	R2,PTPSDO		:point to MPPSD string
	JAL	R7,TYPASC,,
	JFS	PVXD4A
PVXD48	LR	R3,R5			:get the .PVCX word
	SRL	R3,TS			:right align the TID field
TLXID	EQ	1F			:value set up in PVC parameters
	CLHI	R3,TLXID		:kluge, but no other way to check
	JNFS	PVXD4A			:no match--we've said all we can
	LA	R2,PTTLX		:match means its TELEX port
	JAL	R7,TYPASC,,		:so tell the user
PVXD4A	JAL	R7,TYPCRL,,		:new line--clobbers R13 and R1
	JR	R8			:return above

::*********************************************************************
::
::	TABLE:		PVXDTB:
::	FUNCTION:	PVC PARAMETER LABELS
::
::*********************************************************************

PVXDTB	HS	0			:TABLE FOR PARAMETER LABELS
Q	EQ	.			:BEGINNING OF TABLE
	HC	PONPI,PTNPI-Q,PTNNPI-Q	:PRINT N/P ID FOR ALO
	HC	POPAR,PTNPAR-Q,PTPAR-Q	:PARITY
	HC	POHNG,PTHNG-Q,PTNHNG-Q	:HANG ON TIMEOUT
	HC	POHDX,PTNHDX-Q,PTHDX-Q	:HALF DUPLEX
	HC	POCRLF,PTCRL-Q,PTNCRL-Q	:CR ECHO WITH LF
	HC	POLFCR,PTLFC-Q,PTNLFC-Q	:LF ECHO WITH CR
	HC	POTRS,PTNTRS-Q,PTTRS-Q	:RESET TERMINAL OPTIONS
	HC	PORBP,PTNRBP-Q,PTRBP-Q	:REVERSE BACKPRESSURE
	HC	POMPC,PTNMPC-Q,PTMPC-Q	:MPVC SUBPORT CANDIDATE
:	HC	POTLX,PTNTLX-Q,PTTLX-Q	:TELEX PORT (bit unused###jhl)
	HC	-1			:END OF TABLE

PTNPI	SC	/"A0"A0NPI/
PTNNPI	SC	/NONPI/
PTNPAR	SC	/"A0"A0NOPAR/
PTPAR	SC	/"A0"A0"A0"A0PAR/
PTHNG	SC	/"A0"A0"A0"A0HNG/
PTNHNG	SC	/"A0"A0NOHNG/
PTNHDX	SC	/"A0"A0NOHDX/
PTHDX	SC	/"A0"A0"A0"A0HDX/
PTCRL	SC	/"A0"A0"A0"A0CRLF/
PTNCRL	SC	/"A0"A0NOCRLF/
PTLFC	SC	/"A0"A0"A0"A0LFCR/
PTNLFC	SC	/"A0"A0NOLFCR/
PTNTRS	SC	/"A0"A0NOTRS/
PTTRS	SC	/"A0"A0"A0"A0TRS/
PTNRBP	SC	/"A0"A0NORBP/
PTRBP	SC	/"A0"A0"A0"A0RBP/
PTPORT	SC	/PORT"A0/
PTLPRN	SC	/(/
PTRPRN	SC	/)/
PTAID	SC	/"A0"A0"A0"A0AID"A0"A0TID/
PTNAID	SC	/"A0"A0NOAID/
PTALO	SC	/"A0"A0"A0"A0ALO/
PTNALO	SC	/"A0"A0NOALO/
PTPCO	SC	/"A0"A0PCO/
PTSLO	SC	/"A0"A0SLO/
PTMPC	SC	/"A0"A0MPVC/
PTNMPC	SC	/"A0/
PTTLX	SC	/"A0TELEX/
PTNTLX	SC	/"A0/
PTPSDO	SC	/MPPSD/

	FO	PVC
	EI	:PVC
	EI	:2-XRYTMC ###wjl

	SUBTTL	XRAY (SIO ring commands - SP, SR)

::*********************************************************************
::
::	COMMAND:	XSSRN:	SP
::	FUNCTION:	SIO RING TRACE
::	INPUT:		SP [ REL SUP PORT ] [ TRACE OR PRINT ENABLE/DISABLE ] 
::	PERFORM SUPERVISOR PORT DATA TRACE.  WITH NO ARGUMENTS
::	TRACING IS DISABLED AND THE TRACE TABLE IS DISPLAYED IN IT'S
::	ENTIRETY OR UP TO THE FIRST ENTRY.  WITH NO ARGUMENTS, AND CLOSING
::	WITH AN I, DISABLES TRACING AND CLEARS THE TRACE TABLE.
::	WITH NO ARGUMENTS AND CLOSING WITH AN R, TRACE PRINTING
::	IS DISABLED FOR ALL CHANNELS.  WITH NO ARGUMENTS AND CLOSING WITH
::	A P, TRACE PRINTING IS ENABLED FOR ALL CHANNELS.  WITH NO
::	ARGUMENTS AND CLOSING WITH AN X, TRACING IS DISABLED AND
::	ONLY DATA TO SUP IS DISPLAYED.  WITH NO ARGUMENTS AND CLOSING
::	WITH A V, TRACING IS DISABLED AND ONLY DATA FROM SUP IS DISPLAYED.
::
::	SP 0 N/S (CHAN 0 TRACE ENABLE/DISABLE)
::	SP 1 P/R (CHAN 1 TRACE PRINT ENABLE/DISABLE)
::	SP 8     (CHAN 8 TRACE/PRINT STATUS DISPLAY)
::	SP       (DISABLE TRACING AND DISPLAY TRACE TABLE)
::	TABLE ENTRIES ARE DISPLAYED WITH THE LATEST ENTRY FIRST.
::	SP I     (DISABLE TRACING AND CLEAR TRACE TABLE)
::	SP R     (DISABLE TRACE PRINTING FOR ALL CHANNELS)
::	SP P     (ENABLE TRACE PRINTING FOR ALL CHANNELS)
::	SP X     (DISABLE TRACING AND DISPLAY TO SUP TRACE DATA)
::	SP V     (DISABLE TRACING AND DISPLAY FROM SUP TRACE DATA)
::
::*********************************************************************

	IF	SIORNG
	IF	SNRING
	IF	SUPTRC

XSRNH1	SC	/"0D"0ASUPERVISOR RING TRACE"0D"0A/
XSRNH2	SC	/"0D"0ATIME  CHAN DIRECTION  COUNT     DATA"0D"0A/
XSRNH5	SC	/----  ---- ---------  ----- ------------------------------------------------/
XSRNH6	SC	/                            /
XSRNH3	SC	/FROM SUP  /
XSRNH4	SC	/TO SUP    /
XSRNH7	SC	/"0D"0ASUPERVISOR TRACE DISABLED AND TABLE CLEARED"0D"0A/
XSRNJ3	SC	/"0D"0ASUP TRACE PRINTING DISABLED FOR ALL CHANNELS"0D"0A/
XSRNJ4	SC	/"0D"0ASUP TRACE PRINTING ENABLED FOR ALL CHANNELS"0D"0A/
XSRNH8	SC	/"0D"0ASUP PORT - /
XSRNJ5	SC	/,  TRACE - /
XSRNH9	SC	/ENABLED /
XSRNJ1	SC	/DISABLED /
XSRNJ2	SC	/, TRACE PRINT - /
XSRNZ1	SC	/ALL FROM SUP MESSAGE TYPES DISABLED FOR TRACING/
XSRNZ2	SC	/ALL TO SUP MESSAGE TYPES DISABLED FOR TRACING/
XSRNZ3	SC	/ALL FROM SUP MESSAGE TYPES ENABLED FOR TRACING/
XSRNZ4	SC	/ALL TO SUP MESSAGE TYPES ENABLED FOR TRACING/
XSRNZ5	SC	/SPECIFIED FROM SUP MESSAGE TYPE ENABLED FOR TRACING/
XSRNZ6	SC	/SPECIFIED TO SUP MESSAGE TYPE ENABLED FOR TRACING/

XSSRN	HS	0
	LH	R0,SRNSEC,,
	JE	COMERR
	LHL	R2,ARGCT,XD		:GET ARG CNT*4
	SIS	R2,4
	JL	XSRNDP			:NO ARGS, DISPLAY TRACE TABLE
	JG	COMERR			:MORE THAN 1 ARG, ERROR
	LHL	R14,VALUE1+2,XD		:GET ARGUMENT
	JL	COMERR			:BAD CHANNEL
	CLHI	R14,NSP			:WITHIN SUP PORT RANGE ?
	JGE	COMERR			:BAD CHANNEL

	CLHI	R1,4D			:CLOSE WITH AN M ?
	JE	XSRZ30			:YES, ENABLE TRACE OF FROM SUP MSG TYPE
	CLHI	R1,57			:CLOSE WITH A W ?
	JE	XSRZ80			:YES, ENABLE TRACE OF TO SUP MSG TYPE
	CLHI	R1,53			:CLOSE WITH AN S ?
	JNFS	XSRN01			:NO
	RBT	R14,SRNTRE,,		:DISABLE TRACE
	J	XSRN04			:DISPLAY STATUS
XSRN01	CLHI	R1,4E			:CLOSE WITH AN N ?
	JNFS	XSRN02			:NO
	SBT	R14,SRNTRE,,		:ENABLE TRACE
	J	XSRN04			:DISPLAY STATUS
XSRN02	CLHI	R1,52			:CLOSE WITH R ?
	JNFS	XSRN03			:NO
	SBT	R14,SRNTRP,,		:DISABLE PRINT
	JFS	XSRN04			:DISPLAY STATUS
XSRN03	CLHI	R1,50			:CLOSE WITH P ?
	JNFS	XSRN04			:NO
	RBT	R14,SRNTRP,,		:ENABLE PRINT

XSRN04	LA	R2,XSRNH8		:DISPLAY TRACE/PRINT STATUS
	JAL	R7,TYPASC,,
	LR	R3,R14			:GET CHANNEL NUMBER FOR DISPLAY
	JAL	R9,TYPHW,,
	LA	R2,XSRNJ5
	JAL	R7,TYPASC,,
	TBT	R14,SRNTRE,,		:TRACE ENABLED ?
	JEFS	XSRN05			:NO
	LA	R2,XSRNH9		:ENABLED BANNER
	JFS	XSRN06
XSRN05	LA	R2,XSRNJ1		:DISABLED BANNER
XSRN06	JAL	R7,TYPASC,,
	LA	R2,XSRNJ2		:TRACE PRINT BANNER
	JAL	R7,TYPASC,,
	TBT	R14,SRNTRP,,		:PRINT ENABLED
	JNFS	XSRN07			:NO
	LA	R2,XSRNH9		:ENABLED BANNER
	JFS	XSRN08
XSRN07	LA	R2,XSRNJ1		:DISABLED BANNER
XSRN08	JAL	R7,TYPASC,,
	JAL	R7,TYPCRL,,		:CR LF
	J	XPRMPT			:DONE

XSRNDP	CLHI	R1,49			:CLOSE WITH AN I ?
	JE	XSRN30			:YES, CLEAR TABLE
	CLHI	R1,4D			:CLOSE WITH AN M ?
	JE	XSRZ00			:YES, DISABLE ALL FROM SUP MSG TYPES
	CLHI	R1,57			:CLOSE WITH A W ?
	JE	XSRZ50			:YES, DISABLE ALL TO SUP MSG TYPES
	CLHI	R1,50			:CLOSE WITH A P ?
	JE	XSRN50			:YES, ENABLE ALL CHANNELS PRINTING
	CLHI	R1,52			:CLOSE WITH AN R ?
	JE	XSRN60			:YES, DISABLE ALL CHANNELS PRINTING

	LIS	R10,0			:ASSUME PRINT OF TO AND FROM SUP DATA
	CLHI	R1,58			:CLOSE WITH AN X ?
	JNFS	XSRN70			:NO
	LIS	R10,1			:ONLY DISPLAY TO SUP DATA
	JFS	XSRN71
XSRN70	CLHI	R1,56			:CLOSE WITH A V ?
	JNFS	XSRN71			:NO
	LCS	R10,1			:ONLY DISPLAY FROM SUP DATA

XSRN71	LA	R1,SRNTRE,,		:CLEAR TRACE ENABLE BITS
	LHI	R2,SRNBT1/2		:NUMBER OF HWS TO CLEAR
	JAL	R8,HCLEAR,,		:AND CLEAR
	LA	R2,XSRNH1		:BANNER
	JAL	R7,TYPASC,,
	LA	R2,XSRNH2		:BANNER
	JAL	R7,TYPASC,,
	LA	R2,XSRNH5		:BANNER
	JAL	R7,TYPASC,,

	LHL	R11,SRNTRX,,		:TRACE TABLE INDEX
XSRN10	SIS	R11,2			:BACKUP TO LAST TRACE RECORD
	JGEFS	XSRN11			:NO WRAP
	AHI	R11,SRNTSZ		:WRAP
XSRN11	LHL	R3,SRNTBL,R11,		:GET CHANNEL NUMBER
	LR	R12,R3			:SAVE CHANNEL #
	NHI	R3,7FFF			:STRIP HOB
	CLI	R3,NSP			:WITHIN SUP PORT RANGE ?
	JGE	XPRMPT			:NO, INVALID CHAN, DONE
	SIS	R11,2			:DECR TRACE TABLE INDEX
	JGEFS	XSRN12			:NO WRAP
	AHI	R11,SRNTSZ		:WRAP
XSRN12	LHL	R0,SRNTBL,R11,		:GET FASTC MARK TIME
	EXHR	R0,R0			:INTO HO HW OF R0
	SIS	R11,2			:DECR TRACE TABLE INDEX
	JGEFS	XSRNA0			:NO WRAP
	AHI	R11,SRNTSZ		:WRAP
XSRNA0	LHL	R14,SRNTBL,R11,		:GET LOG REC COUNT
	JLE	XPRMPT			:ZERO LENGTH RECORD, END OF TABLE, DONE
	CLHI	R14,255			:CHECK FOR VALID LRC
	JG	XPRMPT			:INVALID LRC, DONE

	OR	R14,R0			:COMBINE TIME AND LRC IN R14
	TBT	R3,SRNTRP,,		:CHECK IF TRACE DISPLAY ENABLED
	JN	XSRN40			:DON'T DISPLAY
	LR	R10,R10			:DATA DISPLAY ONE DIRECTION ONLY?
	JEFS	XSRN73			:NO
	JGFS	XSRN74			:LIMIT DISPLAY TO TO-SUP DATA
	THI	R12,8000		:DATA LIMITED TO FROM-SUP DATA
	JE	XSRN40			:THIS RECORD IS TO SUP, DON'T DISPLAY
	JFS	XSRN73			:DISPLAY
XSRN74	THI	R12,8000		:DATA LIMITED TO TO-SUP DATA
	JN	XSRN40			:THIS RECORD IT FROM-SUP, DON'T DISPLAY

XSRN73	JAL	R7,TYPCRL,,		:CR LF
	LI	R3,0FFFF0000		:MASK HO HW OF R14
	NR	R3,R14			:INTO R3
	EXHR	R3,R3			:LO HW
	JAL	R9,TYPHW,,		:AND DISPLAY FASTC MARK TIME
	NI	R14,0000FFFF		:STRIP R14 DOWN TO LO HW (LRC)
	LR	R3,R12			:RECOVER CHANNEL NUMBER
	NHI	R3,7FFF			:STRIP OFF DIRECTION BIT
	JAL	R9,TYPHW,,		:AND DISPLAY
	THI	R12,8000		:CHECK DATA DIRECTION
	JEFS	XSRN13			:INDICATE TO SUP DIRECTION
	LA	R2,XSRNH3		:FROM SUP BANNER
	JFS	XSRN14
XSRN13	LA	R2,XSRNH4		:TO SUP BANNER
XSRN14	JAL	R7,TYPASC,,		:DISPLAY APPROPRIATE BANNER
	LR	R3,R14			:GET LRC
	JAL	R9,TYPHW,,		:AND DISPLAY

	THI	R14,1			:ODD LRC ?
	JEFS	XSRN19			:NO
	AIS	R14,1			:YES, ACCOUNT FOR DUMMY BYTE
XSRN19	SR	R11,R14			:POINT TO BEGINNING OF DATA
	JGEFS	XSRN15			:NO
	AHI	R11,SRNTSZ		:WRAP
XSRN15	LCS	R12,8			:COUNT HW'S ON LINE
XSRN18	LHL	R3,SRNTBL,R11,		:GET DATA HW
	JAL	R9,TYPHW,,		:DISPLAY
	AIS	R12,1			:BUMP COUNT OF HW'S ON LINE
	JLFS	XSRN16			:STAY ON SAME LINE
	LCS	R12,8			:RESET COUNT OF HW'S ON LINE
	JAL	R7,TYPCRL,,		:AND MOVE TO NEXT LINE
	LA	R2,XSRNH6		:TYPE 28 SPACES
	JAL	R7,TYPASC,,
XSRN16	AIS	R11,2			:MOVE TO NEXT DATA HW
	CLHI	R11,SRNTSZ		:WRAP ?
	JLFS	XSRN17			:NO
	LIS	R11,0			:WRAP
XSRN17	SIS	R14,2			:DECR LRC
	JG	XSRN18			:AND GET NEXT DATA BYTE
	LHL	R14,SRNTBL,R11,		:GET LRC AGAIN
XSRN40	AIS	R14,2			:POINT PAST DATA TO PREVIOUS TRACE REC
	THI	R14,0001		:ODD LRC ?
	JEFS	XSRN20			:NO
	AIS	R14,1			:ENFORCE EVEN LRC
XSRN20	SR	R11,R14			:POINT TO PREVIOUS TRACE RECORD
	JGEFS	XSRN21			:NO WRAP
	AHI	R11,SRNTSZ		:WRAP
XSRN21	LHL	R0,SRNTRX,,		:GET FINAL TRACE INDEX
	LR	R1,R0			:SAVE INDEX
	AHI	R0,0100			:COMPUTE EFFECTIVE END OF TABLE
	CLHI	R0,SRNTSZ		:WRAP ?
	JLFS	XSRN22			:NO
	SHI	R0,SRNTSZ		:WRAP, END < CURRENT
	CR	R11,R0			:COMPARE DISPLAY INDEX TO END
	JL	XPRMPT			:DONE
	CR	R11,R1			:COMPARE DISP TO CURRENT
	JG	XPRMPT			:DONE
	J	XSRN11			:STILL WITHIN EFFECTIVE TABLE
XSRN22	CR	R11,R0			:COMPARE DISP TO END
	JG	XSRN11			:STILL WITHIN EFF TABLE
	CR	R11,R1			:COMPARE DISP TO CURRENT
	JL	XSRN11			:STILL WITHIN EFF TABLE
	J	XPRMPT			:DONE

XSRN30	LA	R1,SRNTRE,,		:CLEAR TRACE ENABLE BITS
	LHI	R2,SRNBT1/2		:NUMBER OF HWS TO CLEAR
	JAL	R8,HCLEAR,,		:AND CLEAR
	LA	R1,SRNTBL,,		:CLEAR TRACE TABLE
	LI	R2,SRNTSZ/2		:NO OF HW'S TO CLEAR
	JAL	R8,HCLEAR,,		:CLEAR IT
	STH	R0,SRNTRX,,		:CLEAR TRACE TABLE INDEX, (R0 = 0)
	LA	R2,XSRNH7		:INFORM
	JAL	R7,TYPASC,,
	J	XPRMPT			:DONE

XSRN50	LA	R1,SRNTRP,,		:CLEAR TRACE PRINT ENABLE ARRAY
	LHI	R2,SRNBT2/2		:THIS MANY HW'S
	JAL	R8,HCLEAR,,		:CLEAR IT
	LA	R2,XSRNJ4		:INFORM
	JAL	R7,TYPASC,,
	J	XPRMPT			:DONE

XSRN60	LA	R1,SRNTRP,,		:SET TRACE PRINT ARRAY (DISABLE)
	LHI	R2,SRNBT2/2		:THIS MANY HW'S
	LCS	R0,1			:ALL 1111'S
	JAL	R8,HCSET,,		:SET IT
	LA	R2,XSRNJ3		:INFORM
	JAL	R7,TYPASC,,
	J	XPRMPT			:DONE

XSRZ00	LCS	R0,1			:DISABLE TRACING OF ALL
	ST	R0,SRNOCK,,		:FROM SUP MESSAGE TYPES
	LA	R2,XSRNZ1		:INFORM BANNER
	JAL	R7,TYPASC,,
	J	XPRMPT			:DONE
XSRZ50	LCS	R0,1			:DISABLE TRACING OF ALL
	ST	R0,SRNICK,,		:TO SUP MESSAGE TYPES
	LA	R2,XSRNZ2		:INFORM BANNER
	JAL	R7,TYPASC,,
	J	XPRMPT			:DONE
XSRZ30	CLHI	R14,SRNCKN		:IS ARG A VALID MESSAGE TYPE ?
	JGFS	XSRZ40			:NO, ENABLE ALL MESSAGE TYPES FOR TRACE
	RBT	R14,SRNOCK,,		:ENABLE TRACE OF SPECIFIED FROM SUP MSG
	LA	R2,XSRNZ5		:INFORM BANNER
	JAL	R7,TYPASC,,
	J	XPRMPT			:DONE
XSRZ40	LIS	R0,0			:ENABLE TRACING OF ALL
	ST	R0,SRNOCK,,		:FROM SUP MESSAGE TYPES
	LA	R2,XSRNZ3		:INFORM BANNER
	JAL	R7,TYPASC,,
	J	XPRMPT			:DONE
XSRZ80	CLHI	R14,SRNCKN		:IS ARG A VALID MESSAGE TYPE ?
	JGFS	XSRZ90			:NO, ENABLE ALL MESSAGE TYPES FOR TRACE
	RBT	R14,SRNICK,,		:ENABLE TRACING OF SPECIFIED TO SUP MSG
	LA	R2,XSRNZ6		:INFORM BANNER
	JAL	R7,TYPASC,,
	J	XPRMPT			:DONE
XSRZ90	LIS	R0,0			:ENABLE TRACING OF ALL
	ST	R0,SRNICK,,		:TO SUP MESSAGE TYPES
	LA	R2,XSRNZ4		:INFORM BANNER
	JAL	R7,TYPASC,,
	J	XPRMPT			:DONE

	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

::*********************************************************************
::
::	COMMAND:	XSR:	SR
::	FUNCTION:	SIO RING STATUS
::	INPUT:		DISPLAY SIO RING STATUS IF NO ARGUMENTS OR IF ARG=0.
::			FORCE SIO RING INITIALIZATION IF ARG=1.
::			FORCE SIO RING AND INTERFACE INITIALIZATION IF ARG=2.
::
::*********************************************************************

	IF	SIORNG
	IF	2-XRYTMC		:###wjl

XSR	HS	0
	LHL	R2,ARGCT,XD		:GET NUMBER OF ARGUMENTS (TIMES 4)
	SIS	R2,4
	JG	COMERR			:TOO MANY ARGUMENTS
	JEFS	XSR05			:ACCEPT SINGLE ARGUMENT
	LIS	R1,0
	STH	R1,VALUE1+2,XD		:FAKE NO ARG AS ZERO VALUE...
	JFS	XSR04			:NO ARGS, NO SECURITY CHECK	###OAS
XSR05	LH	R1,XPOWER,XD		:IF ARGS, MUST HAVE POWER	###OAS
	JG	XPWERR			:NOPE, NOT AUTHORIZED		###OAS
XSR04	LHL	R1,VALUE1+2,XD
	SIS	R1,2			:RANGE CHECK ARGUMENT
	JG	COMERR			:>2, ERROR
	AIS	R1,2			:RESTORE
	STH	R1,SIRXIZ,,		:SET CELL TO FORCE INITIALIZATION
	LR	R1,R1	
	JN	XSR40			:DISPLAY ACTION
:	ARGUMENT 0, DISPLAY CURRENT STATUS...
	LA	R2,XSRM1		:'SIO RING INTERFACE'
	JAL	R7,TYPASC,,
	LH	R0,SIRDLD,,		:-1 IF CURRENTLY DOING LOAD
	JL	XSR70
	LH	R0,SIRFLG,,		:0 FOR DOWN, -1 FOR UP, POSITIVE FOR
					:TIMED-OUT OR AWAITING LOAD
	JGFS	XSR30			:TIMED-OUT OR MISMATCH ON RING 0
	JEFS	XSR20			:DOWN

XSR10	LA	R2,XSRM2		:UP
XSR12	JAL	R7,TYPASC,,		:DISPLAY STATUS
	J	XPRMPT			:DONE

XSR20	LA	R2,XSRM3
	JBS	XSR12

XSR30	CLHI	R0,STSRM0		:AWAITING LOAD?
	JE	XSR60			:YES
	LA	R2,XSRM4		:INTERFACE TIMED-OUT
	JAL	R7,TYPASC,,
	LHL	R3,SIRFLG,,		:IT HAPPENED LAST ON THIS COMMAND
	JAL	R9,TYPHW,,
	LA	R2,XSRM5
	J	XSR12

XSR40	SIS	R1,1
	JNFS	XSR50			:INTERFACE INITIALIZED
	LA	R2,XSRM6		:RING INITIALIZED
XSR42	JAL	R7,TYPASC,,
	J	XPRMPT

XSR50	LA	R2,XSRM7
	JBS	XSR42

XSR60	LA	R2,XSRM8		:'AWAITING LOAD'
	J	XSR12

XSR70	LA	R2,XSRM9		:'LOADING'
	J	XSR12

	EI	:2-XRYTMC ###wjl

	EI	:SIORNG

	SUBTTL	XRAY (Crash info display routines - DC, DCS, DCD)

	IF	(XRSZLV)		:##AL
::*********************************************************************
::
::	COMMAND:	XDCRSH:	DC, DCS, DCD
::	FUNCTION:	DISPLAY CRASH SUMMARY OR DETAIL TABLE OR BOTH
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl

	NOLIST
XDCSH1	SC	/"0D"0ACRASH SUMMARY TABLE/
XDCDH1	SC	/"0D"0ACRASH DETAIL TABLE/
XDCHDR	SC	/"0D"0ATIME"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0CC"A0"A0"A0TYPE"A0"A0PSW"A0"A0"A0ADDRESS"0D"0A/

XDCDH2	SC	/"0D"0AREGISTER SET 0:/
XDCDH3	SC	/"0D"0AUSER REGISTER SET:/
XDCDH4	SC	/"0D"0AMAC REGISTERS (300-35F):/
	LIST

XDCRSH	HS	0
	JAL	R13,XRYIN,,
	NHI	R1,ASCAP		:STRIP PARITY AND LOWER CASE BIT(x5F)
	CLHI	R1,ASCD			:DID USER END WITH 'D'?
	JE	XDCRDT			:YES, GO DO DETAIL TABLE
	CLHI	R1,ASCS			:DID USER END WITH 'S'(x53)?
	JNFS	XDCRS1			:NO
	LI	R11,XRCRLF		:FINISHED AFTER DOING SUMMARY TABLE
	JFS	XDCRSM			:GO DO SUMMARY TABLE
XDCRS1	CLHI	R1,ASCCR		:DID USER END WITH C/R (x0D)?
	JN	COMERR			:NO, ERROR
	LI	R11,XDCRDT		:GO DO DETAIL AFTER DOING SUMMARY

XDCRSM	HS	0			:DISPLAY CRASH SUMMARY TABLE
	LI	R10,XDCRS3		:CONTINUATION POINT
	LIS	R12,0			:INDEX TO SUMMARY TABLE ENTRIES
	LI	R14,CSMTBL		:POINTER TO SUMMARY TABLE
	LA	R2,XDCSH1		:GET HEADER
	JAL	R7,TYPASC,,		:TYPE IT
XDCRS4	LA	R2,XDCHDR
	JAL	R7,TYPASC,,
	LHL	R6,CSMCNT		:NUMBER OF SUMMARY ENTRIES
	JER	R11			:RETURN IF NONE
XDCRS2	HS	0
	L	R2,CS.TIM,R14,R12	:GET CRASH TIME
	JAL	R9,GMTCNX,,		:DISPLAY IT
	JAL	R7,TYP2SP,,
	LHL	R3,CS.CNT,R14,R12	:CRASH COUNT
	JAL	R9,TYPHWD,,
	LHL	R3,CS.CID,R14,R12	:CRASH ID
	JAL	R9,TYPHW,,
	LHL	R3,CS.PSD+2,R14,R12	:CRASH PSW
	JAL	R9,TYPHW,,
	L	R3,CS.PSD+4,R14,R12	:CRASH PC
	JAL	R9,TYPFW,,
	JAL	R7,TYPCRL,,
	JR	R10
XDCRS3	AHI	R12,CS.SIZ		:NEXT ENTRY
	CLHI	R12,CSMTBS		:DONE?
	JGER	R11			:YES, DONE
	SIS	R6,1			:DEC COUNT OF ENTRIES
	JG	XDCRS2			:NO, DO NEXT ENTRY
	JR	R11			:DONE

XDCRDT	HS	0
	LI	R14,CDTTBL		:POINT TO DETAIL TABLE
	LIS	R12,0			:INDEX INTO DETAIL TABLE
	LA	R2,XDCDH1		:HEADER
	JAL	R7,TYPASC,,
XDCRD2	LI	R11,XRCRLF		:GO HERE WHEN ALL DONE
	LHL	R6,CDTCNT		:load count of detail entries
	JER	R11			:none, all done			###wjl
	LI	R10,XDCRD1		:SET UP RETURN POINTER
	J	XDCRS4
XDCRD1	HS	0	:RETURN HERE FROM XDCRS2 AFTER TYPING FIRST LINE
	IF	ISIS			:###OAS
	AR	R14,R12
	LR	R6,R14
	AHI	R6,CD.RSF		:POINT TO REG SET F SAVE AREA
	LA	R2,XDCDH3		:"USER REGISTER SET"
	JAL	R7,TYPASC,,
	LHI	R5,10			:TYPE 16D REGISTERS
	JAL	R8,TYPNFW
	ELSE	:NOT ISIS		:###OAS
	LA	R2,XDCDH2		:"REGISTER SET 0"
	JAL	R7,TYPASC,,
	AR	R14,R12
	LR	R6,R14			:GET POINTER TO TABLE
	AHI	R6,CD.RS0		:POINT TO REG SET 0 SAVE AREA
	LHI	R5,10			:TYP 16d REGISTERS
	JAL	R8,TYPNFW
	LA	R2,XDCDH3		:"USER REGISTER SET"
	JAL	R7,TYPASC,,
	LHI	R5,10			:TYPE 16d REGISTERS
	JAL	R8,TYPNFW		:R6 POINTS TO NEXT SECTION
	LA	R2,XDCDH4		:"MAC REGISTERS (300-35F)"
	JAL	R7,TYPASC,,
	LHI	R5,18			:24d FW'S
	JAL	R8,TYPNFW		:R6 ALREADY POINTS TO NEXT SECTION
	EI	:ISIS			:###OAS

	LR	R12,R12
	JN	XPRMPT
	AHI	R12,CD.SIZ		:NEXT DETAIL ENTRY
	LHL	R6,CDTCNT		:# OF DETAIL ENTRIES - 1 OR MORE?###GT
	SIS	R6,1
	JER	R11			:NO, ALL DONE
	J	XDCRD2

	EI	:2-XRYTMC ###wjl

	SUBTTL	XRAY (Node statistics - NS)

::*********************************************************************
::
::	COMMAND:	XSTATS:	NS
::	FUNCTION:	DISPLAY NODE STATUS DATA
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl

XSTATS	HS	0
	CLHI	R1,ASCZ			:DID USER CLOSE WITH 'Z'(x5A)?
	JN	XST44			:NO, JUST DISPLAY ALL DATA
	LIS	R0,0			:YES, CLEAR PROCESS HW-MARKS
	IF	SWITIM			:SWITCH MAX PROCESS TIME debug switch
	LHI	R10,1F*4		:clear for all processes	###wjl
	ELSE	:not SWITIM		:				###wjl
	LHI	R10,$A60		:CLEAR FOR 15 PROCESSES
	EI	:SWITIM			:				###wjl
XST66	ST	R0,PROHWM,R10,
	CLHI	R10,0C			:REACHED INDEX FOR EXLAVG YET?
	JGFS	XST63			:NO
	ST	R0,EXLAVG,R10		:YES, CLEAR VARIOUS COUNTERS
XST63	SIS	R10,4
	JGEBS	XST66

	IF	SOLOCS
	STH	R0,CS.(FASTCH),,	:CLEAR MAX ASYNC WRAP TIME###OAS
	EI	:SOLOCS
        if      super
        sth     r0,suiccw
        sth     r0,suoccw               :clear high waters
        ei      :super

	LHI	R0,$A9999		:reset EXLALW to max on "NSZ"
	STH	R0,EXLALW		:SET LOW WATER MARK TO MAX
	LHL	R0,PASTHR
	STH	R0,MXPASS		:INITIALIZE MAX NUMBER OF PASS-THRUS
	LHL	R0,HNPORT
	STH	R0,MXPORT		:MAXIMUM NUMBER OF PORTS IN USE
	LHL	R0,NALINK
	STH	R0,MXLINK		:AND MAXIMUM NUMBER OF LINKS

XST44	LA	R2,XSTHD1		:DISPLAY LINE OF HEADER INFORMATION
	JAL	R7,TYPASC,,
	LIS	R10,8			:8 HW OF STATISTICS
	LIS	R11,0
XSTAT3	LHL	R3,EXLAVG,R11
	JAL	R9,TYPHWD,,
	AIS	R11,2
	SIS	R10,1
	JGBS	XSTAT3
	LHL	R3,MXPORT
	JAL	R9,TYPHWD,,		:DISPLAY MAXIMUM NUMBER OF PORTS 
	LHL	R3,MXPASS
	JAL	R9,TYPHWD,,		:DISPLAY MAX NUMBER OF PASSTHRUS
	LHL	R3,MXLINK		:DISPLAY MAXIMUM NUMBER OF LINKS
	JAL	R9,TYPHWD,,
	JAL	R7,TYPCRL,,

	LA	R2,XSTHD2		:HEADER FOR RMAKE STATS
	JAL	R7,TYPASC,,

	L	R3,RMKRMS		:NUMBER OF RMAKE CALLS LAST MINUTE
	JAL	R9,TYPFWD,,
	L	R3,RMKNRS		:RMAKE CALLS FOR WHICH NO RECORD MADE
	JAL	R9,TYPFWD,,
	L	R3,RMKRMS
	S	R3,RMKNRS		:DIFFERENCE IS NUMBER OF PACKETS MADE
	JAL	R9,TYPFWD,,

	LA	R2,XSTHD3		:HEADER FOR CPS STATS
	JAL	R7,TYPASC,,
	LA	R2,XSTHD8
	JAL	R7,TYPASC,,
	LHL	R3,NSCPSO,,		:CPS OUT
	JAL	R9,TYPFWD,,		:DISPLAY
	LHL	R3,NSCPSI,,		:CPS IN
	JAL	R9,TYPFWD,,
	LHL	R3,NSCPHO,,		:HI-WATER MARK OUT
	JAL	R9,TYPFWD,,
	LHL	R3,NSCPHI,,		:HI-WATER MARK IN
	JAL	R9,TYPFWD,,

:	NODE LINKS' TOTAL PHYSICAL CPS RATES				###wjl
	LA	R2,XSTHDB		:header for physical CPS stats	###wjl
	JAL	R7,TYPASC,,		:				###wjl
	LA	R2,XSTHD8		:				###wjl
	JAL	R7,TYPASC,,		:				###wjl
	LHL	R3,NS.PCO+2,,		:Physical CPS Out, HW value	###wjl
	JAL	R9,TYPFWD,,		:stored in FW location		###wjl
	LHL	R3,NS.PCI+2,,		:Physical CPS In, HW value	###wjl
	JAL	R9,TYPFWD,,		:stored in FW location		###wjl
	LHL	R3,NS.PHO,,		:Physical HWM Out		###wjl
	JAL	R9,TYPFWD,,		:				###wjl
	LHL	R3,NS.PHI,,		:Physical HWM In		###wjl
	JAL	R9,TYPFWD,,		:				###wjl
        if      super
        la      r2,xsthdc               :header for sup
        jal     r7,typasc,,
        la      r2,xsthd8
        jal     r7,typasc,,
        lhl     r3,suocct
        jal     r9,typfwd,,
        lhl     r3,suicct
        jal     r9,typfwd,,
        lhl     r3,suoccw
        jal     r9,typfwd,,
        lhl     r3,suiccw
        jal     r9,typfwd,,             :cps rates
        ei      :super

        if      nku
        la      r2,xsthdd                :header for kernel rings
        jal     r7,typasc,,
        la      r2,xsthd8
        jal     r7,typasc,,
        lhl     r3,krocct
        jal     r9,typfwd,,
        lhl     r3,kricct
        jal     r9,typfwd,,
        lhl     r3,kroccw
        jal     r9,typfwd,,
        lhl     r3,kriccw
        jal     r9,typfwd,,             :cps rates
        ei      :nku
	IF	SOLOCS
	LA	R2,XSTHD9		:HEADER FOR ASYNC CPS STATS
	JAL	R7,TYPASC,,
	LA	R2,XSTHD8
	JAL	R7,TYPASC,,
	LHL	R3,CS.(NSASYO),, 	:ASYNC CPS OUT
	JAL	R9,TYPFWD,,
	LHL	R3,CS.(NSASYI),, 	:ASYNC CPS IN
	JAL	R9,TYPFWD,,
	LHL	R3,CS.(NSASHO),, 	:ASYNC HWM OUT
	JAL	R9,TYPFWD,,
	LHL	R3,CS.(NSASHI),, 	:ASYNC HWM IN
	JAL	R9,TYPFWD,,
	IF	NUMPRN
	LA	R2,XSTHDA		:HEADER FOR PRINTER CPS STATS
	JAL	R7,TYPASC,,
	LA	R2,XSTHD8
	JAL	R7,TYPASC,,
	LHL	R3,CS.(NSPRNO),,	:PRINTER CPS OUT
	JAL	R9,TYPFWD,,
	LIS	R3,0			:NO PRINTER DATA IN...
	JAL	R9,TYPFWD,,
	LHL	R3,CS.(NSPRHO),,	:PRINTER HWM OUT
	JAL	R9,TYPFWD,,
	LIS	R3,0
	JAL	R9,TYPFWD,,
	EI	:NUMPRN
	EI	:SOLOCS

XNSPER	LA	R2,XSTHD7		:PERFORMANCE HEADER
	JAL	R7,TYPASC,,
	LIS	R10,0			:CLEAR ACCUMULATOR REGISTERS
	LIS	R11,0
	L	R12,TOTCHR,,		:TOTAL # LOGICAL CHARACTERS THRU NODE
	SRLS	R12,7			:SCALE DOWN TO PREVENT TRUNCATION ERROR
:	VERY EFFICIENT!	THIS WILL BE NUMERATOR OF TICKS TO MS CONVERSION
	JE	XNSPE3			:ZERO TRAFFIC, DON'T DIVIDE BY ZERO!
	LHI	R4,NLINKS*2-2		:SET UP LOOP INDEX
XNSPE1	SLL	R4,1
	L	R14,KDKN,R4,		:GET LINK DESCRIPTOR
	SRL	R4,1
	LB	R0,NLAT,R14		:ANY LINES ATTACHED?
	JE	XNSPE2			:NO, LINK NOT UP, IGNORE IT
	L	R8,KS.LMI,R14		:LOGICAL CHARS IN ON LINK
	A	R8,KS.LMO,R14		:GET TOTAL CHARS ON LINK
	DHR	R8,R12			:GET LINK'S TRAFFIC AS PERCENT OF TOTAL

	LHL	R6,KS.XMT,R14		:AVERAGE TRANSMISSION TIME
	AH	R6,KS.AQU,R14		:PLUS AVERAGE QUEUE TIME=HARDWARE DELAY
	MHR	R6,R9			:MULTIPLY BY APPROPRIATE % OF TRAFFIC
	LHL	R7,KS.RRT,R14		:GET BUFFER DELAY
	AH	R7,KS.SRA,R14		:PLUS SYLVEX-RTEAR DELAY
	AH	R7,SYLXAV,,		:PLUS AVE SYLVEX DELAY=SOFTWARE DELAY
	MHR	R7,R9			:WEIGH WITH PERCENT OF TRAFFIC
	AR	R10,R6			:ACCUMULATE H-WARE DELAY
	AR	R11,R7			:AND CODE DELAY
XNSPE2	SIS	R4,2			:DECREMENT LINK NUMBER INDEX
	JGE	XNSPE1			:LOOP IF MORE LINKS

XNSPE3	LHI	R14,$A80		:DENOMINATOR OF TICKS TO MSEC
					:CONVERSION (128/80)
	LR	R2,R11
	DHR	R2,R14			:GET RESULT IN MILLISECONDS
	JAL	R9,TYPHWD,,
	JAL	R7,TYP8SP,,		:TYPE 8 SPACES
	LR	R2,R10			:SAME FOR H-WARE DELAY
	DHR	R2,R14
	JAL	R9,TYPHWD,,		:DISPLAY DECIMAL RESULT IN MS
	JAL	R7,TYP8SP,,		:TYPE 8 SPACES
	AR	R10,R11			:FORM COMBINED RESULT...
	LR	R2,R10
	DHR	R2,R14
	JAL	R9,TYPHWD,,
	JAL	R7,TYP8SP,,		:TYPE 8 SPACES
	LIS	R3,0			:TAKE PRECAUTION AGAINST ZERO DIVIDE
	SLLS	R12,8			:RESCALE AND DOUBLE		###JHL
	JEFS	XNSPE5			:DON'T DIVIDE BY ZERO

	IF	1-ISIS
	DHR	R12,R10			:COMPUTE EFFICIENCY FOR SOLO NODE
	LR	R3,R13
	ELSE	:1-ISIS
	IF	\TIINEW			:ISIS INTERRUPT ROUTINES MUST COLLECT
         IF    TIINEW                   :must not be zero too ##sdw
					:OUT QUEUE DELAYS FOR US
	DHR	R12,R10			:COMPUTE EFFICIENCY FOR ISIS NODE
	LR	R3,R13
         EI    :TIINEW
	EI	:\TIINEW
	EI	:1-ISIS			:###JHL
XNSPE5	JAL	R9,TYPHWD,,

	LA	R2,XSTMS0		:HEADER
	JAL	R7,TYPASC,,
	LIS	R10,9+2*SOLOCS		:DISPLAY 9 SOLO OR 11 CONSAT PROCESSES
	LIS	R11,0
	LHL	R12,MININT,,		:EXACT MEASUREMENT INTERVAL
	LHI	R14,$A100
XNS22	JAL	R7,TYP2SP,,		:2 SPACES FOR NEAT DISPLAY
	LHL	R2,PSVTIM+2,R11,	:SKIP THE BUFFER-ZAP PROCESS
	MHR	R2,R14			:MULTIPLY BY 100
	DHR	R2,R12			:DIVIDE BY TIME INTERVAL TO GET PERCENT
	JAL	R9,HEXDEC,,
	JAL	R9,TYPBYT,,		:DISPLAY IT
	AIS	R11,2
	SIS	R10,1
	JG	XNS22
	LA	R2,XSTMS1
	JAL	R7,TYPASC,,
	LIS	R10,9+2*SOLOCS		:DISPLAY 9 SOLO OR 11 CONSAT PROCESSES
	LIS	R11,0
XNS33	LHL	R2,PROHWM+6,R11,	:SKIP THE BUFFER-ZAP PROCESS
	JAL	R9,FSTMSC,,		:convert FASTC to MSEC		###wjl
	JAL	R9,TYPHWD,,		:DISPLAY PEAK TIME IN MILLISECONDS
	AIS	R11,4
	SIS	R10,1
	JGBS	XNS33

	IF	SWITIM			:SWITCH MAX PROCESS TIME debug switch
	LA	R2,XSTMS3		:SWITCH SUBPROCESS header	###wjl
	JAL	R7,TYPASC,,		:				###wjl
	LIS	R10,7			:display 7 SWITCH SUBPROCESSES	###wjl
	LIS	R11,0			:				###wjl
XNS44	LHL	R2,PROHWM+PLEP+2,R11,	:start with LEP SUBPROCESS	###wjl
	JAL	R9,FSTMSC,,		:convert FASTC to MSEC		###wjl
	JAL	R9,TYPHWD,,		:display MAX time in MS		###wjl
	AIS	R11,4			:				###wjl
	SIS	R10,1			:				###wjl
	JGBS	XNS44			:				###wjl
	EI	:SWITIM			:				###wjl

:	AVERAGE ASYNC TIME, MAX, WRAP IF SOLOCS
	IF	SOLOCS
	LA	R2,XSTHD4		:'AVERAGE ASYNC TIME (MS) :'
	JAL	R7,TYPASC,,
	LHL	R2,CS.(ASYAVE),,	:AVE FASTC TIME BETWEEN ASYNC EXECUTION
	JAL	R9,FSTMSC,,		:CONVERT FASTC TO MSEC
	JAL	R9,TYPHWD,,		:AND TYPE OUT AVERAGE TIME IN MS
	LA	R2,XSTHD5		:'MAX :'
	JAL	R7,TYPASC,,
	LHL	R2,CS.(FASTCH),,
	JAL	R9,FSTMSC,,		:FASTC-TO-MSEC CONVERT ROUTINE
	JAL	R9,TYPHWD,,
	LA	R2,XSTHD6		:'WRAP :'
	JAL	R7,TYPASC,,
	LHI	R3,RNGWRP
	JAL	R9,TYPHWD,,
	EI	:SOLOCS

	J	XRCRLF		:DONE

	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV)		:##AL

:       KW      display KIO stats

xrykwm  sc      /"0d"0aPORT   Chars In  Chars Out"0d"0a/
xrykw   clhi    r1,ascz                 :clear?
        je      xrykwz
        la      r2,xrykwm
        jal     r7,typasc,,
        lis     r10,0
xrykw1  lr      r3,r10
        jal     r9,typbyd,,
        ar      r10,r10
        jal     r7,typ4sp,,
        l       r3,kerict,r10,r10       :input chars
        jal     r9,typfw,,
        l       r3,keroct,r10,r10       :output chars
        jal     r9,typfw,,
        jal     r7,typcrl,,
        srls    r10,1
        ais     r10,1
        clhi    r10,nku
        jl      xrykw1
        j       xprmpt,,

xrykwz  lis     r0,0                    :clear stats
        lhi     r10,nku*2
xrykw9  st      r0,kerict,r10,r10
        st      r0,keroct,r10,r10
        sis     r10,2
        jgebs   xrykw9
        la      r2,xksm25,,             :stats cleared msg
        jal     r7,typasc,,
        j       xprmpt,,


:       DJ      do tracing for a supe port.  DJ <node number> starts.
:       DJ followed by a CR displays the data and stops the trace.

        if      super
xrdj    sis     r2,4            :with an arg?
        jg      comerr,         :too many args
        jn      xrdjd0          :the display logic
:       here to initiate trace
        l       r3,value1,xd
        jal     r9,octhxr,,     :convert node to hex
        ais     r3,2            :supe chans start off by 2
        ahi     r3,supzfl-400           :node #s start at 2000 octal
        ci      r3,endzfl               :legal chn number?
        jg      comerr,,
        sbt     r3,trchan,,             :400 since node # start at 2000octal
        sth     r3,xdjsav,xd            :chan we are tracing
        j       xprmpt,,

xrdjd0  ts      xdjsat,xd               :indicate TD from DJ
        lis     r4,0
        lis     r0,1
        lis     r2,0
        j       trcd0j                  :goto TD routine

        ei      :super

:       SW      Supe Watch command.

        if      super
xrysw   clhi    r1,ascz                 :want clear?
        jn      xrysw1
:       clear stats
        jal     r9,swclear                      :clear all stats
        la      r2,xksm25,,
        jal     r7,typasc,,
        j       xprmpt,,
swclear li      r1,(nsp+4)*2            :the whole shebang
        lis     r0,0
swcle1  st      r0,supned,r1,r1
        st      r0,supcpi,r1,r1
        st      r0,supcpo,r1,r1
        st      r0,suprej,r1,r1
        st      r0,supilc,r1,r1
        st      r0,supdlc,r1,r1
        st      r0,supdnd,r1,r1
        sth     r0,supind,r1,           :internal circuits
        sis     r1,2
        jge     swcle1
        jr      r9                      :and return (to lep or xray)


xryswj sc /"0d"0a       Logon         ORIGINATION      DESTINATION       Total Chars   Internal/
xryswi sc /"0d"0aNode   Responses  Needles  Total LU Needles  Total LU   IN       OUT  Circuits/
xrysw1  lr      r11,r1
        lr      r12,r2
        la      r2,xryswj
        jal     r7,typasc,,
        la      r2,xryswi
        jal     r7,typasc,,
        lr      r1,r11
        lr r2,r12
        clhi    r1,ascn                 :needles with a threshhold?
        jn      xrysw2
        sis     r2,4
        jn      comerr,,
        l       r14,value1,xd         :get threshhold
        la      r11,supned,,            :supe port 0 an 1 don't count
        j       xrysw7
xrysw2 clhi    r1,ascr                 :rejects with a threshhold?
        jn      xrysw9
        sis     r2,4
        jn      comerr,,
        l       r14,value1,xd         :get threshhold
        la      r11,suprej,,            :supe port 0 an 1 don't count
        j       xrysw7

xrysw9
        clhi    r1,asci                 :chars in with a threshhold?
        jn      xrysw8
        sis     r2,4
        jn      comerr,,
        l       r14,value1,xd         :get threshhold
        la      r11,supcpi,,   
        j       xrysw7
xrysw8 clhi    r1,asco                 :output chars threshhold?
        je      xryswh
        clhi    r1,asct                 :T for termination needles
        je      xryswt
        sis     r2,4                    :have an arg with no threshold?
        jl      xryswu                  :display for all nodes
        jg      comerr,,
        l       r3,value1,xd
        jal     r9,octhxr,,             :convert to hex
        lr      r12,r3
        shi     r12,3fe                 :fix offset
        jle     comerr
        clhi    r12,nsp
        jg      comerr,,
        jal     r6,xryswd
        j       xprmpt                  :displayed that one node
xryswt  la      r11,supdnd,,
        l       r14,value1,xd
        j       xrysw7                  :find them
xryswu  lis     r14,0           :no threshhold
        la      r11,supcpi,,  
        jfs     xrysw7
xryswh  sis     r2,4
        jn      comerr,,
        l       r14,value1,xd         :get threshhold
        la      r11,supcpo,,

xrysw7  lhl     r0,tvrsup
        clhi    r0,machnm&07            :our supe the active supe?
        jn      xryswp
        lis     r12,0                   :start at low node number
xryswm  tbt     r12,supacp,,            :active port?
        jefs    xryswo                  :active if reset
xryswn  ais     r12,1
        clhi    r12,nsp
        jlbs    xryswm
        j       xprmpt,,

xryswo  lr      r1,r12
        slls    r1,2
        cl      r14,0,r11,r1            :above threshhold?
        jg      xryswn                  :no, so don't print
        jal     r6,xryswd               :display it for a node
        j       xryswn                  :and next


xryswp  lis     r12,3                   :start at low node number

xryswq  lr      r1,r12
        slls    r1,2
        c       r14,0,r11,r1            :above threshhold?
        jgfs    xryswr                  :no, so don't print
        jal     r6,xryswd               :display it for a node
xryswr  ais     r12,1
        clhi    r12,nsp
        jlbs    xryswq
        j       xprmpt,,


:       xryswd  routine to print out node number and the values
:       links on r6, has node number -2000 in r11
xryswd  jal     r7,typcrl,,             :new line
        lhi     r3,3fe,r12              :make into node number
        jal     r9,typ5o,,              :output node number
        ar      r12,r12
        l       r3,suprej,r12,r12       :number of rejects
        jal     r9,typfw,,
        jal     r7,typ2sp,,
        l       r3,supned,r12,r12       :output number of orig needlles
        jal     r9,typfw,,
        l       r3,supilc,r12,r12       :link count
        jal     r9,typfw,,
        l       r3,supdnd,r12,r12       :number of dest needles
        jal     r9,typfw,,
        l       r3,supdlc,r12,r12
        jal     r9,typfw,,              :dest link count
        l       r3,supcpi,r12,r12       :chars in
        jal     r9,typfw,,
        l       r3,supcpo,r12,r12       :char outs
        jal     r9,typfw,,
        srls    r12,1
        lhl     r3,supind,r12,r12       :internal circuits
        jal     r9,typhw,,                      :recent in and out
        jr      r6                      :done
        ei      :super





	SUBTTL	XRAY (Query semi-memory error log - QE)

::*********************************************************************
::
::	COMMAND:	QMEM:	QE
::	FUNCTION:	QUERY MEMORY ERRORS FROM MEMORY BOARD LOG
::	MEMTRC LAYOUT:
::	0        1        2        3        4                8
::	------------------------------------------------------
::	|  SPR   | ERR CNT| D/S, BD|ROW/CHIP|    TIME        |
::	------------------------------------------------------
::*********************************************************************

	IF	2-XRYTMC		:###wjl
	IF	1-ISIS			:###wjl
	IF	ZITEL

QMEM	HS	0
	LHL	R5,MEMIN,,		:GET PTR TO BLOCK START
QMEM0	L	R0,MEMTRC+4,R5,		:GET SLOWC TIME OF LOGGING
	JE	QMEM3			:DISPLAY ONLY IF ERRORS LOGGED
	JAL	R7,TYPCRL,,		:START WITH NEW LINE
	L	R3,SLOWC,,		:GET NOW TIME IN SECONDS
	SR	R3,R0			:HOW LONG SINCE ERROR LOGGED
	JAL	R9,TYPFWD,,		:OUTPUT ELAPSED TIME
	LA	R2,BOARD		:PTR TO STRING "ON BOARD:"
	JAL	R7,TYPASCS,,		:OUTPUT TO USER SCREEN
	LB	R3,MEMTRC+2,R5,		:ISOLATE BOARD NUMBER
	NHI	R3,0F			:REMOVE EXTRANEOUS
	JAL	R9,TYPHW,,		:OUTPUT BOARD NUMBER IN HEX
	LA	R2,TIMES		:GET PTR TO STRING "OCCURING:  "
	JAL	R9,TYPASC,,		:OUTPUT TO USER SCREEN
	LB	R3,MEMTRC+1,R5,		:GET ERROR COUNT
	JAL	R9,TYPHWD,,		:OUTPUT COUNT
	LH	R0,MEMTRC+2,R5,		:DOUBLE BIT,SINGLE BIT ERROR
	JLFS	QMEM1
	LA	R2,SBTMSG		:"SINGLE BIT ERROR ON CHIP"
	JFS	QMEM2
QMEM1	LA	R2,DBTMSG		:"DOUBLE BIT ERROR ON ROW"
QMEM2	JAL	R7,TYPASC,,		:OUTPUT PROPER STRING
	LB	R3,MEMTRC+3,R5,		:GET U NUMBER OR ROW
	JAL	R9,TYPHWD,,		:OUTPUT ROW OR CHIP #
QMEM3	AIS	R5,8			:BUMP TO NEXT BOARD
	CLHI	R5,NMTRC*8		:DO TEST FOR LAST BOARD
	JLFS	QMEM7			:BRANCH IF NOT UP TO END
	LIS	R5,0			:SET UP THE END TEST
QMEM7	CH	R5,MEMIN,,
	JE	XRCRLF			:THAT'S ALL FOR NOW...
	J	QMEM0			:OOPS.  LET'S LOOP FOR ANOTHER BOARD

	NOLIST
SBTMSG	SC	/SINGLE BIT ERRORS ON CHIP # /
DBTMSG	SC	/DOUBLE BIT ERRORS IN ROW # /
BOARD	SC	/ AGO, BOARD # /
TIMES	SC	/ SHOWED /
	LIST

	EI	:ZITEL
	EI	:1-ISIS	  ###wjl
	EI	:2-XRYTMC ###wjl

	SUBTTL	XRAY (Link statistics - KS)

	IF	(XRSZLV)		:##AL

::*********************************************************************
::
::	COMMAND:	XKS:	KS
::	FUNCTION:	DISPLAY LINK STATISTICS
::
::*********************************************************************

:	NODE CODE ROUTINE MTRFIC GATHERS LINK TRAFFIC COUNTS FOR LOGICAL
:	AND PHYSICAL COUNTS. COUNT INTERVAL IS NUMBER OF SECONDS IN MTTINT

XKSCIU	WS	1			:0 IF KS NOT IN USE, ELSE XD OF USER

	IF	2-XRYTMC		:###wjl

XKS	HS	0
	LHL	R2,XKSCIU+2		:ANYBODY HERE ALREADY?
	JN	XCOMIU			:YES, COMMAND IN USE MESSAGE
	ST	XD,XKSCIU		:MARK IT IN USE
	LIS	R2,0			:CLEAR STATS ZERO FLAG		###OAS
	STH	R2,XKSZFG		:FOR KSZ COMMAND		###OAS
	CLHI	R1,ASCS			:IS LAST CHAR AN 'S'(x53)?
	JEFS	XKSSS0			:YES, DISPLAY ALL LINKS		###OAS
	CLHI	R1,ASCZ			:IS LAST CHAR A 'Z'(x5A)?	###OAS
	JN	XKS00			:NO				###OAS
	TS	XKSZFG			:YES, FLAG FOR STATS CLEAR	###OAS
	J	XKS00			:AND CONTINUE			###OAS
XKSSS0	LHI	R14,NLINKS-1
	LIS	R11,0
	LIS	R12,8
XKSSS	SLL	R14,1
	L	R10,KDKN,R14,R14	:GET LINK DESCRIPTOR POINTER
	SRL	R14,1
	LB	R0,NLAT,R10		:ANY LINES ATTACHED TO THIS LINK?
	JEFS	XKSSS1			:NO, GO ON TO NEXT LINK
	LHL	R3,NDID,R10		:YES, GET THE NEIGHBOR
	JAL	R9,HEXOCT,,		:##AL
	ST	R3,VALUE1,XD,R11	:STORE IT IN THE ARGUMENT FIELD
	AIS	R11,4			:INCREMENT NUMBER OF ARGS*2
	SIS	R12,1			:GET UP TO EIGHT LINKS MAXIMUM
	JEFS	XKSSS2			:DONE ALL EIGHT, EXIT
XKSSS1	SIS	R14,1			:ADVANCE TO NEXT LINK
	JGE	XKSSS
XKSSS2	STH	R11,ARGCT,XD
XKS00	LHL	R2,ARGCT,XD		:GET ARG COUNT
	JNFS	XKS01
	ST	R2,XKSCIU		:MARK COMMAND NOT IN USE
	J	XRCRLF			:ALLDONE
XKS01	SIS	R2,4			:DEC ARG COUNT
	STH	R2,ARGCT,XD		:AND RESTORE
	L	R3,VALUE1,R2,XD		:GET NEXT NEIGHBOR         ###SHM
	LR	R10,R3			:AND SAVE IT
	JAL	R9,OCTHXR,,		:AND GO HEX
	LR	R1,R3
	JAL	R9,XFNDLK		:FIND LINK REQUESTED
	LIS	R2,0			:NO SUCH LINK
	JFS	XKS03			:GO HANDLE
	JFS	XKS02			:+4 RETURN - LINK VALID, GO DISPLAY
XKS03	ST	R2,XKSCIU		:RESET BUSY FLAG AND
	J	COMERR			:LINK NOT THERE, COMPLAIN
XKS02	LR	R3,R10			:RECOVER NEIGHBOR
	LA	R2,XKSM19		:TYPE HEADER
	JAL	R7,TYPASC,,
	JAL	R9,TYP5CH,,		:AND DISPLAY IT
	L	KX,XKDSAV,XD		:RECOVER KD INTO KX FOR THIS NGHBR##OAS

:	CHECK FOR STATISTICS CLEAR COMMAND AND ZERO THE LINK DESCRIPTOR STATS
:	HIGH WATER MARKS FOR THE SPECIFIED LINK(S) IF CLEAR FLAG IS NON-ZERO

	LH	R1,XKSZFG		:CHECK STATS CLEAR FLAG		###OAS
	JE	XKS09			:NO 'Z' SPECIFIED		###OAS
	LIS	R2,0			:				###OAS
	ST	R2,KS.PHO,KX		:CLEAR PACKET CHARS OUT HWM	###OAS
	ST	R2,KS.PHI,KX		:CLEAR PACKET CHARS IN HWM	###OAS
	ST	R2,KS.LHO,KX		:CLEAR LOGICAL CHARS OUT HWM	###OAS
	ST	R2,KS.LHI,KX		:CLEAR LOGICAL CHARS IN HWM	###OAS
	ST	R2,KS.NPH,KX		:CLEAR #PACKETS MADE HWM	###OAS
	LA	R2,XKSM25		:DISPLAY 'STATISTICS CLEARED'	###OAS
	JAL	R7,TYPASC,,		:FOR THIS NEIGHBOR		###OAS
	J	XKS00			:AND PROCESS NEXT NEIGHBOR	###OAS

:	COPY RELEVANT FIELDS FROM LINK DESCRIPTOR TO SAVE AREA SO
:	KS DISPLAY USES CONSISTENT DATA
XKS09	LHI	R1,KSSZ-4		:7 GROUPS OF 12 BYTES EACH	###OAS
XKS10	L	R0,KS.PCO,KX,R1
	ST	R0,KS.PCO+XKSSKD,R1 	:SAVE AREA
	SIS	R1,4
	JGEBS	XKS10

:	COMPUTE LINK'S CPM RATE OVER REPORTING INTERVAL
	LB	R1,KSPD,KX
	NHI	R1,1F			:ISOLATE LINK SPEED AND
	SLLS	R1,2			: MULTIPLY TIMES 4 FOR FW TABLE LOOKUP
	LHL	R14,MTTINT,,		:MEASUREMENT INTERVAL IN SECS IN R14
	LIS	R3,0
	LHL	R4,KSPCPS,R1		:GET LINK'S CPS RATE,
	MR	R3,R14			: COMPUTE NUMBER OF CHARACTERS OVER 
	ST	R4,KS.PCO+XKSSKD	: REPORTING INTERVAL AND SAVE

	LA	R2,XKSM01		:'LOGICAL LINK CHARACTERS'
	JAL	R7,TYPASC,,		:HEADER LINE
	LA	R2,XKSM03		:'CPS IN :'
	JAL	R7,TYPASC,,
	L	R2,KS.LMI+XKSSKD	:LAST MINUTE'S LOGICAL CHARS IN
	DHR	R2,R14			:COMPUTE NUMBER PER SECOND
	LR	R10,R3			:SAVE FOR LATER
	JAL	R9,TYPFWD,,		: AND DISPLAY
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPASC,,
	L	R2,KS.LHI+XKSSKD	:LOGICAL CHARS IN HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	LA	R2,XKSM04		:'CPS OUT:'
	JAL	R7,TYPASC,,
	L	R2,KS.LMO+XKSSKD	:LAST MINUTE'S LOGICAL CHARS OUT
	DHR	R2,R14
	LR	R12,R3			:SAVE CPS OUT
	JAL	R9,TYPFWD,,
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPASC,,
	L	R2,KS.LHO+XKSSKD	:LOGICAL CHARS OUT HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,

	LA	R2,XKSM02		:'PHYSICAL LINK CHARACTERS'
	JAL	R7,TYPASC,,
	LA	R2,XKSM03		:'CPS IN :'
	JAL	R7,TYPASC,,
	L	R2,KS.PMI+XKSSKD	:LAST MINUTE'S PHYSICAL CHARS IN
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPASC,,
	L	R2,KS.PHI+XKSSKD	:PHYSICAL CHARS IN HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	LA	R2,XKSM04		:'CPS OUT:'
	JAL	R7,TYPASC,,
	L	R2,KS.PMO+XKSSKD	:LAST MINUTE'S PHYSICAL CHARS OUT
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPASC,,
	L	R2,KS.PHO+XKSSKD	:PHYSICAL CHARS OUT HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,

	LA	R2,XKSM06		:'PACKET OVERHEAD'
	JAL	R7,TYPASC,,
	LA	R2,XKSM07		:'IN :'
	JAL	R7,TYPASC,,
	L	R3,KS.PMI+XKSSKD	:PACKET CHARACTERS IN
	LR	R4,R3
	S	R3,KS.LMI+XKSSKD	:PACKET - LOGICAL = OVERHEAD CHARACTERS
	JAL	R9,DECPER,,		:COMPUTE PACKET OVERHEAD IN
	LA	R2,XKSM08		:'OUT :'
	JAL	R7,TYPASC,,
	L	R3,KS.PMO+XKSSKD	:PACKET CHARACTERS OUT
	LR	R4,R3
	S	R3,KS.LMO+XKSSKD
	JAL	R9,DECPER,,		:COMPUTE PACKET OVERHEAD OUT

	LA	R2,XKSM09		:'BANDWIDTH UTILIZATION'
	JAL	R7,TYPASC,,
	LA	R2,XKSM07		:'IN :'
	JAL	R7,TYPASC,,
	L	R4,KS.PCO+XKSSKD	:RETRIEVE LINK'S CPM RATE
	L	R3,KS.PMI+XKSSKD	:LAST MINUTE'S CHARS IN
	JAL	R9,DECPER,,		:COMPUTE BANDWIDTH UTILIZATION IN
	LA	R2,XKSM08		:'OUT :'
	JAL	R7,TYPASC,,
	L	R4,KS.PCO+XKSSKD
	L	R3,KS.PMO+XKSSKD	:LAST MINUTE'S CHARS OUT
	JAL	R9,DECPER,,		:COMPUTE BANDWIDTH UTILIZATION OUT

	LA	R2,XKSM22		:'CHAR/SEC PER CIRCUIT'
	JAL	R7,TYPASC,,
	JAL	R8,CHNCNT		:COUNT NUMBER OF CHANS ACTIVE ON LINK
	LR	R14,R3			:SAVE IT
	JEFS	XKS11			:DONT DIVIDE BY ZERO		###OAS
	LR	R2,R10			:MOVE OVER CPS IN
	DHR	R2,R14			:GET CPS PER CHANNEL
XKS11	JAL	R9,TYPHWD,,		:AND DISPLAY##AL
	LA	R2,XKSM23		:'OUT :'
	JAL	R7,TYPASC,,
	LR	R3,R14			:DONT DIVIDE BY ZERO		###OAS
	JEFS	XKS12			:				###OAS
	LR	R2,R12
	DHR	R2,R14			:GET CPS PER CHANNEL OUT
XKS12	JAL	R9,TYPHWD,,		:DISPLAY##AL
	LA	R2,XKSM24		:'CIRCUITS :'
	JAL	R7,TYPASC,,
	LR	R3,R14
	JAL	R9,TYPHWD,,		:DISPLAY NUMBER OF ACTIVE CHANNELS

	LA	R2,XKSM12		:'PACKET STATISTICS'
	JAL	R7,TYPASC,,		:'PACKETS/SEC :'
	LHL	R2,KS.PKM+XKSSKD
	LHL	R14,MTTINT,,		:GET PRECISE MEASUREMENT INTERVAL
	DHR	R2,R14			:FORM PACKETS/SEC
	JAL	R9,TYPHWD,,		:AND DISPLAY##AL

	LA	R2,XKSM14		:'AVERAGE SIZE :'
	JAL	R7,TYPASC,,
	LHL	R3,KS.ASZ+XKSSKD
	JAL	R9,TYPHWD,,		:DISPLAY AVERAGE PACKET SIZE
	LA	R2,XKSM16		:FOLLOW IT WITH 'BYTES'
	JAL	R7,TYPASC,,

	LA	R2,XKSM13		:'RECORDS/PACKET : '		###JHL
	JAL	R7,TYPASC,,		:TYPE THE STRING		###JHL
	LHL	R3,KS.LRA+XKSSKD	:				###JHL
	JAL	R9,TYPHWD,,		:DISPLAY AVE NUMBER OF RECDS PER PKT

:	LINK DELAY (MS)
	LA	R2,XKSM15		:'LINK DELAY (MS)'
	JAL	R7,TYPASC,,	
XSSYLV	LHL	R2,SYLXAV,,		:GET AVE INTERVAL BETWEEN SYLVER RUNS
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	LR	R10,R3			:SAVE RESULT...
	JAL	R9,TYPHWD,,		:AND DISPLAY 'IN QUEUE' DELAY
	
XSRTD	LHL	R2,KS.SRA+XKSSKD	:average time between SYLVER & RTEAR
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:ADD IN RESULT
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:DISPLAY DECIMAL 'RTEAR' delay IN MS

	IF	BFLTMR
	LHL	R2,BFDOPT,,		:test control cell for dly calc method
	JN	XSRRT			:must be set non-zero for old method
:	compute avg timing pair delay, and output it
	LHL	R2,KS.BFC,KX		:must check for zero divisor
	JNFS	XS100
	LIS	R3,0
	JFS	XS110
XS100	LHL	R1,KS.BFD,KX		:read acc'ed buffer delay
	DHR	R1,R2			:quotient in R2	, remainder in R1
	JAL	R9,FSTMSC		:convert to milliseconds (ret in R3)
XS110	AR	R10,R3			:add into total delay
	JAL	R7,TYP4SP,,		:space on out...
	JAL	R9,TYPHWD,,		:and output delay time (dec ms)
	JFS	XSAQU			:jump to output outqueue delay
	EI	:BFLTMR

XSRRT	LHL	R2,KS.RRT+XKSSKD	:average time per round robin in FASTC
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:SAVE RESULT...
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:DISPLAY RMAKE 'BUFFER' DELAY

XSAQU	LHL	R2,KS.AQU+XKSSKD	:average queueing delay, RMAKE-SYLVEX
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:ACCUMULATE DELAY
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:DISPLAY 'OUT QUEUE' delay

XSXMIT	LHL	R2,KS.XMT+XKSSKD	:average packet transmission time
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:ACCUMULATE DELAY
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:display 'XMIT' delay

XSTOTL	LR	R3,R10			:GET 'TOTAL' DELAY
	JAL	R7,TYP4SP,,	
	JAL	R9,TYPHWD,,		:AND DISPLAY

	LA	R2,XKSM10		:'OVERLOAD COUNT'
	JAL	R7,TYPASC,,	
	LHL	R3,KS.OVL+XKSSKD
	JAL	R9,TYPHWD,,		:DISPLAY OVERLOAD COUNT
	JAL	R7,TYPASP,,		:10 SPACES
	LHL	R3,KS.SAT+XKSSKD
	JAL	R9,TYPHWD,,		:DISPLAY SATURATED COUNT
	JAL	R7,TYPASP,,
	LHL	R3,KS.BAM+XKSSKD
	JAL	R9,TYPHWD,,		:DISPLAY BACKLOG COUNT
	JAL	R7,TYPASP,,
	LHL	R3,KS.PKM+XKSSKD
	JAL	R9,TYPHWD,,		:DISPLAY NUMBER OF PACKETS MADE
	JAL	R7,TYP8SP,,
	L	R3,KS.NPM+XKSSKD
	JAL	R9,TYPFWD,,		:DISPLAY IDLE CALLS	

:	IF	1-ISIS		:ISIS WON'T COLLECT STAT UNTIL REL 6###JHL
	LA	R2,XKSM17		:GET ADDRESS OF HEADER
	JAL	R7,TYPASC,,		:AND OUTPUT TO SCREEN

:	KN(R11) HAS THE LINK DESC PTR FOR LINK WE'RE QUERYING
	LIS	R6,0			:STEP THROUGH LINES
XKSRX2	SLL	R6,1
	L	R3,KDLN,R6,R6		:LOOK AT LINE'S LINK DESC
	SRL	R6,1
	IF	STRHUB
	LB	R7,LTYP,R6,R6
	JE	XKSRX3			:IF STARLINE GO TO DISPLAY THE
	LB	R7,KTYP,KN
	CHI	R7,STRTYP		:MUST MATCH KD'S KTYP
	JE	XKSRX4			:IT IS STRLINK, GO TO DISPLAY
XKSRX3	EI	:STRHUB			: LAST LINE ##AL
	CR	R3,KN			:THIS IS HOW WE TELL COUSINS
	JE	XKSRX4
XKSRX6	AIS	R6,1			:NEXT LINE NUMBER
	CLHI	R6,NLINES
	JN	XKSRX2
	JAL	R7,TYPCRL,,		:FALL THROUGH WHEN ALL LINES CHECKED
	J	XKS00			:REPEAT "KS" FOR REMAINING ARGUMENTS
XKSRX4	IF	STRHUB			:##AL
	LB	R7,LTYP,R6,R6		:IF STRLINE, DISPLAY 'STAR LINK:'
	JEFS	XKSRX5
	LA	R2,XKS18A		:ADDRESS OF 'STAR LINK' STRING
	JAL	R7,TYPASC,,		:OUTPUT HEADER STRING
	LB	R3,LKNM,R11		:GET LINK NUMBER FOR SCREEN
	JFS	XKSRX7
XKSRX5	EI	:STRHUB
	LA	R2,XKSM18		:ADDRESS OF 'LINE' STRING
	JAL	R7,TYPASC,,		:OUTPUT HEADER STRING
	LR	R3,R6			:GET LINE NUMBER FOR SCREEN
XKSRX7	JAL	R9,TYPHWD		:OUTPUT IT TO SCREEN AFTER 'LINE'
	LA	R2,XKSM20		:ADDRESS OF ':'
	JAL	R7,TYPASC,,		:OUTPUT THE STRING
	JAL	R7,TYP4SP,,		:SPACE OUT...

	CLHI	R6,NLINES-SILINS	:CHECK FOR SIO LINE
	JLFS	XKSSYN			:BRANCH IF STILL IN SYNC RANGE
	LA	R2,SINMRK		:PTR TO 'N/A' STRING FOR SIO LINE
	JAL	R7,TYPASC,,		:FILL MARKING FIELD WITH TEXT
	JFS	XKSCNT			:REST OF FIELDS ARE THE SAME
XKSSYN	LHL	R3,KL.LSV,R6,R6		:GET MINUTE'S WORTH OF "MARKING"
	JAL	R9,TYPHWD
XKSCNT	JAL	R7,TYP4SP,,		:MOVE OVER ONCE...
	JAL	R7,TYP8SP,,		:MOVE OVER TWICE...
	IF	STRHUB
	LB	R3,LTYP,R6,R6		:IF STARLINE,NO MULTI-LINE LINK
	JE	XKSCN1
	LHL	R3,KS.TSV+XKSSKD	:GET MINUTE'S WORTH OF "RXMT"
	JAL	R9,TYPHWD,,
	JAL	R7,TYP8SP,,		:SPACE OVER
	LHL	R3,KS.RSV+XKSSKD	:GET MINUTE'S WORTH OF "XMT"
	JAL	R9,TYPHWD,,
	JAL	R7,TYPCRL,,		:REPEAT 'KS' FOR REMAINING ARG.
	J	XKS00
	EI	:STRHUB
XKSCN1	LHL	R3,KL.TSV,R6,R6		:GET MINUTE'S WORTH OF "RXMT"
	JAL	R9,TYPHWD,,
	JAL	R7,TYP8SP,,		:SPACE OVER
	LHL	R3,KL.RSV,R6,R6		:GET MINUTE'S WORTH OF "XMT"
	JAL	R9,TYPHWD,,
	J	XKSRX6			:GO BACK FOR MORE LINES ON THIS LINK
SINMRK	SC	+N/A"20"20"20+		:MARKING FIELD FOR SIO LINE
:	ELSE 	:1-ISIS			:###JHL
:	JAL	R7,TYPCRL
:	J	XKS00			:REPEAT FOR REMAINING ARGUMENTS
:	EI	:1-ISIS			:###JHL

	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV)		:##AL

::*********************************************************************
::
::	SUBROUTINE:	CHNCNT:
::	FUNCTION:	COUNT NUMBER OF ACTIVE CHANNELS ON LINK
::	THIS VALUE IS IDENTICAL TO THE CELL 'ANCHN' FOR T-II LINKS.
::	FOR T-I LINKS, 'ANCHN' IS FREQUENTLY IN ERROR, AND JAL R8,CNTCHN
::	SHOULD BE USED
::	CALLING SEQ:	JAL	R8,CHNCNT
::	INPUT:		XKNSAV, XKDSAV = KN AND KD FOR LINK
::	OUTPUT:		R3 = COUNT
::	DESTROYED:	R0,R1,R2,R4,R9
::
::*********************************************************************

CHNCNT	HS	0
	LHL	R2,XKNSAV,XD		:GET LINK NUMBER
	LHL	R2,LKZFKN,R2,R2 	:GET ABS CHANNEL 0
	SRLS	R2,3			:DIVIDE BY 8
	LA	R4,ACP,R2,		:GET BEGIN OF ACP ARRAY FOR THIS LINK
	L	R2,XKDSAV,XD		:GET LINK DESCRIPTOR
	LHL	R2,NCHN,R2,		:GET NUMBER OF CHANNELS ASSIGNED
	SRLS	R2,4			:DIVIDE BY 16
	JAL	R9,COUNT0		:GET NUMBER OF ACTIVE CHANNELS ON LINK
	JR	R8

	SUBTTL	XRAY (Trace link/line events - TL, TN, TM)

	IF	(XRSZLV-1)		:##AL

	IF	2-XRYTMC	:###wjl
	IF	TSTSZE

::*********************************************************************
::
::	COMMAND:	XTLINK:	TL
::	FUNCTION:	SET/RESET TSLINK TO ENABLE/DISABLE LINK TRACE FUNCTION
::	INPUT:		LINK TO BE TRACED IS SINGLE ARGUMENT, ENTERED IN OCTAL.
::			IF NO ARGUMENT, JUST DISPLAY CURRENT CONTENTS.
::
::*********************************************************************

XTLINK	HS	0
	LHL	R2,ARGCT,XD		:ANY ARGUMENTS?
	SIS	R2,4
	JL	XTLDSP			:NO, GO DISPLAY

	L	R1,VALUE1,XD		:ARGUMENT=0?			###wjl
	JE	XTLIN1			:YES, TURN OFF TRACE
	LHL	R1,TSLINK		:ARGUMENT NOT 0, MAKE SURE WE'RE NOT
	JN	XTLDSP			:ALREADY TRACING,SHOW LINK BEING TRACED
	L	R3,VALUE1,XD		:GET NODE NUMBER		###SHM
	JAL	R9,OCTHXR		:CONVERT TO HEX			###SHM
	LR	R1,R3			:				###wjl
	JAL	R9,XFNDLK		:make sure the neighbor is there###wjl
	J	COMERR			:(immed) it isn't		###wjl
XTLIN1  STH	R1,TSLINK		:(+4) STORE IN TSLINK

XTLDSP	LA	R2,XTLMS1
	JAL	R7,TYPASC,,		:IDENTIFY VALUE BEING DISPLAYED
	LHL	R3,TSLINK
	JAL	R9,HEXOCT		:CONVERT TSLINK VALUE TO OCTAL AND
        JAL	R9,TYP5CH,,		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
	JAL	R7,TYPCRL,,		:CR/LF
	J	XRPRMT			:DONE

::*********************************************************************
::
::	COMMAND:	XTLINE:	TN
::	FUNCTION:	SET/RESET TSLINE TO ENABLE/DISABLE LINE TRACE FUNCTION
::	TRACE LINE WILL TRACE ONLY HEADER OF RECEIVED EVENTS ON UNASSIGNED
::	LINES (ONLY IN FOREGROUND TABLE)	###OAS
::	INPUT:		LINE TO BE TRACED IS SINGLE ARGUMENT, IN DECIMAL.
::			IF NO ARGUMENT, JUST DISPLAY CURRENT CONTENTS.
::
::*********************************************************************

XTLINE	HS	0
	LHL	R2,ARGCT,XD		:ANY ARGUMENTS?
	SIS	R2,4
	JL	XTNDSP			:NO, GO DISPLAY

	LH	R3,VALUE1+2,XD		:GET ARGUMENT
	CI	R3,0FFFFFFFF		:ARGUMENT = FFFFFFFF
	JE	XTNIN1			:YES, TURN OFF TRACE
	LH	R1,TSLINE		:ARGUMENT NOT FFFF, MAKE SURE WE'RE NOT
	JGE	XTNDSP			:TRACING - SHOW LINE BEING TRACED
	JAL	R9,DECHEX		:CONVERT TO HEX
	J	DHXBAD			:(immed) BAD RADIX
	CLHI	R3,NLINES-1		:(+4)compare with number of lines##wjl
	JG	COMERR			:greater??			###wjl
	SLLS	R3,1			:STORE 2*LINE#
XTNIN1	STH	R3,TSLINE		:STORE IT IN TSLINE

XTNDSP	LA	R2,XTNMS1
	JAL	R7,TYPASC,,		:IDENTIFY VALUE BEING DISPLAYED
	LH	R3,TSLINE
	JLFS	XTNIN2			:VALUE IS FFFF
	SRLS	R3,1			:DISPLAY TRUE LINE#
	JAL	R9,HEXDEC		:CONVERT TSLINE VALUE TO DECIMAL AND
XTNIN2	JAL	R9,TYPHW,,		: DISPLAY
	JAL	R7,TYPCRL,,		:CR/LF
	J	XRPRMT			:DONE

::*********************************************************************
::
::	COMMAND:	XTSDAT:	TM
::	FUNCTION:	DISPLAY DATA GATHERED FROM TSLINK/TSLINE OPTION
::	INPUT:	IF TERMINATED WITH 'F' (TM F) DISPLAYS FOREGROUND (TSFTBL)
::		IF TERMINATED WITH 'B' (TM B) DISPLAYS BACKGROUND (TSBTBL)
::
::*********************************************************************

XTSDAT	HS	0
	LHL	R14,TSLINK		:SAVE POTENTIAL NEIGHBOR NUMBER
	EXHR	R14,R14			:IN HO HW			###OAS
	LHL	R2,TSLINE		:AND TRACED LINE		###OAS
	OR	R14,R2			:IN LO HW			###OAS
	CLHI	R3,0F			:LAST ARGUMENT ENTERED = 0F?
	JE	XTSDA9			:YES
	CLHI	R3,0B			:NO,TEST FOR 0B
	JN	COMERR			:NO,ERROR

	LA	R2,XTSBAK		:YES, BACKGROUND MESSAGE
	LHL	R12,TSBPTR		:R12 = BACKGROUND TABLE POINTER
	STH	R12,TSPBAK		:TABLE POINTER BACKUP
	LI	R11,TSBTBL		:R11 = BACKGROUND TABLE ADDRESS
	LHI	R10,TSNBTO		:R10 = BACKGROUND TEXT OFFSET
	JFS	XTSDA8

XTSDA9	LA	R2,XTSFOR		:FOREGROUND MESSAGE
	LHL	R12,TSFPTR		:R12 = FOREGROUND POINTER
	STH	R12,TSPBAK
	LI	R11,TSFTBL		:R11 = FOREGROUND TABLE ADDRESS
	LIS	R10,0			:R10 = FOREGROUND TEXT OFFSET

XTSDA8	ST	R14,XTSSAV		:SAVE NEIGHBOR AND LINE # IN CASE OF ^C
	LCS	R0,1			:###OAS
	STH	R0,TSLINE		:TURN OFF LINE TRACE WHILE DISPLAYING
	LIS	R0,0			:###OAS
	STH	R0,TSLINK		:TURN OFF LINK TRACE WHILE DISPLAYING
	JAL	R7,TYPASC,,		:DISPLAY HEADER

XTSDA1	LB	R1,0,R12,R11		:GET EVENT BYTE
	NHI	R1,0F			:KEEP JUST 4  BITS FOR SAFETY
	SLLS	R1,3			:FORM 2-WORD INDEX
	LA	R2,XTSMSG-1,R1,R10	:GET APPROPRIATE ASCII TEXT
	LIS	R0,8			:MESSAGE LENGTH
	JAL	R7,TYPAS1,,
	JAL	R7,TYP4SP,,		:ALSO TYPE 4 SPACES
	LIS	R5,5			:TYPE 5 BYTES
	LA	R6,1,R11,R12
	JAL	R8,TYPNBY,,
	LHL	R3,6,R11,R12		:GET FASTC
	JAL	R9,TYPHW,,		:AND TYPE IT
	JAL	R7,TYPCRL,,		:TYP CR-LF

	SIS	R12,TSESZE		:BACK UP ONE ENTRY
	JGEFS	XTSDA7			:NON-NEGATIVE
	AHI	R12,TSTSZE		:NEGATIVE, CORRECT FOR WRAP
XTSDA7	CLH	R12,TSPBAK		:COME FULL CIRCLE?
	JEFS	XTSDA2			:YES
	J	XTSDA1			:NO, KEEP DISPLAYING

XTSDA2	L	R14,XTSSAV		:RECOVER NEIGHBOR NUMBER	###OAS
	STH	R14,TSLINE		:RESTORE TSLINE CELL		###OAS
	EXHR	R14,R14			:AND				###OAS
	STH	R14,TSLINK		:RESTORE TSLINK CELL
	LI	R14,0FFFF		:INIT TO 0FFFF			###AL
	ST	R14,XTSSAV		:CLEAR SAVE CELL		###OAS
	J	XRCRLF			:AND RETURN TO MAIN LOOP

	EI	:TSTSZE
	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV-1)		:##AL

	SUBTTL	XRAY (Patch query - PQ)

	IF	(XRSZLV)		:##AL

::*********************************************************************
::
::	COMMAND:	PTCQRY:	PQ
::	FUNCTION:	DISPLAY PATCH HISTORY TABLE	  	###OAS
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl

	NOLIST
PCQDS1	SC	/"0D"0APATCH HISTORY TABLE   VERSION - /
PCQDS2	SC	/"0D"0A"0AYEAR  MODY  TIME  NAME"0D"0A----  ----  ----  ----------/
	LIST
PTCQRY	HS	0
	LR	R2,R2			:ZERO ARGS?
	JN	COMERR			:NO, ERROR
	LA	R2,PCQDS1
	JAL	R7,TYPASC,,		:BANNER
	LHI	R3,VERSION		:DISPLAY NODE CODE
	JAL	R9,HEXOCT		:VERSION NUMBER IN OCTAL
	JAL	R9,TYPFW	
	LA	R2,PCQDS2		:TABLE HEADERS
	JAL	R7,TYPASC,,
	LIS	R14,0			:PATCH HISTORY TABLE INDEX
PTCQR1	JAL	R7,TYPCRL,,		:CR/LF
	CLHI	R14,PHSIZE		:AT END OF TABLE?
	JGE	XPRMPT			:YES, EXIT.
	LB	R0,PATHIS+1,R14,	:CHECK FOR YEAR 1900 (NULL ENTRY)
	JE	XPRMPT			:END, EXIT.

	LHL	R3,PATHIS,R14,		:GET YEAR (19XX)
	JAL	R9,TYPHW
	LHL	R3,PATHIS+2,R14,	:GET DATE (MODY)
	JAL	R9,TYPHW
	LHL	R3,PATHIS+4,R14,	:GET TIME (HHMM)
	JAL	R9,TYPHW
	LA	R2,PATHIS+5,R14,	:POINT TO USERNAME-1
	LIS	R0,0A			:10 CHAR USERNAME
	JAL	R7,TYPAS1,,		:DISPLAY USERNAME

	AHI	R14,10			:POINT TO NEXT PATHIS CELL
	J	PTCQR1			:AND TRY AGAIN

 	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV)		:##AL

	SUBTTL	XRAY (Interface statistics commands - HS, IS, IR)

	IF	(XRSZLV-1)		:##AL
	IF	2-XRYTMC		:###wjl

::*********************************************************************
::
::	COMMAND:	HSTDS:	HS
::	FUNCTION:	DISPLAY HOST INFORMATION
::	INPUT:	HS - DISPLAY, HS <HOST#1.. HOST#7> H - DISPLAY CERTAIN HOSTS
::		HS <SLOT#1..SLOT#7> S - DISPLAY CERTAIN SLOTS, 
::		HS U - DISPLAY ONLY UP OR SHUT HOSTS
::	###OAS
::
::*********************************************************************

	IF	1-T2GATE	:GATEWAY NO >HS CMD##AL

HSTDS1	HS	0			:HOST SLOT PRODUCT DESCRIPTIONS
	NOLIST
ASAT	SC	/TYMSAT/
ACOM	SC	/TYMCOM/
XCOM	SC	/X25-X75/
PBH	SC	/3270 HOST INTERFACE/
PBT	SC	/3270 TERMINAL INTERFACE/
MSAT	SC	/MICRONODE KERNEL/
I21S	SC	/ISIS KERNEL/
TIINC	SC	/TYMNET-II NODE CODE/
XXB	SC	/2020 BASE/
BBXS	SC	/X780-MULTILEAVING/
ELF	SC	/ELF/
I2G1	SC	/ISIS GATEWAY/
I2T1	SC	/ISIS TYMNET-I NODE CODE/
LDII	SC	/LOADII/
MRLN	SC	/MERLIN/
ONTM	SC	/ONTYME/
PRB	SC	/PROBE/
RAM	SC	/RAM/
SPVSR	SC	/SUPERVISOR/
NVAL	SC	/VAL-NETVAL/
ISCS	SC	/ISIS CONSAT/
BOOT	SC	/ENGINE BOOT/
SAKER	SC	/STAND-ALONE KERNEL/
SPKER	SC	/SPLIT STAND-ALONE KERNEL/
SDLC	SC	/SDLC INTERFACE/
TNTT	SC	/TINET INTERFACE/
UTSH	SC	/UTS 4000 INTERFACE/
NTRH	SC	/NTR INTERFACE/
VMB	SC	/VMB INTERFACE/
EWS	SC	/ENGINE WORK STATION/
NEM	SC	/NETWORK EVENT MONITOR/
TMCS	SC	/TMCS/
OUTDIA	SC	/OUTDIAL/
CMTI	SC	/3270 VIRTUAL HOST DRIVER/
TRSW	SC	/TRANSACTION SWITCH/
ITI	SC	/SLIGOS TRANSACTION SERV/
UTST	SC	/UTS VIRTUAL HOST DRIVER/
TOM	SC	/TYMCOM OPERATIONS MON/
LEM	SC	/LEMCOM 370 BASE/
MUX	SC	/MULTIPLEXOR/
UTIL	SC	/SUPERVISOR UTIL SLAVE/
PBOM	SC	/POLLED BISYNC OPS MON/
SOM	SC	/SDLC OPERATIONS MON/
PAOM	SC	/POLLED ASYNC OPS MON/
CRED	SC	/CIRCUIT REDIRECT/
TLXG	SC	/TELEX GATEWAY/
XOM	SC	/X25-X75 OPERATIONS MON/
NTRT	SC	/NTR TERMINAL INTERFACE/
XPC	SC	/X.PC SERVER/
SNAT	SC	/SNA TERMINAL INTERFACE/
SNAH	SC	/SNA HOST INTERFACE/
TNTH	SC	/TINET HOST INTERFACE/
CMTU	SC	/UTS CHAR MODE TRMNL/
ACCT	SC	/ACCOUNT SLAVE/
ELSV	SC	/ELF SLAVE/
ERLG	SC	/ERLOG SLAVE/
NAD	SC	/NAD ASSEMBLER/
NTCN	SC	/NETWORK CONSOLE/
SYSM	SC	/SYSMSG1 SLAVE/
UN2	SC	/UN2 SLAVE/
ISRM	SC	/ISIS SYSTEM RECOVERY MOD/
ONTR	SC	/ONTYME DB RESTORE PGM/
OBJN	SC	/PASCAL OBJECT-NIB CNVRTR/
CPAS	SC	/CONCURRNT PASCAL COMPILER/
STAR	SC	/PASCAL STTMNT ADDR GNRTR/
TMDM	SC	/TMCS DISK MAINT PGM/
TMRE	SC	/TMCS RESOURCE EST PGM/
NMDM	SC	/NEM DISK MAINT PGM/
NMRE	SC	/NEM RESOURCE EST PGM/
NCDM	SC	/NETCON DISK MAINT PGM/
NCRE	SC	/NETCON RESOURCE ESTIMATOR/
NVDM	SC	/NETVAL DISK MAINT PGM/
MSRV	SC	/MENU SERVER/
SHMN    SC      /SHAMAN/
XPI	SC	/XPI/
CPPP	SC	/CPPP/
ATC	SC	/ATC/
ODNU	SC	/OUTDIAL NUCLEUS/
OPAS	SC	/OUTDIAL PASCAL COMPILER/
ACUS	SC	/AUTO CALL UNIT SERVER/
X25	SC	/XCOM - X.25/
X75	SC	/XCOM - X.75/
IHSA	SC	/IHSA/
DMAC	SC	/MAC DIAGNOSTIC/
MLI	SC	/MLI-MULTILEAVING BISYNC/
ISRS	SC	/ISIS SLOT RECOVER SYSTEM/
MXPI	SC	/MXP/
CICL	SC	/ICL PROTOCOL/
HICL	SC	/ICL PROTOCOL - HOST/
TICL	SC	/ICL PROTOCOL - TERMINAL/
T2G2	SC	/TYMNET II GATEWAY/
DMEM	SC	/ENGINE MEMORY DIAGNOSTIC/

HSTDS2	SC	/"0D"0AHOST NO.  SLOT  PID   PRODUCT DESCRIPTION       STAT  TIME OF STAT  CT  DOPI"0D"0A/
HSTDS3	SC	/--------  ----  ----  ------------------------  ----  ------------  --  ----"0D"0A/
HSTDS4	AC	/ UP /		:HOST STATUS TEXT
	AC	/DOWN/
	AC	/SHUT/
	AC	/GONE/
HSTDS5	SC	/N/		:IIX, ORG/DEST ONLY, PORTS AVAILABLE INDICATORS
	SC	/Y/
HSTDS6	SC	/"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20/			:26 SPACES
	LIST

BSEPID	EQ	31			:###jhl
PIDTBL	HS	0			:pointer table for PID strings
PID31	HC	ASAT-SEGD
PID32	HC	ACOM-SEGD
PID33	HC	XCOM-SEGD
PID34	HC	PBH-SEGD
PID35	HC	PBT-SEGD
PID36	HC	MSAT-SEGD
PID37	HC	I21S-SEGD
PID38	HC	TIINC-SEGD
PID39	HC	XXB-SEGD
PID3A	HC	BBXS-SEGD
PID3B	HC	ELF-SEGD
PID3C	HC	I2G1-SEGD
PID3D	HC	I2T1-SEGD
PID3E	HC	LDII-SEGD
PID3F	HC	MRLN-SEGD
PID40	HC	ONTM-SEGD
PID41	HC	PRB-SEGD
PID42	HC	RAM-SEGD
PID43	HC	SPVSR-SEGD
PID44	HC	NVAL-SEGD
PID45	HC	ISCS-SEGD
PID46	HC	BOOT-SEGD
PID47	HC	SAKER-SEGD
PID48	HC	SPKER-SEGD
PID49	HC	SDLC-SEGD
PID4A	HC	TNTT-SEGD
PID4B	HC	UTSH-SEGD
PID4C	HC	NTRH-SEGD
PID4D	HC	VMB-SEGD
PID4E	HC	EWS-SEGD
PID4F	HC	NEM-SEGD
PID50	HC	TMCS-SEGD
PID51	HC	OUTDIA-SEGD
PID52	HC	CMTI-SEGD
PID53	HC	TRSW-SEGD
PID54	HC	ITI-SEGD
PID55	HC	UTST-SEGD
PID56	HC	TOM-SEGD
PID57	HC	LEM-SEGD
PID58	HC	MUX-SEGD
PID59	HC	UTIL-SEGD
PID5A	HC	PBOM-SEGD
PID5B	HC	SOM-SEGD
PID5C	HC	PAOM-SEGD
PID5D	HC	CRED-SEGD		:###LH
PID5E	HC	TLXG-SEGD		:###LH
PID5F	HC	XOM-SEGD		:###LH
PID60	HC	NTRT-SEGD		:###LH
PID61	HC	XPC-SEGD		:###LH
PID62	HC	SNAT-SEGD		:###LH
PID63	HC	SNAH-SEGD		:###LH
PID64	HC	TNTH-SEGD		:###LH
PID65	HC	CMTU-SEGD		:###LH
PID66	HC	ACCT-SEGD		:###LH
PID67	HC	ELSV-SEGD		:###LH
PID68	HC	ERLG-SEGD		:###LH
PID69	HC	NAD-SEGD		:###LH
PID6A	HC	NTCN-SEGD		:###LH
PID6B	HC	SYSM-SEGD		:###LH
PID6C	HC	UN2-SEGD		:###LH
PID6D	HC	ISRM-SEGD		:###LH
PID6E	HC	ONTR-SEGD		:###LH
PID6F	HC	OBJN-SEGD		:Pascal Object to Nib Converter
PID70	HC	CPAS-SEGD		:Concurrent Pascal Compiler
PID71	HC	STAR-SEGD		:Pascal Statement Address Generator
PID72	HC	TMDM-SEGD		:TMCS Disk Maintenance Program
PID73	HC	TMRE-SEGD		:TMCS Resource Estimation Program
PID74	HC	NMDM-SEGD		:NEM Disk Maintenance Program
PID75	HC	NMRE-SEGD		:NEM Resource Estimation Program
PID76	HC	NCDM-SEGD		:Network Console Disk Maint Program
PID77	HC	NCRE-SEGD		:Network Console Resource Estimator
PID78	HC	NVDM-SEGD		:Netval Disk Maintenance Program
PID79	HC	MSRV-SEGD		:Menu Server
PID7A   HC      SHMN-SEGD       	:Shaman      			###LH
PID7B	HC	XPI-SEGD		:Extended Processor Interface	###wjl
PID7C	HC	CPPP-SEGD		:Concurrent Pascal Preprocessor	###wjl
PID7D	HC	ATC-SEGD		:Asynchronous Terminal Concentrator
PID7E	HC	ODNU-SEGD		:Outdial Concurrent Pascal Nucleus#wjl
PID7F	HC	OPAS-SEGD		:Outdial Pascal Compiler	###wjl
PID80	HC	ACUS-SEGD		:Outdial/Bisync Auto Call Unit Server
PID81	HC	X25-SEGD		:XCOM - X.25			###wjl
PID82	HC	X75-SEGD		:XCOM - X.75			###wjl
PID83	HC	IHSA-SEGD		:IHSA				###wjl
PID84	HC	DMAC-SEGD		:Universal Engine MAC Diagnostic###wjl
PID85	HC	MLI-SEGD		:DOS/MLI-Multileaving Bisync-DOS/VSE
PID86	HC	ISRS-SEGD		:ISIS Slot Recovery System	###wjl
PID87	HC	MXPI-SEGD		:MXP				###wjl
PID88	HC	CICL-SEGD		:ICL Protocol			###wjl
PID89	HC	HICL-SEGD		:ICL Protocol - Host		###wjl
PID8A	HC	TICL-SEGD		:ICL Protocol - Terminal	###wjl
PID8B	HC	T2G2-SEGD		:Tymnet II Gateway		###wjl
PID8C	HC	DMEM-SEGD		:Engine Memory Diagnostic	###wjl
PIDTBZ	EQ	.-PIDTBL

HSTDS	HS	0
	LR	R12,R1			:SAVE LAST CHAR ENTERED FOR LATER STUDY
	LR	R14,R2			:GET ARG COUNT
	JEFS	HSTDI0			:WITHOUT ARGS, CAN CLOSE WITH ANYTHING
	CLHI	R12,ASCH		:DID USER CLOSE WITH AN H(x48)?
	JEFS	HSTDI0			:YES, VALID
	CLHI	R12,ASCS		:DID USER CLOSE WITH AN S(x53)?
	JN	COMERR			:ONLY H OR S ARE VALID WITH ARGS
HSTDI0	LA	R2,HSTDS2		:DISPLAY HEADER BANNERS
	JAL	R7,TYPASC,,
	LA	R2,HSTDS3
	JAL	R7,TYPASC,,

HSTDI1	LIS	R11,0			:INIT HOST INDEX
HSTDI2	LHL	R1,HOSTN,R11,R11,	:CHECK HOST ENTRY
	JE	HSTDI6			:NO ENTRY 
	LR	R14,R14			:ANY ARGS
	JE	HSTDI4			:NO ARGS, DON'T CHECK HOST OR SLOT #
	L	R3,VALUE1-4,R14,XD	:GET THIS ARG
	CLHI	R12,ASCH		:USER CLOSE WITH H(x48)?
	JNFS	HSTDI5			:NO, MUST HAVE BEEN AN S
	JAL	R9,DECHEX		:CONVERT ENTERED DECIMAL VALUE
	J	DHXBAD			:(immed) RADIX VIOLATION
	CLH	R3,HOSTN,R11,R11,	:(+4) DOES ENTRY HOST NUMBER MATCH ?
	JE	HSTDI9			:YES, DISPLAY THIS ENTRY
	JFS	HSTDI7
HSTDI5	SLLS	R3,2			:FORM 4*SLOT NUMBER
	CLB	R3,HSTKEY,R11,		:COMPARE SLOT KEY FOR THIS HOST ENTRY
	JE	HSTDI9			:MATCH, DISPLAY THIS ENTRY
HSTDI7	AIS	R11,1			:BUMP HOST INDEX, CHECK FOR MATCH AGAIN
	CLHI	R11,NHOSTS		:ALL ENTRIES CHECKED?
	JL	HSTDI2			:NO, TRY FOR MATCH
	J	HSTDI3			:GIVE UP ON THIS ARG

HSTDI4	CLHI	R12,ASCU		:DID USER CLOSE WITH U(x55)?
	JNFS	HSTDI8			:NO, DISPLAY ALL ENTRIES
	LB	R2,HSTATN,R11,		:CHECK STATUS
	NHI	R2,0060			:CHECK IF BIT 1 OF LO BYTE IS SET
	JN	HSTDI6			:DOWN OR GONE (BIT 1 SET) DON'T DISPLAY
	JFS	HSTDI8

HSTDI9	OI	R14,80000000		:FLAG END PASS (BIT 0 OF R14)

HSTDI8	LHL	R3,HOSTN,R11,R11,	:DISPLAY HOST NUMBER
	JAL	R9,TYPFWD
	LA	R2,ASC1SP
	JAL	R7,TYPASC,,
					:DISPLAY SLOT NUMBER          	###LH
	LB	R3,HSTKEY,R11,		:SLOT# * 4 IF NON-MXP.  (00SS)	###LH
					:SLOT#,MACHINE# IF MXP. (00SM)	###LH
        IF      MXPNM       		:IF MXP, CONVERT (00SM) TO (0M0S)##LH
        EXBR    R2,R3           	: R2 = (SM00)			###LH
        NHI     R2,0F00         	: R2 = (0M00)			###LH
        SRHLS   R3,4            	: R3 = (000S)			###LH
        OR      R3,R2           	: R3 = (0M0S)			###LH
        ELSE	:not MXPNM      	:IF NON-MXP, COMPUTE SLOT#	###LH
	SRLS	R3,2			:(TRUE SLOT#. NOT SLOT# * 4)	###LH
        EI      :MXPNM
        JAL     R9,TYPHW	        :TYPE 4 DIGITS AS (00SS) IF NON-MXP.
	                               	:TYPE 4 DIGITS AS (0M0S) IF MXP.###LH
	LB	R3,HSTYPE,R11,		:DISPLAY PID CODE
	JAL	R9,TYPHW
	SHI	R3,BSEPID		:ensure PID range is OK		###jhl
	JL	HSTD12			:no. Too low
	CLHI	R3,PIDTBZ/2
	JG	HSTD12			:no. Too high
	LHL	R2,PIDTBL,R3,R3		:get offset to PID string descriptor
	LI	R2,SEGD,R2		:add in base offset (SEGD)
	LR	R3,R2			:save pointer to string character count
	JAL	R7,TYPASC
	LHI	R0,1A			:COMPUTE 26 - CHARACTERS
	LB	R2,0,R3			:get byte count of PID string	###jhl
	SR	R0,R2			:subtract length from field size $A26
	LA	R2,HSTDS6		:26 BLANKS
	JAL	R7,TYPAS1		:BYTE COUNT IN R0
	JFS	HSTD13
HSTD12	LA	R2,HSTDS6		:NO KNOWN PID, DISPLAY 26 BLANKS
	JAL	R7,TYPASC
HSTD13	LB	R1,HSTATN,R11,		:GET EXPANDED HOST STATUS
	NHI	R1,00C0			:ISOLATE HOST STATUS (BITS 0,1-LO BYTE)
	SRLS	R1,4			:FORM INDEX (FW)
	LIS	R0,4			:4 CHARACTERS ALWAYS
	LA	R2,HSTDS4-1,R1		:DISPLAY HOST STATUS TEXT
	JAL	R7,TYPAS1		:BYTE COUNT IN R0
	LA	R2,ASC2SP
	JAL	R7,TYPASC
	SLLS	R11,1			:FORM FULLWORD INDEX
	L	R2,HSTTIM,R11,R11,	:INTO HOST STATUS TIME
	ST	R2,GMTNOW,,		:STORE FOR GMTCNV
	JAL	R9,GMTCNV		:TYPE IT
	LA	R2,ASC2SP
	JAL	R7,TYPASC
	SRLS	R11,1			:RESTORE R11
	LB	R3,HSTCST,R11,		:GET HOST COST AND DISPLAY IT
	JAL	R9,TYPBYT,,		:FOLLOWED BY 2 SPACES
	LB	R0,HSTATN,R11,		:GET EXPANDED HOST STATUS
	NHI	R0,000C			:ISOLATE ORG/DEST BITS (4,5 OF LO BYTE)
	JE	HSTD20			:BOTH NO
	CLHI	R0,000C			:ARE BOTH BITS SET?
	JE	HSTD20			:YES, BOTH NO
	LIS	R3,2			:ASSUME Y N (DEST ORG ONLY)
	NHI	R0,0008			:WHICH ONE IS SET?
	JEFS	HSTD21			:DESTINATION ONLY HOST
	XHI	R3,2			:MAKE IT N Y (DEST ORG ONLY)
HSTD21	LA	R2,HSTDS5,R3		:DISPLAY 'Y' DEST ONLY
	JAL	R7,TYPASC
	XHI	R3,2			:TOGGLE NEXT ONE
	LA	R2,HSTDS5,R3
	JAL	R7,TYPASC
	JFS	HSTD22
HSTD20	LA	R2,HSTDS5		:N N (DEST ORG ONLY)
	JAL	R7,TYPASC
	LA	R2,HSTDS5
	JAL	R7,TYPASC

HSTD22	LIS	R3,0			:INDEX FOR 'N'
	LB	R0,HSTATN,R11,		:CHECK IF OUT OF PORTS
	THI	R0,0020			:(BIT 2 OF OF LO BYTE)
	JNFS	HSTD23			:OUT OF PORTS 'N'
	LIS	R3,2			:INDEX FOR 'Y'
HSTD23	LA	R2,HSTDS5,R3		:DISPLAY IT
	JAL	R7,TYPASC
	LB	R0,HSTATN,R11,		:CHECK IF IIX
	LIS	R3,0			:INDEX FOR 'N'
	THI	R0,0010			:CHECK IF IIX HOST
	JEFS	HSTD24			:NOT IIX
	LIS	R3,2			:INDEX FOR 'Y'
HSTD24	LA	R2,HSTDS5,R3		:DISPLAY IT
	JAL	R7,TYPASC
	JAL	R7,TYPCRL

HSTDI6	LR	R14,R14			:CHECK FOR FORCED END OF PASS
	JGEFS	HSTD25			:DUE TO MATCH FOUND (HO BIT SET)
	NI	R14,7FFFFFFF		:CLEAR HO BIT
	JFS	HSTDI3
HSTD25	AIS	R11,1			:BUMP HOST INDEX
	CLHI	R11,NHOSTS		:ALL ENTRIES DISPLAYED?
	JL	HSTDI2			:NO, TRY SOME MORE
HSTDI3	SIS	R14,4			:DECREMENT ARG COUNT, ANY LEFT?
	JG	HSTDI1			:YES, TRY SOME MORE
	J	XRCRLF			:RETURN TO MAIN LOOP

	EI	:1-T2GATE

::*********************************************************************
::
::	COMMAND:	ISSTAT:	IS
::	FUNCTION:	DISPLAY RELEVANT ISIS/DISPATCHER INTERFACE DATA
::
::*********************************************************************

	IF	ISIS

ISSTAT	HS	0
	LA	R2,XISHD1		:EXPLANATORY HEADER
	JAL	R7,TYPASC

	LA	R10,DISICC		:8 HALFWORD FIELDS,
	JAL	R8,TYP8HW		: DISPLAYED WITH SPACES TO SEPARATE

	J	XPRMPT			:DONE

	EI	:ISIS

::*********************************************************************
::
::	COMMAND:	ISRING:	IR
::	FUNCTION:	DISPLAY ISIS/DISPATCHER RING POINTERS
::
::*********************************************************************

	IF	ISIS

ISRING	HS	0
	LA	R2,XIRHD1		:EXPLANATORY HEADER
	JAL	R7,TYPASC

:	INPUT RING
	LHL	R3,DRIF,,		:FILL POINTER, NODE INDEXED
	JAL	R9,TYPHW
	LHL	R3,DRIE,,		:EMPTY POINTER, NODE INDEXED
	JAL	R9,TYPHW
	JAL	R7,TYP4SP
:	OUTPUT RING
	LHL	R3,DROF,,		:FILL POINTER, ISIS INDEXED
	JAL	R9,TYPHW
	LHL	R3,DROE,,		:EMPTY POINTER, NODE INDEXED
	JAL	R9,TYPHW

	JAL	R7,TYPCRL

	J	XRPRMT			:DONE

	EI	:ISIS
	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV-1)		:##AL

	SUBTTL	XRAY (Node snap - ND)

	IF	(XRSZLV)		:##AL
	IF	2-XRYTMC		:###wjl

::*********************************************************************
::
::	COMMAND:	XND:	ND
::	FUNCTION:	FORMAT NODE SNAP FOR DISPLAY
::
::*********************************************************************

XCROPM	SC	/RESTART/
	SC	/STOP   /
	SC	/BOOT   /
	SC	/HALT   /
	SC	/PATCH  /

XND	HS	0
	LA	R2,XNDHD1		:HEADER LINE 1
	JAL	R7,TYPASC
	LHI	R3,MACHNM
	JAL	R9,HEXOCT		:CONVERT NODE NUMBER TO OCTAL
        JAL	R9,TYP5CH		:TYPE FIVE DIGIT NODE NUMBER###SHM
	IF	T2GATE			:GATEWAY PUT 2 SIDE HOST NO.##AL
	JAL	R7,TYP2SP		:				###CWC
	LHI	R3,HHOST		:FROM TYMFILE, HOME NET HOST NO.
	JAL	R9,TYP5DD		:				###CWC
	JAL	R7,TYP2SP		:				###CWC
	LHI	R3,IHOST		:ISIS NET HOST NO.
	JAL	R9,TYP5DD		:				###CWC
	JAL	R7,TYP2SP		:##AL
	ELSE	:NOT T2GATE
	LHI	R3,HST0			:				###wjl
	JAL	R9,TYP5DD		:KERNEL HOST IN DECIMAL		###CWC
	EI	:T2GATE
	LHI	R3,VERSION
	JAL	R9,HEXOCT		:CONVERT VERSION TO OCTAL
	JAL	R9,TYPFW
	JAL	R7,TYP2SP
	LB	R2,CRACTN,,
	SLLS	R2,3
	LA	R2,XCROPM,R2		:CRASH OPTION
	JAL	R7,TYPASC
	JAL	R7,TYP2SP
	LB	R2,CRACTN+1,,
	SLLS	R2,3
	LA	R2,XCROPM,R2		:CRASH OPTION
	JAL	R7,TYPASC
	JAL	R7,TYP2SP
	LHL	R3,TVRSUP		:SUP NUMBER
	JAL	R9,TYPBYD
	JAL	R7,TYP2SP
	IF	1-ISIS
	LA	R1,MEMSIZ
	SVC	0F,SV.RAB
	LR	R3,R1			:GET MEMORY SIZE
	SRLS	R3,0A			:SCALE DOWN
	ELSE	:ISIS
	IF	T2GATE			:###AL
	LHI	R3,MEMORY		:GATEWAY SLOT SIZE
	ELSE	:NOT T2GATE
	LHI	R3,S0CORE		:IF ISIS, JUST USE S0CORE FROM TYMFILE
	EI	:T2GATE
	EI	:1-ISIS
	JAL	R9,HEXDEC		:GO DECIMAL
	JAL	R9,TYPHNS		:AND DISPLAY

	LA	R2,XNDHD2		:HEADER LINE 2
	JAL	R7,TYPASC

:	COMPUTE NUMBER OF PORTS FOR KERNEL, DISPI INTERFACES. RUNNING
:	COUNT IS MAINTAINED IN 'HNPORT', BUT MAY NOT BE TOTALLY ACCURATE
:	DUE TO LOGIN RACE CONDITIONS.
	LIS	R0,0			:CUMULATIVE PORT COUNT
	IF	NKU
	LA	R2,KIOTAB,,		:KERNEL PORT PERMUTER TABLE
	LHI	R1,NKU			: AND NUMBER OF KERNEL PORTS
XNDAP1	LHL	R3,0,R2			:GET PERMUTER TABLE ENTRY
	JEFS	XNDAP2			:PORT NOT IN USE
	AIS	R0,1			:INCREMENT ACTIVE PORT COUNT
XNDAP2	AIS	R2,2
	SIS	R1,1			:ANY MORE TO DO?
	JGBS	XNDAP1			:YES - CONTINUE
	EI	:NKU
XNDAP3	HS	0
	IF	NDP
	LA	R2,DIOTAB,,		:DISPI PORT PERMUTER TABLE
	LHI	R1,NDP			: AND NUMBER OF DISPATCHER PORTS
XNDAP4	LHL	R3,0,R2			:GET PERMUTER TABLE ENTRY
	JEFS	XNDAP5			:PORT NOT IN USE
	AIS	R0,1			:INCREMENT ACTIVE PORT COUNT
XNDAP5	AIS	R2,2
	SIS	R1,1			:ANY MORE TO DO?
	JGBS	XNDAP4			:YES - CONTINUE
	EI	:NDP

	IF	SOLOCS	:SOLOCS doesn't have access to a good running count
	LHI	R9,NGRP-1		:index into RLA bit array
	LIS	R3,0			:init the counter of active ports
XNDAP6	LHL	R1,RLA,R9,R9		:active port bit array, hw at a time
XNDAP7	JFFOH	R1,XNDAP8		:count the set bits
	SIS	R9,1			:step back to next halfword
	JGEBS	XNDAP6			:loop until RLA is covered
	J	XNDTY1			:leave the loop with value in R3
XNDAP8	AIS	R3,1			:count each bit that sent us here
	STH	R1,XRSAVE,XD		:an awkward way to reset a bit
	RBT	R2,XRSAVE,XD
	LHL	R1,XRSAVE,XD
	JBS	XNDAP7			:do this for all set bits in HW
	EI	:SOLOCS
	STH	R0,HNPORT		:UPDATE WITH MOST ACCURATE COUNT

	LHL	R3,HNPORT		:NUMBER OF PORTS IN USE
XNDTY1	JAL	R9,TYPHWD
	JAL	R7,TYP2SP		:COUPLE SPACES
	LHL	R3,PASTHR		:NUMBER OF PASSTHROUGHS IN USE
	JAL	R9,TYPHWD
	JAL	R7,TYP4SP
	LHL	R3,NALINK		:NUMBER OF ACTIVE LINKS
	JAL	R9,TYPHWD
	LHI	R3,NLINKS		:TOTAL NUMBER OF LINKS DEFINED
	JAL	R9,TYPHWD
	LHI	R3,XLINKS		:NUMBER OF XLINKS DEFINED
	JAL	R9,TYPHWD
	IF	STRHUB			:				###wjl
	LHI	R3,NSTKDS+STRXLK	:number of starlinks defined	##al	
	JAL	R9,TYPHWD		:				###wjl
	LHL	R3,NSTXK,,		:FIND NUMBER OF STAR-XLINK 	###AL
	JAL	R9,TYPHWD
	EI	:STRHUB
	JAL	R7,TYP2SP		:MORE SPACES
	LHI	R3,NLINES		:NUMBER OF LINES (SYNC+SIO) DEFINED
	JAL	R9,TYPHWD
	LHI	R3,NLINES-SILINS	:NUMBER OF SYNC LINES DEFINED
	JAL	R9,TYPHWD
	IF	STRHUB			:				###wjl
	LHI	R3,SILINS-NSTLIN	:number of SIO lines defines	###wjl
	JAL	R9,TYPHWD		:				###wjl
	LHI	R3,NSTLIN		:number of STAR lines defined	###wjl
	JAL	R9,TYPHWD		:				###wjl
	ELSE	:NOT STRHUB
	LHI	R3,SILINS		:NUMBER OF SIO LINES DEFINED
	JAL	R9,TYPHWD
	EI	:STRHUB
	IF	SOLOCS
	LHI	R3,NAPORT		:NUMBER OF ASYNC PORTS
	JAL	R9,TYPHWD
	EI	:SOLOCS

	LA	R2,XNDHD5		:TELL WHEN WE FIRST CAME UP
	JAL	R7,TYPASC
	L	R2,XFIRST		:GET TIME OF FIRST TIME UP
	ST	R2,GMTNOW,,		:SAVE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE

	LA	R2,XNDHD3		:TELL HOW LONG WE'VE BEEN UP
	JAL	R7,TYPASC
	L	R2,XLCRSH		:GET TIME OF LAST CRASH
	ST	R2,GMTNOW,,		:SAVE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE

	LA	R2,XNDHD6
	JAL	R7,TYPASC
	L	R2,CS.TIM+CSMTBL	:GET CRASH TIME
	JAL	R9,GMTCNX,,		:DISPLAY IT
	JAL	R7,TYP2SP
	LHL	R3,CS.CNT+CSMTBL	:CRASH COUNT
	JAL	R9,TYPHWD
	LHL	R3,CS.CID+CSMTBL	:CRASH ID
	JAL	R9,TYPHW
	LHL	R3,CS.PSD+2+CSMTBL	:CRASH PSW
	JAL	R9,TYPHW
	L	R3,CS.PSD+4+CSMTBL	:CRASH PC
	JAL	R9,TYPFW

	LA	R2,XNDHD4		:HEADER TO DISPLAY LINK/LINE STATUS
	JAL	R7,TYPASC

	LIS	LN,0			:DO FOR ALL LINES, STARTING WITH 0
XND20	HS	0
	LR	R3,LN			:GET LINE NO.
	JAL	R9,TYPBYD		:TYPE IT
	IF	SILINS			:TEST FOR SYNC OR SIO LINE
	CLHI	LN,NLINES-SILINS	:SYNC LINE?
	JLFS	XND22			:YES
	IF	STRHUB!STRRMT		:				###wjl
	LB	R2,LTYP,LN,LN		:test for starline (=1)		###wjl
:##AL	SIS	R2,1			:				###wjl
	JEFS	XNDS02			:no				###wjl
	IF	STRRMT
	LA	R2,XNDHST		:yes- display 'STAR  '		###wjl
	JFS	XND24			:				###wjl
	ELSE	:STRHUB
	J	XNDSTR			:yes				###wjl
	EI	:STRRMT
XNDS02	HS	0			:				###wjl
	EI	:STRHUB!STRRMT
	LA	R2,XNDHSI		:NO - DISPLAY 'SIO LINE'
	JFS	XND24
	EI	:SILINS
XND22	LA	R2,XNDHSY		:DISPLAY 'SYNC LINE'
XND24	JAL	R7,TYPASC
	LHL	R3,NGSVLN,LN,LN 	:NEIGHBOR NUMBER - 
	JN	XND25			:NEIGHBOR HAS BEEN THERE, GO FIGURE.
	LR	R2,LN			:line no.
	AR	R2,R2			:times 2
	TBT	R2,DWLDSP,,		:check for DWL in progress
	JEFS	XND23			:no
	LA	R2,XDWLDS		:yes, say it
	JFS	XND21
XND23	LA	R2,NONEIG		:CANNED DISPLAY FOR UNUSED LINE
XND21	JAL	R7,TYPASC		:TYPE IT
	J	XND40			:NEXT LINE
XND25	NHI	R3,7FFF			:STRIP HO UP/DOWN INDICATOR BIT###SHM 
	STH	R3,XNDSAV		:SAVE NODE NUMBER(IN HEX)      ###SHM
	JAL	R9,HEXOCT		:CONVERT (R3) TO OCTAL         ###SHM
	JAL	R9,TYP5CH		:TYPE FIVE DIGITS OF NODE #    ###SHM
        LHL	R1,XNDSAV		:LOAD HEX NODE # FOR XFNDLK    ###SHM
	JAL	R9,XFNDLK		:RETURNS KN AND KX (-1 IF NOT FOUND)
	NOP
	LHL	R3,XKNSAV,XD		:LINK# FOR TYPBYT
	JAL	R9,TYPBYT,,		:TYPE LINK NO.

:	SEE IF NEIGHBOR IS TIILNK OR XLINK.
	L	KX,XKDSAV,XD		:LINK DESC.
	JLFS	XND30			:IF <0 XLINK DOWN
	LH	R3,ONDID,KX		:XLINK?
	JEFS	XND30			:YES
	LA	R2,XNDTKD		:TII NEIGHBOR
	JFS	XND32
XND30	LA	R2,XNDXKD		:XLINK
XND32	JAL	R7,TYPASC		:DISPLAY TII OR XLNK
	LR	KX,KX			:CHECK FOR -1
	JLFS	XND31
	LB	R3,NLAT,KX		:NUMBER OF LINES ON LINK
	SIS	R3,1			:MORE THAN ONE LINE?
	JLEFS	XND31			:NO
	LA	R2,XNDMLL		:YES - DISPLAY 'MULTI-LINE LINK'
	JAL	R7,TYPASC
	JFS	XND33
XND31	LA	R2,ASC3SP,,		:3 SPACES
	JAL	R7,TYPASC

:	LINE IS ACTIVE. DISPLAY 'UP', WINDOW SIZE, SPEED, AND NUMBER
:	OF ACTIVE CHANNELS ON LINK.
XND33	LH	R3,NGSVLN,LN,LN		:LINE ATTACHED TO UP LINK IF HO BIT SET
	JGEFS	XND50			:NOT SET
	LA	R2,XNDLUP		:'UP'
	J	XND26			:GO TYPE IT
XND50	SLL	LN,1
	L	R3,KDLN,LN,LN		:GET LINK DESC ADDRESS
	SRL	LN,1
	AIS	R3,1			:IF 'FFFF' LINE IS SUSPENDED, ELSE DOWN
	JEFS	XND51			:LINE IS SUSPENDED
	LR	R2,LN			:line number...
	AR	R2,R2			:...times 2
	TBT	R2,DWLDSP		:see if DWL in progress
	JEFS	XND52			:no
	LA	R2,XDWLBR		:yes, say it
	JFS	XND26
XND52	LA	R2,XNDLOT		:'*DOWN*'
	JFS	XND26			:DISPLAY IT
XND51	LA	R2,XNDSUS		:'*SUSP*'
XND26	JAL	R7,TYPASC
	L	KX,XKDSAV,XD		:LINK DESC.
	JL	XND35
	LB	R3,WSIZ,KX		:PICKUP LINK WINDOWSIZE		###OAS
	JAL	R9,HEXDEC		:CONVERT TO DECIMAL		###OAS
	JAL	R9,TYPHNS		:TYPE FOUR DIGITS(NO SPACES)	###OAS
	LA	R2,ASC1SP		:				###OAS
	JAL	R7,TYPASC		:				###OAS
	LHL	R3,BAUDRT,LN,LN		:PICKUP LINE SPEED		###OAS
	CLHI	R3,HISPD		:IS LINE HIGH SPEED (>19.2KB)?	###wjl
	JLFS	XND29			:NO, DISPLAY CALCULATED SPEED
	LHL	R4,XKNSAV,XD		:GET LINK NUMBER
	TBT	R4,KNCNSP,,		:IS SPEED SPEC IN TYMFILE?
	JEFS	XND29			:NO, DISPLAY CALCULATED SPEED
	LB	R3,KSPD,KX		:H-SPEED CALC AND SPEC, GET LINK SPEED
	NHI	R3,1F			:ISOLATE SPEED BITS
XND29	LB	R4,KSPD,KX		:PICKUP LINK SPEED FOR SAT BIT	###OAS
	LA	R2,ASC2SP		:ASSUME TERRESTIAL LINE		###OAS
	THI	R4,20			:CHECK FOR SAT BIT SET		###OAS
	JEFS	XND27			:NO, LEAVE BLANK		###OAS
	LA	R2,ASCSAT		:YES, PUT @ BEFORE SPEED	###OAS
XND27	JAL	R7,TYPASC		:TYPE IT			###OAS

	SLLS	R3,3			: *8 FOR TABLE LOOK-UP
	LA	R2,HSPEED,R3
	JAL	R7,TYPASC		:DISPLAY HUMAN READABLE LINE SPEED
	JAL	R8,CHNCNT
	JAL	R9,TYPHWD		:DISPLAY NUMBER OF ACTIVE CHNS FOR LINK
	JFS	XND34

XND35	LA	R2,ASCASP		:HERE FOR XLNK THAT IS DOWN	###OAS
	JAL	R7,TYPASC		:PAD IN 19 SPACES		###OAS
	LA	R2,ASC8SP
	JAL	R7,TYPASC		:8 MORE
	LA	R2,ASC1SP	
	JAL	R7,TYPASC		:1 MORE
XND34	LR	R1,LN			:LINE NO.
	SLLS	R1,2			:TIMES 4
	L	R2,LINTIM,R1,		:TIME OF LAST ATT/DET
	JE	XND40			:IGNORE IF 0
	ST	R2,GMTNOW,,		:STORE FOR GMTCNV
	JAL	R9,GMTCNV		:TYPE IT

	LIS	R2,1			:*FOR COUNT1 - NO. HW'S TO SCAN
	LA	R4,LDARLN,LN,LN		:*LD ARRAY FOR LINE -
	JAL	R9,COUNT1		:*HOW MANY 1'S - ANSWER IN R3
	LR	R3,R3			:*NO 1'S?
	JEFS	XND40			:*RIGHT, SO SKIP
	SRLS	R3,2			:*DIVIDE BY 4
	SLLS	R3,3			:*DW INDEX
	LA	R2,ASTER1,R3		:*GET APPROPRIATE NO. OF ASTERISKS
	JAL	R7,TYPASC		:*AND DISPLAY
	
XND40	JAL	R7,TYPCRL
	AIS	LN,1			:ADVANCE TO NEXT LINE NUMBER
	CLHI	LN,NLINES		:MORE TO DO?
	JL	XND20			:YES - CONTINUE
:	J	XND70			:NO - DISPLAY LINKS OUT

:	FIND ALL TIILNK LINKS AND DISPLAY THOSE NOT UP...
XND70	HS	0
	LA	R2,XNDWDN		:DISPLAY 'TIILNK NEIGHBORS DOWN - '
	JAL	R7,TYPASC
	LHI	KN,(NLINKS-1)*2
	LIS	R5,0			:CUMULATIVE COUNT OF DOWN LINKS
XND72	STH	KN,XKNSAV,XD		:SAVE LINK#
	SLL	KN,1
	L	R2,KDKN,KN,		:GET LINK DESCRIPTOR INDEX
	SRL	KN,1
	LR	KX,R2
	LH	R3,ONDID,KX		:IS THIS AN XLINK?
	JE	XND80			:YES - BYPASS
	LB	R1,NLAT,KX		:ARE ANY LINES ATTACHED TO LINK?
	JN	XND80			:YES - LINK UP
	AIS	R5,1			:LINK DOWN - COUNT IT,
	JAL	R9,HEXOCT		: CONVERT TO OCTAL,
        JAL	R9,TYP5CH		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
	CHI	R5,8			:8 NBRS DISPLAYED 1ST LINE ##AL
	JEFS	XND80
:	JAL	R7,TYPCRL		:##AL
:	JFS	XND80
XND73	CHI	R5,8+0B			:11 NBRS DISPLAYED 2ND LINE ##AL
	JNFS	XND80			:GOOD ENOUGH FOR 32 NBRS
	JAL	R7,TYPCRL
XND80	LHL	KN,XKNSAV,XD		:RECOVER LINK#
	SIS	KN,2			:CHECK NEXT LINK
	JGE	XND72
:	DONE WITH ALL LINKS - WERE ANY DOWN?
	LR	R5,R5
	JN	XRCRLF			:YES, DONE WITH DISPLAY
	LA	R2,ASCZIP,,		:NO, ALL TIILNK LINKS UP. DISPLAY 'ZIP'
	JAL	R7,TYPASC
	J	XRCRLF			:DONE WITH ND DISPLAY

:	starline/starlink display
	IF	STRHUB			:				###wjl
XNDSTR	HS	0			:				###wjl
	LA	R2,XNDHST		:display 'STAR  '		###wjl
	JAL	R7,TYPASC		:				###wjl
	SLL	LN,1
	L	R3,KDLN,LN,LN		:get pointer into STHEAD	###wjl
	SRL	LN,1			:RESTORE HALF WORD INDEX	###SHM
	LR	R3,R3			:RESTORE CONDITION CODES	###SHM
	JL	XND23			:UNUSED LINE			###SHM
XNDS2T	L	KX,STHEAD,R3		:get pointer to link descriptor ###wjl
	LIS	R3,1
	STB	R3,LNERFL,,		:SET LINE ERR FLAG PER LINE ##AL
XNDS20	LHL	R3,NDID,KX		:get neighbor number		###wjl
	STH	R3,XNDSAV		:SAVE NODE NUMBER(IN HEX)	###AL
	ST	KX,XKDSAV,XD		:SAVE KD FOR STARLINK		###AL	
	JAL	R9,HEXOCT		:CONVERT (R3) TO OCTAL	        ###SHM
	JAL	R9,TYP5CH		:TYPE FIVE OCTAL DIGITS	        ###SHM
	LB	R3,LKNM,KX		:GET LNNM FROM KX			
	STH	R3,XKNSAV,XD		:SAVE LINK NUMBER		###AL	
	JAL	R9,TYPBYT		:display link number		###wjl
	LA	R2,XNDHST		:display 'STAR  '		###wjl
	JAL	R7,TYPASC		:				###wjl
	LA	R2,ASC1SP		:type 1 space			###wjl
	JAL	R7,TYPASC		:				###wjl
	LA	R2,XNDLUP		:assume 'UP'			###wjl
	LB	R1,STAFLG,KX		:get status flag		###wjl
	CHI	R1,1			:IF LINK UP ##AL
	JE	XNDS30
	CHI	R1,0			:IF LINK DOWN
	JE	XNDS22
	CHI	R1,2			:IF DOWN-LINE-LOAD
	JNFS	XNDS21
	LA	R2,XDWLBR
	JFS	XNDS30
XNDS21	NHI	R1,4			:IF RESET MODE
	JEFS	XNDS22
	LA	R2,XNDRST
	JFS	XNDS30
XNDS22	LA	R2,XNDLOT		:'DOWN'				###wj
XNDS30	JAL	R7,TYPASC		:display status			###wjl
	LB	R3,WSIZ,KX		:get link window size		###wjl
	JAL	R9,HEXDEC		:convert to decimal		###wjl
	JAL	R9,TYPHNS		:type HW (no spaces)		###wjl
	LA	R2,ASC1SP		:type 1 space			###wjl
	JAL	R7,TYPASC		:				###wjl
	LA	R2,ASCSAT		:type '@' for satellite link	###wjl
	JAL	R7,TYPASC		:				###wjl
	LB	R3,KSPD,KX		:get link speed			###wjl
	NHI	R3,1F			:isolate speed bits		###wjl
	SLLS	R3,3			:multiply by 8 for table look-up###wjl
	LA	R2,HSPEED,R3		:display readable speed		###wjl
	JAL	R7,TYPASC		:				###wjl
	JAL	R8,CHNCNT		:display number of active chns	###wjl
	JAL	R9,TYPHWD		:				###wjl
	LR	R1,LN			:line number			###wjl
	SLLS	R1,2			:times 4			###wjl
	L	R2,STRTIM,KX		:time of last attach/detach	###wjl
	JN	STRT0			:ignore if 0 			###al
	LA	R2,ASC6SP		:typ 12 space for line err *	###al
	JAL	R7,TYPASC
	LA	R2,ASC6SP
	JAL	R7,TYPASC
	J	STRT2
STRT0	LR	R7,R2
	NI	R7,0FFFF0000		:IF HO HW 0,USE LAST TAKEOVER
	JNFS	STRT1			: TIME ##AL
	L	R2,XLCRSH		:LAST CAME UP TIME
	L	R7,STRTIM,KX		:PLUS STARLINK UP TIME
	AR	R2,R7
	ST	R2,GMTNOW,,
	JAL	R9,GMTCNV
	JFS	STRT2
STRT1	ST	R2,GMTNOW,,		:store for GMTCNV		###wjl
	JAL	R9,GMTCNV		:type it			###wjl
STRT2	LB	R2,LNERFL,,		:CHECK IF ALREADY DISPLAYED	###al
	JE	XNDS40	
	LIS	R2,1			:number of HW'for COUNT1 to scan###wjl
	LA	R4,LDARLN,LN,LN		:HW bit array for ERRATE	###wjl
	JAL	R9,COUNT1		:count how many 1's, answer in R3##wjl
	LR	R3,R3			:any 1's ??			###wjl
 	JEFS	XNDS40			:no				###wjl
	LIS	R2,0
	STB	R2,LNERFL,,
	SRLS	R3,2			:divide by 4			###wjl
	SLLS	R3,3			:DW index			###wjl
	LA	R2,ASTER1,R3		:get appropriate no. of asterisks##wjl
	JAL	R7,TYPASC		:and display			###wjl
XNDS40	HS	0			:advance to next star link	###wjl
	L	KX,NXTLNK,KX		:pointer to next link descriptor###wjl
	JNFS	XNDS4A			:CHECK IF CAME FROM 'SL' CMD
	LB	R0,SLFLAG,,		: ##AL
	JNFS	XNDS41			:IF 'SL' CMD, FINISH WITH BANNER
	J	XND40
XNDS41	LIS	R0,0
	STB	R0,SLFLAG,,		:RESET THE FLAG
	J	XPRMPT
:	JE	XND40			:finished with this star line	###wjl
XNDS4A	JAL	R7,TYPCRL		:type CR/LF			###wjl
	JAL	R7,TYPASP		:type 10 spaces			###wjl
	J	XNDS20			:continue...			###wjl
	EI	:STRHUB

	EI	:2-XRYTMC ###wjl

	SUBTTL	XRAY (Link descriptor - KD)

	IF	2-XRYTMC		:###wjl

::*********************************************************************
::
::	COMMAND:	XNEIGB:	KD
::	FUNCTION:	DISPLAY LINK DESCRIPTOR TO GIVEN NEIGHBOR
::
::*********************************************************************

XNEIGB	HS	0
	LHL	R2,ARGCT,XD		:ARGUMENT COUNT
	SIS	2,4			:MUST HAVE SINGLE ARG
	JN	COMERR
	JAL	R9,OCTHXR		:CONVERT ARGUMENT IN R3 TO HEX
	LR	R1,R3
	JE	COMERR			:FNDLNK WILL ACCEPT NEIGHBOR # OF 0
	JAL	R9,XFNDLK
	J	COMERR			:NOT FOUND
	JAL	R7,TYPCRL		:TYP CR-LF
	L	KX,XKDSAV,XD		:LINK DESC.
	LA	R10,NDID,KX		:POINTS TO FIRST HW OF LNK DESCRIPTOR
	LA	R2,NEIMS1
	JAL	R7,TYPASC
	LIS	R5,0
XNEIG0	HS	0
	LHL	R3,0,R10
	CLHI	R5,4
	JGFS	XNEIGA
	JAL	R9,TYPHW
	AIS	R10,2
	AIS	R5,2
	JBS	XNEIG0
XNEIGA	LHL	KN,XKNSAV,XD
	TBT	KN,KNCNSP,,
	JNFS	XNEIG1
	NHI	R3,7FFF
XNEIG1	HS	0
	L	KX,XKDSAV,XD
	JAL	R9,TYPHW
	AIS	R10,2
	LIS	R5,4
	JAL	R8,TYPNHW

	LA	R2,NEIMS2
	JAL	R7,TYPASC
	ST	KX,XRSAVE,XD		:SAVE LINK DESCRIPTOR
	ST	R10,XRSAVE+4,XD		:AND POINTER
	LR	R8,XD			:SAVE USER BLOCK POINTER
	LM	R12,0,R10		:COPY DYNAMIC DATA
	STM	R12,XRSAVE+8,R8,	:TO STATIC AREA FOR ACCURATE READING
	LR	XD,R8			:RESTORE XD
	LA	R10,XRSAVE+8,XD
	JAL	R8,TYP8HW
	L	KX,XRSAVE,XD		:RECOVER LINK DESCRIPTOR
	L	R10,XRSAVE+4,XD		:AND POINTER
	AHI	R10,10			:ADVANCE POINTER
	LA	R2,NEIMS3
	JAL	R7,TYPASC
	LHL	R3,0,R10
	JAL	R9,TYPHW
	LHL	KN,XKNSAV,XD		:RECOVER LINK#
	LHL	R3,LKZFKN,KN,KN		:DISPLAY ABSOLUTE CHN FOR CHANNEL 0
	JAL	R9,TYPHW
	LHL	R3,TBDPKN,KN,KN		:DISPLAY BEGINNING OF PERMUTER TABLE
	JAL	R9,TYPHW
	LHL	R3,EBDPKN,KN,KN		:DISPLAY END OF PERMUTER TABLE
	JAL	R9,TYPHW
	L	KX,XKDSAV,XD		:RECOVER LINK DESC.
	LHL	R3,ANCHN,KX		:NO. OF ACTIVE CHANNELS
	JAL	R9,TYPHW
	LHL	R3,KVERNO,KX		:NEIGHBOR VERSION NUMBER
	JAL	R9,TYPHW

:	DISPLAY ALL LINES ATTACHED TO LINK
	LB	R0,NLAT,KX
	JNFS	XNEIG2			:GOT SOME
	LA	R2,ASCZIP,,
	JAL	R7,TYPASC		:NO LINES ATTACHED - SAY 'ZIP'

	IF	XRESET			:###wjl
	LCS	R8,1			:don't display NETID, HOST0, LINE
	EI	:XRESET
	
	J	XNEIG7
XNEIG2	LHI	LN,(NLINES-1)*2
XNEIG3	IF	STRHUB
	LB	R7,LTYP,LN,
	JE	XNEI3A
	LB	R1,NLAT,KX		:USE NLAT FOR STARLINK ##AL
::	check every starlines, if NDID matches, display the line#	###AL
	JE	XNEIG4			:NEXT LINE
	L	R1,SKDPTR,LN,LN		:GET KD LIST
	JLE	XNEIG4
	L	R1,STHEAD,R1,		:1ST STARLINK
	JE	XNEIG4
	LH	R8,NDID,KX		:THIS NDID
XNEI30	CLH	R8,NDID,R1		:NDID IN THE LIST
	JE	XNEIG6			:DISPLAY IF MATCHED
	L	R1,NXTLNK,R1		:NEXT STARLINK
	JE	XNEIG4			:END OF THE LIST
	JBS	XNEI30			:CONTINUE			###AL
:	JN	XNEIG6 			:DISPLAY STARLINE#
:	JFS	XNEIG4
XNEI3A	EI	:STRHUB
	LH	R1,NGSVLN,LN,		:SEE IF THIS LINE ATTACHED TO LINK
	JGEFS	XNEIG4			:8000 BIT SET IF LINE ATTACHED
	NHI	R1,7FFF
	CLH	R1,NDID,KX		:IS LINE ATTACHED TO THIS LINK?
	JEFS	XNEIG6			:YES - DISPLAY IT
XNEIG4	SIS	LN,2
	JGE	XNEIG3			:CHECK ALL LINES
	JAL	R7,TYPCRL
	JFS	XNEIG7
XNEIG6	HS	0

	IF	XRESET			:###wjl
	LR	R8,LN			:save LN for later
	EI	:XRESET	

	LR	R3,LN
	SRLS	R3,1
	JAL	R9,TYPBYT,,		:DISPLAY LINE NUMBER
	JBS	XNEIG4

XNEIG7	HS	0	:See how many of the active circuits are command
			:circuits and display.
	JAL	R7,TYPASI		:Type following string
	SC	/"0D"0ACMD CKTS = /
	LIS	R3,0			:Init count
	LHL	R1,NCHN,KX,		:# channels allocated to this link
	JE	XNEIG8			:none
	SIS	R1,1			:begin with last channel
	LHL	KN,XKNSAV,XD,		:recover link number		###wjl
	LHL	R7,FLDPKN,KN,KN		:beginning of link's bit arrays	###wjl
XNEI7B	HS	0
	TBT	R1,CMDCTS,R7,		:test this one
	JEFS	XNEI7A			:nope
	AIS	R3,1			:got one, inc count
XNEI7A	HS	0
	SIS	R1,1			:next channel
	JGBS	XNEI7B			:don't bother with channel 0
XNEIG8	HS	0
	JAL	R9,TYPHW		:type out count in hex		###wjl
	JAL	R7,TYPCRL

	IF	XRESET			:###wjl
	LR	R8,R8			:any lines attached?
	JL	XPRMPT			:zip
	LHL	SD,SDLN,R8,		:pointer to reset buffer
	LH	R4,VRSTP,SD		:received reset pattern
	NHI	R4,0FFEF		:mask out subsequent line bit
	CLHI	R4,TXRSHD+0F		:Expanded Reset Header?
	JN	XPRMPT			:no, done...	
	JAL	R7,TYPCRL
	JAL	R7,TYPASI		:type following string
	SC	/NET     HOST   LINE/
	JAL	R7,TYPCRL
	L	KX,XKDSAV,XD,		:recover link descriptor
	LHL	R3,KNETID,KX,
	JAL	R9,TYPHW		:type neighbor's NETID
	L	R3,KHOST0,KX,
	JAL	R9,TYPFW		:type neighbor's HOST0
	LB	R3,KLINE,KX,
	JAL	R9,TYPBYT,,		:type neighbor's first line attached
	JAL	R7,TYPCRL
	EI:	XRESET

	J	XPRMPT			:All done.

	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV)		:##AL

	SUBTTL	XRAY (Trace/stop on RD,WRT,FTCH - TS)

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	XTRCBF:	TS
::	FUNCTION:	Control MAC2 trac/stop capability
::
::*********************************************************************

:	if terminate with N then if user is owner then free
:		the command and reset the Trace Control Word
:	otherwise,
:	if inuse then exit else begin
:	mark in use
:	set up occurrence to trigger on
:	set up halt on trace/stop or not
:	set stop qualification bits (bits 6 - 10) in TCW
:	set trace qualification bits (1 - 5) in TCW
:	set stop address bounds (354 & 358)
:	end

	IF	1-ISIS
	IF	ZITEL

ASKSTR	SC	/"0D"0AIS STOP TRACE LOGGING DESIRED? /			:###OAS
ASKOCC	SC	/"0D"0ASPRING ON WHAT OCCURRENCE? /
ASKHLT	SC	/"0D"0AHALT NODE ON TRIGGER? /
ASKTRC	SC	/"0D"0ATRACE BIT MASK8 /
ASKSTP	SC	/"0D"0ASTOP BIT MASK: /
ASKLAD	SC	/"0D"0ALOW PHYSICAL ADDRESS BOUND? /
ASKHAD	SC	/"0D"0AHIGH PHYSICAL ADDRESS BOUND? /
TELBAD	SC	/"0D"0ARELEASE NOT NEEDED OR NOT ALLOWED./

XTRCBF	HS	0
	CLHI	R1,ASCN			:ASCII N is x4E
	JE	XTRCLR			:user asking to clear trc request, OR
					:STOP TRACE LOG
:	Is command in use?
	LHL	R1,TRCUSE,,		:read the in use flag
	JN	XCOMIU			:if in use we're out of luck
	STH	XD,TRCUSE,,		:mark in use by this user

:	Set up the parameters.
	GL	STPWFG,LOGTRC,LOGTRI
	LA	R2,ASKSTR
	JAL	R7,TYPASC		:ASK IF TRACE-LOG IS DESIRED	###OAS
	JAL	R13,XRYIN		:read a character from buffer
	NHI	R1,ASCAP		:force it to upper case
	CLHI	R1,ASCY			:test for "yes"
	JEFS	XTRC51
	LIS	R1,0
	STH	R1,LOGTRC,,		:STOP TRACE NOT DESIRED
	STH	R1,STPWFG,,		:INDICATE NO TRACE-LOG TABLE WRAP
	STH	R1,LOGTRI,,		:ZERO TRACE-LOG TABLE INDEX
	JFS	XTRC50
XTRC51	TS	LOGTRC,,		:STOP TRACE DESIRED
	LIS	R1,0
	STH	R1,STPWFG,,		:INDICATE NO TRACE-LOG TABLE WRAP
	STH	R1,LOGTRI,,		:ZERO TRACE-LOG TABLE INDEX
XTRC50	JAL	R13,XRYIN		:be graceful--wait for cr from user
	NHI	R1,ASCAP
	CLHI	R1,ASCCR		:is it an ASCII cr (0D)?
	JNBS	XTRC50			:we're waiting for a carriage return
	LH	R1,LOGTRC,,		:was trace-log requested?
	JL	XTRC52			:yes, don't req occurence or halt

	LA	R2,ASKOCC
	JAL	R7,TYPASC		:ask for number of trigger occurrence
	JAL	R8,RDEXP		:read in numerical arg--ret in R3
	STH	R3,STPNMB,,		:store it--allow up to 64K?
:	mechanism for halting on trigger
	LA	R2,ASKHLT
	JAL	R7,TYPASC
	JAL	R13,XRYIN		:read a character from buffer
	NHI	R1,ASCAP		:force it to upper case
	CLHI	R1,ASCY			:test for "yes"
	JEFS	XTRC20
	TS	HLTOST,,		:set -1 for normal resume
	JFS	XTRC10
XTRC20	LIS	R1,0			:chose to halt--set flag to zero
	STH	R1,HLTOST,,
XTRC10	JAL	R13,XRYIN		:be graceful--wait for cr from user
	NHI	R1,ASCAP
	CLHI	R1,ASCCR		:is it an ASCII cr (0D)?
	JNBS	XTRC10			:we're waiting for a carriage return
:	set up trace control word masks.
XTRC52	HS	0
	LA	R2,ASKSTP
	JAL	R7,TYPASC		:ask for stop bit mask
	JAL	R8,RDEXP		:read in numerical arg
	NHI	R3,R5BITS		:be sure we have only five bits
	LR	R5,R3			:make trace mask same as stop mask
	SLLS	R5,5			:shift trace mask bits into position
	OR	R5,R3			:or in the stop mask 
	SLL	R5,15			:control bits are at left of word
:	Get physical address bounds
	LA	R2,ASKLAD
	JAL	R7,TYPASC		:ask for low addr range on trace
	JAL	R8,RDEXP		:read in numerical argument
	NI	R3,NMCMSK		:ensure only 22 bits
	LR	R10,R3			:R10 will carry low boundary
	LA	R2,ASKHAD
	JAL	R7,TYPASC		:ask for high addr range on trace
	JAL	R8,RDEXP
	NI	R3,NMCMSK		:ensure only 22 bits
	LR	R11,R3			:R11 will carry high edge
:	Write information to the MAC
	SVC	0F,SV.TCW		:write R5 to TCW, R10,R11 to addr flds
	J	XRCRLF			:output prompt and dismiss

:	Clear the trace-in-use word, if the clearer is the owner, or
:	display the trace log table if we are logging traces or if it
:	contains data.

XTRCLR	HS	0
	LHL	R1,TRCUSE,,		:find out who is using this

	JEFS	XTRC71			:ALLOW DISPLAY OF trace-log

	CR	R1,XD			:if it's not this user, forget it
	JN	XTRERR			:even if it's no one, don't allow chng

XTRC71	LH	R0,LOGTRC,,		:ARE/DID WE EXECUTING trace-log?###OAS
	JL	XTRC55			:YES, DISPLAY trace-log DATA	###OAS
	LR	R1,R1			:IS THERE ANY USER?
	JE	XTRERR			:no, and not logging traces

	LIS	R5,0
	STH	R5,TRCUSE,,		:zero out the INUSE halfword
	LIS	R10,0
	LIS	R11,0
	SVC	0F,SV.TCW		:zero out trace ctrl word--stop trace
	J	XRCRLF			:finished with this cmd for now

XTRC55	HS	0
	LIS	R10,0
	LIS	R11,0			:INITIALIZE trace-log TABLE INDEX###OAS
	LH	R2,TRCUSE,,		:DOES TRACE NEED TO BE STOPPED?
	JEFS	XTRC60			:NO, ALREADY DONE
	SVC	0F,SV.TCW		:STOP TRACE BEFORE DISPLAYING DATA

XTRC60	LH	R2,STPWFG,,		:IS trace-log TABLE WRAPPED?	###OAS
	JLFS	XTRC63			:YES, DISPLAY ALL ENTRIES	###OAS
	CLH	R11,LOGTRI,,		:NOT WRAPPED, INDEX TO LAST ENTRY?#OAS
	JGE	XTRC70			:YES, ALL DATA IS DISPLAYED, EXIT##OAS
XTRC63	LA	R2,XTRD10		:get ptr to string STOP CONDITION
	JAL	R7,TYPASC		:output to the user's screen
	SLLS	R11,1			:FORM HW INDEX			###OAS
	LHL	R3,STPSAV,R11,		:get offset of stop condition
	AR	R3,R3			:double for halfword offset
	LHL	R3,MSKTBL,R3		:converts offset into mask
	JAL	R9,TYPHW
	LA	R2,XTRD20		:get ptr to string NOTED-- ADDR:
	JAL	R7,TYPASC		:output to the user's screen
	SLLS	R11,1			:FORM FW INDEX			###OAS
	L	R3,TRCSV,R11,		:get address of stop condition
	NI	R3,NMCMSK		:strip to 22 bits
	JAL	R9,TYPFW
	LA	R2,XTRD30		:get ptr to string TIME:
	JAL	R7,TYPASC		:output to the user's screen
	L	R3,MTRGTM,R11,		:get FASTC time of interrupt
	JAL	R9,TYPFW
	LA	R2,XTRD35		:get ptr to string PSW:
	JAL	R7,TYPASC		:output to user screen
	SLLS	R11,1			:FORM 2*FW INDEX		###OAS
	L	R3,TSPSW,R11,		:read first word of PSW
	JAL	R9,TYPFW	
	L	R3,TSPSW+4,R11,		:get second word of PSW
	JAL	R9,TYPFW
	IF	MEMMON
:	output the user registers
	LA	R2,XTRD37		:get ptr to string USER REGS
	JAL	R7,TYPASC		:output to user
	SLLS	R11,3			:FORM 16*FW INDEX		###OAS
	LIS	R1,0			:storage area index
	LIS	R2,2			:print out 2 lines		###jhl
	LIS	R10,8			:of 8 regs each
XTRC63	L	R3,TRCREG,R1,R11	:read the register
	STH	R1,XRSAVE,XD		:save index from TYPFW
	STH	R2,XRSAVE+4,XD		:save end marker from TYPFW
	JAL	R9,TYPFW		:output to the screen
	LH	R1,XRSAVE,XD		:restore index from TYPFW
	LH	R2,XRSAVE+4,XD		:restore end marker from TYPFW
	SIS	R10,1			:eight regs on this line yet?
	JG	XTRC65			:no crlf if not
	STH	R1,XRSAVE,XD
	JAL	R7,TYPCRL		:crlf for new line
	SIS	R2,1			:HAVE WE DONE 4 LINES YET?
	JLE	XTRC69			:if yes, go on to trace buffer
	LHL	R1,XRSAVE,XD		:restore register index
	LIS	R10,8			:restore line cursor		###jhl
XTRC65	AIS	R1,4			:point to the next register
	J	XTRC63			:loop for next register

XTRC69	SRLS	R11,6			:RESTORE R11 FROM 16*FW INDEX	###OAS
	ELSE	:MEMMON
	SRLS	R11,3			:RESTORE R11 FROM 2*FW INDEX	###OAS
	EI	:MEMMON
	AIS	R11,1			:BUMP trace-log INDEX		###OAS
	CLHI	R11,NSTRCN		:UP TO END OF TABLE YET?	###OAS
	JL	XTRC60			:NO, DISPLAY MORE IF THERE'S SOME##OAS
XTRC70	HS	0			:NO MORE DATA			###OAS
	LIS	R5,0
	STH	R5,TRCUSE,,		:INDICATE TRACE NOT IN USE
	J	XRCRLF			:EXIT				###OAS

XTRERR	HS	0
	LA	R2,TELBAD		:tell user "no way"
	JAL	R7,TYPASC
	J	XRCRLF			:and exit

::*********************************************************************
::
::	ROUTINE:	XTRDSP:
::	FUNCTION:	ZITEL trace/stop display routine
::
::*********************************************************************

:	XLOOP scans TRCFLG for output in storage.
:	When set (e.g. negative), jump here and output data to XRAY
:	user's screen.
:	Display will look like--
:	STOP CONDITION <mask> NOTED -- ADDR: <lastfetch> 
:	FASTC: <fastc>  PSW: <psw>
:	TRACE CONDITIONS NOTED FOR <mask> AT :
:	<list of up to 32 addresses>

XTRD10	SC	/"0D"0ASTOP CONDITION /
XTRD20	SC	" NOTED -- ADDR: "
XTRD30	SC	/"0D"0AFASTC: /
XTRD35	SC	/ PSW: /
XTRD37	SC	/"0D"0AUSER REGS:"0D"0A/
XTRD40	SC	/"0D"0ATRACE CONDITIONS NOTED FOR /
XTRD50	SC	/ AT: "0D"0A/

XTRDSP	HS	0
:	First, be sure display goes to correct user.
	LHL	R2,TRCUSE,,		:Read XD of owner of the trace-stop
	CR	R2,XD			:is it same as iminent receiver?
	JN	XLOOPM			:if not, prevent some surprise
:	OK.  Show our stuff.
	LA	R2,XTRD10		:get ptr to string STOP CONDITION
	JAL	R7,TYPASC		:output to the user's screen
	LHL	R3,STPSAV,,		:get offset of stop condition
	AR	R3,R3			:double for halfword offset
	LHL	R3,MSKTBL,R3		:converts offset into mask
	JAL	R9,TYPHW
	LA	R2,XTRD20		:get ptr to string NOTED-- ADDR:
	JAL	R7,TYPASC		:output to the user's screen
	L	R3,TRCSV,,		:get adress of stop condition
	NI	R3,NMCMSK		:strip to 22 bits
	JAL	R9,TYPFW
	LA	R2,XTRD30		:get ptr to string TIME:
	JAL	R7,TYPASC		:output to the user's screen
	L	R3,MTRGTM,,		:get FASTC time of interrupt
	JAL	R9,TYPFW
	LA	R2,XTRD35		:get ptr to string PSW:
	JAL	R7,TYPASC		:output to user screen
	L	R3,TSPSW,,		:read first word of PSW
	JAL	R9,TYPFW	
	L	R3,TSPSW+4,,		:get second word of PSW
	JAL	R9,TYPFW
:	output the user registers
	LA	R2,XTRD37		:get ptr to string USER REGS
	JAL	R7,TYPASC		:output to user
	LIS	R1,0			:storage area index
	LIS	R2,2			:print out 2 lines		###jhl
	LIS	R10,8			:	of 8 regs each		###jhl
XTR050	L	R3,TRCREG,R1,		:read the register
	STH	R1,XRSAVE,XD		:save index from TYPFW
	STH	R2,XRSAVE+4,XD		:save end marker from TYPFW
	JAL	R9,TYPFW		:output to the screen
	LH	R1,XRSAVE,XD		:restore index from TYPFW
	LH	R2,XRSAVE+4,XD		:restore end marker from TYPFW
	SIS	R10,1			:eight regs on this line yet?
	JG	XTR055			:no crlf if not
	STH	R1,XRSAVE,XD
	JAL	R7,TYPCRL		:crlf for new line
	SIS	R2,1			:have we done 2 lines yet?	###jhl
	JLE	XTR057			:if yes, go on to trace buffer
	LHL	R1,XRSAVE,XD		:restore register index
	LIS	R10,8			:restore line cursor		###jhl
XTR055	AIS	R1,4			:point to the next register
	J	XTR050			:loop for next register
:	output the trace buffer
XTR057	LA	R2,XTRD40		:get ptr to string TRACE CONDITIONS
	JAL	R7,TYPASC		:output to the user's screen
	LHL	R3,TRMSKS,,		:get trace mask set by user
	JAL	R9,TYPHW		:output to screen
	LA	R2,XTRD50		:pointer to string AT:
	JAL	R7,TYPASC		:output to screen
	LI	R2,2AAAAA		:buffer end flag is 2AAAAA
	LHI	R1,4			:step through buffer (stop cond was 0)
	LHI	R10,4			:display 4 words on a line
XTR100	L	R3,TRCSV,R1,		:get address at start of buffer
	NI	R3,NMCMSK		:strip to 22 bits
	CR	R3,R2			:end marker?
	JE	XTSHWN
	STH	R1,XRSAVE,XD		:save index from TYPFW
	ST	R2,XRSAVE+4,XD		:save end marker from TYPFW
	JAL	R9,TYPFW		:output to XRAY user
	LH	R1,XRSAVE,XD		:restore index from TYPFW
	L	R2,XRSAVE+4,XD		:restore end marker from TYPFW
	SIS	R10,1			:Count along the line
	JGFS	XTNOCR			:CRLF only after 4
	STH	R1,XRSAVE,XD		:restore index from TYPCRL
	JAL	R7,TYPCRL		:outpt CRLF
	LH	R1,XRSAVE,XD		:restore index from TYPCRL
	LHI	R10,4			:reset for next line
XTNOCR	AIS	R1,4			:bump indexer
	CHI	R1,80			:have we read all 32 fw addresses?
	JL	XTR100			:loop until reason to leave
XTSHWN	HS	0
	LIS	R0,0			:get set to zero out TRCFLG
	STH	R0,TRCFLG,,		:tell 'em we showed this stuff
	STH	R0,TRCUSE,,		:free up trace stop for another round
	J	XRCRLF			:output CRLF and XRAY prompt

:	Table for converting stop condition offset to mask
MSKTBL	HS	0
	HC	10,8,4,2,1	:fetch, data rd, data wrt, DMA rd, DMA wrt

	EI	:ZITEL
	EI	:1-ISIS

	SUBTTL	XRAY (Scan memory for halfword match - MA)

::*********************************************************************
::
::	COMMAND:	XRMTCH:	MA
::	FUNCTION:	ENABLES THE USER TO FIND THE ADDRESSES OF ALL
::	OCCURENCES OF A SPECIFIED HALFWORD STRING IN A SPECIFIED
::	MEMORY RANGE.
::	INPUT:		MA <hex string> <start address> <end address>
::	IF THE COMMAND IS TERMINATED BY THE LETTER "N" THE ROUTINE
::	WILL SEARCH FOR ALL OCCURRENCES OF THE SECOND BYTE OF THE
::	STRING WHICH ARE NOT PRECEDED WITH THE FIRST BYTE OF THE
::	STRING.  FOR EXAMPLE,  
::		MA 0322 10000 1FFFFN
::	WILL FIND ALL OCCURRENCES OF 22 NOT PRECEDED WITH 03 IN
::	SEGMENT 1. 	###JHL
::
::*********************************************************************

TIMDSM	EQ	18			:NUMBER OF LOOPS AT ONE SHOT

XRMTCH	HS	0
	ST	R1,XRSAVE,XD		:SAVE LAST CHARACTER ENTERED FOR LATER
	LHL	R1,VALUE1+4,XD		:LIFT SEG # FROM START ADDRESS
	LHL	R2,VALUE1+8,XD		:LIFT SEG # FROM END ADDRESS
	CR	R1,R2			:DON'T READ ACROSS SEG BNDRY
	JN	XRMER1			:TELL USER TO STAY IN ONE SEGMENT
:	FALL THROUGH IF SAME SEG #'S.  NEXT CHECK WE DON'T GO 
:	BEYOND SEGMENT END.
	L	R4,VALUE1+4,XD		:READ START ADDRESS
	L	R0,VALUE1+8,XD		:READ END ADDRESS
	SLLS	R1,2			:MULT TIMES 4 TO GET WORD OFFSET 
	L	R2,SGLTBL,R1		:READ SEG LENGTH FOR THIS SEGMENT
	SRLS	R1,2			:BACK TO NORMAL
	EXHR	R1,R1			:GET SEG # IN HO HW
	AR	R1,R2			:VIRTUAL ADDR OF SEG END
	CR	R0,R1			:END ADDR - SEG END ADDR
	JLE	XRMT05			:OK--REQUESTED END IS WITHIN RANGE
	LR	R0,R1			:OTHERWISE ADOPT THE REAL END
XRMT05	SR	R0,R4			:R0 GETS END ADDR - START ADDR
	JLE	XRMER2			:TELL USER HIS RANGE IS NO GOOD
:	SET UP FOR PROCESSING.  R0 = END OFFSET, R1 = DISMISS TIME COUNTER,
:	R2 = R3 = SCRATCH, R4 = MATCH STRING, R5 = OFFSET COUNTER,
:	R6 = EVEN HALFWORD HOLDER, R7 USED TO LINK TO SUBROUTINES.
	LHI	R1,TIMDSM		:COUNTER FOR DISMISS
	L	R2,VALUE1+4,XD		:GET START ADDR OF SEARCH REGION
	NI	R2,0FFFFFFFE		:MAKE SURE THIS IS AN EVEN ADDRESS
	ST	R2,VALUE1+4,XD		:AND MAKE SURE WE USE IT
	LIS	R5,0			:INITIALIZE RUNNING OFFSET PTR
	L	R4,VALUE1,XD		:FIRST ARG IS MATCH-STRING
	LHL	R6,XRSAVE+2,XD		:DID USER END WITH AN "N"?
	CLHI	R6,ASCN			:IF HE DID IT'S NON-MATCH ON 1ST BYTE
	JE	XRNMFS			:GO TO NON-MATCH FIRST BYTE ROUTINE

:	WE'RE SET UP NOW FOR HW MATCH.  HERE IS THE MAIN MATCHING LOOP.
	LHL	R6,0,R2,R5		:READ FIRST (EVEN) HW
XRMT10	LR	R3,R6			:READ THE EVEN HW
	CLR	R3,R4			:SAME AS OUT STRING?
	JNFS	NMEVN			:SKIP NEXT IF NO MATCH
	L	R2,VALUE1+4,XD		:RESTORE START ADDR FOR FND CALLS
	JAL	R7,FNDEVN		:FOUND A MATCH AT EVEN BOUNDARY
	JAL	R7,TIMOUT		:OUTPUT ROUTINE TAKES A LONG TIME
NMEVN	EXBR	R3,R3			:SHIFT RIGHT BYTE TO LEFT
	NHI	R3,0FF00		:GET RID OF OLD LEFT BYTE
	AIS	R5,2			:BUMP OFFSET PTR TO NEXT HW
	CR	R5,R0			:HAS OFFSET REACHED END OF RANGE?
	JGE	XPRMPT			:IF SO, WE'RE FINALLY DONE CHECKING
	L	R2,VALUE1+4,XD		:GET START OF OUR SEARCH REGION
	LHL	R6,0,R2,R5		:READ NEXT (EVEN) HW
	LR	R2,R6			:MOVE TO A WORKING REGISTER
	EXBR	R2,R2			:WE WANT THE LEFT BYTE OF HW
	NHI	R2,0FF			:GET RID OF RIGHT HW FOR NOW
	OR	R3,R2			:COMBINE ODD-ADDR/ODD-ADDR+1
	CLR	R3,R4			:MATCH AGAINST OUR STRING
	JNFS	NMODD			:SKIP NEXT IF NO MATCH
	L	R2,VALUE1+4,XD		:RESTORE START ADDR FOR FND CALLS
	JAL	R7,FNDODD
	JAL	R7,TIMOUT		:OUTPUT ROUTINE TAKES A LONG TIME
NMODD	SIS	R1,1			:COUNT DOWN OUR DISMISS TIME
	JG	XRMT10			:NOT TIME TO YIELD YET--CONTINUE
	JAL	R7,TIMOUT		:TIME TO GIVE NODE CODE SOME CPU
	J	XRMT10			:CONTINUE MATCH/SHIFT/MATCH

:	SEARCH FOR A BYTE PRECEDED BY ANYTHING BUT A GIVEN BYTE.
:	REGISTER USAGE SAME AS FOR FOR STRAIGHT HW MATCH,
:	EXCEPT R4 = MATCH BYTE (SECOND), R6 = NON-MATCH BYTE. 
XRNMFS	HS	0
	LB	R4,VALUE1+3,XD		:PUT MATCH BYTE (SECOND ONE) IN R4
	LB	R6,VALUE1+2,XD		:PUT NON-MATCH BYTE IN R6
:	THIS WOULD BE A GOOD PLACE TO CHECK FOR 1ST BYTE XX TO DO BYTE COMPARE
NOMF10	AIS	R5,1			:INC THE OFFSET PTR
	CR	R5,R0			:REACHED END OF READ RANGE?
	JGE	XPRMPT			:IF WE HAVE, THEN EXIT
	SIS	R1,1			:DEC THE TIMEOUT COUNTER
	JG	NOMF20			:CONTINUE IF NOT DOWN TO ZERO
	JAL	R7,TIMOUT		:ELSE TIME TO YIELD TO NODE CODE
NOMF20	L	R2,VALUE1+4,XD		:SET UP PTR TO START ADDRESS
	LB	R3,0,R2,R5		:READ BYTE LOOKING FOR MATCH 
	CLR	R3,R4			:DOES IT MATCH OUR SECOND BYTE?
	JN	NOMF10			:IF NOT, MOVE TO NEXT PAIR
	SIS	R5,1			:IT DOES--CHECK PREV BYTE FOR NON-MATCH
	LB	R2,0,R2,R5		:READ THAT PREV BYTE, SAVE R3 FOR LATER
	CLR	R2,R6			:CHECK FOR NON-MATCH
	JE	NOMF30			:BUMP OFSET SO WE DON'T LOOP FOREVER
:	WE FOUND AN APPROPRIATE HW STRING--NOTIFY THE USER
	EXBR	R2,R2
	NHI	R2,0FF00
	OR	R3,R2			:NOW R3 HAS THE STRING
	L	R2,VALUE1+4,XD		:FND ROUTINES REQUIRE START ADDR IN R2
	JAL	R7,FNDEVN		:OUTPUT THE INFORMATION
NOMF30	AIS	R5,1			:RESTORE BYTE OFFSET FOR MORE CHECKS
	J	NOMF10			:AND LOOP AGAIN

:	**UTILITY ROUTINES FOR MATCH COMMAND**

::*********************************************************************
::
::	SUBROUTINE:	TIMOUT:
::	FUNCTION:	TIME OUT
::	CALLING SEQ:	JAL	R7,TIMOUT
::	CALLS:		JAL	R0,XRYYLD
::
::*********************************************************************

TIMOUT	HS	0
	CI	XD,TTYXD		:IS THIS A TTY USER?
	JER	R7			:FOR LOCAL USER, LET IT EAT TIME SLICE
	ST	R0,XRSAVE,XD		:SAVE RANGE FOR RESTORATION LATER
	ST	R5,XRSAVE+4,XD		:DITTO FOR OFFSET PTR
	STH	R6,XRSAVE+8,XD		:DITTO FOR THE LAST HW WE READ
	ST	R7,XRSAVE+0C,XD		:DITTO FOR THE LINK REGISTER
	JAL	R0,XRYYLD		:LET THE NODE CODE RUN
MTCRES	L	R0,XRSAVE,XD		:RESTORE RANGE OF OUR REGION TO CHECK
	LHI	R1,TIMDSM		:RESET COUNTDOWN TICKER	
	LHL	R4,VALUE1+2,XD		:RESTORE HW MATCH-STRING
	L	R5,XRSAVE+4,XD		:RESTORE OFFSET PTR
	LHL	R6,XRSAVE+8,XD		:RESTORE LAST HW WE READ
	L	R7,XRSAVE+0C,XD		:RESTORE THE LINK REGISTER
	JR	R7			:AND TAKE UP WHERE WE LEFT OFF

::*********************************************************************
::
::	SUBROUTINES:	FNDODD:/FNDEVN:
::	FUNCTION:	FOUND A MATCH.  OUTPUT THE ADDRESS AND STRING
::	TO THE USER, AND RESUME MATCH/SHIFT/MATCH.
::
::*********************************************************************

FNDODD	SIS	R2,1			:UPDATE OFFSET FOR ODD HALFWORD
FNDEVN	AR	R2,R5			:NOW R2 HAS THE ADDRESS OF THE MATCH
:	SAVE REGISTERS 0,1,2,3,4,7, AND OUTPUT THE ADDRESS TO THE USER
	ST	R0,XRSAVE,XD
	ST	R1,XRSAVE+4,XD
	ST	R2,XRSAVE+8,XD
	ST	R3,XRSAVE+0C,XD
	ST	R4,XRSAVE+10,XD
	ST	R7,XRSAVE+14,XD
	LR	R3,R2			:SET UP FOR SUBROUTINE CALL
	JAL	R9,TYPADD		:OUTPUT THE FULL WORD ADDRESS
	LHL	R3,XRSAVE+0E,XD		:GET HW STRING AT ABOVE ADDRESS
	JAL	R9,TYPHW		:AND OUTPUT TO THE USER
	JAL	R7,TYPCRL		:GIVE USER A NICE LINE TERMINATOR
:	RESTORE THE REGISTERS AND RETURN TO MATCH LOOP
	L	R0,XRSAVE,XD
	L	R1,XRSAVE+4,XD
	L	R2,XRSAVE+8,XD
	L	R3,XRSAVE+0C,XD
	L	R4,XRSAVE+10,XD
	L	R7,XRSAVE+14,XD
	AIS	R2,1			:BUMP IN CASE WE DEC'ED FOR ODDNESS
	NI	R2,0FFFFFFFE		:ENSURE WE'RE BACK TO AN EVEN OFFSET
	JR	R7

:	**ERROR MESSAGES**
XRMER1	HS	0
	LA	R2,XRMES1		:LOAD ADDRESS OF ERROR STRING
	JAL	R7,TYPASC		:TELL THE USER HOW HE ERRED.
	J	XRCRLF			:THEN WAIT FOR FURTHER INSTRUCTIONS

XRMER2	HS	0
	LA	R2,XRMES2		:LOAD ADDRESS OF ERROR STRING
	JAL	R7,TYPASC		:TELL THE USER HOW HE ERRED.
	J	XRCRLF			:THEN WAIT FOR FURTHER INSTRUCTIONS

	NOLIST
XRMES1	SC	/"0AYOU CAN'T READ ACROSS SEGMENT BOUNDARIES./
XRMES2	SC	/"0ASPECIFIED RANGE IS UNACCEPTABLE./
	LIST

::*********************************************************************
::
::	TABLE:		SGLTBL:
::	FUNCTION:	SEGMENT LENGTH TABLE
::
::*********************************************************************

SGLTBL	WS	0
	WC	S0SIZE
	WC	S1SIZE
	GL	S1SIZE
	IF	NOSEG
	GL	S2SIZE,S3SIZE,S4SIZE,S5SIZE,S6SIZE
	GL	S7SIZE,S8SIZE,S9SIZE,SBSIZE
	EI	:NOSEG##AL
	WC	S2SIZE
	WC	S3SIZE
	WC	S4SIZE
	WC	S5SIZE
	WC	S6SIZE
	WC	S7SIZE
	WC	S8SIZE
	WC	S9SIZE
	WC	0			:SASIZE IS NOT DEFINED
	WC	SBSIZE
	WC	SCSIZE
	GL	SCSIZE
	WC	SDSIZE
	WC	SESIZE
	GL	SDSIZE,SESIZE
	WC	0			:SFSIZE IS NOTHING TO US

	SUBTTL	XRAY (Read crash registers - RR)

::*********************************************************************
::
::	COMMAND:	REGIST:	RR
::	FUNCTION:	TYPE THE REGISTERS SAVED IN ERRREG AFTER AN ERROR
::
::*********************************************************************

REGIST	HS	0
	LA	R6,ERRREG
	LHI	R5,10
	JAL	R8,TYPNFW
	J	XPRMPT

	EI	:(XRSZLV-2)		:##AL

::*********************************************************************
::
::	SUBROUTINE:	TYPNFW:
::	FUNCTION:	TYPE N FULLWORDS
::	CALLING SEQ:	JAL	R8,TYPNFW
::	INPUT:		R5 = NUMBER OF FULLWORDS
::			R6 = STARTING ADDRESS
::
::*********************************************************************

TYPNFW	HS	0 
REGS1	THI	R5,7
	JNFS	REGS3
	JAL	R7,TYPCRL
REGS3	L	R3,0,R6
	JAL	R9,TYPFW
	AIS	R6,4
	SIS	R5,1
	JGBS	REGS1
	JAL	R7,TYPCRL
	JR	R8

	SUBTTL	XRAY (CRYPTO message commands - CL, CP, CM, AP, SM)

	IF	2-XRYTMC		:###wjl

::*********************************************************************
::
::	COMMAND:	CRYLST:	CL
::	FUNCTION:	TYPE LAST N CRYPTO MESSAGES
::
::*********************************************************************

	IF	(XRSZLV-1)		:##AL

CRYLST	HS	0
	LR	R2,R2			:check for no arguments		###wjl
	JE	CRYLS6			:no arguments			###wjl
	L	R3,VALUE1,XD		:ARGUMENT
	CLHI	R1,ASCH			:Ended with 'H' (x48)?
	JNFS	CRYLS0			:No

	LHI	R6,$A3600		:User wants last N hours worth
	JFS	CRYLS4

CRYLS0	HS	0
	CLHI	R1,ASCM			:Ended with 'M'?
	JN	CRYLS2			:No
	
	LHI	R6,$A60			:User wants last N minutes worth
CRYLS4	HS	0
	JAL	R7,CRYPTR		:Go compute out pointer
	JFS	CRYLS1			:Found beginning of time frame

CRYLS6	LHI	R3,10			:default number of args is 16	###wjl
CRYLS2	HS	0
	LHL	R2,CRYPRI
	SLLS	R3,4			:User wants last N messages
	NHI	R3,CRYPRS-1
	SR	R2,R3
	JGEFS	CRYLS1
	AHI	R2,CRYPRS
CRYLS1	STH	R2,CRYPTU,XD
	LIS	R14,0			:OUTPUT ALL MESSAGES
	LCS	R12,1			:ENABLE ALL MESSAGES
CRYLS3	JAL	R7,TYPCRL
	JAL	R8,XCRYPT
	J	XPRMPT
	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	CRYLTP:	CP
::	FUNCTION:	TYPE LAST N CRYPTO priority MESSAGES ###AL1/4/85
::
::*********************************************************************

	IF 	PRIMSG

CRYLTP	HS	0
	L	R3,VALUE1,XD		:ARGUMENT
	CLHI	R1,ASCH			:Ended with 'H' (x48)?
	JNFS	CRYLP0			:No

	LHI	R6,$A3600		:User wants last N hours worth
	JFS	CRYLP4

CRYLP0	HS	0
	CLHI	R1,ASCM			:Ended with 'M'?
	JN	CRYLP2			:No

	LHI	R6,$A60			:User wants last N minutes worth
CRYLP4	HS	0
	JAL	R7,CRPPTR		:Go compute out pointer		###AL
	JFS	CRYLP1			:Found beginning of time frame

CRYLP2	HS	0
	LHL	R2,CRYPPI
	SLLS	R3,4			:User wants last N messages
	NHI	R3,CRYPPS-1
	SR	R2,R3
	JGEFS	CRYLP1
	AHI	R2,CRYPPS
CRYLP1	STH	R2,CRYPPU,XD
	LIS	R14,0			:OUTPUT ALL MESSAGES
	LCS	R12,1			:ENABLE ALL MESSAGES
CRYLP3	JAL	R7,TYPCRL
	JAL	R8,XCRPPT		:###AL
	J	XPRMPT

::*********************************************************************
::
::	SUBROUTINE:	CRPPTR:
::	FUNCTION:	Computes CRYPPU for CRYLTP and CRYMSG.###AL1/4/85
::	CALLING SEQ:	JAL	R7,CRPPTR
::	INPUT:		R3 = argument in minutes or hours, decimal
::			R6 = $A60, if minutes - $A3600 if hours
::	OUTPUT:		R2 = CRYPPU
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R9
::	CALLS:		JAL	R9,DECHEX
::
::*********************************************************************

CRPPTR	HS	0
	JAL	R9,DECHEX		:Argument is decimal, convert to hex
	J	DHXBAD			:(immed) Radix error return
	LHL	R2,CRYPPI		:(+4) Get crypto pointer
	MHR	R6,R3			:Convert to seconds
	JAL	R9,GMTCAL,,		:Get current time to GMTNOW
	L	R3,GMTNOW,,		:Current time + 7 bits of FASTC
	SRLS	R3,7			:Get rid of FASTC
	SR	R3,R6			:We want to go back to this time
	JGE	CPPTR0			:OK

	JALMAC(TYPASI)
	SC	/REQUESTED TIME OUT OF RANGE/
	J	COMERR

CPPTR0	HS	0
	SHI	R2,10			:Look at next oldest message
	JGEFS	CPPTR1

	AHI	R2,CRYPPS		:Wrapped

CPPTR1	HS	0
	CLH	R2,CRYPPI		:Back to where we started?
	JE	XPRMPT			:Yes, no message in time frame

	L	R5,CRYPPB+CRYGMT,R2,	:Get message timestamp
	AIS	R5,1			:Make sure it's not -1
	JEFS	CPPTR2			:It is, done
	SIS	R5,1			:Restore timestamp
	SRLS	R5,7			:Dump FASTC
	CLHI	R5,$A1440		:At least a day's worth
	JL	CPPTR0			:No, keep trying
	CR	R3,R5			:Are we in our time frame?
	JL	CPPTR0			:No, keep trying

CPPTR2	AHI	R2,10			:Move forward one
	NHI	R2,CRYPPS-1		:Correct for wrap
	JR	R7			:RET

	EI	:PRIMSG
	EI	:(XRSZLV-2)

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	SUBROUTINE:	CRYPTR:
::	FUNCTION:	Computes CRYPTU for CRYLST and CRYMSG.
::	CALLING SEQ:	JAL	R7,CRYPT
::	INPUT:		R3 = argument in minutes or hours, decimal
::			R6 = $A60, if minutes - $A3600 if hours
::	OUTPUT:		R2 = CRYPTU
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R9
::	CALLS:		JAL	R9,DECHEX
::
::*********************************************************************

CRYPTR	HS	0
	JAL	R9,DECHEX		:Argument is decimal, convert to hex
	J	DHXBAD			:(immed) Radix error return
	LHL	R2,CRYPRI		:(+4) Get crypto pointer
	MHR	R6,R3			:Convert to seconds
	JAL	R9,GMTCAL,,		:Get current time to GMTNOW
	L	R3,GMTNOW,,		:Current time + 7 bits of FASTC
	SRLS	R3,7			:Get rid of FASTC
	SR	R3,R6			:We want to go back to this time
	JGE	CRPTR0			:OK

	JALMAC(TYPASI)
	SC	/REQUESTED TIME OUT OF RANGE/
	J	COMERR

CRPTR0	HS	0
	SHI	R2,10			:Look at next oldest message
	JGEFS	CRPTR1

	AHI	R2,CRYPRS		:Wrapped

CRPTR1	HS	0
	CLH	R2,CRYPRI		:Back to where we started?
	JE	XPRMPT			:Yes, no message in time frame

	L	R5,CRYPRB+CRYGMT,R2,	:Get message timestamp
	AIS	R5,1			:Make sure it's not -1
	JEFS	CRPTR2			:It is, done
	SIS	R5,1			:Restore timestamp
	SRLS	R5,7			:Dump FASTC
	CLHI	R5,$A1440		:At least a day's worth
	JL	CRPTR0			:No, keep trying
	CR	R3,R5			:Are we in our time frame?
	JL	CRPTR0			:No, keep trying

CRPTR2	AHI	R2,10			:Move forward one
	NHI	R2,CRYPRS-1		:Correct for wrap
	JR	R7			:RETURN

::*********************************************************************
::
::	COMMAND:	SETMES:	SM
::	FUNCTION:	TURN UP TO 7 CRYPTO MESSAGES ON OR OFF
::
::*********************************************************************

SETMES	HS	0
	LHI	R0,$A32			:UP TO 8 ARGUMENTS
	STH	R0,ARGMAX,XD
	JAL	R9,RDARGS,,		:GET ARGUMENTS

	LR	R2,R2			:CHECK FOR NO ARGUMENTS
	JNFS	SETME9			:ARGS PRESENT, PROCESS THEM
	LIS	R0,0			:CLEAR ALL BITS (ENABLE ALL MSGS)
	LIS	R1,0F			:CLEAR 10 HW
SETME8	STH	R0,CRYARY,R1,R1,	:ENABLE ALL MESSAGES
	SIS	R1,1			:NEXT HW
	JGEBS	SETME8			:DO MORE
	J	XRPRMT			:ALL DONE

SETME9	SIS	R3,1
	JG	COMERR			:LAST ARGUMENT MUST BE 1/ON OR 0/0FF

SETME0	SIS	R2,4			:NUMBER OF ARGUMENTS MINUS 1
	JLE	XRPRMT			:DONE

	L	R0,VALUE1-4,XD,R2	:GET A MESSAGE NUMBER
	CLHI	R0,100			:RANGE CHECK
	JGEBS	SETME0			:TOO BIG

	LR	R3,R3			:ON OR OFF?
	JLFS	SETME2			:OFF

	RBT	R0,CRYARY,,		:ON
	J	SETME0

SETME2	SBT	R0,CRYARY,,		:OFF
	J	SETME0
	EI	:(XRSZLV-1)

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	SETPRI:	AP
::	FUNCTION:	TURN UP TO 7 CRYPTO priority MESSAGES ON OR OFF###AL
::
::*********************************************************************

	IF	PRIMSG

SETPRI	HS	0
	LHI	R0,$A32			:UP TO 8 ARGUMENTS
	STH	R0,ARGMAX,XD
	JAL	R9,RDARGS,,		:GET ARGUMENTS

	LR	R2,R2			:CHECK FOR NO ARGUMENTS
	JNFS	SETPR9			:ARGS PRESENT, PROCESS THEM
					:IF NO ARG, BACK TO DEFAUL PRIO. TABLE	
	LA	R0,CRYPDE-2,,		:COPY DEFAULT PRIO. TABLE TO ACTING TAB
	LA	R1,CRYPRE-2,,		:ENDING HW ADDR. R0 SOURCE,R1 DESTINATN
	LHI	R2,10*((CRYPDE-CRYPDF)/2-1)	:SIZE OF HW'S
	COPY	R0,R2
	J	XRPRMT			:ALL DONE

SETPR9	SIS	R3,1
	JG	COMERR			:LAST ARGUMENT MUST BE 1/ON OR 0/0FF

SETPR0	SIS	R2,4			:NUMBER OF ARGUMENTS MINUS 1
	JLE	XRPRMT			:DONE

	L	R0,VALUE1-4,XD,R2	:GET A MESSAGE NUMBER
	CLHI	R0,100			:RANGE CHECK
	JGEBS	SETPR0			:TOO BIG

	LR	R3,R3			:ON OR OFF?
	JLFS	SETPR2			:OFF

	SBT	R0,CRYPRY,,		:ON 
	J	SETPR0

SETPR2	RBT	R0,CRYPRY,,		:OFF
	J	SETPR0

	EI	:PRIMSG
	EI	:(XRSZLV-2)

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	CRYMSG:	CM
::	FUNCTION:	DISPLAY ALL MESSAGES OF A PARTICULAR TYPE
::
::*********************************************************************

CRYMSG	HS	0
	LHI	R0,$A32			:PERMIT UP TO 8 ARGUMENTS
	STH	R0,ARGMAX,XD
	JAL	R9,RDARGS,,		:GET ARGUMENTS

	CLHI	R1,ASCH			:End with 'H' (x48)?
	JNFS	CRYMS0			:No

	LHI	R6,$A3600		:Wants an hour's worth
	JFS	CRYMS5

CRYMS0	HS	0
	CLHI	R1,ASCM			:End with 'M' (x4D)?
	JNFS	CRYMS3			:No

	LHI	R6,$A60			:Wants a minute's worth
CRYMS5	HS	0
	LCS	R2,4			:Decrement arg count since last arg
	AHM	R2,ARGCT,XD		:was time parameter
	JAL	R7,CRYPTR		:Get CRYPTU to R2
	JFS	CRYMS4

CRYMS3	HS	0
	LHL	R2,CRYPRI		:Do all messages
	AHI	R2,10
	NHI	R2,CRYPRS-1
CRYMS4	HS	0
	STH	R2,CRYPTU,XD
	JAL	R7,TYPCRL
	LI	R1,CRYMSK,XD		:Destination pointer
	LHI	R2,10			:16d HW's of CRYMSK to zero
	JAL	R8,HCLEAR,,		:CLEAR THE MASK ARRAY
	LH	R2,ARGCT,XD		:				###wjl
CRYMS2	LR	R2,R2
	JLEFS	CRYMS1			:AT END OF ARGUMENT LIST	###wjl

	LHL	R1,VALUE1-2,R2,XD	:GET AN ARGUMENT
	NHI	R1,$A255
	SBT	R1,CRYMSK,XD		:ENABLE THE MESSAGE TYPE
	SIS	R2,4
	JBS	CRYMS2

CRYMS1	LIS	R12,1			:INDICATOR TO XCRYPT TO USE MASK
	LHI	R14,0			:TYPE AS MANY AS NEEDED
	JAL	R8,XCRYPT
	J	XPRMPT

	EI	:XRSZLV-1 ###wjl
	EI	:2-XRYTMC ###wjl

::*********************************************************************
::
::	SUBROUTINE:	XCRYPT:
::	FUNCTION:	PRINT CONTENTS OF CRYPTOGRAM BUFFER
::	CALLING SEQ:	JAL	R8,XCRYPT
::	INPUT:		R12 =	DISPLAY ONLY MESSAGES MASKED IN CRYMSK
::			ALL MESSAGES  ENABLED IF <0
::			R14 =	-(NUMBER OF MESSAGES TO TYPE). IF >= 0
::			MESSAGES TYPED UNTIL EMPTY PTR = FILL PTR
::
::*********************************************************************

	IF	XRSZLV-1		:###wjl

XCRYPT	HS	0
	LHL	R10,CRYPTU,XD		:GET THE OUT PTR
XCRYP1	CLH	R10,CRYPRI		:EQUAL IN PTR?
	JER	R8			:YES,RETURN

	LB	R11,CRYPRB+CRYTYP,R10,	:Get message type

	LR	R12,R12			:DISPLAY ALL MESSAGES?
	JLFS	XCRYP2			:YES

	TBT	R11,CRYMSK,XD		:NO,ONLY THOSE ENABLED IN CRYMSK ARRAY
	JE	XCRYP3			:THIS ISNT ONE

XCRYP2	CLHI	R11,CRYMTZ/2		:AVOID CRASH,CHECK FOR VALID INDEX
	JG	XCRYP3

XCRYP4	SLLS	R11,1			:FORM HW INDEX
	L	R2,CRYPRB+CRYGMT,R10,	:GET CRYPTOGRAM TIME AND
	ST	R2,GMTNOW,,		:STORE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE
	LA	R2,ASC1SP		:1 SPACE
	JAL	R7,TYPASC
	LHL	R3,CRYPRB+CRYFAS,R10,	:16 BITS OF FASTC
	JAL	R9,TYPHW		:AND TYPE IT
	LHL	R2,CRYMTB,R11		:GET MESSAGE POINTER
	AI	R2,SEGD			:IN CASE NEEDED BELOW.
	LB	R9,CRYPRB+CRYFLG,R10,	:CHECK FOR 0 FLAGS
	JE	XCRY19			:NO DATA
	LIS	R9,0			:INITIALIZE INDEX INTO DATA FLAG ARRAY
XCRY10	TBT	R9,CRYPRB+CRYFLG,R10,	:TYPE THE (R2+1)TH HW OF DATA?
	JE	XCRY12			:NO
	JAL	R7,TYPASC		:R2 HAS POINTER TO NEXT ASCII STRING
					:HW FOLLOWING POINTS TO CONVERSION RTN
	AIS	R2,2			:MAKE SURE ON 
	NHI	R2,-2			:HW BOUNDARY
	ST	R2,XRSAVE+4,XD

	SLLS	R9,1			:HW INDEX
	LHL	R2,0,R2			:GET SEGD DISP TO APPROP CONVERSION RTN
	LHL	R3,CRYPRB+CRYHW0,R10,R9	:HW OF DATA
	STH	R9,XRSAVE,XD		:SAVE R9 BECAUSE OF TYPHW
	JAL	R9,SEGD,R2,		:TYPE IT
	L	R2,XRSAVE+4,XD
	LHL	R9,XRSAVE,XD		:RESTORE FLAG INDEX
	SRLS	R9,1			:RESTORE FLAG INDEX
	AIS	R2,2			:POINTER TO NEXT ASCII STRING
XCRY12	AIS	R9,1			:NEXT HW
	CLHI	R9,4			:CHECKING ONLY BITS 0-3
	JL	XCRY10			:NEXT
	JFS	XCRY20			:ALL DONE
XCRY19	JAL	R7,TYPASC		:TEXT ONLY, NO DATA
XCRY20	JAL	R7,TYPCRL		:TYPE CR/LF

XCRYP3	HS	0
	LHL	R10,CRYPTU,XD
	AHI	R10,10
	NHI	R10,CRYPRS-1		:UPDATE INDEX
	STH	R10,CRYPTU,XD
	AIS	R14,1			:INCREMENT NUMBER OF MESSAGED TYPED
	JER	R8			:IF 0, ALL DONE
	J	XCRYP1
	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	SUBROUTINE:	XCRPPT:
::	FUNCTION:	PRINT CONTENTS OF CRYPTOGRAM priority BUFFER###al
::	CALLING SEQ:	JAL	R8,XCRPPT
::	INPUT:		R12 =	DISPLAY ONLY MESSAGES MASKED IN CRYMSK
::			ALL MESSAGES  ENABLED IF <0
::			R1 =	-(NUMBER OF MESSAGES TO TYPE). IF >= 0
::			MESSAGES TYPED UNTIL EMPTY PTR = FILL PTR
::
::*********************************************************************

	IF	PRIMSG

XCRPPT	HS	0
	LHL	R10,CRYPPU,XD		:GET THE OUT PTR
XCRPP1	CLH	R10,CRYPPI		:EQUAL IN PTR?
	JER	R8			:YES,RETURN

	LB	R11,CRYPPB+CRYTYP,R10,	:Get message type

XCRPP2	CLHI	R11,CRYMTZ/2		:AVOID CRASH,CHECK FOR VALID INDEX
	JG	XCRPP3

XCRPP4	SLLS	R11,1			:FORM HW INDEX
	L	R2,CRYPPB+CRYGMT,R10,	:GET CRYPTOGRAM TIME AND
	ST	R2,GMTNOW,,		:STORE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE
	LA	R2,ASC1SP		:1 SPACE
	JAL	R7,TYPASC
	LHL	R3,CRYPPB+CRYFAS,R10,	:16 BITS OF FASTC
	JAL	R9,TYPHW		:AND TYPE IT
	LHL	R2,CRYMTB,R11		:GET MESSAGE POINTER
	AI	R2,SEGD			:IN CASE NEEDED BELOW.
	LB	R9,CRYPPB+CRYFLG,R10,	:CHECK FOR 0 FLAGS
	JE	XCRP19			:NO DATA
	LIS	R9,0			:INITIALIZE INDEX INTO DATA FLAG ARRAY
XCRP10	TBT	R9,CRYPPB+CRYFLG,R10,	:TYPE THE (R2+1)TH HW OF DATA?
	JE	XCRP12			:NO
	JAL	R7,TYPASC		:R2 HAS POINTER TO NEXT ASCII STRING
					:HW FOLLOWING POINTS TO CONVERSION RTN
	AIS	R2,2			:MAKE SURE ON 
	NHI	R2,-2			:HW BOUNDARY
	ST	R2,XRSAVE+4,XD

	SLLS	R9,1			:HW INDEX
	LHL	R2,0,R2			:GET SEGD DISP TO APPROP CONVERSION RTN
	LHL	R3,CRYPPB+CRYHW0,R10,R9	:HW OF DATA
	STH	R9,XRSAVE,XD		:SAVE R9 BECAUSE OF TYPHW
	JAL	R9,SEGD,R2,		:TYPE IT
	L	R2,XRSAVE+4,XD
	LHL	R9,XRSAVE,XD		:RESTORE FLAG INDEX
	SRLS	R9,1			:RESTORE FLAG INDEX
	AIS	R2,2			:POINTER TO NEXT ASCII STRING
XCRP12	AIS	R9,1			:NEXT HW
	CLHI	R9,4			:CHECKING ONLY BITS 0-3
	JL	XCRP10			:NEXT
	JFS	XCRP20			:ALL DONE
XCRP19	JAL	R7,TYPASC		:TEXT ONLY, NO DATA
XCRP20	JAL	R7,TYPCRL		:TYPE CR/LF

XCRPP3	HS	0
	LHL	R10,CRYPPU,XD
	AHI	R10,10
	NHI	R10,CRYPPS-1		:UPDATE INDEX
	STH	R10,CRYPPU,XD
	AIS	R14,1			:INCREMENT NUMBER OF MESSAGED TYPED
	JER	R8			:IF 0, ALL DONE
	J	XCRPP1

	EI	:PRIMSG


        SUBTTL   XRAY (TYMSTAR/SIO COMMANDS-IK, RK, CF, BN, SL, SI)
	
	IF (XRSZLV-2)

	IF	STRHUB		:TYMSTR HUB KEY INSERT & REMOVE CMD ##AL

::	There two commands IK and RK will update the new starlinks list
::	on that starline. The hub's restarting (software restart after
::	crach or manually restart) will not change the chaining of new 
::	stations.						###AL

::*********************************************************************
::
::	COMMAND:	XLKKEY:	IK
::	FUNCTION:	ENTER KEY & CHAIN KD TO THE LN & KD LIST
::
::*********************************************************************
XLKKEY	HS	0
	CLHI	R2,$A 12	:MUST BE 3 ARG.S
	JEFS	XLKK0
	LA	R2,AUMG3,,
	JAL	R7,TYPASC,,
	J	XPRMPT
XLKK0	L	R3,VALUE1,XD	:GET LINE# IN DECIMAL
	JAL	R9,DECHEX	:CHANG TO HEX
	J	COMERR		:ERR RET, O.W. +4 RET
	CLHI	R3,NLINES	:MUST BE IN THE SIO LINE#'S RANGE ##AL
	JG	CFHS0
	CLHI	R3,NLINES-SILINS:MUST BE IN THE SIO LINE#'S RANGE ##AL
	JL	CFHS0
	LB	R1,LTYP,R3,R3	:MUST BE STAR LINE FOR PROCESSING
	JE	COMERR
	LR	R8,R3		:SAVE STARLINE# FOR LATER
	SLL	R3,1		:FW BOUNDARY
	L	R3,SKDPTR,R3,R3	:GET SKDTBL BLOCK ADDR. FROM LINE#
	JE	COMERR		:NO STAR LINE?
	L	R5,STHEAD,R3,	:TOP OF SKDTBL
	JN	XLKK1		:CHAIN TO OTHER KD
	L	R4,STXPTR,,	:GET FREE STRXLK PTR
	JE	COMERR		:NO MORE FREE STRXLK?
	ST	R4,STHEAD,R3,
	LIS	R2,0
	ST	R2,NXTLNK,R4,	:STRXLK WILL BE THE ONLY STRLNK
	L	R2,VALUE1+4,XD	:ENTER KEY VALUE TO THE KD
	ST	R2,LNKKEY,R4,
	LB	R1,LKNM,R4,	:UPDATE KEYKN
	STB	R9,SXLNKN,R1,	:STORE STARLINE# TO SXLNKN
	L	R3,VALUE1+8,XD	:GET NODE# IN HEX
	LR	R7,R1		:KEEP R1
	JAL	R9,OCTHXR	:CONVERT TO HEX AND STORE BACKIN R3
	LR	R1,R7		:KEEP R1
	STH	R3,NDID,R4	:STORE TO THE KD
	STH	R3,NEIKN,R1,R1	:UPDATE NEIKN ALSO
	LIS	R3,0		:KEEP ONDID=0 FOR STRXLK ORIGINALLY	###AL
	STH	R3,ONDID,R4	:STORE TO THE KD, NOT AN XLINK NOW	###AL
	LCS	R2,1		:DECREASE NSTXK COUNT			###AL
	AHM	R2,NSTXK,,
	SLL	R1,1		:KN*4
	ST	R2,KEYKN,R1,R1
	J	XPRMPT
XLKK1	L	R4,STXPTR,,	:GET FREE STRXLK PTR
	JN	XLKK2
	LA	R2,KYMSG,,
	JAL	R7,TYPASC,,
	J	XPRMPT		:NO MORE FREE STRXLK?
XLKK2	L	R2,VALUE1+4,XD	:ENTER KEY VALUE TO THE KD
	NI	R2,0FFFFFFFF
	L	R3,VALUE1+8,XD	:GET NODE# IN HEX
	JAL	R9,OCTHXR	:CONVERT TO HEX AND STORE BACKIN R3
	LR	R1,R5
XLKK3
	CL	R2,LNKKEY,R1,	:MATCH KEY
	JEFS	XLKK31
	CLH	R3,NDID,R1,	:MATCH NDID
	JNFS	XLKK4
XLKK31	LA	R2,KYMSG2,,	:KEY/NEIGHBOR ALREADY EXIST
	JAL	R7,TYPASC,,
	J	XPRMPT
XLKK4	L	R1,NXTLNK,R1
	JN	XLKK3
	ST	R2,LNKKEY,R4,
	LB	R1,LKNM,R4,	:UPDATE KEYKN
	STB	R8,SXLNKN,R1,	:STORE STARLINE# TO SXLNKN
	LR	R7,R1		:KEEP R1
	SLLS	R1,1		:KN*4
	ST	R2,KEYKN,R1,R1
	L	R1,NXTLNK,R5,	:ORIGINAL CHAIN
	ST	R4,NXTLNK,R5,	:NEW CHAIN
	L	R2,NXTLNK,R4,	:ORIGINAL FREE CHAIN
	ST	R2,STXPTR,,	:UPDATE STXPTR
	ST	R1,NXTLNK,R4,	:NEW CHAIN
	STH	R3,NDID,R4	:STORE NEIGHBOR# IN R3 TO THE KD
	LR	R1,R7		:R1 IS LKNM
	STH	R3,SXNDID,R1,R1	:SAVE NDID IN CASE OF HUB RESTART
	STH	R3,NEIKN,R1,R1	:UPDATE NEIKN ALSO
	LIS	R3,0		:KEEP ONDID=0 FOR STRXLK ORIGINALLY	###AL
	STH	R3,ONDID,R4	:STORE TO THE KD, NOT AN XLINK NOW	###AL
	LCS	R2,1		:DECREASE NSTXK COUNT			###AL
	AHM	R2,NSTXK,,
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	RMXKEY:	RK
::	FUNCTION:	REMOVE KEY(REPALCE BY 0FFFFFFFF)
::			AND KD FROM THE KEYKN & ACTIVE KD LIST
::
::*********************************************************************
RMXKEY	HS	0	
	CLHI	R2,$A 12	:MUST BE 3 ARG.S
	JEFS	RMXK0
	LA	R2,AUMG3,,	:'NEED 3 ARGUMENTS'
	JAL	R7,TYPASC,,
	J	XPRMPT
RMXK0	L	R3,VALUE1,XD	:GET LINE# IN DECIMAL
	JAL	R9,DECHEX	:CHANG TO HEX
	J	COMERR		:ERR RET, O.W. +4 RET
	CLHI	R3,NLINES	:MUST BE IN THE SIO LINE#'S RANGE ##AL
	JG	SSHS3
	CLHI	R3,NLINES-SILINS:MUST BE IN THE SIO LINE#'S RANGE ##AL
	JL	SSHS3
	LB	R1,LTYP,R3,R3	:MUST BE STAR LINE FOR PROCESSING
	JE	COMERR
	SLL	R3,1		:FW BOUNDARY
	L	R3,SKDPTR,R3,R3	:GET SKDTBL BLOCK ADDR. FROM LINE#
	JE	COMERR		:NO STAR LINE?
	L	R1,STHEAD,R3,	:TOP OF SKDTBL
	JNFS	RMXK1		:CHAIN TO OTHER KD
NOKEY	LA	R2,RKMSG,,	:NO THIS KEY
	JAL	R7,TYPASC,,
	J	XPRMPT
RMXK1	L	R2,VALUE1+4,XD	:GET KEY VALUE
	NI	R2,0FFFFFFFF
RMXK2	CL	R2,LNKKEY,R1,	:MATCH KEY
	JE	RMXK4
	J	RMXNXT
RMXK3	CL	R2,LNKKEY,R1,	:MATCH KEY
	JN	RMXNXT
	LR	R2,R3		:KEEP R3
	L	R3,VALUE1+8,XD	:GET NODE# IN HEX
	LR	R7,R1		:KEEP R1
	JAL	R9,OCTHXR	:CONVERT TO HEX AND STORE BACKIN R3
	LR	R1,R7		:KEEP R1
	CLH	R3,NDID,R1	:COMPARE TO THE KD
	JEFS	RMXK3N
	LA	R2,RKMSG2,,	:'NEIGHBOR NUMBER NOT MATCHED'
	JAL	R7,TYPASC,,
	J	XPRMPT
RMXK3N	LR	R3,R2		:KEEP R3
	LB	R2,STAFLG,R1,	:IF LINK IS UP DO BORZAP THEN CHAIN
	CHI	R2,LNKSTA
	JNFS	RMXK33
BZKEY	LA	R2,RKMSG1,,	:TYPE MSG TO NOTIFY DOING BORI ZAP
	JAL	R7,TYPASC,,
	J	XPRMPT
RMXK33	L	R2,NXTLNK,R1,
	ST	R2,NXTLNK,R3,	:CHAIN THE MAIN KD LIST
	J	FREKY2
RMXNXT	LR	R3,R1		:KEEP OLD KD IN R3 TEMPORARY
	L	R1,NXTLNK,R1,	
	JN	RMXK3
	J	NOKEY
RMXK4	LR	R2,R3		:KEEP R3
	L	R3,VALUE1+8,XD	:GET NODE# IN HEX
	LR	R7,R1		:KEEP R1
	JAL	R9,OCTHXR	:CONVERT TO HEX AND STORE BACKIN R3
	LR	R1,R7		:KEEP R1
	CLH	R3,NDID,R1	:STORE TO THE KD
	JEFS	RMXK4N
	LA	R2,RKMSG2,,	:'NEIGHBOR NUMBER NOT MATCHED'
	JAL	R7,TYPASC,,
	J	XPRMPT
RMXK4N	LR	R3,R2
	LB	R2,STAFLG,R1,	:IF LINK IS UP DO BORZAP THEN CHAIN
	CHI	R2,LNKSTA
	JNFS	RMXK44
	J	BZKEY
RMXK44	L	R2,NXTLNK,R1,
	ST	R2,STHEAD,R3,	:UPDATE STHEAD IF FIRST KD KEY MATCHED
FREKEY		
FREKY2	LB	R3,LKNM,R1,	:UPDATE KEYKN
	LHI	R2,0FF		:UPDATE SXLNKN BY FF
	STB	R2,SXLNKN,R3,
	LIS	R2,0
	STH	R2,NDID,R1,	:STORE TO THE KD
	STH	R2,ONDID,R1,	:STORE TO THE KD, NOT AN XLINK NOW	###AL
	STH	R2,NEIKN,R3,R3	:UPDATE NEIKN ALSO
	LHI	R2,STXKWZ	:UPDATE WSZKN AND UNTIL RESTART TO GET
	STH	R2,WSZKN,R3,R3	: STAR-XLINK WSZ SECTORS		###AL	
	LIS	R2,1		:INCREASE NSTXK COUNT			###AL
	AHM	R2,NSTXK,,
	LI	R2,0FFFFFFFF	:FREE THE KEY AND CHAIN TO THE POOL
	ST	R2,LNKKEY,R1,
	SLL	R3,1		:KN*2
	ST	R2,KEYKN,R3,R3
	SRL	R3,1
	L	R2,STXPTR,,
	ST	R2,NXTLNK,R1,
	ST	R1,STXPTR,,
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	CLLKFG:	CF				###LSH
::	FUNCTION:	CLEAR TYMSTAR LINK STATUS FLAG
::
::*********************************************************************
CLLKFG	HS	0
	CLHI	R2,8		:MUST BE 2 ARG.S
	JN	COMERR
	L	R3,VALUE1,XD	:GET LINE# IN DECIMAL
	JAL	R9,DECHEX	:CHANGE TO HEX
	J	COMERR		:ERROR
	CLHI	R3,NLINES	:MUST BE IN THE SIO LINE#'S RANGE ##AL
	JG	SSHS3
	CLHI	R3,NLINES-SILINS:MUST BE IN THE SIO LINE#'S RANGE ##AL
	JL	SSHS3
	LB	R1,LTYP,R3,R3	:MUST BE STAR LINE FOR PROCESSING
	JN	CFHS3		:YES, IT IS A STAR LINE
CFHS0	LA	R2,CFMSG1,,	:NOT STAR LINE, TYPE ERROR MESSAGE
	JAL	R7,TYPASC,,
	J	XPRMPT
CFHS3	SLL	R3,1		:SET UP FULLWORD INDEX
	L	R3,SKDPTR,R3,R3	:R3=POINTER TO STAR LINE LINK CHAIN TABLE
	JE	COMERR		:SOMETHING WRONG, SKDPTR IS NOT SET UP YET.
	L	R4,STHEAD,R3,	:R4 POINT TO THIS STARLINE'S 1ST LINK TABLE
	JLE	COMERR		:R4 MUST BE REAL			###AL
	L	R3,VALUE1+4,XD	:GET NEIGHBOR NUMBER
	JAL	R9,OCTHXR	:CHANGE TO HEX
CFHS2	CLH	R3,NDID,R4	:IS THIS NEIGHBOR ?
	JEFS	CFHS1		:YES, GO TO CHECK LINK FLAG
	L	R4,NXTLNK,R4	:NEXT STAR LINK TABLE
	JNBS	CFHS2		:LOOP AGAIN
	LA	R2,CFMSG2,,	:WRONG NEIGHBOR NUMBER
	JAL	R7,TYPASC,,
	J	XPRMPT
CFHS1	LB	R2,STAFLG,R4	:LINK STATUS FLAG
	CHI 	R2,LNKSTA	:IS LINK ACTIVE ?
	JNFS	CFHS4		:NO, GO TO CLEAR IT
	LA	R2,CFMSG3,,	:ACTIVE LINK, CAN'T CLEAR IT
	JAL	R7,TYPASC,,
	J	XPRMPT
CFHS4	LIS	R2,0		:CLEAR LINK STATUS FLAG
	STB	R2,STAFLG,R4	
	J	XPRMPT

	IF	RBTHUB:WILL BE UNDER STRHUB
::*********************************************************************
::
::	COMMAND:	RBTNBR:	BN				###AL
::	FUNCTION:	REMOTE BOOT THE NEIGHBOR
::
::*********************************************************************
RBTNBR	HS	0
	CLHI	R2,8		:MUST BE 2 ARG.S
	JN	COMERR
	L	R3,VALUE1,XD	:GET LINE# IN DECIMAL
	JAL	R9,DECHEX	:CHANGE TO HEX
	J	COMERR		:ERROR
	CLHI	R3,NLINES	:MUST BE IN THE SIO LINE#'S RANGE ##AL
	JG	COMERR
	CLHI	R3,NLINES-SILINS:MUST BE IN THE SIO LINE#'S RANGE ##AL
	JL	COMERR
	LB	R1,LTYP,R3,R3	:MUST BE STAR LINE FOR PROCESSING
	JE	COMERR		:YES, IT IS A STAR LINE
	SLL	R3,1		:SET UP FULLWORD INDEX
	L	R3,SKDPTR,R3,R3	:R3=POINTER TO STAR LINE LINK CHAIN TABLE
	JE	COMERR		:SOMETHING WRONG, SKDPTR IS NOT SET UP YET.
	L	R4,STHEAD,R3,	:R4 POINT TO THIS STARLINE'S 1ST LINK TABLE
	JLE	COMERR		:R4 MUST BE REAL			###AL
	L	R3,VALUE1+4,XD	:GET NEIGHBOR NUMBER
	JAL	R9,OCTHXR	:CHANGE TO HEX
RBT1	CLH	R3,NDID,R4	:IS THIS NEIGHBOR ?
	JEFS	RBT2		:YES, GO TO SET LINK RBTFLG FLAG
	L	R4,NXTLNK,R4	:NEXT STAR LINK TABLE
	JNBS	RBT1		:LOOP AGAIN
	LA	R2,CFMSG2,,	:WRONG NEIGHBOR NUMBER
	JAL	R7,TYPASC
	J	XPRMPT
RBT2	LIS	R2,1		
	STB	R2,RBTFLG,R4	
	J	XPRMPT
	EI:RBTHUB

::*********************************************************************
::
::	COMMAND:	NDSTAR:	SL				##AL
::	FUNCTION:	TYMSTAR LINE DISPLAY
::
::*********************************************************************
NDSTAR	HS	0
	CLHI	R2,4		:MUST BE SINGLE ARG
	JEFS	NDSTA1
	LA	R2,NDSMSG,,	:ERR MSG 'NEED A STARLINE NUMBER'
	JAL	R7,TYPASC
	J	XPRMPT
NDSTA1	L	R3,VALUE1,XD	:GET LINE# IN DECIMAL
	JAL	R9,DECHEX	:CHANGE TO HEX
	J	COMERR		:ERROR
	CLHI	R3,NLINES	:MUST BE IN THE SIO LINE#'S RANGE ##AL
	JG	SSHS3
	CLHI	R3,NLINES-SILINS:MUST BE IN THE SIO LINE#'S RANGE ##AL
	JL	SSHS3
	LB	R1,LTYP,R3,R3	:MUST BE STAR LINE FOR PROCESSING
	JNFS	NDSTA2		:YES, IT IS A STAR LINE
	LA	R2,CFMSG1,,	:NOT STAR LINE, TYPE ERROR MESSAGE
	JAL	R7,TYPASC
	J	XPRMPT
NDSTA2	SLLS	R3,1
	L	R2,KDLN,R3,R3	:LINE MUST BE UP?
	JG	NDSTA3
	LA	R2,NDSMG1,,	:ERR MSG 'STARLINE IS DOWN'
	JAL	R7,TYPASC
	J	XPRMPT
NDSTA3	SRLS	R3,1
	LA	R2,XNDHD4,,	:HEADER TO DISPLAY LINE/LINK STATUS
	JAL	R7,TYPASC
	JAL	R9,TYPBYD	:TYP LINE# OF R3
	LIS	R2,1		:SET SLFLAG
	STB	R2,SLFLAG,,
	LR	LN,R3		:USE LN
	J	XNDSTR		:ND CMD WILL TAKE CARE IF '>SL'
	EI	:STRHUB

::*********************************************************************
::
::	COMMAND:	RSSILN:	SI				###LSH
::	FUNCTION:	INITIALIZE AN SIO LINE
::
::*********************************************************************

	IF	SILINS 
RSSILN	HS	0
	CLHI	R2,4		:MUST BE SINGLE ARG
	JN	COMERR
	L	R3,VALUE1,XD	:GET LINE# IN DECIMAL
	JAL	R9,DECHEX	:CHANGE TO HEX
	J	COMERR		:ERROR
	CLHI	R3,NLINES	:MUST BE IN THE SIO LINE#'S RANGE ##AL
	JGFS	SSHS3
	SHI	R3,NLINES-SILINS:CHECK IF IN SIO LINE RANGE
	JGEFS	SSHS1		:YES, 
SSHS3	LA	R2,SSMSG1,,	:NOT A SIO LINE
	JAL	R7,TYPASC,,
	J	XPRMPT
SSHS1	CLHI	R3,SILINS	:CHECK IF IT IS TOO BIG
	JGE	SSHS3		:WRONG LINE #
	SLLS	R3,4		:16*LINE#
	LCS	R2,2
	STH	R2,SIOSTT+8,R3,	:-2 INDICATES SOFTWARE INIT
	J	XPRMPT		
	EI	:SILINS	
	EI	:(XRSZLV-2)		:##AL


	SUBTTL	XRAY (Miscellaneous - GB, G , HT, SN, PS, SY, BD)

::*********************************************************************
::
::	COMMAND:	GOBKPT:	GB
::	FUNCTION:	PROCEED FROM BREAKPOINT
::
::*********************************************************************

	IF	1-ISIS
GOBKPT	HS	0
	LHL	R2,ARGCT,XD
	JG	COMERR			:TOO MANY ARGS
	L	R1,XCRADD		:CRASH ADDRESS
	JLE	COMERR			:NO CRASH SET
	L	R0,XCRSAV		:COMMAND
	ST	R0,0,R1			:RESTORE IT
	LCS	R0,1
	ST	R0,XCRADD		:NOTE THERE IS NO CRASH SET
	JFS	PRCEE1			:AND START NODE UP
	EI	:1-ISIS

::*********************************************************************
::
::	COMMAND:	PRCEED:	G
::	FUNCTION:	1 ARG  =  EXECUTE ADDRESS
::			0 ARGS =  CLEAR NODE FLAGS
::
::*********************************************************************

	IF	1-ISIS
PRCEED	HS	0
	LHL	R2,ARGCT,XD
	CLHI	R2,4			:IF 1 ARG, PROCEED ADDR
	JLFS	PRCEE1			:NO ARG, JUST PROCEED
	JG	COMERR			:TOO MANY ARGS
	L	R3,VALUE1,XD	
	LA	R11,ANCPSW+4
	SVC	0F,SV.WFA	
PRCEE1	LIS	R3,0
	LA	R11,ANFLGS
	SVC	0F,SV.WHA
	J	XRPRMT
	EI	:1-ISIS

::*********************************************************************
::
::	COMMAND:	KHALT:	HT
::	FUNCTION:	HALTS THE NODE CODE WITH A SUPPRESS SVC
::
::*********************************************************************

	IF	1-ISIS
KHALT	HS	0
	LA	R1,ANFLGS-2
	SVC	0F,SV.RAB
	NI	R1,0FFFF
	JN	COMERR
	LIS	R3,SLEEPF
	LA	R11,ANFLGS
	SVC	0F,SV.WHA
	LA	R11,ANHALT
	SVC	0F,SV.WHA
	J	XRCRLF
	EI	:1-ISIS

::*********************************************************************
::
::	COMMAND:	XRSTRT:	SN
::	FUNCTION:	RESTARTS NODE CODE 
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl
XRSTRT	HS	0
	IF	1-ISIS
	LIS	R0,0			:###wjl
	STH	R0,CRSHID		:manual restart crash code
	ST	R0,CRSHPS		:store crash psw
	ST	R0,CRSHAD		:store crash address
	JAL	R9,GMTCAL		:returns current time in GMTNOW
	L	R0,GMTNOW,,
	ST	R0,CRSHTM		:store crash time
	STH	XD,XDSAVE,,		:CTENTR clobbers R15!
	JAL	R10,CTENTR,,		:make crash table entry
	LHL	XD,XDSAVE,,		:restore XD

	CI	XD,TTYXD		:TTY USER?
	JE	XRSTR1			:YES
	EI	:1-ISIS

	J	RESTRT,,		:GO RESTART

XRSTR1	HS	0
	IF	1-ISIS
	LA	R1,ANIPSW
	SVC	0F,SV.RAB
	LR	R3,R1
	LA	R11,ANCPSW
	SVC	0F,SV.WFA
	LA	R1,ANIPSW+4
	SVC	0F,SV.RAB
	LR	R3,R1
	LA	R11,ANCPSW+4
	SVC	0F,SV.WFA
	J	PRCEE1
	EI	:1-ISIS
	EI	:2-XRYTMC ###wjl

::*********************************************************************
::
::	COMMAND:	STATUS:	PS
::	FUNCTION:	TYPE USER FLAGS & PSW
::
::*********************************************************************

	IF	1-ISIS
STATUS	HS	0
	JAL	7,TYP2SP
STATU1	HS	0
	LA	R1,ANFLGS-2
	SVC	0F,SV.RAB
	NI	R1,0FFFF
	LR	R3,R1
	JAL	9,TYPHWS
	LA	R1,ANCPSW
	SVC	0F,SV.RAB
	LR	R3,R1
	JAL	9,TYPFW
	LA	R1,ANCPSW+4
	SVC	0F,SV.RAB
	LR	R3,R1
	JAL	9,TYPFW
	J	XRCRLF
	EI	:1-ISIS

::*********************************************************************
::
::	ROUTINE:	XERINT:
::	FUNCTION:	XRAY ERROR INDICATOR
::	INPUT:		R1 = ANHALT, THE CRASH CODE INDICATOR.
::	ANHALT IS SET UP IN SHARE WHEN THE PRIVELEGED CODE DETECTS
::	A NODE CODE ERROR
::
::*********************************************************************

	IF	1-ISIS
XERINT	HS	0
	LCS	R3,1			:CLEAR FLAG SO WE COME HERE ONLY ONCE
	LA	R11,ANHALT
	SVC	0F,SV.WHA
XERIN2	CLHI	R1,SLEEPF		:NODE HALTED BY OPERATOR?
	JNFS	XERIN1			:NO
	LA	R2,ASCHLT,,		:YES
	L	R0,ANCPSW+4		:HW2&3 OF CRYPTO MESSAGE
	J	XERIN9

XERIN1	CLHI	R1,ILLERF		:ILLEGAL INSTRUCTION?
	JNFS	XERIN3			:NO
	LA	R2,ASCERT,,		:YES, TYPE MESSAGE
	L	R0,ILIPSW+4
	J	XERIN9

XERIN3	CLHI	R1,MALNTF		:MACHINE MALFUNCTION?
	JNFS	XERIN4			:NO
	LA	R2,ASCMMR,,		:TYPE 'PARITY ERR' MESSAGE
	L	R0,MALPSW+4
	J	XERIN9

XERIN4	CLHI	R1,MACNTF		:MAC INTERRUPT?
	JNFS	XERIN5			:NOT MAC INTERRUPT...
	LA	R2,ASCMCR,,		:MAC INTERRUPT
	L	R0,MACPSW+4
	JFS	XERIN9

XERIN5	CLHI	R1,DMATOF		:DMA TIMEOUT?
	JNFS	XERIN6			:NO
	L	R0,7C			:GET MAC STATUS REGISTER
	LA	R2,DMAERR,,
	JFS	XERIN9

XERIN6	LA	R2,ASCPF,,		:MUST BE POWER FAIL...TYPE OUT
	LIS	R0,0

XERIN9	ST	R0,CRYSBF		:SAVE PC
	ST	R0,CRASHX		:STORE CRASH 'ADDRESS' FOR 'ND' CMD
	LR	R0,R1			:COPY CRASH ID OVER TO R0
	JAL	R8,CRYPTO,,		:TELL CRYPTO
	HC	CRYE00			:CRASH
	JAL	R7,TYPASC		:TYP OUT DIAGNOSIS
	J	XPRMPT
	EI	:1-ISIS
	EI	:(XRSZLV-2)		:##AL

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	SYMBAD:	SY
::	FUNCTION:	TYPES OUT ADDRESSES OF SYMBOLS FROM THE SYMBOL TABLE
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl
SYMBAD	HS	0
	JAL	R13,XRYIN
	NHI	R1,ASC7BT		:STRIP HOB (x7F)
	CLHI	R1,ASCSPC		:MUST BE SPACE (x20)
	JN	COMERR			:SORRY...
	JAL	R13,XRYIN		:GET KEY TO TABLE
	LR	R6,R1
	JAL	R7,TYPCRL		:TYP CR-LF
	OHI	R6,80			:SET HOB
	LIS	R5,0

	GL	SYMTBL

SYMBA1	CLHI	R6,ASCAST+80		:ASTERISK (x20) = DISPLAY ENTIRE TABLE
	JEFS	SYMBA3

	NHI	R6,ASCUC		:ASSUME ALPHABETIC,ENSURE UPPERCASE/xDF
	LB	R2,SYMTBL+1,R5,		:GET FIRST CHARACTER
	CR	R2,R6
	JN	SYMBA2			:NOT A MATCH

SYMBA3	LA	R2,SYMTBL,R5,		:SYMBOLIC NAME
	JAL	R7,TYPASC
	JAL	R7,TYP2SP		:2 SPACES
	L	R3,SYMTBL+8,R5,		:SYMBOL ADDRESS
	JAL	R9,TYPFW		:TYPE IT OUT
	JAL	R7,TYPCRL

SYMBA2	AHI	R5,ADRESZ	
	CLHI	R5,SYMTSZ		:AT END OF TABLE?
	GL	SYMTSZ
	JL	SYMBA1
	J	XPRMPT			:FINISHED
	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	XBDSET:	BD	###JHL
::	FUNCTION:	BD sets or displays buffer delay timing method.
::	INPUT:		BD displays current method
::			BDP sets timing by char pairs (COMETS 0314)
::			BDR sets timing based on round robin frequency
::
::*********************************************************************

	IF	BFLTMR
XBDPR0	SC	/"0D"0ABUFFER DELAY BY TIMING PAIRS"0D"0A/
XBDPR1	SC	/"0D"0ABUFFER DELAY BY RMK FREQUENCY"0D"0A/

XBDSET	HS	0
	CLHI	R1,ASCP			:DID USER END WITH P?
	JE	XBDSTP			:ZERO OUT THE CELL
	CLHI	R1,ASCR			:DID USER END WITH R?
	JE	XBDSTR			:STORE NON-ZERO IN THE CELL
XBDDSP	LHL	R1,BFDOPT,,		:READ THE CELL
	JEFS	XBDCPR			:GET CHAR PAIR STRING
	LA	R2,XBDPR1		:POINT TO RMK FREQ STRING
	JFS	XBDS10
XBDCPR	LA	R2,XBDPR0		:POINT TO CHAR PAIR STRING
XBDS10	JAL	R7,TYPASC		:OUTPUT THE STRING
	J	XPRMPT			:BACK TO TOP LEVEL

XBDSTP	LIS	R1,0			:FOR CHAR TIMING
XBDS20	STH	R1,BFDOPT,,		:STORE SELECTED VALUE
	J	XBDDSP			:DISPLAY CURRET OPTION TO USER
XBDSTR	LIS	R1,1			:FOR TIMING BY RMK FREQ
	JBS	XBDS20
	EI	:BFLTMR
	EI	:(XRSZLV-2)		:##AL

	SUBTTL 	XRAY (Delay measurement - DL, DB, DD, DE)

	IF	(XRSZLV-1)		:##AL

::*********************************************************************
::
::	COMMAND:	XLUPBK:	DL
::	FUNCTION:	CONSTRUCTS A CLOSED CIRCUIT THAT PASSES THROUGH
::			ALL NODES IN THE ARGUMENT LIST.
::
::*********************************************************************

:	INITIAL 'FILL' BYTES ARE PUT IN THE OUTBOUND BUFFER, AND THEY
:	SUBSEQUENTLY MOVE 'ROUND AND 'ROUND THE LOOP.
:	THE CPS RATE THEY GENERATE (MEASURED WITH THE KS AND NS COMMANDS)
:	INDICATE THE PROCESSING SPEEDS OF THE NODES INCLUDED IN THE CIRCUIT.

:	local equates for needle flag bits
PRTYBT	EQ	100			:priority bit
TPCLA	EQ	00			:throughput class A
TPCLB	EQ	10			:throughput class B
TPCLC	EQ	20			:throughput class C
TPCLD	EQ	30			:throughput class D

	IF	2-XRYTMC		:###wjl
	NOLIST
TPCLAS	SC	/"0D"0ATHROUGHPUT CLASS (0-3): /
	LIST
XLUPBK	HS	0
	LHL	R0,INTLPF,,		:CURRENTLY ONLY 1 LOOPBACK IS SUPPORTED
	JN	COMERR			:ALREADY ONE THERE, ERROR
	TS	XLUPFL			:SET FLAG AND FALL THRU TO DBEGIN CODE

::*********************************************************************
::
::	COMMAND:	DBEGIN:	DB
::	FUNCTION:	COMMAND HANDLER TO INPUT PARAMETERS FOR ROUND-TRIP
::			DELAY MEASUREMENT
::
::*********************************************************************

DBEGIN	HS	0
	SIS	R2,4			:IF NO ARG'S, INDEX = 0.
	JGEFS	DBEGIA			:AT LEAST 1 ARG.
	LIS	R6,0			:DEFAULT INDEX = 0
	JFS	DBEGIB
DBEGIA	LHL	R6,VALUE1+2,XD		:GET DB-INDEX FROM CMD LINE	###JHL
	LH	R13,XPOWER,XD		:GET USER'S POWER		###TZ
	JLEFS	DBEGI9			:OK
	LR	R6,R6
	JN	XPWER1			:ONLY INDEX 0 FOR NON-POWER
DBEGI9	CLHI	R6,TINTCH/2
	JGE	COMERR			:ARGUMENT IS TOO LARGE
DBEGIB	LHL	R13,INTUSE		:MAKE SURE WE HAVE A CHANNEL
	XHI	R13,0FFFF
	JFFOH	R13,DBEGI1
	J	DBERR			:NO,NONE
DBEGI1	CLHI	R14,TINTCH		:MAKE SURE CHANNEL NUMBER'S IN RANGE
	JGE	DBERR			:NO, WE HAVE NO CHANNELS
	STH	R6,INTNDX,R14,R14	:STORE DB-INDEX BY INTHST CHAN#
	LR	R7,R6			:SAVE INDEX
	LHI	R6,DLYBSZ		:SIZE OF DLY DATA AREA
	MHR	R6,R7			:TIMES INDEX = OFFSET INTO TABLE AREA
	AI	R6,DLYBSE		:FORM OFFSET TO THIS INDEX
	LH	R2,DLSTAT,R6		:MAKE SURE IT IS AVAILABLE
	JG	DBERR			:STATUS OF 1 MEANS IT IS IN USE
	STH	R14,DLYCHN,R7,R7	:DELAY # TO INT HST CHN# PERMUTER TBL
	STH	R6,CHNDLY,R14,R14	:CHN # TO DELAY ADDRESS PERMUTER TABLE
	LHI	R2,8080+TPCLD		:MAKE SURE FLAGS ARE NEVER ZERO
	OH	R2,DLYFLG,R6
	STH	R2,DLYFLG,R6
	LR	R7,R7			:DLY CHN INDEX 0?
	JNFS	DBEGIC			:NO, GO PROMPT
	LHI	R2,8080+TPCLD		:PRIORITY 0 FLAGS--THRUPUT CLASS 3
	STH	R2,DLYFLG,R6
	LIS	R2,0
	STH	R2,DLYFIL,R6		:DEFAULT 0 HW FILL
	LIS	R2,3
	STH	R2,DLYINT		:DEFAULT RATE = 3 (1 SEC)
	J	DBEGI6			:GO ASK FOR NODE LIST.
DBEGIC	LA	R2,PRPRTY,,		:PROMPT FOR PRIORITY
	JAL	R7,TYPASC
	JAL	R9,RDARGS,,
	SIS	R1,ASCCR
	JN	COMERR			:MUST TERMINATE ON CR, ELSE ERROR
	LR	R2,R2
	JEFS	DBEGI3			:NO ARGUMENT,LEAVE PRIORITY UNCHANGED
	LHI	R2,8080+TPCLD		:DEFAULT FLAGS (HIGH-SPEED)
	LR	R3,R3			:TEST ARGUMENT
	JLEFS	DBEGI7			:<= 0 MEANS NOT PRIORITY
	OHI	R2,PRTYBT		:SET PRIORITY BIT
DBEGI7	STH	R2,DLYFLG,R6		:AND STORE FLAG
DBEGI3	HS	0
:	set TP class limit for delay msmt circuits	###jhl
	LA	R2,TPCLAS		:pointer to "TP CLASS?" string
	JAL	R7,TYPASC		:output string to user
	JAL	R9,RDARGS,,		:get response from user
	SIS	R1,ASCCR		:insure user ended with <cr>
	JN	COMERR			:output the witty "??"
:	now R2 has # args, R3 has last number entered
	LR	R2,R2			:check # args
	JE	DBEG20			:no args--TP class is default
	SLLS	R3,4			:shift arg into speed bits position
	CLHI	R3,TPCLA		:can't be less than class A (0)
	JL	COMERR
	CLHI	R3,TPCLD		:nor more than class D (3)
	JG	COMERR
	LHL	R2,DLYFLG,R6
	NHI	R2,0FFFF-30		:clear the speed bits field
	AR	R3,R2			:add in the new speed bits
	STH	R3,DLYFLG,R6		:and write the new needle flags

DBEG20	LA	R2,PRFILL,,		:PROMPT FOR NUMBER OF FILL HWS
	JAL	R7,TYPASC
	JAL	R9,RDARGS
	SIS	R1,ASCCR		:MUST TERMINATE WITH CR
	JN	COMERR			:ELSE ABORT
	LR	R2,R2
	JEFS	DBEGI5			:NO ARGUMENT,LEAVE FILL UNCHANGED
	SRLS	R3,1			:CONVERT BYTES TO HW
	STH	R3,DLYFIL,R6
DBEGI5	LA	R2,PRTINT,,
	LH	R0,XLUPFL		:IS THIS SPECIAL LOOPBACK CRQ?
	JL	DBEGI6			:YES, LEAVE TIME INTERVAL ALONE
	JAL	R7,TYPASC		:PROMPT FOR TIME INTERVAL
	JAL 	R9,RDARGS		:AND READ IN THE VALUE
	SIS	R1,ASCCR
	JN	COMERR			:MUST TERMINATE ON CR
	LR	R2,R2			:CHECK FOR ZERO ARGUMENTS
	JEFS	DBEGI6			:YES,LEAVE TIME INTERVAL UNCHANGED
	NHI	R3,7			:KEEP JUST LOWER 3 BITS
	IF	ISIS
	CLHI	R3,7			:ISIS DOESN'T GET A RATE OF 7
	JNFS	DBEISI
	LIS	R3,6
DBEISI	HS	0
	EI	:ISIS
	STH	R3,DLYINT,,		:STORE AWAY RATE
DBEGI6	LA	R2,PRNODE,,		:PROMPT FOR NODES
	JAL	R7,TYPASC
	JAL	R9,RDARGS		:READ IN UP TO 8 NODES
	CLHI	R1,ASCR			:ENDED IN 'R' (x52)?
	JN	DBEGR1			:NO...
	LHI	R2,$A12			:YES, INITIALIZE INDEX       ###SHM
	JAL	R9,OCTHXR		:CONVERT LAST NODE(R3) TO HEX###SHM
	LHI	R4,MACHNM		:GET OUR NODE NUMBER IN HEX  ###SHM
DBEGR2	STH	R3,NODLST,R2,R6		:STORE DESIRED NODE          ###SHM
	STH	R4,NODLST+2,R2,R6	:STORE OUR NODE              ###SHM
	SIS	R2,4			:DECREMENT NODE COUNT        ###SHM
	JGEBS	DBEGR2			:DONE?                       ###SHM
	LHI	R2,$A16			:LOAD 2 X NUMBER OF NODES    ###SHM
	STH	R2,NODCNT,R6		:STORE IN NODCNT             ###SHM
	JAL	R7,TYPCRL		:ECHO CRLF                   ###SHM
	J	DBEGI8			:GO PROCESS NODLST           ###SHM
DBEGR1	JAL	R7,TYPCRL		:ECHO CRLF
	LHL	R2,ARGCT,XD		:4 x NUMBER OF NODES IN ONE-WAY PATH
	SRLS	R2,1			:MAKE IT TWICE # OF NODES
	JE	DBEGI8			:NO ARGS, LEAVE NODE LIST UNCHANGED

	STH	R2,NODCNT,R6		:STORE IN NODE COUNT FIELD
        LIS	R4,0			:INITIALIZE OFFSET              ###SHM
DBEGI4	L	R3,VALUE1,R4,XD		:LOAD FW NODE NUMBER            ###SHM
	JAL	R9,OCTHXR		:CONVERT TO HEX		        ###SHM
	SRLS	R4,1			:CONVERT TO HW INDEX            ###SHM
	STH	R3,NODLST,R4,R6		:STORE HEX NODE NUMBER IN NODLST###SHM
        AR	R4,R4			:BACK TO FW INDEX               ###SHM
	AIS     R4,4			:INCREMENT INDEX                ###SHM
	SIS	R2,2			:DECREMENT NODE COUNT           ###SHM
	JGBS	DBEGI4			:MORE?                          ###SHM
DBEGI8	LIS	R4,1
	STH	R4,DLSTAT,R6		:MARK NEW STATUS : NEEDLE REQUESTED
	LIS	R0,0
	STH	R0,DLYPTF,R6		:ZERO THE FILL POINTER
	STH	R0,DLYAV1,R6
	STH	R0,DLYAV2,R6
	LHI	R2,20			:CLEAR SAMPLE AREA SO AS NOT TO
	LI	R1,DLYTBL,R6		:NOT TO CONFUSE POOR USER IN THE
	JAL	R8,HCLEAR,,		:EARLY GOING.
	SBT	R14,INTUSE		:MARK THE CHANNEL IN USE
	LHI	CHN,INTZFL,R14		:PASS ABSOLUTE CHANNEL NUMBER TO MAKNDL
	JAL	R10,MAKNDL,,		:GO MAKE THE NEEDLE
	LH	R0,XLUPFL		:IS THIS A LOOPBACK CRQ?
	JL	DBEG10			:YES

	LHI	R0,DLYREC-SEG1		:GET DISPATCH ADDRESS FOR THIS CHN
	STH	R0,INTDSP,R14,R14	:AND STORE INTO INTHST DISPATCH ARRAY
	SBT	R14,INTDRF		:SET THE DELAY RECEIVER CRQ FLAG
	LHI	R1,ASCD			:WRITE FUNCTION BYTE AFTER NEEDLE
	JAL	R8,WCI,,		:...BUFFER # WAS SET UP IN MAKNDL
	LHL	R1,DLYFIL,R6		:ALSO GET #OF FILL HW
	JAL	R9,WCIE,,		:AND SEND AFTER NEEDLE
	EXBR	R1,R1			:move high order byte for WCI	###JHL
	JAL	R9,WCIE,,		:and send after needle		###JHL
:	CREATOR OF DLY MSMT CIRCUIT IS OWNER				###JHL
	LHL	R6,INTNDX,R14,R14	:READ DB-INDEX FROM ARRAY BY CHAN#
	AR	R6,R6			:DOUBLE FOR HW OFFSET
	ST	XD,DB0USE,R6,R6		:IDENTIFY CREATOR IN WORD ARRAY

	J	XPRMPT			:ALL DONE

DBEG10	LHI	R0,DLYERR-SEG1
	STH	R0,INTDSP,R14,R14	:DISPATCH ADDRESS = BIT BUCKET
	SBT	R14,INTLPF		:MARK THIS CHANNEL AS LOOPBACK ONE
	LHI	R1,ASCL^10+ASCL		:function byte and fillchars = 'L'
	JAL	R8,WCI,,		:R2 WAS SET UP IN MAKNDL
	LHL	R10,DLYFIL,R6		:FILL NUMBER OF HW
DBEG11	JAL	R9,WHWI,,		:WRITE INTO BUFFER AFTER NEEDLE
	SIS	R10,1
	JGBS	DBEG11
	LIS	R0,0
	STH	R0,XLUPFL		:CLEAR FLAG
:	CREATOR OF DLY MSMT CIRCUIT IS OWNER				###JHL
	LHL	R6,INTNDX,R14,R14	:RECOVER DLY CHN INDEX
	AR	R6,R6			:DOUBLE TO HW OFFSET
	ST	XD,DB0USE,R6,R6		:IDENTIFY CREATOR IN WORD ARRAY

	J	XPRMPT			:ALL DONE

DBERR	LI	R2,DERMSG		:###TZ
	JAL	R7,TYPASC
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	DLDATA:	DD
::	FUNCTION:	DISPLAY DELAY MEASUREMENT STATISITCS
::
::*********************************************************************

DLDATA	HS	0
	SIS	R2,4			:1 ARG?
	JGEFS	DLDAT5			:YES
	LIS	R6,0			:DEFAULT ARG = 0.
	JFS	DLDAT6
DLDAT5	LR	R6,R3			:SAVE ARGUMENT
	JL	COMERR
	CLHI	R6,TINTCH/2		:CHECK SIZE
	JGE	COMERR			:TOO LARGE
DLDAT6	LR	R7,R6			:SAVE INDEX
	LHI	R6,DLYBSZ		:SIZE OF DLY DATA AREA
	MHR	R6,R7			:TIMES INDEX = OFFSET INTO TABLE AREA
	AI	R6,DLYBSE		:ADDRESS OF DATA BLOCK
	LA	R2,DLDMS0,,		:HEADER 0
	JAL	R7,TYPASC
	LA	R2,DLDMS1,,		:HEADER 1
	JAL	R7,TYPASC
	LH	R1,DLYINT,,		:GET TIME INERVAL
	LHL	R10,DLYFIL,R6		:GET FILL
	JEFS	DLDAT4			:SKIP IF ZERO
	AIS	R10,1			:IF NON-ZERO, ADD IN CLOCK
DLDAT4	AIS	R10,1
	SLLS	R10,5			:MULT BY 32
	LIS	R0,0
	STH	R0,XDLTMP
	AIS	R1,8
	SBT	R1,XDLTMP
	LHL	R3,XDLTMP
	SLLS	R3,6
	JAL	R9,TYPHWD
	LR	R2,R10
	DH	R2,XDLTMP
	JAL	R9,TYPHWD

	LIS	R5,0			:TYPE 4 HW
DLDLP3	LHL	R3,DLSTAT,R6,R5		:STAT, FLAG,HWF,PTR
	JAL	R9,TYPHW
	AIS	R5,2
	THI	R5,7			:DONE?
	JNBS	DLDLP3			:NO
	LHL	R2,DLYAV1,R6		:GET FIRST AVERAGE
	JAL	R9,FSTMSC		:CONVERT TO MS (IN R3)
	JAL	R9,TYPHWD		:DISPLAY IN DECIMAL
	LHL	R2,DLYAV2,R6		:SAME FOR SECOND AVERAGE
	JAL	R9,FSTMSC
	JAL	R9,TYPHWD
	JAL	R7,TYPCRL		:CR-LF
	LA	R2,DLDMS2,,
	JAL	R7,TYPASC		:SECOND HEADER
	LHL	R5,NODCNT,R6		:NUMBER OF NODES
	LR	R10,R6
DLDAT3	LHL	R3,NODLST,R10		:NEXT NODE
	AIS	R10,2
	SIS	R5,2			:DECREMENT
	JLFS	DLDAT2			:ALL DONE
	JAL	R9,HEXOCT		:CONVERT TO OCT
        JAL	R9,TYP5CH		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
	JBS	DLDAT3
DLDAT2	LA	R2,DLDMS3,,		:THIRD HEADER
	JAL	R7,TYPASC
:	CONVERT TO MS AND TYP DECIMAL 32 SAMPLES, 8 AT A TIME
	LIS	R11,0			:TO COUNT NO. HW'S TYPED
	JFS	DLDLP2
DLDLP1	JAL	R7,TYPCRL
DLDLP2	LHL	R2,DLYTBL,R6,R11	:GET A SAMPLE VALUE (FASTC)
	JAL	R9,FSTMSC		:CONVERT TO MS (R3)
	JAL	R9,TYPHWD		:DISPLAY
	AIS	R11,2			:POINT TO NEXT HW
	THI	R11,3F			:DONE 64 BYTES (32 HW)?
	JEFS	DLDDON			:ALL DONE
	THI	R11,0F			:DONE 16 BYTES (8 HW) = 1 LINE?
	JE	DLDLP1			:YES, DO NEXT LINE
	J	DLDLP2			:NO, DO NEXT HW
DLDDON	JAL	R7,TYPCRL
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	DLYEND:	DE
::	FUNCTION:	TERMINATE DELAY MEASUREMENT OPERATION ON A CHANNEL
::
::*********************************************************************

:	THE CRQ IS ZAPPED IN THE DIRECTION THAT THE NEEDLE ORIGINALLY TOOK

DLYEND	HS	0
	LHL	R2,ARGCT,XD		:IF NO ARG'S, INDEX = 0.
	JGFS	DLYENA			:AT LEAST 1 ARG.
	C	XD,DB0USE,,		:DID THIS USER SET IT UP?
	JN	COMERR			:NO, CAN'T END IT.
	LIS	R6,0			:DEFAULT INDEX = 0
	JFS	DLYENB
DLYENA	LHL	R6,VALUE1+2,XD
	LH	R4,XPOWER,XD		:				###TZ
	JG	XPWER1			:SECURITY VIOLATION		###TZ
DLYEN2	CLHI	R6,TINTCH/2
	JGE	COMERR			:TOO BIG
DLYENB	HS	0
:	CREATOR OF DLY MSMT CIRCUIT IS THE OWNER			###JHL
	AR	R6,R6			:BYTE INDEX TO HW INDEX
	C	XD,DB0USE,R6,R6		:INDX TO FW TBL--WHO OWNS THIS CHAN
	JN	COMERR			:ONLY THE CREATOR CAN ZAP IT
	SRLS	R6,1			:BACK TO BYTE INDEX

	LR	R5,R6			:SET UP TO GET DELAY CIRCUIT STATUS
	LHI	R6,DLYBSZ		:SIZE OF DELAY DATA AREA
	MHR	R6,R5			:R6=OFFSET INTO TABLE AREA
	AI	R6,DLYBSE		:R6=POINTS TO DATA AREA FOR THIS INDEX
	LH	R4,DLSTAT,R6		:CIRCUIT UP (STAT = 1)?
	JLE	COMERR			:NO
	LH	R5,DLYCHN,R5,R5		:INT HST CHANNEL INDEX
	TBT	R5,INTDRF		:MAKE SURE THIS CHN IS BEING USED
	JNFS	DLYEN9			:OK
	TBT	R5,INTLPF		:NOT DELAY MEASRMENT, PERHAPS LOOPBACK
	JE	COMERR			:NO, NOTHING THERE
DLYEN9	LR	R4,R5			:PUT INT HST CHAN INDEX IN R4
	AHI	R5,INTZFL		:ABSOLUTE CH # IN R5
	LHL	R2,IOTAB,R5,R5		:AND THE OUTGOING BUFFER IN R2
	JE	COMERR			:NOTHING THERE, ALREADY BEEN ZAPPED
	NHI	R2,-4			:STRIP SIGN BITS--SWITCH TO INCOMING
	XHI	R2,4			:BUFFER (INTZAP WILL SWITCH BACK)
	JAL	R10,INTZAP,,		:ZAP THE INT HOST CRQ
DLYEN1	LCS	R0,2
	STH	R0,DLSTAT,R6		:NOTE WE'VE DONE THE ZAP
	J	XPRMPT

	EI	:2-XRYTMC ###wjl	
	EI	:(XRSZLV-1)		:##AL

	SUBTTL	XRAY (Echo mode - RE, LE)

	IF	(XRSZLV-2)		:##AL

::*********************************************************************
::
::	COMMAND:	XRECHO:	RE
::	FUNCTION:	SET DEFERRED OR REMOTE ECHO MODE (XRAY ECHOS)
::
::*********************************************************************

XRECHO	HS	0
	LIS	R0,0
	STH	R0,EKOTYP,XD
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	XLECHO:	LE
::	FUNCTION:	SET LOCAL ECHO MODE ( USER IS DOING ECHOING)
::
::*********************************************************************

XLECHO	HS	0
	TS	EKOTYP,XD
	J	XPRMPT

	SUBTTL	XRAY (Set, remove and display traps - ST, RT, DT)

	IF	ISIS			:ISIS HAS SIMPLE TRAP CAPABILITY


        IF      SDW.TR          :swedels isis traps

::   ISIS traps rewritten to have SOLO style traps with an added
::    capability of definable (NTRAP) number of setable traps.
:: NOTE:  ISIS traps require 3 halfwords to be overwritten at the
::        patch location as compared to the solo's 2 halfwords and the
::        current condition codes are trashed. (ie don't trap a JE or JN
::        instruction and make sure that no one jumps to any of the three
::        halfwords after the trap). Also, neither SOLO or ISIS check to
::        make sure a valid instruction is being trapped.  ###sdw
::        Also, ISIS traps must remove write protection because they
::        cannot know whether the trapped routine had write protection.
::        (write protection has to be removed in order to restore the
::        instruction).   ###sdw

::*********************************************************************
::
::	COMMAND:	SETTRP:	ST (ISIS)
::	FUNCTION:	SETS A TRAP AT A PARTICULAR LOCATION
::
::*********************************************************************

SETTRP	HS	0
        CLHI    R2,0C                   :MAX OF 3 ARGS
	JG	COMERR			:TOO BIG
        CLHI    R2,8                    :test for 2 args
	JL	COMERR			:must give trap number
        JGFS    SETTR1                  :if only 2 then give count of 0
        LIS     R1,0                    :repeat count will be 0
        ST      R1,VALUE1+8,XD          :by acting as if 0 was typed
SETTR1  L       R1,VALUE1,XD            :get address to trap
        TI      R1,10000                :only trap seg 1?
        JE      COMERR                  :could trap some of seg D?
        LHI     R3,4*(NTRAP-1)          :word index to trap addresses
SETTR2  C       R1,TRPADR,R3,           :address already trapped?
        JE      COMERR
        SIS     R3,4                    :check all traps
        JGEBS   SETTR2
        L       R2,VALUE1+4,XD          :trap number
        CLHI    R2,NTRAP                :less than the maximum number of traps
        JGE     COMERR                  :(NTRAP=2 then traps numbers are 0 1)
        SLLS    R2,2                    :trap number as a FW index
        L       R3,TRPSAV,R2,R2         :where we save the overwritten ininstr
        JN      COMERR                  :instruction already there so error
        L       R0,0,R1                 :get instr to trap on
        ST      R1,TRPADR,R2,           :save location of trap
        ST      R0,TRPSAV,R2,R2         :TRPSAV is 2 words
        LHL     R0,4,R1                 :get the 3rd halfword
        STH     R0,TRPSAV+4,R2,R2       :save the instruction
        LHI     R0,4300                 :the J instruction
        STH     R0,0,R1
        L       R0,TRPINX,R2            :where the jump should jump
        AI      R0,40000000             :the RX3 bit
        ST      R0,2,R1                 :put where the jump (trap) handler is
        L       R0,VALUE1+8,XD          :what was the count?
        NHI     R0,7FFF                 :max trap count
        SRLS    R2,1                    :R2 is back to HW index
        STH     R0,TRPCNT,R2,
        ST      XD,TRPXD,R2,R2          :store the xray user for this trap
        J       XRCRLF                  :done with this

::*********************************************************************
::
::	COMMAND:	REMTRP:	RT (ISIS)
::	FUNCTION:	REMOVES THE TRAP
::
::*********************************************************************

REMTRP	HS	0
        CLHI    R2,4                    :must have at least one arg
        JL      COMERR
        SIS     R2,4                    :index into values
REMTR1  L       R1,VALUE1,XD,R2         :trap number to remove
        JL      COMERR
        CLHI    R1,NTRAP                :make sure a valid trap number
        JGE     COMERR
        JAL     R4,REMTR3               :subroutine which removes traps
        SIS     R2,4                    :next value
        JGE     REMTR1
        J       XRCRLF                  :done with the XRAY RT command

:  REMTR0 is entry from xray zap logic (on R9) to clear all traps for this
:  zapped user.

REMTR0  LHI     R1,NTRAP-1              :remove all traps
REMTR9  JAL     R4,REMTR3               :try to remove this trap
        SIS     R1,1
        JGEBS   REMTR9
        JR      R9

: REMTR3 removes the trap in R1 if the trap belongs to the user (XD).
:routine also must not destroy R2 or R9 and links on R4.

REMTR3  LR      R5,R1
        SLLS    R5,2                    :make R5 a fullword index
        C       XD,TRPXD,R5,            :trap belong to this user?
        JNR     R4                      :cannot remove someone elses trap
        L       R3,TRPADR,R5,,          :address of trap
        JLER    R4                      :this trap was not in use
        L       R0,TRPSAV,R5,R5         :restore the instruction
        ST      R0,0,R3
        LHL     R0,TRPSAV+4,R5,R5       :last halfword of instruciton
        STH     R0,4,R3
        LIS     R0,0                    :clean out the trap
        ST      R0,TRPADR,R5,           :no address of a trap
        ST      R0,TRPSAV,R5,R5         :no instruction is saved
                                        :leave other info in case of bug
        JR      R4                      :trap removed


::*********************************************************************
::
::	ROUTINE:	TRAPIS:	(ISIS)
::	FUNCTION:	WHERE THE TRAP IS SPRUNG
::
::*********************************************************************

Q       EQ      0
        RE      NTRAP
TRPI|Q| STM     R0,TRPREG+40*Q,,
        LHI     R0,Q
        J       TRAPIS
Q       EQ      Q+1
        ER

TRPINX  WS      0       :table for each trap number
Q       EQ      0
        RE      NTRAP
        WC      TRPI|Q|
Q       EQ      Q+1
        ER

TRAPIS	HS	0
        SBT     R0,TRPFLG,,
        LR      R12,R0          :let R12 keep track of trap number
        LR      R13,R12         :R13 is going to be 4*trap
        SLLS    R13,2
        L       R0,FASTC,,
        ST      R0,TRPTIM,R13,  :save time of trap spring
        LHI     R0,1F-PXRAY     :sched xray to display trap
        SBT     R0,SQUEUE
        L       R1,TRPXD,R13,   :and schedule the xray owner of trap
        LHL     R1,XUSLTN,R1    :the xray user number
        SBT     R1,XQUEM,,      :sched the user that gets trap info
        JAL     R11,XWRITE      :remove write protection
        L       R1,TRPADR,R13,  :get the address of the trap
        L       R0,TRPSAV,R13,R13 :get 1st 4 bytes of instruction
        ST      R0,0,R1         :restore it
        LHL     R0,TRPSAV+4,R13,R13 :get last two bytes of instruction
        STH     R0,4,R1         :restore it
        ST      R1,TRPPSW+4,,   :save where we are to return to
        SLLS    R13,4           :get displacement into saved regs
        LM      R0,TRPREG,R13,  :restore regs
        UPSW    TRPPSW,,        :return to the instruction

::*********************************************************************
::
::	ROUTINE:	TRPDOR:	(ISIS)
::	FUNCTION:	DISPLAYS THE TRAP
::
::*********************************************************************

TRPDOR  HS      0
        JFFOH   R4,TRPDO1               :R4 is TRPFLG which is which trap
        J       COMERR                  :can never get here but just in case
TRPDO1
        SLLS    R5,1                    :is HW index for trap
        C       XD,TRPXD,R5,R5          :check if trap belongs to this user
        JN      XLOOP0                  :nope but handle this screwup too
	LA	R2,ASCTRP,,             :the TRAP message
	JAL	R7,TYPASC		:HEADER
        LR      R3,R5                   :get 2*trap number
        SRLS    R3,1                    :make it trap number
        RBT     R3,TRPFLG,,             :no longer dis trap have output pending
        JAL     R9,TYPHW                :output trap number
        L       R3,TRPADR,R5,R5         :output trap address
        JAL     R9,TYPFW
        L       R3,TRPTIM,R5,R5         :output time it sprung
        JAL     R9,TYPFW
        LHL     R3,TRPCNT,R5,           :count of springs left
        JAL     R9,TYPHW                :tell them how many left
        LR      R6,R5                   
        SLLS    R6,5                    :make 40 byte index
        LIS     R11,2                   :two lines of 8 FWs
TRPDO4  LIS     R10,8                   :the 8 FWs
        JAL     R7,TYPCRL
TRPDO5  L       R3,TRPREG,R6,           :get a FW
        JAL     R9,TYPFW
        AIS     R6,4                    :move up the pointer
        SIS     R10,1
        JGBS    TRPDO5                  :still within line
        SIS     R11,1                   :how many lines
        JG      TRPDO4
        LHL     R0,TRPCNT,R5,           :how many times to reset trap
        JG      TRPDO6                  :go if must reset trap
        LIS     R0,0
        ST      R0,TRPADR,R5,R5         :no more trap address
        SLLS    R5,1
        ST      R0,TRPSAV,R5,R5         :no more saved instruction
        J       XRCRLF                  :finished with trap

TRPDO6  SIS     R0,1
        STH     R0,TRPCNT,R5,           :reduce count by one
        L       R1,TRPADR,R5,R5         :get address of instruction
        LHI     R2,4300                 :get back trap
        STH     R2,0,R1                 :restore instruction
        L       R2,TRPINX,R5,R5         :last 2 bytes of instr
        AI      R2,40000000
        ST      R2,2,R1
	JAL	R7,TYPCRL
        J       XRCRLF

::*********************************************************************
::
::	COMMAND:	DISTRP:	DT (ISIS)
::	FUNCTION:	DISPLAY CURRENT TRAP LOCATION
::
::*********************************************************************

DISTRP	HS	0
        LHI     R12,2*(NTRAP-1)         :all traps
DISTR1  L       R11,TRPADR,R12,R12      :address of trap
        JE      DISTR2                  :not in use so skip
        LR      R3,R12                  :get trap number
        SRLS    R3,1                    :make back to real number
        JAL     R9,TYPHW
        LR      R3,R11                  :get back trap address
        JAL     R9,TYPFW
        LHL     R3,TRPCNT,R12,          :number of times it will be reset
        JAL     R9,TYPHW
        JAL     R7,TYPCRL               :finish the line
DISTR2  SIS     R12,2                   :decrement the count
        JGE     DISTR1
        J       XRCRLF

        ELSE            :SDW.TR  or stupid old single isis trap

::*********************************************************************
::
::	COMMAND:	SETTRP:	ST (ISIS)
::	FUNCTION:	SETS A TRAP AT A PARTICULAR LOCATION
::
::*********************************************************************

SETTRP	HS	0
	SIS	R2,4			:CHECK FOR 1 ARG
	JN	COMERR			:TOO BIG
	L	R0,TRPSAV,,		:MAKE SURE THERE ISN'T A TRAP ALREADY
	JN	COMERR			:SOMETHING THERE, ABORT
	TI	R3,10000		:CHECK FOR VALID ADDRESS
	JE	COMERR			:NOT SEGD ADDRESS
	L	R0,0,R3			:SAVE CONTENTS
	ST	R0,TRPSAV,,
	LHL	R0,4,R3
	STH	R0,TRPSAV+4,,
	LHI	R0,4300			:FORM RX3 INSTRUCTION
	STH	R0,0,R3			:AND WRITE INTO DESIRED PLACE
	LI	R0,40000000+TRAPIS
	ST	R0,2,R3
	ST	R3,TRPADR,,		:SAVE TRAP ADDRESS
	ST	XD,TRPXD,,		:WHO OWNS THE TRAP
	J	XPRMPT			:AND RETURN

::*********************************************************************
::
::	COMMAND:	REMTRP:	RT (ISIS)
::	FUNCTION:	REMOVES THE TRAP
::
::*********************************************************************

REMTRP	HS	0
	LA	R9,XPRMPT		:ENTRY POINT FOR EXPLICIT COMMAND
	C	XD,TRPXD,,		:IS THIS THE OWNER?
	JN	COMERR			:NO
	L	R0,TRPSAV,,		:RESTORE INSTRUCTION
	JE	COMERR			:NO TRAP THERE
:	ENTRY POINT FOR JAL FROM REMZAP
REMTR0	HS	0
	L	R3,TRPADR,,		:GET TRAP ADDRESS
	ST	R0,0,R3
	LHL	R0,TRPSAV+4,,
	STH	R0,4,R3
	LIS	R3,0
	ST	R3,TRPSAV,,		:CLEAR TPSAV TO INDICATE EMPTY
	JR	R9

::*********************************************************************
::
::	ROUTINE:	TRAPIS:	(ISIS)
::	FUNCTION:	WHERE THE TRAP IS SPRUNG
::
::*********************************************************************

TRAPIS	HS	0
	STM	R0,TRPREG,,		:SAVE OFF ALL THE REGGIES
	JAL	R11,XWRITE		:GET WRITE ACCESS
	LHI	R0,01F-PXRAY
	SBT	R0,SQUEUE		:SCHEDULE XRAY
	STH	R0,TRPFLG,,		:AND NOTE TRAP IS SPRUNG
	L	R3,TRPXD,,		:WHO SHOULD BE NOTIFIED
	LHL	R3,XUSLTN,R3		:HIS XRAY SLOT #
	SBT	R3,XQUEM,,		:SCHEDULE HIM
	L	R3,TRPADR,,		:GET TRAP ADDRES
	L	R0,TRPSAV,,		:RESTORE INSTRUCTION
	ST	R0,0,R3			:FIRST 2 HW
	LHL	R0,TRPSAV+4,,
	STH	R0,4,R3			:THIRD HW
	LIS	R3,0
	ST	R3,TRPSAV,,		:CLEAR TPADR TO INDICATE EMPTY
	JAL	R11,XPRTKT		:RESTORE WRITE PROTECT
	LM	R0,TRPREG,,		:RECOVER ALL REGISTERS
	UPSW	TRPPSW,,		:AND RESUME EXECUTION
::*********************************************************************
::
::	ROUTINE:	TRPDOR:	(ISIS)
::	FUNCTION:	DISPLAYS THE TRAP
::
::*********************************************************************

TRPDOR	HS	0
	C	XD,TRPXD,,		:THIS GUY'S TRAP?
	JN	XLOOP0			:NO, GO BACK
	LA	R2,ASCTRP,,
	JAL	R7,TYPASC		:HEADER
	JAL	R7,TYPCRL
	LA	R10,TRPREG,,		:STARTING ADDRESS
	LIS	R11,4			:COUNT
TRPDO1	JAL	R8,TYP8HW		:DISPLAY
	SIS	R11,1
	JGBS	TRPDO1			:ALL 16 REGISTERS
	LIS	R0,0
	STH	R0,TRPFLG,,		:CLEAR TRAP FLAG
	J	XRCRLF

::*********************************************************************
::
::	COMMAND:	DISTRP:	DT (ISIS)
::	FUNCTION:	DISPLAY CURRENT TRAP LOCATION
::
::*********************************************************************

DISTRP	HS	0
	JAL	R7,TYPCRL
	L	R3,TRPSAV,,		:CHECK IF TRAP THERE
	JE	XPRMPT
	C	XD,TRPXD,,		:DOES IT BELONG TO THIS USER?
	JN	XPRMPT			:NO
	L	R3,TRPADR,,		:GET LOCATION
	JAL	R9,TYPFW		:TYPE OUT
	J	XPRMPT			:AND BACK TO COMMAND LOOP

         EI     :SDW.TR end of stupid isis traps
	ELSE	:NOT ISIS

:	SOLO TRAPS ARE MUCH MORE SOPHISTICATED

::*********************************************************************
::
::	COMMAND:	SETTRP:	ST (SOLO)
::	FUNCTION:	SETS A TRAP AT A PARTICULAR LOCATION
::
::*********************************************************************

SETTRP	HS	0
	CLHI	R2,0C			:TEST FOR 3 ARG'S
	JG	COMERR			:TOO MANY ARG'S
	CLHI	R2,8			:TEST FOR 2 ARG'S
	JL	COMERR			:NOT ENOUGH ARG'S
	JGFS	SETTR1			:MUST BE 3 ARG'S, REPEAT COUNT INCLUDED
	LIS	R1,0			:DEFAULT REPEAT COUNT IS 0
	ST	R1,VALUE1+8,XD		:STORE IT AWAY FOR LATER
SETTR1	L	R1,VALUE1,XD		:TRAP ADDRESS
	JE	COMERR			:WE DON'T TAKE ZERO ADDRESS
	TI	R1,SEG1			:IN SEG1?
	JE	COMERR			:NO,ERROR
	L	R3,0,R1			:GET THE COMMAND FROM MEMORY
	C	R3,TRPCMD,,		:IS IT THE TRAP SVC CALL?
	JE	COMERR			:YES, THIS LOCATION ALREADY TRAPPED
	L	R2,VALUE1+4,XD		:TRAP NUMBER
	NHI	R2,3			:REDUCE MOD 4
	SLLS	R2,2			:FW INDEX
	LR	R4,R1			:SAVE R1
	LA	R1,TRPADR,R2
	SVC	0F,SV.RAB
	LR	R1,R1
	JG	COMERR			:TRAP ALREADY IN USE, MUST REMOVE IT
	LA	R11,TRPSAV,R2
	SVC	0F,SV.WFA
	LA	R11,TRPADR,R2
	LR	R3,R4
	SVC	0F,SV.WFA
	LA	R11,TRPXD,R2
	LR	R3,XD
	SVC	0F,SV.WFA
	LA	R11,TRPCNT,R2
	L	R3,VALUE1+8,XD		:GET REPEAT COUNT
	NHI	R3,0FFF			:MAX
	SVC	0F,SV.WFA
	L	R3,TRPCMD,,		:SVC 0F,11
	ST	R3,0,R4
	J	XRCRLF

::*********************************************************************
::
::	COMMAND:	REMTRP:	RT (SOLO)
::	FUNCTION:	REMOVES THE SPECIFIED TRAP
::
::*********************************************************************

REMTRP	HS	0			:FOR CALLS FROM XRAY
	LA	R9,XPRMPT
REMTR0	HS	0			:ENTRY FOR JAL FROM REMZAP
	CLHI	R2,4			:MUST HAVE AT LEAST ONE ARGUMENT
	JL	COMERR
	SIS	R2,4			:USE R2 TO INDEX INTO VALUES ENTERED
REMTR1	L	R1,VALUE1,XD,R2		:TRAP TO REMOVE
	NHI	R1,3			:REDUCE TO NUMBER 0-3
	SLLS	R1,2			:WORD INDEX
	LR	R4,R1
	LA	R1,TRPXD,R1
	SVC	0F,SV.RAB
	ST	R1,TRABSV,,
	LR	R1,R4
	C	XD,TRABSV,,		:Does this user own this trap?	###wjl
	JN	REMTR2			:No				###wjl
	LR	R4,R1			:				###wjl
	LA	R1,TRPADR,R1
	SVC	0F,SV.RAB
	ST	R1,TRABSV,,
	LR	R1,R4
	L	R3,TRABSV,,
	JLE	REMTR2			:TRAP ISN'T SET
	LR	R4,R1
	LA	R1,TRPSAV,R1
	SVC	0F,SV.RAB
	LR	R5,R1
	LR	R1,R4
	ST	R5,0,R3			:RESTORE
	LCS	R3,1
	LA	R11,TRPADR,R1
	SVC	0F,SV.WFA
	LIS	R3,0
	LA	R11,TRPCNT,R1
	SVC	0F,SV.WFA
	JFS	REMTR2
REMTR2	SIS	R2,4			:ANY MORE?
	JGE	REMTR1			:YES
	JR	R9			:TO XPRMPT OR CALLER

::*********************************************************************
::
::	COMMAND:	DISTRP:	DT (SOLO)
::	FUNCTION:	DISPLAY ALL CURRENTLY ENABLED TRAPS
::
::*********************************************************************

DISTRP	HS	0
	LIS	R12,0C
DISTR2	HS	0
	LA	R1,TRPADR,R12
	SVC	0F,SV.RAB
	LR	R11,R1
	JLE	DISTR1			:NEGATIVE OR ZERO
	LR	R3,R12
	SRLS	R3,2			:TRAP NUMBER
	JAL	R9,TYPHW		
	LR	R3,R11
	JAL	R9,TYPFW		:TYPE ADDRESS
	LA	R1,TRPCNT,R12
	SVC	0F,SV.RAB
	LR	R3,R1
	JAL	R9,TYPHW		:TYPE IT
	JAL	R7,TYPCRL
	JFS	DISTR1
DISTR1	SIS	R12,4
	JL	XPRMPT
	J	DISTR2

::*********************************************************************
::
::	ROUTINE:	TRPDOR:	(SOLO)
::	FUNCTION:	DISPLAYS TRAP OUTPUT
::
::*********************************************************************

TRPDOR	HS	0
	JFFOH	R4,TRPDO1
	J	COMERR
TRPDO1	HS	0
	SLLS	R5,2			:FW INDEX
	LA	R1,TRPXD,R5
	SVC	0F,SV.RAB
	CR	R1,XD
	JN	XLOOP0			:RETURN TO EXEC LOOP
	SRLS	R5,2			:RESTORE INDEX
	LA	R1,TRPFLG
	SVC	0F,SV.RAB
	ST	R1,TRABSV,,
	RBT	R5,TRABSV,,
	LHL	R3,TRABSV,,
	LA	R11,TRPFLG
	SVC	0F,SV.WHA
	LA	R2,ASCTRP,,		:PRINT TRAP MESSAGE
	JAL	R7,TYPASC
	LR	R3,R5
	JAL	R9,TYPHW		:TYPE TRAP NUMBER
	SLLS	R5,3			:2 FW INDEX
	LA	R1,TRPPSW+4,R5
	SVC	0F,SV.RAB
	LR	R3,R1
	JAL	R9,TYPFW
	LA	R1,TRPPSW,R5
	SVC	0F,SV.RAB
	LR	R3,R1
	JAL	R9,TYPFW
	SRLS	R5,2			:HW INDEX
	LA	R1,TRPSEQ-2,R5
	SVC	0F,SV.RAB
	NI	R1,0FFFF
	LR	R3,R1
	JAL	R9,TYPHW		:DISPLAY TIME
	SLLS	R5,1			:FW INDEX
	LA	R1,TRPCNT,R5
	SVC	0F,SV.RAB
	LR	R3,R1
	JAL	R9,TYPHW		:DISPLAY REPEAT COUNT
	LA	R1,TRPTIM,R5
	SVC	0F,SV.RAB
	LR	R3,R1
	JAL	R9,TYPFW		:TYPE FASTC TIME TRAP SPRUNG
	JAL	R7,TYPCRL		:SEND CR-LF TO USER

	ST	R5,XRSAVE,XD		:SAVE TRAP NO. AS FW INDEX
	SLLS	R5,4			:TRPREG INDEX

	LHI	R11,10			:10x FW'S OF DATA TO DISPLAY	###TZ
TRPDO4	HS	0
	LIS	R10,8			:8 FW'S PER LINE		###jhl
TRPDO5	HS	0
	LA	R1,TRPREG,R5
	SVC	0F,SV.RAB
	LR	R3,R1
	JAL	R9,TYPFW
	AIS	R5,4
	SIS	R11,1
	JLEFS	TRPDO6
	SIS	R10,1
	JG	TRPDO5
	JAL	R7,TYPCRL
	J	TRPDO4
TRPDO6	HS	0
	JAL	R7,TYPCRL

	L	R5,XRSAVE,XD		:GET TRAP NO. AS FW INDEX
	LA	R1,TRPCNT,R5
	SVC	0F,SV.RAB
	LR	R1,R1
	JNFS	TRPDO2			:NOT 0, DON'T REMOVE TRAP
	LCS	R3,1
	LA	R11,TRPADR,R5		:NOTE TRAP IS SPRUNG
	SVC	0F,SV.WFA
	J	XRCRLF			:ALL DONE HERE, TRAP NOT SET
TRPDO2	HS	0
	SIS	R1,1
	LR	R3,R1
	LA	R11,TRPCNT,R5
	SVC	0F,SV.WFA
	LA	R1,TRPADR,R5
	SVC	0F,SV.RAB

 	L	R7,TRPCMD,,
	ST	R7,0,R1
	J	XRCRLF

	EI	:(not) ISIS

	SUBTTL	XRAY (Debugging aids - SC, SB, RC)

::*********************************************************************
::
::	COMMAND:	SETCRS:	SC
::	FUNCTION:	SETS A J OOPS AT GIVEN LOCATION
::
::*********************************************************************

SETCRS	HS	0
	CLHI	R2,4			:EXACTLY 1 ARG
	JN	COMERR			:NO
	L	R1,XCRADD,,		:MAKE SURE WE MAY
	JG	COMERR			:NO, A CRASH  OR BP IS THERE ALREADY
	L	R1,0,R3			:R3 is the address of the crash to be
	ST	R1,XCRSAV,,		:save the d10 bytes for restoration
	LHL	R1,4,R3
	STH	R1,XCRSAV+4,,
	L	R1,6,R3
	ST	R1,XCRSAV+6,,
	ST	R3,XCRADD,,
	LHI	R1,4100			:store JAL OOPS, .XRSCH and 0408
	STH	R1,0,R3
	LI	R1,40000000+OOPS
	ST	R1,2,R3
	LI	R1,.XSCRH^10+0408	:crash code and R1, R2		###JHL
	ST	R1,6,R3
	J	XPRMPT			:AND RETURN

::*********************************************************************
::
::	COMMAND:	SETBP:	SB
::	FUNCTION:	SET A BREAKPOINT (ILL INST) AT GIVEN LOCATION
::
::*********************************************************************

SETBP	HS	0
	CLHI	R2,4			:EXACTLY ONE ARG?
	JN	COMERR			:NO
	L	R1,XCRADD,,		:MAKE SURE WE MAY
	JG	COMERR			:NO, A CRASH  OR BP IS THERE ALREADY
	L	R1,0,R3			:SAVE CONTENTS
	ST	R1,XCRSAV,,
	ST	R3,XCRADD,,		:SAVE CRASH ADDRESS
	LIS	R1,0			:ILL INST
	ST	R1,0,R3
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	REMCRS:	RC
::	FUNCTION:	REMOVES THE CRASH OR BREAKPOINT
::
::*********************************************************************

REMCRS	HS	0
	L	R1,XCRADD,,		:ADDRESS
	JLE	COMERR			:NO CRASH SET
	L	R0,XCRSAV,,		:COMMAND
	ST	R0,0,R1			:RESTORE IT
	LHL	R0,XCRSAV+4,,
	STH	R0,4,R1
	L	R0,XCRSAV+6,,
	ST	R0,6,R1
	LCS	R0,1
	ST	R0,XCRADD,,		:NOTE THERE IS NO CRASH SET
	J	XPRMPT			:AND RETURN

	SUBTTL	XRAY (Miscellaneous - XG,GP,BT,NR,RB,WB,BZ,BG,NI)

	IF	EXPSEC

::*********************************************************************
::
::	COMMAND:	XGGMOD:	XG
::	FUNCTION:	DISPLAY, MODIFY, ADD OR DELETE XRAY GOODGUY ENTRIES
::	INPUT:		GG =DISPLAY,  GG A =ADD, GG # M =MODIFY, GG # D =DELETE
::
::*********************************************************************

	NOLIST
XGGDS1	SC	/"0D"0AXRAY GOODGUY LIST"0D"0A/
XGGDS2	SC	/"0D"0ANO.   PRIV  OVER  NAME/
XGGDS3	SC	/"0D"0A----  ----  ----  ----"0D"0A/
XGGDS4	SC	/"0D"0A"0AENTER NEW PRIVILEGE AND OVERRIDE - /
XGGDS5	SC	/"0D"0AENTER UP TO 12(D) CHARS OF USERNAME"0D"0A/
XGGDS6	SC	/"0D"0AXRAY GOODGUY LIST ALLREADY FULL"0D"0A/
	LIST

XGGMOD	HS	0
	LR	R2,R2			:ZERO ARGS?
	JE	XGGM01			:YES
	SIS	R2,4			:ONE ARG?
	JG	COMERR			:NO, TOO MANY
	LH	R13,XPOWER,XD		:IS USER EMPOWERED?
	JGE	XPWER1			:NO, TELL HER SO
	LR	R3,R3			:ENTRY NUMBER = 0?
	JE	COMERR			:YES, NOT VALID
	CLHI	R3,(XGGLEN-(XGGDLD-XRAYGG))/XGGSIZ :WITHIN GGLIST TABLE RANGE?
	JG	COMERR			:NO 
	LHI	R0,XGGSIZ		:GET GGLIST CELL SIZE
	SIS	R3,1			:MAKE ENTRIES BEGIN AT 1
	MR	R2,R0			:FORM GGLIST INDEX (R2 HAS 0 ALREADY)
	CLHI	R1,ASCP			:USER CLOSE WITH "P" (x50)
	JE	XGGDEL			:YES, DELETE ENTRY
	CLHI	R1,ASCM			:USER CLOSE WITH "M" (x4D)
	JE	XGGMDD			:YES, MODIFY ENTRY
	J	COMERR			:NOT CLOSED WITH D OR M
XGGM01	CLHI	R1,ASCI			:USER CLOSE WITH "I" (x49)
	JE	XGGADD			:YES, ADD ENTRY

XGGDSP	LA	R2,XGGDS1		:TYPE OUT DISPLAY HEADER
	JAL	R7,TYPASC
	LA	R2,XGGDS2
	JAL	R7,TYPASC
	LA	R2,XGGDS3
	JAL	R7,TYPASC
	LIS	R11,0			:INIT GGLIST INDEX
XGGDP1	LB	R3,XGGDLD+XGGNAM,R11,	:CHECK FOR ANY ENTRY HERE
	JE	XGGDP2			:NO ENTRY, TRY NEXT GGLIST INDEX

	LIS	R2,0
	LR	R3,R11			:COMPUTE ENTRY NUMBER FROM GGLIST INDEX
	LHI	R0,XGGSIZ		:BY DIVIDING BY GGLIST CELL SIZE
	DR	R2,R0
	AIS	R3,1
	JAL	R9,TYPHW

	LB	R3,XGGDLD+XGGPRV,R11,	:GET USERS PRIVILEGE CAPABILITY
	JAL	R9,TYPHW		:DISPLAY FOLLOWED BY 2 SPACES
	LB	R3,XGGDLD+XGGOVR,R11,	:GET USERS OVERRIDE CAPABLILTY
	JAL	R9,TYPHW		:AND DISPLAY
	LA	R2,XGGDLD+XGGNAM-1,R11,	:DISPLAY USERNAME
	LIS	R0,0C			:12(D) CHARACTERS
	JAL	R7,TYPAS1
	JAL	R7,TYPCRL		:CR/LF AND CHECK NEXT GGLIST ENTRY
XGGDP2	AHI	R11,XGGSIZ		:BUMP GGLIST INDEX
	CLHI	R11,XGGLEN-(XGGDLD-XRAYGG)	:DONE?
	JL	XGGDP1			:NO, DISPLAY SOME MORE ENTRIES
	J	XPRMPT			:YES, EXIT

XGGDEL	LIS	R0,0			:CLEAR OUT
	STB	R0,XGGDLD+XGGPRV,R3,	:BYTE OF PRIVILEGE,
	STB	R0,XGGDLD+XGGOVR,R3,	:BYTE OF OVERRIDE,
	ST	R0,XGGDLD+XGGNAM,R3,	:3 FW OF USERNAME
	ST	R0,XGGDLD+XGGNAM+4,R3,	:IN
	ST	R0,XGGDLD+XGGNAM+8,R3,	:XRAY GOODGUY LIST
	J	XPRMPT			:AND EXIT

XGGMDD	LR	R14,R3			:SAVE GGLIST INDEX
	LA	R2,XGGDS4		:PROMPT FOR PRIV, OVERRIDE
	JAL	R7,TYPASC
	JAL	R9,RDARGS		:GET PRIV, OVERRIDE
	LR	R2,R2			:ANY ARGS?
	JE	COMERR			:NO, ERROR
	CLHI	R2,8			:TWO ARGS?
	JN	COMERR			:NO
	STB	R3,XGGDLD+XGGOVR,R14,	:REPLACE OVERRIDE CAPABILITY
	LH	R3,VALUE1+2,XD		:GET FIRST ARGUMENT (PRIV)
	JGEFS	XGGMD8
	LIS	R3,0			:LOW LIMIT TO 0
XGGMD8	CLHI	R3,0002			:HIGH LIMIT TO 2
	JLEFS	XGGMD7
	LIS	R3,2
XGGMD7	STB	R3,XGGDLD+XGGPRV,R14,	:REPLACE PRIVILEGE CAPABILITY
	J	XPRMPT			:EXIT

XGGADD	LH	R13,XPOWER,XD		:IS USER EMPOWERED?
	JGE	XPWER1			:NO, TELL HER SO
	LIS	R11,0			:INIT XRAY GGLIST INDEX
XGGAD1	LB	R3,XGGDLD+XGGNAM,R11,	:CHECK FOR NULL IN BYTE 1 OF UNAME
	JEFS	XGGAD2			:NULL ENTRY FOUND
	AHI	R11,XGGSIZ		:BUMP GGLIST INDEX
	CLHI	R11,XGGLEN-(XGGDLD-XRAYGG)	:END OF GGLIST
	JLBS	XGGAD1			:NO, KEEP LOOKING FOR EMPTY ENTRY
	LA	R2,XGGDS6		:INFORM HER OF NO GGLIST SPACE
	JAL	R7,TYPASC
	J	XPRMPT			:AND EXIT

XGGAD2	LA	R2,XGGDS5		:PROMPT FOR USERNAME
	JAL	R7,TYPASC
	LIS	R14,0			:COUNT USERNAME CHARACTERS
XGGAD4	JAL	R13,XRYIN		:GET A CHARACTER OF INPUT
	NHI	R1,ASC7BT		:strip high order bit
	CLHI	R1,ASCSPC		:BLANKS PASS WITHOUT CASE CONVERSION
	JEFS	XGGAD9			:BLANK
	NHI	R1,ASCUC		:ENSURE UPPERCASE(x0DF)
	CLHI	R1,ASCCR		:CR (x0D)?
	JEFS	XGGAD3			:YES
XGGAD9	STB	R1,XGGDLD+XGGNAM,R11,R14	:STORE CHAR INTO GGLIST
	AIS	R14,1			:BUMP CHAR COUNT
	CLHI	R14,0C			:UP TO 12(D) YET?
	JL	XGGAD4			:NO, GET NEXT CHARACTER
XGGAD3	LR	R3,R11			:GET GGLIST INDEX FOR XGGMDD
	J	XGGMDD			:AND GET PRIV AND OVERRIDE

	EI	:EXPSEC
	EI	:(XRSZLV-2)		:##AL

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	GETPWR:	GP
::	FUNCTION:	GET POWER
::
::*********************************************************************

GETPWR	HS	0
	LHL	R10,EKOTYP,XD
	LCS	R0,1
	STH	R0,EKOTYP,XD
	JAL	R9,RDARGS
	STH	R10,EKOTYP,XD
	SIS	R2,8			:2 ARGUMENTS
	JN	COMERR
	JAL	R9,DECHEX		:###wjl
	J	COMERR			:###wjl
	CLHI	R3,HST0			:###wjl
	JN	COMERR
	LHL	R0,VALUE1+2,XD
	NHI	R0,1
	JN	GETPW0			:###TZ

	IF	EXPSEC
	CI	XD,TTYXD		:TTY?
	JEFS	GETPW2			:YES, MAKE SUPER PRIVELEGED
	LHL	R9,XUNAME,XD		:GET USER'S INDEX INTO XRAY GGLIST
	LB	R0,XRAYGG+XGGPRV,R9,	:AND GET USER'S PRIVILEGE CAPABILITY
	JE	COMERR			:NOT PRIV, THIS COMMAND NOT ALLOWED
	SIS	R0,1			:IS CAPABILITY 1?
	JEFS	GETPW3			:YES, MAKE NORMAL PRIV

GETPW2	LCS	R0,1			:FLAG SUPER PRIVELEGED
	JFS	GETPW0
GETPW3	LIS	R0,0			:FLAG NORMAL PRIVILEGE
	ELSE	:EXPSEC
	LH	R0,XUNAME,XD		:###TZ
	EI	:EXPSEC

GETPW0	HS	0			:###TZ
	STH	R0,XUINTH+2,XD
	CI	XD,TTYXD		:TTY?
	JN	XPRMPT,,		:NO
	LCS	R0,1			:TEMP KLUDGE. LET TTY PORT HAVE SUPER-P
	STH	R0,XUINTH+2,XD		:###TZ
	IF	JIM
	LHI	R0,$A6000		:give me a break at the TTY port
	ELSE	:NOT JIM
	LHI	R0,$A60			:2 MINUTES MAX
	EI	:JIM
	STH	R0,XPWRCT,,
	J	XPRMPT,,
	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	XBOOT:	BT
::	FUNCTION:	GO TO BOOT
::
::*********************************************************************

	IF	1-ISIS
XBOOT	SVC	0F,SV.BOT		:DO BOOT SVC
	LA	R2,XBTMSG,,		:RETURNED FROM SVC, LOCATION 5A IS BAD
	JAL	R7,TYPASC
	J	XRCRLF,,
	EI	:1-ISIS

::*********************************************************************
::
::	COMMAND:	XNDLRD:	NR
::	FUNCTION:	Read copy of last needle orig in node
::
::*********************************************************************

	IF	NDREAD

	SEG	0
XNDRFG	HS	1			:flags RDBUF to return buffer

	SEG	0D
XNDLRD	HS	0	
	CLHI	R1,ASCN			:if term w/ N then turn on flag for CRQ
	JNFS	XNDL10
	TS	NDRFLG,,
	J	XRCRLF,,
XNDL10	CLHI	R1,ASCZ			:if term w/ Z then turn it off in CRQ
	JNFS	XNDL20
	LIS	R1,0
	STH	R1,NDRFLG,,
	J	XRCRLF,,
XNDL20	CLHI	R1,ASCCR		:otherwise, must end with crlf
	JN	COMERR,,
	TS	XNDRFG,,		:tell RDBUF to return buffer
	L	R2,NDRDSV,,		:get buffer number from memory
	J	XRDBU3
	EI	:NDREAD

::*********************************************************************
::
::	COMMAND:	XRDBUF:	RB
::	FUNCTION:	READS THE CONTENTS OF A BUFFER
::
::*********************************************************************

XRDBUF	HS	0
	LR	R2,R3			:LAST ARG IS BUFFER NUMBER
XRDBU3	NHI	R2,-4			:STRIP SPPEED BITS IN CASE
	JAL	R8,CBCCT,,		:CHAR COUNT
	LR	R1,R1
	JE	XPRMPT,,		:BUFFER EMPTY
	LR	R10,R1			:SAVE COUNT
	LIS	R11,0F			:CHAR COUNT ON LINE
	JAL	R8,PCIS,,		:START THINGS OFF
XRDBU1	LR	R12,R2			:SAVE BUFFER NUMBER
	LR	R14,R3			:AND POINTER
	LR	R3,R1
	JAL	R9,TYPBYT,,
	SIS	R10,1
	JE	XRDBF4			:char count depleted--wrap it up
	SIS	R11,1
	JGEFS	XRDBF2			:zero means end of line--crlf
	JAL	R7,TYPCRL
	LIS	R11,0F
XRDBF2	LR	R2,R12			:restore buffer number
	LR	R3,R14			:restore peek pointer
	JAL	R8,PCI,,
	J	XRDBU1
XRDBF4	IF	NDREAD
	LH	R8,XNDRFG,,		:if buffer was copy of ndl through
	JE	XRCRLF			:node, return to free pool when we've
	LR	R2,R12			:read its contents
	JAL	R8,RFCBUF,,
	LIS	R8,0			:also zero out the memory location to
	ST	R8,NDRDSV,,		:tell CRQ to get new buffer
	STH	R8,XNDRFG,,
	EI	:NDREAD
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XWRBUF:	WB
::	FUNCTION:	Write ASCII into buffer
::	FORMAT:		WB <buff#> <data in hex> (up to seven bytes)
::
::*********************************************************************

XWRBUF	HS	0
	LR	R10,R2			:SAVE ARGUMENT COUNT
	JE	XRCRLF,,		:NO ARGS, BOOGIE
	LHL	R2,VALUE1+2,XD		:BUFFER NUMBER WAS 1ST ARG	###jhl
	JE	COMERR			:BUFFER ZERO, NO-NO!
	CLHI	R2,4	
	JE	COMERR			:SAME GOES FOR BUFFER 4
	LIS	R11,3			:INDEX INTO ARG LIST		###jhl
XWRBU1	SIS	R10,4			:DECREMENT ARG COUNT
	JE	XRCRLF,,		:ALL DONE

	AIS	R11,4			:ADVANCE INDEX
	LB	R1,VALUE1,XD,R11	:GET NEXT BYTE			###jhl
	JAL	R8,WCI,,		:AND WRITE IN
	JBS	XWRBU1			:LOOP BACK TILL DONE
	EI	:(XRSZLV-2)		:##AL

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	XBRZAP:	BZ
::	FUNCTION:	SETS BIT IN BORZAP ARRAY CORRESPONDING TO THE
::			NEIGHBOR NUMBER ARGUMENT
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl

XBRZAP	HS	0
	L	R3,VALUE1,XD		:LOAD NODE NUMBER         ###SHM
	JAL	R9,OCTHXR		:CONVERT TO HEX           ###SHM
	LR	R1,R3			:STORE IN R1 FOR XFNDLK   ###SHM
	JAL	R9,XFNDLK		:FIND LINK NUMBER
	J	COMERR			:NOT THERE
	LHL	KN,XKNSAV,XD		:RECOVER LINK#
	SBT	KN,BORZAP		:SET THE ZAP BIT
	J	XPRMPT,,		:AND RETURN

	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	XBGLST:	BG
::	FUNCTION:	MAKES CHANGES TO, AND DISPLAYS, THE BAD-GUY LIST
::	FORMAT: 	BG <NODE1>...<NODE7> [R OR I]
::			R REMOVES FROM LIST, I INCLUDES INTO LIST
::			IF NO ARGS, JUST DISPLAY BAD GUY LIST
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl

XBGLST	HS	0
	LR	R10,R2			:SAVE ARG COUNT
	JE	XBGSHO			:NO ARGS, JUST DISPLAY
	LH	R3,XPOWER,XD		:IF CHANGING, MUST HAVE POWER	###OAS
	JG	XPWERR			:NOPE, NOT AUTHORIZED		###OAS
	CLHI	R1,ASCR			:WAS LAST ARG A 'R'?
	JE	XBGRMV			:YES, REMOVE FROM LIST
	CLHI	R1,ASCI			:WAS LAST ARG AN 'I'?
	JN	COMERR			:BAD ARGUMENT
XBGLS1  L	R3,VALUE1-4,R10,XD	:GET NODE NUMBER           ###SHM
	TI	R3,88888888		:SEE IF VALID OCTAL	   ###SHM
	JN	XBGLS4			:NON-OCTAL, CHECK NEXT ARG	###OAS
	JAL	R9,OCTHXR		:GO HEX
	LR	R1,R3

	LHI	R5,(BGLSIZ-1)*2
XBGLS2	LH	R0,BGLIST,R5
	JEFS	XBGLS3
	CR	R1,R0			:SEE IF THIS IS DUPLICATE	###OAS
	JEFS	XBGLS4			:DUPLICATE, CHECK NEXT ARG	###OAS
	SIS	R5,2			:THIS ENTRY IN USE		###OAS
	JGBS	XBGLS2			:CHECK NEXT ENTRY		###OAS
	J	XBGSHO			:NO ENTRIES, EXIT		###OAS

XBGLS3	STH	R1,BGLIST,R5		:MAKE ENTRY			###OAS
XBGLS4	SIS	R10,4			:DECREMENT ARGUMENT COUNT	###OAS
	JG	XBGLS1			:LOOK AT NEXT ARG		###OAS
	J	XBGSHO			:NO MORE ARGS, DISPLAY		###OAS

XBGRMV	L	R3,VALUE1-4,R10,XD	:GET NODE NUMBER         ###SHM
	JAL	R9,OCTHXR
	LR	R1,R3

	LIS	R0,0
	LHI	R5,(BGLSIZ-1)*2
XBGS20	CLH	R1,BGLIST,R5
	JNFS	XBGS10			:.+6
	STH	R0,BGLIST,R5
XBGS10	SIS	R5,2
	JGEBS	XBGS20			:.-0C
	SIS	R10,4			:DECREMENT ARG COUNT
	JG	XBGRMV			:MORE ARGS

XBGSHO	JAL	R7,TYPCRL
	LI	R10,BGLIST
	LI	R11,BGLSIZ		:DISPLAY THE LIST
XBGSH1	LHL	R3,0,R10		:GET AN ENTRY
	JEFS	XBGSH2			:NO ENTRY
	JAL	R9,HEXOCT
        JAL	R9,TYP5CH		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
XBGSH2	AIS	R10,2			:ADVANCE POINTE
	SIS	R11,1			:DECREMENT COUNT
	JGBS	XBGSH1			:CONTINUE TYPING
	J	XRCRLF,,

	EI	:2-XRYTMC ###wjl

::*********************************************************************
::
::	COMMAND:	XNID:	NI
::	FUNCTION:	Allow nodes from two different networks to be
::			connected in an emergency situation.
::	FORMAT:		NI <line #> <desired NETID>
::
::*********************************************************************

	IF	XRESET			:###wjl

XNID	HS	0
	LIS	R2,8			:2 arguments * 4
	STH	R2,ARGMAX,XD		:maximum
	JAL	R9,RDARGS,,		:go read arguments
	LHL	R2,ARGCT,XD		:takes 3 arguments
	CLHI	R2,8			:check for them
	JN	COMERR			:if not, go type ??
	LH	R3,VALUE1+2,XD		:first argument is line number
	JAL	R9,DECHEX		:convert to hex
	J	DHXBAD			:(immed) bad radix
	CLHI	R3,NLINES-1		:(+4) check for valid line number
	JG	COMERR
	SLLS	R3,1			:we need 2*line#
	LH	R4,VALUE1+6,XD		:2nd arg is NETID
	STH	R4,LNETID,R3,		:store NETID 

	LHI	R0,NR.XID
	STH	R0,SUPMBF		:indicate XRAY NETID change in HW0
	SRHLS	R3,1			:we need real line# again
	OHI	R3,8000			:avoid escapes
	STH	R3,SUPMBF+2		:include line# in HW1
	OHI	R4,8000
	STH	R4,SUPMBF+4		:include NETID in HW2
	JAL	R10,SUP12,,		:send msg to Sup and CRYPTO Logs

	J	XRCRLF,,
	EI	:XRESET
	EI	:(XRSZLV-2)		:##AL

	SUBTTL	XRAY (Channel status - QC)

	IF	(XRSZLV-1)		:##AL

::*********************************************************************
::
::	COMMAND:	QRYCHN:	QC
::	FUNCTION:	QUERY CHANNEL STATUS
::	INPUT:		START ABS CHAN NUMBER, END CHAN, (U ACTIVE ONLY)
::
::*********************************************************************

	IF	2-XRYTMC	:###wjl

QRYCHN	HS	0
	SHI	R1,ASCU			:DID USER CLOSE WITH A 'U'(x55)	###OAS
	LR	R12,R1			:SAVE FOR LATER STUDY		###OAS
	LR	R2,R2			:CHECK ARG COUNT
	JE	COMERR			:NONE ERROR			###OAS
	SIS	R2,4			:ONE ARGUMENT			###OAS
	JE	QRYCH1			:YES				###OAS
	CLHI	R3,ENDZFL		:CHECK LAST CHANNEL NO.		###OAS
	JGE	COMERR			:TOO BIG			###OAS
	LR	R14,R3
	L	R3,VALUE1,XD		:BEGIN CHANNEL NUMBER		###OAS
	CLHI	R3,ENDZFL		:CHECK				###OAS
	JGE	COMERR			:TOO BIG			###OAS
	SR	R14,R3			:COUNT = END CHAN#-START CHAN#
	AIS	R14,1			:+1				###OAS
	JL	COMERR			:START CHAN > END CHAN		###OAS
	LR	CHN,R3			:CHN = START CHANNEL NO.	###OAS
	JFS	QRYCH2			:START DISPLAYING		###OAS

QRYCH1	CLHI	R3,ENDZFL		:DO RANGE CHECK ON CHANNEL NUMBER
	JGE	COMERR			:TOO BIG
	LIS	R14,1			:ONLY DISPLAY ONE CHANNEL	###OAS
	LR	CHN,R3			:CHN = START CHANNEL NO.	###OAS

QRYCH2	HS	0			:DISPLAY LOOP			###OAS

	LR	R12,R12			:DISP ONLY CHANS WITH BF<>0	###OAS
	JN	QRYCH3			:NO, DISP ALL CHANNELS REQUESTED###OAS
	TBT	CHN,ACP,,		:IS CHANNEL ACTIVE		###OAS
	JN	QRYCH5			:CHAN NOT ACTIVE, DON'T DISPLAY	###OAS

QRYCH3	LA	R2,QRYMS0
	JAL	R7,TYPASC		:HEADER
	LR	R3,CHN			:TYPE CHANNEL NUMBER		###OAS
	JAL	R9,TYPHW
	JAL	R8,CHNLNK		:GET LINK
	LCS	R3,2			:(immed) NEIGHBOR NOT FOUND
	JFS	QRYCH9
	LHI	R3,MACHNM		:(+4) INTERNAL, GET NODE NUMBER
	JAL	R9,HEXOCT		:(+8) CONVERT NEIGHBOR TO OCT
QRYCH9  JAL	R9,TYP5CH		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
	LHL	R3,IOTAB,CHN,CHN	:DESTINATION BUFFER
	LR	R10,R3			:SAVE IT
	NHI	R3,3			:ISOLATE SPEED BITS
	JAL	R9,TYPBYT,,		:AND DISPLAY THEM
	NHI	R10,-4			:STRIP SPEED BITS
	LHL	R3,BF,R10,		:TYPE TERMINATION CHANNEL
	JAL	R9,TYPHW
	JAL	R7,TYP2SP
	LR	R3,R10
	JAL	R9,TYPHW		:TYPE DESTINATION BUFFER
	JAL	R7,TYP2SP
	XHI	R3,4
	JAL	R9,TYPHW		:TYPE SOURCE BUFFER
	XHI	R10,4
	L	R3,BB,R10,		:BB FLAG
	JAL	R9,TYPFW
	L	R3,BE,R10,		:BE FLAG
	JAL	R9,TYPFW
	LHL	R3,BF,R10,		:AND BF
	JAL	R9,TYPHW
	LR	R2,R10
	JAL	R8,CBCCT,,
	LR	R3,R1			:GET BYTE COUNT
	JAL	R9,TYPHW
	LR	R11,R10
	SRLS	R11,1
	NHI	R11,-4			:1/2 BUFFER INDEX FOR BUFTIM
	L	R3,SLOWC,,
	S	R3,BUFTIM,R11,		:CIRCUIT TIME
	JAL	R9,TYPFW

	IF	REBILD
	LA	R2,QRYMS1
	JAL	R7,TYPASC		:REBUILD-TYPE HEADER
	LI	R3,HBUFN,R11		:DISPLAY HISTORY BUFFER INDEX
	JAL	R9,TYPHW
	L	R3,HSEQN+HBUFN,R11,
	JAL	R9,TYPFW		:DISPLAY CURRENT HISTORY BUFFER SEQN
	XHI	R10,4
	L	R3,XSEQN,R10,		:DISPLAY CURRENT TRANSMITTED SEQUENCE#
	JAL	R9,TYPFW
	XHI	R10,4
	L	R3,VSEQN,R10,
	JAL	R9,TYPFW
	LA	R2,QRYMS2		:ASSUME REBUILD ON
	SRLS	R10,3
	TBT	R10,CRQBSY,,
	JNFS	XQRYR0
	LA	R2,QRYMS3
XQRYR0	JAL	R7,TYPASC
	EI	:REBILD

QRYCH5	HS	0			:DISPLAY LOOP END		###OAS
	AIS	CHN,1			:INCREMENT CHANNEL INDEX	###OAS
	SIS	R14,1			:DECREMENT CHANNEL COUNT	###OAS
	JG	QRYCH2			:MORE TO DO			###OAS

	J	XRCRLF,,			:DONE

	NOLIST
QRYMS0	SC	/"0D"0A"0D"0ACHAN  LINK   SP  O-CHN  O-BUF   S-BUF     BB       BE     BF   COUNT SEC(HEX)"0D"0A/
QRYMS2	SC	/   ON/
QRYMS3	SC	/  OFF/
QRYMS1	SC	/"0D"0A"0AH-BUF   HSEQN    XSEQN    VSEQN   REBUILD"0D"0A/
	LIST

	EI	:2-XRYTMC ###wjl

	SUBTTL	XRAY (Symbol commands - SA, RS, WS)

::*********************************************************************
::
::	COMMAND:	DISADR:	SA
::	FUNCTION:	Display Symbol Address
::
::*********************************************************************

DISADR	HS	0
	JAL	R13,XRYIN		:read char from user
	OHI	R1,80			:set high order bit
	CLHI	R1,ASCSPC+80		:is it a space?
	JN	COMERR,,		:must separate symbol with space
	JAL	R10,RDSYMB		:read ASCII into SYMASC
	JAL	R10,SYMVAL		:look for it in symbol table
	J	COMER1			:(immed) found no match
	JAL	R7,TYPCRL		:(+4) found a match--show on next line
	JAL	R7,TYPLF
	JAL	R9,TYPFW		:output the fullword value
	JAL	R7,TYPCRL		:look pretty
	J	XPRMPT,,		:and skedaddle...

::*********************************************************************
::
::	COMMANDS:	READS:/WRITES:	RS/WS
::	FUNCTION:	Read/write symbolic
::
::*********************************************************************

READS	HS	0
	LHI	R1,TYPE-SEGD		:Read comes here
	STH	R1,RWADDR,,
	IF	(XRSZLV-2)		:##AL
	JFS	RDWRIT
WRITES	HS	0
	LHI	R1,WRITE-SEGD		:Write comes here
	STH	R1,RWADDR,,
	EI	:(XRSZLV-2)
RDWRIT	JAL	R13,XRYIN		:get that space in and out of the way
	OHI	R1,80
	CLHI	R1,ASCSPC+80
	JN	COMERR,,
	JAL	R10,RDSYMB
	LR	R11,R1			:SAVE LAST CHAR TYPED
	JAL	R10,SYMVAL
	J	COMER1			:(immed) NO MATCH
	ST	R3,VALUE1,XD		:(+4) STORE THE SYMBOL VALUD
	CLHI	R11,ASCCR+80		:A CR WITH HOB?			###wjl
	JEFS	RDWRI0			:YES				###wjl
	CLHI	R11,ASCCR		:A CR?
	JNFS	RDWRI1			:NO
RDWRI0	LIS	R0,0
	ST	R0,VALUE1+4,XD		:ZERO SECOND ARG
	LIS	R0,4
	STH	R0,ARGCT,XD
	J	RDWRI2

COMER1	J	COMERR,,		:Whenever it needs		###al

RDWRI1	L	R0,VALUE1,XD
	JAL	R9,RDARGS
	ST	R0,VALUE1,XD
	AIS	R2,4
	STH	R2,ARGCT,XD
	ST	R3,VALUE1+4,XD
RDWRI2	JAL	R7,TYPCRL
	LHL	R1,RWADDR,,
	CI	R1,TYPE-SEGD		:READ ONLY?
	JE	SEGD,R1,,		:YES, GO AHEAD

	LH	R7,XPOWER,XD		:HAVE POWER?			###TZ
	JLE	SEGD,R1,,		:YES, GO AHEAD			###TZ

:	IF TRYING TO WRITE WITHOUT POWER, MUST BE ONE OF FOLLOWING SYMBOLS:
	LIS	R7,2			:ALLOW ONLY 2 BYTES TO BE WRITTEN
	ST	R7,VALUE1+4,XD		:AS SO
	L	R7,VALUE1,XD		:GET THE WRITE ADDRESS
	CI	R7,CRYDIS
	JE	SEGD,R1,,
	CI	R7,REBDIS
	JE	SEGD,R1,,
	CI	R7,ASYDIS
	JE	SEGD,R1,,

	J	COMERR,,		:NONE OF THE ABOVE, SECURITY VIOLATION

	SUBTTL	XRAY (Channel commands - AC, TC, TD, TE, TA)

::*********************************************************************
::
::	COMMAND:	XACHAN:	AC
::	FUNCTION:	DISPLAY ACTIVE CHANNELS
::	INPUT:		ABS CHAN NUMBER, RANGE
::	###OAS
::*********************************************************************

	IF	2-XRYTMC	:###wjl

XACHAN	HS	0
	LR	R2,R2			:ZERO ARGS
	JE	COMERR,,		:YES,ERROR
	SIS	R2,4			:ONE ARG
	JE	COMERR,,		:YES,ERROR
	CLHI	R3,ENDZFL		:LAST ARG (RANGE) VALID
	JGE	COMERR,,		:NO
	LR	R3,R3			:RANGE = 0?
	JE	COMERR,,		:YES, ERROR
	LR	R14,R3			:OKAY, SAVE RANGE
	L	R3,VALUE1,XD		:GET FIRST ARG (START CHAN)
	CLHI	R3,ENDZFL		:START CHAN VALID
	JGE	COMERR,,		:NO
	LR	CHN,R3			:SAVE START CHANNEL
	AR	R14,CHN			:COMPUTE END CHANNEL
	SIS	R14,1
	CLHI	R14,ENDZFL		:TRUNCATE END CHANNEL?
	JLFS	XACHN1			:NO
	LHI	R14,ENDZFL		:YES

XACHN1	HS	0
	LIS	R12,0C			:12 HW'S PER LINE
	JAL	R7,TYPCRL
XACHN2	HS	0
	TBT	CHN,ACP,,		:CHANNEL ACTIVE?
	JNFS	XACHN3			:NO, DON'T DISPLAY
	LR	R3,CHN			:YES, DISPLAY CHANNEL NUMBER
	JAL	R9,TYPHW
	SIS	R12,1			:COUNT THIS ITEM ON THIS LINE
XACHN3	HS	0
	AIS	CHN,1			:BUMP CHANNEL NO.
	CR	CHN,R14			:UPPER LIMIT YET?
	JG	XRCRLF,,		:YES
	LR	R12,R12			:NOT DONE, CHECK FOR NEXT LINE
	JE	XACHN1			:LINE FULL, USE NEXT LINE
	J	XACHN2			:NOT FULL, CHECK FOR NEXT ACTIVE CHAN

	EI	:2-XRYTMC ###wjl

::*********************************************************************
::
::	COMMAND:	XCHTRC:	TC
::	FUNCTION:	SET CHANNEL DATA TRACE
::	INPUT:		ARG 2 =	START/END TRACE SELECT
::			ARG 1 =	ABS CHANNEL NO
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl

XCHTRC	HS	0
	LR	R2,R2
	JE	XCHTR2
	SIS	R2,8
	JN	COMERR,,
	LHL	R1,VALUE1+2,XD		:ABS CHANNEL TO TRACE
	CLHI	R1,ENDZFL		:LARGEST ALLOWABLE CHANNEL
	JG	COMERR,,			:TOO BIG
	LR	R3,R3			:0=> END TRACE, 1=> START TRACE
	JN	XCHTR1
	RBT	R1,TRCHAN,,
	J	XCHTR2
XCHTR1	SIS	R3,1
	JN 	COMERR,,
	SBT	R1,TRCHAN,,
XCHTR2	LIS	R10,0
XCHTR4	LHL	R12,TRCHAN,R10,
XCHTR6	JFFOH	R12,XCHTR3
	JFS	XCHTR5			:DONE WITH THIS H-WORD
XCHTR3	XH	R12,HMSK,R13,R13
	LR	R3,R10
	SLLS	R3,3
	AR	R3,R13
	JAL	R9,TYPHW
	JBS	XCHTR6
XCHTR5	AIS	R10,2
	CLHI	R10,ENDZFL/8
	JL	XCHTR4
	J	XRCRLF,,

	EI	:2-XRYTMC ###wjl

::*********************************************************************
::
::	COMMANDS:	TRCDAT:/TRCDES:/TRCASC:	TD, TE, TA
::	FUNCTION:	DISPLAY DATA FROM THE CHANNEL TRACE BUFFERS
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl

TRCMS0	SC	?"0D"0AI/O  CHN  TIME"0D"0A"0A?	:###wjl
TRCMS1	SC	/OUT /
TRCMS2	SC	/IN  /

TRCASC	HS	0			:SAME AS TRCDAT, BUT DISPLAYS IN ASCII
	LHI	R4,$A44			:INDICATE ASCII DISPLAY MODE
	JFS	TRCD00

TRCDES	HS	0			:SAME AS TRCDAT, BUT DISPLAYS ESCAPES
	LIS	R4,0			:INDICATE HEX DISPLAY MODE
	LIS	R0,0			:INDICATE DISPLAY ESCAPES
	JFS	TRCD00

TRCDAT	HS	0
	LIS	R4,0			:INDICATE HEX DISPLAY MODE
	LIS	R0,1			:INDICATE SUPPRESS ESCAPES
TRCD00  lis     r11,0
        sth     r11,xdjsat,xd           :indicate trace TD/TA/TE trace (not aDJ)
trcd0j  
	STH	R0,TDESFL,,		:SAVE VALUE IN ESCAPE FLIPPER
	STH	R4,TDMODE,,		:STORE ASCII/HEX MODE INDICATOR
	LIS	R11,0			:CLEAR TRMASK TO DISPLAY ALL DATA
	LHI	R5,(TRRSIZ/8)-4
TRCD01	ST	R11,TRMASK,R5,
	SIS	R5,4
	JGEBS	TRCD01
	STH	R11,XTDXCT,,		:INITIALIZE LOOP COUNTER
:	R11=0, ASSUME ALL TYPES OF MESSAGE DESIRED
	CLHI	R1,ASCI			: 'I' ?
	JNFS	TRCD13			:NO, CHECK FOR 'O' 
	LCS	R11,2			:YES, ENABLE INPUT MESSAGES
	JFS	TRCD14			:AND PROCEED
TRCD13	CLHI	R1,ASCO			: 'O'?
	JNFS	TRCD14			:NO
	LCS	R11,1			:YES, ENABLE OUTPUT MESSAGES

TRCD14	LHL	R5,TRRIX		:OLDEST ENTRY IN TABLE
	LR	R2,R2			:NUMBER OF ARGS
	JNFS	TRCDA0
	AHI	R3,200			:DISPLAY ENTIRE TABLE
TRCDA0	LR	R8,R3			:SAVE ARGUMENT
	LHI	R1,308			:TURN OFF TRACE
	STH	R1,CHRTRC,,
	STH	R1,XTDFLG,,		:NOTE XRAY IN TD INST IN CASE OF ^C
	LA	R2,TRCMS0		:HEADER
	JAL	R7,TYPASC

	LCS	R10,1			:R10 SERVES AS FLAG AND POINTER
TRCDA5	SIS	R5,8			:BACK UP 4 HW
	JGEFS	TRCDA1			:NO WRAP
	AHI	R5,TRRSIZ		:DE-WRAP
TRCDA1	CLH	R5,TRRIX		:COME FULL CIRCLE?
	JEFS	TRCDA3			:YES, JUST DISPLAY WHOLE TABLE
	JAL	R9,TRCTST		:INVESTIGATE THIS DW
	J	TRCDA5			:NOT SATISFACTORY, BACK UP
	LR	R10,R5			:SAVE POINTER TO LAST MESSAGE FOUND
	SIS	R8,1			:DECREMENT NUMBER OF MESSAGES DESIRED
	JG	TRCDA5			:NOT DONE YET, KEEP LOOKING

TRCDA3	LR	R5,R10			:RECOVER POINTER
	JL	TRCD30			:R10 STILL -1, NO MESSSAGES FOUND. EXIT

TRCDA2	JAL	R9,TRCTST		:DOUBLE-CHECK THIS POTENTIAL BEGINNING
	J	TRCD20			:NOT GOOD, ADVANCE TO NEXT DW BOUNDARY
	JAL	R10,TRCSUP		:SET UP FOR DISPLAY
	J	TRCD11			:NOT PRINTABLE

:	FOUND AN APPARENTLY VALID ENTRY...PRINT IT
	LA	R2,TRCMS1		:PRESUME OUTPUT MESSAGE (-1)
	AIS	R4,1			:VERIFY THAT GUESS
	JEFS	TRCDA6			:RIGHT
	LA	R2,TRCMS2		:WRONG, INPUT MESSAGE (-2)
TRCDA6	JAL	R7,TYPASC		:TYPE THE I/O MESSAGE
        lh      r0,xdjsat,xd            :mode?
        jefs    trcdj1
        ahi     r3,400-2-supzfl
        jal     r9,typ5o,,              :print it as node number
        jfs     trcdj2
trcdj1
	JAL	R9,TYPHW		:AND CHANNEL NUMBER
trcdj2	LHL	R3,TRRING+4,R5,,
	JAL	R9,TYPHW		:TIME				###jhl
	AIS	R5,8			:ADVANCE TO NEXT DW BOUNDARY
	NHI	R5,TRRSIZ-1
	LIS	R10,1			:ESCAPE STRIPPER

TRCDA8	LIS	R8,$A12			:12 BYTES MAX LINE IF HEX DISPLAY MODE
	AH	R8,TDMODE,,		:TDMODE NON-ZERO IF ASCII MODE.
					: LENGTHENS LINE
TRCDA9	LB	R3,TRRING,R5,,		:GET NEXT BYTE OF MESSAGE
	JGFS	TRCD10			:UNESCAPED
	XH	R10,TDESFL,,		:FLIP R10 IF 'TD', NOP IF 'TE'
	JE	TRCD12			:THIS IS FIRST 0, DONT TYPE
TRCD10	LIS	R10,0
	TBT	R5,TRMASK,,		:PRINTABLE CHARACTER?
TRCDUX	JN	TRCD12			:NO
	LIS	R10,1			:YES - SET R10 TO ADVANCE LINE POINTER
	LHL	R7,TDMODE,,		:TEST FOR ASCII/HEX DISPLAY MODE
	JEFS	TRCMHX			:ZERO, DISPLAY IN HEX
	LR	R1,R3			:ASCII, COPY OVER TO R1
	JAL	0D,XRYOUT		:AND TYPE DIRECTLY OUT
	NHI	R1,ASC7BT		:STRIP OUT HOB
	SIS	R1,ASCCR		:CARRIAGE RETURN?
	JNFS	TRCD12			:NO
	JAL	R7,TYP8SP,,		:YES, POSITION ON COLUMN 16
	JAL	R7,TYP8SP,,
	JFS	TRCD12
TRCMHX	JAL	R9,TYPBYT		:HEX MODE, DISPLAY HEX BYTE
TRCD12	SIS	R6,1			:DECREMENT BYTE COUNT
	JE	TRCDA7			:DONE. (WE NEVER GET A ZERO BYTE COUNT)
	AIS	R5,1			:INCREMENT BYTE POINTER
	NHI	R5,TRRSIZ-1		:CORRECT FOR WRAP
	SR	R8,R10			:R10 IS EITHER 0 OR 1
	JG	TRCDA9			:ROOM FOR MORE BYTES ON THIS LINE
	JAL	R7,TYPCRL		:NO MORE ROOM ON THIS LINE
	JAL	R7,TYP8SP
	JAL	R7,TYP8SP

	J	TRCDA8			:CONTINUE WITH THIS MESSAGE

TRCDA7	JAL	R7,TYPCRL		:DO CR-LF
TRCD20	AIS	R5,8			:ADVANCE TO NEXT DW BOUNDARY
	NHI	R5,TRRSIZ-8	
	CLH	R5,TRRIX		:AT CURRENT POSITION?
	JEFS	TRCD30			:YES - DONE TRACE DISPLAY
	LHL	R6,XTDXCT,,		:# OF TIMES THROUGH HERE
	AIS	R6,1
	STH	R6,XTDXCT,,
	CLHI	R6,TRRSIZ/8		:ARE WE OUT OF CONTROL?
	JL	TRCDA2			:NO - CONTINUE

:	END OF TD COMMAND
TRCD30	LHI	R1,208
	STH	R1,CHRTRC,,		:RE-ENABLE TRACE
	TS	XTDFLG,,
        lh      r0,xdjsat,xd            :doing from DJ cmd?
        je      xprmpt,,
        lhl     r0,xdjsav,xd
        rbt     r0,trchan,,             :stop tracing
	J	XPRMPT,,		:AND RETURN

TRCD11	AR	R5,R6			:ADD IN BYTE COUNT
	J	TRCD20			: AND PROCEED

	EI	:2-XRYTMC ###wjl

::*********************************************************************
::
::	SUBROUTINE:	TRCTST:
::	FUNCTION:	DOES RANGE CHECK ON BYTE COUNT AND CHANNEL NUMBER,
::			TESTS BIT IN TRCHAN, AND MASKS THE I/O INDICATOR.
::	CALLING SEQ:	JAL	R9,TRCTST
::	INPUT:		R5 = POINTER TO ENTRY IN TRRING
::			R11= MASK TO SELECT INPUT(-2),OUTPUT(-1),OR ALL(0) MSGS
::	OUTPUT:		R6 = BYTE COUNT
::	RETURNS:	DIRECT RETURN	=>	NOT SATISFACTORY
::			SKIP RETURN	=>	SATISFCTORY
::
::*********************************************************************

TRCTST	HS	0
	LH	R6,TRRING+6,R5,,	:PRESUMED BYTE COUNT
	JLER	R9			:NON-POSITIVE => INVALID, DIRECT RETURN
	CLHI	R6,$A121		:TEST FOR MAXIMUM SIZE
	JGR	R9			:TOO BIG => INVALID, DIRECT RETURN
	LHL	R3,TRRING+2,,R5		:POSSIBLE CHANNEL
	CLHI	R3,ENDZFL		:WITHIN RANGE?
	JGR	R9			:NO,DIRECT RETURN
	TBT	R3,TRCHAN,,		:BIT SET?
	JER	R9			:NO,DIRECT RETURN
	LH	R4,TRRING,,R5		:I/O INDICATOR
	CR	R4,R11			:MATCH WITH R11?
	JE	4,R9			:YES,SKIP RETURN
	LR	R11,R11			:ALL MESSAGES ENABLED?
	JNR	R9			:NO, THIS ISNT A VALID MESS.
	LR	R2,R4			:YES, VALID MESSAGE IF I/O INDICATOR OK
	AIS	R2,1			:IS R2 = -1 ?
	JE	4,R9			:YES, SKIP RETURN
	AIS	R2,1			:NO, IS R2 = -2 ?
	JE	4,R9			:YES,SKIP RETURN
	JR	R9			:NO, DIRECT RETURN

::*********************************************************************
::
::	SUBROUTINE:	TRCSUP:
::	FUNCTION:	TRACE DISPLAY SET-UP
::	CALLING SEQ:	JAL	R10,TRCSUP
::	PRESERVED:	R3, R4, R5, R6, R9, AND R11
::	RETURNS:	IMMEDIATE = NOT PRINTABLE
::			+4	  = FOUND APPARENTLY VALID ENTRY
::
::*********************************************************************

:	CHECK FOR COMMAND CIRCUIT TRACING. IF TRUE, MASK OUT PASSWORDS.
:	THE BIT ARRAY 'TRMASK' HAS A BIT POSITION FOR EACH BYTE OF TRRING.
:	TRCSUP CLEARS THE BIT ARRAY, AND THEN SETS BITS FOR PASSWORD
:	CHARACTERS. TRMASK IS TESTED IN 'TRCD10', AND BYTES ARE NOT
:	OUTPUT FOR SET BITS.
	
TRCSUP	HS	0
	JAL	R9,TRCTST		:TEST FOR PRINTABLE MESSAGE
	J	0,R10			:NO - NON-SKIP RETURN

	IF	ISIS+SOLOCS

:	IS THIS POSSIBLY A COMMAND CIRCUIT?
	CLHI	R3,LEPZFL
	JL	4,R10			:NO - TOO LOW
	CLHI	R3,DISZFL
	JGE	4,R10			:TOO HIGH

:	SET UP TO SCAN FOR SUP MESSAGES WHICH MAY CONTAIN PASSWORDS. LOOK
:	FOR THE SEQUENCE:
:		MACHNM+8000
:		0E,80+N
:		PORT NUMBER+8000
:		X,X
:		X,X
:	WHERE N IS THE NUMBER OF PASSWORD CHARACTERS X.

	LR	R13,R6			:SET R13 AS # OF CHARACTERS TO SCAN
	LHI	R12,TRRSIZ-1		:R12 IS RING WRAP MASK

	LR	R1,R5			:R1 POINTS TO BEGIN OF STRING TO SCAN
	AIS	R1,7
TRCS10	AIS	R1,1			:BEGIN NEW SCAN FOR PASSWORD MESSAGE
	NR	R1,R12
	SIS	R13,1			:DONE?
	JL	4,R10			:YES - GO DISPLAY

	LB	R0,TRRING,R1,
	CLHI	R0,(MACHNM+8000)/100
	JNBS	TRCS10			:NO MATCH - TRY NEXT BYTE
	LR	R2,R1			:POTENTIAL SUP MSG W/PASSWORD,PRESRV R1
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,
	CLHI	R0,MACHNM&0FF		:OUR NODE NUMBER?
	JN	TRCS10			:NO
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,
	CLHI	R0,0E			:0E MESSAGE TYPE?
	JN	TRCS10			:NO
:	YES - GOT A PASSWORD MESSAGE...
	AIS	R2,2
	NR	R2,R12	
	LB	LRC,TRRING,R2,		:GET CHARACTER COUNT
	NHI	LRC,7F			: AND ISOLATE
	SHI	R13,2,LRC		:DECREMENT COUNT OF CHARACTERS TO SCAN
	AIS	R2,2			:ADVANCE INDEX PAST PORT NUMBER
	LR	R1,R2
	AR	R1,LRC			:POINT PAST PASSWORD MSG FOR NEXT SCAN
	NR	R1,R12
	NR	R2,R12
TRCS20	AIS	R2,1			:INDEX TO		###sn###wjl
	NR	R2,R12			:  PASSWORD CHARACTER	###sn###wjl
	SBT	R2,TRMASK,,		:PREVENT DISPLAY OF PASSWORD CHARACTERS
	CR	R2,R1			:DONE MASKING PASSWORD?
	JNBS	TRCS20			:NOT YET
	J	TRCS10			:YES - LOOK FOR MORE TO DO

	ELSE	:NOT ISIS

	J	4,R10			:SKIP RETURN

	EI	:ISIS+SOLOCS

	SUBTTL	XRAY (CRYPTO display mode - CD)

::*********************************************************************
::
::	COMMAND:	XCRMOD:	CD
::	FUNCTION:	CD Y TURNS DISPLAY ON
::			CD N TURNS DISPLAY OFF
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl

XCRMOD	HS	0
	LR	R2,R2			:DETERMINE NUMBER OF ARGS
	JN	COMERR,,		:NON-ZERO,ERROR!
	CLHI	R1,ASCY			:LAST CHAR = 'Y'(x59)?
	JEFS	XCRMO3			:YES, TURN ON
	CLHI	R1,ASCN			:LAST CHAR = 'N'(x4E)?
	JNFS	XCRMO1			:NO, JUST DISPLAY
	LIS	R2,1
XCRMO3	STH	R2,CRYMOD,XD		:MAKE ENTRY
XCRMO1	LA	R2,CRYPON		:PRESUME ON
	LHL	R1,CRYMOD,XD		:VERIFY GUESS
	JEFS	XCRMO2			:RIGHT
	LA	R2,CRYPOF		:WRONG
XCRMO2	JAL	R7,TYPASC		:DISPLAY MODE
	J	XPRMPT,,		:AND RETURN

	NOLIST
CRYPON	SC	/"0D"0A AUTO CRYPTO ON"0D"0A/
CRYPOF	SC	/"0D"0A AUTO CRYPTO OFF"0D"0A/
	LIST

	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV-1)		:##AL

	SUBTTL	XRAY (ASYNC ports status - IZ, HP, AZ, AS, MC)

	IF	SOLOCS

::*********************************************************************
::
::	COMMAND:	XASYIZ:	IZ
::	FUNCTION:	INITIALIZES ASYNC RING
::
::*********************************************************************

	SEG	0			:###jhl
XIZCIU	HS	1

	SEG	0D

	IF	2-XRYTMC		:###wjl
	IF	0			:remove for version 6		###wjl	
XASYIZ	HS	0
	LHL	R2,XIZCIU,,		:###jhl
	JN	XCOMIU,,		:command in use			###jhl
	STH	XD,XIZCIU,,		:destroyed by IZASYN		###jhl
	LHI	R11,(NAPORT-1)*2
XIZAS1	LHL	R2,ASYTAB,R11,		:IS THERE A CIRCUIT?
	JEFS	XIZAS2			:NO
	NHI	R2,-4			:YES, ZAP IT
	JAL	R9,ZAPHRD,,
XIZAS2	SIS	R11,2
	JGEBS	XIZAS1
	JAL	R10,IZASYN,,		:INITIALIZE ASYNC RING
	IF	TELEX			:###wjl
	JAL	R0,TINIT,,		:build telex pvc circuits
	EI	:TELEX
	LHL	XD,XIZCIU,,		:restore XD destroyed by IZASYN	###jhl
	LIS	R0,0
	STH	R0,CS.(HNPORT),,
	STH	R0,XIZCIU,,		:free up the command		###jhl
	J	XRCRLF,,
	EI	:0

::*********************************************************************
::
::	COMMAND:	XHANGP:	HP
::	FUNCTION:	HANG ASYNC PORT (HP)
::
::*********************************************************************

XHANGP	HS	0
	JAL	R9,OCTHXR		:CHANGE R3 (PORT#) TO OCTAL
	CLHI	R3,NAPORT		:IN RANGE?
	JGE	COMERR,,		:NO
	LHL	R2,ASYTAB,R3,R3 	:GET BUFFER NUMBER FROM PORT TO NETWORK
	JE	COMERR,,		:NO BUFFER, PORT IS ALREADY HUNG
	XHI	R2,4			:FLIP TO BUFFER TOWARDS PORT
	LHI	R1,01F0			:FORM A HANG
	JAL	R9,W2CI,,		:AND DEPOSIT INTO BUFFER
	LHI	R1,01F1			:SUPER-HANG TOO
	JAL	R9,W2CI,,
	J	XPRMPT,,

::*********************************************************************
::
::	COMMAND:	XAZASY:	AZ
::	FUNCTION:	CLEAR ALL ASYNC STATISTICS PARAMETERS
::
::*********************************************************************

XAZASY	HS	0
	LIS	R0,0
	LIS	R2,1
	STH	R0,CS.(NSASHO),,	:CLEAR HI-WATER MARKS
	STH	R0,CS.(NSASHI),,

	IF	NUMPRN
	STH	R0,CS.(NSPRHO),,
	EI	:NUMPRN

	STH	R0,CS.(MXPORT),, 	:MAX NUMBER OF ASYNC PORTS IN USE

	IF	ASYNCT
	STH	R0,CS.(FASTCH),,
	EI	:ASYNCT

	LHI	R1,NAPORT-1
XAZAS1	STH	R0,CS.(IZITUP),R1,R1
	TBT	R1,ASYACP,,		:IS THIS PORT UP?
	JNFS	XAZAS2			:NO
	AHM	R2,CS.(MXPORT),,	:BUMP MAX ASYNC PORTS COUNT
XAZAS2	SIS	R1,1
	JGEBS	XAZAS1
	J	XRCRLF,,

	EI	:2-XRYTMC ###wjl

::*********************************************************************
::
::	COMMAND:	XASYNC:	AS
::	FUNCTION:	DISPLAY ASYNC PORT STATUS
::			Can include SIO and MPVC ###jhl
::
::*********************************************************************

	SEG	0
RLASAV	HS	1			:for saving RLA array during count##jhl

	SEG	0D

	IF	2-XRYTMC		:###wjl

XASYH0	SC	/    PEAK = /
XASYH1	SC	/PORTS IN USE OUT OF  /
XASYH2	SC	/BPS MAX/
XASYHD	SC	/"0D"0A"0APORT  RLA DTR DSR RTS CP DPLX BR  CCT NL  CHAN  LINK  TIME(SEC)   UP"0D"0A"0A/

XASYNC	SHI	R1,ASCU			:DID USER CLOSE WITH 'U'(x55)?
	LR	R11,R1			:SAVE FOR LATER STUDY
	LHI	R14,NPORT		:NUMBER OF ASYNC PORTS		###jhl
	LIS	R10,0			:FIRST ASYNC PORT
	LR	R2,R2			:ZERO ARGUMENTS?
	JE	XASY11			:YES
	SIS	R2,4			:ONE ARGUMENT?
	JE	XASY17			:YES

	JAL	R9,OCTHXR		:CONVERT END PORT NUMBER TO HEX
	CLHI	R3,NPORT		:DO RANGE CHECK			###jhl
	JGE	COMERR,,		:TOO BIG
	LR	R14,R3
	L	R3,VALUE1,XD		:STARTING PORT NUMBER
	JAL	R9,OCTHXR		:CONVERT PORT NUMBER TO HEX
	CLHI	R3,NPORT		:DO RANGE CHECK			###jhl
	JGE	COMERR,,		:INVALID PORT NUMBER
	LR	R10,R3			:MOVE PORT NUMBER
	SR	R14,R10			:COUNT = ENDING PORT - START PORT
	AIS	R14,1			:...PLUS 1
	JFS	XASY11

XASY17	LIS	R14,1			:DISPLAY FOR JUST 1 PORT
	JAL	R9,OCTHXR		:CONVERT PORT NUMBER TO HEX
	CLHI	R3,NPORT		:DO RANGE CHECK			###jhl
	JGE	COMERR,,		:INVALID PORT NUMBER
	LR	R10,R3			:MOVE PORT NUMBER

XASY11	JAL	R7,TYPCRL		:TYP CR-LF
:	Use RLA array for counting active ports, 
:	particularly in the MPVC environment. ###jhl
	LIS	R3,0			:init the one's counter
	LHI	R2,NGRP-1		:halfword index into RLA
XASYAA	LHL	R0,RLA,R2,R2		:read a HW of RLA (back to front)
	STH	R0,RLASAV,,		:working copy halfword at a time
XASYAB	LHL	R0,RLASAV,,		:reset the target halfword
	JFFOH	R0,XASYAC	
	SIS	R2,1			:step to previous halfword
	JGEBS	XASYAA			:loop while index is valid
	JFS	XASYAD			:exit counting loop.  R3 has result.
XASYAC	AIS	R3,1			:increment the counter
	RBT	R1,RLASAV,,		:count one's once only
	JBS	XASYAB			:and look for more
XASYAD	JAL	R9,TYPHWD		:TYPE NUMBER OF ACTIVE PORTS
	LA	R2,XASYH1		:TYPE FIRST HEADER
	JAL	R7,TYPASC
	LHI	R3,NPORT		:AND TOTAL NUMBER OF PORTS	###jhl
	JAL	R9,TYPHWD
	LA	R2,XASYH0
	JAL	R7,TYPASC
:	note--this is not kept in the SOLOCS, as it is not easy to keep
:	track of in our environment without changes to the consat.
	LHL	R3,CS.(MXPORT),,	:MAX NUMBER OF ASYNC PORTS IN USE
	JAL	R9,TYPHWD
	JAL	R7,TYP4SP
	JAL	R7,TYP4SP
	LHI	R3,1200+BAUDR*1B00
	JAL	R9,TYPHW		:DISPLAY MAXIMUM CPS SUPPPORT
	LA	R2,XASYH2
	JAL	R7,TYPASC
	LA	R2,XASYHD		:TYPE HEADER
	JAL	R7,TYPASC
XASY12	JAL	R12,XASYOU		:OUTPUT DATA
	AIS	R10,1			:INCREMENT PORT INDEX
	SIS	R14,1			:DECREMENT PORT COUNT
	JGBS	XASY12			:AND REPD REPEAT IF MORE
	J	XPRMPT,,		:ELSE DEPART

XASYOU	LR	R11,R11			:DID USER WANT ACTIVE PORTS ONLY?
	JNFS	XASY15			:NO,ALL PORTS
	TBT	R10,RLA,,		:Is this port active?		###jhl
	JER	R12			:bits set for active		###jhl
XASY15	LR	R3,R10
	JAL	R9,HEXOCT		:GO TO OCTAL FOR DISPLAY
	CLHI	R3,077			:DOES IT FIT INTO 2 DIGITS?
	JGFS	XASY13			:NO
	JAL	R7,TYP2SP		:YES, TYPE TWO SPACES
	JAL	R9,TYPBYT		:TYPE PORT NUMBER
	JFS	XASY14
XASY13	JAL	R9,TYPHW
XASY14	LCS	R3,1
:	For pseudo ports in particular, test RLA
	TBT	R10,RLA,,		:test RLA...1=>active		###jhl
	JNFS	XASY01			:				###jhl
	LIS	R3,0
XASY01	JAL	R9,TYPBYT
	LCS	R3,1
	TBT	R10,CS.(DTR),,		:TEST DTR...0=>ACTIVE
	JEFS	XASY02
	LIS	R3,0
XASY02	JAL	R9,TYPBYT
	LCS	R3,1
	TBT	R10,CS.(DSR),,		:TEST DSR...0=ACTIVE
	JEFS	XASY03
	LIS	R3,0
XASY03	JAL	R9,TYPBYT
	LCS	R3,1
	TBT	R10,CS.(RTS),,		:TEST RTS...0=>ACTIVE
	JEFS	XASY04
	LIS	R3,0
XASY04	JAL	R9,TYPBYT
	LCS	R3,1
	TBT	R10,CS.(CP),,		:AND CARRIER PRESENCE
	JEFS	XASY05
	LIS	R3,0
XASY05	JAL	R9,TYPBYT
	LIS	R3,0
	TBT	R10,CS.(HAFDUX),,	:1=>HALF DUPLEX
	JEFS	XASY06
	LCS	R3,1
XASY06	JAL	R9,TYPBYT
	LB	R3,CS.(IBRATE),R10,	:BAUD RATE, INPUT AND OUT
	SLLS	R3,4
	LB	R9,CS.(OBRATE),R10,
	OR	R3,R9
	JAL	R9,TYPBYT
:	Read the .TERMT H-word out of the port table, use it to index into VID
:	table (byte which is at	this offset from VID.ID).  $0 0C0!CCT is the
:	actual table entry, so strip 0C0 and convert to decimal to conform to
:	CIRCUIT.DOC Circuit Characteristic Type (CCT)			###wjl
	LHL	R13,.PTP.,R10,R10	:get port table offset into seg4
	AI	R13,PTBASE		:add seg4 base offset
	LHL	R3,.TERMT,R13,		:get index into VID table for port#wjl
	LB	R3,VID.ID,R3,		:this byte is CCT		###wjl
	NHI	R3,3F			:remove HO bits from table entry###wjl
	JAL	R9,TYPBYD		:convert to decimal 		###wjl

	LB	R3,CS.(ASYLNK),R10,	:NUMBER OF LINKS IN CRQ
	JAL	R9,TYPBYD		:TYPE OUT
	LHL	R6,ASYTAB,R10,R10	:ASYNC PORT'S SINK BUFFER
	JE	XASY07			:ZERO, THIS PORT GOES NOWHERE
	NHI	R6,-4
	LHL	R3,BF,R6,,		:THE OUTBOUND CHANNEL
	JAL	R9,TYPHW		:DISPLAY CHANNEL
	LR	CHN,R3
	JAL	R8,CHNLNK		:FIND NEIGHBOR
	LCS	R3,2			:(immed) NO NEIGHBOR
	JFS	XASY09
	J	XASY21			:(+4) internal			:###wjl
	JAL	R9,HEXOCT		:(+8) R3 HAS NEIGHBOR NUMBER, CONVERT
XASY09	JAL	R9,TYPHW		:DISPLAY NEIGHBOR
XASY19	L	R3,SLOWC,,		:COMPUTE CIRCUIT LIFETIME
	SRLS	R6,1
	NHI	R6,-4
	S	R3,BUFTIM,R6,		:CIRCUIT LIFETIME
XASY20	JAL	R9,TYPFWD		:DISPLAY CIRCUIT UP TIME
XASY08	JAL	R7,TYP2SP
	LHL	R3,CS.(IZITUP),R10,R10	:NUMBER OF TIMES PORT WAS ANSWER'D#wjl
	JAL	R9,TYPHW		:				###wjl
	JAL	R7,TYPCRL		:CR-LF
	JR	R12			:AND RETURN

XASY07	LIS	R3,0			:NULL CIRCUIT
	JAL	R9,TYPHW
	JAL	R9,TYPHW
	JAL	R9,TYPFW		:DISPLAY 0 FOR CHN, NEIGHBOR, TIME
	J	XASY08

XASY21	LHI	R3,MACHNM		:get machine number		###wjl
	JAL	R9,HEXOCT		:convert from hex to octal	###wjl
	JAL	R9,TYPHW		:display			###wjl
	LIS	R3,0			:set up for circuit up time of zero
	CLHI	CHN,ASYZFL		:and if CHN is not INTHST channel##wjl
	JGE	XASY20			:assume it is a port in login,	###wjl
	CLHI	CHN,INTZFL		:so circuit lifetime not	###wjl
	JL	XASY20			:meaningful...			###wjl
	J	XASY19			:must be INTHST channel		###wjl

	EI	:2-XRYTMC ###wjl

::*********************************************************************
::
::	COMMAND:	XASYMC:	MC
::	FUNCTION:	FIDDLE WITH ASYNC MICROCODE PARAM'S
::
::*********************************************************************

XASYMC	SVC	0F,SV.SR4
	LHI	R5,NACARD*2
	LA	R10,XASYMV
	JAL	R8,TYPNHW
	J	XPRMPT,,

XASYMV	WS	10

	EI	:SOLOCS:*:


	SUBTTL	XRAY (Conversion routines - HO, OH, HD, DH, OD, DO)

	IF	(XRSZLV-2)		:##AL

::*********************************************************************
::
::	COMMAND:	XHXOCT:	HO
::	FUNCTION:	CONVERT HEX TO OCTAL
::
::*********************************************************************

XHXOCT	HS	0
	NI	R3,0FFFF		:STRIP TOP HW
	JAL	R9,HEXOCT
	JAL	R9,TYPFW		:5 DIGIT NODE# NEEDS FW		###AL
:	JAL	R9,TYPHW
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XOCHEX:	OH
::	FUNCTION:	CONVERT OCTAL TO HEX
::
::*********************************************************************

XOCHEX	HS	0
	JAL	R9,OCTHXR
	JAL	R9,TYPFW		:		###shm
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XHXDEC:	HD
::	FUNCTION:	HEX TO DECIMAL
::
::*********************************************************************

XHXDEC	HS	0
	JAL	R9,HEXDEC
	CLI	R3,10000
	JGEFS	XHXDE1
	JAL	R9,TYPHW
	J	XRCRLF,,
XHXDE1	JAL	R9,TYPFW
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XDCHEX:	DH
::	FUNCTION:	DECIMAL TO HEX
::
::*********************************************************************

XDCHEX	HS	0

	JAL	R9,DECHEX
	J	DHXBAD			:(immed) RADIX VIOLATION
	JAL	R9,TYPHW		:(+4) DISPLAY
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XOCDEC:	OD
::	FUNCTIOPN:	OCTAL TO DECIMAL
::
::*********************************************************************

XOCDEC	HS	0
	TI	R3,88888888		:CHECK FOR VALID OCTAL		###OAS
	JN	DHXBAD			:RADIX VIOLATION		###OAS
	JAL	R9,OCTHXR		:CONVERT TO HEX
	JAL	R9,HEXDEC		:CONVERT HEX TO DECIMAL
	JAL	R9,TYPFW
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XDCOCT:	DO
::	FUNCTION:	DECIMAL TO OCTAL
::
::*********************************************************************

XDCOCT	HS	0
	JAL	R9,DECHEX		:CONVERT DECIMAL TO HEX		###OAS
	J	DHXBAD			:(immed) BAD RADIX		###OAS
	JAL	R9,HEXOCT		:(+4) CONVERT HEX TO OCTAL	###OAS
	JAL	R9,TYPHW
	J	XRCRLF,,
	EI	:(XRSZLV-2)		:##AL

	SUBTTL	XRAY (Miscellaneous - CO, PM, PA)

	IF	(XRSZLV)		:##AL
::*********************************************************************
::
::	COMMAND:	XCROPT:	CO
::	FUNCTION:	SELECTS CRASH RESPONSE
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl

XCROPT	HS	0
	LR	R2,R2
	JEFS	XCROP1			:NO ARGS, DISPLAY CURRENT MODE
	LH	R2,XPOWER,XD		:IF CHANGING, MUST HAVE POWER	###TZ
	JG	XPWERR,,		:NOPE, NOT AUTHORIZED		###TZ
	NHI	R3,303
	STH	R3,CRACTN,,
XCROP1	LB	R3,CRACTN,,
	SLLS	R3,3
	LA	R2,XCROPM,R3
	JAL	R7,TYPASC
	JAL	R7,TYP2SP
	LB	R3,CRACTN+1,,
	SLLS	R3,3
	LA	R2,XCROPM,R3
	JAL	R7,TYPASC
	J	XRCRLF,,
	SLLS	R3,3			:FORM TWO-WORD INDEX
	LA	R2,XCROPM,R3		:GET CURRENT MODE
	JAL	R7,TYPASC
	J	XRCRLF,,

	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV)		:##AL

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	XRYPFM:	PM
::	FUNCTION:	PERFORMANCE MONITORING ROUTINE FOR USER CHANNELS
::	INPUT:		ACCEPTS A TERMINATING CHANNEL NUMBER
::
::*********************************************************************

:	SENDS 16 XLAXS AND TIMERS TOWARDS THE OTHER END, AND COMPUTES THE
:	AVERAGE ROUND-TRIP DELAY WHEN THE XLAX ACKS AND TIMER ACKS RETURN

	IF	2-XRYTMC	:###wjl

	NOLIST
XRYPM1	SC	/"0AROUND TRIP DELAY (MS)   TIMER : /
XRYPM2	SC	/  XLAX : /
XRYPM3	SC	/"0ABAD CHANNEL OR TIMEOUT"0D"0A/
	LIST

XRYPFM	HS	0
	CI	XD,TTYXD		:TEST FOR TTY OR ISIS-DDT USER
	JE	XRYPFS			:YES, ILLEGAL BECAUSE OF WCI-GCI RACE
	CLHI	R3,LNKZFL		:R3 IS CHAN NUMBER, CHECK RANGE
	JGE	XRYPFR			:ONLY LEGAL FOR TERMINATING CHANNELS
	LHL	R2,IOTAB,R3,R3		:GET BUFFER NUMBER
	JE	XRYPFR			:ERROR, NO CIRCUIT THERE
	NHI	R2,-4			:STRIP SPEED BITS

	LR	R13,R3			:SAVE CHANNEL NUMBER IN R13
	LHL	R5,BF,R2,		:GET CHANNEL ON OUT SIDE
	JAL	R8,CHNLNK		:RETURNS NEIGHBOR ON OUT CHANNEL
	J	XRYPFR			:IMMEDIATE RETURN--NO NEIGHBOR
	J	XRYPFR			:+4 RETURN--INTERNAL TERMINATION
:	+8 RETURN HAS NEIGHBOR NUMBER IN R3	####JHL
	CLHI	R3,400			:OCTAL 2000 IS LOWER BOUND FOR TII
	JL	XRYPF1			:T-I NEIGHBOR--RMK CAN'T HANDLE 03-PAIR

XRYPFE	HS	0			:##TZ
	LIS	R10,0			:ACCUMULATOR FOR TIMERS 	##TZ
	LIS	R11,0			:CLEAR R11 (ACCUMULATOR FOR XLAXS) 
	LIS	R14,0F			:DO 16 TIMES
XRYPFL	LIS	R0,0
:	XLAX'S AND TIMERS ARE SENT OUT IN PAIRS	##TZ
	ST	R0,ARRIVX,,		:CLEAR TIME-OF ARRIVAL CELLS
	ST	R0,ARRIVT,,		:CLEAR TIME-OF ARRIVAL CELLS

	LHL	R2,IOTAB,R13,R13	:GET BUFFER NUMBER
	JE	XRYPFR			:SOMETHING WRONG, NO CHANNEL
	NHI	R2,-4			:STRIP SPEED BITS
	L	R9,FASTC,,		:GET CURRENT TIME

	LIS	R1,3			:FORM '03'
	JAL	R8,WCI,,		:TIMER, WRITE IN '03'
	LHI	R1,TIMER		:AND TIMER
	JAL	R8,WCI,,

XPFXLX	LHI	R1,XLAX			:XLAX, GET XLAX
	JAL	R8,WCD,,		: AND PREFIX IT IN
	LIS	R1,03
	JAL	R8,WCD,,		:PREFIX THE '03'

XRYPFC	STM	R9,XREGSV,XD		:SAVE REGISTERS
XRYPF2	JAL	R0,XRYYLD,,		:AND YIELD TO EXEC LOOP
	L	R9,XREGSV,XD		:RECOVER TIME OF ORIGINAL STARTUP
	L	R3,ARRIVT,,		:HAS A TIMER ACK RETURNED?
	JNFS	XRYPFA			:YES, GO PROCESS DATA
	L	R3,FASTC,,		:NO, HAVE WE TIMED OUT?
	SR	R3,R9			:COMPUTE DELTA TIME SINCE STARTUP
	CLHI	R3,12C0			:ALLOW APPROX 8 SECONDS PER TRIP###OAS
	JG	XRYPFR			:ERROR, TIMED OUT
	J	XRYPF2			:STILL TICKING, DISMISS AND RETRY
XRYPFA	HS	0
	L	R3,ARRIVX,,		:WE GOT TIMER ACK,BETTER HAVE XLACK##TZ
	JE	XRYPFR			:SOMETHINGS WRONG		###TZ
	LM	R10,XREGSV+4,XD		:RECOVER REGISTERS
	SR	R3,R9			:GET TRAVEL TIME XLAX
	AR	R11,R3			:ACCUMULATE IN R11
	L	R3,ARRIVT,,		:TIMER ACK TIME			##TZ
	SR	R3,R9			:TRAVEL TIME TIMER		##TZ
	AR	R10,R3			:ACCUM TIMER TIME IN R10	##TZ
	SIS	R14,1			:DO THIS 16 TIMES
	JGE	XRYPFL			:MORE LEFT

	LA	R2,XRYPM1		:DONE FOR BOTH TIMER AND XLAX
	JAL	R7,TYPASC		:HEADER
	LHI	R12,$A10
	LR	R2,R10			:GET TIMER (IN R10) TIME	##TZ
	DHR	R2,R12			:AVERAGE AND GO DECIMAL...	##TZ
	JAL	R9,TYPHWD
	LA	R2,XRYPM2		:HEADER
	JAL	R7,TYPASC
	LR	R2,R11			:GET XLAX TIME (IN R11)
	DHR	R2,R12			:AVERAGE AND GO DECIMAL		##TZ
	JAL	R9,TYPHWD		:DISPLAY
	J	XRCRLF,,		:RETURN TO LOOP

XRYPFR	LA	R2,XRYPM3
	JAL	R7,TYPASC		:TYPE ERROR MESSAGE OUT
	J	XRCRLF,,

XRYPFS	LA	R2,XPFMNO		:ERROR
	JAL	R7,TYPASC
	J	XRCRLF,,

XRYPF1	LA	R2,XRYPFT		:GET PTR TO ERROR STRING	###JHL
	JAL	R7,TYPASC		:OUTPUT THE STRING TO XRAY USER
	J	XRCRLF,,		:AND LEAVE XRAY 

	NOLIST
XPFMNO	SC	/"07ILLEGAL FROM DDT OR TTY!/
XRYPFT	SC	/"0ASORRY.  FIRST NEIGHBOR IS T-I NODE./
	LIST

	EI	:2-XRYTMC ###wjl
	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	XPATCH:	PA
::	FUNCTION:	??
::
::*********************************************************************

	IF	1-ISIS
PHPATC	EQ	0A0000+40+SVC1FV
XPATCH	SVC	0F,SV.SR4
	LA	R10,PHPATC-NACARD*8,,
	LHI	R5,NACARD*4
	JAL	R8,TYPNHW
	J	XPRMPT,,

	ELSE	:NOT (1-ISIS)
XPATCH	J	XPRMPT,,
	EI	:1-ISIS

	SUBTTL	XRAY (UPSW trace option - TR, TT)

	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl

::*********************************************************************
::
::	COMMAND:	XTRACE:	TR
::	FUNCTION:	TURNS UPSW TRACER OFF (IF NO ARGUMENTS)
::			OR ON (FOR RANGE ARG1 - ARG2).  IF ARG1=ARG2=0,
::			TRACE IS ON FOR ALL OF MEMORY.
::
::*********************************************************************

XTRACE	HS	0
	LR	R2,R2			:ANY ARGUMENTS?
	JG	XTRAC0			:YES

					:REQUEST TO TURN TRACER OFF
	LH	R1,TRCRRQ,,		:IS TRACER ON?
	JL	XTROFF			:YES, GO TURN IT OFF

	JALMAC(TYPASI)			:TRACER NOT ON...
	SC	/TRACER NOT ON/		:...COMPLAIN
	J	COMERR,,

XTRAC0	HS	0			:REQUEST TO TURN ON TRACER
	LH	R1,TRCRRQ,,		:IS TRACER ON?
	JGE	XTRON			:NO, GO TURN IT ON

	JALMAC(TYPASI)			:TRACER ALREADY ON...
	SC	/TRACER ALREADY ON/
	J	COMERR,,

XTRON	HS	0		:VALIDATE REQUEST TO TURN SPECIAL TRACER ON
	SIS	R2,4			:ONE ARGUMENT?
	JE	XTRON0			:YES, OK

	SIS	R2,4			:MORE THAN 2 ARGUMENTS?
	JE	XTRON1			:NO, OK

	JALMAC(TYPASI)			:TOO MANY ARG'S...
	SC	/TOO MANY ARG'S/	:...COMPLAIN
	J	COMERR,,

XTRON0	HS	0			:ONLY 1 ARG
	LI	R5,0DFFFE		:DEFAULT UPPER LIMIT
	JFS	XTRON2

XTRON1	HS	0			:VALIDATE 2 ARGUMENTS
	L	R5,VALUE1+4,XD		:2ND ARGUMENT
XTRON2	HS	0			:2ND ARGUMENT IS IN R5
	L	R3,VALUE1,XD		:GET 1ST ARGUMENT
	CR	R3,R5			:R3 MUST BE < R5
	JL	XTRON3

	JALMAC(TYPASI)			:1ST ARG >= 2ND ARG...
	SC	/RANGE ERROR/		:...COMPLAIN
	J	COMERR,,

XTRON3	HS	0			:R3= LOWER LIMIT, R5= UPPER LIMIT
	ST	R3,TRCBEG,,		:SET TRACER LOWER LIMIT
	JALMAC(TYPASI)	
	SC	/TRACER ON FOR RANGE: /
	JAL	R9,TYPFW		:LOWER LIMIT
	LR	R3,R5			:GET UPPER LIMIT TO R3
	ST	R3,TRCEND,,		:SET TRACER UPPER LIMIT
	JAL	R9,TYPFW		:AND TYPE IT

	LHL	R1,EXEPSW+2,,		:GET CURRENT STATE OF TRACER BIT IN PSW
	STH	R1,EXPSSV,,		:SAVE IT
	LHI	R1,1000			:TURN TRACER ON NEXT EXEC LOOP TOP...
	STH	R1,EXEPSW+2,,		:...AND...
	STH	R1,TRCRRQ,,		:...FORCE TRACER OFF FOR NOW (TRCRRQ>0)
:	CLEAR TRACER TABLE
	LA	R1,TRCTAB,,		:DESTINATION ADDRESS FOR HCLEAR
	LHI	R2,TRTBSZ/2		:HW SIZE OF TRACER TABLE
	JAL	R8,HCLEAR,,		:CLEAR IT
	STH	R0,TRNDEX,,		:SET TRACER INDEX TO 0
	TS	TRCRRQ,,		:TELL TRACER SPECIAL REQUEST
	J	XPRMPT,,		:DONE

XTROFF	HS	0			:TURN SPECIAL TRACER OFF
	LIS	R3,1			:FORCE TRACER OFF...
	STH	R3,TRCRRQ,,		:... UNCONDITIONALLY
	JALMAC(TYPASI)
	SC	/TRACER INDEX: /	:HEADER INFORMATION
	LHL	R3,TRNDEX,,		:GET THE INDEX
	JAL	R9,TYPHW		:TYPE IT
	JALMAC(TYPASI)
	SC	/RANGE: /		:RANGE
	L	R3,TRCBEG,,		:RANGE LOWER LIMIT
	JAL	R9,TYPFW
	L	R3,TRCEND,,		:UPPER LIMIT
	JAL	R9,TYPFW
	JALMAC(TYPCRL)			:TYPE CR/LF

:	COPY CONTENTS OF TRACER TABLE TO SAVE AREA
	LA	R0,TRCTAB+(TRTBSZ-2),,	:ADDRESS OF LAST SOURCE HW
	LA	R1,TRSTAB+(TRTBSZ-2),,	:ADDRESS OF LAST DESTINATION HW
	LHI	R2,(TRTBSZ/2-1)*10	:AMOUNT TO COPY
	COPY	R0,R2			:COPY IT

:	RESTORE ORIGINAL STATE OF TRACE BIT AND ENABLE NORMAL TRACER
	LIS	R0,0
	STH	R0,TRCRRQ,,		:LET TRACER GO
	LHL	R0,EXPSSV,,		:GET ORIGINAL STATE OF TRACE BIT
	STH	R0,EXEPSW+2,,		:RESTORE
:	OUTPUT TRACER TABLE
	LIS	R0,8			:SET UP FOR TYPE0
	STH	R0,ARGCT,XD		:ARG COUNT = 2
	LA	R0,TRSTAB,,		:START ADDRESS
	ST	R0,VALUE1,XD		:1ST ARG
	LHI	R0,TRTBSZ		:NO. OF BYTES
	ST	R0,VALUE1+4,XD		:2ND ARGUMENT
	JAL	R12,TYPE0,,		:PRINT OUT THE TRACER TABLE
	J	XPRMPT,,

::*********************************************************************
::
::	COMMAND:	TYPTRC:	TT
::	FUNCTION:	WITH NO ARGUMENT:  IDENTICAL TO R C0800,100
::			WITH 1 ARGUMENT :  TYPES OUT THE LAST N JUMP ADDRESSES
::
::*********************************************************************

TYPTRC	HS	0
	LI	R0,TRSTAB
	LR	R2,R2			:ZERO ARGS?
	JNFS	TYPTR1			:NO
	ST	R0,VALUE1,XD
	LHI	R0,TRTBSZ
	ST	R0,VALUE1+4,XD
	JFS	TYPTR2
TYPTR1	L	R1,VALUE1,XD		:NUMBER OF JUMPS TO DISPLAY
	SLLS	R1,1			:TWO BYTES PER ENTRY
	ST	R1,VALUE1+4,XD		:STORE IN COUNT FIELD
	SR	R0,R1
	AHI	R0,TRTBSZ		:STARTING ADDRESS
	ST	R0,VALUE1,XD
TYPTR2	LIS	R0,8
	STH	R0,ARGCT,XD
	J	TYPE,,

	EI	:DB.TRC

	SUBTTL	XRAY (CPU utilization - CU)

	IF	2-XRYTMC	:###wjl
	IF	DB.CPU

::*********************************************************************
::
::	COMMAND:	XCPUT:	CU
::	FUNCTION:	MONITOR CPU UTILIZATION
::
::*********************************************************************

	GL	CPUTTT,CPUTTC

XCPUT	HS	0
	LH	R0,CPUTFL,,		:MAKE SURE IT ISN'T RUNNING
	JGE	XCPUT0			:NOT RUNNING, OK

	JALMAC(TYPASI)			:OUTPUT FOLLOWING MESSAGE
	SC	/"0D"0ACPUTIL RUNNING/
	J	XPRMPT,,		:AND BACK TO USER

XCPUT0	HS	0
	LR	R2,R2			:ARG CNT = 0?
	JG	XCPSET			:SET UP

	L	R3,CPUTIN,,		:SEE IF THERE'S ANY DATA TO DISPLAY
	JGFS	XCPDIS			:YES, CONTINUE

	JALMAC(TYPASI)			:OUTPUT FOLLOWING MESSAGE
	SC	/"0D"0ANO DATA/
	J	XPRMPT,,

XCPDIS	HS	0
	JALMAC(TYPASI)
	SC	/"0D"0ACPU UTILIZATION STATISTICS:/
	JALMAC(TYPASI)
	SC	/"0D"0AFASTC INTERVAL - ACTUAL: /
	JAL	R9,TYPHW		:INTERVAL
	JALMAC(TYPASI)
	SC	/REQUESTED: /
	LHL	R3,CPUNRQ,,		:INTERVAL REQUESTED
	JAL	R9,TYPHW
	IF	ISIS
	IF	DB.CLK
	JALMAC(TYPASI)
	SC	/SLOT0 TIME: /
	LHL	R3,CPUTII,,		:GET SLOT0 INTERVAL TIME
	JAL	R9,TYPHW
	EI	:DB.CLK
	EI	:ISIS
	IF	SUPER
	JALMAC(TYPASI)
	SC	/"0D"0ASUPERVISOR CHARACTER COUNT  TO SUP: /
	L	R3,SUICCT,,		:GET SUPIN CHARACTER COUNT
	JAL	R9,TYPFW
	JALMAC(TYPASI)
	SC	/ FROM SUP: /
	L	R3,SUOCCT,,		:GET SUPOUT CHARACTER COUNT
	JAL	R9,TYPFW
	EI	:SUPER
	JALMAC(TYPASI)
	IF	DSPTRC
	SC	/"0D"0APROCESS TIME COUNT  NODSP/
	ELSE	:DSPTRC
	SC	/"0D"0APROCESS TIME COUNT/
	EI	:DSPTRC
	LIS	R12,0			:LABEL TABLE INDEX
	LIS	R11,0			:DATA TABLE INDEX
	STH	R11,CPUTTT,,		:CLEAR TOTAL FASTC		###OAS
	STH	R11,CPUTTC,,		:CLEAR TOTAL DISMISS COUNT	###OAS
	IF	DSPTRC
	GL	CPUTND
	STH	R11,CPUTND,,		:CLEAR TOTAL 'FAKE' DISMISS COUNT###OAS
	EI	:DSPTRC
XCPDI2	HS	0
	JAL	R7,TYPCRL		:DOWN A LINE
	LA	R2,CPUTLB,R12,		:ROUTINE NAME
	LB	R0,0,R2			:LENGTH
	JE	XCPDI3			:DONE WITH INDIVIDUAL ROUTINES
	JAL	R7,TYPAS1		:PRINT IT
	JALMAC(TYPASI)
	SC	/: /
	LHL	R3,CPUTTB,R11,		:TIME
	AHM	R3,CPUTTT,,		:TOTAL TIME
	JAL	R9,TYPHW		:PRINT TIME
	LHL	R3,CPUTTB+CPTBCT,R11,	:COUNT
	AHM	R3,CPUTTC,,		:TOTAL COUNT
	JAL	R9,TYPHW		:PRINT IT
	IF	DSPTRC
	LHL	R3,CPUTTB+CPTBHW,R11,	:'FAKE' DISMISS COUNT		###OAS
	AHM	R3,CPUTND,,		:TOTAL 'FAKE' DISMISS COUNT	###OAS
	JAL	R9,TYPHW		:PRINT IT
	EI	:DSPTRC
	AIS	R12,7			:INCR POINTER INTO CPUTLB
	AIS	R11,CPUTSZ
	CLHI	R11,CPUTNE*CPUTSZ	:DONE?
	JL	XCPDI2			:NO, CONTINUE
XCPDI3	HS	0
	JALMAC(TYPASI)
	SC	/"0D"0ATOTALS: /
	LHL	R3,CPUTTT,,		:TOTAL TIME
	JAL	R9,TYPHW
	LHL	R3,CPUTTC,,		:TOTAL COUNT
	JAL	R9,TYPHW
	IF	DSPTRC
	LHL	R3,CPUTND,,		:TOTAL 'FAKE' DISMISS COUNT	###OAS
	JAL	R9,TYPHW
	EI	:DSPTRC

	IF	ISIS
	JALMAC(TYPASI)
	SC	/"0D"0A"0ASYLVER: /
	IF	DB.CLK
	LHL	R3,CSYTTM,,		:GET SYLVER TIME
	JAL	R9,TYPHW
	EI	:DB.CLK
	LHL	R3,CSYTCT,,		:GET SYLVER DISMISS COUNT
	JAL	R9,TYPHW
	EI	:ISIS
	JALMAC(TYPASI)			:###OAS
	IF	ISIS
	IF	DSPTRC
	IF	DB.CLK
	SC	/"0D"0A"0ADISPATCH TOP OF X EXECTIME SYLFORCD COUNT-NODSP"0D"0A/ :###OAS
	ELSE	:DB.CLK
	SC	/"0D"0A"0ADISPATCH TOP OF X COUNT-NODSP"0D"0A/		:###OAS
	EI	:DB.CLK
	ELSE	:DSPTRC
	IF	DB.CLK
	SC	/"0D"0A"0ADISPATCH TOP OF X EXECTIME SYLFORCD"0D"0A/	:###OAS
	ELSE	:DB.CLK
	SC	/"0D"0A"0ADISPATCH TOP OF X"0D"0A/			:###OAS
	EI	:DB.CLK
	EI	:DSPTRC
	ELSE	:ISIS
	IF	DSPTRC
	IF	DB.CLK
	SC	/"0D"0A"0ADISPATCH TOP OF X EXECTIME COUNT-NODSP"0D"0A/	:###OAS
	ELSE	:DB.CLK
	SC	/"0D"0A"0ADISPATCH TOP OF X COUNT-NODSP"0D"0A/		:###OAS
	EI	:DB.CLK
	ELSE	:DSPTRC
	IF	DB.CLK
	SC	/"0D"0A"0ADISPATCH TOP OF X EXECTIME"0D"0A/		:###OAS
	ELSE	:DB.CLK
	SC	/"0D"0A"0ADISPATCH TOP OF X"0D"0A/			:###OAS
	EI	:DB.CLK
	EI	:DSPTRC
	EI	:ISIS
	L	R3,EXC1CT,,		:NO. OF DISPATCHES		###OAS
	JAL	R9,TYPFW		:				###OAS
	L	R3,EXC2CT,,		:NO. OF PASSES THRU TOP OF EXEC	###OAS
	JAL	R9,TYPFW		:				###OAS
	IF	DB.CLK
	LHL	R3,EXCTIM,,		:TIME IN EXEC PROCESSING	###OAS
	JAL	R9,TYPFW		:				###OAS
	IF	ISIS
	LHL	R3,CSYFRC,,		:GET SYLVER FORCED DISMISS COUNT
	JAL	R9,TYPFW
	EI	:ISIS
	EI	:DB.CLK
	IF	DSPTRC
	LHL	R3,CPUTTC,,		:COMPUTE TOTAL DISMISS COUNT	###OAS
	SH	R3,CPUTND,,		:MINUS TOTAL 'FAKE' DISMISS COUNT##OAS
	JAL	R9,TYPFW		:				###OAS
	EI	:DSPTRC
	J	XPRMPT,,

XCPSET	HS	0			:HERE TO INITIATE CPUTIL
	CLHI	R3,7			:REQUESTED INTERVAL (LOG2 SEC'S)
	JLE	XCPSE0			:OK, CONTINUE

	JALMAC(TYPASI)
	SC	/"0D"0AARGUMENT TOO LARGE/
	J	XPRMPT,,

XCPSE0	HS	0
	LA	R1,CPUTTB,,		:CLEAR CPUTIL TABLE
	LHI	R2,CPUTNE*3		:THIS MANY HW'S
	JAL	R8,HCLEAR,,		:SET TO 0
	IF	ISIS
	LIS	R1,0
	STH	R1,CSYTCT,,		:CLEAR SYLVER DISMISS COUNT
	IF	DB.CLK
	STH	R1,CSYTTM,,		:CLEAR SYLVER TIME 
	STH	R1,CSYFRC,,		:CLEAR SYLVER FORCED DISMISS COUNT
	EI	:DB.CLK
	EI	:ISIS
	IF	DSPTRC
	LIS	R1,0
	LA	R1,EXADR0,,		:CLEAR DISPATCH TRACE TABLE
	LHI	R2,EXTBLE/2		:LENGTH IN HW'S
	JAL	R8,HCLEAR,,		:SET TO 0
	LA	R1,EXCNT0,,		:CLEAR DISPATCH COUNT TABLE
	LHI	R2,EXTBLE/2		:LENGTH IN HW'S
	JAL	R8,HCLEAR,,		:SET TO 0
	EI	:DSPTRC

	TS	CPUTCD,,		:MARK CODE CELL OK TO USE
	STH	R3,CPUTRQ,,		:TELL EXEC TO START
	J	XPRMPT,,

	EI	:DB.CPU
	EI	:2-XRYTMC ###wjl

	SUBTTL	XRAY (Miscellaneous - SS, BS)

::*********************************************************************
::
::	COMMAND:	XSIOST:	SS
::	FUNCTION:	DISPLAY SIO LINE STATUS
::
::*********************************************************************

	IF	1-DB56KB
	IF	SILINS
	IF	HMICRO		:display four halfwords for HDLC MICRO
XSIOH1	SC	/"0D"0ALN        REG0            REG1      IDL CRC HDLC  A R I T Rx/
XSIOH2	SC	/"0D"0ANO  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 LIN ERR ABRT  1 C L C OVR"0D"0A/
	ELSE	:ENGINE		:display three halfwords for engine
XSIOH1	SC	/"0D"0ALN        REG0            REG1      IDL CRC HDLC  A R I T/
XSIOH2	SC	/"0D"0ANO  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 LIN ERR ABRT  1 C L C"0D"0A/
	EI	:HMICRO

XSIOST	HS	0
	LR	R2,R2			:zero args?
	JNFS	XSIO02			:no
	LHI	R12,SILINS		:counter
	LIS	R14,0			:relative SIO line number
	J	XSIO04
XSIO02	JAL	R9,DECHEX		:convert line number to hex
	J	DHXBAD			:(immed) here if error on conversion
	LR	R14,R3			:(+4) save line number
	CLHI	R14,NLINES
	JGE	COMERR,,		:too big to be a line number
	SHI	R14,NLINES-SILINS	:compute relative SIO line number
	JL	COMERR,,		:to small for SIO line
	SLLS	R14,4			:line number*10x
	LIS	R12,1			:counter
XSIO04	LA	R11,SIOSTT,,		:pointer to SIO status blocks
	LA	R2,XSIOH1
	JAL	R7,TYPASC		:type header 1
	LA	R2,XSIOH2
	JAL	R7,TYPASC		:type header 2

XSIOLN	LR	R3,R14
	SRLS	R3,4			:relative SIO line number
	AHI	R3,NLINES-SILINS	:compute absolute line number
	JAL	R9,TYPBYD		:display line number
	LHL	R3,SS.REG,R11,R14
	LHI	R4,10			:set up number of bits
	JAL	R9,TYPBIT		:display SIO read REGs 0 and 1
	LB	R3,SS.IDL,R11,R14
	JAL	R9,TYPBYT		:display idle line counter
	LB	R3,SS.CRC,R11,R14
	JAL	R9,TYPBYT		:display CRC error counter
	LHL	R3,SS.ABR,R11,R14
	SRLS	R3,4			:isolate HDLC abort counter
	JAL	R9,TYPHW		:display HDLC abort counter
	LHL	R3,SS.ABR,R11,R14
	SLLS	R3,0C			:shift bits 44-47 into position
	LIS	R4,4			:set up number of bits
	JAL	R9,TYPBIT		:display bits 44-47	
	IF	HMICRO			:HDLC MICRO-engine only
	LB	R3,SS.HM1,R11,R14
	JAL	R9,TYPBYT		:display receive overrrun counter
	EI	:HMICRO

	JAL	R7,TYPCRL		:CR-LF
	AHI	R14,10			:advance line pointer
	SIS	R12,1			:decrement counter
	JG	XSIOLN			:keep displaying
	J	XRCRLF,,		:return
	ELSE	:NO SILINS
XSIOST	LA	R2,BADCON,,
	JAL	R7,TYPASC		:TYPE OUT ERROR MESSAGE
	J	XRCRLF,,		:AND RETURN
	EI	:SILINS

	ELSE	:DB56KB			:OBSOLETE, FORCED OFF

X56KBM	SC	?"0D"0ATIME(1/2SEC)   ABORTS	CHKSUMS    STATUS"0D"0A"0A?
X56KBN	SC	/"0D"0ADATA PRESENT"0D"0A/
XSIOST	JAL	R9,DECHEX		:CONVERT LINE NUMBER TO HEC
	J	DHXBAD			:(immed) HERE IF ERROR ON CONVERSION
	LR	R10,R3			:(+4) SAVE LINE NUMBER
	SLLS	R3,1			:LINE * 2
	CLHI	R3,NLINES*2
	JGE	COMERR,,		:TOO BIG TO BE A LINE NUMBER
	CLHI	R3,SBASE
	JL	COMERR,,		:TO SMALL FOR SIO LINE
	TBT	R10,DBSHUT		:IS THERE DATA THERE?
	JEFS	X56KB9			:NO
	LA	R2,X56KBN
	JAL	R7,TYPASC		:YES, SAY SO
X56KB9	LA	R2,X56KBM		:TYPE HEADER
	JAL	R7,TYPASC
	LHL	R14,DEBPTR-SBASE,R3,	:POINTER TO DATA AREA FOR THIS LINE
	LIS	R12,0			:COUNTER
	LHL	R11,SIONDX,R14,		:INDEX INTO OLDEST ENTRY

X56K2	JAL	R7,TYP2SP
	LR	R3,R12
	JAL	R9,TYPBYD		:TIME INDEX
	LA	R2,ASCASP
	JAL	R7,TYPASC
	LHL	R3,ABORTS,R11,R14
	JAL	R9,TYPHWD		:DISPLAY HDLC ABORTS+IDLES
	LA	R2,ASC6SP,,
	JAL	R7,TYPASC
	LHL	R3,CKSUMS,R11,R14
	JAL	R9,TYPHWD		:DISPLAY CHECKSUMS
	LA	R2,ASC6SP,,
	JAL	R7,TYPASC
	LHL	R3,SSTATS,R11,R14
	JAL	R9,TYPBYT,,		:DISPLAY STATUS NIBBLE
	AIS	R12,1			:BUMP TIME INDEX
	JAL	R7,TYPCRL		:CR-LF
	AIS	R11,2			:ADVANCE
	NHI	R11,SKBSIZ
	CH	R11,SIONDX,R14,		:FULL CIRCLE?
	JN	X56K2			:NO,KEEP DISPLAYING
	RBT	R10,DBSHUT		:RE-ENABLE MONITORING
	J	XRCRLF,,

	EI	:1-DB56KB

::*********************************************************************
::
::	COMMAND:	XBUFLT:	BS
::	FUNCTION:	DISPLAYS HISTOGRAMS OF BUFFERLET USE
::	DATA DISPLAYED REPRESENTS BYTES IN ALLOCATED BUFFERLETS
::	IF TERMINATED WITH 'Z', CLEARS OUT HISTOGRAMS AND MAX COUNTER
::
::*********************************************************************

	IF	2-XRYTMC		:###wjl
	NOLIST
	IF	REBILD
XBUFH0	SC	/"0D"0ABUFFER STATUS (BYTES):/
XBUFH3	SC	/"0D"0A            TOTAL    TOTAL   HISTORY  HISTORY   TOTAL/
XBUFH4	SC	/"0D"0A   BUFFERS  IN USE    PEAK    IN USE    PEAK  AVAILABLE  ZAPS"0D"0A  /
	ELSE	:REBILD
XBUFH0	SC	/"0D"0ABUFFER STATUS (BYTES):"0D"0A    TOTAL   IN USE    PEAK   AVAILABLE  ZAPS"0D"0A  /
	EI	:REBILD

XBUFH1	SC	/"0A"0D"0ARANGE	COUNT(HEX)"0A"0D"0A/
	LIST
	EI	:2-XRYTMC ###wjl

:	SIX DIFFERENT DISPLAYS ARE POSSIBLE, DEPENDING UPON HOW MANY
:	BUFFERLETS THE NODE IS CONFIGURED FOR. THIS INFORMATION IS
:	CONTAINED IN THE VARIABLE 'ISCALE'

XBUFH2	HS	$A42			:ACTUAL DISPLAY DEFINED IN FIN FOR NAD

	IF	2-XRYTMC		:###wjl

XBUFLT	HS	0
	CLHI	R1,ASCZ			:DID USER CLOSE WITH 'Z'(x5A)?
	JE	XBUFLZ			:YES, GO INITIALIZE
	LA	R2,XBUFH0		:TYPE FIRST HEADERS		###OAS
	JAL	R7,TYPASC

	IF	REBILD

	LA	R2,XBUFH3		:TYPE FIRST HEADERS		###OAS
	JAL	R7,TYPASC
	LA	R2,XBUFH4		:TYPE FIRST HEADERS		###OAS
	JAL	R7,TYPASC


	EI	:REBILD

	LI	R3,NBFLE2		:CONFIGURED NUMBER OF BUFFERLET BYTES
	GL	NBFLE2
	LR	R10,R3			:SAVE
	JAL	R9,TYPFWD		:TYPE OUT CONFIGURED NUMBER OF BYTES
	L	R3,BFLTSV		:CURRENT COUNT
	SR	R10,R3			:GET NUMBER OF BYTES AVAILABLE
	JAL	R9,TYPFWD		:TYPE NUMBER OF BYTES CURRENTLY IN USE
	L	R3,BFLTMX
	JAL	R9,TYPFWD		:TYPE MAX NUMBER OF BYTES EVER IN USE

	IF	REBILD
	L	R3,HBFTSV		:GET CURRENT HISTORY BUFFER USAGE##OAS
	JAL	R9,TYPFWD
	L	R3,HBFTMX		:GET PEAK HISTORY BUFFER USAGE	###OAS
	JAL	R9,TYPFWD
	EI	:REBILD

	LR	R3,R10
	JAL	R9,TYPFWD		:TYPE NUMBER OF BYTES STORAGE LEFT
	JAL	R7,TYP2SP		:TYPE TWO SPACES
	LHL	R3,BZAPCT,,		:GET NUMBER OF BUFFER ZAPS TO DATE...
	JAL	R9,TYPHWD		:AND DISPLAY IN DECIMAL
	LA	R2,XBUFH1		:SECOND HEADER
	JAL	R7,TYPASC
	LIS	R10,0			:DO FOR 'NSTEPS' SAMPLES HISTOGRAM DATA
	LHI	R11,$A(8-1)*10		:FORM STARTING INDEX FOR HEADER
XBUFL2	L	R3,BFLTHG,R10,		:READ ONE DATA VALUD
	LA	R2,XBUFH2,R11		:GET APPROPRIATE HEADER
	JAL	R7,TYPASC		:TYPE TEXT
	JAL	R7,TYP2SP		:TYPE TWO SPACES
	JAL	R9,TYPFW		:AND HEX DATA
	JAL	R7,TYPCRL
	SIS	R11,0A			:GET NEXT HEADER
	AIS	R10,4
	CLHI	R10,(NSTEPS-1)*4	:DO FOR 'NSTEPS' VALUES
	GL	NSTEPS
	JLE	XBUFL2			:MORE LEFT
	J	XPRMPT,,		:###jhl

XBUFLZ	LIS	R0,0			:CLEAR ALL VALUES
	ST	R0,BFLTMX		:CLEAR TOTAL BUFFER USAGE
	STH	R0,BZAPCT,,

	IF	REBILD
	ST	R0,HBFTMX		:CLEAR HISTORY PEAK BUFFER USAGE###OAS
	EI	REBILD

	LHI	R10,$A4*15
XBFLE2	ST	R0,BFLTHG,R10,
	SIS	R10,4
	JGEBS	XBFLE2
	J	XPRMPT,,		:###jhl

	EI	:2-XRYTMC ###wjl

	SUBTTL	XRAY (Dump dispatcher rings - DR, DS)

::*********************************************************************
::
::	COMMANDS:	DRINGS:/DSRNGS:	DR/DS			###wjl
::	FUNCTION:	IRING/ORING DUMP ROUTINE
::	INTERPRETS THE ISIS MESSAGE TYPE AND DUMPS THE CONTENTS IN HEX
::	AND ASCII.  MAKES A GUESS AT THE FIRST MESSAGE IN THE RING.
::	'DR' DUMPS DISPATCHER RINGS, 'DS' DUMPS RINGS SAVED AFTER A CRASH.
::
::*********************************************************************

	IF	ISIS

::	IRING/ORING TRACE MESSAGES AND TABLES
:	-------------------------------------
SIAASC	AC	/0123456789ABCDEF/
M.I	SC	/I /
M.O	SC	/O /
XDRMS4	SC	/NDL/			:NEEDLE
XDRMS3	SC	/DTA/			:DATA
XDRASC	SC	/  *                */	:ASCII MESSAGE DUMP STORAGE

	BND	2
XDRECH	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
XDRVL	HC	0082,0000		:VARIABLE LENGTH MESSAGE FLAGS

::	ISIS CONTROL MESSAGES
:	---------------------
	BND	2
XDRICA	HS	0
	SC	/DET/		:DETACH MESSAGE TYPE
	SC	/ZAP/		:DISCONNECT MESSAGE
	SC	/NOS/		:APPLY BACK-PRESSURE (NO SEND)
	SC	/SND/		:RELEASE BACK-PRESSURE (SEND)
	SC	/ICM/		:FLUSH OUTPUT (GOBBLER)
	SC	/BKG/		:FLUSH INPUT (BACK GOBBLER)
	SC	/BLK/		:DATA LOST IN THIS DIRECTION (BLACK BALL)
	SC	/GRY/		:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	SC	/EDE/		:ENTER DEFERED ECHO MESSAGE
	SC	/LDE/		:LEAVE DEFERED ECHO MESSAGE
	SC	/ETM/		:ENTER TRANSPARENCY MODE
	SC	/LTM/		:LEAVE TRANSPARENCY MODE
	SC	/GB /		:GREEN BALL
	SC	/RB /		:RED BALL
	SC	/YB /		:YELLOW BALL
	SC	/OB /		:ORANGE BALL
	SC	/BRK/		:BREAK DETECTED
	SC	/HNG/		:HANG UP
	SC	/QTP/		:QUERY TERMINAL PARAMETER
	SC	/STP/		:SET TERMINAL PARAMETER
	SC	/PSN/		:PSEUDO NEEDLE
	SC	/NLC/		:NORMAL LOGON CHAR
	SC	/NLS/		:NORMAL LOGON STATUS
	SC	/LOF/		:LOG ON FAILURE
	SC	/NCC/		:NORMAL CIRCUIT COMPLETE
	SC	/ADA/		:ADDENDUM TO ACCOUNTING
	SC	/SHG/		:SUPER-HANG UP
	SC	/TLM/		:SET TRANSMIT LIMIT
	SC	/EBK/		:END OF BREAK
	SC	/ZAK/		:ZAP ACK
	SC	/EAO/		:ENTER ALTERNATE OUTPUT DEVICE MODE
	SC	/LAO/		:LEAVE ALTERNATE OUTPUT DEVICE MODE
	SC	/ZAR/		:ZAP WITH REASON
	SC	/SIX/		:START INTERFACE INFORMATION EXCHANGE
	SC	/TIX/		:TERMINATE INTERFACE INFORMATION EXCHANGE
	SC	/***/		:UNDEFINED TYPE

::	ISIS CONTROL MESSAGE LENGTHS
:	----------------------------
	BND	2
XDRILA	HS	0
	BC	3		:DETACH MESSAGE TYPE
	BC	3		:DISCONNECT MESSAGE
	BC	3		:APPLY BACK-PRESSURE (NO SEND)
	BC	3		:RELEASE BACK-PRESSURE (SEND)
	BC	3		:FLUSH OUTPUT (GOBBLER)
	BC	3		:FLUSH INPUT (BACK GOBBLER)
	BC	3		:DATA LOST IN THIS DIRECTION (BLACK BALL)
	BC	3		:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	BC	3		:ENTER DEFERED ECHO MESSAGE
	BC	3		:LEAVE DEFERED ECHO MESSAGE
	BC	3		:ENTER TRANSPARENCY MODE
	BC	3		:LEAVE TRANSPARENCY MODE
	BC	3		:GREEN BALL
	BC	3		:RED BALL
	BC	3		:YELLOW BALL
	BC	3		:ORANGE BALL
	BC	3		:BREAK DETECTED
	BC	3		:HANG UP
	BC	4		:QUERY TERMINAL PARAMETER
	BC	5		:SET TERMINAL PARAMETER
	BC	6		:PSEUDO NEEDLE
	BC	4		:NORMAL LOGON CHAR
	BC	4		:NORMAL LOGON STATUS
	BC	4		:LOG ON FAILURE
	BC	0A		:NORMAL CIRCUIT COMPLETE
	BC	8		:ADDENDUM TO ACCOUNTING
	BC	3		:SUPER-HANG UP
	BC	4		:SET TRANSMIT LIMIT
	BC	3		:END OF BREAK
	BC	3		:ZAP ACK
	BC	3		:ENTER ALTERNATE OUTPUT DEVICE MODE
	BC	3		:LEAVE ALTERNATE OUTPUT DEVICE MODE
	BC	4		:ZAP WITH REASON
	BC	3		:START INTERFACE INFORMATION EXCHANGE
	BC	3		:TERMINATE INTERFACE INFORMATION EXCHANGE

::	INTRANODE MESSAGES
:	-------------------
	BND	2
XDRICB	HS	0
	SC	/RQR/		:RESTART REQUEST
	SC	/RST/		:RESTART INTERFACE
	SC	/NTO/		:NODE HAS BEEN TAKEN OVER
	SC	/REP/		:REPORT TO SUPERVISOR'S LOG
	SC	/RHS/		:REPORT HOST STATUS (OBSOLETE)
	SC	/RAC/		:REPORT ACCOUNTING
	SC	/TIM/		:GMT TIME
	SC	/RNP/		:REQUEST FOR NORMAL PSEUDO NEEDLE
	SC	/RAP/		:REQUEST AUX PSEUDO-NEEDLE
	SC	/PSR/		:PSEUDO-NEEDLE REJECTED
	SC	/HPA/		:HOST PORT AVAILABILITY
	SC	/HNA/		:HOST NOT ACCEPTABLE
	SC	/RHC/		:REPORT HOST COST
	SC	/NSU/		:NO SUPERVISOR
	SC	/ODN/		:1-DOWN TEXT
	SC	/RAH/		:REPORT ALL HOSTS
	SC	/HSR/		:HOST STATUS REPORT
	SC	/***/		:UNDEFINED TYPE

::	INTRANODE MESSAGE LENGTHS
:	-------------------------
	BND	2
XDRILB	HS	0
	BC	3		:RESTART REQUEST
	BC	3		:RESTART INTERFACE
	BC	4		:NODE HAS BEEN TAKEN OVER
	BC	9		:REPORT TO SUPERVISOR'S LOG
	BC	0C		:REPORT HOST STATUS (OBSOLETE)
	BC	8		:REPORT ACCOUNTING
	BC	8		:GMT TIME
	BC	0B		:REQUEST FOR NORMAL PSEUDO NEEDLE
	BC	0E		:REQUEST AUX PSEUDO-NEEDLE
	BC	7		:PSEUDO-NEEDLE REJECTED
	BC	0A		:HOST PORT AVAILABILITY
	BC	07		:HOST NOT ACCEPTABLE
	BC	0A		:REPORT HOST COST
	BC	3		:NO SUPERVISOR
	BC	9		:1-DOWN TEXT
	BC	3		:REPORT ALL HOSTS
	BC	0E		:HOST STATUS REPORT
	BC	0

::	UTILITY SUBROUTINE:	XDTPUT
::	OUTPUT A BYTE AS 2 DIGITS
:	-------------------------
:	CALLING SEQ:	JAL	R11,XDTPUT
:	INPUT:		R5  = BYTE TO BE OUTPUT
:			R12 = BYTE COUNTER
:	PRESERVED:	R5
:	DESTROYED:	R0, R1, R2, R4, R7, R13
XDTPUT	HS	0
	LBR	R4,R5			:COPY IT
	LBR	R7,R5			:COPY AGAIN
	SRHLS	R4,4			:LEFT NIBBLE
	LB	R1,SIAASC,R4,		:CONVERT TO ASCII
	JAL	R13,XRYOUT		:PUT IT OUT
	NHI	R7,0F			:RIGHT NIBBLE
	LB	R1,SIAASC,R7,		:CONVERT TO ASCII
	JAL	R13,XRYOUT		:PUT IT OUT
	LBR	R0,R12			:GET BYTE COUNTER
	NHI	R0,1			:EVERY OTHER BYTE, PUT OUT EXTRA SPACE
	JER	R11			:IF EVEN
	LA	R2,ASC1SP		:GET SPACE
	JAL	R7,TYPASC		:PUT IT OUT
	JR	R11			:RETURN

::	ENTRY POINTS:	DSRNGS/DRINGS
::	DUMP I/O RINGS
:	--------------
NFMI	EQ	0			:OFFSET TO NEXT FILL MESSAGE INDEX
RING	EQ	4			:OFFSET TO THE RING ITSELF
RR	EQ	0E			:REGISTER FOR ADDRESS OF RING
RS	EQ	3			:REGISTER FOR RING SIZE
MAXINM	EQ	10			:MAX NUMBER OF INTRA NODE MESSAGE TYPES
L.ISCT	EQ	22			:MAX NUMBER OF ISIS CONTROL MESSAGE TPS

DSRNGS	HS	0			:ENTRY POINT FOR DS COMMAND
	LH	R0,DIRSAV,,		:INITED TO -1, IF NO CRASHES YET
	JL	COMERR,,		:RETURN WITH ??
	LA	R1,DIRSAV+DRSZ+2,,	:ADDRESS OF DIRSAVS END TO R1
	LA	R4,DORSAV+DRSZ+2,, 	:ADDRESS OF DORSAVS END TO R4
	JFS	XDR010
DRINGS	HS	0			:ENTRY POINT FOR DR COMMAND
	LA	R1,DIRING+DRSZ+2,, 	:ADDRESS OF DIRINGS END TO R1
	LA	R4,DORING+DRSZ+2,, 	:ADDRESS OF DORINGS END TO R4
XDR010	LA	R2,IRING+DRSZ+2,,  	:ADDRESS OF DESTINATION END TO R1+1
	LHI	R3,10*(DRSZ/2+1)   	:10*(NUMBER OF HW'S -1)
	COPY	R1,R3		   	:COPY IRING TO DATA STORAGE
	LA	R5,ORING+DRSZ+2,,  	:ADDRESS OF DESTINATION END TO R4+1
	LHI	R3,10*(DRSZ/2+1)   	:COUNTER FOR COPY INSTRUCTION
	COPY	R4,R3		   	:COPY ORING
XDR020	LA	RR,IRING,,		:HANDLE IRING
	LHI	RS,DRSZ 		:RING SIZE
	LIS	R7,0			:INIT COUNTER FOR EMPTY RING CHECK
	LH	R8,NFMI,RR		:GET CURRENT POINTER, USE OLDEST ENTRY
	JAL	R10,BEGMSG		:GUESS AT FIRST MESSAGE
	JAL	R7,TYPCRL,,		:TYPE CR/LF
	J	XDR0A4

XDR090	AIS	R8,3			:ROUND UP TO FULL WORD
	NHI	R8,-4			:AND I.E., NEXT MESSAGE
	CR	R8,RS			:TO END OF RING ??
	JLFS	XDR0A0			:JUMP IF NOT, ELSE
	SR	R8,RS			:FOLD TO START OF RING
XDR0A0	JAL	R7,TYPCRL,,		:CR LF
XDR0A1	CLH	R8,NFMI,RR		:CAUGHT UP ?
	JN	XDR0A4			:NOT YET
	CLI	RR,IRING		:SEE IF JUST FINISHED IRING
	JN	XDR0FF			:FINISHED!

	LA	RR,ORING,,		:GET SET TO DO ORING
	LHI	RS,DRSZ 		:RING SIZE
	LIS	R7,0			:REINITIALIZE COUNTER
	LH	R8,NFMI,RR		:USE OLDEST ENTRY
	JAL	R10,BEGMSG		:GUESS AT FIRST MESSAGE
:	J	XDR0A1		:GO DO IT bug if NFMI points to valid msg ###sdw

XDR0A4	CLI	RR,ORING		:IS THIS THE ORING?
	JEFS	XDR0A6			:JUMP IF SO, ELSE
	LA	R2,M.I	 		:OUTPUT "I "
	JFS	XDR0A8
XDR0A6	LA	R2,M.O	 		:OUTPUT "O "
XDR0A8	JAL	R7,TYPASC
	LB	R9,RING+2,R8,RR		:GET MESSAGE CODE
	LHL	R10,RING,R8,RR		:GET PORT #
	JE	XDR0C0			:IF INTRANODE MESSAGE
	LR	R9,R9			:CHECK FOR NEEDLE
	JE	XDR0F0			:IF SO
	CLHI	R9,9E			:DATA MESSAGE ??
	JL	XDR0B0			:IF SO
	SHI	R9,9E			:BIAS TO 0
	CLHI	R9,L.ISCT		:CHECK MAX MSG TYPE
	JLE	XDR0A9			:IF OK
	LHI	R9,L.ISCT+1		:GET "UNDEFINED" MESSAGE
XDR0A9	LA	R4,,R9,R9		:FOR INDEXING	
	LA	R2,XDRICA,R4,R4		:ASCII MESSAGE LABEL
	JAL	R7,TYPASC		:TYPE IT
	JAL	R10,XDRISB		:GO DUMP ISIS CONTROL MESSAGE
	J	XDR090			:GO TO NEXT MESSAGE
XDR0B0	LA	R2,XDRMS3,,		:"DATA" MESSAGE HEADER
	JAL	R7,TYPASC		:TYPE IT
	JAL	R10,XDRISA		:GO DUMP ISIS DATA MSG
	J	XDR090			:GO TO NEXT MESSAGE
XDR0C0	CLHI	R9,MAXINM		:CHECK MAX MSG TYPE
	JLE	XDR0C1			:IF OK
	LHI	R9,MAXINM+1		:GET "UNDEFINED" MESSAGE
XDR0C1	LA	R4,,R9,R9		:FOR INDEXING
	LA	R2,XDRICB,R4,R4 	:ASCII MESSAGE LABEL
	JAL	R7,TYPASC		:TYPE IT
	TBT	R9,XDRVL,,		:VARIABLE LENGTH MESSAGE ??
	JNFS	XDR0D0			:IF SO BECAUSE CAN'T HANDLE YET
	JAL	R10,XDRISC		:GO DUMP ISIS INTRANODE MESSAGE
	J	XDR090			:GO TO NEXT MESSAGE
XDR0D0	CLHI	R9,8			:AUX CIRCUIT REQUEST ??
	JN	XDR0E0			:MUST BE "1-DOWN"
	LA	R4,0A,R8		:STEP TO SIZE BYTE
	CR	R4,RS			:CHECK FOR WRAP AROUND
	JLFS	XDR0D4			:IF NOT
	SR	R4,RS			:IF SO
XDR0D4	LB	R6,RING,RR,R4		:GET VARIABLE STRING SIZE
	AIS	R6,0B			:ADD CONSTANT PORTION
	LA	R2,ASC1SP		:INSERT A SPACE
	JAL	R7,TYPASC		:TYPE IT
	JAL	R10,XDRISE		:TO PUT OUT MESSAGE
	J	XDR090
XDR0E0	LA	R4,5,R8			:STEP TO 1-DOWN STRING SIZE
	CLHI	R4,RS			:CHECK FOR WRAP AROUND
	JLFS	XDR0E4			:IF NOT
	SHI	R4,RS			:IF SO
XDR0E4	LB	R6,RING,RR,R4		:GET VARIABLE MESSAGE SIZE
	AIS	R6,6			:ADD FIXED MESSAGE LENGTH
	LA	R2,ASC1SP		:INSERT A SPACE
	JAL	R7,TYPASC
	JAL	R10,XDRISE		:TO PUT OUT MESSAGE
	J	XDR090			:TO CONTINUD
XDR0F0	LA	R2,XDRMS4,,		:NEEDLE MESSAGE
	JAL	R7,TYPASC		:TYPE IT
	LB	R6,RING+3,R8,RR		:GET ADDITIONAL LENGTH
	AIS	R6,4			:ADD FIXED PORTION
	LA	R2,ASC1SP		:INSERT A BLANK
	JAL	R7,TYPASC		:PUT IT OUT
	JAL	R10,XDRISE		:TO PUT REST OF MESSAGE
	J	XDR090

XDR0FF	J	XRCRLF,,		:RETURN WITH CR/LF

::	SUBROUTINE:	BEGMSG
::	GUESS AT FIRST MESSAGE IN RING
:	------------------------------
:	CALLING SEQ:	JAL	R10,BEGMSG
:	INPUT:		R3  = RS = RING SIZE
:			R7  = COUNTER
:			R8  = CURRENT POINTER
BEGMSG  NHI     R8,-4
        J       BEG010                  :make sure start on even boundary

BEG000	AIS	R8,4			:BUMP POINTER
	AIS	R7,4			:BUMP POINTER
	CR	R7,RS			:SEE IF GONE AROUND RING COMPLETELY
	JGE	XDR0FF			:WE HAVE!  JUMP TO CR/LF
	CR	R8,RS			:SEE IF AT END OF RING
	JLFS	BEG010			:IF NOT
	LIS	R8,0			:START FRESH
BEG010	HS	0
	LB	R9,RING,R8,RR		:GET BYTE
	JN	BEG000			:IF NOT ZERO
        LB      R9,RING+1,R8,RR         :VALID DPORT?
        CLHI    R9,NDP                  :MAXIMUM DPORT
        JG      BEG000
BEG050	L	R9,RING,R8,RR		:IS WHOLE WORD NONZERO?
	JNR	R10			:IF SO, SHOULD DO FOR A GUESS!
	J	BEG000			:TEST NEXT WORD 

::	SUBROUTINES:	XDRISA/XDRISB/XDRISC/XDRISE
::	DUMP A MESSAGE
:	--------------
:	LINKS:	R10
:	INPUT:	R8 - RING INDEX
:		R9 - MSG CODE TYPE
:		RS - RING SIZE
:		RR - RING START
:	DATA MESSAGE
XDRISA	HS	0
	LA	R6,3,R9			:MESSAGE LENGTH=MESSAGE TYPE+3
	LA	R2,ASC1SP		:INSERT A SPACE
	JAL	R7,TYPASC		:LETS BE TIDY
	J	XDRISE
:	CONTROL MESSAGE
XDRISB	HS	0
	LB	R6,XDRILA,R9,		:MESSAGE LENGTH FROM TABLE
	LA	R2,ASC1SP		:INSERT A SPACE
	JAL	R7,TYPASC
	J	XDRISE
:	INTRANODE MESSAGE TYPE
XDRISC	HS	0
	LB	R6,XDRILB,R9,		:MESSAGE LENGTH FROM TABLE
	LA	R2,ASC1SP		:INSERT A SPACE
	JAL	R7,TYPASC
	JFS	XDRISE

XDRISD	LA	R2,XDRASC,,		:ASCII EQUIVALENT OF LINE
	JAL	R7,TYPASC
	JAL	R7,TYPCRL,,		:NEW LINE
	LA	R2,ASC6SP,,		:6 BLANKS FOR ALIGNMENT
	JAL	R7,TYPASC
XDRISE	LIS	R12,0			:LINE LENGTH COUNTER
XDRISF	LB	R5,RING,R8,RR		:NEXT BYTE FROM RING
	LHI	R0,ASCSPC		:DEFAULT BLANK CHARACTER
	TBT	R5,XDRECH,,		:PRINTABLE ??
	JEFS	XDRISH			:IF NOT, USE BLANK
	LR	R0,R5			:ELSE IF OK TO PRINT IT
XDRISH	LR	R4,R12			:COMPUTE WHERE TO PLUG INTO LINE
	NHI	R4,0F			:16 BYTES PER LINE
	STB	R0,XDRASC+4,R4,,	:PUT 'ER THERE FOR ASCII OUTPUT LATER
	JAL	R11,XDTPUT,,		:PUT IT OUT IN HEX NOW
	AIS	R8,1			:BUMP RING INDEX
	CR	R8,RS			:END OF RING ??
	JLFS	XDRISG			:IF NOT
	SR	R8,RS			:FOLD TO RING START
XDRISG	AIS	R12,1			:LINE LENGTH
	CLH	R8,NFMI,RR		:SEE IF AT RING POINTER
	JE	XDRISI			:IF SO GET OUT
	SIS	R6,1			:CHECK FOR END OF MSG
	JLE	XDRISI			:FINISH BLANKING AND PRINT	
	THI	R12,0F			:END OF LINE
	JE	XDRISD			:IF SO
	THI	R12,1			:END OF HALFWORD
	JN	XDRISF			:IF NOT TO CONTINUE
	LA	R2,ASC1SP		:ADD A SPACE
	JAL	R7,TYPASC		:TO FORMAT WORDS
	J	XDRISF
XDRISI	LHI	R0,ASCSPC		:BLANK
XDRISJ	NHI	R12,0F			:LINE LENGTH OF 16
	JEFS	XDRISK			:IF TO END OF LINE
	STB	R0,XDRASC+4,R12,,	:PUT IN A BLANK
	AIS	R12,1			:COUNT ON UP
	JBS	XDRISJ			:AND SEE IF DONE
XDRISK	LA	R2,XDRASC,,		:PUT IT OUT
	JAL	R7,TYPASC
	JR	R10			:DONE

	EI	:ISIS
	EI	:(XRSZLV-2)		:##AL

	SUBTTL	XRAY (Busy port - BP)

	IF	2-XRYTMC		:###wjl
	IF	SCBSYO
	IF	SOLOCS

::*********************************************************************
::
::	COMMAND:	XBSYPT:/XBSYDS:	BP/QB
::	FUNCTION:	Routine to control busy-port array.
::	INPUT:		BP <hex port #> [0 (off), 1 (on)]
::			BP with no args displays current BUSY.H array
::			QB also displays current BUSY.H array
::
::*********************************************************************

:	Use of bit arrays is as follows:
:		BUSY.C	set for ports needing attention in initialization
:		BUSY.A	set for ports needing attention next run of A.BUSY
:		BUSY.H	shows state of RTS desired for port getting attention

XBSYPT	HS	0
	LR	R2,R2
	JE	XBSYDS			:just show the bit arrays for now
	CLHI	R2,8			:2 args--port # and on or off
	JN	COMERR,,
	L	R3,VALUE1,XD		:get arg in octal
	JAL	R9,OCTHXR,,		:convert to hex in R3
	CLHI	R3,NAPORT		:range check on the port number
	JGE	COMERR,,
	LR	R2,R3			:keep port number in R2
	SBT	R2,BUSY.A,,		:we want attention from 4 sec logic
	L	R3,VALUE1+4,XD		:this is 0 for unbusy, 1 for busy
	JEFS	XBSY10
	SBT	R2,BUSY.H,,		:let's busy the port
	SBT	R2,BUSY.C,,		:set bit to busy it if reinit or crash
	JFS	XBSYDS
XBSY10	RBT	R2,BUSY.H,,		:unbusy the port
	RBT	R2,BUSY.C,,		:turn off attention if reinit
:	This is a problem if we reinit in the next four seconds.
:	It would be a lot smarter to call that routine A.BUSY when we
:	init and when this command is issued, rather than every four
:	seconds.  Fix this. ###jhl
:	ENTRY POINT FOR QB COMMAND 
XBSYDS	HS	0
	LIS	R5,0			:index into the bit array
XBSYD4	LHL	R3,BUSY.H,R5,		:get the bits for this group
	JAL	R9,TYPHW		:output 16 bits worth
	AIS	R5,2
	CLHI	R5,NAGRP*2		:check for running off end
	JLBS	XBSYD4			:loop to get all ports
	J	XRCRLF,,		:otherwise, we're finished

	EI	:SOLOCS
	EI	:SCBSYO
	EI	:2-XRYTMC ###wjl

	SUBTTL	XRAY (Utility routines)

::*********************************************************************
::
::	SUBROUTINE:	FSTMSC:
::	FUNCTION:	CONVERT FASTC TO MILLISECONDS
::	CALLING SEQ:	JAL	R9,FSTMSC
::	INPUT:		R2  = FASTC VALUE
::	OUTPUT:		R3  = RETURNED MILLISECOND VALUE 
::	DESTROYED:	R0
::
::*********************************************************************

FSTMSC	HS	0
	LR	R0,R2
	SLLS	R0,2
	AR	R2,R0			:MULTIPLY R2 BY 5
	LIS	R0,3
	DHR	R2,R0			:AND DIVIDE BY 3 ( I.E., BY 1000/600)
	SIS	R2,1			:R2 IS REMAINDER (0,1 OR 2)
	JLER	R9			:0 OR 1, LEAVE RESULT ALONE
	AIS	R3,1			:REMAINDER = 2, ROUND UP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	XFNDLK:
::	FUNCTION:	LIKE FNDLNK, BUT STORES KN AND KD IN THE XKNSAV
::	AND XKDSAV FIELDS OF THE REMOTE XRAY USER BLOCK.
::	CALLING SEQ:	JAL	R9,XFNDLK
::	INPUT:		R1  = NEIGHBOR NUMBER
::	NOTE:		R11 IS USED AS KN OR KX (KD) THROUGHOUT	XRAY.
::	RETURNS:	IMMEDIATE = NOT FOUND
::			+4 = FOUND
::
::*********************************************************************

XFNDLK	HS	0
	ST	R9,XFNDSV,,		:SAVE RETURN
	LHI	R11,NLINKS-1		:HIGHEST LINK#
XFNDL1	SLL	R11,1
	L	R9,KDKN,R11,R11		:LINK DESC.
	SRL	R11,1
	CLH	R1,NDID,R9		:THIS IT?
	JEFS	XFNDL2			:YES
	SIS	R11,1			:NO, TRY AGAIN
	JGEBS	XFNDL1
	ST	R11,XKDSAV,XD		:LINK DESC<0
	STH	R11,XKNSAV,XD		:KN=-1
	L	R9,XFNDSV,,		:RECOVER RETURN
	JR	R9			:STRAIGHT RETURN
XFNDL2	ST	R9,XKDSAV,XD		:FOUND KD
	STH	R11,XKNSAV,XD		:AND KN
	L	R9,XFNDSV,,		:RECOVER RETURN
	J	4,R9			:SKIP RETURN

::*********************************************************************
::
::	SUBROUTINE:	CHNLNK:
::	FUNCTION:	FINDS THE NEIGHBOR CONNECTED TO A CHANNEL
::	CALLING SEQ:	JAL	R8,CHNLNK
::	INPUT:		R5(CHN)	= CHANNEL
::	OUTPUT:		R3	= RETURNS NEIGHBOR NUMBER
::	DESTROYED:	R1, R9
::	RETURNS:	IMMEDIATE IF NO NEIGHBOR
::			+4 IF INTERNAL TERMINATION
::			+8 IF NEIGHBOR FOUND
::
::*********************************************************************

CHNLNK	HS	0
	LCS	R3,4
CHNLN1	AIS	R3,4
	CLH	CHN,CHNMAP,R3,		:CHNMAP ORGANIZED IN DESCENDING ORDER
	JLBS	CHNLN1			:CHN IS STILL TOO LOW
	LHL	R3,CHNMAP+2,R3,		:CHNMAP+2 IS POINTER TO NEIGHBOR NUMBER
	THI	R3,8000			:HOB SET MEANS INTERNAL TERMINATION
	JN	4,R8			:IT IS
	LHL	R3,CHNMPD,R3,		:IT ISN'T, LOOK UP NEIGHBOR
	THI	R3,8000			:IS IT A T-I NEIGHBOR?
	JEFS	CHNLN2			:NO, ITS A T-II
	NHI	R3,3FFF			:T-1, STRIP OUT THE 'C000'
	J	8,R8			:AND RETURN
	
CHNLN2	LR	R1,R3
	ST	R11,XRSAVE,XD
	JAL	R9,XFNDLK		:MAKE SURE THE NEIGHBOR IS THERE
	J	CHNLN3			:IT ISN'T, IMMEDIATE RETURN
	AIS	R8,8			:IT IS, +8 RETURN
CHNLN3	HS	0
	L	R11,XRSAVE,XD
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	COUNT0:/COUNT1:
::	FUNCTION:	COUNTS NUMBER OF 0'S/1'S IN A SERIES OF CONTIGIOUS HW
::	CALLING SEQ:	JAL	R9,COUNT0
::	INPUT:		R2  = HW COUNT
::			R4  = POINTER TO FIRST HW
::	OUTPUT:		R3  = RESULT
::	DESTROYED:	R0, R1
::
::*********************************************************************

COUNT1	HS	0
	LIS	R3,0			:SO XOR HAS NO EFFECT BELOW.
	JFS	COUNTD
COUNT0	HS	0
	LCS	R3,1			:TO INVERT BITS IN XOR BELOW.
COUNTD	STH	R3,CNTXOR,,
	LIS	R3,0			:CLEAR RESULT
	LR	R2,R2			:VERIFY NON-ZERO COUNT
	JER	R9			:ZERO COUNT, RETURN
COUNTA	LHL	R0,0,R4			:GET A HW
	XH	R0,CNTXOR,,		:COMPLEMENT (0'S) OR NOT (1'S)
COUNTB	JFFOH	R0,COUNTC		:FIND FIRST 1
	JFS	NOONE			:NO MORE ONES
COUNTC	AIS	R3,1			:INCREMENT COUNT IN R3
	XH	R0,HMSK,R1,R1		:COUNT EACH 1 ONLY ONCE
	JBS	COUNTB			:AND KEEP SEARCHING
NOONE	AIS	R4,2			:INCREMENT HW INDEX
	SIS	R2,1			:DECREMENT HW COUNT
	JGBS	COUNTA			:MORE HW, CONTINUE
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	RDSYMB:
::	FUNCTION:	READS UP TO 6 ASCII CHARACTERS INTO SYMASC+1
::	CALLING SEQ:	JAL	R10,RDSYMB
::	DESTROYED:	R1, R2
::
::*********************************************************************

RDSYMB	HS	0
	LI	R1,0A0A0A0		:INITIALIZE SYMASC TO SPACES
	ST	R1,SYMASC,,
	LI	R1,0A0A0A000
	ST	R1,SYMASC+4,,
	LIS	R2,1
RDSYM1	JAL	R13,XRYIN		:READ A CHAR
	OHI	R1,80			:SET HOB
	CLHI	R1,ASCSPC+80		:IF SPACE ASSUME USER IS DONE
	JER	R10
	CLHI	R1,ASCCR+80		:SAME FOR CR
	JER	R10
	CLHI	R1,ASCCOM+80		:SAME FOR COMMA			###wjl
	JER	R10			:				###wjl
	CLHI	R1,ASCNIN+80		:ASSUME A DIGIT			###wjl
	JLEFS	RDSYM2			:				###wjl
	NHI	R1,ASCUC		:ASSUME ALPHABETIC,ENSURE UPPERCASE,0DF
RDSYM2	STB	R1,SYMASC,R2,
	AIS	R2,1
	CLHI	R2,6
	JLE	RDSYM1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SYMVAL:
::	FUNCTION:	FINDS THE VALUE OF A SYMBOL IN THE SYMBOL TABLE
::	CALLING SEQ:	JAL	R10,SYMVAL
::	OUTPUT:		R3  = RETURNS THE VALUE
::	DESTROYED:	R2
::	RETURNS:	IMMEDIATE = NO MATCH
::			+4 = MATCH
::
::*********************************************************************

SYMVAL	HS	0
	LIS	R2,0			:init index into symbol table
SYMVA2	L	R3,SYMTBL,R2,		:read 3 chars of first symbol
	NI	R3,0FFFFFF		:mask to three chars worth
	C	R3,SYMASC,,		:is it what we're looking for?
	JN	SYMVA1			:not is first 3 chars
	L	R3,SYMTBL+4,R2,		:partial match.  Confirm rest.
	NHI	R3,0FF00		:mask off 4 lobs
	C	R3,SYMASC+4,,		:compare more
	JN	SYMVA1
	L	R3,SYMTBL+8,R2,		:etc. (this isn't clear to jhl)
	J	4,R10			:FOUND A MATCH, SKIP RETURN
SYMVA1	AHI	R2,ADRESZ		:NAD'S INADEQUACIES PREVENT USE OF AIS
	CLHI	R2,SYMTSZ
	JL	SYMVA2
	JR	R10			:NO MATCH, IMMEDIATE RETURN

::*********************************************************************
::
::	SUBROUTINE:	OCTHXR:
::	FUNCTION:	CONVERTS A VALUE IN R3 FROM OCTAL TO HEX
::	CALLING SEQ:	JAL	R9,OCTHXR
::	INPUT/OUPUT:	R3  = ARGUMENT AND RESULT
::	DESTROYED:	R0, R1
::
::*********************************************************************

OCTHXR	HS	0
	LR	R1,R3
	LR	R0,R3
	NHI	R1,7			:FIRST OCTAL DIGIT
	NHI	R3,70			:SECOND OCTAL DIGIT
	SRLS	R3,1
	AR	R1,R3
	LR	R3,R0
	NHI	R3,700			:THIRD OCTAL DIGIT
	SRLS	R3,2
	AR	R1,R3
	LR	R3,R0			:FOURTH OCTAL DIGIT
	NHI	R3,7000
	SRLS	R3,3
	AR	R1,R3 						  :###SHM
	LR	R3,R0						  :###SHM
	NI	R3,070000  		:FIFTH OCTAL DIGIT         ###SHM
	SRLS	R3,4						  :###SHM
	AR	R1,R3						  :###SHM
	LR	R3,R0						  :###SHM
	NI	R3,0700000              :SIXTH OCTAL DIGIT         ###SHM
	SRLS	R3,5						  :###SHM
	AR	R1,R3						  :###SHM
	LR	R3,R0						  :###SHM
	NI	R3,07000000             :SEVENTH OCTAL DIGIT	   ###SHM
	SRLS	R3,6						  :###SHM
	AR	R1,R3						  :###SHM
	LR	R3,R0						  :###SHM
	NI	R3,70000000             :EIGTH OCTAL DIGIT	   ###SHM
	SRLS	R3,7						  :###SHM
	AR	R3,R1						  :###SHM
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	OCTHEX:
::	FUNCTION:	CONVERTS A SERIES OF MEMORY LOCATIONS FROM OCTAL TO HEX
::	CALLING SEQ:	JAL	R9,OCTHEX
::	INPUT:		R0  = 2 X NUMBER OF HW TO BE CONVERTED
::			R1  = ADDRESS OF FIRST HW
::	DESTROYED:	R0, R1
::
::*********************************************************************

OCTHEX	HS	0
	ST	R2,XREGSV,XD		:SAVE REGS FOR PROGRAMMING CONVENIENCE
	ST	R3,XREGSV+4,XD
	ST	R4,XREGSV+8,XD
OCTHE1	LHL	R2,0,R1			:GET A HW
	LR	R4,R2
	NHI	R2,7			:FIRST OCTAL DIGIT
	LR	R3,R4
	NHI	R3,70			:SECOND OCTAL DIGIT
	SRLS	R3,1
	AR	R2,R3
	LR	R3,R4
	NHI	R3,700			:THIRD OCTAL DIGIT
	SRLS	R3,2
	AR	R2,R3
	LR	R3,R4			:FOURTH OCTAL DIGIT
	NHI	R3,7000
	SRLS	R3,3
	AR	R2,R3
	STH	R2,0,R1			:STORE RESULT
	SIS	R0,2
	JLEFS	OCTHE2			:ALL DONE
	AIS	R1,2			:GET NEXT VALUE
	J	OCTHE1			:AND REPEAT
OCTHE2	L	R2,XREGSV,XD		:RESTORE REGS
	L	R3,XREGSV+4,XD
	L	R4,XREGSV+8,XD
	JR	R9			:AND RETURN

::*********************************************************************
::
::	SUBROUTINE:	HEXOCT:
::	FUNCTION:	CONVERT VALUE FROM HEX TO OCTAL.
::	CALLING SEQ:	JAL	R9,HEXOCT
::	INPUT/OUTPUT:	CALLING ROUTINE PASSES HEX VALUE IN LOW-ORDER
::	2 BYTES OF R3 -- OCTAL VALUE RETURNED IN LOW-ORDER 3 BYTES OF R3.
::	HEX VALUES OF FFF OR LESS RESULT IN OCTAL VALUE OF 7777 OR LESS,
::	AND CAN BE DISPLAYED BY HALFWORD DISPLAY ROUTINES. HEX VALUES
::	GREATER THAN FFF ARE FULLY DISPLAYED BY FULLWORD DISPLAY ROUTINES.
::	DESTROYED:	R1, R2
::
::*********************************************************************

HEXOCT	HS	0
	EXHR	R3,R3		:MOVE VALUE TO HIGH-ORDER HALFWORD. WE CONVERT
	LIS	R1,4		:TO OCTAL BY DOING A SERIES OF 3-BIT SHIFTS AND
HEXOC2	SRLS	R3,3		: ZERO-BIT INSERTS. EACH TRI-BIT FIELD CONVERTS
	SRHLS	R3,1		: TO A QUAD-BIT FIELD WITH A HIGH-ORDER ZERO.
	SIS	R1,1
	JGBS	HEXOC2			:GET 4 OCTAL NIBBLES IN LOW-ORDER HW
	LR	R2,R3
	SRLS	R2,3			:CONVERT NEXT OCTAL NIBBLE
	SRHLS	R2,1
	SRLS	R2,0C			:SHIFT OUT LEFT-OVER AND
	EXHR	R2,R2			:	ALIGN HIGH-ORDER 2 NIBBLES,
	NHI	R3,7FFF			:	ISOLATE LOW-ORDER 4 NIBBLES,
	OR	R3,R2			:	AND COMBINE.
	JR	R9			:DONE - OCTAL VALUE IN R3

::*********************************************************************
::
::	SUBROUTINE:	DECHEX:
::	FUNCTION:	DECIMAL TO HEX CONVERSION ROUTINE
::	CALLING SEQ:	JAL	R9,DECHEX
::	INPUT/OUTPUT:	HALF-WORD ARGUMENT PASSED AND RETURNED IN R3
::	DESTROYED:	R0-R4
::	RETURNS:	DIRECT RETURN IF RADIX VIOLATION
::			+4 SKIP RETURN IF OK
::
::*********************************************************************

DHXTBL	HC	$A 1
	HC	$A 10
	HC	$A 100
	HC	$A 1000

DECHEX	HS	0
	NI	R3,0FFFF		:KEEP ONLY L-O HW
	LIS	R1,6			:LOOP INDEX
	LR	R2,R3			:SAVE OFF ARGUMENT
	LIS	R3,0			:CLEAR RESULT
	EXHR	R2,R2			:MOVE ARGUMENT TO HO HW
DECHE1	LHL	R0,DHXTBL,R1		:GET POWER OF 10
	RLL	R2,4			:ISOLATE TOP NIBBLE
	LHR	R4,R2			:MOVE IT TO R4
	CLHI	R4,9			:CHECK FOR RADIX VIOLATION	###wjl
	JGR	R9			:YES, IMMEDIATE RETURN
	MHR	R4,R0			:MULTIPLY BY POWER OF 10
	AR	R3,R4			:ACCUMULATE RESULT
	NHI	R2,0FFF0		:STRIP OFF NIBBLE
	SIS	R1,2			:DECREMENT LOOP INDEX
	JGEBS	DECHE1	
	J	4,R9			:DONE
DHXBAD	LA	R2,BADRDX,,
	JAL	R7,TYPASC		:ERROR CONDITION
	J	XRCRLF,,		:###jhl

::*********************************************************************
::
::	SUBROUTINE:	HEXDEC:
::	FUNCTION:	CONVERT VALUE FROM HEX TO DECIMAL.
::	CALLING SEQ:	JAL	R9,HEXDEC
::	INPUT/OUTPUT:	Calling Routine Passes Hex Value in R3 -- Decimal
::				value returned in R3.
::	NOTE:  Maximum Value convertable is 99999999d (5F5E0FF HEX).
::	DESTROYED:	R0 - R4
::
::*********************************************************************

HEXDEC	HS	0
	LIS	R0,$A10			: Divisor for Radix Conversion
	LR	R2,R3			: copy (HEX) value
	LIS	R3,0			: Clear decimal accumulator
	LIS	R4,7			: 8 loops, once for each digit/nibble
HEXDC2	LIS	R1,0			: extend operand to 64-bits
	DR	R1,R0
	OR	R3,R1			: accumulate remainder as new digit
	RRL	R3,4			: make room for next digit
	SIS	R4,1			: (aligned after 8 loops)
	JGEBS	HEXDC2
	JR	R9			: RETURN WITH DECIMAL VALUE IN R3

::*********************************************************************
::
::	SUBROUTINE:	DECPER:
::	FUNCTION:	COMPUTE AND DISPLAY DECIMAL PERCENTAGE OF
::	PASSED VALUES AS:	A/B=NN%
::	WHERE A IS PASSED IN R3, B IS PASSED IN R4, AND NN IS A DECIMAL
::	VALUE. THE VALUE IS DISPLAYED FOLLOWED BY A '%'.
::	CALLING SEQ:	JAL	R9,DECPER
::	DESTROYED:	R0, R2
::	CALLS:	 	HEXDEC, TYPBYT, AND TYPASC
::
::*********************************************************************

DECPER	HS	0
	ST	R9,DPRSAV,XD		:SAVE RETURN LINK
	LHI	R0,$A100
	MR	R2,R0			:MULTIPLY DIVIDEND BY 100
	LR	R4,R4	
	JLEFS	DECPR1			:NO DIVIDE BY ZERO...
	DR	R2,R4			:(A/B), QUOTIENT IN R3
	JFS	DECPR2
DECPR1	LIS	R3,0			:DIVIDE BY ZERO, GIVE ZERO RESULT
DECPR2	JAL	R9,HEXDEC		:CONVERT TO DECIMAL AND
	JAL	R9,TYPBYT		:	DISPLAY
	LA	R2,ASCPCT,,
	JAL	R7,TYPASC		:DISPLAY PERCENT SIGN (%)
	L	R9,DPRSAV,XD
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	RDCOMD:
::	FUNCTION:	READS A TWO-CHARACTER COMMAND 
::	CALLING SEQ:	JAL	R9,RDCOMD
::	OUTPUT:		R0  = RETURNS COMMAND
::			R1  = RETURNS LAST CHARACTER TYPED
::
::*********************************************************************

RDCOMD	HS	0
	LIS	R0,0
	STH	R0,ARGCT,XD		:ZERO OUT ARGUMENT COUNT
XCMSPC	JAL	R13,XRYIN		:GET FIRST CHARACTER
	OHI	R1,80			:SET MSB
	CLHI	R1,ASCCR+80		:CARRIAGE RETURN?
	JE	XRCRLF,,		:YES, RETURN TO XLOOP WITH CR-LF###jhl 
	CLHI	R1,ASCLF+80		:HOW ABOUT LINE-FEED?
	JE	XRCRLF,,		:RETURN TO COMMAND LOOP
	CLHI	R1,ASCSPC+80		:LEADING SPACE?
	JE	XCMSPC			:YES, STRIP LEADING SPACES

	NHI	R1,ASCUC		:ASSUME ALPHABETIC,ENSURE UPPERCASE,0DF
	EXBR	R0,R1			:MOVE TO R0
	OHI	R0,ASCSPC+80		:SET SECOND CHAR TO SPACE
	JAL	R13,XRYIN		:GET SECOND BYTE
	OHI	R1,80			:SET MSB
	CLHI	R1,ASCCR+80		:CR?
	JER	R9			:YES,RETURN
	CLHI	R1,ASCCOM+80		:COMMA?
	JER	R9			:YES,RETURN
	CLHI	R1,ASCSPC+80		:SPACE?
	JER	R9			:YES,RETURN
	NHI	R1,ASCUC		:ASSUME ALPHABETIC,ENSURE UPPERCASE,0DF
	NHI	R0,0FF00		:STRIP SPACE
	OR	R0,R1			:AND MOVE TO R0
	JR	R9			:AND RETURN

::*********************************************************************
::
::	SUBROUTINE:	RDARGS:
::	FUNCTION:	READS A STRING OF ARGS UNTIL A <CR> IS TYPED OR
::	UNTIL ARGMAX/4 ARGS ARE ENTERED.  THE FW ARGS GO INTO VALUE1
::	AND 4*(# OF ARGS TYPED) GOES INTO 'ARGCT'.
::	CALLING SEQ:	JAL	R9,RDARGS
::	OUTPUT:		R1=RETURNS LAST NON-DIGIT TYPED
::			R2=RETURNS 4*(# OR ARGS TYPED)
::			R3=RETURNS LAST NUMBER TYPED
::	DESTROYED:	R4, R8
::
::*********************************************************************

RDARGS	HS	0
	LIS	R2,0			:CLEAR ARGUMENT COUNT
	STH	R2,ARGCT,XD
RDAR1	JAL	R8,RDEXP		:READ AN EXPRESSION
	LR	R4,R4
	JEFS	RDAR2			:NO DIGITS TYPED, PROCESS NON-DIGIT
	AIS	R2,4			:GOT A DIGIT, INC ARG COUNT
	STH	R2,ARGCT,XD
	ST	R3,VALUE1-4,2,XD	:SAVE ARG
RDAR2	CLHI	R1,ASCCR		:CR?
	JEFS	RDAR5			:YES
	CLHI	R1,ASCSPC		:SPACE?
	JEFS	RDAR4			:YES
	CLHI	R1,ASCCOM		:IS IT A COMMA?
	JNFS	RDAR5			:NO, RETURN
RDAR4	CLH	R2,ARGMAX,XD		:ARE WE AT THE MAX NO OF ARGS?
	JN	RDAR1			:NO,GO BACK FOR MORE
RDAR5	LHI	0D,$A8*4
	STH	0D,ARGMAX,XD		:FALL BACK TO 8 ARGS
	L	R3,VALUE1-4,R2,XD	:RECOVER R3 = LAST ARGUMENT ENTERED
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	RDEXP:
::	FUNCTION:	READ A NUMERICAL VALUE
::	CALLING SEQ:	JAL	R8,RDEXP
::	OUTPUT:		R1=LAST NON-DIGIT TYPED
::			R3=RETURNS NUMERICAL VALUE
::			R4=RETURNS COUNT OF DIGITS TYPED
::
::*********************************************************************

RDEXP	HS	0
	LIS	R4,0			:CLEAR COUNT AND VALUE
	LIS	R3,0
RDNU1	JAL	R7,RDHEX		:READ A DIGIT
	J	0,R8			:(immed) NON-DIGIT TYPED, RETURN
	AIS	R4,1			:(+4) INC COUNT
	SLLS	R3,4			:SHIFT IN DIGIT
	AR	R3,R1
	J	RDNU1

::*********************************************************************
::
::	SUBROUTINE:	RDHEX:
::	FUNCTION:	READ A SINGLE HEX DIGIT
::	CALLING SEQ:	JAL	R7,RDHEX
::	OUTPUT:		R1=RETURNS HEX DIGIT OR LAST CHAR TYPED IF NON-DIGIT
::	RETURNS:	IMMEDIATE RETURN IF NON-DIGIT TYPED
::			(+) SKIP RETURN IF DIGIT TYPED
::
::*********************************************************************

RDHEX	HS	0
	JAL	R13,XRYIN		:READ CHAR INTO R1
	NHI	R1,ASC7BT		:GOT A CHAR, CLEAR PARITY
	CLHI	R1,ASCZRO
	JLR	R7			:< 30, NOT A DIGIT
	CLHI	R1,ASCNIN
	JLEFS	RDHE1			:0 - 9
	CLHI	R1,ASCA
	JLR	R7			:< A, NOT A DIGIT
	NHI	R1,ASCAP		:ENSURE UPPERCASE(x5F)
	CLHI	R1,ASCF
	JGR	R7			:> F
	AIS	R1,9			:A - F, JUST ADD 9 AND TRUNCATE
RDHE1	NHI	R1,0F
	J	4,R7			:SKIP RETURN

::*********************************************************************
::
::	SUBROUTINE:	TYPHEX:
::	FUNCTION:	TYPE A SINGLE HEX DIGIT
::	CALLING SEQ:	JAL	R7,TYPHEX
::	INPUT:		R1=DIGIT
::
::*********************************************************************

TYPHEX	HS	0
	NHI	R1,0F			:TRUNCATE
	OHI	R1,30			:IF > 39, ADD 7
	CLHI	R1,ASCNIN
	JLEFS	TYPH10			:.+4
	AIS	R1,7
TYPH10	JAL	R13,XRYOUT
	JR	R7

::*********************************************************************
::
::	SUBROUTINE:	TYPHWD:
::	FUNCTION:	CONVERTS TO DECIMAL AND TYPES A HW
::	CALLING SEQ:	JAL	R9,TYPHWD
::	INPUT:		R3  = VALUE
::	DESTROYED:	R3
::	OTHER REGISTERS IDENTICAL TO TYPHW
::
::*********************************************************************

TYPHWD	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXDEC		:GO DECIMAL
	JAL	R9,TYPHW		:DISPLAY
	L	R9,XHDSAV,XD
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TYPHWO:
::	FUNCTION:	CONVERTS TO OCTAL AND TYPES A HW
::	CALLING SEQ:	JAL	R9,TYPHWO
::	INPUT:		R3  = VALUE
::	DESTROYED:	R3
::	OTHER REGISTERS IDENTICAL TO TYPHW
::
::*********************************************************************

TYPHWO	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXOCT		:GO OCTAL
	JAL	R9,TYPHW		:DISPLAY
	L	R9,XHDSAV,XD
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TYPFWD:
::	FUNCTION:	IDENTICAL TO TYPHWD FOR A FULL-WORD
::	CALLING SEQ:	JAL	R9,TYPFWD
::
::*********************************************************************

TYPFWD	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXDEC
	JAL	R9,TYPFW		:DISPLAY
	L	R9,XHDSAV,XD
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TYPFW:
::	FUNCTION:	TYPE 8 DIGITS FOLLOWED BY SPACES
::	CALLING SEQ:	JAL	 R9,TYPFW
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7
::
::*********************************************************************

TYPFW	HS	0
	LIS	R4,8			:init counter
	LR	R0,R3			:move R3 to work register
TYPF1	RLL	R0,4			:rotate four bits (hex digit's worth)
	LR	R1,R0			:and get it into R1 for TYPHEX
	JAL	R7,TYPHEX		:type out ASCII for a hex digit
	SIS	R4,1			:decrement the counter
	JGBS	TYPF1			:loop until zero
	LA	R2,ASC1SP,,		:get pointer to "space" string
	JAL	R7,TYPASC		:and output to user
	JR	R9			:return to caller

::*********************************************************************
::
::	TABLE:	  BCDTBL:
::	FUNCTION: HEX INDEX INTO BYTE TABLE RETURNS DECIMAL VALUE OF INDEX
::
::*********************************************************************

BCDTBL	HS	0
Q	EQ	0
	RE	$A10			:TEN'S
	RE	$A10			:ONE'S
	BC	Q
Q	EQ	Q+1
	ER				:ONE'S
Q	EQ	Q+6
	ER				:TEN'S

::*********************************************************************
::
::	SUBROUTINE:	GMTCAL:
::	FUNCTION:	GET THE CURRENT GMT FOR STORAGE OR DISPLAY.
::	CALLING SEQ:	JAL	R9,GMTCAL
::	OUTPUT:		R2 = 25 BITS OF HEX SEC'S SINCE START OF CURRENT YEAR
::			PLUS BITS 22-28 OF FASTC
::	DESTROYED:	R1,R3,R4
::
::*********************************************************************

	IF	1-ISIS
GMTPC1	JAL	R9,GMTCAL
	LIS	R0,0
	LA	R1,PCTEN3
	LPSWR	R0
	EI	:1-ISIS

GMTCAL	HS	0
	ST	R2,XYSAVE,,		:SAVE REGISTER 2
	L	R2,SLOWC,,		:GET CURRENT NODE TIME.
	LHL	R1,FASTC+2,,		:GET LO HW OF FASTC.
	LH	R3,GETGMT,,		:SEE IF WE'VE GOT GMT YET

	JNFS	GMTCA2			:RECEIVED GMT, NO NEED TO ADJUST###OAS
	S	R2,NODSLC,,		:NO GMT RECEIVED YET, ADJUST FROM SLOWC
					:AT TIME OF NSTART,SOFTWARE RESTART#OAS
	J	GMTCA1			:AND SKIP ADJUSTMENTS		###OAS

GMTCA2	LR	R3,R2			:SAVE IT IN CASE WE GO TO GMTUPD
	S	R2,GMTSLC,,		:SUBTRACT BASE NODE TIME
	A	R2,GMTHEX,,		:ADD BASE GMT TIME TO GET NO. SEC'S
					:	SINCE START OF CURRENT YEAR
	C	R2,CYRMAX,,		:PAST END OF CURRENT YEAR?
	JLE	GMTCA1			:NO, SKIP
GMTUPD	HS	0
	ST	R3,GMTSLC,,		:NEW BASE NODE TIME
	S	R2,CYRMAX,,		:HOW MUCH INTO NEW YEAR?
	AI	R2,$A24*3600		:EXTRA DAY'S WORTH TO NIX DAY 0
	LI	R3,$A366*24*3600	:# SECS IN NORMAL YEAR+1 DAY FOR CYRMAX
	LHL	R4,CYRCOD,,		:OLD CURRENT YEAR CODE
	AIS	R4,1			:BUMP IT 1
	NHI	R4,3			:MOD 4
	STH	R4,CYRCOD,,		:SAVE NEW CURRENT YEAR CODE
	JNFS	GMTUP1			:NOT LEAPYEAR, SKIP
	AI	R3,$A24*3600		:add day's sec's for leapyear
GMTUP1	ST	R3,CYRMAX,,		:NEW CURRENT YEAR MAX SEC'S
	ST	R2,GMTHEX,,		:NEW GMT BASE TIME

GMTCA1	SRLS	R1,3			:LOSE LO BITS OF FASTC
	NHI	R1,7F			:SAVE LO 7 BITS
	SLLS	R2,7			:ALIGN SEC'S AND
	OR	R2,R1			:COMBINE WITH FASTC INTO R2
	ST	R2,GMTNOW,,		:SAVE IT
	L	R2,XYSAVE,,		:RESTORE REGISTER2
	JR	R9			:RETURN FOR DEPOSIT

::*********************************************************************
::
::	SUBROUTINE:	GMTCNV:
::	FUNCTION:	CONVERTS GMT SEC'S+FASTC IN R2 INTO DDD:HH:MM:SS.FF
::			AND DISPLAYS IT.
::	CALLING SEQ:	JAL	R9,GMTCNV
::
::*********************************************************************

GMTCNV	HS	0	
	L	R2,GMTNOW,,		:GET TIME
GMTCNX	ST	R0,XRSAVE,XD		:SAVE REGISTER
	LR	R0,R2			:SAVE R2 TO GET FASTC LATER
	SRLS	R2,7			:STRIP FASTC BITS
	LI	R3,$A24*1800		:NO. SEC'S IN HALF DAY (FOR HW DIVIDE)
	DHR	R2,R3			:R3=NO. HALFDAYS ELAPSED, R2=NO. SEC'S
					:INTO CURRENT HALFDAY
	SRLS	R3,1			:R3=NO. DAYS ELAPSED
	JNCFS	GMTCN1			:NO CARRY, SKIP
	AI	R2,$A24*1800		:ADJUST R2 FOR HALFDAY CARRY
GMTCN1	CHI	R3,$A300		:DDD>=300?
	JLFS	GMTCN2			:NO, TRY 200
	LIS	R1,3			:HO DIGIT OF DDD
	JAL	R7,TYPHEX		:TYPE IT
	SHI	R3,$A300		:R3=0-66
	J	GMTCN4
GMTCN2	CHI	R3,$A200		:DDD>=200?
	JLFS	GMTCN3			:NO, TRY 100
	LIS	R1,2			:HO DIGIT OF DDD
	JAL	R7,TYPHEX		:TYPE IT
	SHI	R3,$A200		:R3=0-99
	J	GMTCN4
GMTCN3	CHI	R3,$A100		:DDD>=100?
	JLFS	GMTCN0			:NO, DDD<=99
	LIS	R1,1			:HO DIGIT OF DDD
	JAL	R7,TYPHEX		:TYPE IT
	SHI	R3,$A100		:R3=0-99
	JFS	GMTCN4
GMTCN0	LIS	R1,0			:HO DIGIT
	JAL	R7,TYPHEX
GMTCN4	LB	R4,BCDTBL,R3,		:GET DD IN DECIMAL
	SLL	R4,$A24			:R4=DD000000
	LHI	R3,$A60*60		:SEC'S IN HOUR
	DHR	R2,R3			:R2=SEC'S INTO CURRENT HOUR
					:R3=CURRENT HOUR
	LB	R3,BCDTBL,R3,		:HH INDECIMAL
	SLL	R3,$A16			:R3=00HH0000
	OR	R4,R3			:R3=DDHH0000
	LHI	R3,$A60			:SEC'S IN MINUTE
	DHR	R2,R3			:R3=CURRENT MIN, R2=CURRENT SEC
	LB	R3,BCDTBL,R3,		:R3=000000MM
	SLLS	R3,8			:R3=0000MM00
	OR	R4,R3			:R4=DDHHMM00
	LB	R3,BCDTBL,R2,		:R3=000000SS
	OR	R4,R3			:R4=DDHHMMSS

::*********************************************************************
::
::	SUBROUTINE:	TYPGMT:
::	FUNCTION:	TYPES DD:HH:MM:SS.FF FROM DDHHMMSS IN R4 
::			AND FF (7 BITS FASTC) IN R0
::	CALLING SEQ:	JAL	R9,TYPGMT
::
::*********************************************************************

TYPGMT	HS	0
	LIS	R3,3			:FOUR PAIRS OF DIGITS TO TYPE,
					: 3 FOLLOWED BY ':'
TYPGM2	LIS	R2,2			:TWO DIGITS PER PAIR
TYPGM1	RLL	R4,4			:NEXT DIGIT TO LO NIBBLE OF R4
	LR	R1,R4			:R1 PASSES DIGIT TO BE TYPED
	JAL	R7,TYPHEX		:TYPE DIGIT
	SIS	R2,1			:1 DIGIT DOWN
	JGBS	TYPGM1			:NEXT DIGIT IN PAIR IF MORE
	LBR	R3,R3			:ALL DONE WITH PAIRS?
	JEFS	TYPGM3			:DON'T TYPE ':' AFTER SS. GO TYPE .FF
	LHI	R1,3A			:ASCII ':'
	JAL	0D,XRYOUT		:TYPE IT
	SIS	R3,1			:A PAIR DOWN
	JBS	TYPGM2			:NEXT PAIR

TYPGM3	HS	0
	L	R0,XRSAVE,XD		:RESTORE REG
	JR	R9			:RETURN TO THE SOURCE

::*********************************************************************
::
::	SUBROUTINE:	TYPHW:
::	FUNCTION:	TYPE 4 DIGITS FOLLOWED BY SPACES
::	CALLING SEQ:	JAL	R9,TYPHW
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7
::
::*********************************************************************

ASCNUL	SC	//

TYPHWS	JAL	R7,TYP2SP		:TYPE 2 SPACES
	JFS	TYPHW
TYPHNS	LA	R2,ASCNUL
	JFS	TYPH2
TYPHW	LA	R2,ASC2SP,,
TYPH2	LIS	R4,4
	LR	R0,3
TYPH1	SLLS	R0,4
	EXHR	R1,0
	JAL	R7,TYPHEX
	SIS	R4,1
	JGBS	TYPH1
	JAL	R7,TYPASC
	JR	R9

::**************************************************************************
::
::	SUBROUTINE:	TYP5O
::	FUNCTION:	CONVERTS TO OCTAL AND TYPES FIVE DIGITS
::	CALLING SEQ:	JAL	R9,TYP5O
::	INPUT:		R3= ARGUMENT
::	DESTROYED:	R0,R1,R2,R3,R4,R7			###SHM
::	
::**************************************************************************
TYP5O	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK		
	JAL	R9,HEXOCT		:CONVERT TO HEX
	JAL	R9,TYP5CH		:TYPE FIVE CHARACTERS
	L	R9,XHDSAV,XD		:RESTORE LINK
	JR	R9			:RETURN
	

::***************************************************************
::
::    	SUBROUTINE:	TYP5CH:
::	FUNCTION:	TYPE FIVE DIGITS FOLLOWED BY TWO SPACES
::	CALL SEQ:	JAL R9,TYP5CH
::	INPUT:		R3= ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7
::
::***************************************************************

TYP5CH	HS	0			
	LA	R2,ASC2SP,,		:LOAD TWO SPACES          ###SHM
        LIS	R4,4			:LOAD CHARCOUNT-1         ###SHM
	LR	R0,R3			:LOAD ARGUMENT INTO R0    ###SHM
TYPCH1	EXHR	R1,R0			:LOAD FIRST DIGIT INTO LOWER
					:NIBBLE OF R1             ###SHM
	JAL	R7,TYPHEX		:TYPE DIGIT		  ###SHM
TYPCH2	SLLS	R0,4			:SHIFT IN NEXT DIGIT FROM LOWER
					:HALF WORD OF R0          ###SHM
	EXHR	R1,R0			:LOAD NEXT DIGIT INTO LOWER
					:NIBBLE OF R1		  ###SHM
	JAL	R7,TYPHEX		:TYPE DIGIT		  ###SHM
	SIS	R4,1			:DECREMENT R4             ###SHM
	JGBS	TYPCH2			:MORE DIGITS?		  ###SHM
	JAL	R7,TYPASC		:TYPE TWO SPACES	  ###SHM
	JR	R9			:RETURN TO CALLER         ###SHM

::**************************************************************************
::
::	SUBROUTINE:	TYP5DD:
::	FUNCTION:	CONVERTS A HALFWORD HEX TO DECIMAL AND DISPLAYS IT
::			IN 5-DIGIT FORMAT FOLLOWED BY 2 SPACES
::	CALLING SEQ:	JAL	R9,TYP5DD
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7,R13
::
::**************************************************************************

TYP5DD		ST	R9,XHDSAV,XD		:SAVE THE RETURN ADDR 	###CWC
		JAL	R9,HEXDEC		:TURN R3 TO DECIMAL	###CWC
		JAL	R9,TYP5CH		:DISPLAY 5 DIGITS	###CWC
		L	R9,XHDSAV,XD		:RETRIEVE RETURN ADDR	###CWC
		JR	R9			:RTS			###CWC


::*********************************************************************
::
::	SUBROUTINE:	TYPBYT:
::	FUNCTION:	TYPE 2 DIGITS FOLLOWED BY 2 SPACES
::	CALLING SEQ:	JAL	R9,TYPBYT
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R7
::
::*********************************************************************

TYPBYT	HS	0
	LA	R2,ASC2SP		:PREPARE TO DISPLAY 2 SPACES
TYPBY1	LR	R1,R3			:ENTRY POINT FOR TYPNBY ROUTINE
	SRLS	R1,4			:SLIDE FIRST HEX DIGIT TO LO NIBBLE
	JAL	R7,TYPHEX		:	AND DISPLAY
	LR	R1,R3
	JAL	R7,TYPHEX		:DISPLAY SECOND HEX DIGIT
	JAL	R7,TYPASC		:DISPLAY 2 SPACES
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TYPBYO:
::	FUNCTION:	CONVERT LO HW IN R3 TO OCTAL AND TYPE LO BYTE
::	CALLING SEQ:	JAL	R9,TYPBYO
::
::*********************************************************************

TYPBYO	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXOCT
	JAL	R9,TYPBYT
	L	R9,XHDSAV,XD
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	TYPBYD:
::	FUNCTION:	CONVERT LO HW IN R3 TO DECIMAL AND TYPE LO BYTE
::	CALLING SEQ:	JAL	R9,TYPBYD
::
::*********************************************************************

TYPBYD	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXDEC
	JAL	R9,TYPBYT
	L	R9,XHDSAV,XD
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	TYPNBY:
::	FUNCTION:	TYP N BYTES FOLLOWED BY 4 SPACES
::	CALLING SEQ:	JAL	R8,TYPNBY
::	INPUT:		R6  = ADDRESS OF FIRST BYTE
::			R5  = BYTE COUNT
::	DESTROYED:	R0,R1,R2,R3,R4,R7,R9
::
::*********************************************************************

TYPNBY	HS	0
	LIS	R4,0
TYPNB1	CR	R4,R5
	JER	R8			:DONE

	LB	R3,0,R6,R4		:GET A BYTE
	LA	R2,ASC4SP		:AND FOUR SPACES
	JAL	R9,TYPBY1		:AND TYPE IT
	AIS	R4,1			:INC INDEX
	JBS	TYPNB1			:AND LOOP

::*********************************************************************
::
::	SUBROUTINE:	TYPADD:
::	FUNCTION:	TYPE A 5-DIGIT ADDRESS FOLLOWED BY A ":"
::	CALLING SEQ:	JAL	R9,TYPADD
::	INPUT:		R3=ADDRESS
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R4,R7
::
::*********************************************************************

TYPADD	HS	0
	LIS	R4,5
	LR	R0,R3
TYPA1	EXHR	R1,R0
	JAL	R7,TYPHEX
	SLLS	R0,4
	SIS	R4,1
	JGBS	TYPA1
	LA	R2,ASCCLN
	JAL	R7,TYPASC		:TYPE ':'
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	TYPOCT:
::	FUNCTION:	TYPE 3 OCTAL DIGITS
::	CALLING SEQ:	JAL	R9,TYPOCT
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R4,R7
::
::*********************************************************************

TYPOCT	HS	0
	LIS	R4,3
	LR	R0,3
	SLLS	R0,7
TYPOC1	SLLS	R0,3
	EXHR	R1,R0
	NHI	R1,7
	JAL	R7,TYPHEX
	SIS	R4,1
	JGBS	TYPOC1
	LA	R2,ASC2SP
	JAL	R7,TYPASC
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	TYP8HW/TYP8HS/TYPNHW
::	ENTRY POINT:	TYP8HW:  TYPES 8 HW WITH 2 SPACES BETWEEN EACH
::			TYP8HS:  PRECEEDS FIRST HW WITH 4 SPACES
::			TYPNHW:  TYPES AS MANY HW AS COUNT IN R5
::	LINK:		R8
::	INPUT:		R10 = STARTING ADDRESS
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R6,R7,R9
::
::*********************************************************************

TYP8SV	WS	1			:LINK SAVE AREA FOR TYP8H

TYP8HD	ST	R8,TYP8SV
	LI	R8,TYPHWD		:DECIMAL DISPLAY
	JAL	R7,TYP4SP
	LIS	R5,8
	JFS	TYPNH1
TYP8HS	JAL	R7,TYP4SP
TYP8HW	LIS	R5,8
TYPNHW	ST	R8,TYP8SV		:SAVE LINK
	LI	R8,TYPHW		:HEX DISPLAY
TYPNH1	SIS	R5,1			:DONE?
	JLFS	TYP8H1			:YES
	LHL	R3,0,R10
	AIS	R10,2
	JALR	R9,R8			:TYPHW OR TYPHWD
	JBS	TYPNH1
TYP8H1	JAL	R7,TYPCRL
	L	R8,TYP8SV		:RESTORE LINK REG
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	TYPCRL/TYPLF
::	ENTRY POINT:	TYPCRL:  TYPES A CR-LF
::			TYPLF:   TYPES LINE FEED
::	LINK:		R7
::	DESTROYED:	R1
::
::*********************************************************************

TYPCRL	HS	0
	LIS	R1,0D
	JAL	R13,XRYOUT
TYPLF	HS	0
	LIS	R1,0A
	JAL	R13,XRYOUT
	JR	R7

::*********************************************************************
::
::	SUBROUTINE:	TYPBIT:
::	FUNCTION:	TYPES BIT ARRAY
::	CALLING SEQ:	JAL	R9,TYPBIT
::	INPUT:		R3 = HWD OF BIT ARRAY
::			R4 = NUMBER OF BITS TO TYPE
::	DESTROYED:	R0, R1, R2, R5
::
::*********************************************************************

TYPSAV	HS	1			:save area for HW of bit array

TYPBIT	HS	0			:				###wjl
	LIS	R5,0			:initialize pointer/counter
	STH	R3,TYPSAV		:store HW of bit array
TYPB02	TBT	R5,TYPSAV		:bit set??
	JNFS	TYPB04			:yes
	JAL	R7,TYP0			:no, type a 0
	JFS	TYPB06
TYPB04	JAL	R7,TYP1			:type a 1
TYPB06	AIS	R5,1			:increment pointer/counter
	CR	R5,R4			:finished??
	JL	TYPB02			:no
	JR	R9			:yes, return

::*********************************************************************
::
::	SUBROUTINE:	TYPASC:
::	ENTRY POINTS:	TYP2SP,TYP4SP,TYP8SP,TYPASP,TYPASC,TYPAS1
::	LINK:		R7
::	INPUT:		R2=PTR TO STRING
::	DESTROYED:	R0,R1
::
::*********************************************************************

ASCSAT	SC	/@-/			:SATELITE FLAG FOR "ND"		###OAS
ASCPCT	SC	/%"A0/
ASC0	SC	/0"A0/			:ASCII 0 for TYPBIT		###wjl
ASC1	SC	/1"A0/			:ASCII 1 for TYPBIT		###wjl
ASC1SP	SC	/"A0/
ASC2SP	SC	/"A0"A0/
ASC3SP	SC	/"A0"A0"A0/
ASC4SP	SC	/"A0"A0"A0"A0/
ASC8SP	SC	/"A0"A0"A0"A0"A0"A0"A0"A0/
ASCASP	SC	/"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0/
ASCCLN	SC	/:"A0"A0/
ASCRLF	SC	/"0D"0A/

:	TYP0:	TYPE AN ASCII 0						###wjl
TYP0	LA	R2,ASC0
	JFS	TYPASC

:	TYP1:	TYPE AN ASCII 1						###wjl
TYP1	LA	R2,ASC1
	JFS	TYPASC

:	TYP2SP:
TYP2SP	LA	R2,ASC2SP
	JFS	TYPASC

:	TYP4SP: TYPES 4 SPACES
TYP4SP	LA	R2,ASC4SP
	JFS	TYPASC

:	TYP8SP: TYPES 8 SPACES
TYP8SP	LA	R2,ASC8SP
	JFS	TYPASC

:	TYPASP: TYPES 10 SPACES
TYPASP	LA	R2,ASCASP		:FALL THRU TO TYPASC

:	TYPASC:	TYPE ASCII STRING
:	TYPAS1:	ALTERNATE ENTRY POINT HAS BYTE COUNT PASSED IN R0
TYPASC	HS	0
	LB	R0,0,R2			:BYTE COUNT
	JER	R7			:NULL LENGTH
TYPAS1	HS	0
	LB	R1,1,R2			:CHAR
	JAL	R13,XRYOUT
	AIS	R2,1
	SIS	R0,1
	JGBS	TYPAS1
	JR	R7

::*********************************************************************
::
::	SUBROUTINE:	TYPASI:
::	FUNCTION:	TYPE ASCII STRING IMMEDIATELY FOLLOWING CALL
::	LINKS ON:	R7 (WHICH ALSO POINTS TO BEGINNING OF STRING)
::	DESTROYED:	R0,R1
::
::*********************************************************************

TYPASI	HS	0
	LB	R2,0,R7			:LENGTH OF STRING
TYASI0	HS	0
	AIS	R7,1			:POINT TO NEXT CHAR
	LB	R1,0,R7			:GET THE CHAR
	JAL	R13,XRYOUT		:PUT IT OUT
	SIS	R2,1			:DECREMENT COUNT OF REMAINING CHAR'S
	JGBS	TYASI0			:MORE TO DO
	AIS	R7,2			:ADJUST RETURN TO NEXT HW
	NHI	R7,0FFFE		:...AS SO
	JR	R7			:RETURN TO INSTRUCTION FOLLOWING STRING

::*********************************************************************
::
::	SUBROUTINE:	XRYTST:
::	FUNCTION:	CHECK IF THERE IS ANY INPUT DATA FOR XRAY
::	CALLING SEQ:	JAL	R13,XRYTST
::	DESTROYED:	R0, R2
::	RETURNS:	IMMEDIATE = USER DATA
::			+2 = NO DATA
::*********************************************************************

XRYTST	HS	0
	CI	XD,TTYXD		:TTY USER?
	JE	XRYTS1			:TTY XRAY USER
	LHL	R0,XRYPTF,XD		:REMOTE USER. IS FILL POINTER EQUAL
	CLH	R0,XRYPTE,XD		:TO EMPTY POINTER?
	JE	2,R13			:YES, NO DATA. DO +2 RETURN
	JR	R13			:REMOTE USER DATA. IMMEDIATE RETURN

XRYTS1	HS	0
	IF	ISIS
	SVC	0A,0200			:ISIS SVC READS 1 CHAR INTO R2
	J	NODATA			:DIRECT RETURN IF NO DATA
	STH	R2,XINDDT,,		:GOT A CHAR, SAVE IT
        NHI     R2,7F                   :see if logout chars
        CLHI    R2,1A                   :control z?
        JE      XRISZP                  :yes zap
        CLHI    R2,18                   :control x?
        JE      XRISEX                  :yes exit to DDt
	JR	R13			:RETURN IMMEDIATE
NODATA	TS	XINDDT,,		:NO DATA...FLAG CELL AS EMPTY
	J	2,R13			:AND DO +2 RETURN
	ELSE	:NOT ISIS
	SVC	0F,SV.PTY		:SOLO SVC
	J	2,R13			:NO DATA, DO +2 RETURN
	JR	R13			:DATA, DO IMMEDIATE RETURN
	EI	:ISIS

::*********************************************************************
::
::	SUBROUTINE:	XRYIN:
::	FUNCTION:	READ A SINGLE CHARACTER FROM THE TTY OR
::			A NODE CODE BUFFER
::	XRYIN RETURNS WITH A CHARACTER IN R1. IF THERE IS NO DATA
::	AVAILABLE IT DISMISSES XRAY AND TRIES AGAIN WHEN RESCHEDULED
::
::*********************************************************************

::      Only echo chars which are printable (or move cursor in a known manner)
XRPABL  HC      0FE00                   :echo ^G thru ^O (^N ^O are shifts
        HC      -1,0,0,0,0,0,0          :for katakana/kanji)            ###sdw

XRYIN	HS	0
	STM	R0,XREGSV,XD		:SAVE ALL REGISTERS
XRYIN8	CI	XD,TTYXD		:TTY USER?
	JE	XRYIN1			:YES
	LHL	R4,XRYPTE,XD		:REMOTE, GET BUFFER EMPTY POINTER
	CLH	R4,XRYPTF,XD		:IS THERE DATA?
	JNFS	XRYIN9			:YES, GET IT
	JAL	R0,XRYDIS,,		:NO,DISMISS
	JBS	XRYIN8			:AND RETRY WHEN RESCHEDULED

XRYIN9	LB	R1,XRYBFI,R4,XD		:GET A CHARACTER
	NHI	R1,7F			:STRIP PARITY BIT
	LH	R2,EKOTYP,XD		:CHECK ECHO MODE
	JLFS	XRYIN2			:LOCAL ECHO, SKIP THE REST
        TBT     R1,XRPABL               :printable char?                ###sdw
        JNFS    XRYIN2                  :not nice to echo ^S or ESCs    ###sdw
	LHL	R2,XRYBFO,XD		:GET OUTBOUND BUFFER NUMBER
	JAL	R9,WCIE,,		:AND ECHO TO USER
XRYIN2	AIS	R4,1			:INCREMENT EMPTY POINTER
	NHI	R4,XBFSZE-1		:MOD THE BUFFER SIZE
	STH	R4,XRYPTE,XD		:AND STORE BACK

XRYIN6	L	R0,XREGSV,XD
	LM	R2,XREGSV+8,XD		:RECOVER REGISTERS
	JR	R13			:AND RETURN

XRYIN1	HS	0			:HERE IF XRAY IN TTY MODE
	IF	ISIS
	LH	R1,XINDDT,,		:IS THERE A CHAR IN THE XINDDT CELL?
	JLFS	XRYIN7			:NO
	TS	XINDDT,,		:YES, FLAG XINDDT AS BEEN READ
	J	XRYIN6			:AND RETURN WITH CHAR IN R1

XRYIN7	SVC	0A,0100			:DO A SVC TO READ A CHAR INTO R1
	J	XRYIN7			:NO DATA, DO MERCILESS LOOP
        LR      R0,R1                   :work reg (just in case someone cares)
        NHI     R0,7F
        CLHI    R0,1A                   :contro Z for tty (through ISIS DDT)
        JE      XRISZP                  :handle zap
        CLHI    R0,18                   :^X returns to ISIS DDT
        JE      XRISEX                  :goto xray isis exit
	J	XRYIN6			:GOT CHAR INTO R1, RETURN

	ELSE	:NOT ISIS
	SVC	0F,SV.RTY		:FOR SOLO DO NORMAL TTY SVC
	J	XRYIN3			:DISMISS IF THERE IS NO DATA
	J	XRYIN6			:RETURN IF DATA
XRYIN3	SVC	0F,SV.DSM		:dismiss to next context
	J	XRYIN8			:RETRY UPON RETURN
	EI	:ISIS

::*********************************************************************
::
::	SUBROUTINE:	XRYOUT:
::	FUNCTION:	CHARACTER OUTPUT UTILITY ROUTINE
::	IN REMOTE MODE (XRYTTY=1  OR ISIS), XRAY MAY WRITE INTO ITS
::	OUTBOUND BUFFER ONLY IF THERE ARE LESS THAN 100 CHARACTERS IN
::	IT.  ELSE, XRAY SCHEDULES ITSELF OFF THE HALF-SEC PROCESS
::	(XRYRUN = 1 ) AND DISMISSES TO THE EXEC LOOP. 	IN TTY MODE
::	(SOLO AND XRYTTY=0) THE OUTPUT GOES TO THE TTY ALONE 
::
::*********************************************************************

XRYOUT	HS	0
	STM	R0,XREGSV,XD		:SAVE ALL REGISTERS
XRYOU8	CI	XD,TTYXD		:TTY USER?
	JE	XRYOU1			:YES
	LHL	R2,XRYBFO,XD		:GET BUFFER NUMBER
	LHL	R0,BCT,R2,		:GET ESTIMATE OF BYTE COUNT
XRYSPD	CLHI	R0,$A160		:ARE WE AT OUR LIMIT?
	JLEFS	XRYOU3			:NO, WE MAY ADD ANOTHER CHARACTER
	JAL	R0,XRYYLD,,
	J	XRYOU8			:RETRY WHEN RESCHEDULED

XRYOU3	L	R1,XREGSV+4,XD		:CHARACTER TO BE WRITTEN
	JAL	R9,WCIE,,		:DEPOSIT INTO BUFFER
	IF	INTACC	:###EV
	LHL	R3,XUINTH,XD		:Get internal host port index
	JAL	R8,AARDO1,,		:Count one character
	EI	:INTACC	:###EV
	LM	R0,XREGSV,XD		:RECOVER ALL OUR REGISTERS
	JR	R13			:RETURN

XRYOU1	HS	0
	IF	ISIS
	STB	R1,XOUDDT+1,,		:SET UP CELL FOR DDT
	SVC	0B,XOUDDT,,
	ELSE	:NOT ISIS
	SVC	0F,SV.WTY		:OUTPUT TO TTY
	EI	:ISIS
	LM	R0,XREGSV,XD		:RECOVER RREGISTERS
	JR	R13			:AND RETURN

        IF      ISIS
XRISEX  JAL     R12,REMZAI,,            :remove traps and wahtever for dis one
        SVC     0D,1                    :return them to DDT
        J       XRAY,,                  :in case they hit P in ddt

XRISZP  JAL     R12,REMZAI,,            :prepare to zap them
        SVC     0D,0                    :disconnect them
        J       XPRMPT,,                :DDT type P comes here??
        EI  :ISIS

::*********************************************************************
::
::	EQUATES FOR CRYPTOGRAMS
::
::*********************************************************************

BH	EQ	TYPBYT-SEGD
BO	EQ	TYPBYO-SEGD
BD	EQ	TYPBYD-SEGD
HH	EQ	TYPHW-SEGD
HO	EQ	TYPHWO-SEGD
HD	EQ	TYPHWD-SEGD
O5	EQ	TYP5O-SEGD
D5	EQ	TYP5DD-SEGD		:				###CWC
	IF SOLOCS
	FO DATA
	EI

:	****END***

	ENDMO.(XRAY)
	EI	:1-KILLIT
	KILMSG(XRAY)

:	***NOTHING PAST THIS POINT***


 	SUBTTL	IIXRAY

:		*****  *****  *   *  ****     *   *   *
:		  *      *     * *   *   *   * *   * *
:		  *      *      *    ****   *****   *
:		  *      *     * *   *  *   *   *   *
:		*****  *****  *   *  *   *  *   *   *

:	*****************************************************************
:	|   >>T M C S / X R A Y  O P E R A T I O N S  M O N I T O R<<	|
:	*****************************************************************

	IF	XRYTMC			:###wjl

	IF	1-KILLIT		:assemble it??
	BEGMO.

	IF	SOLOCS
	LO	DATA
	EI	:SOLOCS

	SEG	0D

:**********************************************************************
:	XEQ### - IIXRAY EQUATES for XREF
:**********************************************************************

XEQ000	EQ	00			:80 with parity bit stripped
XEQ001	EQ	01			:81 with parity bit stripped
XEQ010	EQ	10			:90 with parity bit stripped
XEQ040	EQ	40			:C0 with parity bit stripped
XEQ076	EQ	76			:F6 with parity bit stripped
XEQ077	EQ	77			:F7 with parity bit stripped
XEQSIX	EQ	01F6			:SIIX message
XEQTIX	EQ	01F7			:TIIX message
XEQ080	EQ	80			:used for global IIX, MSB, etc
XEQ0C0	EQ	0C0			:used for dialect
XEQ081	EQ	81			:second byte of various msgs
XEQ082	EQ	82			:second byte of Response msg
XEQ083	EQ	83			:second byte of End Response
XEQ085	EQ	85			:second byte of Command Mode
XEQ086	EQ	86			:second byte of PIV msg
XEQ090	EQ	90			:second byte of NCD msg
XE0FFF	EQ	0FFF			:nibble stripper
XE7FFF	EQ	7FFF			:bit stripper

:**********************************************************************
:	ICMTBL - TMCS XRAY command table
:	DFIXC. macro defaults to not audited
:**********************************************************************

DFIXC.	MACRO(NAME,NUMB,AUDIT)[
	AC	/NUMB/
	HC	NAME-SEGD
	KILL	Q.
Q.`AUDIT EQ	0
	IF	\Q.
	HC	0
	ELSE
	HC	AUDIT
	EI
	]

IX.AUD	EQ	1			:audit type command

ICMTBL	WS	0			:COMMANDS AND THEIR ADRESSES
	DFIXC.(IXND,01)			:Display NODE Descriptor (ND)
	DFIXC.(IXNS,02)			:Display NODE Statistics (NS)
	DFIXC.(IXNSZ,03)		:Display NODE Reset statistics (NSZ)
	DFIXC.(IXBG,04)			:Display BAD-Guy list(BG)
	DFIXC.(IXWM1,08)		:Display XRAY Warning message (WM1)
	DFIXC.(IXTC,0C)			:Display CHANNEL Traced (TC)
	DFIXC.(IXBS,0D)			:Display Bufferlet Use Histograms (BS)
	DFIXC.(IXDC,0E)			:Display CRASH Tables (DC)
	DFIXC.(IXDCS,0F)		:Display CRASH Summary Table (DCS)
	DFIXC.(IXDCD,10)		:Display CRASH Detail Table (DCD)
	DFIXC.(IXCO,11)			:Display CRASH Options (CO)
	DFIXC.(IXKD,14)			:Display Link Descriptor (KD)
	DFIXC.(IXKS,15)			:Display Link Statistics (KS)
	DFIXC.(IXAC,1C)			:Display Active Channels (AC)
	DFIXC.(IXQC,1D)			:Display Channel Status (QC#)
	DFIXC.(IXQC2,1E)		:Display Range Channel Status (QC # #)
	DFIXC.(IXQC1U,1F)		:Display Active Channel Status (QC # U)
	DFIXC.(IXQC2U,20)		:Display Range Active Chan Stat (QC##U)
	DFIXC.(IXPM,21)			:Display Channel Performance (PM)
	DFIXC.(IXRD,22)			:Display Memory (R #)
	DFIXC.(IXRDC,23)		:Display Memory (R # #)
	DFIXC.(IXRS,26)			:Display Memory at <Symbol> (RS)
	DFIXC.(IXRSC,27)		:Display Memory at <Symbol> (RS #)
	DFIXC.(IXTD,28)			:Display Channel DATA Trace (TD,TE,TA)
	DFIXC.(IXTDC,29)		:Display LAST <count> DATA Trace (TD#)
	DFIXC.(IXTDI,2A)		:Display Input DATA Trace (TD I)
	DFIXC.(IXTDCI,2B)		:Display LAST <count> Input DATA Trace
	DFIXC.(IXTDO,2C)		:Display Output DATA Trace (TD O)
	DFIXC.(IXTDCO,2D)		:Display LAST <count> Output DATA Trace
	DFIXC.(IXCL,2E)			:Display CRYPTO Log (CL)
	DFIXC.(IXCLC,2F)		:Display Last <n> CRYPTO Messages (CL#)
	DFIXC.(IXCLH,30)		:Display Last <n> Hours CRYPTO Messages
	DFIXC.(IXCLM,31)		:Display Last <n> Minutes CRYPTO Msgs
	DFIXC.(IXCM,32)			:Display CRYPTO Messages by Type (CM)
	DFIXC.(IXDD,33)			:Display Delay Measurement Stats (DD)
	DFIXC.(IXDDX,34)		:Display Delay Measurement Stats <n>
	DFIXC.(IXBSZ,3F)		:Initialize Bufferlet Use Hstgrms (BSZ)
	DFIXC.(IXBZ,42,IX.AUD)		:BORI ZAP LINK (BZ)
	DFIXC.(IXTC1,46)		:Set Channel Trace (TC # 1)
	DFIXC.(IXSM1,48)		:Enable <type> CRYPTO Messages (SM#1)
	DFIXC.(IXBGI,49,IX.AUD)		:Set Neighbor# in BAD-Guy list (BGI)
	DFIXC.(IXWM0,4C)		:Clear Warning message (WM0)
	DFIXC.(IXDE,4D)			:Terminate Delay Measurement Circ (DE)
	DFIXC.(IXDEX,4E)		:Terminate Delay Measurement Circ <n>
	DFIXC.(IXTC0,4F)		:Clear Channel Trace (TC # 0)
	DFIXC.(IXKSZ,50)		:Clear Link Statistics (KS # Z)
	DFIXC.(IXSM0,51)		:Disable <type> CRYPTO Messages (SM#0)
	DFIXC.(IXBGR,52,IX.AUD)		:Clear Neighbor# in BAD-Guy list (BGR)
	DFIXC.(IXDL,53)			:Build Data Loopback Circuit (DL)
	DFIXC.(IXDLX,54)		:Build  Data Loopback Circuit <n>
	DFIXC.(IXWM,55)			:Enter Warning message (WM)
	DFIXC.(IXDB,57)			:Build Delay Measurement Circuit (DB)
	DFIXC.(IXDBX,58)		:Build Delay Measurement Circuit <n>
	DFIXC.(IXDBR,59)		:Build Delay Measurement Circuit [R]
	DFIXC.(IXDBXR,5A)		:Build Delay Measurement Circuit <n>[R]
	DFIXC.(IXWR,5B,IX.AUD)		:Write Memory (W #)
	DFIXC.(IXWRC,5C,IX.AUD)		:Write Memory (W # #)
	DFIXC.(IXWRF,5D,IX.AUD)		:Write Fullword (WF #)
	DFIXC.(IXWRFC,5E,IX.AUD)	:Write Fullword (WF # #)
	DFIXC.(IXWS,60)			:Set Symbol (WS)
	DFIXC.(IXSY,61)			:Display Symbol Addresses (SY)
	DFIXC.(IXCDY,62)		:Auto CRYPTO On (CD Y)
	DFIXC.(IXCDN,63)		:Auto CRYPTO Off (CD N)
	DFIXC.(IXCOH,64)		:Change H-Ware Crash Option
	DFIXC.(IXCOS,65)		:Change S-Ware Crash Option
	DFIXC.(IXCMH,66)		:Display <n> Hours CRYPTO Msgs by Type
	DFIXC.(IXCMM,67)		:Display <n> Minutes CRYPTO Msgs by Typ
	DFIXC.(IXSM,68)			:Enable all CRYPTO Message (SM)
	DFIXC.(IXDLR,69)		:Build Data Loopback Circuit [R]
	DFIXC.(IXDLXR,6A)		:Build Data Loopback Circuit <n>[R]
	DFIXC.(IXPQ,6B)			:Display Patch History table (PQ)

        IF 1-T2GATE                     :not for gateways
	DFIXC.(IXHS,38)			:Display Host Information (HS)
	DFIXC.(IXHSH,39)		:Display Host <n> Information (HS # H)
	DFIXC.(IXHSU,3A)		:Display Host Up or Shut Info (HS U)
	DFIXC.(IXHSS,3B)		:Display Slot <n> Information (HS # S)
        EI      :NOT T2GATE

	IF	TSTSZE			:Disabled with NTLV Option in TYMFILE
	DFIXC.(IXTL,05)			:Display LINK Trace parameter (TL)
	DFIXC.(IXTMF,06)		:Display Foreground table (TMF)
	DFIXC.(IXTMB,07)		:Display Background table (TMB)
	DFIXC.(IXTN,12)			:Display LINE Trace parameter (TN)
	DFIXC.(IXTLN,45)		:Set Neighbor# in LINK Trace (TL#)
	DFIXC.(IXTNL,47)		:Set Line# in LINE Trace (TN#)
	DFIXC.(IXTL0,4A)		:Clear LINK Trace function (TL0)
	DFIXC.(IXTNF,4B)		:Clear LINE Trace function (TNF)
	EI	:TSTSZE

	IF	1-ISIS
	IF	ZITEL
	DFIXC.(IXQE,6F)			:Display Memory Errors (QE)
	EI	:ZITEL
	EI	:I-ISIS

	IF	DB.CPU			:must be set at assembly time
	DFIXC.(IXCU,70)			:Display CPU Utilization (CU)
	DFIXC.(IXCUN,71)		:Set CPU Utilization (CU #)
	EI	:DB.CPU

	IF	1-ISIS
	DFIXC.(IXRA,24)			:Display Absolute Memory (RA #)
	DFIXC.(IXRAC,25)		:Display Absolute Memory (RA # #)
	DFIXC.(IXRG,37)			:Display Register Set (RG #)
	DFIXC.(IXSN,41,IX.AUD)		:Restart Node Code (SN)
	DFIXC.(IXWA,5F,IX.AUD)		:Write FW Absolute Memory (WA #)
	EI	:1-ISIS

	IF	ISIS
	DFIXC.(IXIS,0A)			:Display ISIS Interface Statistics (IS)
	DFIXC.(IXIR,0B)			:Display ISIS Ring Pointers (IR)
	EI	:ISIS

	IF	SOLOCS
	DFIXC.(IXAS,16)			:Display Async Port Status (AS)
	DFIXC.(IXASN,17)		:Display Async Port <n> Status (AS#)
	DFIXC.(IXASR,18)		:Display Range of Async Ports (AS # #)
	DFIXC.(IXASU,19)		:Display Active Async Ports (AS U)
	DFIXC.(IXASNU,1A)		:Display Active Async Port <n> (AS # U)
	DFIXC.(IXASRU,1B)		:Display Range of Active Async Ports
	DFIXC.(IXIZ,3C,IX.AUD)		:Initialize Async Ring (IZ)
	DFIXC.(IXAZ,40)			:Clear Async Statistics (AZ)
	DFIXC.(IXHP,43,IX.AUD)		:Hang Port (HP)

	IF	SCBSYO			:Defaulted on
	DFIXC.(IXBP,6C,)		:Display Busy-port array (BP)
	DFIXC.(IXBP1,6D,IX.AUD)		:Busy Port <n> (BP # 1)
	DFIXC.(IXBP0,6E,IX.AUD)		:Unbusy Port <n> (BP # 0)
	EI	:SCBSYO
	EI	:SOLOCS

	IF	PVC
	DFIXC.(IXPV,35)			:Display PVC Parameters (PV)
	DFIXC.(IXPVN,36)		:Display Port <n> PVC parameters (PV#)
	EI	:PVC

	IF	SIORNG
	DFIXC.(IXSR,09)			:Display SIO Ring Status (SR)
	DFIXC.(IXSR1,3D,IX.AUD)		:Initialize SIO Ring (SR 1)
	DFIXC.(IXSR2,3E,IX.AUD)		:Initialize SIO Ring and Interface(SR2)
	EI	:SIORNG

IXNCMD	EQ	(.-ICMTBL)/6		:Total number of xray commands


:**********************************************************************
:	XRAYIX -  entry point for TMCS XRAY logging in
:**********************************************************************

XRAYIX	HS	0
	JAL	R8,XRYSDC		:send IIX select dialect command
	LHL	R4,XUINTH,XD		:get INTHST port index
	SBT	R4,INTOUT		:set timeout until dialect selected
XRYIX1	JAL	R0,XRYDIS,,		:remote (TMCS) dismiss
XRYIX2	JAL	R13,XRYTST,,		:check for SIIX in buffer
	JFS	XRYIX3			:immediate return = yes
	JBS	XRYIX1			:+2 return = no

XRYIX3	JAL	R13,XRYIN,,		:get lo byte of SIIX into R1
	CLHI	R1,XEQ076		:SIIX (0F6) w/o parity?
	JE	XRYIX4			:go check for global message
	J	XRYIX2			:check again??

XRYIX4	JAL	R13,XRYIN,,		:get first byte in R1
	CLHI	R1,XEQ000		:global msg (80) w/parity bit stripped?
	JE	XRYIX5			:go check for second byte
	J	XRYIX2			:check again??

XRYIX5	JAL	R13,XRYIN,,		:get second byte in R1
	CLHI	R1,XEQ001		:dialect selected (81) w/o parity?
	JE	XRYIX6			:go check for third byte
	J	XRYIX2			:check again??

XRYIX6	JAL	R13,XRYIN,,		:get third byte in R1
	CLHI	R1,XEQ000		:dialect (80) w/o parity?
	JE	XRYIX7			:go check for last byte
	J	XRYIX2			:check again??

XRYIX7	JAL	R13,XRYIN,,		:get last byte in R1
	CLHI	R1,XEQ010		:NETCON dialect (90) w/o parity?
	JE	XRYIX8			:go finish handshake
	J	XRYIX2			:check again??
		
XRYIX8	LHL	R4,XUINTH,XD		:get INTHST port index
	RBT	R4,INTOUT		:no timeout for TMCS XRAY
	JAL	R8,XRYPIV		:send IIX PIV message
	JAL	R8,XRYNC5		:send Command Mode message
	TS	IIXNTC,XD,		:indicate TMCS/XRAY in User Block
	J	IXLP02			:go check for Command Data msg


:************************************************************************
:	TMCS MAIN COMMAND LOOP - XRAY loops here until it receives a
:	command to execute or is restarted.
:************************************************************************

:	RETURN HERE AFTER EXECUTING COMMAND
IXLRET	HS	0
	LH	R1,IIXNTC,XD,		:check if TMCS/XRAY user
	JLFS	IXLP00			:yes
	J	XNRPRT,,		:no
IXLP00	JAL	R7,XRYTIX		:send TIIX message
	JAL	R8,XRYNC3		:send End Response message

IXLOOP	HS	0
	LHL	R0,CRYPRI		:test for CRYPTO...get In-Pointer
	LHL	R1,CRYMOD,XD		:are we automatically displaying?
	JEFS	IXLP01			:yes
	STH	R0,CRYPTU,XD		:no, don't let them pile up

IXLP01	CLH	R0,CRYPTU,XD		:any crypto messages?
	JE	IXLP02			:none came in
	LCS	R14,4			:output messages one at a time
	LCS	R12,1			:enable all messages
	JAL	R8,XRYACR		:send another response message
	JAL	R5,IXCT00		:output crypto messages
	JAL	R7,XRYTIX		:send TIIX to avoid timeout!
	LHL	R0,CRYPTU,XD		:remote user...
	CLH	R0,CRYPRI		:have we typed all messages?
	JEFS	IXLP02			:yes
	TS	XRYRUN			:no, reschedule in 1 second
	LHL	R0,XUSLTN,XD		:get this user's slot #
	SBT	R0,XQUEM,,		:set this user in master queue

IXLP02	JAL	R13,XRYTST,,		:check for SIIX in buffer
	JFS	IXLP03			:immediate return = yes
	JAL	R0,XRYDIS,,		:+2 return = no
	J	IXLOOP			:check again later

IXLP03	JAL	R13,XRYIN,,		:get lo byte of SIIX into R1
	CLHI	R1,XEQ076		:SIIX (0F6) w/o parity?
	JE	IXLP04			:go check for Cmd Data msg
	J	IXLP02			:check again??

IXLP04	JAL	R13,XRYIN,,		:get first byte in R1
	CLHI	R1,XEQ040		:dialect msg (C0) w/o parity?
	JE	IXLP05			:go check for second byte
	J	IXLP02			:check again??

IXLP05	JAL	R13,XRYIN,,		:get second byte in R1
	CLHI	R1,XEQ000		:Cmd Data msg (80) w/o parity?
	JE	IXLP06			:go check for third byte
	J	IXLP02			:check again??

IXLP06	JAL	R13,XRYIN,,		:get first byte of Cmd ID in R1
	OHI	R1,XEQ080		:set MSB
	STB	R1,IIXCID,XD		:store as first byte of Cmd ID

	JAL	R13,XRYIN,,		:get second byte of Cmd ID
	OHI	R1,XEQ080		:set MSB
	STB	R1,IIXCID+1,XD		:store second byte of Cmd ID

	JAL 	R13,XRYIN,,		:get first byte of command
	OHI	R1,XEQ080		:set MSB
	STB	R1,IIXCMD,XD		:store as first byte of command

	JAL	R13,XRYIN,,		:get second byte of command
	OHI	R1,XEQ080		:set MSB
	STB	R1,IIXCMD+1,XD		:store as second byte of command
	LHL	R0,IIXCMD,XD		:load command into R0

ICMDSP	HS	0
	LHI	R14,IXNCMD*6
ICMDS1	SIS	R14,6
	JL	ICMER0
	LHL	R2,ICMTBL,R14		:is this the command?
	CR	R0,R2
	JNBS	ICMDS1			:no, try next one

:	GOT THE RIGHT COMMAND
	LIS	R5,0F			:test '1' bit
	TBT	R5,ICMTBL+4,R14		:Audit type command?
	JE	ICMDS2			:no, skip over

	IF	EXPSEC
	LHL	R8,XUNAME,XD		:get user's index into GGLIST
	L	R5,XRAYGG+XGGNAM+2,R8,	:get chars 3,4,5,6 of Username
	ST	R5,CRYSBF		:for CRYPTO MESSAGE
	EXHR	R0,R0			:move Command Type to HO HW
	LHL	R5,XRAYGG+XGGNAM,R8,	:and combine
	AR	R0,R5			:with chars 1,2 of Username
	EI	:EXPSEC

	JAL	R8,CRYPTO,,		:R0 conveniently holds the Command
	HC	CRYE54			:TYPE = COMMAND AUDIT

ICMDS2	JAL	R8,XRYNC2		:send Response message
	LHL	R14,ICMTBL+2,R14	:get the address
	J	SEGD,R14,,		:and dispatch

ICMCIU	HS	0
	LH	R1,IIXNTC,XD,		:check if TMCS/XRAY user
	JLFS	ICMCI1			:yes
	J	XCOMIU,,		:no
ICMCI1	LIS	R1,0E			:send command in use message code
	JAL	R7,TYP80X
	JAL	R7,XRYTIX		:send TIIX message
	JAL	R8,XRYNC3		:send End Response message
:	LHL	R0,XRYPTF,XD		:clear input ring??
:	STH	R0,XRYPTE,XD
	J	IXLOOP

ICMER0	JAL	R8,XRYNC2		:send Response message
ICMERR	HS	0
	LH	R1,IIXNTC,XD,		:check if TMCS/XRAY user
	JLFS	ICMER1			:yes
	J	COMERR,,		:no
ICMER1	LIS	R1,0F			:invalid command
	JAL	R7,TYP80X		:send error response
	JAL	R7,XRYTIX		:send TIIX message
	JAL	R8,XRYNC3		:send End Response message
	J	IXLOOP			:check for new Command Data msg


 	SUBTTL	IIXRAY (Display Node Descriptor - ND)
:	******	*************************************

:**********************************************************************
:	IXND - Display Node Descriptor (ND)
:**********************************************************************

IXND	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LHI	R3,MACHNM
	JAL	R9,TY80HW		:send node number
	LHL	R3,MACHID,,		:khost stored in decimal
	JAL	R9,DECHEX		:convert to hex for consistency
	LHI	R3,0			:direct return=radix violation
	JAL	R9,TY80HW		:+4 return=send khost number
	LHI	R3,VERSION
	JAL	R9,TY80HW		:send version number
	LB	R1,CRACTN,,
	JAL	R7,TYP80X		:send h-ware crash option
	LB	R1,CRACTN+1,,
	JAL	R7,TYP80X		:send s-ware crash opton
	LHL	R1,TVRSUP
	JAL	R7,TYP80X		:send supervisor number

	IF	1-ISIS
	LA	R1,MEMSIZ		:get max memory address
	SVC	0F,SV.RAB		:read a FW at address in R1
	LR	R3,R1			:memory size returned in R1
	SRLS	R3,0A			:scale down
	ELSE
	LHI	R3,MEMAVL/400		:ISIS could be a gateway  ###sdw
	EI	:1-ISIS
	JAL	R9,TY80HW		:send memory size

:	COMPUTE NUMBER OF PORTS FOR KERNEL, DISPI INTERFACES. RUNNING
:	COUNT IS MAINTAINED IN 'HNPORT', BUT MAY NOT BE TOTALLY ACCURATE
:	DUE TO LOGIN RACE CONDITIONS.
	LIS	R0,0			:cumulative port count
	IF	NKU
	LA	R2,KIOTAB,,		:Kernel Port Permuter Table
	LHI	R1,NKU			: and Number of Kernel Ports
IXNDP1	LHL	R3,0,R2			:get Permuter Table entry
	JEFS	IXNDP2			:port not in use
	AIS	R0,1			:increment active port count
IXNDP2	AIS	R2,2
	SIS	R1,1			:any more to do?
	JGBS	IXNDP1			:yes - continue
	EI	:NKU

IXNDP3	HS	0
	IF	NDP
	LA	R2,DIOTAB,,		:Dispi Port Permuter Table
	LHI	R1,NDP			: and Number of Dispatcher Ports
IXNDP4	LHL	R3,0,R2			:get Permuter Table entry
	JEFS	IXNDP5			:port not in use
	AIS	R0,1			:increment active port count
IXNDP5	AIS	R2,2
	SIS	R1,1			:ANY more to do?
	JGBS	IXNDP4			:yes - continue
	EI	:NDP

	IF	SOLOCS
	LHI	R9,NGRP-1		:index into RLA bit array
	LIS	R3,0			:init the counter of active ports
IXNDP6	LHL	R1,RLA,R9,R9		:active port bit array, HW at a time
IXNDP7	JFFOH	R1,IXNDP8		:count the set bits
	SIS	R9,1			:step back to next halfword
	JGEBS	IXNDP6			:loop until RLA is covered
	J	IXND02			:leave the loop with value in R3
IXNDP8	AIS	R3,1			:count each bit that sent us here
	STH	R1,XRSAVE,XD		:an awkward way to reset a bit
	RBT	R2,XRSAVE,XD
	LHL	R1,XRSAVE,XD
	JBS	IXNDP7			:do this for all set bits in HW
	EI	:SOLOCS

	STH	R0,HNPORT		:update with most accurate count
	LHL	R3,HNPORT
IXND02	JAL	R9,TY80HW		:send number of PORTS in use
	LHL	R3,PASTHR
	JAL	R9,TY80HW		:send number of PASSTHRUS in use
	LHL	R3,NALINK
	JAL	R9,TY80HW		:send number of Active Links
	LHI	R3,NLINKS
	JAL	R9,TY80HW		:send Total number of links defined
	LHI	R3,XLINKS
	JAL	R9,TY80HW		:send number of XLNKs defined
	LHI	R3,NLINES
	JAL	R9,TY80HW		:send num of (sync+sio) LINES defined
	LHI	R3,NLINES-SILINS
	JAL	R9,TY80HW		:send number of SYNC lines defined
	LHI	R3,SILINS
	JAL	R9,TY80HW		:send number of SIO lines defined

	IF	SOLOCS
	LHI	R3,NAPORT
	ELSE
	LIS	R3,0
	EI	:SOLOCS
	JAL	R9,TY80HW		:send number of ASYNC ports

	L	R3,XFIRST
	SRLS	R3,7			:dump FASTC bits
	JAL	R9,TY80FW		:send time FIRST CAME UP
	L	R3,XLCRSH
	SRLS	R3,7			:dump FASTC bits
	JAL	R9,TY80FW		:send time LAST CAME UP

	L	R3,CS.TIM+CSMTBL
	SRLS	R3,7			:dump FASTC bits
	JAL	R9,TY80FW		:send LAST CRASH TIME
	LHL	R3,CS.CNT+CSMTBL
	JAL	R9,TY80HW		:send Crash Count
	LHL	R3,CS.CID+CSMTBL
	JAL	R9,TY80HW		:send crash TYPE
	LHL	R3,CS.PSD+2+CSMTBL
	JAL	R9,TY80HW		:send crash PSW
	L	R3,CS.PSD+4+CSMTBL
	JAL	R9,TY80FW		:send crash ADDRESS
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGEFS	IXND04			:don't send IXX messages!
	JAL	R8,XRYRES		:send another Response message

IXND04	LHI	R3,NLINES
	JAL	R9,TY80BY		:tell TMCS how many lines to expect
	LIS	LN,0			:DO FOR ALL LINES, STARTING WITH 0
IXND06	LR	R3,LN
	JAL	R9,TY80BY		:send LINE NO.

	IF	SILINS			:TEST FOR SYNC OR SIO LINE
	CLHI	LN,NLINES-SILINS	:SYNC line?
	JLFS	IXND08			:yes
	LIS	R1,1			:no - send SIO line code
	JFS	IXND10
	EI	:SILINS
IXND08	LIS	R1,0			:send SYNC line code
IXND10	JAL	R7,TYP80X

	LHL	R3,NGSVLN,LN,LN 	:check for neighbor number
	JN	IXND16			:neighbor has been there, send data
	LR	R2,LN			:index by LN*2
	AR	R2,R2
	TBT	R2,DWLDSP,,		:check for DWL in progress
	JEFS	IXND12			:no
	LIS	R1,1			:yes, send DWLOAD code
	JFS	IXND14
IXND12	LIS	R1,2			:send UNUSED code
IXND14	JAL	R7,TYP80X		:send it
	J	IXND50			:next line

IXND16	LIS	R1,0			:has been up code
	JAL	R7,TYP80X		:let TMCS know more info follows
	NHI	R3,XE0FFF		:strip HO nib from NEIG number (in R3)
	JAL	R9,TY80HW		:send NEIGhbor number
	LR	R1,R3			:NEIG NO. in R1 for FNDLNK
	JAL	R9,XFNDLK		:stores KN and KX (-1 if not found)
	NOP
	LHL	R3,XKNSAV,XD
	JAL	R9,TY80BY		:send LINK NO.

:	SEE IF NEIGHBOR IS TII OR XLINK
	LH	KX,XKDSAV,XD		:get Link Descriptor
	JLFS	IXND18			:IF <0 XLINK DOWN
	LH	R3,ONDID,KX		:XLINK?
	JEFS	IXND18			:yes
	LIS	R1,1			:TII neighbor code
	JFS	IXND20	
IXND18	LIS	R1,0			:XLINK code
IXND20	JAL	R7,TYP80X		:send TII OR XLNK
	LR	KX,KX			:check for -1
	JLFS	IXND22
	LB	R3,NLAT,KX		:number of lines on link
	SIS	R3,1			:more than one line?
	JLEFS	IXND22			:no
	LIS	R1,1			:yes, send Multi-line link code
	JFS	IXND24
IXND22	LIS	R1,0			:not Multi-line link code
IXND24	JAL	R7,TYP80X		:send link code

:	LINE IS ACTIVE. DISPLAY 'UP', WINDOW SIZE, SPEED, AND NUMBER
:	OF ACTIVE CHANNELS ON LINK.
IXND26	LH	R3,NGSVLN,LN,LN		:line attatchd to up link if HO bit set
	JGEFS	IXND28			:not set
	LIS	R1,0			:UP code
	J	IXND34			:go send it
IXND28	LH	R3,KDLN,LN,LN		:get link descriptor address
	AIS	R3,1			:if X'FFFF', line SUSPENDED, else DOWN
	JEFS	IXND32			:line is SUSPENDED
	LR	R2,LN			:line number...
	AR	R2,R2			:...times 2
	TBT	R2,DWLDSP		:see if DWLOAD in progress
	JEFS	IXND30			:no
	LIS	R1,1			:yes, send DWLOAD code
	JFS	IXND34
IXND30	LIS	R1,2			:*DOWN* code
	JFS	IXND34			:go send it
IXND32	LIS	R1,3			:*SUSP* code
IXND34	JAL	R7,TYP80X		:send it
	LH	KX,XKDSAV,XD		:link descriptor
	JL	IXND40			:if <0 XLINK DOWN

	LB	R3,WSIZ,KX
	JAL	R9,TY80BY		:send LINK WSIZ
	LHL	R3,BAUDRT,LN,LN		:pickup LINE SPEED
	CLHI	R3,HISPD		:is line high speed (>19.2KB)?
	JLFS	IXND36			:no, display calculated speed
	LHL	R4,XKNSAV,XD		:get link number
	TBT	R4,KNCNSP,,		:is speed spec in TYMFILE?
	JEFS	IXND36			:no, display calculated speed
	LB	R3,KSPD,KX		:HI speed calc and spec, snd LINK SPEED
	NHI	R3,1F			:isolate speed bits
IXND36	LB	R4,KSPD,KX		:pickup LINK SPEED for SAT bit
	LIS	R1,0			:assume TERRESTIAL LINE
	THI	R4,20			:check for SAT bit set
	JEFS	IXND38			:no
	LIS	R1,1			:send SAT code
IXND38	JAL	R7,TYP80X		:send it
	JAL	R9,TY80BY		:send LINE SPEED (in R3)

	JAL	R8,CHNCNT,,		:count returned in R3
	JAL	R9,TY80HW		:send no. of active channels for LINK

IXND40	HS	0			:here for XLINK that is DOWN
	LR	R1,LN			:line number
	SLLS	R1,2			:times 4
	L	R3,LINTIM,R1,		:TIME of last ATT/DET
	JE	IXND44			:IF 0 go tell TMCS
	SRLS	R3,7			:dump FASTC bits
	JAL	R9,TY80FW		:send TIME ATT/DET

	LIS	R2,1			:no. of HW'S for COUNT1 to scan
	LA	R4,LDARLN,LN,LN		:LD array for line
	JAL	R9,COUNT1		:how many 1's? - answer in R3
	LR	R1,R3			:no 1's?
	JEFS	IXND46			:right, so skip
	SRLS	R1,2			:divide by 4
	AIS	R1,1			:add 1
	JAL	R7,TYP80X		:send LINE ERRATE
	JFS	IXND48

IXND44	LIS	R1,0
	JAL	R7,TYP80X		:send 0 TIME ATT/DET
IXND46	LIS	R1,0
	JAL	R7,TYP80X		:send 0 LINE ERRATE
IXND48	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGEFS	IXND50			:don't send IXX messages!
	JAL	R8,XRYRES		:send another Response message
IXND50	AIS	LN,1			:advance to next line number
	CLHI	LN,NLINES		:more to do?
	JL	IXND06			:yes - do it again!

:	FIND ALL TIILNK LINKS AND DISPLAY THOSE NOT UP
IXND52	LHI	KN,(NLINKS-1)*2
	LIS	R5,0			:cumulative count of down links
IXND54	STH	KN,XKNSAV,XD		:save link#
	LHL	KX,KDKN,KN,		:get link descriptor index
	LH	R3,ONDID,KX		:is this an XLINK?
	JEFS	IXND56			:yes - bypass
	LB	R1,NLAT,KX		:are any lines attached to link?
	JNFS	IXND56			:yes - link up
	AIS	R5,1			:link DOWN - count it
	JAL	R9,TY80HW		:and send NEIGHBOR number (in R3)
IXND56	LHL	KN,XKNSAV,XD		:recover link#
	SIS	KN,2			:check next link
	JGE	IXND54

:	DONE WITH ALL LINKS - WERE ANY DOWN?
	LR	R5,R5
	JN	IXLRET			:yes, done with display
	LIS	R1,0			:no, all TIILNKs up - send ZIP code
	JAL	R7,TYP80X
	J	IXLRET			:done with Node Descriptor display

	SUBTTL	IIXRAY (Display Node Statistics - NS,NSZ)
:	******	*****************************************

:**********************************************************************
:	IXNSZ - Reset Node Statistics (NSZ)
:**********************************************************************

IXNSZ	HS	0
	LIS	R0,0			:clear process HW-marks
	LHI	R10,$A60		:clear for 15 processes
IXNSZ0	ST	R0,PROHWM,R10,
	CLHI	R10,0C			:reached index for EXLAVG yet?
	JGFS	IXNSZ2			:no
	ST	R0,EXLAVG,R10		:yes, clear various counters
IXNSZ2	SIS	R10,4
	JGEBS	IXNSZ0

	IF	SOLOCS
	STH	R0,CS.(FASTCH),,	:clear max async wrap time
	EI	:SOLOCS

	LHI	R0,$A9999		:reset EXLALW to max
	STH	R0,EXLALW		:set low water mark to max
	LHL	R0,PASTHR
	STH	R0,MXPASS		:initialize max number of pass-thrus
	LHL	R0,HNPORT
	STH	R0,MXPORT		:maximum number of ports in use
	LHL	R0,NALINK
	STH	R0,MXLINK		:and maximum number of links

:**********************************************************************
:	IXNS - Display Node Status Data - Exec Loop Counters, Needle Times
:**********************************************************************

IXNS	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LIS	R10,8			:8 HW of statistics
	LIS	R11,0
IXNS00	LHL	R3,EXLAVG,R11
	JAL	R9,TY80HW		:send them
	AIS	R11,2
	SIS	R10,1
	JGBS	IXNS00
	LHL	R3,MXPORT
	JAL	R9,TY80HW		:send Maximum Number of Ports 
	LHL	R3,MXPASS
	JAL	R9,TY80HW		:send Max Number of Passthrus
	LHL	R3,MXLINK
	JAL	R9,TY80HW		:send Maximum Number of Links

	L	R3,RMKRMS
	JAL	R9,TY80FW		:Number of RMAKE Calls Last Minute
	L	R3,RMKNRS
	JAL	R9,TY80FW		:RMAKE Calls for which No Record Made
	L	R3,RMKRMS
	S	R3,RMKNRS
	JAL	R9,TY80FW		:difference is Number of PACKETS Made

	LHL	R3,NSCPSO,,
	JAL	R9,TY80FW		:send CPS Out
	LHL	R3,NSCPSI,,
	JAL	R9,TY80FW		:send CPS In
	LHL	R3,NSCPHO,,
	JAL	R9,TY80FW		:send Hi-Water Mark Out
	LHL	R3,NSCPHI,,
	JAL	R9,TY80FW		:send Hi-Water Mark In
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGEFS	IXNS02			:don't send IXX messages!
	JAL	R8,XRYRES		:send another Response message

IXNS02	HS	0
	IF	SOLOCS
	LHL	R3,CS.(NSASYO),,
	JAL	R9,TY80FW		:send ASYNC CPS Out
	LHL	R3,CS.(NSASYI),,
	JAL	R9,TY80FW		:send ASYNC CPS In
	LHL	R3,CS.(NSASHO),,
	JAL	R9,TY80FW		:send ASYNC Hi-Water Mark Out
	LHL	R3,CS.(NSASHI),,
	JAL	R9,TY80FW		:send ASYNC Hi-Water Mark In

	IF	NUMPRN
	LIS	R1,1
	JAL	R7,TYP80X		:tell TMCS to expect PRINTER CPS STATS
	LHL	R3,CS.(NSPRNO),,
	JAL	R9,TY80FW		:send PRINTER CPS Out
	JAL	R7,TYP80Z		:no PRINTER Data In!
	LHL	R3,CS.(NSPRHO),,
	JAL	R9,TY80FW		:send PRINTER Hi-Water Mark Out
	JAL	R7,TYP80Z		:no PRINTER Hi-Water Mark In!
	ELSE
	JAL	R7,TYP80Z		:tell TMCS no PRINTER CPS STATS
	EI	:NUMPRN
	EI	:SOLOCS

IXNSP	LIS	R10,0			:clear accumulator registers
	LIS	R11,0
	L	R12,TOTCHR,,		:total no. of logical chars thru node
	SRLS	R12,7			:scale down to prevent truncation error

:	VERY EFFICIENT!	THIS WILL BE NUMERATOR OF TICKS TO MS CONVERSION
	JE	IXNSP3			:zero traffic, don't divide by zero!
	LHI	R4,NLINKS*2-2		:set up loop index
IXNSP1	LH	R14,KDKN,R4,		:get link descriptor
	LB	R0,NLAT,R14		:any lines attached?
	JE	IXNSP2			:no, link not up, ignore it
	L	R8,KS.LMI,R14		:logical chars in on link
	A	R8,KS.LMO,R14		:get total chars on link
	DHR	R8,R12			:get link's traffic as prcnt of total

	LHL	R6,KS.XMT,R14		:average transmission time
	AH	R6,KS.AQU,R14		:plus average queue time=hardware delay
	MHR	R6,R9			:mult by appropriate prcnt of traffic
	LHL	R7,KS.RRT,R14		:get buffer delay
	AH	R7,KS.SRA,R14		:plus SYLVEX-RTEAR delay
	AH	R7,SYLXAV,,		:plus ave SYLVEX delay=software delay
	MHR	R7,R9			:weigh with percent of traffic
	AR	R10,R6			:accumulate H-Ware delay
	AR	R11,R7			:and Code delay
IXNSP2	SIS	R4,2			:decrement link number index
	JGE	IXNSP1			:loop if more links

IXNSP3	LHI	R14,$A80		:denom of ticks to msec conver (128/80)
	LR	R2,R11
	DHR	R2,R14			:get result in milliseconds (in R3)
	JAL	R9,TY80HW		:send CODE DELAY
	LR	R2,R10			:same for H-Ware delay
	DHR	R2,R14
	JAL	R9,TY80HW		:send H-WARE DELAY
	AR	R10,R11			:form combined result
	LR	R2,R10
	DHR	R2,R14
	JAL	R9,TY80HW		:send TOTAL
	LIS	R3,0			:take precaution against zero divide
	SLLS	R12,8			:rescale original SRLS 7 and double
	JEFS	IXNSP5			:don't divide by zero

	IF	1-ISIS
	DHR	R12,R10			:compute efficiency for SOLO node
	LR	R3,R13
	ELSE	:1-ISIS
	IF	\TIINEW	:ISIS INTERRUPT ROUTINES MUST COLLECT OUT QUEUE DELAYS
	DHR	R12,R10			:compute efficiency for ISIS node
	LR	R3,R13
	EI	:\TIINEW
	EI	:1-ISIS	
IXNSP5	JAL	R9,TY80HW		:send EFFICIENCY
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGEFS	IXNSP6			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message

IXNSP6	LIS	R10,9+2*SOLOCS		:send 9 or 11 (SOLOCS) processes
	LIS	R11,0
	LHL	R12,MININT,,		:exact measurement interval
	LHI	R14,$A100
IXNS20	LHL	R2,PSVTIM+2,R11,	:skip the buffer-zap process
	MHR	R2,R14			:multiply by 100
	DHR	R2,R12			:divide by time interval to get prcnt
	JAL	R9,TY80BY		:send PERCENT
	AIS	R11,2
	SIS	R10,1
	JGBS	IXNS20
	LIS	R10,9+2*SOLOCS		:send 9 or 11 (SOLOCS) processes
	LIS	R11,0
	LIS	R14,$A10
IXNS30	LHL	R2,PROHWM+6,R11,	:skip the buffer-zap process
	SLLS	R2,4
	DHR	R2,R14
	JAL	R9,TY80HW		:send MAX time in Milliseconds
	AIS	R11,4
	SIS	R10,1
	JGBS	IXNS30

	IF	SOLOCS
	LHL	R2,CS.(ASYAVE),,	:get AVE FASTC TIME between ASYNC exec
	JAL	R9,FSTMSC		:convert FASTC to MSEC
	JAL	R9,TY80HW		:send AVERAGE TIME in MS
	LHL	R2,CS.(FASTCH),,	:do same for MAX TIME
	JAL	R9,FSTMSC		:convert FASTC TO MSEC
	JAL	R9,TY80HW		:send MAX TIME in MS
	LHI	R3,RNGWRP
	JAL	R9,TY80HW		:send WRAP
	EI	:SOLOCS

	J	IXLRET			:done with Node Statistics display

	SUBTTL	IIXRAY (Bad-Guy List - BG)
:	******	**************************

:**********************************************************************
:	IXBGI - Set Neighbor Node# in Bad-Guy List
:**********************************************************************

IXBGI	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R1,VALUE1,XD		:get the neighbor

	LHI	R5,(BGLSIZ-1)*2
IXBGI2	LH	R0,BGLIST,R5
	JEFS	IXBGI4			:nothing here, go make an entry
	CR	R1,R0			:see if this is duplicate
	JE	IXBG			:duplicate, display only
	SIS	R5,2			:this entry in use
	JGBS	IXBGI2			:check next entry
	J	IXBG			:no room for entry, display only

IXBGI4	STH	R1,BGLIST,R5		:make entry
	J	IXBG			:display

:**********************************************************************
:	IXBGR - Clear Neighbor Node# in Bad-Guy List
:**********************************************************************

IXBGR	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R1,VALUE1,XD		:get the neighbor

	LIS	R0,0
	LHI	R5,(BGLSIZ-1)*2
IXBGR2	CLH	R1,BGLIST,R5		:is this it?
	JNFS	IXBGR4			:(.+6) no check next entry
	STH	R0,BGLIST,R5		:yes, zero entry
IXBGR4	SIS	R5,2
	JGEBS	IXBGR2			:.-0C

:**********************************************************************
:	IXBG - Display Bad-Guy List
:**********************************************************************

IXBG	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LI	R10,BGLIST
	LI	R11,BGLSIZ
IXBG1	LHL	R3,0,R10		:get an entry
	JEFS	IXBG2			:no entry
	JAL	R9,TY80HW		:send it
IXBG2	AIS	R10,2			:advance pointer
	SIS	R11,1			:decrement count
	JGBS	IXBG1			:continue sending
	J	IXLRET			:done with Bad-Guy List display

	SUBTTL	XRAY (Warning message - WM)
:	******	***************************

:**********************************************************************
:	IXWM1 -	Display XRAY Warning Message (WM1)
:**********************************************************************

IXWM1	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LB	R3,XWMSGB,,		:anything there?
	JE	IXWM10			:no, send message length = 0
IXWM11	JAL	R9,TY80BY		:yes, send message length
	LA	R2,XWMSGB,,
	JAL	R7,TY80AS		:send current Message
	L	R3,XWMSGT,,
	SRLS	R3,7			:dump FASTC bits
	JAL	R9,TY80FW		:send message time
	J	IXLRET

IXWM10	JAL	R9,TY80BY		:send message length = 0
	J	IXLRET			:done with Warning Message display

:**********************************************************************
:	IXWM0 - Clear Warning Message buffer (WM0)
:**********************************************************************

IXWM0	HS	0
	LIS	R1,0			:zero out message buffer count
	STB	R1,XWMSGB,,
	JAL	R7,TYP80Xs		:send byte for non-error response
	J	IXLRET

:**********************************************************************
:	IXWM - Enter Warning Message (WM)
:**********************************************************************

IXWM	HS	0
	LB	R3,XWMSGB,,		:make sure buffer is empty
	JE	IXWM20
	LIS	R1,0D
	JAL	R7,TYP80X		:send buffer-in-use response
	J	IXWM11			:send current message

IXWM20	LHL	R2,XWMCIU,,
	JE	IXWM21
	LIS	R1,0E
	JAL	R7,TYP80X		:send command-in-use message
	J	IXLRET			:done

IXWM21	STH	XD,XWMCIU,,
	JAL	R7,TYP80Z		:send non-error response
	LIS	R5,2			:init message length count
IXWM30	JAL	R13,XRYIN,,
	NHI	R1,ASC7BT		:strip parity
	CLHI	R1,ASCCR		:<CR>?
	JE	IXWM40			:yes
	CLHI	R5,MXWMSG		:max warning msg length = 40x
	JLE	IXWM32
	J	IXWM42			:message too long

IXWM32	STB	R1,XWMSGB+3,R5,		:store char in message buffer
	AIS	R5,1			:inc msg length count
	J	IXWM30			:get another character

IXWM40	CLHI	R5,MXWMSG		:max warning msg length = 40x
	JLEFS	IXWM41
IXWM42	LIS	R1,0			:message too long
	STH	R1,XWMCIU,,		:clear command-in-use flag
	STB	R1,XWMSGB,,		:clear message buffer byte count
	J	IXLRET			:return

IXWM41	LIS	R1,0D			:store CR/LF
	STB	R1,XWMSGB+3,R5,
	LIS	R1,0A
	STB	R1,XWMSGB+4,R5,
	AIS	R5,2
	STB	R5,XWMSGB,,
	JAL	R9,GMTCAL,,
	L	R2,GMTNOW,,		:store time
	ST	R2,XWMSGT,,
	LIS	R0,0
	STH	R0,XWMCIU,,		:clear command-in-use flag
	J	IXLRET			:done with Warning message

	SUBTTL	IIXRAY (Channel Trace - TC)
:	******	***************************

:**********************************************************************
:	IXTC0 - Clear Channel Trace  
:	Argument = Absolute Channel Number
:**********************************************************************

IXTC0	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R1,VALUE1,XD		:get abs Channel
	CLHI	R1,ENDZFL		:largest allowable Channel
	JG	ICMERR			:too big
	RBT	R1,TRCHAN,,
	J	IXTC

:**********************************************************************
:	IXTC1 - Set Channel Trace
:	Argument = Absolute Channel Number
:**********************************************************************

IXTC1	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R1,VALUE1,XD		:get abs Channel to trace
	CLHI	R1,ENDZFL		:largest allowable Channel
	JG	ICMERR			:too big
	SBT	R1,TRCHAN,,

:**********************************************************************
:	IXTC - Display Channel Trace parameter (TC)
:**********************************************************************

IXTC	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LHI	R11,10			:don't exceed 128 byte message
	LIS	R10,0
IXTC24	LHL	R12,TRCHAN,R10,
IXTC26	JFFOH	R12,IXTC23
	J	IXTC25			:done with this H-Word
IXTC23	XH	R12,HMSK,R13,R13
	LR	R3,R10
	SLLS	R3,3
	AR	R3,R13
	JAL	R9,TY80HW		:send Channel number
	SIS	R11,1
	JG	IXTC26			:more room in this response message?
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGE	IXTC26			:don't send IXX messages!
	JAL	R8,XRYRES		:send another response message
	LHI	R11,10			:reset counter
	J	IXTC26
IXTC25	AIS	R10,2
	CLHI	R10,ENDZFL/8
	JL	IXTC24
	J	IXLRET

	SUBTTL	IIXRAY (Display Channel Trace Data - TD, TE, TA)
:	******	************************************************

:**********************************************************************
:	IXTDCI -  Display <count> Channel Trace Input Entries
:**********************************************************************

IXTDCI	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R12,VALUE1,XD		:get the count
	JFS	IXTDI2

:**********************************************************************
:	IXTDI - Display Channel Trace Input Data
:**********************************************************************

IXTDI	HS	0
	LHI	R12,200			:display entire table
IXTDI2	LCS	R11,2			:enable input messages
	J	IXTD21

:**********************************************************************
:	IXTDCO - Display <count> Channel Trace Output Entries
:**********************************************************************

IXTDCO	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R12,VALUE1,XD		:get the count
	JFS	IXTDO2

:**********************************************************************
:	IXTDO - Display Channel Trace Output Data
:**********************************************************************

IXTDO	HS	0
	LHI	R12,200			:display entire table
IXTDO2	LCS	R11,1			:enable output messages
	J	IXTD21

:**********************************************************************
:	IXTDC - Display <count> Channel Trace events
:**********************************************************************

IXTDC	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R12,VALUE1,XD		:get the count
	JFS	IXTD20

:**********************************************************************
:	IXTD - Display Channel Trace Data
:**********************************************************************

IXTD	HS	0
	LHI	R12,200			:display entire table
IXTD20	LIS	R11,0			:enable all messages
IXTD21	JAL	R7,TYP80Z		:send non-error response
	LIS	R0,0			:clear TRMASK to display all data
	LHI	R5,(TRRSIZ/8)-4
IXTD22	ST	R0,TRMASK,R5,
	SIS	R5,4
	JGEBS	IXTD22
	STH	R0,XTDXCT,,		:initialize loop counter

	LHL	R5,TRRIX		:oldest entry in table
	LHI	R1,308			:turn off trace
	STH	R1,CHRTRC,,
	STH	R1,XTDFLG,,		:note XRAY in TD inst in case of ^C

	LCS	R10,1			:R10 serves as flag and pointer
IXTD23	SIS	R5,8			:back up 4 HW
	JGEFS	IXTD24			:no wrap
	AHI	R5,TRRSIZ		:de-wrap
IXTD24	CLH	R5,TRRIX		:come full circle?
	JEFS	IXTD25			:yes, just display whole table
	JAL	R9,TRCTST		:investigate this DW
	J	IXTD23			:(direct ret)-not satisfactory, back up
	LR	R10,R5			:(+4)save pointer to last message found
	SIS	R12,1			:decrement number of messages desired
	JG	IXTD23			:not done yet, keep looking

IXTD25	LR	R5,R10			:recover pointer
	JL	IXTD99			:R10 is still -1, no msgs found. EXIT

IXTD30	JAL	R9,TRCTST		:double-check this potential beginning
	J	IXTD70			:not good, advance to next DW boundary
	JAL	R10,TRCSUP		:(+4)-set up for display
	J	IXTD80			:(direct return)-not printable

:	FOUND AN APPARENTLY VALID ENTRY...SEND IT
	LIS	R1,0			:(+4)-presume Output message (-1)
	AIS	R4,1			:verify that guess
	JEFS	IXTD32			:right
	LIS	R1,1			:wrong, Input message (-2)
IXTD32	JAL	R7,TYP80X		:send the I/O message type code
	JAL	R9,TY80HW		:send the Channel number (in R3)
	LHL	R3,TRRING+4,R5,,
	JAL	R9,TY80HW		:send Time (LO HW of FASTC)
	AIS	R5,8			:advance to next DW boundary
	NHI	R5,TRRSIZ-1

IXTD40	LHI	R8,$A118		:118 data bytes max for each msg
IXTD42	LB	R3,TRRING,R5,,		:get next byte of message
	LIS	R10,0			:bytes not output for set bits!
	TBT	R5,TRMASK,,		:printable character?
	JN	IXTD44			:no
	LIS	R10,1			:yes - set R10 to incre max msg counter
	JAL	R9,TY80BY		:send Hex Byte of record data
IXTD44	SIS	R6,1			:decrement byte count
	JE	IXTD46			:done (we never get a zero byte count)
	AIS	R5,1			:increment byte pointer
	NHI	R5,TRRSIZ-1		:correct for wrap
	SR	R8,R10			:R10 is either 0 or 1
	JG	IXTD42			:room for more bytes in this message
	LH	R1,IIXNTC,XD,		:no more room-check if TMCS/XRAY user
	JGE	IXTD40			:don't send IXX messages!
	JAL	R8,XRYRES		:send another response message

	J	IXTD40			:continue with this message

IXTD46	LH	R1,IIXNTC,XD,		:check if TMCS/XRAY user
	JGEFS	IXTD70			:don't send IXX messages!
	JAL	R8,XRYRES		:send another Response message
IXTD70	AIS	R5,8			:advance to next DW boundary
	NHI	R5,TRRSIZ-8	
	CLH	R5,TRRIX		:at current position?
	JEFS	IXTD99			:yes - done with Trace display
	LHL	R6,XTDXCT,,		:# of times through here
	AIS	R6,1
	STH	R6,XTDXCT,,
	CLHI	R6,TRRSIZ/8		:are we out of control?
	JL	IXTD30			:no - continue

:	END OF TD COMMAND
IXTD99	LHI	R1,208
	STH	R1,CHRTRC,,		:re-enable trace
	TS	XTDFLG,,
	J	IXLRET			:and return

IXTD80	AR	R5,R6			:add in byte count
	J	IXTD70			:and proceed

	SUBTTL	IIXRAY  (Bufferlet Use Histograms -BS,BSZ)
:	******	******************************************

:**********************************************************************
:	IXBS - Display Bufferlet Use Histograms (BS)
:	Data displayed represents bytes in allocated bufferlets.
:	Six different displays are possible, depending upon how many
:	bufferlets the node is configured for. This information is
:	contained in the variable 'ISCALE'
:**********************************************************************

IXBS	HS	0
	JAL	R7,TYP80Z		:send non-error response

	IF	REBILD
	LIS	R1,1
	JAL	R7,TYP80X		:tell TMCS to expect history info
	ELSE
	JAL	R7,TYP80X		:tell TMCS to expect no history info
	EI	:REBILD

	LI	R3,NBFLE2		:configured number of Bufferlet bytes
	GL	NBFLE2
	LR	R10,R3			:save
	JAL	R9,TY80FW		:send configured number of bytes
	L	R3,BFLTSV		:get Total In Use
	SR	R10,R3			:save Total Available
	JAL	R9,TY80FW		:send Total In Use
	L	R3,BFLTMX
	JAL	R9,TY80FW		:send Total Peak

	IF	REBILD
	L	R3,HBFTSV
	JAL	R9,TY80FW		:send History In Use
	L	R3,HBFTMX
	JAL	R9,TY80FW		:send History Peak
	EI	:REBILD

	LR	R3,R10
	JAL	R9,TY80FW		:send Total Available
	LHL	R3,BZAPCT,,
	JAL	R9,TY80HW		:send number of Buffer Zaps to date

	LHI	R1,ISCALE
	JAL	R7,TYP80X		:tell TMCS what display to use
	LHI	R1,NSTEPS
	JAL	R7,TYP80X		:tell TMCS how many steps to expect

	LIS	R10,0		:DO FOR 'NSTEPS' SAMPLES OF HISTOGRAM DATA
IXBS02	L	R3,BFLTHG,R10,
	JAL	R9,TY80FW		:send one data value
	AIS	R10,4
	CLHI	R10,(NSTEPS-1)*4	:do for 'NSTEPS' values
	GL	NSTEPS
	JLE	IXBS02			:more left
	J	IXLRET

:**********************************************************************
:	IXBSZ - Initialize Bufferlet Use Histograms
:**********************************************************************

IXBSZ	HS	0
	LIS	R1,0			:clear all values
	ST	R1,BFLTMX		:clear Total Peak buffer usage
	STH	R1,BZAPCT,,		:clear Buffer Zap count

	IF	REBILD
	ST	R1,HBFTMX		:clear history peak buffer usage
	EI	REBILD

	LHI	R10,$A4*15
IXBSZ2	ST	R1,BFLTHG,R10,		:clear histogram data
	SIS	R10,4
	JGEBS	IXBSZ2
	JAL	R7,TYP80X		:send non-error response
	J	IXLRET

	SUBTTL	IIXRAY (Display Crash Tables - DC,DCS,DCD)
:	******	******************************************

:**********************************************************************
:	IXDCS -  Display Crash Summary Table (DCS)
:**********************************************************************

IXDCS	HS	0
	LI	R11,IXLRET		:finish after doing summary table
	JFS	IXDC02			:go do summary table

:**********************************************************************
:	IXDC - Display Crash Tables (DC)
:**********************************************************************

IXDC	HS	0
	LI	R11,IXDCD2		:do detail after doing summary
IXDC02	HS	0			:display crash summary table
	JAL	R7,TYP80Z		:send non-error response
	LI	R10,IXDC06		:continuation point
	LIS	R12,0			:index to summary table entries
	LI	R14,CSMTBL		:pointer to summary table
	LHL	R3,CSMCNT		:number of summary entries
	JAL	R9,TY80BY		:tell TMCS how many to expect
	LHL	R6,CSMCNT		:init counter
	JER	R11			:return if none

IXDC04	L	R3,CS.TIM,R14,R12	:get Crash Time
	SRLS	R3,7			:strip FASTC bits
	JAL	R9,TY80FW		:send Time
	LHL	R3,CS.CNT,R14,R12
	JAL	R9,TY80HW		:send Crash Count
	LHL	R3,CS.CID,R14,R12
	JAL	R9,TY80HW		:send Crash ID
	LHL	R3,CS.PSD+2,R14,R12
	JAL	R9,TY80HW		:send Crash PSW
	L	R3,CS.PSD+4,R14,R12
	JAL	R9,TY80FW		:send Crash PC
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGER	R10			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
	JR	R10

IXDC06	AHI	R12,CS.SIZ		:next entry
	CLHI	R12,CSMTBS		:done?
	JGER	R11			:yes, done
	SIS	R6,1			:dec count of entries
	JG	IXDC04			:no, do next entry
	JR	R11			:done

:**********************************************************************
:	IXDCD - Display Crash Detail Table (DCD)
:**********************************************************************

IXDCD	HS	0
	JAL	R7,TYP80Z		:send non-error response
IXDCD2	LI	R14,CDTTBL		:point to detail table
	LIS	R12,0			:index into detail table
IXDCD4	LI	R11,IXLRET		:go here when all done
	LHL	R1,CDTCNT
	JAL	R7,TYP80X		:tell TMCS how many
	LHL	R6,CDTCNT		:load count of detail entries
	JER	R11			:none, all done
	LI	R10,IXDCD5		:set up return pointer
	J	IXDC04
IXDCD5	HS	0		:RETURN HERE FROM IXDC04 AFTER SENDING 1ST LINE

	IF	ISIS
	AR	R14,R12
	LR	R6,R14			:get pointer to table
	AHI	R6,CD.RSF		:point to REG SET F save area
	LHI	R5,10			:we want to send 16D REGS
	JAL	R8,TY80NF		:send USER REGISTER SET
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGEFS	IXDCD9			:don't send IXX messages!
	JAL	R8,XRYRES		:send another Response message

	ELSE	:NOT ISIS
	AR	R14,R12
	LR	R6,R14			:get pointer to table
	AHI	R6,CD.RS0		:point to REG SET 0 save area
	LHI	R5,10			:16d REGS
	JAL	R8,TY80NF		:send REGISTER SET 0
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGEFS	IXDCD6			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
IXDCD6	LHI	R5,10			:16d REGS - R6 points to next section
	JAL	R8,TY80NF		:send USER REGISTER SET
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGEFS	IXDCD7			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
IXDCD7	LHI	R5,10			:24d FW'S - R6 points to next section
	JAL	R8,TY80NF		:send 16d MAC REGISTERS (300-35F)
	LH	R1,IIXNTC,XD,
	JGEFS	IXDCD8
	JAL	R8,XRYRES
IXDCD8	LIS	R5,8
	JAL	R8,TY80NF		:send 8 more 
	EI	:ISIS

IXDCD9	LR	R12,R12
	JN	IXLRET
	AHI	R12,CD.SIZ		:next detail entry
	LHL	R6,CDTCNT		:number of detail entries - 1 or more?
	SIS	R6,1
	JER	R11			:no, all done
	J	IXDC04

	SUBTTL	IIXRAY	(Crash Options - CO)
:	******	****************************

:**********************************************************************
:	IXCOH - Change Hardware Crash Option
:**********************************************************************

IXCOH	HS	0
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R3,VALUE1,XD		:get H-Ware Crash Option
	SLLS	R3,8			:get into position
	LB	R1,CRACTN+1,,		:current S-Ware
	AR	R3,R1			:combine
	STH	R3,CRACTN,,		:store
	J	IXCO			:display

:**********************************************************************
:	IXCOS - Change Software Crash Option
:**********************************************************************

IXCOS	HS	0
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R3,VALUE1,XD		:get S-Ware Crash Option
	LB	R1,CRACTN,,		:current H-Ware
	SLLS	R1,8			:get into position
	AR	R1,R3			:combine
	STH	R1,CRACTN,,		:store and fall thru

:**********************************************************************
:	IXCO - Display Current Crash Options
:**********************************************************************

IXCO	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LB	R1,CRACTN,,		:h-ware
	JAL	R7,TYP80X
	LB	R1,CRACTN+1,,		:s-ware
	JAL	R7,TYP80X
	J	IXLRET

	SUBTTL	IIXRAY (Display Link Descriptor - KD)
:	******	*************************************

:************************************************************************
:	IXKD - Display Link to Given Neighbor
:************************************************************************

IXKD	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R1,VALUE1,XD		:get the neighbor number
	JE	ICMERR			:XFNDLK won't accept neighbor # of 0
	JAL	R9,XFNDLK
	J	ICMERR			:immediate return - not found
	JAL	R7,TYP80Z		:+4 - send non-error response
	LHL	KX,XKDSAV,XD		:get Link Descriptor into R11
	LA	R10,NDID,KX		:points to first HW of Lnk Descriptor
	LHL	R3,0,R10
	JAL	R9,TY80HW		:send Neighbor Node Number
	AIS	R10,7
	LB	R3,0,R10
	JAL	R9,TY80BY		:send Link Number
	SIS	R10,4
	LB	R3,0,R10
	JAL	R9,TY80BY		:send BORI
	AIS	R10,2
	LB	R3,0,R10
	JAL	R9,TY80BY		:send Window Size
	AIS	R10,1
	LB	R3,0,R10
	NHI	R3,1F
	JAL	R9,TY80BY		:send Link Speed index
	LB	R3,0,R10
	LIS	R1,0			:assume terrestrial
	THI	R3,20			:check for sat bit set
	JEFS	IXKD02			:no
	LIS	R1,1			:send sat code
IXKD02	JAL	R7,TYP80X		:send it
	AIS	R10,2
	LIS	R5,4
	JAL	R8,TY80NH		:send 4 HW - NCHN,ISEC,NRTR,AMSK

	ST	KX,XRSAVE,XD		:save Link Descriptor
	ST	R10,XRSAVE+4,XD		:and pointer
	LR	R8,XD			:save User Block pointer
	LM	R12,0,R10		:copy dynamic data
	STM	R12,XRSAVE+8,R8,	:to static area for accurate reading
	LR	XD,R8			:restore XD
	LA	R10,XRSAVE+8,XD
	LIS	R5,8
	JAL	R8,TY80NH		:send 8 HW's
	L	KX,XRSAVE,XD		:recover Link Descriptor
	L	R10,XRSAVE+4,XD		:and pointer
	AHI	R10,10			:advance pointer
	LHL	R3,0,R10
	JAL	R9,TY80HW		:send BNOD
	LHL	KN,XKNSAV,XD		:recover Link#
	LHL	R3,LKZFKN,KN,KN
	JAL	R9,TY80HW		:send absolute CHN0
	LHL	R3,TBDPKN,KN,KN
	JAL	R9,TY80HW		:send B.PT
	LHL	R3,EBDPKN,KN,KN
	JAL	R9,TY80HW		:send E.PT
	LHL	KX,XKDSAV,XD		:recover Link Descriptor
	LHL	R3,ANCHN,KX
	JAL	R9,TY80HW		:send ACHN
	LHL	R3,KVERNO,KX
	JAL	R9,TY80HW		:send VERS

:	SEND NUMBER OF COMMAND CIRCUITS
	LIS	R3,0			:init count
	LHL	R1,NCHN,KX,		:# channels allocated to this link
	JE	IXKD08			:none
	SIS	R1,1			:begin with last channel
	LHL	KN,XKNSAV,XD,		:recover Link Number
	LHL	R7,FLDPKN,KN,KN		:beginning of link's bit arrays
IXKD10	TBT	R1,CMDCTS,R7,		:test this one
	JEFS	IXKD12			:nope
	AIS	R3,1			:got one, inc count
IXKD12	SIS	R1,1			:next channel
	JGBS	IXKD10			:don't bother with channel 0
IXKD08	JAL	R9,TY80HW		:send CMD CKTS

:	DISPLAY ALL LINES ATTACHED TO LINK
	LHL	KX,XKDSAV,XD,		:recover Link Descriptor
	LB	R0,NLAT,KX
	JNFS	IXKD14			:got some
	LCS	R3,1
	JAL	R9,TY80BY		:no lines attached - send zip code
	J	IXLRET			:done
IXKD14	LHI	LN,(NLINES-1)*2
IXKD18	LH	R1,NGSVLN,LN,		:see if this line attached to link
	JGEFS	IXKD20			:8000 bit set if line attached
	NHI	R1,7FFF
	CLH	R1,NDID,KX		:is line attached to this link?
	JEFS	IXKD22			:yes - display it
IXKD20	SIS	LN,2
	JGEBS	IXKD18			:check all lines
	J	IXLRET			:done
IXKD22	LR	R3,LN
	SRLS	R3,1
	JAL	R9,TY80BY		:send LINE number
	JBS	IXKD20

	SUBTTL	IIXRAY (Display Link Statistics - KS)
:	******	*************************************

:**********************************************************************
:	IXKSZ - Clear Link Statistics (KSZ)
:**********************************************************************

IXKSZ	HS	0
	LI	R10,IXKSZ2		:set up continuation point
	JFS	IXKS00

:**********************************************************************
:	IXKS - Display Link Statistics. Node Code routine MTRFIC gathers link
:	traffic counts for logical and physical counts. Count interval is
:	Number of seconds in MTTINT. Display counts...
:**********************************************************************

IXKS	HS	0
	LI	R10,IXKS03		:set up continuation point
IXKS00	LHL	R2,XKSCIU+2,,		:anybody here already?
	JN	ICMCIU			:yes, COMMAND IN USE Message
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	ST	XD,XKSCIU,,		:mark it in use AFTER reading arg
	LHL	R3,VALUE1,XD		:get the Neighbor Number
	LR	R1,R3			:R1 for XFNDLK, R3 for TY80HW
	JAL	R9,XFNDLK		:find link requested
	LIS	R2,0			:immediate return - link not found
	JFS	IXKS01			:go handle
	JFS	IXKS02			:+4 return - link valid, go display
IXKS01	ST	R2,XKSCIU,,		:reset busy flag and
	J	ICMERR			:link not there, complain
IXKS02	JAL	R7,TYP80Z		:send error free response
 	JAL	R9,TY80HW		:send neighbor number back
	LHL	KX,XKDSAV,XD		:recover KD into KX for this nghbr
	JR	R10			:continue

:	CHECK FOR STATISTICS CLEAR COMMAND AND ZERO THE LINK DESCRIPTOR STATS
:	HIGH WATER MARKS FOR THE SPECIFIED LINK(S) IF CLEAR FLAG IS NON-ZERO
IXKSZ2	LIS	R2,0
	ST	R2,KS.PHO,KX		:clear Packet Chars Out HWM
	ST	R2,KS.PHI,KX		:clear Packet Chars In HWM
	ST	R2,KS.LHO,KX		:clear Logical Chars Out HWM
	ST	R2,KS.LHI,KX		:clear Logical Chars In HWM
	ST	R2,KS.NPH,KX		:clear #Packets Made HWM
	ST	R2,XKSCIU,,		:mark command not in use
	J	IXLRET			:done

:	COPY RELEVANT FIELDS FROM LINK DESCRIPTOR TO SAVE AREA SO
: 	KS DISPLAY USES CONSISTENT DATA
IXKS03	LHI	R1,KSSZ-4		:7 groups of 12 bytes each
IXKS04	L	R0,KS.PCO,KX,R1
	ST	R0,KS.PCO+XKSSKD,,R1 	:save area
	SIS	R1,4
	JGEBS	IXKS04

	LB	R1,KSPD,KX
	NHI	R1,1F			:isolate Link Speed and
	SLLS	R1,2			: mult times 4 for FW table lookup
	LHL	R14,MTTINT,,		:measurement interval in R14
	LIS	R3,0
	LHL	R4,KSPCPS,,R1		:get link's CPS rate,
	MR	R3,R14			: compute number of characters over 
	ST	R4,KS.PCO+XKSSKD,,	: reporting interval and save

	L	R2,KS.LMI+XKSSKD,,	:Last Minute's Logical Chars In
	DHR	R2,R14			:compute number per second
	LR	R10,R3			:save CPS In
	JAL	R9,TY80FW		:send Logical Link CPS In
	L	R2,KS.LHI+XKSSKD,,
	DHR	R2,R14
	JAL	R9,TY80FW		:send Logical Chars In HWM
	L	R2,KS.LMO+XKSSKD,,
	DHR	R2,R14
	LR	R12,R3			:save CPS Out
	JAL	R9,TY80FW		:send Logical Link CPS Out
	L	R2,KS.LHO+XKSSKD,,
	DHR	R2,R14
	JAL	R9,TY80FW		:send Logical Chars Out HWM

	L	R2,KS.PMI+XKSSKD,,
	DHR	R2,R14
	JAL	R9,TY80FW		:send Physical LInk CPS In
	L	R2,KS.PHI+XKSSKD,,
	DHR	R2,R14
	JAL	R9,TY80FW		:send Physical Chars In HWM
	L	R2,KS.PMO+XKSSKD,,
	DHR	R2,R14
	JAL	R9,TY80FW		:send Physical Link CPS Out
	L	R2,KS.PHO+XKSSKD,,
	DHR	R2,R14
	JAL	R9,TY80FW		:send Physical Chars Out HWM

	L	R3,KS.PMI+XKSSKD,,	:Packet Characters In
	LR	R4,R3
	S	R3,KS.LMI+XKSSKD,,	:Packet-Logical=Overhead Characters
	JAL	R8,TY80PC		:compute and send Packet Overhead In
	L	R3,KS.PMO+XKSSKD,,	:Packet Characters Out
	LR	R4,R3
	S	R3,KS.LMO+XKSSKD,,
	JAL	R8,TY80PC		:compute and send Packet Overhead Out

	L	R4,KS.PCO+XKSSKD,,	:retrieve link's CPM rate
	L	R3,KS.PMI+XKSSKD,,	:last Minute's chars In
	JAL	R8,TY80PC		:compute/send Bandwidth Utilization In
	L	R4,KS.PCO+XKSSKD,,
	L	R3,KS.PMO+XKSSKD,,	:last Minute's chars Out
	JAL	R8,TY80PC		:compute Bandwidth Utilization Out

	JAL	R8,CHNCNT,,		:Count num of Channels active on link
	LR	R14,R3			:save it
	JEFS	IXKS05			:dont divide by zero!
	LR	R2,R10			:move over CPS In
	DHR	R2,R14			:get CPS Per Channel In
IXKS05	JAL	R9,TY80HW		:send CPS Per Channel IN
	LR	R3,R14			:dont divide by zero
	JEFS	IXKS06
	LR	R2,R12
	DHR	R2,R14			:get CPS Per Channel Out
IXKS06	JAL	R9,TY80HW		:send CPS per Channel Out
	LR	R3,R14
	JAL	R9,TY80HW		:send Number of Active Channels

	LHL	R2,KS.PKM+XKSSKD,,
	LHL	R14,MTTINT,,		:get precise Measurement Interval
	DHR	R2,R14			:form Packets/Sec
	JAL	R9,TY80HW		:send Packets/Sec

	LHL	R3,KS.ASZ+XKSSKD,,
	JAL	R9,TY80HW		:send Average Packet Size

	LHL	R3,KS.LRA+XKSSKD,,
	JAL	R9,TY80HW		:send Average Number of Recds Per Pkt

IXKSYL	LHL	R2,SYLXAV,,		:get Average Interval btwn SYLVER Runs
	JAL	R9,FSTMSC		:convert to milliseconds
	LR	R10,R3			:save result
	JAL	R9,TY80HW		:send SYLVER Delay
	
IXKSRT	LHL	R2,KS.SRA+XKSSKD,,
	JAL	R9,FSTMSC		:convert to milliseconds
	AR	R10,R3			:add in result
	JAL	R9,TY80HW		:send SYLVER-RTD Time in MS

	IF	BFLTMR
	LHL	R2,BFDOPT,,		:test control cell for dly calc method
	JN	IXKSRR			:must be set non-zero for old method

:	COMPUTE AVG TIMING PAIR DELAY, AND OUTPUT IT
	LHL	R2,KS.BFC,KX		:must check for zero divisor
	JNFS	IXKS09
	LIS	R3,0
	JFS	IXKS10
IXKS09	LHL	R1,KS.BFD,KX		:read acc'ed buffer delay
	DHR	R1,R2			:quotient in R2	, remainder in R1
	JAL	R9,FSTMSC		:convert to milliseconds (ret in R3)
IXKS10	AR	R10,R3			:add into total delay
	JAL	R9,TY80HW		:send delay time (dec ms)
	JFS	IXKSAQ			:jump to output Out Queue delay
	EI	:BFLTMR

IXKSRR	LHL	R2,KS.RRT+XKSSKD,,
	JAL	R9,FSTMSC		:convert to milliseconds
	AR	R10,R3			:save result
	JAL	R9,TY80HW		:send RMAKE Buffer Delay

IXKSAQ	LHL	R2,KS.AQU+XKSSKD,,
	JAL	R9,FSTMSC		:convert to milliseconds
	AR	R10,R3			:accumulate delay
	JAL	R9,TY80HW		:send Out Queue

IXKSXM	LHL	R2,KS.XMT+XKSSKD,,	
	JAL	R9,FSTMSC		:convert to milliseconds
	AR	R10,R3			:accumulate delay
	JAL	R9,TY80HW	 	:send XMIT


IXKSTL	LR	R3,R10			:get Total Delay
	JAL	R9,TY80HW		:send Total Delay
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGEFS	IXKS11			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message

IXKS11	LHL	R3,KS.OVL+XKSSKD,,
	JAL	R9,TY80HW		:send Overload Count
	LHL	R3,KS.SAT+XKSSKD,,
	JAL	R9,TY80HW		:send Saturated Count
	LHL	R3,KS.BAM+XKSSKD,,
	JAL	R9,TY80HW		:send Backlog Count
	LHL	R3,KS.PKM+XKSSKD,,
	JAL	R9,TY80HW		:send Number of Packets Made
	L	R3,KS.NPM+XKSSKD,,
	JAL	R9,TY80FW		:send Idle Calls	

	IF	1-ISIS		:ISIS WON'T COLLECT STAT UNTIL REL 6

:	FIND THE DATA FOR ALL LINES ON THE LINK
:	KN(R11) HAS THE LINK DESC PTR FOR LINK WE'RE QUERYING
	LIS	R10,8			:don't exceed 128 byte message
	LIS	R6,0			:step through lines
IXKS15	LHL	R3,KDLN,R6,R6		:look at line's link desc
	CR	R3,KN			:this is how we tell cousins
	JE	IXKS16

IXKS17	AIS	R6,1			:next line number
	CLHI	R6,NLINES
	JN	IXKS15

	LIS	R2,0			:fall through when all lines checked
	ST	R2,XKSCIU,,		:mark comand not in use
	J	IXLRET			:done

:	LINE STATISTICS OUTPUT ROUTINE
IXKS16	LR	R3,R6			:get line number for screen
	JAL	R9,TY80HW		:send Line Number

:	NOW OUTPUT OUR STATISTICS
	CLHI	R6,NLINES-SILINS	:check for SIO line
	JLFS	IXKSSY			:branch if still in SYNC range
	LCS	R3,1
	JAL	R9,TY80HW		:send indicator for n/a
	JFS	IXKS19
IXKSSY	LHL	R3,KL.LSV,R6,R6		:get minute's worth of Marking
	JAL	R9,TY80HW		:send Marking
IXKS19	LHL	R3,KL.TSV,R6,R6		:get minute's worth of Rxmt
	JAL	R9,TY80HW		:send Rexmissions
	LHL	R3,KL.RSV,R6,R6		:get minute's worth of Xmt
	JAL	R9,TY80HW		:send Xmissions

	SIS	R10,1
	JG	IXKS17			:more room in this Response message?
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGE	IXKS17			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
	LIS	R10,8			:reset counter
	J	IXKS17		:GO BACK FOR ANY MORE LINES ON THIS LINK

	ELSE
	LI	R2,0
	ST	R2,XKSCIU,,		:mark command not in use
	J	IXLRET			:done
	EI	:1-ISIS

	SUBTTL	IIXRAY (Display Active Channels - AC)
:	******	*************************************

:**********************************************************************
:	IXAC - Display Active Channels (AC)
:	INPUT = ABS CHAN NUMBER (CHN=R5), RANGE (R14)
:**********************************************************************

IXAC	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	CHN,VALUE1,XD		:get starting channnel
	CLHI	CHN,ENDZFL		:check if starting channel valid?
	JGE	ICMERR			:no

	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R14,VALUE1,XD		:get range
	JE	ICMERR			:range=0?
	AR	R14,CHN			:compute end channel
	SIS	R14,1
	CLHI	R14,ENDZFL		:check if range valid?
	JL	IXAC02			:valid
	LHI	R14,ENDZFL		:not valid, truncate

IXAC02	JAL	R7,TYP80Z		:send non-error response
IXAC04	LHI	R12,1F			:don't exceed 128 byte msg limit
IXAC06	TBT	CHN,ACP,,		:channel active?
	JNFS	IXAC08			:no, don't display
	LR	R3,CHN			:yes, send Channel Number
	JAL	R9,TY80HW
	SIS	R12,1			:count this item for this message
IXAC08	AIS	CHN,1			:bump channel number
	CR	CHN,R14			:upper limit yet?
	JG	IXLRET			:yes, done
	LR	R12,R12			:not done, check for next message
	JG	IXAC06			:not yet
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGE	IXAC04			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
	J	IXAC04

	SUBTTL	IIXRAY (Display Channel Status - QC)
:	******	************************************

:**********************************************************************
:	IXQC1U - Display Active Channel Status (QC # U)
:**********************************************************************

IXQC1U	HS	0
	LIS	R12,0			:display only active channels
	LI	R11,IXQC01		:continuation point for one channel
	J	IXQC00

:**********************************************************************
:	IXQC2U - Display Range Active Channel Status (QC # # U)
:**********************************************************************

IXQC2U	HS	0
	LIS	R12,0			:display only active channels
	LI	R11,IXQC02		:continuation point for range
	J	IXQC00

:**********************************************************************
:	IXQC2 - Display Range Channel Status (QC # #)
:**********************************************************************

IXQC2	HS	0
	LIS	R12,1			:display all channels
	LI	R11,IXQC02		:set up continuation point
	J	IXQC00

:**********************************************************************
:	IXQC - Display Channel Status (QC)
:**********************************************************************

IXQC	HS	0
	LIS	R12,1			:display all channels
	LI	R11,IXQC01		:set up continuation point

IXQC00	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	CHN,VALUE1,XD		:get starting channel number
	CLHI	CHN,ENDZFL		:check if valid
	JGE	ICMERR			:too big
	JR	R11			:continue

IXQC02	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R14,VALUE1,XD		:get ending channel number
	CLHI	R14,ENDZFL		:check if valid
	JGE	ICMERR			:too big

	SR	R14,CHN			:count = end chan#-start chan#
	AIS	R14,1			:+1
	JL	ICMERR			:start chan > end chan?
	JFS	IXQC04			:start displaying

IXQC01	LIS	R14,1			:only display one channel

IXQC04	JAL	R7,TYP80Z		:send non-error response

IXQC06	HS	0			:display loop
	LR	R12,R12			:disp only active chans (with BF<>0)?
	JN	IXQC08			:no, disp all channels requested
	TBT	CHN,ACP,,		:is channel active
	JN	IXQC10			:chan not active, don't display

IXQC08	LR	R3,CHN
	JAL	R9,TY80HW		:send Channel Number
	JAL	R8,CHNLNK		:get link
	LCS	R3,2			:(immed) neighbor not found
	JFS	IXQC12
	LHI	R3,MACHNM		:(+4) INTERNAL, GET NODE NUMBER
	NHI	R3,XE0FFF		:(+8) strip HO nib from neig number
IXQC12	JAL	R9,TY80HW		:send Link
	LHL	R3,IOTAB,CHN,CHN	:destination buffer
	LR	R10,R3			:save it
	NHI	R3,3			:isolate speed bits
	JAL	R9,TY80BY		:send Speed bits
	NHI	R10,-4			:strip speed bits
	LHL	R3,BF,R10,
	JAL	R9,TY80HW		:send Termination Channel
	LR	R3,R10
	JAL	R9,TY80HW		:send Destination Buffer
	XHI	R3,4
	JAL	R9,TY80HW		:send Source Buffer
	XHI	R10,4
	L	R3,BB,R10,		:BB flag
	JAL	R9,TY80FW
	L	R3,BE,R10,		:BE flag
	JAL	R9,TY80FW
	LHL	R3,BF,R10,		:and BF
	JAL	R9,TY80HW
	LR	R2,R10
	JAL	R8,CBCCT,,
	LR	R3,R1
	JAL	R9,TY80HW		:send Byte Count
	LR	R11,R10
	SRLS	R11,1
	NHI	R11,-4			:1/2 buffer index for BUFTIM
	L	R3,SLOWC,,
	S	R3,BUFTIM,R11,
	JAL	R9,TY80FW		:send Circuit Time

	IF	REBILD
	LIS	R1,1			:tell TMCS to expect REBILD data
	JAL	R7,TYP80X
	LHI	R3,HBUFN,R11
	JAL	R9,TY80HW		:send History Buffer index
	L	R3,HSEQN+HBUFN,R11,
	JAL	R9,TY80FW		:send Current History Buffer SEQN
	XHI	R10,4
	L	R3,XSEQN,R10,
	JAL	R9,TY80FW		:send Current Transmitted SEQN
	XHI	R10,4
	L	R3,VSEQN,R10,
	JAL	R9,TY80FW		:send Current Received SEQN
	LIS	R1,1			:assume REBUILD ON
	SRLS	R10,3
	TBT	R10,CRQBSY,,
	JNFS	IXQC14
	LIS	R1,0			:REBUILD OFF code
IXQC14	JAL	R7,TYP80X
	ELSE
	JAL	R7,TYP80Z		:tell tmcs not to expect REBILD
	EI	:REBILD

	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGE	IXQC10			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message

IXQC10	HS	0			:display loop end
	AIS	CHN,1			:increment channel index
	SIS	R14,1			:decrement channel count
	JG	IXQC06			:more to do

	J	IXLRET			:done

:**********************************************************************
:	IXPM - Display Channel Performance
:	Performance Monitoring routine for user channels accepts
:	a terminating channel number, sends 16 XLAXS and TIMERS 
:	towards the other end, and computes the average round-trip
:	delay when the XLAX acks and TIMER acks return
:************************************************************************

IXPM	HS	0
	CI	XD,TTYXD		:test for TTY or ISIS-DDT user
	JE	IXPMER			:yes, illegal because of WCI-GCI race
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R3,VALUE1,XD		:get the channel number
	CLHI	R3,LNKZFL		:check range
	JGE	IXPMBC			:only legal for terminating channels
	LHL	R2,IOTAB,R3,R3		:get buffer number
	JE	IXPMBC			:error, no circuit there
	NHI	R2,-4			:strip speed bits
	LR	R13,R3			:save channel number in R13
	LHL	R5,BF,R2,		:get channel on out side
	JAL	R8,CHNLNK		:returns neighbor on out channel
	J	IXPMBC			:immediate return--no neighbor
	J	IXPMBC			:+4 return--internal termination

: 	+8 RETURN HAS NEIGHBOR NUMBER IN R3
	CLHI	R3,400			:octal 2000 is lower bound for TII
	JL	IXPMTI			:T-I neighbor--RMK can't handle 03-pair
	LIS	R10,0			:accumulator for TIMERS
	LIS	R11,0			:clear R11--accumulator for XLAXS
	LIS	R14,0F			:do 16 times
IXPMLP	LIS	R0,0

:	XLAX'S AND TIMERS ARE SENT OUT IN PAIRS
	ST	R0,ARRIVX,,		:clear time-of arrival cells
	ST	R0,ARRIVT,,		:clear time-of arrival cells

	LHL	R2,IOTAB,R13,R13	:get buffer number
	JE	IXPMBC			:something wrong, no channel
	NHI	R2,-4			:strip speed bits
	L	R9,FASTC,,		:get current time

	LIS	R1,3			:form '03'
	JAL	R8,WCI,,		:TIMER, write in '03'
	LHI	R1,TIMER		:and TIMER
	JAL	R8,WCI,,

IXPMXL	LHI	R1,XLAX			:XLAX, get XLAX
	JAL	R8,WCD,,		: and prefix it in
	LIS	R1,03
	JAL	R8,WCD,,		:prefix the '03'

IXPM02	STM	R9,XREGSV,XD		:save registers
IXPM04	JAL	R0,XRYYLD,,		:and yield to exec loop
	L	R9,XREGSV,XD		:recover time of original startup
	L	R3,ARRIVT,,		:has a timer ack returned?
	JNFS	IXPM06			:yes, go process data
	L	R3,FASTC,,		:no, have we timed out?
	SR	R3,R9			:compute delta time since startup
	CLHI	R3,12C0			:allow approximately 8 seconds per trip
	JG	IXPMBC			:error, timed out
	J	IXPM04			:still ticking, dismiss and retry
IXPM06	HS	0
	L	R3,ARRIVX,,		:have a TIMER ACK, have an XLACK too?
	JE	IXPMBC			:somethings wrong
	LM	R10,XREGSV+4,XD		:recover registers
	SR	R3,R9			:get travel time XLAX
	AR	R11,R3			:accumulate in R11
	L	R3,ARRIVT,,		:TIMER ACK time
	SR	R3,R9			:travel time TIMER
	AR	R10,R3			:accum TIMER time in R10
	SIS	R14,1			:do this 16 times
	JGE	IXPMLP			:more left

	JAL	R7,TYP80Z		:send non-error response
	LHI	R12,$A10
	LR	R2,R10			:get TIMER time (in R10) 
	DHR	R2,R12			:average
	JAL	R9,TY80HW		:send TIMER
	LR	R2,R11			:get XLAX time (in R11)
	DHR	R2,R12			:average
	JAL	R9,TY80HW		:send XLAX
	J	IXLRET			:done

IXPMBC	LIS	R1,0E
	JAL	R7,TYP80X		:send error message out
	J	IXLRET			:done

IXPMER	LA	R2,IXPMNO		:error
	JAL	R7,TYPASC
	J	XRCRLF,,
IXPMNO	SC	/"07ILLEGAL FROM DDT OR TTY!/

IXPMTI	LIS	R1,0D
	JAL	R7,TYP80X		:send error message out
	J	IXLRET			:done

	SUBTTL	IIXRAY (Display Memory - R, RA, RS, SY, RG)
:	******	*******************************************

:**********************************************************************
:	IXRDC - Display Memory
:	Address followed by 8 HW per line
:	Arg 1=starting address,	Arg 2=byte count
:**********************************************************************

IXRDC	HS	0
	LI	R10,IXRDCT		:set up continuation point
	JFS	IXRDAD

:**********************************************************************
:	IXRD - Display Memory
:	Address followed by 8 HW
:	Arg=starting address, default byte count=16d
:**********************************************************************

IXRD	HS	0
	LI	R10,IXRD16		:set up continuation point
IXRDAD	HS	0
	JAL	R8,RD80FW		:read FW arg and store in VALUE1
	L	R11,VALUE1,XD		:get the address
	THI	R11,1			:must be even address
	JN	ICMERR			:error - return
	JR	R10			:continue

IXRDCT	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R12,VALUE1,XD		:get the count
	JFS	IXRD03

IXRD16	LHI	R12,10			:default to 16 bytes

IXRD03	LIS	R6,3			:three lines max per message
IXRD04	LIS	R5,8			:eight HW per line
	LR	R3,R11
	JAL	R9,CHKMAC,,
	J	IXCHKM			:address out of range, reject!
	AHI	R3,10			:+4 =ok, check end address
	JAL	R9,CHKMAC,,		:don't read across seg boundary
	J	IXCHKM			:address out of range, reject!
	JAL	R7,TYP80Z		:+4 =ok, send non-error response
	LR	R3,R11
	JAL	R9,TY80FW		:send Address

IXRD06	LHL	R3,0,R11		:send H-Word
	JAL	R9,TY80HW
	SIS	R12,2			:decrement byte count
	JLE	IXLRET			:done
	AIS	R11,2
	SIS	R5,1
	JG	IXRD06			:not done with present line yet

	SIS	R6,1
	JG	IXRD04			:more room in this Response message?
	LH	R1,IIXNTC,XD,		:no, check for non-tmcs xray
	JGE	IXRD03			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
	J	IXRD03			:move on to next line

IXCHKM	LIS	R1,0D
	JAL	R7,TYP80X		:send Out of Range message
	J	IXLRET

:**********************************************************************
:	IXRSC - Display <count> bytes of Memory at Symbol
:**********************************************************************

IXRSC	HS	0
	LI	R12,IXRDCT		:set up continuation point
	JFS	IXRDSY

:**********************************************************************
:	IXRS - Display Memory at Symbol 
:**********************************************************************

IXRS	HS	0
	LI	R12,IXRD16		:set up continuation point

IXRDSY	HS	0
	JAL	R10,RDSYMB
	JAL	R10,SYMVAL
	J	ICMERR			:(immed) no match
	LR	R11,R3			:(+4) load the symbol value from R3
	JR	R12			:continue

:**********************************************************************
:	IXRAC - Display specified number of bytes from Absolute Memory
:**********************************************************************

	IF	1-ISIS
IXRAC	HS	0
	LI	R10,IXRACT		:set up continuation point
	J	IXRDAD

:**********************************************************************
:	IXRA - Display Absolute Memory 
:	Default 16d byte count
:**********************************************************************

IXRA	HS	0
	LI	R10,IXRA16		:set up continuation point
	J	IXRDAD

IXRACT	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R12,VALUE1,XD		:get the count
	JFS	IXRA02

IXRA16	LHI	R12,10			:default to 16d bytes

IXRA02	LHL	R2,XRACIU,,		:make sure command not in use
	JN	ICMCIU			:BUSY, tell user
	STH	XD,XRACIU,,		:mark command in use
IXRA03	LIS	R6,3			:three lines max per message
IXRA04	LIS	R5,8			:eight HW per line
	GL	ENDNOD
	CI	R11,ENDNOD-10		:address out of range?
	JLFS	IXRA05			:ok
	LIS	R0,0
	STH	R0,XRACIU,,		:mark RA command no longer in use
	J	IXCHKM			:complain - Out of Range

IXRA05	JAL	R7,TYP80Z		:send non-error response
	LR	R3,R11			:address to R3
	JAL	R9,TY80FW		:send Address

IXRA06	LR	R1,R11			:address to R1
	SVC	0F,SV.RAB		:FW returned in R1
	EXHR	R3,R1
	JAL	R9,TY80HW		:send first H-Word
	EXHR	R3,R3
	JAL	R9,TY80HW		:send second H-Word
	SIS	R12,4			:decrement byte count
	JLE	IXRA08			:done
	AIS	R11,4
	SIS	R5,2			:decrement HW count for this line
	JG	IXRA06			:more for this line

	SIS	R6,1
	JG	IXRA04			:more room in this Response message?
	LH	R1,IIXNTC,XD,		:no, check for non-tmcs xray
	JGE	IXRA03			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
	J	IXRA03			:move on to next line

IXRA08	LIS	R0,0
	STH	R0,XRACIU,,		:mark RA command no longer in use
	J	IXLRET			:done
	EI	:1-ISIS

:**********************************************************************
:	IXSY - Display Symbol Addresses (SY)
:**********************************************************************

IXSY	HS	0
	JAL	R13,XRYIN		:get character key to table into R1
	LR	R6,R1
	OHI	R6,80			:set HOB
	JAL	R7,TYP80Z		:send non-error response
	LIS	R5,0

	GL	SYMTBL

	LIS	R10,8			:init counter-8 symbols per message
IXSY02	CLHI	R6,ASCAST+80		:asterisk (2A) = display entire table
	JEFS	IXSY04

	NHI	R6,ASCUC		:assume alphabet-ensure uppercase(xDF)
	LB	R2,SYMTBL+1,R5,		:get first character
	CR	R2,R6
	JN	IXSY06			:not a match

IXSY04	LA	R2,SYMTBL,R5,
	JAL	R7,TY80AS		:send symbolic name
	L	R3,SYMTBL+8,R5,
	JAL	R9,TY80FW		:send symbol address
	SIS	R10,1			:decrement loop counter
	JG	IXSY06			:room for another symbol in this msg
	LH	R1,IIXNTC,XD		:no more room-check for tmcs/xray user
	JGE	IXSY05			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
IXSY05	LIS	R10,8			:re-initialize counter
IXSY06	AHI	R5,ADRESZ		:bump index
	CLHI	R5,SYMTSZ; GL SYMTSZ	:at end of table?
	JL	IXSY02
	J	IXLRET			:finished

:**********************************************************************
:	IXRG - Display Register Set <n>
:**********************************************************************

	IF	1-ISIS
IXRG	HS	0
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R0,VALUE1,XD		:get requested register set into R0
	NHI	R0,0F			:cut it down to size
	SVC	0F,SV.SAS		:write contents to ABSSAV

	JAL	R7,TYP80Z		:send non-error response
	LIS	R11,0			:storage area index
	LIS	R2,2			:send out 2 lines
	LIS	R10,8			: of 8 regs each
IXRG02	L	R3,ABSSAV,R11,		:read the register
	JAL	R9,TY80FW		:send a Register
	SIS	R10,1			:eight regs on this line yet?
	JG	IXRG04			:next reg if not
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGE	IXRG06			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
IXRG06	SIS	R2,1			:have we done 2 lines yet?
	JLE	IXLRET			:if yes, done - return

	LIS	R10,8			:restore line cursor
IXRG04	AIS	R11,4			:point to the next register
	J	IXRG02			:loop for next register
	EI	:1-ISIS

	SUBTTL	IIXRAY (Write Memory - W, WF, WA, WS)
:	******	*************************************

:**********************************************************************
:	IXWRC -  Write <count> bytes to Memory
:**********************************************************************

IXWRC	HS	0
	LI	R10,IXWRCT		:set up continuation point
	J	IXRDAD

:**********************************************************************
:	IXWR - Write Memory
:	Default byte count = 2
:**********************************************************************

IXWR	HS	0
	LI	R10,IXWR02		:set up continuation point
	J	IXRDAD

IXWRCT	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R12,VALUE1,XD		:get the count
	JFS	IXWR04

IXWR02	LIS	R12,2			:default to 2 bytes

IXWR04	LR	R3,R11
	JAL	R9,CHKMAC,,		:get MAC approval
	J	IXCHKM			:error if immediate return

	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R3,VALUE1,XD		:get new value
	STH	R3,0,R11		:store the value
	AIS	R11,2
	SIS	R12,2			:decrement count
	JG	IXWR04			:some left
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET

:**********************************************************************
:	IXWRFC - Write <count> bytes to Memory a F-Word at a time
:***********************************************************************

IXWRFC	HS	0
	LI	R10,IXWRFT		:set up continuation point
	J	IXRDAD

:**********************************************************************
:	IXWRF - Write  Fullword into Memory
:**********************************************************************

IXWRF	HS	0
	LI	R10,IXWRF2		:set up continuation point
	J	IXRDAD

IXWRFT	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R12,VALUE1,XD		:get the count
	JFS	IXWRF4

IXWRF2	LIS	R12,4			:default to 4 bytes

IXWRF4	LR	R3,R11
	JAL	R9,CHKMAC,,		:get MAC approval
	J	IXCHKM			:error if immediate return

	JAL	R8,RD80FW		:read FW arg and store in VALUE1
	L	R3,VALUE1,XD		:get new value in R3
	ST	R3,0,R11		:store the value
	AIS	R11,4
	SIS	R12,4			:decrement count
	JG	IXWRF4			:some left
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET

:**********************************************************************
:	IXWA - Write FW to Absolute Memory
:**********************************************************************

	IF	1-ISIS
IXWA	HS	0
	JAL	R8,RD80FW		:read FW arg and store in VALUE1	
	L	R11,VALUE1,XD		:get the address
	THI	R11,1			:must be even address
	JN	ICMERR			:error - return

	CI	R11,ENDNOD-4		:can't be greater than available memory
	JG	IXCHKM			:if so, complain

	JAL	R8,RD80FW		:read FW arg and store in VALUE1
	L	R3,VALUE1,XD		:get Value into R3
	SVC	0F,SV.WFA		:write FW R3 value into Abs Add in R11
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET
	EI	:1-ISIS

:**********************************************************************
:	IXWS - Write Memory at Symbol
:	If trying to write, must be one of the following symbols
:**********************************************************************

IXWS	HS	0
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R7,VALUE1,XD		:get the symbol code
	LI	R11,CRYDIS		:load address
	CHI	R7,1			:check for CRYDIS
	JE	IXWS02			:yes
	LI	R11,ASYDIS		:no, reload
	CHI	R7,2			:check for ASYDIS
	JE	IXWS02			:yes
	LI	R11,REBDIS		:no, reload
	CHI	R7,3			:check for REBDIS
	JE	IXWS02			:yes
	J	ICMERR			:no, error

IXWS02	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R3,VALUE1,XD		:get value
	STH	R3,0,R11		:store the value
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET

	SUBTTL	IIXRAY (Restart Node - SN)
:	******	**************************

	IF	1-ISIS

:**********************************************************************
:	IXSN - Restart Node Code (SN)
:**********************************************************************

IXSN	HS	0
	LIS	R0,0
	STH	R0,CRSHID		:manual restart Crash Code
	ST	R0,CRSHPS		:store Crash PSW
	ST	R0,CRSHAD		:store Crash Address
	JAL	R9,GMTCAL		:returns current time in GMTNOW
	L	R0,GMTNOW,,
	ST	R0,CRSHTM		:store Crash Time
	STH	XD,XDSAVE,,		:CTENTR clobbers R15!
	JAL	R10,CTENTR,,		:make Crash Table Entry
	LHL	XD,XDSAVE,,		:restore XD

	CI	XD,TTYXD		:TTY user?
	JE	IXSN02			:yes

	J	RESTRT,,		:GO RESTART

IXSN02	LA	R1,ANIPSW		:Initial PSW
	SVC	0F,SV.RAB		:Read FW from Abs Address in R1
	LR	R3,R1			:return it in R1
	LA	R11,ANCPSW		:Current PSW
	SVC	0F,SV.WFA		:Write FW from R3 into Abs Add in R11
	LA	R1,ANIPSW+4
	SVC	0F,SV.RAB
	LR	R3,R1
	LA	R11,ANCPSW+4
	SVC	0F,SV.WFA

	LIS	R3,0
	LA	R11,ANFLGS		:clear Node Flags - Restart Node Code
	SVC	0F,SV.WHA		:Write HW from R3 into Abs Add in R11
	J	XRPRMT,,

	EI	:1-ISIS

	SUBTTL	IIXRAY (BORI Zap a Link - BZ)
:	******	*****************************

:**********************************************************************
:	IXBZ - BORI Zap a Link (BZ)
:	Sets bit in BORZAP array corresponding to the
:	neighbor number argument
:**********************************************************************

IXBZ	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R1,VALUE1,XD		:get neighbor number into R1
	JAL	R9,XFNDLK		:Find Link Number
	J	ICMERR			:not there
	LHL	KN,XKNSAV,XD		:recover Link#
	SBT	KN,BORZAP		:set the zap bit
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET			:and return

	SUBTTL	IIXRAY (Display CRYPTO Messages - CD, CL, CM, SM)
:	******	****** ******************************************

:**********************************************************************
:	IXCDY - Auto CRYPTO On
:**********************************************************************

IXCDY	HS	0
	LIS	R2,0
	STH	R2,CRYMOD,XD		:make entry
	JAL	R7,TYP80Z		:send non-error response
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGE	XPRMPT,,		:don't send IIX messages!
	JAL	R7,XRYTIX		:send TIIX right away to avoid time out
	LH	R1,IIXCID,XD,		:get Command ID
	STH	R1,IIXAID,XD,		:store it for Auto CRYPTO responses
	J	IXLOOP			:test for CRYPTO...

:**********************************************************************
:	IXCDN - Auto CRYPTO Off
:**********************************************************************

IXCDN	HS	0
	LIS	R2,1
	STH	R2,CRYMOD,XD		:make entry and fall thru
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET			:and return

:**********************************************************************
:	IXCLH -	Display Last <n> Hours CRYPTO Messages
:**********************************************************************

IXCLH	HS	0
	LHI	R6,$A3600		:User wants last N hours worth
	JFS	IXCLM2

:**********************************************************************
:	IXCLM - Display Last <n> Minutes of CRYPTO Messages
:**********************************************************************

IXCLM	HS	0
	LHI	R6,$A60			:User wants last N minutes worth
IXCLM2	HS	0
	JAL	R10,IXCP			:go compute out pointer
	J	IXCL04

:**********************************************************************
:	IXCLC - Display Last <n> CRYPTO Messages
:**********************************************************************

IXCLC	HS	0
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R3,VALUE1,XD		:get count
	JFS	IXCL02
 
:**********************************************************************
:	IXCL - Display Last 10x CRYPTO Messages
:**********************************************************************

IXCL	HS	0
	LHI	R3,10			:default 16d messages
IXCL02	HS	0
	LHL	R2,CRYPRI
	SLLS	R3,4			:User wants last N messages
	NHI	R3,CRYPRS-1
	SR	R2,R3
	JGEFS	IXCL04
	AHI	R2,CRYPRS
IXCL04	STH	R2,CRYPTU,XD
	LIS	R14,0			:output all messages
	LCS	R12,1			:enable all messages
	JAL	R5,IXCT
	J	IXLRET

:**********************************************************************
:	IXCMH - Display Last <n> Hours CRYPTO Messages by Type
:**********************************************************************

IXCMH	HS	0
	LHI	R6,$A3600		:wants last <n> hours worth
	JFS	IXCMM2

:**********************************************************************
:	IXCMM - Display Last <n> Minutes CRYPTO Messages by Type
:**********************************************************************

IXCMM	HS	0
	LHI	R6,$A60			:wants last <n> minutes worth

IXCMM2	HS	0
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R1,VALUE1,XD		:get Message Type
	STB	R1,XRSAVE+4,XD		:save for later
	JAL	R10,IXCP		:Get CRYPTU to R2
	JFS	IXCM02

:**********************************************************************
:	IXCM - Display CRYPTO Messages by Type (CM)
:**********************************************************************

IXCM	HS	0
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R1,VALUE1,XD		:get Message Type
	STB	R1,XRSAVE+4,XD		:save for later
	LHL	R2,CRYPRI		:Do all messages
	AHI	R2,10
	NHI	R2,CRYPRS-1
IXCM02	HS	0
	STH	R2,CRYPTU,XD
	LI	R1,CRYMSK,XD		:Destination pointer in R1 
	LHI	R2,10			:16d HW's of CRYMSK to zero
	JAL	R8,HCLEAR,,		:clear the mask array

	LB	R1,XRSAVE+4,XD		:get Message Type
	SBT	R1,CRYMSK,XD		:enable the Message Type

	LIS	R12,1			:indicator to IXCT to use Mask
	LHI	R14,0			:send as many as needed
	JAL	R5,IXCT
	J	IXLRET

:**********************************************************************
:	IXCT - Send contents of Cryptogram Buffer
:	IXCT00 - Entry from main command loop for auto CRYPTO
:	R12	=	Display only messages masked in CRYMSK
:			All messages  enabled if <0
:	R14	=	-(Number of messages to type). IF >= 0
:			messages typed until Empty PTR = Fill PTR
:**********************************************************************

IXCT	HS	0
	JAL	R7,TYP80Z		:send non-error response
IXCT00	HS	0
	LHL	R10,CRYPTU,XD		:get the Out PTR
IXCT01	LIS	R6,4			:don't exceed 128 byte message
IXCT02	CLH	R10,CRYPRI		:equal In PTR?
	JER	R5			:yes,RETURN

	LB	R11,CRYPRB+CRYTYP,R10,	:Get message type

	LR	R12,R12			:display all messages?
	JLFS	IXCT04			:yes

	TBT	R11,CRYMSK,XD		:no,only those enabled in CRYMSK array
	JE	IXCT06			:this isnt one

IXCT04	CLHI	R11,CRYMTZ/2		:avoid crash,check for valid index
	JG	IXCT06

	L	R3,CRYPRB+CRYGMT,R10,	:get cryptogram time and
	SRLS	R3,7			:dump FASTC bits
	JAL	R9,TY80FW		:send Time
	LHL	R3,CRYPRB+CRYFAS,R10,	:16 bits of FASTC
	JAL	R9,TY80HW		:send FASTC
	LB	R3,CRYPRB+CRYFLG,R10,
	JAL	R9,TY80BY		:send Bit Flags
	LBR	R3,R11			:get message type into R3
	JAL	R9,TY80BY		:send Message Type
	LB	R9,CRYPRB+CRYFLG,R10,	:check for 0 flags
	JE	IXCT10			:no data

	LIS	R11,0			:initialize index into Data Flag Array
IXCT08	TBT	R11,CRYPRB+CRYFLG,R10,	:send the HW of Data?
	JE	IXCT12			:no

	SLLS	R11,1			:HW index
	LHL	R3,CRYPRB+CRYHW0,R10,R11
	JAL	R9,TY80HW		:send H-Word of Data
	SRLS	R11,1			:restore Flag index
	JFS	IXCT14

IXCT12	LIS	R3,0			:no Data, but TMCS is counting...
	JAL	R9,TY80HW		:send HW of zero
IXCT14	AIS	R11,1			:next HW
	CLHI	R11,4			:check counter
	JL	IXCT08			:next
	JFS	IXCT05			:all done with this message
IXCT10	LIS	R3,0			:no Data, but TMCS is counting...
	JAL	R9,TY80HW		:send 4 HW's of zero
	JAL	R9,TY80HW
	JAL	R9,TY80HW
	JAL	R9,TY80HW

IXCT05	SIS	R6,1			:decrement - message sent
IXCT06	LHL	R10,CRYPTU,XD
	AHI	R10,10
	NHI	R10,CRYPRS-1		:update index
	STH	R10,CRYPTU,XD
	AIS	R14,1			:increment number of messages sent
	JER	R5			:if 0, all done

	LR	R6,R6
	JG	IXCT02			:more room in this Response message?
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGE	IXCT01			:don't send IIX messages!
	JAL	R8,XRYRES		:send another response message
	J	IXCT01

:**********************************************************************
:	IXCP	Computes CRYPTU for CRYLST and CRYMSG
:	Expects:  R6 = $A60, if minutes - $A3600 if hours
:	Returns:  R2 = CRYPTU
:	Clobbers: R0,R1,R2,R3,R4,R5,R8,R9,R13
:	Links on: R10
:**********************************************************************

IXCP	HS	0
	LHL	R2,CRYPRI		:Get crypto pointer
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R3,VALUE1,XD		:get number
	MHR	R6,R3			:Convert to seconds
	JAL	R9,GMTCAL,,		:Get current time to GMTNOW
	L	R3,GMTNOW,,		:Current time + 7 bits of FASTC
	SRLS	R3,7			:Get rid of FASTC
	SR	R3,R6			:We want to go back to this time
	JGE	IXCP02			:OK
	J	ICMERR			:??

IXCP02	SHI	R2,10			:Look at next oldest message
	JGEFS	IXCP04

	AHI	R2,CRYPRS		:Wrapped

IXCP04	CLH	R2,CRYPRI		:Back to where we started?
	JE	IXCP08			:Yes, no message in time frame

	L	R5,CRYPRB+CRYGMT,R2,	:Get message timestamp
	AIS	R5,1			:Make sure it's not -1
	JEFS	IXCP06			:It is, done
	SIS	R5,1			:Restore timestamp
	SRLS	R5,7			:Dump FASTC
	CLHI	R5,$A1440		:At least a day's worth
	JL	IXCP02			:No, keep trying
	CR	R3,R5			:Are we in our time frame?
	JL	IXCP02			:No, keep trying

IXCP06	AHI	R2,10			:Move forward one
	NHI	R2,CRYPRS-1		:Correct for wrap
	JR	R10			:Continue

IXCP08	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET			:return

:**********************************************************************
:	IXSM - Enable All CRYPTO Messages
:**********************************************************************

IXSM	HS	0
	LIS	R0,0			:clear all bits - enable all msgs
	LIS	R1,0F			:clear 10x HW
IXSM02	STH	R0,CRYARY,R1,R1, 	:enable all messages
	SIS	R1,1			:next HW
	JGEBS	IXSM02			:do more
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET			:all done

:**********************************************************************
:	IXSM0 - Disable <type> CRYPTO Messages
:**********************************************************************

IXSM0	HS	0
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R0,VALUE1,XD	 	:get Message Number
	CLHI	R0,100			:range check
	JGE	ICMERR			:too big
	SBT	R0,CRYARY,,		:off
	JAL	R7,TYP80Z		:non-error response
	J	IXLRET

:**********************************************************************
:	IXSM1 - Enable <type> CRYPTO Messages
:**********************************************************************

IXSM1	HS	0
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R0,VALUE1,XD	 	:get Message Number
	CLHI	R0,100			:range check
	JGE	ICMERR			:too big
	RBT	R0,CRYARY,,		:on
	JAL	R7,TYP80Z		:non-error response
	J	IXLRET

	SUBTTL	IIXRAY (Delay Measurement - DD, DL, DB, DE)
:	******	*******************************************************

:**********************************************************************
:	IXDDX - Display Delay Measurement Statistics <index>
:**********************************************************************

IXDDX	HS	0
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R6,VALUE1,XD		:get Index
	JL	ICMERR
	CLHI	R6,TINTCH/2		:check size
	JGE	ICMERR			:too large
	JFS	IXDD02

:**********************************************************************
:	IXDD - Display Delay Measurement Statistics (DD)
:**********************************************************************

IXDD	HS	0
	LIS	R6,0			:default arg = 0
IXDD02	JAL	R7,TYP80Z		:send non-error response
	LHI	R7,DLYBSZ		:DLY Data Block Size
	MHR	R6,R7			:times Index = Offset into table area
	AI	R6,DLYBSE		:address of Data Block
	LH	R1,DLYINT,,		:get Time Interval
	LHL	R10,DLYFIL,R6		:get Fill
	JEFS	IXDD04			:skip if zero
	AIS	R10,1			:if non-zero, add in clock
IXDD04	AIS	R10,1
	SLLS	R10,5			:mult by 32
	LIS	R0,0
	STH	R0,XDLTMP,,
	AIS	R1,8
	SBT	R1,XDLTMP,,
	LHL	R3,XDLTMP,,
	SLLS	R3,6
	JAL	R9,TY80HW		:send Time
	LR	R2,R10
	DH	R2,XDLTMP,,
	JAL	R9,TY80HW		:send CPS

	LIS	R5,0			:send 4 HW
IXDD06	LHL	R3,DLSTAT,R6,R5		:STAT, FLAG, HWF, PTR
	JAL	R9,TY80HW
	AIS	R5,2
	THI	R5,7			:done?
	JNBS	IXDD06			:no
	LHL	R2,DLYAV1,R6		:get First Average
	JAL	R9,FSTMSC		:convert to MS (in R3)
	JAL	R9,TY80HW		:send AVE1
	LHL	R2,DLYAV2,R6		:same for Second Average
	JAL	R9,FSTMSC
	JAL	R9,TY80HW		:send AVE2
	LHL	R3,NODCNT,R6		:Node Count
	LR	R5,R3			:save it
	SRLS	R3,1			:divide by 2
	JAL	R9,TY80BY		:tell tmcs what to expect
	LR	R10,R6
IXDD08	LHL	R3,NODLST,R10		:next node
	AIS	R10,2
	SIS	R5,2			:decrement
	JLFS	IXDD10			:all done
	NHI	R3,XE0FFF		:strip HO nib from Node #
	JAL	R9,TY80HW		:send Node #
	JBS	IXDD08

	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGE	IXDD10			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message

:	CONVERT TO MS AND SEND 32 SAMPLES, 8 AT A TIME
IXDD10	LIS	R11,0			:to count # HW's typed
IXDD12	LHL	R2,DLYTBL,R6,R11	:get a sample value (FASTC)
	JAL	R9,FSTMSC		:convert to MS (R3)
	JAL	R9,TY80HW		:send Sample
	AIS	R11,2			:point to next HW
	THI	R11,3F			:done 64 bytes (32 HW)?
	JE	IXLRET			:all done

	J	IXDD12			:no, do next HW

:**********************************************************************
:	IXDLR - Build Data Loopback "back and forth" Circuit (DL R)
:**********************************************************************

IXDLR	HS	0
	TS	VALUE1+4,XD		:Flag for later use
	JFS	IXDL02

:**********************************************************************
:	IXDL - Build Data Loopback Circuit (DL)
:	Constructs a closed circuit that passes through all nodes
:	in the argument list.  Initial 'Fill' bytes are put in the outbound
:	buffer, and they subsequently move 'round and 'round the loop.
:	The CPS rate they generate (measured with the KS and NS commands)
:	indicate the processing speeds of the nodes included in the
:	circuit.
:************************************************************************

:	local equates for needle flag bits
:PRTYBT	EQ	100			:priority bit
:TPCLA	EQ	00			:throughput class A
:TPCLB	EQ	10			:throughput class B
:TPCLC	EQ	20			:throughput class C
:TPCLD	EQ	30			:throughput class D

IXDL	HS	0
	LIS	R0,0
	STH	R0,VALUE1+4,XD		:clear Flag
IXDL02	LHL	R0,INTLPF,,		:currently only 1 loopback is supported
	JN	ICMERR			:already one there, error
	TS	XLUPFL,,		:set Flag and jump to IXDB code
	J	IXDB00

:**********************************************************************
:	IXDLXR - Build Data Loopback "back and forth" Circuit <index>
:**********************************************************************

IXDLXR	HS	0
	TS	VALUE1+4,XD		:set Flag
	JFS	IXDLX2

:**********************************************************************
:	IXDLX - Build Data Loopback Circuit <index>
:**********************************************************************

IXDLX	HS	0
	LIS	R0,0
	STH	R0,VALUE1+4,XD		:clear Flag
IXDLX2	LHL	R0,INTLPF,,		:currently only 1 loopback is supported
	JN	ICMERR			:already one there, error
	TS	XLUPFL,,		:set Flag
	JFS	IXDBX2			:jump to IXDBX code

:**********************************************************************
:	IXDBXR - Build Delay Measurement "back and forth" Circuit <index>
:**********************************************************************

IXDBXR	HS	0
	TS	VALUE1+4,XD		:set Flag
	JFS	IXDBX2

:**********************************************************************
:	IXDBX - Build Delay Measurement Circuit <index>
:**********************************************************************

IXDBX	HS	0
	LIS	R0,0
	STH	R0,VALUE1+4,XD		:clear Flag
IXDBX2	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R6,VALUE1,XD		:get DB-Index
	CLHI	R6,TINTCH/2
	JGE	ICMERR			:argument is too large
	JFS	IXDB02

:**********************************************************************
:	IXDBR - Build Delay Measurement "back and forth" Circuit
:**********************************************************************

IXDBR	HS	0
	TS	VALUE1+4,XD		:set Flag
	JFS	IXDB00

:**********************************************************************
:	IXDB - Build Delay Measurement Circuit
:	Command handler to input parameters for round-trip delay
:	measurement
:**********************************************************************

IXDB	HS	0
	LIS	R0,0
	STH	R0,VALUE1+4,XD		:clear flag
IXDB00	LIS	R6,0			:default index = 0
IXDB02	HS	0
	LHL	R13,INTUSE		:make sure we have a channel
	XHI	R13,0FFFF
	JFFOH	R13,IXDB04
	J	IXDBER			:no,none
IXDB04	CLHI	R14,TINTCH		:make sure channel number's in range
	JGE	IXDBER			:no, we have no channels
	STH	R6,INTNDX,R14,R14	:store DB-Index by INTHST Chan#
	LR	R7,R6			:save Index for later use
	LHI	R6,DLYBSZ		:DLY Data Block Size
	MHR	R6,R7			:times Index = Offset into Table Area
	AI	R6,DLYBSE		:form Offset to this Index
	LH	R2,DLSTAT,R6		:make sure it is available
	JG	IXDBER			:status of 1 means it is in use
	STH	R14,DLYCHN,R7,R7	:DELAY # to INT HST CHN# PERMUTER TBL
	STH	R6,CHNDLY,R14,R14	:CHN # to DELAY ADDRESS PERMUTER TABLE
	LHI	R2,8080+TPCLD		:make sure Flags are never zero
	OH	R2,DLYFLG,R6
	STH	R2,DLYFLG,R6
	LR	R7,R7			:DLY CHN Index 0?
	JNFS	IXDB06			:no, go read args

:	Default Priority, Thruput Class, Byte Fill, Rate
	LHI	R2,8080+TPCLD		:PRIORITY 0 Flags--THRUPUT CLASS 3
	STH	R2,DLYFLG,R6
	LIS	R2,0
	STH	R2,DLYFIL,R6		:Default 0 HW FILL
	LIS	R2,3
	STH	R2,DLYINT		:Default RATE = 3 (1 SEC)
	J	IXDB12			:go read NODE LIST

:	Get and set Priority
IXDB06	JAL	R8,RD80BY		:get byte arg and store in VALUE1
	LHI	R2,8080+TPCLD		:Default Flags (HIGH-SPEED)
	LB	R3,VALUE1,XD		:get argument
	JLEFS	IXDB08			:<= 0 means not PRIORITY
	OHI	R2,PRTYBT		:set PRIORITY Bit
IXDB08	STH	R2,DLYFLG,R6		:and store FLAG

:	Get and set TP Class
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R3,VALUE1,XD		:get TP Class limit
	SLLS	R3,4			:shift arg into speed bits position
	CLHI	R3,TPCLA		:can't be less than class A (0)
	JL	ICMERR
	CLHI	R3,TPCLD		:nor more than class D (3)
	JG	ICMERR
	LHL	R2,DLYFLG,R6
	NHI	R2,0FFFF-30		:clear the speed bits field
	AR	R3,R2			:add in the new speed bits
	STH	R3,DLYFLG,R6		:and write the new needle flags

:	Get and set Byte Fill
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R3,VALUE1,XD		:get Byte Fill
	SRLS	R3,1			:convert Bytes to HW
	STH	R3,DLYFIL,R6

:	If DB, get and set Rate
	LH	R0,XLUPFL,,		:is this special Loopback CRQ?
	JL	IXDB12			:yes, leave time interval alone
	JAL 	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R3,VALUE1,XD		:get Rate
	NHI	R3,7			:keep just lower 3 bits

	IF	ISIS
	CLHI	R3,7			:ISIS doesn't get a Rate of 7
	JNFS	IXDB10
	LIS	R3,6
IXDB10	HS	0
	EI	:ISIS

	STH	R3,DLYINT,,		:store away Rate

:	Get T-II Node List
IXDB12	LH	R1,VALUE1+4,XD		:check if 'R' type (FFFF)?
	JGE	IXDB16			:no

	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R4,VALUE1,XD		:get desired Node #
	CLHI	R4,400			:ensure T-II Nodes only
	JL	ICMERR			:no good, reject
	LHI	R5,$A12			:yes, expand using Node # in R4
	LHL	R3,MACHID+2,,		:our Node Number stored in octal
	JAL	R9,OCTHXR		:convert to hex in R3
IXDB14	STH	R4,NODLST,R5,R6		:desired Node
	STH	R3,NODLST+2,R5,R6	:us
	SIS	R5,4
	JGEBS	IXDB14			:more
	LHI	R2,$A16			:simulate 8 arguments
	STH	R2,NODCNT,R6		:store in Node Count field
	J	IXDB20

IXDB16	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R2,VALUE1,XD		:get count of Node numbers
	SLLS	R2,1			:make it twice # of Nodes
	STH	R2,NODCNT,R6		:store in Node Count field
	LIS	R5,0
IXDB18	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R4,VALUE1,XD		:get desired Node #
	CLHI	R4,400			:ensure T-II Nodes only
	JL	ICMERR			:no good, reject
	STH	R4,NODLST,R5,R6		:store Node #
	SIS	R2,2			:decrement Node Count
	JLE	IXDB20			:done reading
	AIS	R5,2			:increment index
	J	IXDB18

IXDB20	JAL	R7,TYP80Z		:send non-error response
	LIS	R4,1
	STH	R4,DLSTAT,R6		:mark new status: Needle Requested
	LIS	R0,0
	STH	R0,DLYPTF,R6		:zero the Fill Pointer
	STH	R0,DLYAV1,R6
	STH	R0,DLYAV2,R6
	LHI	R2,20			:clear Sample Area so as not to
	LI	R1,DLYTBL,R6		:not to confuse poor user in the
	JAL	R8,HCLEAR,,		:early going
	SBT	R14,INTUSE		:mark the Channel in Use
	LHI	CHN,INTZFL,R14		:pass Absolute Channel Number to MAKNDL
	JAL	R10,MAKNDL,,		:go Make Needle
	LH	R0,XLUPFL,,		:Is this a Loopback CRQ?
	JL	IXDB22			:yes

	LHI	R0,DLYREC-SEG1		:get Dispatch Address for this CHN
	STH	R0,INTDSP,R14,R14	:and store into INTHST Dispatch Array
	SBT	R14,INTDRF		:set the Delay Receiver CRQ Flag
	LHI	R1,ASCD			:write Function Byte after Needle
	JAL	R8,WCI,,		:...Buffer # was set up in MAKNDL
	LHL	R1,DLYFIL,R6		:also get # of Fill HW
	JAL	R9,WCIE,,		:and send after Needle
	EXBR	R1,R1			:move high order byte for WC
	JAL	R9,WCIE,,		:and send after needle

:	CREATOR OF DLY MSMT CIRCUIT IS OWNER
	LHL	R6,INTNDX,R14,R14	:read DB-Index from array by CHAN#
	AR	R6,R6			:double for HW offset
	ST	XD,DB0USE,R6,R6		:identify creator in word array
	J	IXLRET			:all done

IXDB22	LHI	R0,DLYERR-SEG1
	STH	R0,INTDSP,R14,R14	:Dispatch Address = Bit Bucket
	SBT	R14,INTLPF		:mark this Channel as Loopback one
	LHI	R1,ASCL^10+ASCL		:function byte and fillchars = 'L'
	JAL	R8,WCI,,		:R2 was set up in MAKNDL
	LHL	R10,DLYFIL,R6		:Fill number of HW
IXDB24	JAL	R9,WHWI,,		:write into Buffer after Needle
	SIS	R10,1
	JGBS	IXDB24
	LIS	R0,0
	STH	R0,XLUPFL,,		:clear Flag

:	CREATOR OF DLY MSMT CIRCUIT IS OWNER
	LHL	R6,INTNDX,R14,R14	:recover DLY CHN Index
	AR	R6,R6			:double to HW offset
	ST	XD,DB0USE,R6,R6		:identify creator in word array
	J	IXLRET			:all done

IXDBER	LIS	R1,0D			:out of int hst chan/index in use
	JAL	R7,TYP80X		:send error response
	J	IXLRET

:**********************************************************************
:	IXDEX - Terminate Delay Measurement or Loopback Circuit <index>
:**********************************************************************

IXDEX	HS	0
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R6,VALUE1,XD		:get Index
	CLHI	R6,TINTCH/2
	JGE	ICMERR			:too big
	JFS	IXDE02

:**********************************************************************
:	IXDE - Terminate Delay Measurement Circuit (DE)
:	The CRQ is zapped in the direction that the needle originally took
:**********************************************************************

IXDE	HS	0
	C	XD,DB0USE,,		:did this user set it up?
	JN	ICMERR			:no, can't end it
	LIS	R6,0			:default Index = 0
IXDE02	HS	0

:	CREATOR OF DLY MSMT CIRCUIT IS THE OWNER
	AR	R6,R6			:byte Index to HW Index
	C	XD,DB0USE,R6,R6		:INDX to FW TBL--who owns this CHAN
	JN	ICMERR			:only the creator can zap it
	SRLS	R6,1			:back to byte Index

	LR	R5,R6			:set up to get Delay Circuit Status
	LHI	R6,DLYBSZ		:Delay Data Block Size
	MHR	R6,R5			:R6=Offset into Table Area
	AI	R6,DLYBSE		:R6=points to Data Area for this Index
	LH	R4,DLSTAT,R6		:Circuit up (STAT = 1)?
	JLE	ICMERR			:no
	LH	R5,DLYCHN,R5,R5		:INT HST Channel Index
	TBT	R5,INTDRF		:make sure this CHN is being used
	JNFS	IXDE04			:ok
	TBT	R5,INTLPF		:not Delay Measurment, perhaps Loopback
	JE	ICMERR			:no, nothing there
IXDE04	LR	R4,R5			:put INT HST CHAN Index in R4
	AHI	R5,INTZFL		:Absolute CH # in R5
	LHL	R2,IOTAB,R5,R5		:and the Outgoing Buffer in R2
	JE	ICMERR			:nothing there, already been zapped
	NHI	R2,-4			:strip Sign Bits--switch to Incoming
	XHI	R2,4			:Buffer (INTZAP will switch back)
	JAL	R10,INTZAP,,		:zap the INT HOST CRQ
	LCS	R0,2
	STH	R0,DLSTAT,R6		:note we've done the zap
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET

	SUBTTL	IIXRAY (Display Patch History Table - PQ)
:	******	*****************************************

:**********************************************************************
:	IXPQ - Display Patch History Table (PQ)
:**********************************************************************

IXPQ	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LHI	R3,VERSION
	JAL	R9,TY80FW		:send Version number

	LIS	R14,0			:Patch History Table index
	LIS	R6,5			:don't exceed 128 byte Response msg
IXPQ02	CLHI	R14,PHSIZE		:at end of table?
	JGE	IXLRET			:yes, exit
	LB	R0,PATHIS+1,R14,	:check for year 1900 (null entry)
	JE	IXLRET			:end, exit
	SIS	R6,1			:decrement count
	JG	IXPQ06			:more room in this Response msg?
	LH	R1,IIXNTC,XD,		:no, check for non-tmcs xray
	JGE	IXPQ04			:don't send IIX messages
	JAL	R8,XRYRES		:send another Response message
IXPQ04	LIS	R6,4			:reset counter
	
IXPQ06	LHL	R3,PATHIS,R14,
	JAL	R9,TY80HW		:send Year (19xx)
	LHL	R3,PATHIS+2,R14,
	JAL	R9,TY80HW		:send Date (MODY)
	LHL	R3,PATHIS+4,R14,
	JAL	R9,TY80HW		:send Time (HhMm)
	LA	R2,PATHIS+5,R14,	:point to Username-1
	LIS	R0,0A			:10 char Username
	JAL	R7,TY80A1		:send Username

	AHI	R14,10			:point to next PATHIS cell
	J	IXPQ02			:and try again

	SUBTTL	IIXRAY (Display Trace Link/Line Events - TL,TN,TM)
:	******	**************************************************

	IF	TSTSZE			:Disabled with NTLV Option in TYMFILE

:**********************************************************************
:	IXTLN -	Set TSLINK to Enable Link Trace function.
:	Link to be traced is single argument <neighbor#>.
:**********************************************************************

IXTLN	HS	0
	LHL	R1,TSLINK		:make sure we're not already
	JN	IXTL			:tracing - show link being traced
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R1,VALUE1,XD		:get the neighbor#
	STH	R1,TSLINK		:store it in TSLINK
	J	IXTL			:send it for display, too

:**********************************************************************
:	IXTL0 - Reset TSLINK to Disable Link Trace function (TL0)
:**********************************************************************

IXTL0	HS	0
	LIS	R1,0
	STH	R1,TSLINK

:**********************************************************************
:	IXTL - Display Link Trace parameter (TL)
:**********************************************************************

IXTL	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LHL	R3,TSLINK
	JAL	R9,TY80HW		:send link neighbor#
	J	IXLRET			:done

:**********************************************************************
:	IXTNL - Set TSLINE to Enable Line Trace function.
:	Line to be traced is single argument <line#>.
:	Trace Line will trace only header received events on unassigned
:	lines (only in Foreground Table).
:**********************************************************************

IXTNL	HS	0
	LH	R1,TSLINE		:make sure we're not 
	JGE	IXTN			:tracing - show line being traced
	JAL	R8,RD80BY		:read Byte arg and store in VALUE1
	LB	R3,VALUE1,XD		:get the line#
	SLLS	R3,1			:store 2*line#
	STH	R3,TSLINE		:store it in TSLINE
	J	IXTN			:send it for display, too

:**********************************************************************
:	IXTNF - Reset TSLINE to Disable Line Trace function 
:**********************************************************************

IXTNF	HS	0
	TS	TSLINE

:**********************************************************************
:	IXTN - Display Line Trace parameter (TN)
:**********************************************************************

IXTN	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LH	R3,TSLINE
	JLFS	IXTN2			:value is FFFF
	SRLS	R3,1			:display true line#
IXTN2	JAL	R9,TY80HW		:send line#
	J	IXLRET			:done

:**********************************************************************
:	IXTMB - Display Background Table (TSBTBL) data gathered from
:   	TSLINK/TSLINE option in convenient form
:**********************************************************************

IXTMB	HS 	0
	LHL	R12,TSBPTR		:R12 = Background Table Pointer
	STH	R12,TSPBAK,,		:Table Pointer Backup
	LI	R11,TSBTBL		:R11 = Background Table Address
	JFS	IXTM

:**********************************************************************
:	IXTMF - Display Foreground Table (TSFTBL) data gathered from
:	TSLINK/TSLINE option in  convenient form
:**********************************************************************

IXTMF	HS	0
	LHL	R12,TSFPTR		:R12 = Foreground Pointer
	STH	R12,TSPBAK,,
	LI	R11,TSFTBL		:R11 = Foreground Table Address

IXTM	LHL	R14,TSLINK		:save potential Neighbor Number
	EXHR	R14,R14			:in HO HW
	LHL	R2,TSLINE		:and Traced Line
	OR	R14,R2			:in LO HW

	ST	R14,XTSSAV,,		:save neig and line #s in case of ^C
	LCS	R0,1
	STH	R0,TSLINE		:turn off Line Trace while displaying
	LIS	R0,0
	STH	R0,TSLINK		:turn off Link Trace while displaying

	JAL	R7,TYP80Z		:send non-error response
IXTM00	LIS	R10,8			:don't exceed 8 lines for 128 byte msg
IXTM01	LB	R1,0,R12,R11		:get EVENT byte
	JAL	R7,TYP80X		:send LO nibble
	LIS	R5,5			:send 5 bytes
	LA	R6,1,R11,R12
	JAL	R8,TY80NB
	LHL	R3,6,R11,R12		:get 2 more bytes of FASTC
	JAL	R9,TYPHNS		:and send them

	SIS	R12,TSESZE		:back up one entry
	JGEFS	IXTM02			:non-negative?
	AHI	R12,TSTSZE		:negative, correct for wrap
IXTM02	CLH	R12,TSPBAK,,		:come full circle?
	JEFS	IXTM03			:yes
	SIS	R10,1			:no, keep displaying
	JG	IXTM01			:more room in this Response msg?
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGE	IXTM00			:don't send IIX messages!
	JAL	R8,XRYRES		:send another response message
	J	IXTM00

IXTM03	STH	R14,TSLINE		:restore TSLINE cell
	EXHR	R14,R14			:and
	STH	R14,TSLINK		:restore TSLINK cell
	LIS	R14,0
	ST	R14,XTSSAV,,		:clear save cell
	J	IXLRET			:done with display, return

	EI	:TSTSZE

	SUBTTL	IIXRAY (Display Semi-Memory Error Log - QE)
:	******	*******************************************

:**********************************************************************
:	IXQE - 	Display Memory Errors from Memory Board Log
:	MEMTRC LAYOUT:
:	0        1        2        3        4                8
:	------------------------------------------------------
:	|  SPR   | ERR CNT| D/S, BD|ROW/CHIP|    TIME        |
:	------------------------------------------------------
:**********************************************************************

	IF	1-ISIS
	IF	ZITEL

IXQE	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LHL	R5,MEMIN,,		:get ptr to block start
IXQE02	L	R0,MEMTRC+4,R5,		:get SLOWC Time of logging
	JE	IXQE08			:display only if errors logged
	L	R3,SLOWC,,		:get now time in seconds
	SR	R3,R0			:How long since error logged?
	JAL	R9,TY80FW		:send Elapsed Time
	LB	R3,MEMTRC+2,R5,		:isolate Board Number
	NHI	R3,0F			:remove extraneous
	JAL	R9,TY80BY		:send Board Number
	LB	R3,MEMTRC+1,R5,
	JAL	R9,TY80BY		:send Error Count
	LH	R0,MEMTRC+2,R5,
	JLFS	IXQE04			:Double Bit or Single Bit Error?
	LIS	R1,0			:Single Bit Error on Chip
	JFS	IXQE06
IXQE04	LIS	R1,1			:Double Bit Error on Row
IXQE06	JAL	R7,TYP80X		:send Error code
	LB	R3,MEMTRC+3,R5,
	JAL	R9,TY80BY		:send Row or Chip Number
IXQE08	AIS	R5,8			:bump to next board
	CLHI	R5,NMTRC*8		:do test for last board
	JLFS	IXQE10			:branch if not up to end
	LIS	R5,0			:set up the end test
IXQE10	CH	R5,MEMIN,,
	JE	IXLRET			:that's all for now...
	J	IXQE02			:Oops.  Let's loop for another board.

	EI	:ZITEL
	EI	:1-ISIS

	SUBTTL	IIXRAY (CPU Utilization - CU)
:	******	*****************************

	IF	DB.CPU

:**********************************************************************
:	IXCU - Monitor CPU Utilization
:**********************************************************************

	GL	CPUTTT,CPUTTC

IXCU	HS	0
	LH	R0,CPUTFL,,		:make sure it isn't running
	JGE	IXCU00			:not running, ok

	LIS	R1,0E
	JAL	R7,TYP80X		:send 'CPUTIL RUNNING' code
	J	IXLRET			:and return

IXCU00	L	R3,CPUTIN,,		:see if there's any data to display
	JGFS	IXCU02			:yes, continue

	LIS	R1,0D
	JAL	R7,TYP80X		:send 'NO DATA' message code
	J	IXLRET
	
IXCU02	JAL	R7,TYP80Z		:send non-error code
	JAL	R9,TY80HW		:send Actual FASTC Interval (R3)
	LHL	R3,CPUNRQ,,
	JAL	R9,TY80HW		:send Requested Interval

	IF	DB.CLK
	LIS	R1,1
	JAL	R7,TYP80X		:send DB.CLK code

	IF	ISIS
	LHL	R3,CPUTII,,
	JAL	R9,TY80HW		:send 'SLOT0 TIME'
	EI	:ISIS

	ELSE	:(not)DB.CLK
	JAL	R7,TYP80Z		:send non-DB.CLK code
	EI	:DB.CLK

	IF	SUPER			:'SUPERVISOR CHARACTER COUNT  TO SUP: '
	L	R3,SUICCT,,
	JAL	R9,TY80FW		:send SUPIN Character Count
	L	R3,SUOCCT,,		:' FROM SUP:'
	JAL	R9,TY80FW		:send SUPOUT Character Count
	EI	:SUPER

	LIS	R12,0			:Label Table Index
	LIS	R11,0			:Data Table Index
	STH	R11,CPUTTT,,		:clear Total FASTC
	STH	R11,CPUTTC,,		:clear Total Dismiss Count

	LHI	R3,CPUTNE
	JAL	R9,TY80BY		:tell tmcs number of entries to expect
	LIS	R6,6			:don't exceed 128 byte Response msg
IXCU04	LA	R2,CPUTLB,R12,		:Process Name
	LB	R0,0,R2			:Length of Name
	JE	IXCU10			:done with individual routines
	JAL	R7,TY80A1		:send PROCESS Name
	LHL	R3,CPUTTB,R11,		:get Time
	AHM	R3,CPUTTT,,		:Total Time
	JAL	R9,TY80HW		:send TIME
	LHL	R3,CPUTTB+CPTBCT,R11,	:get Count
	AHM	R3,CPUTTC,,		:Total Count
	JAL	R9,TY80HW		:send COUNT

	SIS	R6,1			:decrement count
	JG	IXCU08			:more room in this Response msg?
	LH	R1,IIXNTC,XD,		:no,check for non-tmcs xray
	JGE	IXCU06			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
IXCU06	LIS	R6,5			:reset counter
IXCU08	AIS	R12,7			:incr pointer into CPUTLB
	AIS	R11,CPUTSZ
	CLHI	R11,CPUTNE*CPUTSZ	:Done?
	JL	IXCU04			:no, continue

IXCU10	LHL	R3,CPUTTT,,		:TOTALS:
	JAL	R9,TY80HW		:send TOTAL TIME
	LHL	R3,CPUTTC,,
	JAL	R9,TY80HW		:send TOTAL COUNT

	IF	ISIS			:SYLVER:

	IF	DB.CLK
	LHL	R3,CSYTTM,,
	JAL	R9,TY80HW		:send SYLVER Time
	EI	:DB.CLK

	LHL	R3,CSYTCT,,
	JAL	R9,TY80HW		:send SYLVER Dismiss Count
	EI	:ISIS

	L	R3,EXC1CT,,
	JAL	R9,TY80FW		:send No. of DISPATCHES
	L	R3,EXC2CT,,
	JAL	R9,TY80FW		:send No. of Passes through TOP OF X

	IF	DB.CLK
	LHL	R3,EXCTIM,,
	JAL	R9,TY80FW		:send EXECTIME

	IF	ISIS
	LHL	R3,CSYFRC,,
	JAL	R9,TY80FW		:send SYLVER FORCED DISMISS Count
	EI	:ISIS
	EI	:DB.CLK

	J	IXLRET

:**********************************************************************
:	IXCUN - Set CPU Utilization (CU #)
:**********************************************************************

IXCUN	HS	0			:here to initiate CPUTIL
	LH	R0,CPUTFL,,		:make sure it isn't running
	JGE	IXCUN2			:not running, ok

	LIS	R1,0E
	JAL	R7,TYP80X		:send 'CPUTIL RUNNING' code
	J	IXLRET			:and return

IXCUN2	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R3,VALUE1,XD		:get Requested Interval
	CLHI	R3,7			:requested interval (LOG2 SEC'S)
	JLE	IXCUN4			:ok, continue

	LIS	R1,0D			:'ARGUMENT TOO LARGE' code
	JAL	R7,TYP80X		:send error code
	J	IXLRET

IXCUN4	LA	R1,CPUTTB,,		:clear CPUTIL Table
	LHI	R2,CPUTNE*3		:this many HW's
	JAL	R8,HCLEAR,,		:set to 0

	IF	ISIS
	LIS	R1,0
	STH	R1,CSYTCT,,		:clear SYLVER Dismiss Count

	IF	DB.CLK
	STH	R1,CSYTTM,,		:clear SYLVER Time 
	STH	R1,CSYFRC,,		:clear SYLVER Forced Dismiss Count
	EI	:DB.CLK
	EI	:ISIS

	TS	CPUTCD,,		:mark code cell ok to use
	STH	R3,CPUTRQ,,		:tell EXEC to start
	JAL	R7,TYP80Z		:send non-error code
	J	IXLRET

	EI	:DB.CPU

	SUBTTL	IIXRAY (Display ISIS Info -  IS, IR)
:	******	************************************

	IF	ISIS

:**********************************************************************
:	IXIS - Display ISIS Interface statistics (IS)
:**********************************************************************

IXIS	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LIS	R5,8			:8 H-Word Fields
	LA	R10,DISICC		:starting address
	JAL	R8,TY80NH		:send H-Words

	J	IXLRET			:done

:**********************************************************************
:	IXIR - Display ISIS/Dispatcher Ring Pointers (IR)
:**********************************************************************

IXIR	HS	0
	JAL	R7,TYP80Z		:send non-error response

:	INPUT RING
	LHL	R3,DRIF,,		:Fill Pointer, Node Indexed
	JAL	R9,TY80HW		:send Fill Pointer
	LHL	R3,DRIE,,		:Empty Pointer, ISIS Indexed
	JAL	R9,TY80HW		:send Empty Pointer

:	OUTPUT RING
	LHL	R3,DROF,,		:Fill Pointer, ISIS Indexed
	JAL	R9,TY80HW		:send Fill Pointer
	LHL	R3,DROE,,		:Empty Pointer, Node Indexed
	JAL	R9,TY80HW		:send Empty Pointer

	J	IXLRET			:done

	EI	:ISIS

	SUBTTL	IIXRAY (Display Host Information - HS)
:	******	**************************************

        IF      1-T2GATE        :gates have no other hosts  ###sdw

:**********************************************************************
:	IXHSH - Display Host <host#> Information (HS # H)
:**********************************************************************

IXHSH	HS	0
	LIS	R11,0			:init Host index
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R3,VALUE1,XD		:get Host Number
IXHSH2	CLH	R3,HOSTN,R11,R11,	:does entry Host Number match?
	JE	IXHS08			:yes,display this entry
	AIS	R11,1			:no, bump Host index
	CLHI	R11,NHOSTS		:all entries checked?
	JL	IXHSH2			:no, try for a match
	J	ICMERR			:give up

:**********************************************************************
:	IXHSS - Display Slot <slot#> Information (HS # S)
:**********************************************************************

IXHSS	HS	0
	LIS	R11,0			:init Host index
	JAL	R8,RD80BY		:read byte arg and store in VALUE1
	LB	R3,VALUE1,XD		:get Slot Number
	SLLS	R3,2			:form 4*Slot Number
IXHSS2	CLB	R3,HSTKEY,R11,		:compare with Slot Key for this Host
	JE	IXHS08			:match, display this entry
	AIS	R11,1			:no, bump Host index
	CLHI	R11,NHOSTS		:all entries checked?
	JL	IXHSS2			:no, try for a match
	J	ICMERR			:give up

:**********************************************************************
:	IXHSU - Display Up or Shut Host Information (HS U)
:**********************************************************************

IXHSU	HS	0
	LIS	R12,1			:Display Up or Shut Hosts only
	JFS	IXHS02

:**********************************************************************
:	IXHS - Display Host Information
:**********************************************************************

IXHS	HS	0
	LIS	R12,0			:display all Hosts
IXHS02	LIS	R14,0			:clear end pass flag
	LIS	R11,0			:init Host index
	LIS	R6,4			:don't exceed 128 byte message
	JAL	R7,TYP80Z		:send non-error response
IXHS04	LHL	R1,HOSTN,R11,R11,	:check Host entry
	JN	IXHS06			:entry 
IXHS05	AIS	R11,1			:no entry, bump Host index
	CLHI	R11,NHOSTS		:all entries displayed?
	JL	IXHS04			:no, try some more
	J	IXLRET			:return to main loop

IXHS06	LR	R12,R12			:Up or Shut only?
	JEFS	IXHS10			:no, display all entries
	LB	R2,HSTATN,R11,		:check Status
	NHI	R2,0040			:check if bit 1 of LO byte is set
	JN	IXHS05			:Down or Gone (bit 1 set) don't display
	JFS	IXHS10

IXHS08	LIS	R14,1			:flag end pass
	JAL	R7,TYP80Z		:send non-error response

IXHS10	LHL	R3,HOSTN,R11,R11,
	JAL	R9,TY80HW		:send Host Number
	LB	R3,HSTKEY,R11,		:get Slot Number
	SRLS	R3,2			:true Slot Number not Slot*4
	JAL	R9,TY80BY
	LB	R3,HSTYPE,R11,		:send PID Code
	JAL	R9,TY80BY

	LB	R3,HSTATN,R11,		:get Expanded Host Status
	NHI	R3,00C0			:isolate Host Stat bits 0,1 of LO byte
	SRLS	R3,6			:shift into position
	JAL	R9,TY80BY		:send Host Status
	SLLS	R11,1			:form F-Word index
	L	R3,HSTTIM,R11,R11,	:into Host Status Time
	SRLS	R3,7			:dump FASTC bits
	JAL	R9,TY80FW		:send Time of Stat
	SRLS	R11,1			:restore R11
	LB	R3,HSTCST,R11,
	JAL	R9,TY80BY		:send Host Cost

	LB	R0,HSTATN,R11,		:get Expanded Host Status
	NHI	R0,000C			:isolate ORG/DEST bits (4,5 of LO byte)
	JE	IXHS16			:both no
	CLHI	R0,000C			:are both bits set?
	JE	IXHS16			:yes, both no
	LIS	R1,8			:assume Y N (Dest Only)
	NHI	R0,0008			:Which one is set?
	JEFS	IXHS18			:Destination Only Host
	LIS	R1,4			:make it N Y (Org Only)
	JFS	IXHS18
IXHS16	LIS	R1,0			:N N

IXHS18	LIS	R2,0			:assume no Ports available
	LB	R0,HSTATN,R11,		:check for Ports available
	THI	R0,0020			:bit 2 of LO byte
	JNFS	IXHS20			:out of ports - 'N'
	LIS	R2,2			:Ports available - 'Y'
IXHS20	OR	R1,R2			:combine results
	LIS	R2,0			:assume not IIX
	LB	R0,HSTATN,R11,		:check if IIX host
	THI	R0,0010			:bit 3 of LO byte
	JEFS	IXHS22			:not IIX
	LIS	R2,1			:IIX - 'Y'
IXHS22	OR	R1,R2			:combine results
	JAL	R7,TYP80X		:send DOPI bit flag in R3

IXHS90	LR	R14,R14			:check for forced end of pass
	JN	IXLRET			:done
	SIS	R6,1			:decrement - message sent
	JG	IXHS05			:more room in this Response message?
	LH	R1,IIXNTC,XD,		:no, check for non-tmcs xray
	JGE	IXHS92			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
IXHS92	LIS	R6,4			:reset counter
	J	IXHS05

        EI      :T2GATE

	SUBTTL	IIXRAY (Async Ports Status - IZ, HP, AZ, AS, BP)
:	******	************************************************

	IF	SOLOCS

:**********************************************************************
:	IXIZ - Initializes Async Ring (IZ)
:**********************************************************************

:	SEG	0
:XIZCIU	HS	1
:	SEG	0D

IXIZ	HS	0
	LHL	R2,XIZCIU,,
	JN	ICMCIU			:command in us
	STH	XD,XIZCIU,,		:destroyed by IZASYN
	LHI	R11,(NAPORT-1)*2
IXIZ01	LHL	R2,ASYTAB,R11,		:Is there a circuit?
	JEFS	IXIZ02			:no
	NHI	R2,-4			:yes, zap it
	JAL	R9,ZAPHRD,,
IXIZ02	SIS	R11,2
	JGEBS	IXIZ01
	JAL	R10,IZASYN,,		:Initialize ASYNC Ring

	IF	TELEX
	JAL	R0,TINIT,,		:build telex pvc circuits
	EI	:TELEX

	LHL	XD,XIZCIU,,		:restore XD destroyed by IZASYN
	LIS	R0,0
	STH	R0,CS.(HNPORT),,
	STH	R0,XIZCIU,,		:free up the command
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET

:**********************************************************************
:	IXHP - Hang Port (HP)
:**********************************************************************

IXHP	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R3,VALUE1,XD		:get port number
	CLHI	R3,NAPORT		:in range?
	JGE	ICMERR			:no
	LHL	R2,ASYTAB,R3,R3		:get buffer number from port to network
	JE	ICMERR			:no buffer, port is already hung
	XHI	R2,4			:flip to buffer towards port
	LHI	R1,01F0			:form a hang
	JAL	R9,W2CI,,		:and deposit into buffer
	LHI	R1,01F1			:super-hang too
	JAL	R9,W2CI,,
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET

:**********************************************************************
:	IXAZ - Clear All Async Statistics Parameters
:**********************************************************************

IXAZ	HS	0
	LIS	R0,0
	LIS	R2,1
	STH	R0,CS.(NSASHO),,	:clear hi-water marks
	STH	R0,CS.(NSASHI),,

	IF	NUMPRN
	STH	R0,CS.(NSPRHO),,
	EI	:NUMPRN

	STH	R0,CS.(MXPORT),,	:Max number of async ports in use

	IF	ASYNCT
	STH	R0,CS.(FASTCH),,
	EI	:ASYNCT

	LHI	R1,NAPORT-1
IXAZ01	STH	R0,CS.(IZITUP),R1,R1
	TBT	R1,ASYACP,,		:Is this port up?
	JNFS	IXAZ02			:no
	AHM	R2,CS.(MXPORT),,	:bump Max Async Ports Count
IXAZ02	SIS	R1,1
	JGEBS	IXAZ01
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET

:**********************************************************************
:	IXASRU - Display Range of Active Async Ports
:**********************************************************************

IXASRU	HS	0
	LIS	R11,0			:active ports only
	J	IXASR2

:**********************************************************************
:	IXASR - Display Range of Async Ports
:**********************************************************************

IXASR	HS	0
	LIS	R11,1			:display all ports
IXASR2	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R10,VALUE1,XD		:get starting port number
	CLHI	R10,NPORT		:do range check
	JGE	ICMERR			:invalid port number
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R14,VALUE1,XD		:get ending port number
	CLHI	R14,NPORT		:do range check
	JGE	ICMERR			:invalid port number
	SR	R14,R10			:count = ending port - start port
	AIS	R14,1			:...plus 1
	J	IXAS02

:**********************************************************************
:	IXASNU - Display Active Async Port <n>
:**********************************************************************

IXASNU	HS	0
	LIS	R11,0			:active ports only
	JFS	IXASN2

:**********************************************************************
:	IXASN - Display Async Port <n>
:**********************************************************************

IXASN	HS	0
	LIS	R11,1			:display all ports
IXASN2	LIS	R14,1			:display for just 1 port
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R10,VALUE1,XD		:get the port number
	CLHI	R10,NPORT		:do range check
	JGE	ICMERR			:invalid port number
	JFS	IXAS02

:**********************************************************************
:	IXASU - Display Active Async Ports
:**********************************************************************

IXASU	HS	0
	LIS	R11,0			:active ports only
	JFS	IXAS00

:**********************************************************************
:	IXAS - Display Async Port Status
:	Can include SIO and MPVC
:**********************************************************************

:	SEG	0
:RLASAV	HS	1			:for saving RLA array during count
:	SEG	0D

IXAS	HS	0
	LIS	R11,1			:display all ports
IXAS00	LHI	R14,NPORT		:Number of Async Ports
	LIS	R10,0			:first Async Port

IXAS02	HS	0			:RLA is array for counting active ports
	JAL	R7,TYP80Z		:send non-error response
	LIS	R3,0			:init the one's counter
	LHI	R2,NGRP-1		:halfword index into RLA
IXAS04	LHL	R0,RLA,R2,R2		:read a HW of RLA (back to front)
	STH	R0,RLASAV,,		:working copy halfword at a time
IXAS06	LHL	R0,RLASAV,,		:reset the target halfword
	JFFOH	R0,IXAS08	
	SIS	R2,1			:step to previous halfword
	JGEBS	IXAS04			:loop while index is valid
	JFS	IXAS10			:exit counting loop.  R3 has result.
IXAS08	AIS	R3,1			:increment the counter
	RBT	R1,RLASAV,,		:count one's once only
	JBS	IXAS06			:and look for more
IXAS10	JAL	R9,TY80HW		:send Number of Active Ports
	LHI	R3,NPORT
	JAL	R9,TY80HW		:send Total Number of Ports
	LHL	R3,CS.(MXPORT),,
	JAL	R9,TY80HW		:send Max Number of Async Ports In Use
	LHI	R3,1200+BAUDR*1B00
	JAL	R9,TY80HW		:send Maximum CPS supported

	LIS	R5,3			:don't exceed 128 byte Response msg
IXAS12	SIS	R5,1			:decrement count
	JG	IXAS16			:more room in this Response message?
	LH	R1,IIXNTC,XD,		:no, check for non-tmcs xray
	JGE	IXAS14			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
IXAS14	LIS	R5,2			:reset counter
IXAS16	JAL	R12,IXASOU		:output data
	AIS	R10,1			:increment port index
	SIS	R14,1			:decrement port count
	JGBS	IXAS12			:repeat if more
	J	IXLRET			:else depart

IXASOU	HS	0
	LR	R11,R11			:Did user want active ports only?
	JNFS	IXAS20			:no, all ports
	TBT	R10,RLA,,		:bits set for active
	JER	R12
IXAS20	LR	R3,R10
	JAL	R9,TY80HW		:send Port number
	LCS	R3,1
	TBT	R10,RLA,,		:test RLA...1=>active
	JNFS	IXAS22
	LIS	R3,0
IXAS22	JAL	R9,TY80BY		:send RLA
	LCS	R3,1
	TBT	R10,CS.(DTR),,		:test DTR...0=>active
	JEFS	IXAS24
	LIS	R3,0
IXAS24	JAL	R9,TY80BY		:send DTR
	LCS	R3,1
	TBT	R10,CS.(DSR),,		:test DSR...0=>active
	JEFS	IXAS26
	LIS	R3,0
IXAS26	JAL	R9,TY80BY		:send DSR
	LCS	R3,1
	TBT	R10,CS.(RTS),,		:test RTS...0=>active
	JEFS	IXAS28
	LIS	R3,0
IXAS28	JAL	R9,TY80BY		:send RTS
	LCS	R3,1
	TBT	R10,CS.(CP),,		:test CP...0=>active
	JEFS	IXAS30
	LIS	R3,0
IXAS30	JAL	R9,TY80BY		:send CP
	LIS	R3,0
	TBT	R10,CS.(HAFDUX),,	:test HAFDUX...1=>Half Duplex
	JEFS	IXAS32
	LCS	R3,1
IXAS32	JAL	R9,TY80BY		:send DPLX
	LB	R3,CS.(IBRATE),R10,	:Input Baud Rate
	SLLS	R3,4
	LB	R9,CS.(OBRATE),R10,	:Output Baud Rate
	OR	R3,R9
	JAL	R9,TY80BY		:send BR

:	Read the .TERMT H-word out of the port table, use it to index into VID
:	table (byte which is at	this offset from VID.ID).  $0 0C0!CCT is the
:	actual table entry, so strip 0C0 to display CIRCUIT.DOC Circuit
:	Characteristic Type (CCT)
	LHL	R13,.PTP.,R10,R10	:get port table offset into seg4
	AI	R13,PTBASE		:add seg4 base offset
	LHL	R3,.TERMT,R13,		:get index into VID table for port
	LB	R3,VID.ID,R3,		:this byte is CCT
	NHI	R3,2F			:remove HO bits from table entry
	JAL	R9,TY80BY		:send TY

	LB	R3,CS.(ASYLNK),R10,	:Number of Links in CRQ
	JAL	R9,TY80BY		:send NL
	LHL	R6,ASYTAB,R10,R10	:ASYNC Port's Sink Buffer
	JE	IXAS38			:zero, this port goes nowhere
	NHI	R6,-4
	LHL	R3,BF,R6,,		:the outbound channel
	JAL	R9,TY80HW		:send CHAN
	LR	CHN,R3
	JAL	R8,CHNLNK		:find neighbor
	LCS	R3,2			:(immed) no neighbor
	JFS	IXAS34
	LHI	R3,MACHNM		:(+4) internal, get node number in hex
IXAS34	JAL	R9,TY80HW		:(+8) R3 has neighbor number, display
	L	R3,SLOWC,,		:compute circuit lifetime
	SRLS	R6,1
	NHI	R6,-4
	S	R3,BUFTIM,R6,		:circuit lifetime
	JAL	R9,TY80FW		:send Circuit Up TIME
IXAS36	LHL	R3,CS.(IZITUP),R10,R10	:number of times port was answer'd
	JAL	R9,TY80HW		:send UP
	JR	R12			:and return

IXAS38	JAL	R7,TYP80Z		:null circuit
	JAL	R7,TYP80Z
	JAL	R7,TYP80Z		:send 0 for CHAN, NEIGHBOR, TIME
	J	IXAS36

	IF	SCBSYO

:**********************************************************************
:	IXBP1 - Busy Port <n>
:	Use of bit arrays is as follows:
:		BUSY.C	set for ports needing attention in initialization
:		BUSY.A	set for ports needing attention next run of A.BUSY
:		BUSY.H	shows state of RTS desired for port getting attention
:**********************************************************************

IXBP1	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R3,VALUE1,XD		:get Port number 
	CLHI	R3,NAPORT		:range check on the port number
	JGE	ICMERR
	LR	R2,R3			:keep port number in R2
	SBT	R2,BUSY.A,,		:get attention from 4 sec logic
	SBT	R2,BUSY.H,,		:let's busy the port
	SBT	R2,BUSY.C,,		:set bit to busy it if reinit or crash
	J	IXBP

:**********************************************************************
:	IXBP0 - Unbusy Port <n>
:**********************************************************************

IXBP0	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R3,VALUE1,XD		:get Port number 
	CLHI	R3,NAPORT		:range check on the port number
	JGE	ICMERR
	LR	R2,R3			:keep port number in R2
	SBT	R2,BUSY.A,,		:get attention from 4 sec logic
	RBT	R2,BUSY.H,,		:unbusy the port
	RBT	R2,BUSY.C,,		:turn off attention if reinit
	JFS	IXBP

:**********************************************************************
:	IXBP - Display Busy-port array (BP)
:**********************************************************************

IXBP	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LIS	R5,0			:index into the bit array
IXBP20	LHL	R3,BUSY.H,R5,		:get the bits for this group
	JAL	R9,TY80HW		:output 16 bits worth
	AIS	R5,2
	CLHI	R5,NAGRP*2		:check for running off end
	JLBS	IXBP20			:loop to get all ports
	J	IXLRET			:otherwise, we're finished

	EI	:SCBSYO
	EI	:SOLOCS

	SUBTTL	IIXRAY (PVC Port Status - PV)
:	******	*****************************

	IF	PVC			:display PVC parameters
	LO	PVC

:**********************************************************************
:	IXPVN - Display Specified Port's PVC Parameters
:**********************************************************************

IXPVN	HS	0
	JAL	R8,RD80HW		:read HW arg and store in VALUE1
	LHL	R3,VALUE1,XD		:get port number
	CHI	R3,NPORT-1		:valid port number?
	JG	ICMERR			:no
	TBT	R3,PVCARY,,		:PVC port?
	JE	ICMERR			:no
	LR	PN,R3			:set up PN
	JAL	R7,TYP80Z		:send non-error response
	JAL	R8,IXPVDS		:go display parameters
	J	IXLRET			:all done

:**********************************************************************
:	IXPV - Display PVC Paramters for all PVC Ports
:**********************************************************************

IXPV	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LIS	R12,0			:to keep track of no. of groups
	LIS	R6,8			:don't exceed 128 byte Response msg
IXPV02	L	R10,PVCARY,R12,		:get the bit array for PVC ports
IXPV04	JFFO	R10,IXPV06		:find no. of 1st PVC port
	AIS	R12,4			:no more in this group so check next
	CHI	R12,(NPORT+1F)/20*4	:Is there a next group?
	JLBS	IXPV02			:yes, go get it
	J	IXLRET			:all done
IXPV06	LR	PN,R11			:port no. for IXPVDS
	LR	R0,R12			:copy R12 to work with it
	ST	R12,XRSAVE+4,XD		:preserve R12--word index
	ST	R10,XRSAVE+8,XD		:preserve R10--service-bit array
	RBT	R11,XRSAVE+8,XD		:service each port only once
	SLLS	R0,3			:convert 4 bytes to 32 bits
	AR	PN,R0			:set up PN(R14) with port number
	JAL	R8,IXPVDS		:go display parameters
	L	R10,XRSAVE+8,XD		:restore R10
	L	R12,XRSAVE+4,XD		:restore R12
	SIS	R6,1			:decrement count
	JG	IXPV04			:more room, do next PVC port
	LH	R1,IIXNTC,XD,		:check for non-tmcs xray
	JGE	IXPV08			:don't send IIX messages!
	JAL	R8,XRYRES		:send another Response message
IXPV08	LIS	R6,8			:reset counter
	J	IXPV04			:next PVC port

:**********************************************************************
:	IXPVDS: Routine to Display PVC Parameters
:**********************************************************************

IXPVDS	HS	0
	LR	R3,PN
	JAL	R9,TY80HW		:send Port Number

:	get PVC parameters for port no. PN
	LHL	R12,.PTP.,PN,PN		:read HW offset
	AI	R12,PTBASE		:add in the base offset
	L	R3,.PVCX,R12		:pick up the PVC flag word
	JAL	R9,TY80FW		:send PVC flag word

	CLHI	PN,.MPORT		:check for MPVC pseudo port
	JLFS	IXPVD2			:it's not
	LIS	R1,1
	JAL	R7,TYP80X		:tell tmcs it's MPPSD
	JR	R8
IXPVD2	JAL	R7,TYP80Z		:tell tmcs to check for TELEX TID
	JR	R8			:return above

	FO	PVC
	EI	:PVC

	SUBTTL	IIXRAY (SIO Ring Status - SR)
:	******	*****************************

	IF	SIORNG

:**********************************************************************
:	IXSR1 - Initialize SIO Ring
:**********************************************************************

IXSR1	HS	0
	LIS	R1,1
	JFS	IXSR22

:**********************************************************************
:	IXSR2 - Initialize SIO Ring and Interface
:**********************************************************************

IXSR2	HS	0
	LIS	R1,2
IXSR22	STH	R1,SIRXIZ,,		:set cell to force initialization
	JAL	R7,TYP80Z		:send non-error response
	J	IXLRET

:**********************************************************************
:	IXSR - Display SIO Ring Status
:**********************************************************************

IXSR	HS	0
	JAL	R7,TYP80Z		:send non-error response
	LH	R0,SIRDLD,,		:-1 if currently LOADING
	JL	IXSR10
	LH	R0,SIRFLG,,	:0=DOWN, -1=UP, >0=TIMED-OUT or AWAITING LOAD
	JGFS	IXSR06			:TIMED-OUT OR MISMATCH ON RING 0
	JEFS	IXSR04			:DOWN
	LIS	R1,1			:UP

IXSR02	JAL	R7,TYP80X		:send Status
	J	IXLRET			:done

IXSR04	LIS	R1,0			:DOWN
	JBS	IXSR02

IXSR06	CLHI	R0,STSRM0		:AWAITING LOAD?
	JE	IXSR08			:yes
	LIS	R1,4			:INTERFACE TIMED-OUT
	JAL	R7,TYP80X		:send Status
	LHL	R3,SIRFLG,,		:it happened last on this command
	JAL	R9,TY80HW		:send Command number
	J	IXLRET

IXSR08	LIS	R1,2			:AWAITING LOAD
	J	IXSR02

IXSR10	LIS	R1,3			:LOADING
	J	IXSR02

	EI	:SIORNG

	SUBTTL	IIXRAY (Utilities)
:	******	******************

:**********************************************************************
:	XRYSIX - send SIIX command to TMCS
:		R7=link  R1,R13=clobbered
:**********************************************************************

XRYSIX	LHI	R1,XEQSIX		:get SIIX command
	JAL	R13,IIXOUT,,		:and send it
	JR	R7			:and return

:**********************************************************************
:	XRYTIX - send TIIX command to TMCS
:		R7=link  R1,R13=clobbered
:**********************************************************************

XRYTIX	LHI	R1,XEQTIX		:get TIIX command
	JAL	R13,IIXOUT,,		:and send it
	JR	R7			:and return

:**********************************************************************
:	XRYSDC - send IIX select dialect command	
:		R8=link  R1,R7,R13=clobbered
:**********************************************************************

XRYSDC	JAL	R7,XRYSIX		:send SIIX message
	LHI	R1,XEQ080		:get select dialect message
	JAL	R13,XRYOUT,,		:and send it (8080)
	JAL	R13,XRYOUT,,
	JAL	R13,XRYOUT,,		:get network console dialect
	LHI	R1,XEQ090		:and send it (8090)
	JAL	R13,XRYOUT,,
	JAL	R7,XRYTIX		:send TIIX message
	JR	R8			:and return

:**********************************************************************
:	XRYPIV - send IIX product id and version message
:		product id and version number: pppp vvvv
:		where:	pppp =	product id
:			vvvv =	version number
:		R8=link  R1,R7,R13=clobbered
:**********************************************************************

XRYPIV	JAL	R7,XRYSIX		:send SIIX message
	LHI	R1,XEQ080		:get product id and version message
	JAL	R13,XRYOUT,,		:and send it
	LHI	R1,XEQ086
	JAL	R13,XRYOUT,,
	LIS	R1,0			:get prodid and send it
	JAL	R13,XRYOUT,,		:start with leftmost byte of halfword
	LB	R1,HSTYPE
	JAL	R13,XRYOUT,,
	LHI	R1,VERSION		:get version and send it
	SRLS	R1,8			:start with leftmost byte of halfword
	JAL	R13,XRYOUT,,
	LHI	R1,VERSION
	JAL	R13,XRYOUT,,
	JR	R8			:and return

:**********************************************************************
:	XRYNC2 - send Response message to TMCS
:	XRYRES - alternate entry with TIIX message
:		R8=link  R1,R7,R13=clobbered
:**********************************************************************

XRYRES	HS	0
	JAL	R7,XRYTIX		:send TIIX message
XRYNC2	JAL	R7,XRYSIX		:send SIIX message
	LHI	R1,XEQ0C0		:send C082 message
	JAL	R13,XRYOUT,,
	LHI	R1,XEQ082
	JAL	R13,XRYOUT,,
	JAL	R7,XRYCID		:send command id
	JR	R8

:**********************************************************************
:	XRYNC3 - send End Response message to TMCS
:		R8=link  R1,R7,R13=clobbered
:**********************************************************************

XRYNC3	JAL	R7,XRYSIX		:send SIIX message
	LHI	R1,XEQ0C0		:send C083 message
	JAL	R13,XRYOUT,,
	LHI	R1,XEQ083
	JAL	R13,XRYOUT,,
	JAL	R7,XRYCID		:send command id
	JR	R8

:**********************************************************************
:	XRYNC5 - send Command Mode message to TMCS
:		R8=link	 R1,R7,R13=clobbered
:**********************************************************************

XRYNC5	JAL	R7,XRYSIX		:send SIIX message
	LHI	R1,XEQ0C0		:send C085 message
	JAL	R13,XRYOUT,,
	LHI	R1,XEQ085
	JAL	R13,XRYOUT,,
	LHI	R1,XEQ081		:send command mode
	JAL	R13,XRYOUT,,
	JAL	R7,XRYTIX		:send TIIX message
	JR	R8

:**********************************************************************
:	XRYCID - send Command ID to TMCS
:		R7=link	 R1,R13=clobbered
:**********************************************************************

XRYCID	LHL	R1,IIXCID,XD		:send command id
	SRLS	R1,8			:start with leftmost byte of halfword
	JAL	R13,XRYOUT,,
	LHL	R1,IIXCID,XD
	JAL	R13,XRYOUT,,
	JR	R7

:**********************************************************************
:	XRYACR - Send Response message for auto CRYPTO
:		R8=Link  R1,R7,R13=Clobbered
:**********************************************************************

XRYACR	HS	0
	JAL	R7,XRYSIX		:send SIIX message
	LHI	R1,XEQ0C0		:send C082 message
	JAL	R13,XRYOUT,,
	LHI	R1,XEQ082
	JAL	R13,XRYOUT,,
	LHL	R1,IIXAID,XD		:send auto CRYPTO command id
	SRLS	R1,8			:start with leftmost byte of halfword
	JAL	R13,XRYOUT,,
	LHL	R1,IIXAID,XD
	JAL	R13,XRYOUT,,
	JR	R8

:**********************************************************************
:	TYP80X - type a single hex digit with MSB set
:	TYP80W - alternate entry point from utility routines
:	TYP80Z - alternate entry point with R1=0
:		R1=digit, R7=link, R13=clobbered
:**********************************************************************

TYP80Z	HS	0
	LIS	R1,0
TYP80X	HS	0
	ST	R7,XRSAVE,XD		:save link
	LI	R7,TYP80U		:continuation
TYP80W	HS	0			
	NHI	R1,0F			:truncate
	OHI	R1,30			:ASCII hex equivalent
	CLHI	R1,ASCNIN		:if > 39, add 7
	JLEFS	TYP80V
	AIS	R1,7
TYP80V	OHI	R1,80			:set MSB
	JAL	R13,XRYOUT,,
	JR	R7

TYP80U	L	R7,XRSAVE,XD		:restore link
	LH	R1,IIXNTC,XD		:check for non-tmcs xray
	JLR	R7			:tmcs - return
	LHI	R1,0A0
	JAL	R13,XRYOUT		:space for non-tmcs xray
	JR	R7

:**********************************************************************
:	TY80BY - Type 2 Digits, the first with MSB set
:		R3=Argument (Preserved), R9=Link
:		R1,R7,R13=Clobbered
:**********************************************************************

TY80BY	HS	0
	LR	R1,R3			:preserve Byte
	SRLS	R1,4			:get hi digit into position
	JAL	R7,TYP80W		:send hex digit with MSB set
	LR	R1,R3			:get lo digit into position
	JAL	R7,TYPHEX

TYP1SP	HS	0
	LH	R1,IIXNTC,XD		:check for non-tmcs xray
	JLR	R9			:tmcs - return
	LHI	R1,0A0
	JAL	R13,XRYOUT		:space for non-tmcs xray

	JR	R9

:**********************************************************************
:	TY80NB - Type N Bytes, each with MSB set
:		R5=Byte count, R6=Address of first byte, R8=Link
:		R1,R3,R4,R7,R9,R13=Clobbered
:**********************************************************************

TY80NB	HS	0
	LIS	R4,0
TY80N1	CR	R4,R5
	JER	R8			:done
	LB	R3,0,R6,R4		:get a byte
	JAL	R9,TY80BY		:and type it
	AIS	R4,1			:inc index
	JBS	TY80N1			:and loop

:**********************************************************************
:	TY80HW - Type 4 Digits, the first with MSB set
:		R3=Argument (Preserved), R9=Link
:		R0,R1,R4,R7,R13=Clobbered
:**********************************************************************

TY80HW	HS	0
	LR	R0,R3			:preserve HW
	SLLS	R0,4			:get hi digit into position
	EXHR	R1,R0			:in R1
	JAL	R7,TYP80W		:send hex digit with MSB set
	LIS	R4,3			:init counter for other three
TY80H1	SLLS	R0,4
	EXHR	R1,R0
	JAL	R7,TYPHEX
	SIS	R4,1
	JGBS	TY80H1
	J	TYP1SP

:**********************************************************************
:	TY80NH - Type N HW's, each with MSB set
:		R5=Number of HW's, R10=Starting address, R8=Link
:		R0,R1,R4,R7,R9,R13=Clobbered
:**********************************************************************

TY80NH	HS	0
	SIS	R5,1			:done?
	JLR	R8			:yes
	LHL	R3,0,R10
	AIS	R10,2
	JAL	R9,TY80HW		:send HW
	JBS	TY80NH

:**********************************************************************
:	TY80FW - Type 8 Digits, the first with MSB set
:		R3=Argument (Preserved), R9=Link
:		R0,R1,R4,R7=Clobbered
:**********************************************************************

TY80FW	HS	0
	LR	R0,R3			:preserve FW
	RLL	R0,4			:get hi digit into position
	LR	R1,R0			:in R1
	JAL	R7,TYP80W		:send hex digit with MSB set
	LIS	R4,7			:init counter for other seven
TY80F1	RLL	R0,4
	LR	R1,R0
	JAL	R7,TYPHEX
	SIS	R4,1
	JGBS	TY80F1
	J	TYP1SP

:**********************************************************************
:	TY80NF - Type N FW's, each with MSB set
:		R5=Number of FW's, R6=Starting Address, R8=Link
:		R0,R1,R4,R7,R9,R13=Clobbered
:**********************************************************************

TY80NF	HS	0
	L	R3,0,R6			:get a FW
	JAL	R9,TY80FW		:send it
	AIS	R6,4			:add 4 to address
	SIS	R5,1			:decrement count
	JGBS	TY80NF			:more?
	JR	R8			:done

:**********************************************************************
:	TY80AS - Type ASCII string, the first letter with MSB set
:	TY80A1 - Alternate entry point has byte count passed in R0
:		R2=Ptr to string, R0,R1,R13=Clobbered, R7=Link
:**********************************************************************

TY80AS	HS	0
	LB	R0,0,R2			:get byte count in R0
	JER	R7			:null length
TY80A1	HS	0
	LB	R1,1,R2			:get first char in R1	
	OHI	R1,80			:set MSB in first byte
	JAL	R13,XRYOUT		:send first byte
	SIS	R0,1
	JGFS	TY80A2
	JR	R7
TY80A2	LB	R1,2,R2
	NHI	R1,ASC7BT		:strip MSB in remaining bytes
	JAL	R13,XRYOUT		:send remaining bytes
	AIS	R2,1
	SIS	R0,1
	JGBS	TY80A2
	JR	R7

:**********************************************************************
:	TY80PC - Compute and send percentage of passed values as:
:	A/B=NN   Where A is passed in R3, B is passed in R4, and NN is a
:	hex value.  R8=Link, R0,R2=Clobbered
:**********************************************************************

TY80PC	HS	0
	LHI	R0,$A 100
	MR	R2,R0			:multiply dividend by 100
	LR	R4,R4			:no zero divide!
	JLEFS	TY80P1
	DR	R2,R4			:(A/B), quotient in R3
	JFS	TY80P2
TY80P1	LIS	R3,0			:divide by zero, give zero result
TY80P2	JAL	R9,TY80BY		:send hex percentage
	JR	R8			:return

:**********************************************************************
:	RD80FW	- Read FW
:		Entry point for reading 4 bytes
:**********************************************************************

RD80FW	HS	0
	LIS	R0,4
	STH	R0,XRSAVE,XD		:store number of bytes desired
	J	RD80B2

:**********************************************************************
:	RD80HW - Read HW
:		Entry point for reading 2 bytes
:**********************************************************************

RD80HW	HS	0
	LIS	R0,2
	STH	R0,XRSAVE,XD		:store number of bytes desired
	JFS	RD80B2

:**********************************************************************
:	RD80BY - Read 2 Digits
:		Arg stored in VALUE1, R8=Link
:		R0,R1,R7,R9,R13=Scratch
:**********************************************************************

RD80BY	HS	0
	LIS	R0,1
	STH	R0,XRSAVE,XD		:store number of bytes desired
RD80B2	HS	0
	LIS	R9,0
RD80B4	JAL	R7,RDHEX,,		:get first digit in R1
	J	ICMERR			:(immed) non-digit typed, error
	SLLS	R1,4			:(+4) shift digit to left nibble
	STB	R1,VALUE1,R9,XD		:store
	JAL	R7,RDHEX,,		:get second digit in R1
	J	ICMERR			:(immed) non-digit typed, error
	LB	R0,VALUE1,R9,XD		:(+4) get first nibble
	AR	R1,R0			:combine with second
	STB	R1,VALUE1,R9,XD		:store it
	AIS	R9,1			:increment byte count
	CLH	R9,XRSAVE,XD		:check number of bytes  desired
	JL	RD80B4			:more to do
	JR	R8

:**********************************************************************
:	IIXOUT - output utility routine for unescaped SIIX and TIIX msgs.
:	writes 2 characters from R1, without escaping, into buffer
:	indexed in R2.
:	IN REMOTE MODE (XRYTTY=1  OR ISIS), XRAY MAY WRITE INTO ITS
:	OUTBOUND BUFFER ONLY IF THERE ARE LESS THAN 100 CHARACTERS IN
:	IT.  ELSE, XRAY SCHEDULES ITSELF OFF THE HALF-SEC PROCESS
:	(XRYRUN = 1 ) AND DISMISSES TO THE EXEC LOOP.
:**********************************************************************

IIXOUT	HS	0
	STM	R0,XREGSV,XD		:save all registers
IIXOU1	LHL	R2,XRYBFO,XD		:get buffer number
	LHL	R0,BCT,R2,		:get estimate of byte count
	CLHI	R0,$A160		:are we at our limit?
	JLFS	IIXOU2			:not yet, add a couple characters
	JAL	R0,XRYYLD,,
	J	IIXOU1			:retry when rescheduled

IIXOU2	L	R1,XREGSV+4,XD		:character to be written
	JAL	R9,W2CI,,		:deposit into buffer
	LM	R0,XREGSV,XD		:recover all our registers
	JR	R13			:return

	IF	SOLOCS
	FO	DATA
	EI	:SOLOCS

	ENDMO.(IIXRAY)
	EI	:1-KILLIT
	KILMSG(IIXRAY)
	EI	:XRYTMC	###wjl

:	***NOTHING PAST THIS POINT***

 	SUBTTL DEBUG
:
:		***   ***** ****   *   *   ***
:		*   * *     *   *  *   *  *
:		*   * ****  ****   *   *  *  **
:		*   * *     *   *  *   *  *   *
:		***   ***** ****    ***    ***

::#####################################################################
::
::	MODULE:			DEBUG
::
::	FUNCTION:		DEBUGGERS
::
::	SUBTTLS:		UTILITIES
::				PORT LOGON/LOGOFF DEBUGGER <LNFDBG>
::				CRQ BUILDING/ZAPPING DEBUGGER <CBZDBG>
::				BUFFER STRUCTURE DEBUGGER <BFSDBG>
::				NODE CODE - SUPE COMM. DEBUGGER <LPGDBG>
::				ASYNC INPUT/OUTPUT DEBUGGER <AIODBG>
::				OTHER DEBUGGING AIDS
::				XRAY COMMANDS
::
::	###LSH	THIS DEBUGGER IS IMPLEMENTED BY LOUISA HSU  
::
::#####################################################################

	IF	1-KILLIT		:TO ASSEMBLE OR NOT 

	BEGMO.


	SEG	0D			:DEBUGGER  RUNS IN SEGD


	

	SUBTTL DEBUG ( UTILITIES )

	IF	LNFDBG

::*********************************************************************
::
::	SUBROUTINE:	INLNFH:
::	FUNCTION:	INCREMENT "LNFHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INLNFH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLNFH	HS	0
	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,LNFSIZ	:CHECK IF NEED WRAP AROUND
	JLFS	INCP0		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
INCP0	JR	R4		:END OF INLNFH


::*********************************************************************
::
::	SUBROUTINE:	INLNFB:
::	FUNCTION:	INCREMENT "LNFHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INLNFB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLNFB	HS	0
	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,LNFSIZ	:CHECK IF NEED WRAP AROUND
	JLFS	INCP1		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
INCP1	JR	R4		:END OF INLNFB

::*********************************************************************
::
::	SUBROUTINE:	EVNLNF:
::	FUNCTION:	EVEN UP "LNFHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNLNF
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNLNF	HS	0
	AIS	R6,1
	NHI	R6,LNFSIZ-2	:INSURE HALF WORD BOUNDARY
	JR	R4		:END OF EVNLNF

::*********************************************************************
::
::	SUBROUTINE:	MRKLNF:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING LNFHST
::	CALLING SEQ:	JAL	R4,MRKLNF
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::			R3 - ROUTINE NUMBER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKLNF	HS	0
	ST	R4,REGSV8,,		:STORE R4
	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,LNFHST,R6,
	JAL	R4,INLNFH
	STH	R3,LNFHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INLNFH
	L	R4,REGSV8,,		:RESTORE R4
	JR	R4			:END OF MRKLNF

::*********************************************************************
::
::	SUBROUTINE:	BUFLNF:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING LNFHST
::	CALLING SEQ:	JAL	R3,BUFLNF
::	INPUT:		R6 - RING POINTER
::			R3 - LINK REGISTER
::			R2 - BUFFER NUMBER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFLNF	HS	0
	STH	R2,LNFHST,R6,	:BUFFER NUMBER
	JAL	R4,INLNFH
	LHL	R4,BF,R2,
	STH	R4,LNFHST,R6,	:BF OF BUFFER (R2)
	JAL	R4,INLNFH
	LHL	R4,BF+4,R2,
	STH	R4,LNFHST,R6,	:BF OF BUFFER (R2)+4
	JAL	R4,INLNFH
	JR	R3		:END OF BUFLNF

	IF	SOLOCS

::*********************************************************************
::
::	SUBROUTINE:	PRTLNF:
::	FUNCTION:	WRITE BUFFER STRUCTURE OF A PORT INTO LNFHST
::	CALLING SEQ:	JAL	R4,PRTLNF
::	INPUT:		R6 - RING POINTER
::			RPI - POINTER TO PORT TABLE
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R3
::
::*********************************************************************

PRTLNF	HS	0
	ST	R4,REGSV8,,	:STORE R4
	L	R3,.FTBUF,RPI,
	STH	R3,LNFHST,R6,	:FTBUF
	JAL	R4,INLNFH
	LHL	R4,BF,R3,
	STH	R4,LNFHST,R6,	:BF (.FTBUF)
	JAL	R4,INLNFH
	LHL	R4,BF+4,R3,
	STH	R4,LNFHST,R6,	:BF (.TTBUF)
	JAL	R4,INLNFH
	L	R3,.LGBUF,RPI
	STH	R3,LNFHST,R6,	:LGBUF
	JAL	R4,INLNFH
	LHL	R4,BF,R3,	
	STH	R4,LNFHST,R6,	:BF(.LGBUF)
	JAL	R4,INLNFH
	L	R3,.ALBUF,RPI
	STH	R3,LNFHST,R6,	:.ALBUF
	JAL	R4,INLNFH
	LHL	R4,BF,R3,	
	STH	R4,LNFHST,R6,	:BF(.ALBUF)
	JAL	R4,INLNFH
	LHL	R4,BF+4,R3,	
	STH	R4,LNFHST,R6,	:BF (.ALBUF+4)
	JAL	R4,INLNFH
	L	R4,REGSV8,,	:RESTORE R4
	JR	R4		:END OF PRTLNF

	EI	:SOLOCS

::*********************************************************************
::
::	SUBROUTINE:	CLALNF:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R10) INTO RING LNFHST
::	CALLING SEQ:	JAL	R3,CLALNF
::	INPUT:		R6  - RING POINTER
::			R10 - ADDRESS OF CALLER
::			R3 - LINK REGISTER
::	OUTPUT:		R6  - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

CLALNF	HS	0
	EXHR	RLINK,RLINK
	STH	RLINK,LNFHST,R6,:CALLER (R10)
	EXHR	RLINK,RLINK
	JAL	R4,INLNFH
	STH	RLINK,LNFHST,R6,
	JAL	R4,INLNFH
	JR	R3		:END OF CLALNF

	EI	:LNFDBG


	IF	CBZDBG

::*********************************************************************
::
::	SUBROUTINE:	INCBZH:
::	FUNCTION:	INCREMENT "CBZHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INCBZH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INCBZH	HS	0
	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,CBZSIZ	:CHECK IF NEED WRAP AROUND
	JLFS	INCP2		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
INCP2	JR	R4		:END OF INCBZH


::*********************************************************************
::
::	SUBROUTINE:	INCBZB:
::	FUNCTION:	INCREMENT "CBZHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INCBZB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INCBZB	HS	0
	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,CBZSIZ	:CHECK IF NEED WRAP AROUND
	JLFS	INCP3		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
INCP3	JR	R4		:END OF INCBZB

::*********************************************************************
::
::	SUBROUTINE:	EVNCBZ:
::	FUNCTION:	EVEN UP "CBZHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNCBZ
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNCBZ	HS	0
	AIS	R6,1
	NHI	R6,CBZSIZ-2	:INSURE HALF WORD BOUNDARY
	JR	R4		:END OF EVNCBZ

::*********************************************************************
::
::	SUBROUTINE:	MRKCBZ:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING CBZHST
::	CALLING SEQ:	JAL	R4,MRKCBZ
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKCBZ	HS	0
	ST	R4,REGSV8,,		:STORE R4
	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,CBZHST,R6,
	JAL	R4,INCBZH
	STH	R3,CBZHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INCBZH
	L	R4,REGSV8,,		:RESTORE R4
	JR	R4			:END OF MRKCBZ

::*********************************************************************
::
::	SUBROUTINE:	BUFCBZ:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING CBZHST
::	CALLING SEQ:	JAL	R3,BUFCBZ
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFCBZ	HS	0
	STH	R2,CBZHST,R6,	:BUFFER NUMBER
	JAL	R4,INCBZH
	LHL	R4,BF,R2,
	STH	R4,CBZHST,R6,	:BF OF BUFFER
	JAL	R4,INCBZH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,CBZHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INCBZH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFCBZ

::*********************************************************************
::
::	SUBROUTINE:	CL9CBZ:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R9) INTO RING CBZHST
::	CALLING SEQ:	JAL	R3,CL9CBZ
::	INPUT:		R6 - RING POINTER
::			R9 - ADDRESS OF CALLER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

CL9CBZ	HS	0
	EXHR	R9,R9
	STH	R9,CBZHST,R6,	:CALLER
	EXHR	R9,R9
	JAL	R4,INCBZH
	STH	R9,CBZHST,R6,
	JAL	R4,INCBZH
	JR	R3		:END OF CL9CBZ

	EI	:CBZDBG


	IF	BFSDBG

::*********************************************************************
::
::	SUBROUTINE:	INBFSH:
::	FUNCTION:	INCREMENT "BFSHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INBFSH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INBFSH	HS	0
	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,BFSSIZ	:CHECK IF NEED WRAP AROUND
	JLFS	INCP4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
INCP4	JR	R4		:END OF INBFSH


::*********************************************************************
::
::	SUBROUTINE:	INBFSB:
::	FUNCTION:	INCREMENT "BFSHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INBFSB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INBFSB	HS	0
	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,BFSSIZ	:CHECK IF NEED WRAP AROUND
	JLFS	INCP5		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
INCP5	JR	R4		:END OF INBFSB

::*********************************************************************
::
::	SUBROUTINE:	EVNBFS:
::	FUNCTION:	EVEN UP "BFSHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNBFS
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNBFS	HS	0
	AIS	R6,1
	NHI	R6,BFSSIZ-2	:INSURE HW BOUNDARY
	JR	R4		:END OF EVNBFS

::*********************************************************************
::
::	SUBROUTINE:	MRKBFS:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING BFSHST
::	CALLING SEQ:	JAL	R4,MRKBFS
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKBFS	HS	0
	ST	R4,REGSV8,,		:STORE R4
	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,BFSHST,R6,
	JAL	R4,INBFSH
	STH	R3,BFSHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INBFSH
	L	R4,REGSV8,,		:RESTORE R4
	JR	R4			:END OF MRKBFS

::*********************************************************************
::
::	SUBROUTINE:	BUFBFS:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING BFSHST
::	CALLING SEQ:	JAL	R3,BUFBFS
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFBFS	HS	0
	STH	R2,BFSHST,R6,	:BUFFER NUMBER
	JAL	R4,INBFSH
	LHL	R4,BF,R2,
	STH	R4,BFSHST,R6,	:BF OF BUFFER
	JAL	R4,INBFSH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,BFSHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INBFSH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFBFS

::*********************************************************************
::
::	SUBROUTINE:	CL3BFS:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R3) INTO RING BFSHST
::	CALLING SEQ:	JAL	R4,CL3BFS
::	INPUT:		R6 - RING POINTER
::			R3 - ADDRESS OF CALLER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

CL3BFS	HS	0
	ST	R4,REGSV8,,	:STORE R4
	EXHR	R3,R3
	STH	R3,BFSHST,R6,	:CALLER
	EXHR	R3,R3
	JAL	R4,INBFSH
	STH	R3,BFSHST,R6,
	JAL	R4,INBFSH
	L	R4,REGSV8,,	:RESTORE R4
	JR	R4		:END OF CL3BFS

::*********************************************************************
::
::	SUBROUTINE:	FRLTDB:
::	FUNCTION:	SAVE "FREELT" INTO RING BFSHST
::	CALLING SEQ:	JAL	R3,FRLTDB
::	INPUT:		R6 - RING POINTER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

FRLTDB	HS	0
	LHL	R4,FREELT,,
	STH	R4,BFSHST,R6,	:SAVE FREELT INTO RING BFSHST
	JAL	R4,INBFSH
	JR	R3		:END OF FRLTDB

::*********************************************************************
::
::	SUBROUTINE:	REBLDB:
::	FUNCTION:	SAVE "REBL" INTO RING BFSHST
::	CALLING SEQ:	JAL	R3,REBLDB
::	INPUT:		R6 - RING POINTER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

REBLDB	HS	0
	LHL	R4,REBL,,
	STH	R4,BFSHST,R6,	:SAVE REBL INTO RING BFSHST
	JAL	R4,INBFSH
	JR	R3		:END OF REBLDB

	EI	:BFSDBG

	IF	LPGDBG

::*********************************************************************
::
::	SUBROUTINE:	INLPGH:
::	FUNCTION:	INCREMENT "LPGHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INLPGH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLPGH	HS	0
	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,LPGSIZ	:CHECK IF NEED WRAP AROUND
	JLFS	INCP6		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
INCP6	JR	R4		:END OF INLPGH


::*********************************************************************
::
::	SUBROUTINE:	INLPGB:
::	FUNCTION:	INCREMENT "LPGHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INLPGB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLPGB	HS	0
	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,LPGSIZ	:CHECK IF NEED WRAP AROUND
	JLFS	INCP7		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
INCP7	JR	R4		:END OF INLPGB

::*********************************************************************
::
::	SUBROUTINE:	EVNLPG:
::	FUNCTION:	EVEN UP "LPGHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNLPG
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNLPG	HS	0
	AIS	R6,1
	NHI	R6,LPGSIZ-2	:INSURE HW BOUNDARY
	JR	R4		:END OF EVNLPG

::*********************************************************************
::
::	SUBROUTINE:	MRKLPG:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING LPGHST
::	CALLING SEQ:	JAL	R4,MRKLPG
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKLPG	HS	0
	ST	R4,REGSV8,,		:STORE R4
	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,LPGHST,R6,
	JAL	R4,INLPGH
	STH	R3,LPGHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INLPGH
	L	R4,REGSV8,,		:RESTORE R4
	JR	R4			:END OF MRKLPG

::*********************************************************************
::
::	SUBROUTINE:	BUFLPG:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING LPGHST
::	CALLING SEQ:	JAL	R3,BUFLPG
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFLPG	HS	0
	STH	R2,LPGHST,R6,	:BUFFER NUMBER
	JAL	R4,INLPGH
	LHL	R4,BF,R2,
	STH	R4,LPGHST,R6,	:BF OF BUFFER
	JAL	R4,INLPGH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,LPGHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INLPGH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFLPG

	EI	:LPGDBG


	IF	AIODBG
	IF	SOLOCS

::*********************************************************************
::
::	SUBROUTINE:	INAIOH:
::	FUNCTION:	INCREMENT "AIOHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INAIOH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INAIOH	HS	0
	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,AIOSIZ	:CHECK IF NEED WRAP AROUND
	JLFS	INCP8		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
INCP8	JR	R4		:END OF INAIOH


::*********************************************************************
::
::	SUBROUTINE:	INAIOB:
::	FUNCTION:	INCREMENT "AIOHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INAIOB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INAIOB	HS	0
	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,AIOSIZ	:CHECK IF NEED WRAP AROUND
	JLFS	INCP9		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
INCP9	JR	R4		:END OF INAIOB

::*********************************************************************
::
::	SUBROUTINE:	EVNAIO:
::	FUNCTION:	EVEN UP "AIOHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNAIO
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNAIO	HS	0
	AIS	R6,1
	NHI	R6,AIOSIZ-2	:INSURE HW BOUNDARY
	JR	R4		:END OF EVNAIO

::*********************************************************************
::
::	SUBROUTINE:	MRKAIO:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING AIOHST
::	CALLING SEQ:	JAL	R4,MRKAIO
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKAIO	HS	0
	ST	R4,REGSV8,,		:STORE R4
	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,AIOHST,R6,
	JAL	R4,INAIOH
	STH	R3,AIOHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INAIOH
	L	R4,REGSV8,,		:RESTORE R4
	JR	R4			:END OF MRKAIO

::*********************************************************************
::
::	SUBROUTINE:	BUFAIO:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING AIOHST
::	CALLING SEQ:	JAL	R3,BUFAIO
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFAIO	HS	0
	STH	R2,AIOHST,R6,	:BUFFER NUMBER
	JAL	R4,INAIOH
	LHL	R4,BF,R2,
	STH	R4,AIOHST,R6,	:BF OF BUFFER
	JAL	R4,INAIOH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,AIOHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INAIOH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFAIO

::*********************************************************************
::
::	SUBROUTINE:	CL7AIO:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R7) INTO RING AIOHST
::	CALLING SEQ:	JAL	R3,CL7AIO
::	INPUT:		R6 - RING POINTER
::			R7 - ADDRESS OF CALLER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

CL7AIO	HS	0
	EXHR	R7,R7
	STH	R7,AIOHST,R6,	:CALLER
	EXHR	R7,R7
	JAL	R4,INAIOH
	STH	R7,AIOHST,R6,
	JAL	R4,INAIOH
	JR	R3		:END OF CL7AIO

	EI	:SOLOCS
	EI	:AIODBG



	SUBTTL 	DEBUG ( PORT LOGON/LOGOFF DEBUGGER <LNFDBG> )

	IF	LNFDBG		:PORT LOGON/LOGOFF DEBUGGER

::*********************************************************************
::
::	SUBROUTINE:	LINDB1
::	FUNCTION:	DEBUGGER 1 FOR LOGIN
::	CALLING SEQ:	JAL	R4,LINDB1
::
::*********************************************************************

LINDB1	HS	0		:DEBUGGER  FOR  LOGIN
	ST	R4,REGSV1,,
	LHL	R4,LINDIS,,
	JE	HSULN1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,LNFPTR,,
	LIS	R3,2		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLNF
	STH	CHN,LNFHST,R6,	:ABS LOGIN CHANNEL NUMBER
	JAL	R4,INLNFH
	JAL	R3,BUFLNF	:STORE BUFFER STRUCTURE OF LOGIN BUFFER
	LHL	R3,TVRBUF
	STH	R3,LNFHST,R6,	:SUPERVISOR BUFFER
	JAL	R4,INLNFH
	STH	R0,LNFHST,R6,	:TID OF THE PORT
	JAL	R4,INLNFH
	STH	R6,LNFPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSULN1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF LINDB1

	IF	SOLOCS		:PORT LOGON/LOGOFF DEBUGGER
				:BUT SOLO CONSAT ONLY

::*********************************************************************
::
::	SUBROUTINE:	IZPDB1:
::	FUNCTION:	DEBUGGER 1 FOR IZ.PRT
::	CALLING SEQ:	JAL	R4,IZPDB1
::
::*********************************************************************

IZPDB1	HS	0		:DEBUGGER 1 FOR  IZ.PRT
	ST	R4,REGSV1,,
	LHL	R4,LNFDIS,,
	JE	HSUIZ3
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,LNFPTR,,
	LIS	R3,0		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLNF
	JAL	R3,CLALNF	:CALLER (RLINK)
	STH	PN,LNFHST,R6,	:PORT NUMBER
	JAL	R4,INLNFH
	L	R2,.FTBUF,RPI,	
	JAL	R3,BUFLNF	:STORE BUFFER STRUCTURE OF OLD .FTBUF
	STH	R6,LNFPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUIZ3	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF IZPDB1

::*********************************************************************
::
::	SUBROUTINE:	IZPDB2:
::	FUNCTION:	DEBUGGER 2 FOR IZ.PRT
::	CALLING SEQ:	JAL	R4,IZPDB2
::
::*********************************************************************

IZPDB2	HS	0		:DEBUGGER 2 FOR  IZ.PRT
	ST	R4,REGSV1,,
	LHL	R4,LNFDIS,,
	JE	HSUIZ6
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,LNFPTR,,
	L	R2,.FTBUF,RPI,	
	JAL	R3,BUFLNF	:STORE BUFFER STRUCTURE OF NEW .FTBUF
	STH	R6,LNFPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUIZ6	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF IZPDB2

::*********************************************************************
::
::	SUBROUTINE:	ESPDB1:
::	FUNCTION:	DEBUGGER 1 FOR ESTPRT
::	CALLING SEQ:	JAL	R4,ESPDB1
::
::*********************************************************************

ESPDB1	HS	0		:DEBUGGER  1 FOR  ESTPRT
	ST	R4,REGSV1,,
	LHL	R4,LNFDIS,,
	JE	HSUES1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,LNFPTR,,
	LIS	R3,1		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLNF
	STH	PN,LNFHST,R6,	:REL. ASY PORT #
	JAL	R4,INLNFH
	STH	CHN,LNFHST,R6,	:REL. ANI CHANNEL #
	JAL	R4,INLNFH
	JAL	R4,PRTLNF	:STORE BUFFER STRUCTURE OF THE PORT		
	STH	R6,LNFPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUES1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF ESPDB1

::*********************************************************************
::
::	SUBROUTINE:	SNDDB1:
::	FUNCTION:	DEBUGGER 1 FOR SNDLOG
::	CALLING SEQ:	JAL	R4,SNDDB1
::
::*********************************************************************

SNDDB1	HS	0		:DEBUGGER FOR SNDLOG
	ST	R4,REGSV1,,
	LHL	R4,SNDDIS,,
	JE	HSUSD1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,LNFPTR,,
	LIS	R3,3		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLNF
	STH	PN,LNFHST,R6,	:REL PORT NUMBER (PN)
	JAL	R4,INLNFH
	JAL	R4,PRTLNF	:STORE BUFFER STRUCTURE OF THE PORT
	STH	R6,LNFPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUSD1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF SNDDB1

::*********************************************************************
::
::	SUBROUTINE:	SNDDB2:
::	FUNCTION:	DEBUGGER 2 FOR SNDLOG
::	CALLING SEQ:	JAL	R4,SNDDB2
::
::*********************************************************************

SNDDB2	HS	0		:DEBUGGER 2 FOR SNDLOG
	ST	R4,REGSV1,,
	LHL	R4,SNDDIS,,
	JE	HSUSD3
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,
	LHL	R6,LNFPTR,,

	LHL	R3,BCT,R2,	:IS BUFFER EMPTY ?
	JLE	HSUSD7		:YES

	L	R3,BB,R2,
HSUSD4	HS	0
	LB	R1,0,R3		:GET CHARACTER
	STB	R1,LNFHST,R6,
	JAL	R4,INLNFB
	CL	R3,BE,R2,	:IS IT THE LAST CHAR. ?
	JEFS	HSUSD6		:YES
	JAL	R8,NCI,,	:CALCULATE BUFFER OUTPUT POINTER
	J	HSUSD4		:CONTINUE TO GET CHAR.
HSUSD6	HS	0
	JAL	R4,EVNLNF	:EVEN UP RING POINTER
	STH	R6,LNFPTR,,
HSUSD7	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSUSD3	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF SNDDB2

::*********************************************************************
::
::	SUBROUTINE:	SNDDB3:
::	FUNCTION:	DEBUGGER 3 FOR SNDLOG
::	CALLING SEQ:	JAL	R4,SNDDB3
::
::*********************************************************************

SNDDB3	HS	0		:DEBUGGER 3 FOR SNDLOG
	ST	R4,REGSV1,,
	LHL	R4,SNDDIS,,
	JE	HSUSD5
	ST	R6,REGSV2,,
	LHL	R6,LNFPTR,,
	LHI	R4,1
	STH	R4,LNFHST,R6,	:STORE 1, IF LOGIN BUFFER OVERFLOW
	JAL	R4,INLNFH
	STH	R6,LNFPTR,,
	L	R6,REGSV2,,
HSUSD5	L	R4,REGSV1,,
	JR	R4		:END OF SNDDB3

::*********************************************************************
::
::	SUBROUTINE:	ASLDB1:
::	FUNCTION:	DEBUGGER 1 FOR ASYLOU
::	CALLING SEQ:	JAL	R4,ASLDB1
::
::*********************************************************************

ASLDB1	HS	0		:DEBUGGER 1 FOR ASYLOU
	ST	R4,REGSV1,,
	LHL	R4,LNFDIS,,
	JE	HSUAL1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	ST	R8,REGSV4,,

	LHL	R6,LNFPTR,,

	LIS	R3,4		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLNF
	STH	R5,LNFHST,R6,	:REL ANI CHN #
	JAL	R4,INLNFH
	NHI	R10,-4
	STH	R10,LNFHST,R6,	:.ALBUF (GET FROM ANITAB)
	JAL	R4,INLNFH

	LR	R5,R5
	JL	HX1		:IF ANI CHN NEGATIVE, SKIP

	LIS	R3,0
	TBT	R5,ANIACP,,
	JE	HSUAS1
	LIS	R3,1
HSUAS1	STB	R3,LNFHST,R6,	:ANIACP/LOGSTB

	LIS	R3,0
	TBT	R5,LOGSTB,,
	JE	HSUAL2
	LIS	R3,1
HSUAL2	STB	R3,LNFHST+1,R6,
	JAL	R4,INLNFH
	IF	NMPVC
	LIS	R3,0
	TBT	R5,SUBSTB,,
	JE	HSUAL3
	LIS	R3,1
HSUAL3	STH	R3,LNFHST,R6,	:SUBSTB
	JAL	R4,INLNFH
	EI	:NMPVC
	LHL	R3,BF,R10,
	STH	R3,LNFHST,R6,	:BF(ALBUF)
	JAL	R4,INLNFH
	LHL	R3,BF+4,R10,,
	STH	R3,LNFHST,R6,	:BF(ALBUF+4)
	JAL	R4,INLNFH
	LHL	R3,ALMTAB,R5,R5 :.TTBUF (GET FROM ALMTAB)
	NHI	R3,-4
	STH	R3,LNFHST,R6,
	JAL	R4,INLNFH
	LHL	R8,BF-4,R3,
	STH	R8,LNFHST,R6,	:BF(.FTBUF)
	JAL	R4,INLNFH
	LHL	R8,BF,R3,	
	STH	R8,LNFHST,R6,	:BF(.TTBUF)
	JAL	R4,INLNFH
	LH	R8,BF,R3,
	JLE	HX1		:IF NEGATIVE OR = 0, SKIP
	SHI	R8,ASYZFL
	CLHI	R8,NPORT
	JGE	HX1		:IF NOT IN RANGE OF ASY, SKIP
	STH	R8,LNFHST,R6,	:REL ASY PORT NUMBER
	JAL	R4,INLNFH

	LIS	R4,0
	TBT	R8,ASYACP,,
	JE	HSUAS2
	LIS	R4,1
HSUAS2	STH	R4,LNFHST,R6,	:ASYACP
	JAL	R4,INLNFH

	LHL	R4,ASYTAB,R8,R8	:.FTBUF (GET FROM ASYTAB)
	STH	R4,LNFHST,R6,
	JAL	R4,INLNFH
HX1	STH	R6,LNFPTR,,

	L	R3,REGSV2,,
	L	R6,REGSV3,,
	L	R8,REGSV4,,
HSUAL1	HS	0
	L	R4,REGSV1,,
	JR	R4			:END OF ASLDB1

::*********************************************************************
::
::	SUBROUTINE:	ASLDB2:
::	FUNCTION:	DEBUGGER 2  FOR ASYLOU
::	CALLING SEQ:	JAL	R4,ASLDB2
::
::*********************************************************************

ASLDB2	HS	0		:DEBUGGER 2 FOR ASYLOU
	ST	R4,REGSV1,,
	LHL	R4,LNFDIS,,
	JE	HSUAL8	
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,
	ST	R8,REGSV4,,

	LHL	R6,LNFPTR,,
	L	R3,.TTBUF,RPI,	:.TTBUF (GET FROM PORT TABLE)
	STH	R3,LNFHST,R6,
	JAL	R4,INLNFH
	LHL	R8,BF-4,R3,	
	STH	R8,LNFHST,R6,	:BF(.FTBUF)
	JAL	R4,INLNFH
	LHL	R8,BF,R3,
	STH	R8,LNFHST,R6,	:BF(.TTBUF)
	JAL	R4,INLNFH
	LH	R8,BF,R3,
	JLE	HX3		:IF NEGATIVE OR = 0, SKIP
	SHI	R8,ASYZFL
	CLHI	R8,NPORT
	JGE	HX3		:IF NOT IN RANGE OF ASY, SKIP
	STH	R8,LNFHST,R6,	:REL ASY PORT #
	JAL	R4,INLNFH
HX3	STH	R6,LNFPTR,,
	L	R6,REGSV2,,
	L	R3,REGSV3,,
	L	R8,REGSV4,,
HSUAL8	HS	0
	L	R4,REGSV1,,
	JR	R4		::END OF ASLDB2

::*********************************************************************
::
::	SUBROUTINE:	ASLDB3:
::	FUNCTION:	DEBUGGER 3 FOR ASYLOU
::	CALLING SEQ:	JAL	R4,ASLDB3
::
::*********************************************************************

ASLDB3	HS	0		:DEBUGGER 3 FOR ASYLOU
	ST	R4,REGSV1,,
	LHL	R4,LNFDIS,,
	JE	HSUAL9
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,
	LHL	R6,LNFPTR,,

	LHL	R3,BCT,R2,	:IS BUFFER EMPTY ?
	JLE	HSUAL4		:YES

	L	R3,BB,R2,
HSUAL5	HS	0
	LB	R1,0,R3		:GET CHARACTER
	STB	R1,LNFHST,R6,
	JAL	R4,INLNFB
	CL	R3,BE,R2,	:IS IT THE LAST CHAR. ?
	JEFS	HSUAS3		:YES
	JAL	R8,NCI,,	:CALCULATE BUFFER OUTPUT POINTER
	J	HSUAL5		:CONTINUE GETTING CHAR.
HSUAS3	HS	0
	JAL	R4,EVNLNF	:EVEN UP RING POINTER
	STH	R6,LNFPTR,,
HSUAL4	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSUAL9	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF ASLDB3

::*********************************************************************
::
::	SUBROUTINE:	ASMDB1:
::	FUNCTION:	DEBUGGER 1 FOR ASYMPC
::	CALLING SEQ:	JAL	R4,ASMDB1
::
::*********************************************************************

	IF	NMPVC
ASMDB1	HS	0		:DEBUGGER 1 FOR ASYMPC
	ST	R4,REGSV1,,
	LHL	R4,ASMDIS,,
	JE	HSUAM1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,LNFPTR,,
	LIS	R3,5		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLNF
	STH	R5,LNFHST,R6,	:REL ANI CHN NUMBER
	JAL	R4,INLNFH	
	STH	R10,LNFHST,R6,	:.ALBUF (GET FROM ANITAB)
	JAL	R4,INLNFH
	STH	R11,LNFHST,R6,	:.TTBUF (GET ROM ALMTAB)
	JAL	R4,INLNFH
	LH	R3,BF,R11,	
	JLE	HX2		:IF NEGATIVE, OR = 0, SKIP
	SHI	R3,ASYZFL	
	CLHI	R3,NPORT
	JGE	HX2
	STH	R3,LNFHST,R6,	:REL ASY PORT NUMBER
	JAL	R4,INLNFH

	LHL	R4,ASYTAB,R3,R3	:.FTBUF (GET FROM ASYTAB)
	STH	R4,LNFHST,R6,	
	JAL	R4,INLNFH
	AR	R3,R3
	LHL	R4,.PTP.,R3,
	AI	R4,PTBASE
	L	R3,.TTBUF,R4,	:.TTBUF(GET FROM PORT TABLE)
	STH	R3,LNFHST,R6,
	JAL	R4,INLNFH

HX2	STH	R6,LNFPTR,,

	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUAM1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF ASMDB1

::*********************************************************************
::
::	SUBROUTINE:	ASMDB2:
::	FUNCTION:	DEBUGGER 2 FOR ASYMPC
::	CALLING SEQ:	JAL	R4,ASMDB2
::
::*********************************************************************

ASMDB2	HS	0		:DEBUGGER 2 FOR ASYMPC
	ST	R4,REGSV1,,
	LHL	R4,ASMDIS,,
	JE	HSUAM4
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,
	LHL	R6,LNFPTR,,

	LHL	R3,BCT,R2,	:IS BUFFER EMPTY ?
	JLE	HSUAM2		:YES

	L	R3,BB,R2,
HSUAM3	HS	0
	LB	R1,0,R3		:GET CHARACTER
	STB	R1,LNFHST,R6,
	JAL	R4,INLNFB
	CL	R3,BE,R2,	:IS IT THE LAST CHAR. ?
	JEFS	HSUAM5		:YES
	JAL	R8,NCI,,	:CALCULATE BUFFER OUTPUT POINTER
	J	HSUAM3		:CONTINUE TO GET CHAR.
HSUAM5	HS	0
	JAL	R4,EVNLNF	:EVEN UP RING POINTER
	STH	R6,LNFPTR,,
HSUAM2	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSUAM4	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF ASMDB2
	EI	:NMPVC

::*********************************************************************
::
::	SUBROUTINE:	DTPDB1:
::	FUNCTION:	DEBUGGER 1 FOR DT.PRT
::	CALLING SEQ:	JAL	R4,DTPDB1
::
::*********************************************************************

DTPDB1	HS	0		:DEBUGGER 1 FOR DT.PRT
	ST	R4,REGSV1,,	:SAVE REGISTER
	LHL	R4,LNFDIS,,
	JE	HSUDT1		
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	
	LHL	R6,LNFPTR,,
	LIS	R3,6		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLNF
	JAL	R3,CLALNF	:CALLER (RLINK)
	STH	PN,LNFHST,R6,	:REL. PORT NUMBER
	JAL	R4,INLNFH
	JAL	R4,PRTLNF	:STORE BUFFER STRUCTURE OF THE PORT
	STH	R6,LNFPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUDT1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF DTPDB1

::*********************************************************************
::
::	SUBROUTINE:	DPCAS:
::	FUNCTION:	SAVE CASE NUMBER FOR DT.PRT
::	CALLING SEQ:	JAL	R4,DPCAS
::
::*********************************************************************

DPCAS	HS	0		:SAVE CASE NUMBER FOR DT.PRT
	ST	R4,REGSV1,,
	LHL	R4,LNFDIS,,
	JE	HSUDT2
	STH	R1,DTPCAS,,
HSUDT2	L	R4,REGSV1,,
	JR	R4

::*********************************************************************
::
::	SUBROUTINE:	DTPDB2:
::	FUNCTION:	DEBUGGER 2 FOR DT.PRT
::	CALLING SEQ:	JAL	R4,DTPDB2
::
::*********************************************************************

DTPDB2	HS	0
	ST	R4,REGSV1,,
	LHL	R4,LNFDIS,,
	JE	HSUD10
	ST	R6,REGSV2,,
	LHL	R4,DTPCAS,,
	LHL	R6,LNFPTR,,
	STH	R4,LNFHST,R6,	:SAVE CASE #
	JAL	R4,INLNFH
	STH	R6,LNFPTR,,
	L	R6,REGSV2,,
HSUD10	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF DTPDB2

::*********************************************************************
::
::	SUBROUTINE:	CRDDB1:
::	FUNCTION:	DEBUGGER 1  FOR CIRDIS
::	CALLING SEQ:	JAL	R4,CRDDB1
::
::*********************************************************************

CRDDB1	HS	0
	ST	R4,REGSV1,,	:SAVE REGISTER
	LHL	R4,LNFDIS,,	:IS DEBUGGER ON
	JE	HSUCI1		:NO
	ST	R3,REGSV2,,	:SAVE REGISTER
	ST	R6,REGSV3,,

	LHL	R6,LNFPTR,,
	LIS	R3,7		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLNF
	JAL	R3,CLALNF	:CALLER (RLINK)
	STH	PN,LNFHST,R6,	:REL. PORT NUMBER
	JAL	R4,INLNFH
	JAL	R4,PRTLNF	:STORE BUFFER STRUCTURE OF THE PORT
	STH	R6,LNFPTR,,
	L	R3,REGSV2,,	:RESTORE REGISTER
	L	R6,REGSV3,,
HSUCI1	HS	0
	L	R4,REGSV1,,	:RESTORE REGISTER
	JR	R4		:END OF CRDDB1

::*********************************************************************
::
::	SUBROUTINE:	CRCAS:
::	FUNCTION:	DEBUGGER FOR CIRDIS TO SAVE CASE #
::	CALLING SEQ:	JAL	R4,CRCAS
::
::*********************************************************************

CRCAS	HS	0		:DEBUGGER FOR CIRDIS TO SAVE CASE #
	ST	R4,REGSV1,,
	LHL	R4,LNFDIS,,
	JE	HSUCI2
	STH	R3,CRDCAS,,
HSUCI2	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF CRCAS

::*********************************************************************
::
::	SUBROUTINE:	CRDDB2:
::	FUNCTION:	DEBUGGER 2 FOR CIRDIS
::	CALLING SEQ:	JAL	R4,CRDDB2
::
::*********************************************************************

CRDDB2	HS	0
	ST	R4,REGSV1,,
	LHL	R4,LNFDIS,,
	JE	HSUCR4
	ST	R6,REGSV2,,
	LHL	R6,LNFPTR,,
	LHL	R4,CRDCAS,,
	STH	R4,LNFHST,R6,	:SAVE CASE #
	JAL	R4,INLNFH
	STH	R6,LNFPTR,,
	L	R6,REGSV2,,
HSUCR4	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF CRDDB2

	EI	:SOLOCS
	EI	:LNFDBG		:END OF PORT LOGON/LOGOFF DEBUGGER



	SUBTTL DEBUG ( CRQ BUILDING/ZAPPING DEBUGGER <CBZDBG> )

	IF	CBZDBG		:CIRCUIT BUILDING/ZAPPING DEBUGGER

::*********************************************************************
::
::	SUBROUTINE:	CRHDB1:
::	FUNCTION:	DEBUGGER 1 FOR CRQHCR
::	CALLING SEQ:	JAL	R4,CRHDB1
::
::*****************************************************************
CRHDB1	HS	0		:DEBUGGER  1 FOR  CRQHCR
	ST	R4,REGSV1,,
	LHL	R4,CRQDIS,,
	JE	HSUCH1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,CBZPTR,,
	LIS	R3,8		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
	JAL	R3,BUFCBZ	:BUFFER STRUCTURE OF ORIGINAL BUFFER
	STH	R6,CBZPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUCH1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF CRHDB1

::*********************************************************************
::
::	SUBROUTINE:	CRQDB1:
::	FUNCTION:	DEBUGGER 1 FOR CRQ
::	CALLING SEQ:	JAL	R4,CRQDB1
::
::*********************************************************************

CRQDB1	HS	0		:DEBUGGER  1 FOR  CRQ
	ST	R4,REGSV1,,
	LHL	R4,CRQDIS,,
	JE	HSUCH1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,CBZPTR,,
	LIS	R3,9		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKCBZ
	JAL	R3,BUFCBZ	:BUFFER STRUCTURE OF NEEDLE BUFFER
	STH	R6,CBZPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUCH1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF CRQDB1

::*********************************************************************
::
::	SUBROUTINE:	ZPHDB1:
::	FUNCTION:	DEBUGGER FOR ZAPHRD
::	CALLING SEQ:	JAL	R4,ZPHDB1
::
::*********************************************************************

ZPHDB1	HS	0		:DEBUGGER FOR  ZAPHRD
	ST	R4,REGSV1,,
	LHL	R4,ZAPDIS,,
	JE	HSUZP1
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,

	LHL	R6,CBZPTR,,
	LIS	R3,0A		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
	JAL	R3,BUFCBZ	:STORE BUFFER STRUCTURE OF ORIGINAL BUF.
	STH	R6,CBZPTR,,
	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSUZP1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF ZPHDB1

::*********************************************************************
::
::	SUBROUTINE:	ZPVDB1:
::	FUNCTION:	DEBUGGER FOR ZAPV
::	CALLING SEQ:	JAL	R4,ZPVDB1
::
::*********************************************************************

ZPVDB1	HS	0		:DEBUGGER FOR  ZAPV
	ST	R4,REGSV1,,
	LHL	R4,ZAPDIS,,
	JE	HSUZV1
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,

	LHL	R6,CBZPTR,,
	LIS	R3,0B		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
	JAL	R3,BUFCBZ	:SOTRE BUFFER STRUCTURE OF ORIGINAL BUF.
	STH	R6,CBZPTR,,
	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSUZV1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF ZPVDB1

::::*************************************************
:  Debugger for gateway GB3CR3
:   R5 channel clearing IOTAB
:                                       sdw
::***************************************************

        IF      T2GATE
GPZDB3  HS      0               :DEBUGGER FOR DB3CR3
	ST	R4,REGSV1,,
	LHL	R4,ZAPDIS,,
	JE	HSUGV2
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,

	LHL	R6,CBZPTR,,
	LHI	R3,1E		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKCBZ
        STH     R5,CBZHST,R6,    :save the channel number
        JAL     R4,INCBZH       :bump up pointer by 2
	STH	R6,CBZPTR,,
	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSUGV3	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF ZPVDB1
        EI      :T2GATE

::::*************************************************
:  Debugger for gateway ZAPX7
:   R3 channel clearing IOTAB
:                                       sdw
::***************************************************

        IF      T2GATE
GPZDB2	HS	0		:DEBUGGER FOR  ZAPX7
	ST	R4,REGSV1,,
	LHL	R4,ZAPDIS,,
	JE	HSUGV2
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,

	LHL	R6,CBZPTR,,
	LHI	R3,1E		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKCBZ
        L       R3,REGSV3,,
        STH     R3,CBZHST,R6,    :save the channel number
        JAL     R4,INCBZH       :bump up pointer by 2
	STH	R6,CBZPTR,,
	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSUGV2	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF ZPVDB1
        EI      :T2GATE


::::*************************************************
:  Debugger for gateway GLZPV
:   r9 link, r5 channel clearing IOTAB
:                                       sdw
::***************************************************

        IF      T2GATE
GPZDB1	HS	0		:DEBUGGER FOR  GLZPV
	ST	R4,REGSV1,,
	LHL	R4,ZAPDIS,,
	JE	HSUGV1
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,

	LHL	R6,CBZPTR,,
	LHI	R3,1C		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
        STH     R5,CBZHST,R6,    :save the channel number
        JAL     R4,INCBZH       :bump up pointer by 2
	STH	R6,CBZPTR,,
	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSUGV1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF ZPVDB1
        EI      :T2GATE

	EI	:CBZDBG		:END OF CRQ BUILDING/ZAPPING DEBUGGER



	SUBTTL DEBUG ( BUFFER STRUCTURE DEBUGGER <BFSDBG> )

	IF	BFSDBG		:BUFFER STRUCTURE DEBUGGER

::*********************************************************************
::
::	SUBROUTINE:	GFCDB1:
::	FUNCTION:	DEBUGGER FOR GFCBUF
::	CALLING SEQ:	JAL	R4,GFCDB1
::
::*********************************************************************

GFCDB1	HS	0
	ST	R4,REGSV1,,
	LHL	R4,GRFDIS	
	JE	HSUGF1		
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,
	LHL	R6,BFSPTR,,	
	LIS	R3,0C		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKBFS
	LR	R3,R8		:CALLER (R8)
	JAL	R4,CL3BFS
	LHL	R2,FREELB
	STH	R2,BFSHST,R6,	:BUFFER NUMBER
	JAL	R4,INBFSH
	STH	R6,BFSPTR,,	
	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSUGF1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF GFCDB1

::*********************************************************************
::
::	SUBROUTINE:	RFCDB1:
::	FUNCTION:	DEBUGGER FOR RFCBUF
::	CALLING SEQ:	JAL	R4,RFCDB1
::
::*********************************************************************

RFCDB1	HS	0
	ST	R4,REGSV1,,
	LHL	R4,GRFDIS	
	JE	HSURF1	
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,
	LHL	R6,BFSPTR,,
	LIS	R3,0D		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKBFS
	LR	R3,R8		:CALLER (R8)
	JAL	R4,CL3BFS
	JAL	R3,BUFBFS	:STORE THE BUFFER (R2)'S STRUCTURE
	STH	R6,BFSPTR,,	
	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSURF1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF RFCDB1

::*********************************************************************
::
::	SUBROUTINE:	CBCDB1:
::	FUNCTION:	DEBUGGER 1 FOR CBCLR
::	CALLING SEQ:	JAL	R4,CBCDB1
::
::*********************************************************************

CBCDB1	HS	0		:DEBUGGER  1 FOR   CBCLR
	ST	R4,REGSV1,,
	LHL	R4,CBCDIS,,
	JE	HSUCB1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,BFSPTR,,
	LHI	R3,0F		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKBFS
	LR	R3,R8		:CALLER (R8)
	JAL	R4,CL3BFS
	JAL	R3,BUFBFS	:STRUCTURE OF ORIGINAL BUFFER
	LHL	R4,BCT,R2,
	STH	R4,BFSHST,R6,	:BCT OF ORIGINAL
	JAL	R4,INBFSH
	JAL	R3,FRLTDB	:OLD FREELT (BEFORE BUFFER IS CLEARED)
	STH	R6,BFSPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUCB1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF CBCDB1

::*********************************************************************
::
::	SUBROUTINE:	CBCDB2:
::	FUNCTION:	DEBUGGER 2 FOR CBCLR
::	CALLING SEQ:	JAL	R4,CBCDB2
::
::*********************************************************************

CBCDB2	HS	0		:DEBUGGER  2 FOR  CBCLR
	ST	R4,REGSV1,,
	LHL	R4,CBCDIS,,
	JE	HSUCB2
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,BFSPTR,,
	JAL	R3,FRLTDB	:NEW FREELT (AFTER BUFFER IS CLEARED)
	STH	R6,BFSPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUCB2	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF CBCDB2

::*********************************************************************
::
::	SUBROUTINE:	WREDB1:
::	FUNCTION:	DEBUGGER 1 FOR WRE
::	CALLING SEQ:	JAL	R4,WREDB1
::
::*********************************************************************

WREDB1	HS	0		:DEBUGGER 1 FOR  WRE
	ST	R4,REGSV1,,
	LHL	R4,WREDIS,,
	JE	HSUWR1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,BFSPTR,,
	LHI	R3,10		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKBFS
	LR	R3,R0		:CALLER (R0)
	JAL	R4,CL3BFS
	JAL	R3,FRLTDB	:OLD FREELT (BEFORE LINK RESERVE TANK)
	JAL	R3,REBLDB	:OLD REBL (BEFORE LINK RESERVE TANK)
	STH	R6,BFSPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUWR1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF WREDB1

::*********************************************************************
::
::	SUBROUTINE:	WREDB2:
::	FUNCTION:	DEBUGGER 2 FOR WRE
::	CALLING SEQ:	JAL	R4,WREDB2
::
::*********************************************************************

WREDB2	HS	0		:DEBUGGER 2 FOR  WRE
	ST	R4,REGSV1,,
	LHL	R4,WREDIS,,
	JE	HSUWR2
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,BFSPTR,,
	JAL	R3,FRLTDB	:NEW FREELT (AFTER LINK RESERVE TANK)
	JAL	R3,REBLDB	:NEW REBL (AFTER LINK RESERVE TANK)
	STH	R6,BFSPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUWR2	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF WREDB2

::*********************************************************************
::
::	SUBROUTINE:	CKZDB1:
::	FUNCTION:	DEBUGGER 1 FOR CKZB
::	CALLING SEQ:	JAL	R4,CKZDB1
::
::*********************************************************************

CKZDB1	HS	0		:DEBUGGER 1  FOR  CKZB
	ST	R4,REGSV1,,
	LHL	R4,WREDIS,,
	JE	HSUCZ1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,BFSPTR,,
	LHI	R3,11		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKBFS
	JAL	R3,FRLTDB	:NEW FREELT (AFTER GOT 80 BUFFERLETS
				:AND REFILLED THE RESERVE TANK)
	JAL	R3,REBLDB	:NEW REBL (AFTER GOT 80 BUFFERLETS 
				:AND REFILLED THE RESERVE TANK)
	STH	R6,BFSPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUCZ1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF CKZDB1

::*********************************************************************
::
::	SUBROUTINE:	RBZDB1
::	FUNCTION:	DEBUGGER 1 FOR REBZ
::	CALLING SEQ:	JAL	R4,RBZDB1
::
::*********************************************************************

RBZDB1	HS	0		:DEBUGGER 1 FOR  REBZ
	ST	R4,REGSV1,,
	LHL	R4,WREDIS,,
	JE	HSURZ1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,BFSPTR,,
	LHI	R3,12		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKBFS
	STH	R2,BFSHST,R6,	:THE BUFFER ZAPPED
	JAL	R4,INBFSH
	JAL	R3,FRLTDB	:NEW FREELT (AFTER BUFFER IS ZAPPED)
	STH	R6,BFSPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSURZ1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF RBZDB1

::*********************************************************************
::
::	SUBROUTINE:	BFZDB1
::	FUNCTION:	DEBUGGER 1 FOR BUFZAP
::	CALLING SEQ:	JAL	R4,BFZDB1
::
::*********************************************************************

BFZDB1	HS	0		:DEBUGGER  1 FOR  BUFZAP
	ST	R4,REGSV1,,
	LHL	R4,WREDIS,,
	JE	HSUFZ1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,BFSPTR,,
	LHI	R3,13		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKBFS
	LR	R3,R0		:CALLER (R0)
	JAL	R4,CL3BFS
	STH	R2,BFSHST,R6,	:BUFFER NUMBER TO BE ZAPPED
	JAL	R4,INBFSH	
	STH	R8,BFSHST,R6,	:BUFFER COUNT OF THE BUFFER 
	JAL	R4,INBFSH
	JAL	R3,FRLTDB	:NEW FREELT (AFTER BUFFER IS CLEARED)
	JAL	R4,INBFSH
	STH	R6,BFSPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUFZ1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF BFZDB1

::*********************************************************************
::
::	SUBROUTINE:	EMTDB1:
::	FUNCTION:	DEBUGGER FOR EMPTY
::	CALLING SEQ:	JAL	R4,EMTDB1
::
::*********************************************************************

	IF	SOLOCS		:BUFFER STRUCTURE DEBUGGER
				:BUT SOLO CONSAT ONLY

EMTDB1	HS	0		:DEBUGGER 1 FOR EMPTY
	ST	R4,REGSV1,,
	LHL	R4,EMTDIS,,
	JE	HSUEM1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,BFSPTR,,
	LIS	R3,0E		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKBFS
	LR	R3,R7		:CALLER (R7)
	JAL	R4,CL3BFS
	JAL	R3,BUFBFS	:STORE THE BUFFER STRUCTURE
	STH	R6,BFSPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSUEM1	L	R4,REGSV1,,
	JR	R4		:END OF EMTDB1

	EI	:SOLOCS		
	EI	:BFSDBG		:END OF BUFFER STRUCTURE DEBUGGER



	SUBTTL	DEBUG ( NODE CODE - SUPE COMM. DEBUGGER <LPGDBG> )

	IF	LPGDBG

::*********************************************************************
::
::	SUBROUTINE:	LEPDB1
::	FUNCTION:	DEBUGGER 1 FOR LEP
::	CALLING SEQ:	JAL	R4,LEPDB1
::
::*********************************************************************

LEPDB1	HS	0		:DEBUGGER  1  FOR  LEP
	ST	R4,REGSV1,,
	LHL	R4,LPGDIS,,
	JE	HSULE1
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,LPGPTR,,
	LHI	R3,14		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLPG
	STH	R1,LPGHST,R6,	:LEADING 0
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSULE1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF LEPDB1

::*********************************************************************
::
::	SUBROUTINE:	LEPDB2
::	FUNCTION:	DEBUGGER 2 FOR LEP
::	CALLING SEQ:	JAL	R4,LEPDB2
::	INPUT:		R5 - LRC (BYTE COUNT OF MESSAGE)
::
::*********************************************************************

LEPDB2	HS	0		:DEBUGGER  2  FOR  LEP
	ST	R4,REGSV1,,
	LHL	R4,LPGDIS,,
	JE	HSULE2
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,LPGPTR,,
	SIS	R5,2		:LRC INCLUDES LEADING 0 AND LRC ITSELF
HSULE3	HS	0
	JAL	R8,PCI,,	:THE DATA IN LEP BUFFER
	STB	R1,LPGHST,R6,
	JAL	R4,INLPGB
	SIS	R5,1		:DECREMENT THE BYTE COUNT
	JGBS	HSULE3
	JAL	R4,EVNLPG	:EVEN UP RING POINTER
	STH	R6,LPGPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSULE2	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF LEPDB2

::*********************************************************************
::
::	SUBROUTINE:	LPDDB1
::	FUNCTION:	DEBUGGER 1 FOR LEP0D
::	CALLING SEQ:	JAL	R4,LPDDB1
::
::*********************************************************************

LPDDB1	HS	0		:DEBUGGER  1  FOR  LEP0D
	ST	R4,REGSV1,,
	LHL	R4,LPDDIS,,
	JE	HSULD0
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,LPGPTR,,
	LHI	R3,16		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLPG
	STH	CHN,LPGHST,R6,	:CHN (ABS LOGIN CHANNEL NUMBER)
	JAL	R4,INLPGH
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	LR	R3,R7
	NHI	R3,0E0
	STB	R3,LPGHST,R6,	:FLAG
	JAL	R4,INLPGB
	LR	R3,R7
	NHI	R3,1F
	STB	R3,LPGHST,R6,	:MESSAGE SUB TYPE
	JAL	R4,INLPGB
	STH	R6,LPGPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSULD0	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF LPDDB1

::*********************************************************************
::
::	SUBROUTINE:	LP9DB1:
::	FUNCTION:	DEBUGGER 1 FOR LEP09
::	CALLING SEQ:	JAL	R4,LP9DB1
::	INPUT:		R6 - LOGIN BUFFER
::			R7 - TO NETWORK BUFFER		
::
::*********************************************************************

LP9DB1	HS	0		:DEBUGGER  1  FOR  LEP09
	ST	R4,REGSV1,,
	LHL	R4,LPDDIS,,
	JE	HSUL90
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	ST	R2,REGSV4,,
	LR	R2,R6		:LOAD LOGIN BUFFER INTO R2
	LHL	R6,LPGPTR,,
	LHI	R3,17		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLPG
	STH	CHN,LPGHST,R6,	:CHN (ABS LOGIN CHANNEL NUMBER)
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	STH	R7,LPGHST,R6,	:TO NETWORK BUFFER NUMBER
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
	L	R2,REGSV4,,
HSUL90	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF LP9DB1

::*********************************************************************
::
::	SUBROUTINE:	LP9DB2:
::	FUNCTION:	DEBUGGER 2 FOR LEP09
::	CALLING SEQ:	JAL	R4,LP9DB2
::	INPUT:		R3 - CASE #
::
::*********************************************************************

LP9DB2	HS	0		:DEBUGGER  2 FOR  LEP09
	ST	R4,REGSV1,,
	LHL	R4,LPDDIS,,
	JE	HSUL92
	ST	R6,REGSV3,,
	LHL	R6,LPGPTR,,
	STH	R3,LPGHST,R6,	:CASE NUMBER
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	L	R6,REGSV3,,
HSUL92	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF LP9DB2

::*********************************************************************
::
::	SUBROUTINE:	LPZDB1
::	FUNCTION:	DEBUGGER 1 FOR LEPZLI
::	CALLING SEQ:	JAL	R4,LPZDB1
::
::*********************************************************************

LPZDB1	HS	0		:DEBUGGER  1  FOR  LEPZLI
	ST	R4,REGSV1,,
	LHL	R4,LPDDIS,,
	JE	HSULZ0
	ST	R3,REGSV2,,
	ST	R6,REGSV3,,
	LHL	R6,LPGPTR,,
	LHI	R3,18		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLPG
	STH	CHN,LPGHST,R6,	:CHN (ABS LOGIN CHANNEL NUMBER)
	JAL	R4,INLPGH
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	STH	R6,LPGPTR,,
	L	R3,REGSV2,,
	L	R6,REGSV3,,
HSULZ0	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF LPZDB1


::*********************************************************************
::
::	SUBROUTINE:	LGGDB2
::	FUNCTION:	DEBUGGER 2 FOR LOGGER TO SAVE CASE #
::	CALLING SEQ:	JAL	R4,LGGDB2
::	INPUT:		R1 - CASE #
::
::*********************************************************************

LGGDB2	HS	0		:DEBUGGER  2 FOR  LOGGER
	ST	R4,REGSV1,,
	LHL	R4,LPGDIS,,
	JE	HSULG2
	ST	R6,REGSV3,,
	ST	R3,REGSV2,,
	LHL	R6,LPGPTR,,
	LHI	R3,15		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKLPG
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	STH	R1,LPGHST,R6,	:CASE #
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	L	R6,REGSV3,,
	L	R3,REGSV2,,
HSULG2	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF LGGDB2
::*********************************************************************
::
::	SUBROUTINE:	LGGDB3
::	FUNCTION:	DEBUGGER 3 FOR LOGGER
::	CALLING SEQ:	JAL	R4,LGGDB3
::	INPUT:		R2 - TVRBUF (SUPERVISOR BUFFER)
::
::*********************************************************************

LGGDB3	HS	0		:DEBUGGER  3  FOR  LOGGER
	ST	R4,REGSV1,,
	LHL	R4,LPGDIS,,
	JE	HSULG3
	ST	R6,REGSV3,,
	ST	R3,REGSV2,,
	LHL	R6,LPGPTR,,
	LHL	R3,BCT,R2,	:IS BUFFER EMPTY ?
	JLE	HSULG4		:YES

	L	R3,LPGSSV,,	:GET POINTER TO MSG TYPE
HSULG5	HS	0
	LB	R1,0,R3		:GET CHARACTER
	STB	R1,LPGHST,R6,
	JAL	R4,INLPGB
	CL	R3,BE,R2,	:IS IT THE LAST CHAR. ?
	JEFS	HSULG6		:YES
	JAL	R8,NCI,,	:CALCULATE BUFFER OUTPUT POINTER
	J	HSULG5		:CONTINUE TO GET CHAR.
HSULG6	HS	0
	JAL	R4,EVNLPG	:EVEN UP RING POINTER
	STH	R6,LPGPTR,,
HSULG4	L	R6,REGSV3,,
	L	R3,REGSV2,,
HSULG3	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF LGGDB3

	EI	:LPGDBG		:END OF NODE CODE - SUPE COMM DEBUGGER


	SUBTTL	DEBUG ( ASYNC INPUT/OUTPUT DEBUGGER <AIODBG> )

	IF	AIODBG		:ASYNC INPUT/OUTPUT DEBUGGER
	IF	SOLOCS		:BUT SOLO CONSAT ONLY

::*********************************************************************
::
::	SUBROUTINE:	GTCDB1:
::	FUNCTION:	DEBUGGER 1 FOR GETCHR
::	CALLING SEQ:	JAL	R4,GTCDB1
::
::*********************************************************************

GTCDB1	HS	0		:DEBUGGER 1 FOR GETCHR
	ST	R4,REGSV1,,
	LHL	R4,GTCDIS,,
	JE	HSUGC1
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,
	LHL	R6,AIOPTR,,
	LHI	R3,19		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKAIO
	JAL	R3,CL7AIO	:CALLER (R7)
	JAL	R3,BUFAIO	:STORE BUFFER (R2)'S STRUCTURE
	STH	R6,AIOPTR,,
	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSUGC1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF GTCDB1

::*********************************************************************
::
::	SUBROUTINE:	GTCDB2:
::	FUNCTION:	DEBUGGER 2 FOR GETCHR
::	CALLING SEQ:	JAL	R4,GTCDB2
::
::*********************************************************************

GTCDB2	HS	0
	ST	R4,REGSV2,,
	LHL	R4,GTCDIS,,
	JE	HSUGC9
	ST	R6,REGSV1,,
	LHL	R6,AIOPTR,,
	STH	R1,AIOHST,R6,	:DATA CHARACTER
	JAL	R4,INAIOH
	STH	R6,AIOPTR,,
	L	R6,REGSV1,,
HSUGC9	L	R4,REGSV2,,
	JR	R4		:END OF GTCDB2
::*********************************************************************
::
::	SUBROUTINE:	GTCDB3:
::	FUNCTION:	DEBUGGER 3 FOR GETCHR
::	CALLING SEQ:	JAL	R4,GTCDB3
::
::*********************************************************************

GTCDB3	HS	0
	ST	R4,REGSV2,,
	LHL	R4,GTCDIS,,
	JE	HSUGC3
	ST	R6,REGSV1,,
	LHL	R6,AIOPTR,,
	STH	R1,AIOHST,R6,	:DATA CHARACTER
	JAL	R4,INAIOH
	LH	R4,PFXSIG,R1,R1
	STH	R4,AIOHST,R6,	:CONTENTS OF PFXSIG TABLE
	JAL	R4,INAIOH
	STH	R6,AIOPTR,,
	L	R6,REGSV1,,
HSUGC3	L	R4,REGSV2,,
	JR	R4		:END OF GTCDB3
::*********************************************************************
::
::	SUBROUTINE:	GTCDB4:
::	FUNCTION:	DEBUGGER 3 FOR GETCHR
::	CALLING SEQ:	JAL	R4,GTCDB4
::
::*********************************************************************

GTCDB4	HS	0
	ST	R4,REGSV2,,
	LHL	R4,GTCDIS,,
	JE	HSUGC4
	ST	R6,REGSV1,,
	LHL	R6,AIOPTR,,
	STH	R5,AIOHST,R6,	:CONSAT SIGNAL NUMBER
	JAL	R4,INAIOH
	STH	R6,AIOPTR,,
	L	R6,REGSV1,,
HSUGC4	L	R4,REGSV2,,
	JR	R4		:END OF GTCDB4

::*********************************************************************
::
::	SUBROUTINE:	PTCDB1:
::	FUNCTION:	DEBUGGER FOR PUTCHR
::	CALLING SEQ:	JAL	R4,PTCDB1
::
::*********************************************************************

PTCDB1	HS	0		:DEBUGGER FOR PUTCHR
	ST	R4,REGSV1,,
	LHL	R4,PTCDIS,,
	JE	HSUPC1
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,
	LHL	R6,AIOPTR,,
	LHI	R3,1A		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKAIO
	JAL	R3,CL7AIO	:CALLER (R7)
	JAL	R3,BUFAIO	:STORE BUFFER (R2)'S STRUCTURE
	STH	R1,AIOHST,R6,	:CHARACTER (FROM CONSAT)
:				:(HAS NOT ESCAPED YET)
	JAL	R4,INAIOH
	STH	R6,AIOPTR,,
	L	R6,REGSV2,,
	L	R3,REGSV3,,
HSUPC1	HS	0
	L	R4,REGSV1,,
	JR	R4		:END OF PTCDB1

::*********************************************************************
::
::	SUBROUTINE:	PTSDB1:
::	FUNCTION:	DEBUGGER FOR PUTSIG
::	CALLING SEQ:	JAL	R4,PTSDB1
::
::*********************************************************************

PTSDB1	HS	0		:DEBUGGER FOR PUTSIG
	ST	R4,REGSV2,,
	LHL	R4,PTSDIS,,
	JE	HSUPS1
	ST	R3,REGSV1,,
	ST	R6,REGSV3,,
	LHL	R6,AIOPTR,,
	LHI	R3,1B		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R4,MRKAIO
	JAL	R3,CL7AIO	:CALLER (R7)
	JAL	R3,BUFAIO	:STORE BUFFER (R2)'S STRUCTURE
	STB	R8,AIOHST,R6,	:CONSAT SIGNAL NUMBER (BYTE)
	STB	R1,AIOHST+1,R6,	:ASSOCIATED DATA (BYTE)
	JAL	R4,INAIOH
	LHL	R3,CONSIG,R8,R8
	STH	R3,AIOHST,R6,	:CONTENTS OF CONSIG TABLE
	JAL	R4,INAIOH
	LIS	R3,0
	TBT	R8,SIGDAT,,
	JEFS	HSUPS3
	LIS	R3,1
HSUPS3	STH	R1,AIOHST,R6,	: = 0,  THERE IS NO ASSOCIATED DATA
:				: = 1, THERE IS ASSOCIATED DATA
	JAL	R4,INAIOH
	STH	R6,AIOPTR,,
	L	R3,REGSV1,,
	L	R6,REGSV3,,
HSUPS1	HS	0
	L	R4,REGSV2,,
	JR	R4		:END OF PTSDB1
::*********************************************************************
::
::	SUBROUTINE:	PTSDB2:
::	FUNCTION:	DEBUGGER 2 FOR PUTSIG
::	CALLING SEQ:	JAL	R4,PTSDB2
::
::*********************************************************************

PTSDB2	HS	0		:DEBUGGER FOR PUTSIG
	ST	R4,REGSV2,,
	LHL	R3,PTSDIS,,
	JE	HSUPS2
	ST	R6,REGSV3,,
	LHL	R6,AIOPTR,,
	EXBR	R1,R1
	STH	R1,AIOHST,R6,	:NODE CODE CONTROL SIGNAL
:				:(AND WITH CONTROL SIGNAL ALREADY)
	EXBR	R1,R1
	JAL	R4,INAIOH
	STH	R6,AIOPTR,,
	L	R6,REGSV3,,
HSUPS2	HS	0
	L	R4,REGSV2,,
	JR	R4		:END OF PTSDB2

	EI	:SOLOCS
	EI	:AIODBG		:END OF ASYNC INPUT/OUTPUT DEBUGGER


	SUBTTL	DEBUG (OTHER DEBUGGING AIDS)

::*********************************************************************
::
::	SUBROUTINE:	BFZDB2
::	FUNCTION:	DEBUGGER 2 FOR BUFZAP PROBLEM
::			SAVE SOME DATA OF THE BUFFER TO BE ZAPPED
::			BECAUSE OF BCT OVERFLOW.
::	CALLING SEQ:	JAL	R4,BFZDB2
::	INPUT:		R2 - BUFFER NUMBER TO BE ZAPED
::
::*********************************************************************

BFZDB2	HS	0		:DEBUGGER  2 FOR  BUFZAP PROBLEM
	ST	R1,REGSV1,,
	ST	R6,REGSV2,,
	ST	R3,REGSV3,,
	ST	R8,REGSV4,,
	LIS	R6,0		:POINTER TO THE SAVED BUFFER

	LHL	R3,BCT,R2,	:DOES BCT OF BUFFER OVERFLOW ?
	CI	R3,0FFF0	
	JL	HSUFZ4		:NO, EXIT

	L	R3,BB,R2,
HSUFZ5	HS	0
	LB	R1,0,R3		:GET CHARACTER
	STB	R1,BUFZSV,R6,	:STORE INTO BUFFER BUFZSV.
	CL	R3,BE,R2,	:IS IT THE LAST CHAR. ?
	JEFS	HSUFZ4		:YES, EXIT
	JAL	R8,NCI,,	:CALCULATE BUFFER OUTPUT POINTER
	AIS	R6,1		:INCREMENT POINTER
	CHI	R6,BUFZSZ	:HAVE WE STORED BUFSZ BYTES YET ?
	JL	HSUFZ5		:CONTINUE GETTING CHAR.
HSUFZ4	L	R6,REGSV2,,
	L	R3,REGSV3,,
	L	R8,REGSV4,,
	L	R1,REGSV1,,
	JR	R4		:END OF BFZDB2


	SUBTTL	DEBUG (XRAY COMMANDS)

::*********************************************************************
::
::	TABLE:		INTERP
::	FUNCTION:	THIS IS A TABLE TO SHOW 3-LETTER INTERPRETATIONS
::			FOR SOME OF THE ROUTINES.
::
::*********************************************************************
	IF	DBGON
INTERP	HS	0
	SC	/IZP/	:IZ.PRT		ROUTINE NUMBER 0
	SC	/ESP/	:ESPRT		ROUTINE NUMBER 1
	SC	/LIN/	:LOGIN		ROUTINE NUMBER 2
	SC	/SND/	:SNDLOG		ROUTINE NUMBER 3
	SC	/ASL/	:ASYLOU		ROUTINE NUMBER 4
	SC	/ASM/	:ASYMPC		ROUTINE NUMBER 5
	SC	/DTP/	:DT.PRT		ROUTINE NUMBER 6
	SC	/CRD/	:CIRDIS		ROUTINE NUMBER 7
	SC	/CRH/	:CRQHCR		ROUTINE NUMBER 8
	SC	/CRQ/	:CRQ		ROUTINE NUMBER 9
	SC	/ZPH/	:ZAPHRD		ROUTINE NUMBER A
	SC	/ZPV/	:ZAPV		ROUTINE NUMBER B
	SC	/GFC/	:GFCBUF		ROUTINE NUMBER C
	SC	/RFC/	:RFCBUF		ROUTINE NUMBER D
	SC	/EMT/	:EMPTY		ROUTINE NUMBER E
	SC	/CBC/	:CBCLR		ROUTINE NUMBER F
	SC	/WRE/	:WRE		ROUTINE NUMBER 10
	SC	/CKZ/	:CKZB		ROUTINE NUMBER 11
	SC	/RBZ/	:REBZ		ROUTINE NUMBER 12
	SC	/BFZ/	:BUFZAP		ROUTINE NUMBER 13
	SC	/LEP/	:LEP		ROUTINE NUMBER 14
	SC	/LGG/	:LOGGER		ROUTINE NUMBER 15
	SC	/LPD/	:LEP0D		ROUTINE NUMBER 16
	SC	/LP9/	:LEP09		ROUTINE NUMBER 17
	SC	/LPZ/	:LEPZLI		ROUTINE NUMBER 18
	SC	/GTC/	:GETCHR		ROUTINE NUMBER 19
	SC	/PTC/	:PUTCHR		ROUTINE NUMBER 1A
	SC	/PTS/	:PUTSIG		ROUTINE NUMBER 1B
	SC	/GPV/	:GLZPV		ROUTINE NUMBER 1C
	SC	/B3Z/	:GB3CR3		ROUTINE NUMBER 1D
	SC	/ZPZ/	:ZAPX7		ROUTINE NUMBER 1E
MXRTNM	EQ	(.-INTERP)/4-1	:MAX ROUTINE NUMBER

::*********************************************************************
::
::	SUBROUTINE:	TYPCIU
::	FUNCTION:	TYPE MESSAGE "This command is in use"
::
::*********************************************************************
TYPCIU	LA	R2,ASCCIU	:TYPE "This command is in use."
	JAL	R7,TYPASC,,
	J	XRCRLF,,	:QUIT AND YIELD

ASCCIU	SC	/"0D"0AThis command is in use./

::*********************************************************************
::
::	SUBROUTINE:	RSTCIU
::	FUNCTION:	RESET COMMAND IN USE INDICATOR TO INDICATE
::			THE COMMAND IS NOT IN USE.
::			0 = NOT IN USE,  1 = IN USE.
::	INPUT:		R8 = THE POINTER TO THE INDICATOR
::*********************************************************************
RSTCIU	LIS	R3,0
	STH	R3,,R8,		:RESET COMMAND IN USE INDICATOR
	J	XRCRLF,,	:QUIT AND YIELD

::*********************************************************************
::
::	SUBROUTINE:	XRDSRN
::	FUNCTION:	DISPLAY ALL THE DATA IN A HISTORY RING
::	CALLING SEQ:	JUMP 
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - COMMAND IN USE INDICATOR
::
::*********************************************************************
XRDSRN	HS	0
	LR	R12,R11		:KEEP THE ORIGINAL RING POINTER IN R12
DBINST				:INITIALIZE THE STATE MARKERS
	LIS	R6,0		:HEAD LINE INDICATOR.  1 -- HEAD LINE.
	LIS	R10,8		:MAX # OF HW PER LINE. 9 -- HEAD LINE.
DBGTHW	HS	0
	LH	R3,SAVHST,R11,	:GET HW FROM RING
	JE	DBFLSH		:FLUSH LEADING ZEROS
	LR	R6,R6		:ARE WE EXPECTING A ROUTINE NUMBER
	JL	DBRTNM		:YES,
	CHI	R3,HSUMRK	:NO, THEN IS THIS A ROUTINE MARKER ?
	JE	DBHEAD		:YES, 
	CHI	R10,8		:IS IT THE FIRST DATA BYTE ?
	JE	DBFSDT		:YES, IT IS THE FIRST DATA
DBTPHW	HS	0		:NO, IT IS NOT THE FIRST DATA 
	JAL	R9,TYPHW,,	:OUTPUT THE HALFWORD IN HEX FROM R3
DBUPST	HS	0		:UPDATE THE STATE MARKERS
	SIS	R10,1		:DECREMENT LINE COUNTER
	AIS	R11,2		:INCREMENT RING OUT POINTER
	CR	R11,R5		:CHECK FOR RING WRAP
	JLFS	DBNOWP		:NO,
	LIS	R11,0		:YES, WRAP, REINIT TO BEGINNING OF RING
DBNOWP	CR	R11,R12		:HAVE WE GOTTEN BACK TO THE START YET ?
	JE	RSTCIU		:YES, GO TO RESET THE COMMAND IN USE
				:INDICATOR, AND THEN EXIT
	LR	R10,R10		:CHECK FOR END OF LINE
	JE	DBINST		:YES, HAS REACHED THE END OF LINE
				:GO TO REINIT THE STATE MARKER, AND
				:KEEP ON READING FROM RING
	J	DBGTHW		:OTHERWISE, JUST KEEP ON READING FROM RING
DBFLSH	HS	0		:FLUSH LEADING ZEROS
	AIS	R11,2		:INCREMENT RING OUT POINTER
	CR	R11,R5		:CHECK FOR RING WRAP
	JLFS	DBNWP		:NO,
	LIS	R11,0		:YES, WRAP, REINIT TO BEGINNING OF RING
DBNWP	CR	R11,R12		:HAVE WE GOTTEN BACK TO THE START YET ?
	JE	RSTCIU		:YES, GO TO RESET THE COMMAND IN USE
				:INDICATOR, AND THEN EXIT
	J	DBGTHW		:KEEP ON READING FROM RING
DBFSDT	HS	0		:THE FIRST DATA IN A LINE
	LR	R6,R6		:NEW LINE OF DATA -- DO WE FOLLOW A
				:HEADER ?
	JN	DBTPHW		:YES, FOLLOW A HEADER, JUST TYPE DATA
	JAL	R7,TYPCRL,,	:OTHERWISE, START A NEW LINE
	LA	R2,ASC6SP,,	:AND SPACE IN 6 PLACES
	JAL	R7,TYPASC,,
	J	DBTPHW		:AND THEN TYPE DATA

DBRTNM	HS	0
	LR	R3,R3		:CHECK IF GOT RIGHT ROUTINE NUMBER
	JL	DBFLSH		:NO, GET THE NEXT HW (get a new HW ###sdw)
	CHI	R3,MXRTNM	:SEE IF IT IS TOO BIG
	JG	DBFLSH		:IT IS TOO BIG, (get a new HW ###sdw 3-3-87)
	LA	R7,,R3,R3	:FOR INDEXING
	LA	R2,INTERP,R7,R7	:GET 3-LETTER INTERPRETATION
	JAL	R7,TYPASC,,	:TYPE 3-LETTER INTERPRETATION
	LA	R2,ASC3SP,,
	JAL	R7,TYPASC,,	:TYPE 3 SPACES
	LIS	R6,1		:INDICATE HAVE GOTTEN ROUTINE NUMBER
	J	DBUPST		:GO TO UPDATE STATE MARKER
DBHEAD	HS	0
	JAL	R7,TYPCRL,,	:START A NEW LINE
	LCS	R6,1		:REINIT THE HEAD LINE INDICATOR
				: -1 INDICATES WE ARE EXPECTING A
				:ROUTINE NUMBER.
	LIS	R10,9		:REINIT THE HEAD LINE COUNTER
	J	DBFLSH		:FLUSH THE ROUTINE MARKER, AND THEN
				:GO TO GET THE ROUTNE NUMBER
	EI	:DBGON

::*********************************************************************
::
::	SUBROUTINE:	LGXRDB
::	FUNCTION:	XRAY COMMAND "LG" TO DISPLAY HISTORY RING  
::			LNFHST --- PORT LOGON/LOGOFF HISTORY RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	LNFDBG
LGXRDB	HS	0
	LHI	R5,LNFSIZ
	LHL	R11,LNFPTR,,
	TS	LGINUS,,	:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,LGINUS,,
	LA	R1,LNFHST+LNFSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+LNFSIZ-2,,	:LAST DESTINATION HW
	LHI	R3,10*(LNFSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING LNFHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:LNFDBG		:THE END OF LGXRDB
::*********************************************************************
::
::	SUBROUTINE:	CZXRDB
::	FUNCTION:	XRAY COMMAND "CZ" TO DISPLAY HISTORY RING  
::			CBZHST --- CIRCUIT BUILDING/ZAPPING HISTORY 
::					RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	CBZDBG
CZXRDB	HS	0
	LHI	R5,CBZSIZ
	LHL	R11,CBZPTR,,
	TS	CZINUS,,	:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,CZINUS,,
	LA	R1,CBZHST+CBZSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+CBZSIZ-2,,	:LAST DESTINATION HW
	LHI	R3,10*(CBZSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING CBZHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:CBZDBG		:THE END OF CZXRDB
::*********************************************************************
::
::	SUBROUTINE:	BFXRDB
::	FUNCTION:	XRAY COMMAND "BF" TO DISPLAY HISTORY RING  
::			BFSHST --- BUFFER STRUCTURE  HISTORY RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	BFSDBG
BFXRDB	HS	0
	LHI	R5,BFSSIZ
	LHL	R11,BFSPTR,,
	TS	BFINUS,,	:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,BFINUS,,
	LA	R1,BFSHST+BFSSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+BFSSIZ-2,,	:LAST DESTINATION HW
	LHI	R3,10*(BFSSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING BFSHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:BFSDBG		:THE END OF BFXRDB
::*********************************************************************
::
::	SUBROUTINE:	LLXRDB
::	FUNCTION:	XRAY COMMAND "LL" TO DISPLAY HISTORY RING  
::			LPGHST --- LEP/LOGGER HISTORY RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11- RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	LPGDBG
LLXRDB	HS	0
	LHI	R5,LPGSIZ
	LHL	R11,LPGPTR,,
	TS	LLINUS,,	:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,LLINUS,,
	LA	R1,LPGHST+LPGSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+LPGSIZ-2,,	:LAST DESTINATION HW
	LHI	R3,10*(LPGSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING LPGHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:LPGDBG		:THE END OF LLXRDB
::*********************************************************************
::
::	SUBROUTINE:	ADXRDB
::	FUNCTION:	XRAY COMMAND "AD" TO DISPLAY HISTORY RING  
::			AIOHST --- ASYNC I/O HISTORY RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	AIODBG
	IF	SOLOCS
ADXRDB	HS	0
	LHI	R5,AIOSIZ
	LHL	R11,AIOPTR,,
	TS	ADINUS,,	:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,ADINUS,,
	LA	R1,AIOHST+AIOSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+AIOSIZ-2,,	:LAST DESTINATION HW
	LHI	R3,10*(AIOSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING AIOHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:SOLOCS
	EI	:AIODBG		:THE END OF ADXRDB
::*********************************************************************
::
::	SUBROUTINE:	THXRDB
::	FUNCTION:	XRAY COMMAND "TH" TO TURN ON/OFF HISTORY TRACE
::	CALLING SEQ:	JUMP FROM XLOOP
::	INPUT:		R3=ARGUMENT
::
::*********************************************************************

	IF	DBGON
THXRDB	HS	0
	CLHI	R2,4		:MUST BE SINGLE ARG
	JN	COMERR,,
	L	R3,VALUE1,XD	:GET TRACING LEVEL
	CHI	R3,0
	JE	THXR00		:LEVEL = 0, GO TO TURN FLAGS OFF
	CHI	R3,1
	JL	COMERR,,	:EXIT, IF LEVEL < 1
	CHI	R3,4
	JG	COMERR,,	:EXIT, IF LEVEL > 4
	J	THXR01		:GO TO TURN FLAGS ON
THXR00	HS	0
	LIS	R1,0		:ARGUMENT  = 0
	LIS	R3,4		:TURN OFF ALL THE DEBUGGERS
	J	THXR
THXR01	HS	0		:ARGUMENT  >= 1  AND <= 4
	LIS	R1,1
THXR	HS	0
	IF	LNFDBG
	IF	SOLOCS
	STH	R1,LNFDIS,,
	EI	:SOLOCS
	EI	:LNFDBG
	IF	CBZDBG
	STH	R1,ZAPDIS,,
	EI	:CBZDBG
	IF	BFSDBG
	STH	R1,GRFDIS,,
	EI	:BFSDBG
	IF	LPGDBG
	STH	R1,LPGDIS,,
	EI	:LPGDBG
	CHI	R3,2		:IS ARGUMENT >= 2 ?
	JL	XRCRLF,,	:NO, EXIT
THXR02	HS	0		:YES, ARGUMENT >= 2 AND <= 4
	IF	LNFDBG
	IF	SOLOCS
	STH	R1,SNDDIS,,
	STH	R1,ASMDIS,,
	EI	:SOLOCS
	STH	R1,LINDIS,,
	EI	:LNFDBG
	IF	CBZDBG
	STH	R1,CRQDIS,,
	EI	:CBZDBG
	IF	BFSDBG
	IF	SOLOCS
	STH	R1,EMTDIS,,
	EI	:SOLOCS
	STH	R1,CBCDIS,,
	EI	:BFSDBG
	IF	LPGDBG
	STH	R1,LPDDIS,,
	EI	:LPGDBG
	CHI	R3,3		:IS ARGUMENT >= 3 ?
	JL	XRCRLF,,	:NO, EXIT
THXR03	HS	0		:YES, ARGUMENT >= 3 AND <= 4
	IF	BFSDBG
	STH	R1,WREDIS,,
	EI	:BFSDBG
	CHI	R3,4		:IS ARGUMENT = 4 ?
	JN	XRCRLF,,	:NO, EXIT
THXR04	HS	0		:YES, ARGUMENT = 4
	IF	AIODBG
	IF	SOLOCS
	STH	R1,GTCDIS,,
	STH	R1,PTCDIS,,
	STH	R1,PTSDIS,,
	EI	:SOLOCS
	EI	:AIODBG

	J	XRCRLF,,

	EI	;DBGON	




	ENDMO.(DEBUG)
	EI	:1-KILLIT
	KILMSG(DEBUG)

:	***NOTHING PAST THIS POINT***


	SUBTTL	FIN

:			***** ***** *   *
:			*       *   **  *
:			****    *   * * *
:			*       *   *  **
:			*     ***** *   *

::#####################################################################
::
::	MODULE:		F I N
::
::	FUNCTION:	SOME LAST MINUTE DEFINITIONS AND ERROR COMMENTS
::
::	SUBTTLS:
::		DMA region
::		Patch Areas, XRAY Symbol Table
::		Segment usuage
::		Physical addresses
::		BS - Bufferlet Statistics
::		Memory allocation symbol declaration
::
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE
	BEGMO.

:	SOME LAST MINUTE DEFINITIONS AND ERROR COMMENTS:

CRETIM	CURGMT
	SYAD(CRETIM)

	if	1-alhub		:move to data module for STRHUB ###al
        SEG.(0)
	RA	0

::*********************************************************************
::
::	TABLE:		LDTIME:
::	FUNCTION:	USED TO CONTROL THE FREQUENCY OF LINE
::		DIAGNOSTIC REPORTING TO THE SUPERVISOR.  EACH ARRAY LDTIMx
::		RECORDS THE TIME (IN TIK4MN UNITS) THAT THE LAST REPORT WAS
::		MADE.  IF 2 CONSECUTIVE REPORTS ARE MADE, THEN SKIP 3
::		OCCURRENCES OF LDRPRT BEFORE REPORTING AGAIN.  WHEN A EVENT
::		THRESHOLD HAS BEEN EXCEEDED, TEST THE LDTIMx FIELD:
::
::	1. IF TIME OF LAST REPORT = CURRENT TIME MINUS 1, SET LDTIMx TO
::	    CURRENT TIME + 3.
::	2. IF LDTIMx IS LESS THAN CURRENT TIME MINUS 1, SET LDTIMx TO CURRENT
::	    TIME.
::	3. IF LDTIMx IS GREATER THAN OR EQUAL TO CURRENT TIME, MAKE NO REPORT.
::
::*********************************************************************

LDTIME	WS	0
Q	EQ	0
	RE	LDNEVT
LDTIM|Q| WS	NLINES		:ONE LDTIMx ARRAY PER EVENT
Q	EQ	Q+1
	ER
	ei	:1-alhub

::*********************************************************************
::
::	CPU Utilization tables, counts, times
::
::*********************************************************************

	IF	DB.CPU

	IF	DSPTRC
EXADR0	WS	$A40		:DISPATCH TRACE TABLE		###OAS
EXTBLE	EQ	.-EXADR0	:DISPATCH TRACE TABLE LENGTH	###OAS
EXCNT0	WS	$A40		:DISPATCH TRACE COUNT TABLE	###OAS
	EI	:DSPTRC

EXC1CT	WS	1		:DISPATCH COUNT			###OAS
EXC2CT	WS	1		:TOP OF EXEC LOOP COUNT		###OAS
	IF	DB.CLK
EXCTIM	HS	1		:TIME IN EXEC PROCESSING	###OAS
EXCTM1	WS	1		:TIME OF LAST YIELD OR DISMISS	###OAS
	EI	:DB.CLK
	IF	ISIS
CSYTCT	HS	1		:SYLVER DISMISS COUNT
	IF	DB.CLK
CPUTII	HS	1		:SLOT0 INTERVAL TIME
CSYTTM	HS	1		:SYLVER TIME 
CSYTFC	WS	1		:SYLVER DISPATCH TIME IN FASTC
CSYTSC	HS	1		:SYLVER DISPATCH TIME IN SLOT0 FASTC
CSYFRC	HS	1		:SYLVER FORCED DISMISS COUNT
	EI	:DB.CLK
	EI	:ISIS
CPUTFL	HS	1		:<0 IF CPUTIL ACTIVE
CPUTTO	HS	2		:FASTC AT WHICH CPUTIL TIMES OUT IF >0
CPUTIN	HS	2		:CPUTIL MEASUREMENT INTERVAL
CPUTRQ	HS	1		:INIT TO -1 - SET TO LOG2 NO. SEC'S 
				:REQUESTED FOR CPUTIL.
CPUNRQ	HS	1		:SAVED VALUE OF CPUTRQ
CPUTFC	HS	2		:CPUTIL START FASTC
CPUTCD	HS	1		:CODE FOR ROUTINE CURRENTLY UNDER CPUTIL
CPUTTT	HS	1		:TOTAL TIME OF CPUTIL
CPUTTC	HS	1		:TOTAL DISMISS COUNT FOR CPUTIL
	IF	DSPTRC
CPUTND	HS	1		:TOTAL 'FAKE' DISMISS COUNT FOR CPUTIL	###OAS
	EI	:DSPTRC
CPUTTB	HS	(CPUTNE-1)*3	:CPUTIL STAT TABLE, 3 HW'S FOR EACH ROUTINE
	EI	:DB.CPU

	SUBTTL	FIN (DMA region)

::*********************************************************************
::
::	Define the DMA region for SIO mother board interface.
::	Define the DMA region in seg 0 here if switch SIBFRL is not
::	turned on. Otherwise, relocate DMA region to seg 2 (DATA module).
::	
::	************	NOTE	*************
::	Both of SIO DMA regions defined here and defined in DATA must
::	be the same.  Any change to them must be the same.	###LSH
::
::*********************************************************************

        IF      SILINS
	IF	1-SIBFRL	:DEFINE DMA REGION IN SEG 0 HERE IF
				:SWITCH SIBFRL IS NOT TURNED ON ###LSH

        BND     20              :QUAD WORD BOUNDARY
:	>>NOTE--FOLLOWING MUST NOT CROSS 100 BOUNDARY<<
SIOIPG  WS      8               :7 CCWS FOR HDLC INITIALIZATION
SIODUM  WS      4               :WILL CONTAIN DUMMY RECORD
	IF	STRHUB
STRDUM  WS      4               :WILL CONTAIN DUMMY RECORD FOR STARLINE
	EI	:STRHUB
	IF	NAKCOD		:STRHUB!STRRMT
SIONAK	WS	4		:PUT IN QUAD STORAGE ANYWAY ##AL
	EI	:NAK 
SIOBLK  WS      8*SILINS        :CCW PAIR FOR OUTPUT
SIOBLI  WS      4*SILINS        :CCW FOR INPUT
	IF	XRESET		:###wjl
SIOBLR	WS	0C*SILINS	:for Expanded Reset
	ELSE
SIOBLR  WS      4*SILINS        :CCW FOR RESET
	EI	:XRESET
SIOSTT  WS      4*SILINS	:STATUS BLOCKS
SIDWCM	BS	10*SILINS	:SIO DWL CCW AREA
SIDWBF	BS	80*SILINS	:SIO DWL OUTPUT BUFFERS
SIOBLO  BS      90*2*SILINS  	:OUTPUT BUFFERS
	IF	STRHUB
SIBUF	BS	(SIBFSZ+20)*SILINS	:INPUT BUFFERS
	ELSE
SIBUF	BS	SIBFSZ*SILINS	:INPUT BUFFERS
	EI
:	SYAD(SIBUF)
	IF	DB56KB		:###LSH###wjl
	BND	20
SSTSAV	WS	4*SILINS	:ANOTHER SIO STATUS QUERY SAVE AREA
	EI	:DB56KB
SIOXQW	WS	4		:SIO MOTHER BOARD NEEDS EXTRA QUAD WORD###LSH
SIOEND	EQ	.		:END OF SIO DMA AREA
SIOKLG  EQ      SIOBLO^10+SIOBLO/10     :KLUDGE TO HELP DUMB ASSEMBLER
	EI	:1-SIBFRL	:NOT SIBFRL			###LSH

::*********************************************************************
::
::	56 KB DEBUG Option
::
::*********************************************************************

	IF	DB56KB		:56 KB DEBUG OPTION
SKBSIZ	EQ	$A255
Q	EQ	.		:SAVE CURRENT PC
	ORG	0
SIONDX	HS	1
CKLAST	HS	1
ABLAST	HS	1
CKACC	HS	1
ABACC	HS	1
CKSAVE	HS	1
ABSAVE	HS	1
CKSUMS	BS	SKBSIZ+1
ABORTS	BS	SKBSIZ+1
SSTATS	BS	SKBSIZ+1
DEBSIZ	EQ	.		:SIZE OF SIO DEBUG AREA
	ORG	Q
DEBSAV	RE	SILINS
	BS	DEBSIZ
	ER

	SEG.(1)
Q	EQ	DEBSAV
DEBPTR	RE	SILINS
	HC	Q
Q	EQ	Q+DEBSIZ
	ER

	EI	:DB56KB
	EI	:SILINS

	SUBTTL	FIN (Patch Areas, XRAY Symbol Table)

::*********************************************************************
::
::	PATCH AREAS
::
::	PATHIS:	defines the start of the patch history area,
::		each entry will be 16 bytes as follows,
::		19yy/mmdd/hhmm/uname(10 chars 0 filled)
::		where 19yy, mmdd and hhmm are in bcd (4 bits per decimal
::		digit) and uname is in ASCII.
::	PATCH0:	defines the start of the Segment 0 patch area.
::	PATCH1:	defines the start of the Segment 1 patch area.
::
::*********************************************************************

	SEG.(0)

PATCH0	HS	P0SIZE/2	:PATCH READ WRITE AREA
	SYAD(PATCH0)

	SEG.(1)
CRCDTB	HC	0FE63		:Debug crash code
	IF	CRHRMK
	REMARK	%Crash codes defined in this version:%
	EI
.QC.	EQ	1
	RE	.NCCD
	DFC.|.QC.|((CT.|.QC.|),(CST.|.QC.|))
.QC.	EQ	.QC.+1
	ER

PATHIS	WS	PHSIZE/4	:PATCH HISTORY TABLE
PATCH1	HS	P1SIZE/2	:FOR READ ONLY PATCH CODE
	SYAD(PATCH1)

:	PAHPTR:	pointer to the next available entry in PATHIS
:	PA0PTR:	This symbol may be used to place a patch at the next
:		available address in the PATCH0 area.  It starts out
:		equal to PATCH0 and is moved up after each patch in
:		the PATCH0 area.  Use of the symbol assumes that all
:		patches from PATCH0 to PATCH0+P0SIZE will be done in order.
:	PA1PTR:	This symbol may be used to place a patch at the next
:		available address in the PATCH1 area.  It starts out
:		equal to PATCH1 and is moved up after each patch in
:		the PATCH1 area.  Use of the symbol assumes that all
:		patches from PATCH1 to PATCH1+P1SIZE will be done in order.

PAHPTR	EQ	PATHIS	:INIT HISTORY POINTER TO START OF AREA
PA0PTR	EQ	PATCH0	:INIT PTR TO START OF AREA
PA1PTR	EQ	PATCH1	:INIT PTR TO START OF AREA

::*********************************************************************
::
::	TABLE:		SYMTBL:
::	FUNCTION:	Create the XRAY Symbol Table, at the end of seg D
::
::*********************************************************************

	SEG.(0D)
SYMTBL	WS	0
Q	EQ	0
	RE	NSYMBL
	SYAD|Q|
Q	EQ	Q+1
	ER
SRESER	HS	0			:SYMBOL RESERVE AREA
	ORG	.+(3*ADRESZ)		:room for HIADDR, ENDNOD, OPTMEM
SYMTSZ	EQ	.-SYMTBL		:SYMBOL TABLE ENDS HERE

	SUBTTL	FIN (Segment usuage)

::*********************************************************************
::
::	OLD SEGMENT USAGE:
::
::	1.	SEG 0 :	NODE CODE DATA AREA
::	2.	SEG 1 :	NODE CODE EXECUTE-ONLY AREA
::	3.	SEG 2 :	DATA AREA
::	4.	SEG 3 :	DATA AREA
::	5.	SEG 4 :	KERNEL COMMUNICATION AREA IF ISIS OR SUP, ELSE UNUSED
::	6.	SEG 5 :	ASYNC RING IF TYMSAT, SUP RING IF SUP, ELSE UNUSED
::	7.	SEG 6 :	BUFFERLETS
::	8.	SEG 7 :	BUFFERLETS
::	9.	SEG 8 :	BUFFERLETS
::	10.	SEG 9 :	BUFFERLETS
::	11.	SEG A :	DUMMY SEGMENT MAPS ONTO ABSOLUTE 0 - FFFF FOR SOLO
::	12.	SEG B :	SYNC INPUT RINGS
::	13.	SEG C :	DATA, PRESERVED THROUGH CRASHES
::	14.	SEG D :	XRAY
::	15.	SEG E :	ISIS CTA TABLE IF ISIS, DUMMY MAPPING ONTO ABSOLUTE
::			600 IF SOLO (FOR FASTC AND SLOWC)
::
::	NEW SEGMENT USUAGE:
::
::	1.	SEG 0 : NODE CODE DATA AREA
::	2.	SEG 1 : NODE CODE EXECUTE-ONLY AREA
::	3.	SEG 2 - SEG C : NEW DATA STRUCTURE:START FROM SEG 2 WILL BE IN
::		ONE MEMORY AREA, DATA THEN BUFFERLETS, NO SEG RESTRICTN##AL
::	4.	SEG D : XRAY
::	5.	SEG E : CTA TABLE IF ISIS, DUMMY MAPPING ONTO ABSOLUTE 600
::			IF SOLO (FOR FASTC AND SLOWC)
::
::	THE SEGMENTS DO NOT PHYSICALLY FALL INTO ORDER, NOR IS THE PHYSICAL
::	LAYOUT THE SAME BETWEEN SOLO AND ISIS CONFIGURATIONS
::
::*********************************************************************

:	DETERMINE SQSIZE FOR SEGS 0, 1, 0D, AND 0E
        SEG.(0)
S0SIZE  EQ      .-SEG0
	IF	(S0SIZE-10000)	:WARNS ASSEMPLER IF SEG0 OVERFLOW	###AL
	REMARK	%*** SEG0 SPACE NOT ENOUGH, S0SIZE =
	NUMBER $0 S0SIZE
	REMARK	%********** CONFIGURATION ERROR **********
	KILLER(1)
	EI
        SEG.(1)
S1SIZE  EQ      .-SEG1

PAGESZ  EQ      100
        IF      MACHIN-2
PAGESZ  EQ      400
        EI
        IF      MACHIN-3
PAGESZ  EQ      100
        EI

	IF	1-NOSEG
	IF	SOLOCS
	SEG.(4)
S4SIZE	EQ	.-SEG4
	EI	:SOLOCS
	EI	:1-NOSEG##AL

	SEG.(0D)
SDSIZE	EQ	.-SEGD			:XRAY CODE
	IF	1-\HELLISH
SESIZE	EQ	1000
	EI

:	ROUND UP SEGMENT SIZES TO MAC PAGE BOUNDARY
	IF	NOSEG
Q	EQ	0
	RE	$A 15
	IF	\S|Q|SIZE
S|Q|SZ	EQ	(S|Q|SIZE+PAGESZ-1)&1FF00&(-PAGESZ)
	EI	:S|Q|SIZE
Q	EQ	Q+1
	ER
	ELSE	:NOT NOSEG##AL

:	DEFAULT TO 0 SIZE FOR ALL SEGMENTS THAT HAVE NAT BEEN ASSIGNED
:	SIZES YET, WITH THE EXCEPTION OF SEGMENTS 6-9
Q	EQ	0
	RE	6
	IF	\S|Q|SIZE
S|Q|SZ	EQ	(S|Q|SIZE+PAGESZ-1)&1FF00&(-PAGESZ)
	ELSE	:NOT \S|Q|SIZE
S|Q|SZ	EQ	0
	EI	:S|Q|SIZE
Q	EQ	Q+1
	ER

:	MUST SKIP SEGS 6 - 9 SINCE SIZE NOT COMPUTED YET...
Q	EQ	0A
	RE	5
	IF	\S|Q|SIZE
S|Q|SZ	EQ	(S|Q|SIZE+PAGESZ-1)&1FF00&(-PAGESZ)
	ELSE	:NOT \S|Q|SIZE
S|Q|SZ	EQ	0
	EI	:\S|Q|SIZE
Q	EQ	Q+1
	ER
	EI	:NOSEG


:	ASSIGN ISIS PHYSICAL ADDRESSES
	IF	ISIS
	IF	1-\NCTA
NCTA	EQ	10000		:DEFINE NCTA IF NOT THERE
	EI	:1-\NCTA
SESZ	EQ	(SESIZE+PAGESZ-1)&1FF00&(-PAGESZ)
SEPH	EQ	NCTA
S0PH	EQ	SEPH+SESZ	
S1PH	EQ	S0PH+S0SZ
KERNSZ	EQ	0		:SIZE OF SOLO KERNEL (NOT PRESENT FOR ISIS)
CTASIZE	EQ	SESZ		:CTA TABLE IS ALL OF SEG E
	EI	:ISIS

	IF	1-NOSEG
	IF	SOLOCS
HIADDR	EQ	SESZ+S0SZ+S1SZ+S2SZ+S3SZ+S4SZ+SBSZ+SCSZ+SDSZ+(CHRBUF-SEG6)
	ELSE	:NOT SOLOCS
HIADDR	EQ	SESZ+S0SZ+S1SZ+S2SZ+S3SZ+SBSZ+SCSZ+SDSZ+(CHRBUF-SEG6)
	EI	:SOLOCS
	IF	IKNRNG	:SEG 4 NOT SHARED
HIADDR	EQ	HIADDR+S4SZ
	EI	:IKNRNG
	EI	:1-NOSEG##AL

:	ASSIGN SOLO CODE PHYSICAL ADDRESSES
	IF	1-ISIS
VPHSZ   EQ      (VPHSIZ+0FF)&1FF00      :ROUND UP PRIVILEGED CODE SIZE
	IF	NOSEG
S0PH	EQ	VPHYS+VPHSZ		:SEG 0 FOLLOWS PRIVILEGED CODE
S1PH	EQ	S0PH+S0SZ		:NODE CODE FOLLOWS THE DATA AREAS
SDPH	EQ	S1PH+S1SZ		:XRAY FOLLOWS THE NODE CODE
	IF	SOLOCS
CONTRL	EQ	SDPH+SDSZ
CTLSZ   EQ      400             	:CONTROL STORAGE SIZE
LCTIME  EQ      CONTRL+CTLSZ   		:START OF TIMEOUT STORAGE##AL
LCTSZ   EQ      200             	:SIZE OF TIMEOUT STORAGE
RING    EQ      LCTIME+LCTSZ    	:START OF RING STORAGE
RINGE   EQ      RING+RINGS	      	:END OF RING STORAGE##al
SRSIZE	EQ	RINGE-CONTRL		:size of async ring area	###wjl
SRSZ	EQ	(SRSIZE+0FF)&0FFF00	:round up boundary		###wjl
BADNAD	EQ	RING-CONTRL		:##AL
S2PH	EQ	(RINGE+0FF)&0FFF00	:ROUND UP BOUNDARY
	ELSE	:NOT SOLOCS
S2PH	EQ	SDPH+SDSZ
	EI	:SOLOCS
	ELSE	:NOT NOSEG
SBPH	EQ	VPHYS+VPHSZ      	:INPUT RINGS FOLLOW PRIVILEGED CODE
S0PH	EQ	SBPH+SBSZ		:SEGS 0, 1, 2 AND 3 ARE NEXT
S1PH	EQ	S0PH+S0SZ
S2PH    EQ      S1PH+S1SZ
S3PH    EQ      S2PH+S2SZ
	IF	SOLOCS
S4PH	EQ	S3PH+S3SZ
SCPH	EQ	S4PH+S4SZ		:SEGC IS NEXT
	ELSE	:SOLOCS
SCPH	EQ	S3PH+S3SZ
	EI	:SOLOCS
SDPH	EQ	SCPH+SCSZ		:THEN XRAY
QQQQ	EQ	SDPH+SDSZ		:INTERMEDIATE VALUE
	EI	:NOSEG##AL
SEPH	EQ	600			:SEG E IS HARDWIRED TO ABSOLUTE 600


:	KLUDGE TO ACCOMMODATE ASSEMBLER'S INABILITY TO FORWARD 
:	REFERENCE EQUATES....

	IF	SOLOCS			:ASYNC RING IS IN SEG5
	IF	1-NOSEG
S5PH	EQ      SDPH+SDSZ		:SEG 5 STARTS AFTER SEG D
CONTRL	EQ	S5PH
CTLSZ   EQ      400             	:CONTROL STORAGE SIZE
LCTIME  EQ      CONTRL+CTLSZ   		:START OF TIMEOUT STORAGE##AL
LCTSZ   EQ      200             	:SIZE OF TIMEOUT STORAGE
RING    EQ      LCTIME+LCTSZ    	:START OF RING STORAGE
RINGE   EQ      RING+RINGS      	:END OF RING STORAGE
S5SIZE  EQ      RINGE-S5PH      	:SIZE OF SEG 5 STORAGE
S5SZ	EQ	(S5SIZE+0FF)&1FF00	:ROUND UP
QQQQ	EQ	QQQQ+S5SZ		:UPDATE INTERMEDIATE VALUE
BADNAD	EQ	RING-CONTRL		:##AL
	EI	:1-NOSEG
	EI	:SOLOCS

	IF	1-NOSEG
HIADDR	EQ	QQQQ+(CHRBUF-SEG6)	:TOTAL NODE MEMORY EXCLUDING BUFFERLETS
	EI	:1-NOSEG##AL

	EI	:1-ISIS

:	HIADDR IS THE TOTAL STORAGE REQUIREMENT FOR CODE AND DATA AREAS,
:	EXCLUDING THE BUFFERLETS.
:	CHRBUF MARKS THE BEGINNING OF BUFFERLET STORAGE.
	IF	NOSEG			:				###wjl
	IF	ISIS			:				###wjl
VPHSZ	EQ	0			:not needed for ISIS		###wjl
	EI	:ISIS							###wjl
	IF	1-SOLOCS		:				###wjl
SRSZ	EQ	0			:only needed for SOLOCS		###wjl
	EI	:1-SOLOCS						###wjl
HIADDR	EQ	VPHSZ+SESZ+S0SZ+S1SZ+SDSZ+SRSZ+(CHRBUF-SEG2)	:	###wjl
	EI	:NOSEG							###wjl

	ORG	SRESER
	SC	/HIADDR:/
	WC	HIADDR

:	COMPUTE THE SIZE OF THE EXCESS MEMORY TO BE ALLOCATED TO BUFFERLETS
	IF	MEMAVL-HIADDR
CHBFSZ	EQ	MEMAVL-HIADDR		:BUFFERLET AREA SIZE
MEMORE	EQ	0			:we have enough for code, etc,	###wjl
	ELSE	:NOT NEARLY ENOUGH MEMORY...
CHBFSZ	EQ	0
MEMORE	EQ	HIADDR-MEMAVL		:we need this much more for code, etc.
	EI	:MEMAVL-HIADDR

:	IF THERE ISN'T AT LEAST ONE BUFLET/CKT or if THERE IS LESS THAN 4K
:	BUFLET SPACE...make an error remark
	IF	(NCIRCS*10)-CHBFSZ
CHBCIR	EQ	(NCIRCS*10)-CHBFSZ	:we need at least one buflet/ckt###wjl
	ELSE
CHBCIR	EQ	0			:we have at least one buflet/ckt###wjl
	EI
	IF	1000-CHBFSZ
CHB4K	EQ	1000-CHBFSZ		:we need at least 4k buflet space##wjl
	ELSE
CHB4K	EQ	0			:we have at least 4k buflet space##wjl
	EI

	IF	CHBCIR!CHB4K
MEMORE	EQ	MEMORE+CHBCIR+CHB4K		:a little extra won't hurt#wjl
	REMARK	%%Fatal error - configuration too large!%
	NUMBER	$A (MEMAVL+1023)/1024
	REMARK	d KB specified as available,%
	REMARK	MUST be increased by AT LEAST 
	NUMBER	$A (MEMORE+1023)/1024		:###wjl
	REMARK	d KB!%
	KILLER(1)
	EI	:CHBCIR!CHB4K

	IF	NOSEG
        
        IF      1-SIORNG
         IF     CHRBUF+CHBFSZ-0D0000    :stop before XRAY
CHBFSZ  EQ      0D0000-CHRBUF-10
         EI
        ELSE            :supe ring is in seg C
         IF     CHRBUF+CHBFSZ-0C0000
CHBFSZ  EQ      0C0000-CHRBUF-10
         EI
        EI
:	COMPUTE SIZES OF SEGMENTS 2-C
Q	EQ	(CHRBUF-SEG2)+CHBFSZ	:NOW COMPUTE SIZES OF SEGS 2-0C	###wjl
Q1	EQ	2
	RE	$A 11
	IF	Q-10000
S|Q1|SIZE EQ	10000
	ELSE	:NOT Q-10000
	IF	Q
S|Q1|SIZE EQ	Q
	ELSE	:NOT Q
S|Q1|SIZE EQ	0
	EI	:Q
	EI	:Q-10000
Q	EQ	Q-10000
Q1	EQ	Q1+1
	ER

:	ROUND SEGMENT SIZES UP TO MAC PAGE BOUNDARY
Q	EQ	2
	RE	$A 11			:SEG2-SEGC
S|Q|SZ	EQ	(S|Q|SIZE+PAGESZ-1)&1FF00&(-PAGESZ)
Q	EQ	Q+1
	ER
	ELSE	:NOT NOSEG
Q	EQ	CHBFSZ		:NOW COMPUTE SIZES OF SEGS 6 - 9
				:SIZE OF LOGICAL SEGS 4 - C##AL
:	SEG 6 ALREADY PARTIALLY ALLOCATED, UP TO 'CHRBUF' WHICH IS
:	THE BEGINNING OF THE BUFFERLET STORAGE AREA

	IF	Q-(10000-(CHRBUF-SEG6))
S6SIZE	EQ	10000
Q	EQ	Q-(10000-(CHRBUF-SEG6))
	ELSE	:NOT EVEN FULL SEGMENT 6 USED
S6SIZE	EQ	Q+(CHRBUF-SEG6)
Q	EQ	0
	EI	:Q-(10000-(CHRBUF-SEG6))
Q1	EQ	7
:	COMPUTE SIZES OF SEGMENTS 7 - 9
	RE	3
	IF	Q-10000
S|Q1|SIZE EQ	10000
	ELSE	:NOT Q-10000
	IF	Q
S|Q1|SIZE EQ	Q
	ELSE	:NOT Q
S|Q1|SIZE EQ	0
	EI	:Q
	EI	:Q-10000
Q	EQ	Q-10000
Q1	EQ	Q1+1
	ER
:	ROUND SEGMENT SIZES UP TO MAC PAGE BOUNDARY
Q	EQ	6
	RE	4
S|Q|SZ	EQ	(S|Q|SIZE+PAGESZ-1)&1FF00&(-PAGESZ)
Q	EQ	Q+1
	ER
	EI	:NOSEG

:	COMPUTE ENDNOD, THE TOTAL AMOUNT OF MEMORY USED. THIS CAN NEVER BE 
:	LARGER THAN MEMAVL, THE AVAILABLE MEMORY.
	IF	NOSEG
	IF	ISIS
ENDNOD	EQ	HIADDR+S2SZ+S3SZ+S4SZ+S5SZ+S6SZ+S7SZ+S8SZ+S9SZ+SASZ+SBSZ+SCSZ-(CHRBUF-SEG2)
	ELSE	:SOLO
S3PH	EQ	S2PH+S2SZ
S6PH	EQ	S3PH+S5SZ+S4SZ+S3SZ
S7PH	EQ	S6PH+S6SZ
S8PH	EQ	S7PH+S7SZ
S9PH	EQ	S8PH+S8SZ
SAPH	EQ	S9PH+S9SZ
SBPH	EQ	SAPH+SASZ
       IF       SIORNG
ENDNOD  EQ      SBPH+SBSZ
       ELSE
SCPH	EQ	SBPH+SBSZ
ENDNOD	EQ	SCPH+SCSZ
       EI       :SIORNG
	EI	:ISIS
	ELSE	:NOT NOSEG
	IF	ISIS
ENDNOD	EQ	HIADDR+S6SZ+S7SZ+S8SZ+S9SZ-(CHRBUF-SEG6)
	ELSE	:NOT ISIS
S6PH	EQ	HIADDR-(CHRBUF-SEG6)
S7PH	EQ	S6PH+S6SZ
S8PH	EQ	S7PH+S7SZ
S9PH	EQ	S8PH+S8SZ
ENDNOD	EQ	S9PH+S9SZ
	EI	:ISIS
	EI	:NOSEG

	SC	/ENDNOD:/
	WC	ENDNOD

	IF	MEMAVL-ENDNOD+10	:DON'T RUN OFF THE END OF LAST SEG
CHBFSZ	EQ	ENDNOD-HIADDR-10	:MORE MEMORY AVAILABLE THAN MAC
	EI	:MEMVAL-ENDNOD

      IF        NOSEG
       IF       1-SIORNG
        IF      CHRBUF+CHBFSZ-0D0000+10
CHBFSZ  EQ      0D0000-CHRBUF-10        :don't let it overflow to xray
        EI
       ELSE    :SIORNG
        IF      CHRBUF+CHBFSZ-0C0000+10 :don't let if overflow in supe ring
CHBFSZ  EQ      0C0000-CHRBUF-10        :logical adress overflow
        EI
        IF      CHRBUF+CHBFSZ-KIOAR+S2PH-SEG2+10 :physical address overflow
CHBFSZ  EQ      KIOAR-S2PH+SEG2-CHRBUF-10
        EI
       EI       :SIORING
      EI        :NOSEG

RCBFSZ	EQ	CHBFSZ			:REAL CHAR. BUFFERLET SIZE ###LSH

	IF	1-ISIS
:	SET UP FOR KERNEL
	IF	KERNEL
	GL TI,SUPCOD,MICRO,KIOAR
	IF	1-SUPER
KERNSZ	EQ	4000		:SOLO KERNEL SIZE
SUPCOD	EQ	0		:INDICATE NOT SUPERVISOR NODE TO KERNEL
KIOAR	EQ	ENDNOD		:ORG KERNEL FOLLOWING NODE CODE
TI	EQ	1		:SYMBOL REQUIRED BY KERNEL
	ELSE	:SUPER
KERNSZ	EQ	0		:KERNEL SIZE NOT NECESSARILY ZERO, BUT
:				NOT COUNTED  IN NODE CODE MEMORY REQUIREMENTS
TI	EQ	1
SUPCOD	EQ	1		:SYMBOLS NOT PASSED TO KERNEL, BUT
				:PREVENTS  ASSEMBLY ERRORS FROM 'GL' STATEMENT
	EI	:1-SUPER
	ELSE	:NOT KERNEL
:	MUST DEFINE SOME START ADDRESS FOR KERNEL SO CONTEXT SWITCHER
:	CAN DETERMINE KERNEL'S ABSENCE.
KIOAR	EQ	ENDNOD
KERNSZ	EQ	0		:KERNEL SIZE ZERO
	EI	:KERNEL

:	KERNEL ENTRY POINTS

KIZ	EQ	KIOAR+1800	:INITIALIZE KERNEL
KGO	EQ	KIOAR+1804	:RUN NEXT USER
KND	EQ	KIOAR+1808	:TIME SLICE IS UP, YIELD TO NODE
KILL	EQ	KIOAR+1818	:ILLEGAL INSTRUCTION BY KERNEL USER
KMAC	EQ	KIOAR+1820	:MAC INTERRUPT BY KERNEL USER
KRET	EQ	KIOAR+1828	:FOR RETURN ADDRESS TO NODE
STIMP	EQ	KIOAR+182C	:POINTER TO STIME

:	NOTE SYMBOL DEFINITIONS CAREFULLY SEQUENCED TO AVOID NAD
:	FORWARD REFERENCE LIMITATIONS.

        IF      1-ISIS
	IF	SUPER
        IF      NOSEG
SCPH    EQ      KIOAR
S4PH    EQ      KIOAR           :define symbol so SIO ring tables can be
S5PH    EQ      (S4PH+SS4SIZ+1F)&(-20)   :starts on a BND 20
SIOAR   EQ      S5PH
        ELSE    :1-NOSEG        :defined (forward reference to S4PH)
S4PH    EQ      KIOAR		:KERNEL PHYSICAL ADDRESS ORG
        EI      :1-NOSEG
	EI	:SUPER
        EI      :1-ISIS

	IF	1-\SIOAR
SIOAR	EQ	KIOAR+0A200	:SUP SEGMENT FOLLOWS KERNEL I/O AREA
	EI	:1-\SIOAR

	IF	1-ISIS
	IF	SUPER
       IF       1-NOSEG
S5PH	EQ	SIOAR		:SEG 5 FOR SUP INTERFACE AREA
       EI       :1-NOSEG
	EI	:SUPER
	EI	:1-ISIS

	IF	1-NOSEG
	IF	KERNEL
        IF      ENDNOD-KIOAR
        REMARK  %%******  NODE CONFIGURATION TOO LARGE FOR KERNEL NODE ****%%
	KILLER(1)		:kill assembly
        EI
        EI      :KERNEL
	EI	:1-ISIS
	EI	:1-NOSEG##AL

	IF	1-ISIS

       IF       NOSEG           :note these were defined above  ###sdw
S4PH    EQ      S3PH+S3SZ
S5PH    EQ      S4PH+S4SZ
SCSZ    EQ      (((SS4SIZ+1F)&-20)+SS5SIZ+PAGESZ-1)&1FF00&(-PAGESZ)
SCSIZE  EQ      SCSZ
ENDNOD  EQ      ENDNOD+SCSZ
       EI       :NOSEG          now define S4PH and S5PH to be correct

:	XRAY MAC REGISTERS:
	SETMAC(0,90)
	SETMAC(1,10)
	SETMAC(2,90)
	SETMAC(3,90)
	SETMAC(4,90)
	SETMAC(5,90)
	SETMAC(6,90)
	SETMAC(7,90)
	SETMAC(8,90)
	SETMAC(9,90)
	IF	NOSEG
	SETMAC(0A,90)
	EI	:NOSEG##AL
	SETMAC(0B,90)
	SETMAC(0C,90)
	SETMAC(0D,10)			:XRAY RUNS IN SEG D
	SETMAC(0E,10)

	IF	1-NOSEG
AXMACA  EQ      0FF00090                :USED BY XRAY FOR 00000-0FFFF
	EI	:1-NOSEG##AL

:	NODE MAC REGISTERS:

ANMAC0	EQ	AXMAC0
ANMAC1	EQ	AXMAC1!20		:SEG1 IS WRITE-PROTECTED
ANMAC2	EQ	AXMAC2
ANMAC3	EQ	AXMAC3
ANMAC4	EQ	AXMAC4
ANMAC5	EQ	AXMAC5
ANMAC6	EQ	AXMAC6
ANMAC7  EQ      AXMAC7
ANMAC8  EQ      AXMAC8
ANMAC9  EQ      AXMAC9
	IF	NOSEG
ANMACA	EQ	AXMACA
	ELSE	:NOT NOSEG
ANMACA  EQ      0
	EI	:NOSEG##AL
ANMACB  EQ      AXMACB
ANMACC  EQ      AXMACC
ANMACD  EQ      AXMACD!20		:SEGD IS WRITE-PROTECTED
ANMACE  EQ      AXMACE

	SUBTTL	FIN (Physical addresses)

::*********************************************************************
::
::	DEFINITION OF PHYSICAL ADDRESSES
::
::*********************************************************************

PHSQUE	EQ	SQUEUE+S0PH	:DEFINITION OF PHYSICAL ADDRESSES
PGMTCA	EQ	GMTCAL+SDPH-SEGD
PGMTNO	EQ	GMTNOW+S0PH
PCRHTM	EQ	CRSHTM+S0PH
	IF	SILINS
PHSINS	EQ	SINTPC-SEG1+S1PH
PHSION	EQ	SIONEW+S0PH
	EI	:SILINS
PHXQUM	EQ	XQUEM+S0PH
PHSCTB	EQ	SCHTAB+S0PH
PHCNSL	EQ	CONSOL+S0PH
	IF	NOSEG
PHSVBF	EQ	SVNTBF-SEG2+S2PH
PHSVTP	EQ	SVNTIP-SEG2+S2PH
	ELSE	:NOT NOSEG##AL
PHSVBF	EQ	SVNTBF-SEGB+SBPH
PHSVTP	EQ	SVNTIP-SEGB+SBPH
	EI	:NOT NOSEG##AL
	IF	SOLOCS
PHFFLS	EQ	S0PH+F.FLSH
PHFLSH	EQ	S0PH+P.FLSH
	EI	:SOLOCS
PHRECN	EQ	RECN+S0PH
PHRLNK	EQ	RLNK+S0PH
PHBREC	EQ	BREC+S0PH
PHEREC  EQ      EREC+S0PH
PHLLXM	EQ	LLXM+S0PH
PHRSHF	EQ	RSHF+S0PH
PHRXTR	EQ	TRRXMT+S0PH
PHRCTR	EQ	RCTRNS+S0PH
PHRCBF	EQ	RECBUF-SEG2+S2PH	:###wjl
PHLXMS	EQ	LXMSET+S0PH		:###jhl
PHCRST  EQ      CRACTN+S1PH-SEG1
PHCRID	EQ	CRSHID+S0PH
PHCRTY	EQ	CRTYPE+S0PH
PHMCSR	EQ	MACISR+S0PH
PHWDOG  EQ      WATCHDOG+S0PH
PHCRYI	EQ	CRYPRI+S0PH
PHCRYU	EQ	CRYPTU+S0PH
PHCRAD	EQ	CRSHAD+S0PH
PHILIP	EQ	ILIPSW+S0PH
PHMALP	EQ	MALPSW+S0PH
PHMACP	EQ	MACPSW+S0PH
PHSMAC	EQ	SMACSV+S0PH
PHILDC	EQ	ILDVCT+S0PH
PHILDA	EQ	ILDVAD+S0PH
PHERRG	EQ	ERRREG+S0PH
PHERG0	EQ	ERREG0+S0PH
PHCRPS	EQ	CRSHPS+S0PH
PHCRHD	EQ	CRSHDR+S0PH
	IF	SIORNG
PHSIRI	EQ	SIRI+S0PH
PHSIRO	EQ	SIRO+S0PH
PHSIRX	EQ	SIRX+S0PH
	EI	:SIORNG
PHXTTY	EQ	XRYTTY+S0PH
PHXBRK	EQ	XBREAK+S0PH
	IF	SILINS
	IF	SIBFRL			:###LSH
PHSIOT	EQ	SIOSTT+S2PH-20000	:###LSH
	ELSE	:NOT SIBFRL		:###LSH
PHSIOT	EQ	SIOSTT+S0PH
	EI	:SIBFRL			:###LSH
	EI	:SILINS
PHTEMP  EQ      TEMPER+S0PH
PHVOLT  EQ      VOLTS+S0PH
	EI	:1-ISIS
	IF	WHEREE
PHWHTA	EQ	WHTABL+S0PH
	EI	:WHEREE
PHDMAF	EQ	DMAFLG+S0PH
PHABEN	EQ	ABENPC+S0PH
PHSFTM	EQ	SFTMAC+S0PH
PHSFTD	EQ	SFTDMA+S0PH
PHLILC	EQ	LILCNT+S0PH
	IF	1-ISIS
	IF	NOSEG
PHABSV	EQ	ABSSAV+S2PH-SEG2
	ELSE
PHABSV	EQ	ABSSAV+SCPH-SEGC
	EI	:NOSEG##AL
	EI	:1-ISIS
PHSUTM	EQ	SUPTIM+S0PH
PHSLOC	EQ	SLOWC+SEPH-0E0000
PHSUSC	EQ	SUPSLC+S0PH
PHCRCT	EQ	CRHCNT+S0PH
PHCDTB	EQ	CDTTBL+S0PH

::*********************************************************************
::
::	PHYSICAL ADDRESSES FOR INTERRUPT ROUTINES -- TRACE/STOP FUNCTION
::
::*********************************************************************

	IF	1-ISIS
	IF	ZITEL

PHSTPW	EQ	STPWFG+S0PH	:STOPTRACE TABLE WRAP FLAG###OAS
PHLTRC	EQ	LOGTRC+S0PH	:STOPTRACE FLAG
PHLTRX	EQ	LOGTRI+S0PH	:STOPTRACE TABLE INDEX
PHSTRG	EQ	STRRGS+S0PH	:TEMP REG SAVE AREA

PHMTRG	EQ	MTRGTM+S0PH	:holds time of trace trigger
PHTSPS	EQ	TSPSW+S0PH	:holds PSW at time of MAC interrupt
PHLSTF	EQ	LSTFSV+S0PH	:save last fetch and parity error addresses
PHTRCR	EQ	TRCREG+S0PH	:save set F regs from MAC int time
PHTRCS	EQ	TRCSV+S0PH	:save 32 trace buffer addresses
PHSTPS	EQ	STPSAV+S0PH	:save offset of stop condition
PHTRMS	EQ	TRMSKS+S0PH	:save user-specified trace mask
PHTRIN	EQ	TRINCT+S0PH	:count number of trace interrupts
PHBDTR	EQ	BDTRNT+S0PH	:count bad trace interrupts
PHTROV	EQ	TROVRN+S0PH	:count new ints before old one output
PHTRCF	EQ	TRCFLG+S0PH	:flag telling XRAY to display trc data 
PHTRCU	EQ	TRCUSE+S0PH	:XD of user setting trace specs (halfword)
PHHLTO	EQ	HLTOST+S0PH	:zero means "halt on trc int"
PHSTNM	EQ	STPNMB+S0PH	:number of trggr occ to spring on

	EI	:ZITEL
	EI	:1-ISIS

	SUBTTL	FIN (BS - Bufferlet Statistics)

::*********************************************************************
::
::	Bufferlet Statistics
::
::*********************************************************************

NBFLET	EQ	CHBFSZ/CBSZ	:NUMBER OF BUFFERLETS ALLOCATED
NBFLE2	EQ	NBFLET*(CBSZ-2)	
ISCALX	EQ	0		:DETERMINE SCALE PARAMETER FOR B'LET HISTOGRAM
ISTEP	EQ	$A1024		:ASSUME SMALLEST STEP SIZE
Q	EQ	$A13
	RE	$A10
QQX	EQ	1^Q-1
	IF	(NBFLE2-QQX)	:IF NBFLE2 IS LARGER
ISCALX	EQ	ISCALX+1	:INCREMENT SCALE FACTOR
ISTEP	EQ	ISTEP*2		:AND SCALE STEP SIZE
	EI
Q	EQ	Q+1
	ER
NSTEPS	EQ	NBFLE2/ISTEP+1	:NUMBER OF LINES TO DISPLAY

	ORG	XBUFH2
ISCALE	EQ	ISCALX
        IF      ISCALE-4        :MAX RANGE IS TO 256K BYTES IN 32K BYTE STEPS
        SC      /224K-256K/
        SC      /192K-224K/
        SC      /160K-192K/
        SC      /128K-160K/
        SC      /96K -128K/
        SC      /64K - 96K/
        SC      /32K - 64K/
        SC      /UNDER 32K/
        ELSE
        IF      ISCALE-3        :ISCALE = 4 => UP TO 128K BYTES IN 16K STEPS
        SC      /112K-128K/
        SC      /96K -112K/
        SC      /80K - 96K/
        SC      /64K - 80K/
        SC      /48K - 64K/
        SC      /32K - 48K/
        SC      /16K - 32K/
        SC      /UNDER 16K/
        ELSE
        IF      ISCALE-2        :ISCALE = 3 => TO 64K IN 8K STEPS
        SC      /56K - 64K/
        SC      /48K - 56K/
        SC      /40K - 48K/
        SC      /32K - 40K/
        SC      /24K - 32K/
        SC      /16K - 24K/
        SC      /8K  - 16K/
        SC      /UNDER  8K/
        ELSE
        IF      ISCALE-1        :ISCALE = 2
        SC      /28K - 32K/
        SC      /24K - 28K/
        SC      /20K - 24K/
        SC      /16K - 20K/
        SC      /12K - 16K/
        SC      / 8K - 12K/
        SC      / 4K -  8K/
        SC      /UNDER  4K/
        ELSE
        IF      ISCALE          :ISCALE = 1
        SC      /14K - 16K/
        SC      /12K - 14K/
        SC      /10K - 12K/
        SC      / 8K - 10K/
        SC      / 6K -  8K/
        SC      / 4K -  6K/
	SC	/ 2K -  4K/
        SC      /UNDER  2K/
        ELSE                    :ISCALE=0
        SC      / 7K -  8K/
        SC      / 6K -  7K/
        SC      / 5K -  6K/
	SC	/ 4K -  5K/
        SC      / 3K -  4K/
        SC      / 2K -  3K/
        SC      / 1K -  2K/
        SC      / UNDER 1K/
        EI
        EI
        EI
	EI
	EI

:	NUMBER OF DATA BYTES IN BUFFERLET

:	USER MAY DEFINE NUMBER OF BUFFERLETS/CIRCUIT REQUIRED
	IF	1-\BFPCIR
BFPCIR	EQ	4		:DEFAULT TO 4 BUFFERLETS PER CIRCUIT
	EI	:1-\BFPCIR

	IF	REBILD
	DEFAULT(BFPHIS,8)	:MINIMUM # OF BFLETS PER HISTORY BUFFER
	ELSE	:
BFPHIS	EQ	0
	EI	:REBILD

OPTMEM	EQ	(HIADDR+(BFPCIR*NCIRCS*CBSZ)+(BFPHIS*NTERMS*CBSZ))
       IF       SIORNG
OPTMEM  EQ      OPTMEM+SCSZ             :add in room taken by sio rings
       EI

	ORG	SRESER+(2*ADRESZ)
	SC	/OPTMEM:/
	WC	OPTMEM

	IF	KERNSZ
	REMARK %EXPECT SOLO KERNEL, VERSION 222%
	EI	:KERNSZ

	SUBTTL	FIN (Memory allocation symbol declaration)

::*********************************************************************
::
::	NOW THAT MEMORY ALLOCATION SYMBOLS HAVE BEEN DEFINED, DECLARE
::	THEM FOR XRAY SYMBOL TABLE. THIS EXERCISE NOT NECESSARY FOR
::	2-PASS ASSEMBLER.  
::
::*********************************************************************

	IF	1-ISIS
PRIVBG	EQ	0
RANGE1	EQ	S0PH+RSEG0
SEG1BG	EQ	S1PH
SEG1RL	EQ	10000
SEG1SZ	EQ	S1SZ
XRAYBG	EQ	SDPH
XRAYRL	EQ	SEGD
XRAYSZ	EQ	SDSZ
	EI	:1-ISIS

	ENDMO.(FIN)

:	***END FIN***

	EI	:1-KILLIT

	KILMSG(FIN)

BADCOD	ERRCNT
	KILLER(BADCOD)
	IF	KILLIT

	REMARK	%%%%
	REMARK	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%
	REMARK	!!! FATAL ERROR !!! FATAL ERROR !!!%
	REMARK	!!! ASSEMBLY HAS BEEN KILLED !!!!!!%
	REMARK	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	REMARK	%%%%

	KILL	SEG0,PRIVBG		:Don't allow write-out

	EI	:KILLIT
	UN

:	***NOTHING PAST THIS POINT***

	SUBTTL	CONFIG

:			 ***   ***  *   * ***** *****  ***
:			*   * *   * **  * *       *   *   *
:			*     *   * * * * ****    *   *
:			*   * *   * *  ** *       *   *  **
:			 ***   ***  *   * *     *****  ****

::#####################################################################
::
::	MODULE:		C O N F I G
::
::	FUNCTION:	Display assembly configuration
::
::#####################################################################

	IF	1-KILLIT

::*********************************************************************
::
::	Display assembly configuration, based on value of CONFIG -
::		CONFIG = 0 means no display
::			 1 means simple display
::		       > 1 means full display
::	Simple display (CONFIG = 1) looks like this:
::
::	TYMNET-II Node Code Version 5.12, ISIS Node
::
::	Node: 2161  Kernel Host: 633
::
::	Ports:		Lines:		Links:
::	    32d Pthru	    16d Sync	     6d TIILNK
::	     3d Xray	    18 SIO	    10d XLNK
::			    24d Total	    16d Total
::	   512d Disp
::	     4d Krnl
::
::	Maximum number of circuits =  604d
::
::
::	Bufferlet storage space:
::
::	 0AA76 bytes ( 43d KB) for  604d total circuits  ( 72d bytes per circuit)
::
::
::	Memory used by this configuration = 40000x, 256d KB.
::
::	Optimal amount of memory for this configuration =   246d  KB.
::
::*********************************************************************

	DEFAULT(CONFIG,(1+BLAB))

	IF	CONFIG

:	IDENTITY REMARKS...

	REMARK	%%TYMNET-II Node Code, Version 
	NUMBER $8(VERSION/100)&77
	 IF	$81-(VERSION&070)
	REMARK .0
	 ELSE	:NO LEADING ZERO REQUIRED
	REMARK .
	 EI	:$81-(VERSION&070)
	NUMBER $8VERSION&77
	 IF	SOLOCS
	REMARK	, SOLO Consat
	 ELSE	ISIS
	  IF	T2GATE
	REMARK	, GATEWAY Node
	  ELSE
	REMARK	, ISIS Node
	  EI	:T2GATE
	 ELSE	SUPER
	REMARK	, SOLO Supervisor Base
	 ELSE	:none of the above
	REMARK	, SOLO Switcher
	 EI	:SOLOCS
	CRLF.(2)
	REMARK	Node: 
	NUMBER	$8MACHNM

	IF	T2GATE
	REMARK	  H-Net Host (Kernel):
	NUMBER	$AHHOST
	REMARK    I-Net Host:
	NUMBER	$AIHOST
	CRLF.(2)
	ELSE	:NOT T2GATE

	REMARK	  Kernel Host: 
	NUMBER	$AHST0
	CRLF.(2)
	EI	:T2GATE

	 IF	SIORNG
	REMARK %SIO ring interface, device address 
	NUMBER SIORNG
	REMARK x%
	 EI	:SIORNG

:	REPORT LINES AND LINKS AND PORTS
	REMARK	Ports:		Lines:		Links:
	CRLF.

	NMBR.(NPASTH,A,6)		:CHANGED BY ###EV
	REMARK	Pthru
	TAB.
	NMBR.((NLINES-SILINS),A,6)
	REMARK	Sync
	TAB.
	NMBR.((NLINKS-XLINKS),A,6)
	REMARK	TIILNK
	CRLF.

	NMBR.(NXUBLK-1,A,6)
	REMARK	Xray
	TAB.
	NMBR.(SILINS,A,6)
	REMARK	SIO
	TAB.
	NMBR.(XLINKS,A,6)
	REMARK	XLNK
	CRLF.

	TAB.(2)
	NMBR.(NLINES,A,6)
	REMARK	Total
	TAB.
	NMBR.(NLINKS,A,6)
	REMARK	Total
	CRLF.

	 IF	NAPORT
	NMBR.(NAPORT,A,6)
	REMARK	Async
	CRLF.

	  IF	PVC
	NMBR.(PVCCNT,A,6)
	REMARK	PVC
	CRLF.

	  EI	:PVC
	 EI	:NAPORT
	 IF	ISIS
	NMBR.(NDP,A,6)
	REMARK	Disp
	CRLF.

	 EI	:ISIS
	 IF	KERNEL
	NMBR.(NKU,A,6)
	REMARK	Krnl
	CRLF.

	 EI	:KERNEL
	 IF	SUPER
	NMBR.(NSP,A,6)
	REMARK	Supe
	CRLF.

	 EI	:SUPER
	CRLF.

	REMARK Maximum number of circuits = 
	NMBR.(NCIRCS,A,4)
	CRLF.(2)

BTPCIR	EQ	BFPCIR*(CBSZ-2)	: Bufferlet bytes per circuit -- Recommended
BTPHIS	EQ	BFPHIS*(CBSZ-2)	: Bufferlet bytes per history Buffer
NBFLBT	EQ	NBFLET*(CBSZ-2)	: Number of Bufferlet bytes
NCIRBT	EQ	NBFLBT		: Number of Circuit bytes
NHISBT	EQ	0		: Number of History bytes

	REMARK	%Bufferlet storage space:%%

	 IF	REBILD
	  IF	NBFLETS+1-(NCIRCS*BFPCIR)
NCIRBT	EQ	NCIRCS*BTPCIR	:Number of Circuit bytes
	  ELSE
NCIRBT	EQ	NBFLBT
	  EI

	  IF	NBFLBT-NCIRBT
NHISBT	EQ	(NBFLBT-NCIRBT)	: Number of History bytes
	  EI

	NMBR.(NCIRBT,0,6)
	REMARK	bytes (
	NMBR.(((NCIRBT+1023)/1024),A,3)
	REMARK	KB) for 
	NMBR.(NCIRCS,A,4)
	REMARK	circuit buffers (
	NMBR.((NCIRBT/NCIRCS),A,3)
	REMARK	bytes per circuit)%

	NMBR.(NHISBT,0,6)
	REMARK	bytes (
	NMBR.(((NHISBT+1023)/1024),A,3)
	REMARK	KB) for 
	NMBR.(NTERMS,A,4)
	REMARK	history buffers (
	NMBR.((NHISBT/NTERMS),A,3)
	REMARK	bytes per termination)%
	 EI	:REBILD

	NMBR.(NBFLBT,0,6)
	REMARK	bytes (
	NMBR.(((NBFLBT+1023)/1024),A,3)
	REMARK	KB) for 
	NMBR.(NCIRCS,A,4)
	REMARK	total circuits  (
	NMBR.((NBFLBT/NCIRCS),A,3)
	REMARK	bytes per circuit)%%

Q	EQ	(NCIRCS*BTPCIR)+(NTERMS*BTPHIS)

	 IF	Q-NBFLBT
	REMARK	****************************************************************
	REMARK	%Number of bufferlets allocated is insufficient...%
	  IF	REBILD
	NMBR.(BTPCIR,A,3)
	REMARK	bytes per circuit buffer recommended, 
	NMBR.((NCIRBT/NCIRCS),A,3)
	REMARK	bytes allocated.%
	NMBR.(BTPHIS,A,3)
	REMARK	bytes per history buffer recommended, 
	NMBR.((NHISBT/NTERMS),A,3)
	REMARK	bytes allocated.%
	  EI	:REBILD
	NMBR.((((NCIRCS*BTPCIR)+(NTERMS*BTPHIS))/NCIRCS),A,3)
	REMARK	total bytes per circuit recommended,  
	NMBR.((NBFLBT/NCIRCS),A,3)
	REMARK	bytes allocated.%%
	NUMBER $A(100-(NBFLBT*100)/Q)
	REMARK	 percent below recommended level,
	NMBR.((((Q-NBFLBT)+2*((Q-NBFLBT)/(CBSZ-2))+1023)/1024),A,3)
	REMARK	KB additional memory recommended.%
	REMARK	****************************************************************
	 EI	:Q-ETC...

	REMARK %Memory used by this configuration = 
	NUMBER $0 ENDNOD
	REMARK x, 
	NUMBER $A (ENDNOD+1023)/1024
	REMARK d KB.%


	REMARK %Optimal amount of memory for this configuration = 
	NMBR.(((OPTMEM+1023)/1024),A,4)
:	NUMBER $A ((HIADDR+(BFPCIR*NCIRCS)*CBSZ)+1023)/1024
	REMARK  KB.%

	 IF	MEMRMK-1
:	TELL MEMORY REQUIREMENTS
	REMARK	Memory:
QQ	EQ	0
QQCT	EQ	3
	RE      0F
	  IF	\S|QQ|SIZE
	   IF	S|QQ|SIZE
	    IF	(QQCT&3)-2
	CRLF.
	    ELSE
	TAB.
	    EI
	    IF	0A-QQ
	REMARK	SEG0
	    ELSE
	REMARK	SEG
	    EI
	NUMBER	QQ
	REMARK	=
	NMBR.((S|QQ|SZ),0,6)
:	NUMBER	S|QQ|SZ
:	REMARK	x
QQCT	EQ	QQCT+1
	   EI
	  EI
QQ	EQ	QQ+1
	ER
	CRLF.
	 EI	:MEMRMK-1


	 IF	KERNSZ
	REMARK %EXPECT SOLO KERNEL, VERSION 222%
	 EI	:KERNSZ

	IF	CONFIG-1

NCFRMK	EQ	0
	REMARK	%Assembly switches and options were set as follow:%
	REMARK	CONSAT -
	CFGRMK(CONSAT)
	REMARK	DB.BTR -
	CFGRMK(DB.BTR)
	REMARK	DB.BUB -
	CFGRMK(DB.BUB)
	REMARK	DB.CIR -
	CFGRMK(DB.CIR)
	REMARK	DB.DEB -
	CFGRMK(DB.DEB)
	REMARK	DB.SYN -
	CFGRMK(DB.SYN)
	REMARK	DB.TRC -
	CFGRMK(DB.TRC)
	REMARK	IKNRNG -
	CFGRMK(IKNRNG)
	REMARK	KERNEL -
	CFGRMK(KERNEL)
	REMARK	KNRING -
	CFGRMK(KNRING)
	REMARK	ISIS   -
	CFGRMK(ISIS)
	REMARK	NEWALI -
	CFGRMK(NEWALI)
	REMARK	PVC    -
	CFGRMK(PVC)
	REMARK	REBILD -
	CFGRMK(REBILD)
	REMARK	SIORNG -
	CFGRMK(SIORNG)
	REMARK	SRING  -
	CFGRMK(SRING)
	REMARK	SUPER  -
	CFGRMK(SUPER)
	REMARK	TYMSAT -
	CFGRMK(TYMSAT)
	EI	:CONFIG-1
	EI	:CONFIG
	EI	:1-KILLIT

	END

:	***NOTHING PAST THIS POINT***

   )  