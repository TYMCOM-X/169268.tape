	SUBTTL  SHARE

:			*****     ***** *****
:			  *         *     *
:			  *   ***   *     *
:			  *         *     *
:			  *       ***** *****

:	TYMNET II NODE CODE  --  BOTH STAND-ALONE AND UNDER ISIS

: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source  code  listing  constitutes  the proprietary   **
: **  property of MDC-TYMNET.  The recipient, by receiving this   **
: **  program listing, agrees that neither this listing nor the   **
: **  information disclosed herein nor any part thereof shall be  **
: **  reproduced or transferred to other documents or used or dis-**
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by MDC-TYMNET. **
: ******************************************************************

:			 **** *   *   *   ****  *****
:			*     *   *  * *  *   * *
:			 ***  ***** ***** ****  ****
:			    * *   * *   * *  *  *
:			****  *   * *   * *   * *****

::#####################################################################
::
::	MODULE:		SHARE
::
::	FUNCTION:  Define the default value of 'IF' switches and low
::		   core memory area where NODE CODE starts. Handler
::		   routines and entry points for SuperVisor Calls,
::		   TTY interrupt, context switcher, illegal instruction
::		   interrupt and Memory Access Controller interrupt.
::
::	REGISTER CONVENTIONS:	None
::
::	SUBTTLS:   Solo Low Core Assignments
::		   Solo Privileged Code
::		   ASYNC Microcode Parameters
::		   SSTART
::		   SVC'S
::		   ASYNC I/O SVC'S
::		   TTY Interrupt Routines
::		   Context Switcher
::		   Hardware Faults
::
::	ROUTINES:  SSTART: Node code starts, stores an active flag.
::		   SVC00 ~ SVC24: SuperVisor Call services thru int..
::		   TTYINT: on TTY int.
::		   TVINT:  TTY receiVe int. mode
::		   TXINT:  TTY Xmit int. mode
::		   ANCALL: Active Node code thru context switcher.
::		   AXCALL: Active Xray thru context switcher.   
::		   KRCALL: Kernel call thru context switcher.
::		   IDCALL: Idle for 1/600 sec thru context switcher.
::		   ILINST: Illegal instructn int. service.
::		   
::#####################################################################

:	DEFINE KILLIT TO ENABLE ASSEMBLY.  IF KILLIT GETS SET > 0,
:	ASSEMBLY STOPS IMMEDIATELY.

KILLIT	EQ	0
	IF	(1-KILLIT)	:OK to assemble

	RA	0		:INITIALIZE TO HEX RADIX

::*********************************************************************
::
::	DEFAULT:  NEW EXPANDED CODE AS OF APRIL '86 REQUIRES THE
::		  FOLLOWING DEFAULTS
::
::*********************************************************************

	DEFAULT(NOSEG,1)
	DEFAULT(NAKCOD,0)	:Starlink NAK protocol
	DEFAULT(CKSM,0)		:DON,T SEND CHECKSUM FOR NON-STAR SIO LINE##LSH
				:MUST SEND CHECKSUM FOR STAR LINE ###LSH
	DEFAULT(XRESET,1)	:..but for now .. one at a time	###ev
::	THE ABOVE MAY LATER BE REMOVED AS SECTIONS ARE INCORPORATED INTO 
::	PRODUCTION CODE ASSEMBLY
	DEFAULT(MEMMON,0)	:MEMORY MONITOR
	DEFAULT(BLAB,0)
	DEFAULT(SUP,0)		:FOR ISIS GOODGY LIST COMPATABILITY	###OAS
	DEFAULT(LOWSPD,0)
	DEFAULT(NSPORT,0)
	DEFAULT(NANIPT,0)
	DEFAULT(NRPORT,0)
	DEFAULT(CRHRMK,0)
	DEFAULT(NAPORT,0)
	DEFAULT(NAPRT2,2*NAPORT)
	DEFAULT(NEWALI,0)
	DEFAULT(TYMSTR,0)	:TYMSTAR PROJECT ##AL
	DEFAULT(STRHUB,0)	:TYMSTR CENTRAL HUB STATION SWITCH ##AL
	DEFAULT(RBTHUB,0)	:TYMSTR CENTRAL HUB REMOTE BOOT SWITCH ##AL
	DEFAULT(RBTRMT,0)	:TYMSTR REMOT STATION REMOTE BOOT SWITCH ##AL
	DEFAULT(STRDCD,0)	:TYMSTAR SIOUT SWITCH TO TEST DCD BIT ###LSH
	DEFAULT(RESTRY,0A)	:Tymstar remote reset retry counter	##ev
	DEFAULT(STRRMT,0)	:TYMSTAR REMOTE EARTH STATION SWITCH
	DEFAULT(RSTFRQ,4)	:Tymstar remote sends initial reset 4 x 4 (sec)
	DEFAULT(TH.ACK,3)	:NULL REC ACK THRESHOLD			##GT
	DEFAULT(SYNFCS,0)	:SYNC LINE SW FCS ERR CHECKING		##al
	DEFAULT(STCNSW,0)	:TYMSTAR SIOCO/SIONO SWAPING ##AL
	DEFAULT(NODUM,0)
	DEFAULT(ALHUB,0)	:LDTIM, XUBLK relocation		###AL
	DEFAULT(AL1,0)		:#passthrough is 32 per link		###AL
	DEFAULT(NGRDTM,0)	:NO GOOD RCD RCVED REPORTING TIME	###AL
:	DEFAULT(ALBERT,0)
:	DEFAULT(ALTEST,0)	:TEST CODE			###AL
	DEFAULT(PRIMSG,1)	:PRIORITY CRYPTO MESSAGE BUFFER
				: DEFAULTED FOR XRAY ##AL
	DEFAULT(IRC,0)		:INTERNATNAL RCD CARRIER FOR GATEWAY##AL
	DEFAULT(NETNAM,0)	:GATEWAY NETWORK NAMING ##AL
	DEFAULT(INTACC,0)	:INTERNAL HOST ACCOUNTING 		##AL
	DEFAULT(XRSZLV,3)	:XRAY SIZE ASSEMBLY LEVEL SWITCHES 	##AL
	DEFAULT(SDW.TR,0)       :for multiple isis traps
	DEFAULT(SDW.1,0)
	DEFAULT(SDW.2,0)
	DEFAULT(SPLCSZ,180)     :BCT of both buffers before use SPLICE 
                                :instead of APPEND (new rebuild logic)
	DEFAULT(REBTST,0)               :better and faster rebuild code
	DEFAULT(LHSU,0)
	DEFAULT(PKTSAV,0)	:SAVE PACKETS ON CRASH 			###LSH
	DEFAULT(EV1,0)
	DEFAULT(EV2,0)		:###EV
	DEFAULT(EV3,0)
	DEFAULT(ACCT,0)		:GATEWAY ACCOUNTING 			##AL
	DEFAULT(KOPFJ,0)
	DEFAULT(NDREAD,0)	:enable reading of last org ndl in node
	DEFAULT(SVCCXT,1) 	:makes SVCPSW part of switched context envrnmnt
        DEFAULT(SPAM,0)         :issue svc to send Node CPS to SPAM     ###sdw
	DEFAULT(NEWTRP,0)	:New Trapdoor (SVC29 - unimplemented)	###tz
	DEFAULT(BFLTMR,0)	:for buffer timer pairs
	DEFAULT(ZITEL,0)
	DEFAULT(NMACH,1)	:NUMBER OF MACHINES FOR ISIS-MXP SUPPORT
	DEFAULT(MXPNM,0)	:FOR ISIS-MXP SUPPORT
	IF	MXPNM		:###wjl
	DEFAULT(NUMHST,$A 128)	:TYMFILE spec for NHOSTS
	ELSE	:not MXPNM
	DEFAULT(NUMHST,$A 64)
	EI	:MXPNM
	DEFAULT(JIM,0)
	DEFAULT(LADEN,0)
	DEFAULT(XRYTMC,0)	:TMCS/XRAY 0=off, 1=on, 2=reduced XRAY	###wjl
	DEFAULT(NETNAM,0)
:	DEFAULT(KILLT1,1)	:Default as of 3/20/86 eliminates T-1 code #ev
	DEFAULT(IDTACH,0)	:ISIS Detach				###wjl
	DEFAULT(EXPSEC,1)	:DEFAULT EXPANDED XRAY SECURITY SWITCH	###OAS
	DEFAULT(SUPTRC,0)	:SUP RING TRACE DEBUG CODE		###OAS
	DEFAULT(XRYMES,0)	:DEFAULT FOR XRAY MESSAGE ENTERED IN TYMFILE
	DEFAULT(SOLOCS,0)	:Default to no SOLO Consat
	DEFAULT(LABTST,0)	:for bypassing consat version list
	DEFAULT(.PROF.,0)	: Disable PROFILE			###JOK
	DEFAULT(TELEX,0)	:this should be in CONSAT proper	###jhl
	DEFAULT(SCBSYO,1)	:enables busy out of async port from XRAY
	DEFAULT(NPAPRT,0)	:number of addressable ports
:	DEFAULT(NETID,0)	:NETWORK ID (TYMFILE SPEC)		###OAS 
	DEFAULT(NETMOD,0)	:NETWORK MODIFIER (TYMFILE SPEC)	###OAS
	DEFAULT(SUBNET,0)	:SUBNET NUMBER (TYMFILE SPEC)		###OAS
				:THESE PARAMETERS ARE USED IN THE
				:EXPANDED SUPERVISOR TAKEOVER RESPONSE
	DEFAULT(DIALUP,0)	:and in the Expanded Reset pattern	###wjl
				:AND WILL EVENTUALLY BE A TYMFILE SPEC	###OAS
	DEFAULT(ACCT2,0)	:Default for current accounting formats 
				:19-apr-85  supports 24bit fields only	###EV
	DEFAULT(T2GATE,0)	:Gateway not configured normally
	DEFAULT(MACHIN,1)	:ISIS Tymfile parameter - 1=Engine,	###wjl
	DEFAULT(HMICRO,0)	:	2=HDLC Micro, 3=TSI		###wjl
	DEFAULT(TSI,0)		:					###wjl
	DEFAULT(BPFIX,0)		:###EV TESTING BP LOGIC
:	INSERT FUTURE SWITCHES AT TOP OF LIST				###wjl
	IF	MACHIN-2
TSI	EQ	1
	ELSE	MACHIN-1
HMICRO	EQ	1
	ELSE	:MACHIN
:	DEFAULT
	EI	:MACHIN
::	TYMSTAR  SIO Initialization for HDLC Micro, TESTING SWITCH
::		(May be removed after new HDLC Init CCW is tested)	###EV
	DEFAULT(HMITST,0)

:: Gateway equates and constants and defaults
	IF	T2GATE
	DEFAULT(INCOST,0)
	DEFAULT(HNCOST,0)
ISIS	EQ	1
TII	EQ	1
IDTACH	EQ	1		:Gateway will use Isis detatch logic
NUSLT	EQ	0
NUMHST  EQ      4               :must be a multiple of four  ###sdw
RKERNL	EQ	0
KNRING	EQ	0
IKNRNG	EQ	0
PTHRU	EQ	1		:Gateway does not allow passthroughs
	EI	:T2GATE	

::Starhub or Star remote require default parameters
	IF	STRHUB!STRRMT	:FOR TYMSTAR				
	DEFAULT(APLYBP,1)	:Apply BackPressure logic for Tymstar	###ev
	DEFAULT(MAKNUL,1)	:Checks for sending null rec	###ev
	DEFAULT(RRXLIM,3)	:Threshold of repeat rexmissions before null
	DEFAULT(ST.ACK,14)	:DIFFERENT THRESHOLD FOR TYMSTAR	###GT
	DEFAULT(RXTIME,600)	:Paced reXmissions at 1 packet per sec ###ev
XRESET	EQ	1
	ELSE
	DEFAULT(MAKNUL,0)	:Checks for sending null rec
	DEFAULT(RRXLIM,3)	:Threshold of repeat rexmissions before null
	DEFAULT(APLYBP,0)
	EI	:STRHUB!STRRMT:
	IF	STRRMT
NGRDTM	EQ	4		:Remote use defaulted 16sec no data reporting
	EI	:STRRMT							###AL

:	The following symbols may be defined in the TYMFILE if the defaults
:	listed below are not satisfactory for patching.
:	PHSIZE defines the length in bytes of the PATHIS area.
:		default: 140 hex
:	P0SIZE defines the length in bytes of the PATCH0 area.
:		default: 200 hex
:		default: an area will be defined by this library
:	P1SIZE defines the length in bytes of the PATCH1 area.
:		default: 400 hex
	DEFAULT(PHSIZE,200)
PHSIZE	EQ	(PHSIZE+0F)/10*10
	DEFAULT(P0SIZE,200)
	DEFAULT(P1SIZE,400)

::*********************************************************************
::
::	ASCII equates for character comparison ###JHL
::
::*********************************************************************

ASC7BT	EQ	7F	:SEVEN BITS OF CHARACTER
ASCLF	EQ	0A	:ASCII LINE FEED
ASCCR	EQ	0D	:ASCII CARRIAGE RETRUN
ASCESC	EQ	1B	:ASCII ESCAPE CHAR
ASCSPC	EQ	20	:ASCII SPACE
ASCEXP	EQ	21	:ASCII EXCLAMATION POINT
ASCAST	EQ	2A	:ASCII *
ASCPLS	EQ	2B	:ASCII +	
ASCCOM	EQ	2C	:ASCII COMMA
ASCDSH	EQ	2D	:ASCII DASH (HYPHEN)
ASCDOT	EQ	2E	:ASCII PERIOD
ASCFSL	EQ	2F	:ASCII FORESLASH
ASCZRO	EQ	30	:ASCII ZERO
ASCONE	EQ	31	:ASCII ONE
ASCTWO	EQ	32	:ASCII TWO
ASCTHR	EQ	33	:ASCII THREE
ASCFOU	EQ	34	:ASCII FOUR
ASCFIV	EQ	35	:ASCII FIVE
ASCSIX	EQ	36	:ASCII SIX
ASCSEV	EQ	37	:ASCII SEVEN
ASCEIG	EQ	38	:ASCII EIGHT
ASCNIN	EQ	39	:ASCII NINE
ASCCOL	EQ	3A	:ASCII COLON
ASCSMC	EQ	3B	:ASCII SEMICOLON
ASCQST	EQ	3F	:ASCII ?
ASCAT	EQ	40	:ASCII @
ASCA	EQ	41	:ASCII A
ASCB	EQ	42	:ASCII B
ASCC	EQ	43	:ASCII C
ASCD	EQ	44	:ASCII D
ASCE	EQ	45	:ASCII E
ASCF	EQ	46	:ASCII F
ASCG	EQ	47	:ASCII G
ASCH	EQ	48	:ASCII H
ASCI	EQ	49	:ASCII I
ASCJ	EQ	4A	:ASCII J
ASCK	EQ	4B	:ASCII K
ASCL	EQ	4C	:ASCII L
ASCM	EQ	4D	:ASCII M
ASCN	EQ	4E	:ASCII N
ASCO	EQ	4F	:ASCII O
ASCP	EQ	50	:ASCII P
ASCQ	EQ	51	:ASCII Q
ASCR	EQ	52	:ASCII R
ASCS	EQ	53	:ASCII S
ASCT	EQ	54	:ASCII T
ASCU	EQ	55	:ASCII U
ASCV	EQ	56	:ASCII V
ASCW	EQ	57	:ASCII W
ASCX	EQ	58	:ASCII X
ASCY	EQ	59	:ASCII Y
ASCZ	EQ	5A	:ASCII Z
ASCBSL	EQ	5C	:ASCII BACKSLASH
ASCAP	EQ	5F	:and-mask to force upper case 
ASCUC	EQ	0DF	:and-mask with HOB set

	IF	XRYTMC			:###wjl
EHIIXX	EQ	10			:indicate IIX for HSTATN
IIX0F6	EQ	0F6			:second byte of SIIX for GCIXRY
IIX0F7	EQ	0F7			:second byte of TIIX for GCIXRY
	EI	:XRYTMC

	IF	SOLOCS
CSBASE	EQ	0
A.DATA	EQ	0		:CONSAT's name for seg0
A.CODE	EQ	1		:CONSAT's name for seg1
	GL	CSBASE,A.DATA,A.CODE

	IF	TELEX		:###wjl
PRODID	EQ	31		:Product ID...Consat
REVLEV	EQ	2		:Revision Level
	GL	PRODID,REVLEV
	EI	:TELEX




::*********************************************************************
::
::	PORT TABLE LAYOUT (ENTRIES REQUIRED BY CONSAT ARE MARKED %%%%)
::
::*********************************************************************

	GL	.PTP.,.LRSAV
	GL	.PORT,.TERMT,.TTBUF,.FTBUF,.LGBUF,.VSTAT,.VSAVE
	GL	.XSTAT,.XSAVE,.LSTAT,.MARGE,.PVCX,.PVCTO,.PVCDO

Q	EQ	.		:HERE WE ARE

	ORG	0		:BASELINE
.PORT	HS	1		:PORT NUMBER %%%%
.TERMT	HS	1		:TERMINAL TYPE %%%%
.TTBUF	HS	2		:TO-TERMINAL BUFFER INDEX %%%%
.FTBUF	HS	2		:FROM-TERMINAL BUFFER INDEX %%%%
.LGBUF	HS	2		:LOGON INPUT BUFFER INDEX %%%%
.ALBUF	HS	2		:LOGIN BUFFER FOR LOGGER
.VSTAT	HS	2		:POINTER TO CURRENT RECEIVER FILTER %%%%
.VSAVE	HS	2		:POINTER TO NORMAL RECEIVER FILTER %%%%
.XSTAT	HS	2		:POINTER TO CURRENT TRANSMITTER FILTER %%%%
.XSAVE	HS	2		:POINTER TO BACKUP TRANSMITTER FILTER %%%%
.LSTAT	HS	2		:POINTER TO LOGON STATUS HANDLER %%%%
.VBSTA	HS	1		:Pointer to current AGETCH routine
.MARGE	HS	1		:CURSOR POSITION OR DELAY COUNT
.LRSAV	HS	2		:Link register save area

.PVCX	HS	2		:PVC EXCEPTION PARAMETERS %%%%
.PVCTO	HS	1		:PVC TIMEOUT %%%%
.PVCLH	HS	2		:PVC LOGON HISTORY/FLAG %%%%
.PVCDO	BS	1		:PVC ACTION STATE %%%%

	IF	TELEX		:change to IIX before release?	###wjl
	GL	.IIXDT,.IIXMD,.IIXSV,.IIXSM
.IIXMD	HS	1		:-1 if in dialect select mode
.IIXDT	HS	1		:IIX dialect, 0 means no dialect selected
.IIXSV	HS	2		:IXX save area
.IIXSM	HS	1		:IXX save msg area
	EI	:TELEX

.PTLEN	WS	0		:TABLE ENTRY LENGTH %%%%
	GL	.PTLEN
	ORG	Q		:BACK TO WHERE WE STARTED
	EI	:SOLOCS

	DEFAULT(BAUDR,0)	:Async rate: 0=1200, 1=not used, 2=4800 BPS

:	SET UP DEBUGGING AND TEST OPTIONS. THE OPTIONS MAY BE SPECIFIED
:	BY EXPLICIT DEFINITION OF FLAGS TO BE SET, BY USE OF THE OPTION MACRO,
:	OR BY SETTING THE SYMBOL O.FLAG WITH THE PROPER BIT ARRAY VALUE.
	DEFAULT(O.FLAG,0)		:DEFAULT TO 0 IF NOT DEFINED
	IF	BAUDR-1			:IF 4800 BAUD CONSAT		###wjl
DB.TRC	EQ	0			:DON'T ALLOW UPSW JUMP TRACE OPTION
	EI	:BAUDR-1		:				###wjl
	DEFAULT(DB.TRC,O.FLAG&UTRC)	:DB.TRC ENABLES UPSW JUMP TRACE OPTION
	DEFAULT(DB.CIR,O.FLAG&CIRD)	:DB.CIR ENABLES XRAY DISPLAY OF
					: CIRCUITS BUILT AND ZAPPED.
	IF	(1-\DB.SYN)
Q	EQ	O.FLAG&NTLV	:NTLV DISABLES TLEV TRACING		###OAS 
	IF	Q
DB.TSN	EQ	0
	ELSE	:Q
DB.TSN	EQ	TLEV		:DB.TSN ENABLES SYNC LINE DIAGNOSTIC TRACE
	EI	:Q
	EI	(1-\DB.SYN)

	DEFAULT(DB.DEB,O.FLAG&DBUG)	:GENERAL NODE CODE DEBUGGING OPTION

	DEFAULT(REBILD,(O.FLAG&REBLD)/REBLD)	:REBUILD LOST CIRCUITS
                                                :divide added by        ###sdw

:	Define General Registers

	GLOBAL(R0,0)			: register 0
	GLOBAL(R1,1)			: register 1
	GLOBAL(R2,2)			: register 2
	GLOBAL(R3,3)			: register 3
	GLOBAL(R4,4)			: register 4
	GLOBAL(R5,5)			: register 5
	GLOBAL(R6,6)			: register 6
	GLOBAL(R7,7)			: register 7
	GLOBAL(R8,8)			: register 8
	GLOBAL(R9,9)			: register 9
	GLOBAL(R10,0A)			: register 10
	GLOBAL(R11,0B)			: register 11
	GLOBAL(R12,0C)			: register 12
	GLOBAL(R13,0D)			: register 13
	GLOBAL(R14,0E)			: register 14
	GLOBAL(R15,0F)			: register 15

:	Special Register Definitions

R2BE	EQ	R2		:EVEN BUFFER INDEX
R2BO	EQ	R2		:ODD BUFFER INDEX
CD	EQ	R13		:pointer to reCord Descriptor
KD	EQ	R15		:pointer to linK Descriptor
KN	EQ	R11		:linK Number 
KX	EQ	KN		:pointer to linK descriptor (Xray)
LN	EQ	R14		:Line Number
PN	EQ	R14		:async Port Number
PN2	EQ	R13		:async Port Number * 2
PRD	EQ	R12		:Pointer to Record Data
:	WORKING REGISTERS FOR HANG/ANSWER MODULE
W20	EQ	R15		:RING GROUP TIMES 20
WP	EQ	R14		:PORT
WP2	EQ	R13		:TWICE PORT
W4	EQ	R12		:BYTE ADRS OF GROUP BITS. 0,4,8, OR 0C.
WCP	EQ	R11		:CARRIER PRESENCE
WDSR	EQ	R10		:DATA SET READY
WDTR	EQ	R9		:DATA TERMINAL READY
WTA	EQ	R8		:HANG/ANSWER TIMEOUT PARAMETER
WRLA	EQ	WDTR		:RECEIVER LINE ACTIVE

	GLOBAL(RBC,R1)		:Register points to Bufferlet Character
	GLOBAL(RBF,R8)		:Register links to BuFferlet operations
RBPTMP	EQ	R2
	GL	RBPTMP
	GLOBAL(RBPTMP,RBP)
	GLOBAL(RCH,R7)		:Register for getCH link
	GLOBAL(RLINK,R10)	:Register LINKs to polling processes, et al.
	GLOBAL(RP,R14)		:CONSAT uses this for port number
	GLOBAL(RP2,R13)		:CONSAT uses this for port number * 2
	GLOBAL(RBITS,R13)	:points to start of async bit arrays
	GLOBAL(RPI,R12)		:Register points to Port table Information
	GLOBAL(RPOL,R11)	:Register used by consat POLLing processes
SD	EQ	PRD		:pointer to reSet Data buffer
XD	EQ	R15		:pointer to Xray user block Descriptor
XN	EQ	XD		:Xray user slot Number

:	DEFINE VIRTUAL SEGMENTS

SEG1	EQ	10000
SEGD	EQ	0D0000

	GLOBAL(NSYMBL,0)	:init count of symbols for XRAY symbol table
	GLOBAL(ADRESZ,0C)	:size of symbol table entry

::*********************************************************************
::
::	DEFINE DEFAULT VALUES FOR CONFIGURATION PARAMETERS
::
::*********************************************************************

:	IF TII DEFINED, THEN NODE CODE IS BEING ASSEMBLED WITH ISIS
	IF	\TII
	IF	TII
ISIS	EQ	1		:IF TII TRUE, THEN MUST BE ISIS
	DEFAULT(NSYNC,10)	:ISIS TYMFILE parameter for Number of	###wjl
	IF	NSYNC		: SYNC lines.  Version 7.00 ISIS and	###wjl
	DEFAULT(NEWSYN,0)	: above allow configuration with no	###wjl
	ELSE	:no SYNC	: sync lines. NEWSYN is a temporary	###wjl
	DEFAULT(NEWSYN,1)	: assembly switch which can be removed	###wjl
	EI	:NSYNC		: after ISIS changes for record	descr,	###wjl
	IF	NEWSYN		: RECBUF, and KDSC are implemented	###wjl
	DEFAULT(EXPWSZ,1)	:					###wjl
	ELSE	:current SYNC
PKTSAV	EQ	0		:CAUTION -- COPY instruction will ALWAYS
:	access an additional half-word (this half-word is NOT copied)
:	BEFORE the beginning of the source block...if this block begins
:	on a segment boundary, this will cause a reference to the LAST
:	half-word of the previous segment, and will cause a MAC violation!!
:	PKTSAV will cause RECBUF to be COPYed to PCKTSV on crash.	###wjl
	DEFAULT(EXPWSZ,0)	:ISIS SYN DRIVER HAS NOT BE CHANGED TO SUPPORT
	EI	:NEWSYN		: EXPANDED WINDOW SIZE ##AL
	EI	:TII
	ELSE	:TII NOT DEFINED, TEST FOR ISIS
	DEFAULT(ISIS,0)		:TII, ISIS NOT DEFINED - NOT ISIS CONFIGURATION
	DEFAULT(NEWSYN,1)	:temporary switch for ISIS only		###wjl
	DEFAULT(EXPWSZ,1)	:					###wjl
	EI	:\TII

	DEFAULT(EXPNDL,0)	:expanded needle handling and SNI's (UUN)

	IF	1-ISIS		:					###wjl
	IF	EXPNDL		:					###wjl
EXPNDL	EQ	0		:expanded needle not available on solo	###wjl
	REMARK	%
	REMARK	%********************************************************
	REMARK	%!! EXPANDED NEEDLE HANDLING NOT ALLOWED ON SOLO NODES !!
	REMARK	%********************************************************
	REMARK	%
	EI	:EXPNDL		:					###wjl
	EI	:1-ISIS		:					###wjl

	IF	(1-\KERNEL)
	IF	ISIS
KERNEL	EQ	1	:ISIS HAS A KERNEL
	ELSE	:ISIS
KERNEL	EQ	0	:DEFAULT TO NO KERNEL ON MACHINE
	EI	:ISIS
	EI	(1-\KERNEL)

	DEFAULT(IKNRNG,0)	:DEFAULT TO ISIS NO NEG RING KERNEL.
	DEFAULT(PAT1SZ,80)	:size of seg 1 patch area
	DEFAULT(PAT0SZ,80)	:size of seg 0 patch area
	DEFAULT(PTHRU,0)	:DEFAULT TO PASSTHROUGHS ENABLED
	DEFAULT(NPTHR,100)	:DEFAULT TO $A 256 PASSTHROUGHS
	DEFAULT(NDP,100)	:DEFAULT TO $A 256 DISPATCHER PORTS
	DEFAULT(NSP,180)	:DEFAULT TO $A 384 SUP PORTS FOR SUP NODE

:	NETID MUST BE SPECIFIED IN TYMFILE
	IF	\NETID
	ELSE	:NETID NOT DEFINED
	REMARK	%
	REMARK	%****************************************ARK	%!! NETID MUST BE SPECIFIED IN TYMFILE !!
	REMARK	%****************************************
	REMARK	%
	KILLER(1)		:KILL ASSEMBLY!!
	EI	:\NETID

	IF	EXPSEC
	IF	ISIS
XGGER1	ERRCNT
	XGG
XGGER2	ERRCNT
	IF	XGGER2-XGGER1
	REMARK	%
	REMARK	%****************************************
	REMARK	%!!!! XGG MACRO ERROR !!!!!!!!!!!!!!!!!!!
	REMARK	%!!!! GOODGUY LIST MUST BE PROVIDED !!!!!
	REMARK	%****************************************
	REMARK	%
	EI	:XGGER2-XGGER1
	EI	:ISIS

	IF	XGGCNT
	ELSE	:XGGCNT
	REMARK	%
	REMARK	%*****************************************
	REMARK	%!!!!! NO XRAY GOODGUY LIST PROVIDED !!!!!
	REMARK	%*****************************************
	REMARK	%
	EI	:XGGCNT
	EI	:EXPSEC

	DEFAULT(NLINES,$A 16)	:DEFAULT NUMBER OF NETWORK SYNC LINES TO 16
:	NOTE THAT THIS DEFINES LINES, NOT LINKS. ALSO BEWARE THAT
:	CODE COMPUTES NLINES = NLINES + SILINS , CAUSING THE VALUE
:	OF NLINES TO BE RE-COMPUTED IN THE CODE IF SILINS <> 0.

	IF	\MICRO
	IF	(2-MICRO)		:MICRO 0 OR 1
	REMARK	%>>> MICRO = 0, AND MICRO = 1 NOT SUPPORTED!!!!!! <<<
	REMARK	%>>> CHANGE TYM-FILE IF YOUR MACHINE CAN RUN SYNC <<<
	REMARK	%>>> E N H A N C E D !!!!!!!!!!!!!!!!!!!!!!!!!!!! <<<%
	KILLER(1)		:kill assembly
	EI	(2-MICRO)
	ELSE	:NOT \MICRO
MICRO	EQ	2		:DEFAULT, AND ONLY ACCEPTABLE VALUE
	EI	(\MICRO)

EASYNC	EQ	1		:NO OTHER LEGAL VALUES
ESYNC	EQ	1
	IF	STRHUB&STRRMT
KILLIT	EQ	1
	KILLER(1)
	EI

	IF	ISIS
:	FOR ISIS NODES, SILINS MUST BE SPECIFIED IF SIO REQUIRED.
:	THE STAND-ALONE COMPUTES SILINS BASED ON M.DAx AND M.NPx,
:	AND MUST THEREFORE HAVE SILINS INITIALIZED TO 0.
	DEFAULT(SILINS,0)	:ISIS NODE, NO SIO SUPPORT

	IF	T2GATE		:For T2 Gateway use sync logical units
NLINES	EQ	T2SYLU		:###EV
	ELSE
NLINES	EQ	NLUS0-SILINS	:NUMBER OF SYNC LINES, TEMPORARILY
	EI	:T2GATE
:	(SEE RE-DEFINITION OF NLINES BELOW TO REFLECT TOTAL NETWORK PORTS)
	ELSE	:NOT ISIS
	IF	\SILINS
	REMARK %SILINS COMPUTED FROM M.DAx, M.NPx%
	EI	(\SILINS)
SILINS	EQ	0	:INIT FOR SILINS COMPUTATION

	IF	\M.NP0
	IF	(1-ESYNC)
	REMARK %%***** SIO LINES REQUIRE MICROCODE LEVEL 2 *****%%
	EI	(1-ESYNC)
Q	EQ	0
	RE	0A		:MAX 10 SIO BOARDS
	IF	\M.NP|Q|
SILINS	EQ	SILINS+M.NP|Q|
	EI	(\M.NP|Q|)
Q	EQ	Q+1
	ER
	EI	(M.NP0)

	EI	(ISIS)

:	SIBFRL: SIO BUFFER RELOCATION
:	FOR 12 SIO LINES OR LESS NO SIO BUFFER RELOCATION IS REQUIRED.
:	FOR MORE THAN 12 SIO LINES, DEFAULT SIO BUFFER RELOCATION ON.
	IF	($A13-SILINS)
	DEFAULT(SIBFRL,0)	:12 SIO OR LESS - BUFFER RELOCATION OFF	###wjl
	ELSE	:NOT ($A13-SILINS)
	DEFAULT(SIBFRL,1)	:MORE THAN 12 SIO - RELOCATION ON	###wjl
	EI	:($A13-SILINS)

:	SYNLNA:	FW WITH 1-BIT FOR EACH SYNC LINE GEN'D

Q	EQ	0
SYNLNA	EQ	0
	IF	NLINES
	RE	NLINES
SYNLNA	EQ	SYNLNA+(80000000^Q)
Q	EQ	Q-1
	ER	:NLINES
	EI	:NLINES

NLINES	EQ	NLINES+SILINS	:NLINES = TOTAL NUMBER OF NETWORK PORTS
:::
LNSIZE	EQ	(((NLINES-1)/20)+1)*4  :SIZE OF ARRAY IN BYTES
	IF	0:DUMMY TONY1 CODE ##AL
	IF	(NLINES-MAXLIN)	:CHECK IF EXCESSIVE TOTAL LINES
KILLIT	EQ	1		:KILL ASSEMBLY, TOO MANY LINES.
	REMARK	%
	REMARK	%********************************************
	REMARK	%!!!! TOO MANY LINES CONFIGURED - 
	NUMBER	$ANLINES
	REMARK	D    !!!!
	REMARK	%!!!!   
	NUMBER	$AMAXLIN
	REMARK	D IS MAXIMUM NUMBER OF LINES   !!!!
	REMARK	%!!!!            FATAL ERROR             !!!!
	REMARK	%********************************************
	REMARK	%
	EI	:(NLINES-MAXLIN)
	EI	:TONY1

	IF	SILINS
	ELSE
	IF	STRHUB!STRRMT
	REMARK	%Tymstar configurations must use SIO lines
	REMARK	%********** CONFIGURATION ERROR **********
	KILLER(1)
	EI	:STRHUB!STRRMT
	EI	:SILINS

	IF	STRHUB!STRRMT		:RANGE CHECK ON STARLINES
Q	EQ	0
	RE	NLINES
	IF	\NSTR|Q|
	  IF	((NLINES-SILINS)-Q)
	REMARK	%**************************************************
	REMARK	%
	REMARK	%STARLINE number 
	NUMBER	$A Q
	REMARK	 is NOT within range of SIO lines%
	REMARK	%
	REMARK	CONFIGURATION ERROR  !!!!
	REMARK	%
	REMARK	%**************************************************
	  EI			:((-)-||)
	EI			:\||
Q	EQ	Q+1
	ER
	EI			:!


NLINEW	EQ	$A (NLINES+31)/32	: Number of words of bits to reserve

SBASE	EQ	2*(NLINES-SILINS)	:2*FIRST SIO LINE, RELATIVE

	DEFAULT(DB.CPU,0)	:DEFAULT EXEC LOOP DISPATCH-DISMISS TRACE OFF
	DEFAULT(DSPCNT,0)	:DEFAULT TO NOT TRACK DISPATCH COUNTS
				:(USED WITH DB.CPU ONLY)		###OAS
	DEFAULT(DB.CLK,0)	:DEFAULT EXEC LOOP TIME TRACE OFF 
				:(USED WITH DB.CPU ONLY)		###OAS
	DEFAULT(DSPTRC,0)	:DEFAULT DISPATCH ADDRESS AND COUNT TRACE OFF
				:(USED WITH DB.CPU ONLY)		###OAS
	IF	1-DB.CPU	:force DB.CPU-related parameters off if
DSPCNT	EQ	0		:	DB.CPU is not set
DB.CLK	EQ	0
DSPTRC	EQ	0
	EI	:DB.CPU

	DEFAULT(XLINKS,0)	:DEFAULT TO 0 XLINKS
	DEFAULT(STRXLK,0)	:Starlink Xlinks
	DEFAULT(STXKWZ,0)	:Starlink Xlinks window-size
	DEFAULT(DB56KB,0)	:DEFAULT TO 56KB DEBUG OPTION OFF
	DEFAULT(MACERR,0)	:MAC ERROR RECOVERY NOT ENABLED
	DEFAULT(INFLGT,0)	:DEFAULT TO INFINITE LOGON TIMER NOT ENABLED
	DEFAULT(NXUBLK,3)	:DEFAULT TO 4 CONCURRENT REMOTE XRAY USERS SUPPORTED
	DEFAULT(MEMRMK,0)	:NO SPECIAL MEMORY REMARKS

DB56KB	EQ	0		:OBSOLETE, FORCE OFF

NXUBLK	EQ	NXUBLK+1	:ADD 1 FOR TTY ACCESS
	IF	(2-NXUBLK)	:NO REMOTE XRAY ACCESS.
	REMARK	%***NO REMOTE XRAY PORTS DEFINED (NXUBLK < 1)***%
	EI	(2-NXUBLK)
	IF	(NXUBLK-0F)	:NO MORE THAN 15d XRAY USERS TOTAL
	REMARK	%***NXUBLK TOO LARGE, HAS BEEN RESET TO MAX VALUE (14d)***%
NXUBLK	EQ	0F
	EI	(NXUBLK-0F)

SUPER	EQ	MACHNM%400	:SUPER # (IF APPLICABLE)

	IF	(SUPER-7)
SUPER	EQ	0		:NOT A SUP NODE
	ELSE	:(SUPER-7)						###cwc
:NOSEG	EQ	0		:force NOSEG off if it's a Sup node	###cwc
	EI	(SUPER-7)

 IF	(1-\KNRING)
  IF	(1-ISIS)
   IF	SUPER
KNRING	EQ	1	:DEFAULT TO KERNEL NEGATIVE INDEXED RING	###OAS
   ELSE	:NOT SUPER
KNRING	EQ	0	:DEFAULT TO KERNEL NEGATIVE INDEXED RING	###OAS
   EI	:SUPER
  ELSE	:ISIS
KNRING	EQ	0	:NORMAL RING HANDLING FOR ISIS
  EI	(1-ISIS)
 EI	(1-\KNRING)


	IF	\SRING
SNRING	EQ	SRING		:SUP DEFINES SNRING INTERFACE W/ SRING VALUE.
	EI	(\SRING)	:INSURE CONSISTENT CONFIGURATION.

	DEFAULT(SNRING,1)	:DEFAULT TO SUP NEGATIVE RING		###OAS
	DEFAULT(SIORNG,0)	:DEFAULT TO NO SPLIT CONFIGURATION (SIO RING)

	IF	SIORNG
KNRING	EQ	1		:NEGATIVE INDEXING FOR SIO RING
SNRING	EQ	1		:SUP NEGATIVE INDEXED RING ALSO
KIOAR   EQ      0F0000          :assign maximum amount of bufferlets    ###sdw
	EI	:SIORNG

:	INSURE VERSION 15 INITIALIZATION FILE USED...
Q	EQ	0	:Q WILL GET SET IF OLD INITIALIZATION FILE
 IF	(1-\INITVR)
Q	EQ	1
 ELSE		:INITVR DEFINED. TEST FOR PROPER VERSION
  IF	($8INITVR%17)
Q	EQ	1
  EI	($8 INITVR%17)
 EI	(1-\INITVR)
	IF	Q
	REMARK %* Must use TII05.I00 initialization file! *%
	KILLER(1)		:kill assembly 
	EI	:Q

	DEFAULT(NACARD,0)		:DEFAULT TO NO ASYNC CARDS
	DEFAULT(NAPORT,0)
	DEFAULT(NAPRT2,0)

	DEFAULT(NEWALI,0)
	DEFAULT(BUBLAB,0)		:NOT IN BUBB-NET LAB ENVIRONMENT
	DEFAULT(WHEREE,0)
	DEFAULT(RESHST,0)		:NO RESTRICTED HOSTS
	DEFAULT(PVC,0)

	IF	(SOLOCS)
NACARD	EQ	(NAPORT+1F)/20  :allow odd # groups for microengine	###jhl
	DEFAULT(ASYNDA,0C1)		:ASYNC CARDS START AT DEVICE 0C1
	DEFAULT(ASYNCT,1)		:ASYNC TRACE DEBUG OPTION
	EI	:(SOLOCS)

:	THE CODFLT (CRASH OPTION DEFAULT) MACRO SETS THE SYMBOL
:	C.xxxx TO 1 IF THE OPTION IS TRUE, ELSE SETS IT TO 0. THE xxxx
:	MNEMONIC VALUE IS BASED ON THE COMMON CRASH ACTION DEFINITIONS.


	CODFLT(NRSH)
	CODFLT(NRSS)
	CODFLT(NHTH)
	CODFLT(NHTS)
	CODFLT(NBTH)
	CODFLT(NBTS)
	CODFLT(NSTH)
	CODFLT(NSTS)

:	IF NO HARDWARE OPTION DEFINED, DEFAULT TO NRSH
	IF	(1-(C.NHTH+C.NBTH+C.NSTH))
C.NRSH	EQ	1		:RESTART ON HARDWARE CRASH
	EI	(1-(C.NHTH+C.NBTH+C.NSTH))

:	IF NO SOFTWARE OPTION DEFINED, DEFAULT TO NRSS
	IF	(1-(C.NHTS+C.NBTS+C.NSTS))
C.NRSS	EQ	1		:RESTART ON SOFTWARE CRASH
	EI	(1-(C.NHTS+C.NBTS+C.NSTS))

	IF	((C.NRSH+C.NHTH+C.NBTH+C.NSTH)-1)
	REMARK %ERROR - MULTIPLE HARDWARE CRASH OPTIONS DEFINED!%
	KILLER(1)		:kill assembly
	EI	((C.NRSH+C.NHTH+C.NBTH+C.NSTH)-1)

	IF	((C.NRSS+C.NHTS+C.NBTS+C.NSTS)-1)
	REMARK %ERROR - MULTIPLE SOFTWARE CRASH OPTIONS DEFINED!%
	KILLER(1)		:kill assembly
	EI	((C.NRSS+C.NHTS+C.NBTS+C.NSTS)-1)

:	SET UP CRASH HANDLING OPTION.  VALUE OF CRSTOP DETERMINES THE ACTION
:	TAKEN ON HARDWARE (MAC, ILLEGAL INST) AND SOFTWARE ( JAL R0,OOPS)
:	CRASHES. THE UPPER BYTE OF CRSTOP IS FOR HARDWARE, THE LOWER FOR
:	SOFTWARE. THE CODES ARE:
:		0	=>	RESTART
:		1	=>	STOP NODE CODE, LEAVE XRAY ON
:		2	=>	DISABLE WATCHDOG TIMER AND DO BOOT SVC
:		3	=>	HALT MACHINE, TURN WAIT BAR ON

HLTNOD	EQ	3
DOBOOT	EQ	2
STOPLK	EQ	1
RSTRT	EQ	0

	DEFAULT(CRSTOP,0000)	:DEFAULT TO RESTART IN ALL CASES


	IF	(C.NHTH)
CRSTOP	EQ	(CRSTOP&0FF)+0300
	EI	(C.NHTH - HALT ON HARDWARE CRASH)

	IF	(C.NBTH)
CRSTOP	EQ	(CRSTOP&0FF)+0200
	EI	(C.NBTH - BOOT ON HARDWARE CRASH)

	IF	(C.NSTH)
CRSTOP	EQ	(CRSTOP&0FF)+0100
	EI	(C.NSTH - STOP ON HARDWARE CRASH)

	IF	(C.NHTS)
CRSTOP	EQ	(CRSTOP&0FF00)+03
	EI	(C.NHTS - HALT ON SOFTWARE CRASH)

	IF	(C.NBTS)
CRSTOP	EQ	(CRSTOP&0FF00)+02
	EI	(C.NBTS - BOOT ON SOFTWARE CRASH)

	IF	(C.NSTS)
CRSTOP	EQ	(CRSTOP&0FF00)+01
	EI	(C.NSTS - STOP ON SOFTWARE CRASH)

	DEFAULT(RPTHCE,2)	:REPORTING THRESHOLD FOR CIRCUIT ERRORS

	IF	\NBFLET
	KILL	NBFLET		:PREVENT OLD TYM FILE OPTION FROM LIVING
	GL	NBFLET
	EI	(\NBFLET)

:	COMPUTE MAXIMUM NUMBER OF LINKS
NLINKS	EQ	XLINKS+STRXLK	:START WITH NUMBER OF WILD CARD LINKS
Q	EQ	0
:	FOR EACH LINK DESCRIPTOR DEFINED, INCREMENT NUMBER OF LINKS
	RE	MAXLNK
	IF	\NEI|$AQ|
NLINKS	EQ	NLINKS+1
	ELSE
NLINKS	EQ	NLINKS
	EI	:(\NEI|$AQ|)
Q	EQ	Q+1
	ER
	if	al1
NPTHR	EQ	20*NLINKS	:UPDATE NPTHR TO 32 PER LINK		###AL
	ei
:Now for Starhub machines, give StarXlinks a dummy Key
	IF	STRHUB
Q	EQ	(NLINKS-XLINKS)-1
	IF	STRXLK
	RE	STRXLK
	DEFAULT(K.S|$A Q|,$0 0FFFFFFFF)
WSIZ|$A Q|	EQ	STXKWZ	:REDEFINE WSIZ FOR STRXLK		###AL
Q	EQ	Q-1
	ER
	EI	:STRXLK
	EI	:STRHUB


NLINKW	EQ	$A (NLINKS+31)/32	: Number of words needed for bits
:::
LKSIZE	EQ	(((NLINKS-1)/20)+1)*4	:SIZE OF ARRAY IN BYTES

:	TEST FOR KERNEL=1 AND MICRO=1	STOP ASSEMBLY IF TRUE.
	IF	KERNEL		:... AND KERNEL SELECTED
	IF	(MICRO*(2-MICRO))	:IE MICRO=1
	REMARK	%*** KERNEL MUST NOT BE SELECTED WITH MICRO=1 ***%
	KILLER(1)		:kill assembly
	EI	(MICRO=1)
	EI	:KERNEL


 IF	(1-T2GATE)		:Not used for gateway
 IF	(1-\KIOAR)
  IF	(1-ISIS)
   IF	(1-\NBRK)
	REMARK %NBRK not defined, assuming 256d KB%%
NBRK	EQ	$A 256
   EI	(1-\NBRK)
   IF	(NBRK&3F)
	REMARK %%Warning - NBRK not a multiple of 64d!%
   EI	(NBRK&3F)
:	MEMAVL DEFINES THE AMOUNT OF MEMORY AVAILABLE FOR THIS CONFIGURATION
MEMAVL	EQ	(NBRK*400)-(10000-0F000)	:ALLOW ROOM FOR RELOCATED BOOT
  ELSE	:ISIS
MEMAVL	EQ	S0CORE*400
  EI	(1-ISIS)
 ELSE	:\KIOAR
MEMAVL	EQ	KIOAR
 EI	(1-\KIOAR)
 EI	:(1-T2GATE)

	IF	T2GATE
MEMAVL	EQ	MEMORY*400		:Gateway MUST define MEMORY IN Tymfile
	EI	:T2GATE

:	DEFINE THE NUMBER OF CONSECUTIVE OCCURRENCES OF FOUR SECONDS
:	WITH NO RECORDS RECEIVED IN A LINE, WHICH IS ALLOWED BEFORE
:	DETACH IS TAKEN.	###LH

	DEFAULT(LNCKTM,4)	:DEFAULT TO 4 IF NOT DEFINED IN TYMFILE

	IF	SUPER
KERNEL	EQ	1		:IF SUP BASE, GOT A KERNEL
	EI	:SUPER

	IF	SUPER
	IF	\HST0
Q	EQ	$A 120+SUPER
	IF	(Q%HST0)	:BITCH IF HST0 INCORRECT FOR SUP NODE...
	REMARK %** SUP HOST NUMBER SPECIFIED INCORRECTLY - 
	REMARK SETTING TO $A 
	NUMBER $A Q
	REMARK  **%
	EI	(Q%HST0)
	EI	(\HST0)

HST0	EQ	$A 120+SUPER	:SET HOST NUMBER FOR SUPERVISOR

	ELSE	:NOT SUPER
	DEFAULT(HST0,MACHNM-$82000+$A520)
	EI	:SUPER

	IF	T2GATE		:Gateway uses a specified or default
	IF	\HHOST		:for Network host number
HST0	EQ	HHOST	:If specified, it can be either as HHOST
	ELSE	: (use HST0, either specified or default)  <<<--- OR
HHOST	EQ	HST0	:as HST0.
	EI	:\HHOST
	EI	:T2GATE

NSP	EQ	NSP*SUPER/SUPER		:NO LIMITS TO NSP		###GT
	IF	(NSP&1F)
	REMARK	%>>WARNING - NSP not a multiple of 32d!!<<%
	EI	:(NSP&1F)

	IF	ISIS

	IF	MXPNM		:ISIS-MXP SUPPORT
NUSLT	EQ	NMACH*$A16	:# SLOTS = # MACHINES * 16		###GT
	ELSE			:DEFINE A NEW SYMBOL FOR # SLOTS	###GT
	IF	1-T2GATE		:###EV
NUSLT	EQ	NSLOT		:OLD ISIS
	EI	:1-T2GATE		:###EV
	EI	:MXPNM

	IF	(1-SUPER)
SUPNKU	EQ	0	:0 SUP KERNEL USERS IF NO SUPERVISOR
	EI	(1-SUPER)
	IF	T2GATE		:###EV
NKU	EQ	0		:T2 Gateway has no kernel ports
NSLOT	EQ	0		:Nor does Gateway have slots!
	ELSE
NKU	EQ	1+NSLOT+SUPNKU	:# OF KERNEL USERS
	EI	:T2GATE		:###EV
	ELSE	:NOT ISIS
	DEFAULT(NKUSUP,20)	:DEFAULT NUMBER OF KERNEL PORTS
				:ONLY USED FOR STANDALONE SUPS OR SPLIT SUPS
	IF	SOLOCS
	IF	NPAPRT
NKU	EQ	20		:channel range for CRQ to notify CONSAT of
				:	needle for addressable port	###jhl
	ELSE	:1-NPAPRT
NKU	EQ	20*KERNEL/KERNEL
	EI	:NPAPRT
	ELSE	:1-SOLOCS
	IF	SUPER
NKU	EQ	NKUSUP*KERNEL/KERNEL
	ELSE	:SUPER
NKU	EQ	20*KERNEL/KERNEL
	EI	:SUPER
	EI	:SOLOCS
	EI	:ISIS

:###JHL--THESE CODES UNUSED AS OF (BEFORE) REL 502
:	DEFINE VALUES TO IDENTIFY NODE FAULTS. THE VALUE WILL BE STORED
:	IN 'CRSHAD', AND IS USED AS THE ADDRESS PORTION OF A HALT PSW.
F.MMAL	EQ	84	:MACHINE MALFUNCTION - OLD PSW @ LOCATION 20
F.ILDV	EQ	86	:ILLEGAL DEVICE INTERRUPT - DEVICE ADDRESS IN R2
F.ILNS	EQ	88	:ILLEGAL INSTRUCTION - PSW IN R14, R15
F.MACI	EQ	8A	:MAC INTERRUPT - MAC STATUS STORED @ 'SMACSV'
F.POWU	EQ	8C	:POWER UP INTERRUPT
F.DMAT	EQ	8E	:DMA TIMEOUT INTERRUPT
F.ILXX	EQ	90	:ILLEGAL INSTRUCTION, 

:	CODES TO IDENTIFY VARIOUS CRASH CAUSES. THESE VALUES ARE STORED
:	INTO THE 'CRSHID' FIELD, AND ALSO INTO THE 'ANHALT' FIELD. THE
:	LATTER SERVES AS A FLAG BETWEEN THE PRIVILEGED CODE AND XRAY TO
:	INDICATE WHEN THE NODE CODE HAS UNDERGONE A TRAUMATIC CRASH

SLEEPF	EQ	2		:OPERATOR-HALTED
OUTWTF	EQ	2		:OUTPUT WAIT
ILLERF	EQ	4		:ILLEGAL INSTRUCTION
DMATOF	EQ	5		:DMA TIMEOUT
MACNTF	EQ	8		:MAC INTERRUPT
MALNTF	EQ	20		:MACHINE MALFUNCTION INTERRUPT
ABSNTF	EQ	80		:NO SUCH PROCESS
PWFLF	EQ	1		:POWER FAIL

NMACR	EQ	0F		:# OF MAC REGISTERS IN USE
MRN	EQ	10-NMACR	:FOR MULTIPLE LOAD/STORE OF MAC REGS

	IF	KERNEL
VPHYS	EQ	1400		:START OF PRIVILEGED CODE (ALLOWS SPACE
:	FROM LOCATIONS 700-12FF FOR VERSION 3 LBOOT TO RESIDE, 1300-13FF
:	FOR  KERNEL INTERRUPT ROUTINES)
	ELSE	:NOT KERNEL
VPHYS	EQ	700		:START OF PRIV CODE FOR NON-KERNEL SOLO NODE
	EI	:KERNEL

::*********************************************************************
::
::	NR.###:	DEFINE VALUES TO IDENTIFY NODE REPORTS TO SUPERVISOR.
::	NODE REPORTS ARE THE 'REPORT TO SUPERVISOR'S LOG' MESSAGE, TYPE 1280.
::	THE NODE REPORT CONTAINS 3 HALFWORDS OF DATA.  THE FIRST
::	HALFWORD IS THE NODE REPORT MESSAGE TYPE, DEFINED AS FOLLOWS:
::
::*********************************************************************

NR.CHU	EQ	1		:CHANNEL IN USE
NR.UAC	EQ	2		:DATA ON UNASSIGNED CHANNEL
NR.BFZ	EQ	3		:BUFFER ZAP
NR.RLK	EQ	4		:RESPONSE TO REMOVE NEIGHBOR COMMAND
NR.ALK	EQ	5		:RESPONSE TO ADD NEIGHBOR COMMAND
NR.BUB	EQ	6		:LINK BUBBLE
NR.SHK	EQ	7		:LINK SHRINK
NR.NPT	EQ	8		:OUT OF PERMUTER TABLE SPACE
NR.NKD	EQ	9		:OUT OF LINK SPACE FOR NEW LINE ATTACH
NR.PLI	EQ	0A		:NUMBER CIRCUITS ZAPPED DUE TO LINK OUT
NR.ODP	EQ	0B		:NODE OUT OF DISPATCHER PORTS
NR.NRJ	EQ	0C		:NEEDLE REJECTED BY SLOT
NR.HIM	EQ	0D		:HOST IS IMPOSTER, DETECTED BY NODE CODE
NR.CTM	EQ	0E		:REPORT CIRCUIT LIFETIME (IN SECONDS) FOLLOWING
				:CHANNEL IN USE REPORT
NR.SNP	EQ	0F		:LINK SNIP - NEIGHBOR SPLIT CHARACTER PAIR OR
				:SENT INVALID CHANNEL NUMBER IN PACKET
NR.DGN	EQ	10		:GENERAL DIAGNOSTIC NODE REPORT - FIRST BYTE OF
				:HW2 CONTAINS SUB-TYPE
NR.NNE	EQ	11		:NEEDLE BOUND FOR NEIGHBOR NOT FOUND
NR.XMN	EQ	12		:INVALID NODE NUMBER ON COMMAND CIRCUIT MESSAGE
NR.XCM	EQ	13		:INVALID COMMAND TYPE ON COMMAND CIRCUIT
NR.NCE	EQ	14		:CIRCUIT BUILDING ERRORS DETECTED
NR.CKC	EQ	15		:CIRCUIT BUILDING CONSISTENCY ERRORS
NR.LFR	EQ	16		:LINK FROZEN
NR.LTH	EQ	17		:LINK THAWED
NR.CCZ	EQ	18		:COUNT OF CMD CRCUITS ZAPPED DUE TO LINK OUTAGE
NR.CRP	EQ	19		:NODE CRASH REPORT
NR.SSX	EQ	1A		:REPORT # SIO, SYNC, XLINKS, NLINKS
NR.PPT	EQ	1B		:REPORT # PORTS, PASSTHROUGHS
NR.UNL	EQ	1C		:REPORT UNUSED LINES
NR.LNR	EQ	1D		:LINE/LINK REPORT (INSTEAD OF SYNPRT)
NR.SML	EQ	1E		:SLOT REPORT LIMIT EXCEEDED
NR.INH	EQ	1F		:INVALID HOST ON RESTRICTED HOST NODE
NR.CLE	EQ	20		:SLOT/HOST CIRCUIT LIMIT EXCEEDED
NR.DLD	EQ	21		:COUNT OF CIRCUITS ZAPPED DUE TO DLOAD COMMAND
NR.I3C	EQ	22		:INVALID 03-CHAR PAIR ON COMMAND CIRCUIT
NR.MAC	EQ	23		:NODE TOOK MAC INTERRUPT AND RECOVERED
NR.K56	EQ	24		:56KB DIAGNOSTIC - SIO TIMEOUT ON OUTPUT
	IF	SOLOCS
NR.SBR	EQ	25		:TYMSAT DIAGNOSTIC: DATA ON DISABLED ASYNC PORT
	EI	:SOLOCS
NR.T13	EQ	26		:INVALID 03-CHAR PAIR ON T-I COMMAND CIRCUIT
NR.T1L	EQ	27		:T-I SUP RECORD WITH INVALID LENGTH
NR.DMA	EQ	28		:MAC INTERRUPT CASED BY DMA HARDWARE TIMEOUT
NR.KZF	EQ	29		:KERNEL PORT ZAP SVC GAVE NON-SKIP RETURN
NR.CR1	EQ	2A		:FIRST ADDENDUM TO CRASH REPORT, CRASH ID
NR.CR2	EQ	2B		:2ND ADDENDUM TO CRASH REPORT,REGISTER CONTENTS
NR.HVR	EQ	2C		:REPORT KERNEL HOST NUMBER AND VERSION NUMBER
NR.SQF	EQ	2D		:SQFIX ERROR. HW1=BUFFER, HW2=COUNT
NR.TMP	EQ	2E		:TEMPERATURE EXCEEDS DESIRABLE RANGE
				:(OR IS BELOW ACCEPTABLE).		###JHL
NR.NID	EQ	2F		:NETID mismatch for potential new link	###wjl
NR.WSZ	EQ	30		:WSIZ match down for new link		###wjl
NR.XID	EQ	31		:XRAY NETID change for new link		###wjl
NR.RRF	EQ	32		:STARLINK Remote Reset Failure		###ev
NR.ARW	EQ	33		:Async Ring Wrap			###wjl

:	DEFINE SUB-TYPES FOR GENERAL DIAGNOSTIC NODE REPORT (NR.DGN)

DR.SYM	EQ	0		:SYNC SCAN INSTRUCTION TOOK NON-SKIP RETURN
:	INDICATING 'START BIT' FOUND IN SYNC RING, BUT MEMORY POINTED TO
:	BY INDEX REGISTERS (R11 & R13) CONTAINED ALL ONES.  SECOND BYTE
:	OF HW2 HAS 2*LINE NUMBER, HW3 HAS R13 (SYNC RING BASE INDEX,
:	OFFSET INTO SEGMENT 0B).

DR.SIO	EQ	1		:SIO BUFFER LENGTH FIELD = 0 OR > 90,
:	SHOULD BE NEGATIVE UNTIL POSITIVE COUNT STORED BY MOTHER
:	BOARD.  SECOND BYTE OF HW2 HAS 2*LINE NUMBER, HW3 HAS NUMBER OF
:	OCCURRENCES.

DR.SZC	EQ	2	:TIMEOUT ON M-BOARD WHILE ATTEMPTING CONNECT.
:	SECOND BYTE OF HW2 = LINE NUMBER, HW3= NEIGHBOR NUMBER (+8000 IF UP)

DR.SZI	EQ	3	:IDENTICAL TO DR.SZC FOR INPUT TIMEOUT
DR.SZO	EQ	4	:IDENTICAL TO DR.SZC FOR OUTPUT TIMEOUTS
DR.SZS	EQ	5	:IDENTICAL TO DR.SZS FOR STATUS SVC TIMEOUTS

:	THE FOLLOWING MESSAGE TYPES ARE FOR REPORTING LINE DIAGNOSTICS.
:	THE FIRST 16 BITS ARE OF THE FORMAT TTLL, WHERE TT IS THE
:	MESSAGE TYPE, AND LL IS THE LINE NUMBER FOR WHICH THE DIAGNOSTIC
:	REPORT IS BEING MADE.

LL	EQ	0		:VALID VALUES ARE 0 - NLINES-1

NR.SRT	EQ	8000+LL		:TOTAL PACKETS SENT AND RECEIVED
NR.BRI	EQ	8100+LL		:# OF BAD BORI'S
NR.ACK	EQ	8200+LL		:# OF BAD ACKS
NR.RCN	EQ	8300+LL		:# OF BAD RECORD NUMBERS
NR.CHS	EQ	8400+LL		:# OF CHECKSUM ERRORS
NR.RTR	EQ	8500+LL		:# OF RETRANSMISSIONS RECEIVED
NR.RTS	EQ	8600+LL		:# OF RETRANSMISSIONS SENT
NR.4SG	EQ	8700+LL		:# OF 4-SECOND GAPS W/ NO GOOD RECORDS RECEIVED
NR.CRS	EQ	8800+LL		:# OF CROSS-TALK ERRORS
NR.SPC	EQ	8900+LL		:# OF TIMES SPACING DETECTED ON INPUT
NR.HCK	EQ	8A00+LL		:# OF SIO HDLC CHECKSUM ERRORS
NR.HAB	EQ	8B00+LL		:# OF SIO HDLC ABORTS

:	DEFINE SYMBOLS TO IDENTIFY ISIS SVC'S
	IF	ISIS		:###wjl
DISMIS	EQ	0		:dismiss
FAST	EQ	1		:fast dismiss
SYS	EQ	2		:system
IO	EQ	3		:I/O control
	EI	:ISIS

	SUBTTL	SHARE (Solo Low Core Assignments)

	IF	(1-ISIS)		:>>NOT ISIS - TO END OF MODULE<<

:	LOW CORE ASSIGNMENTS

::*********************************************************************
::
::	ORG	0:
::
::*********************************************************************

:	>>START MEMORY<<

	ORG	0
:	SPECIAL VALUES ARE MAINTAINED IN LOW MEMORY TO ASSIST IN DUMP
:	ANALYSIS AND FIELD TROUBLESHOOTING.
	HC	0		:00 - ALWAYS 0
	HC	MACHNM		:02 - NODE NUMBER
	HC	VERSION		:04 - NODE CODE VERSION #
	GL	VERSION
	HC	S0PH		:06 - SEGMENT 00 PHYSICAL ADDRESS
	GL	S0PH
	IF	1-NOSEG
	HC	S0SZ		:08 - SEGMENT 00 SIZE (S0PH+S0SZ=S1PH)
::	CHANGE TO FULL WORD TO SKIP SEG0 OVERFLOW ASSEMBLY ERR ##AL
:	WC	S0SZ		:08 - SEGMENT 00 SIZE (S0PH+S0SZ=S1PH)
	GL	S0SZ
	ELSE	:NOSEG
	HC	0
	EI	:1-NOSEG##AL
	IF	1-NOSEG
	HC	SBPH		:0A - SEGMENT 0B PHYSICAL ADDRESS
	GL	SBPH
	ELSE	:NOSEG
	HC	0
	EI	:1-NOSEG##AL
	HC	CRSHAD		:0C - CRASH POINTER SEGMENT 0 ADDRESS
	GL	CRSHAD
	HC	CRYPRI		:0E - CRYPTO INDEX SEGMENT 0 ADDRESS
	GL	CRYPRI
	HC	ILIPSW		:10 - ILLEGAL INSTRUCTION PSW SEG 0 ADDRESS
	GL	ILIPSW
	HC	MACPSW		:12 - MAC INTERRUPT PSW SEGMENT 0 ADDRESS
	GL	MACPSW
	WC	S2PH		:14 - SEGMENT 02 PHYSICAL ADDRESS (FULLWORD)
	GL	S2PH
	WC	S6PH		:18 - SEGMENT 06 PHYSICAL ADDRESS (FULLWORD)
	GL	S6PH
	IF	1-NOSEG
	WC	SCPH		:1C - SEGMENT 0C PHYSICAL ADDRESS (FULLWORD)
	GL	SCPH
	ELSE	:NOSEG
	WC	0
	EI	:1-NOSEG##AL

::*********************************************************************
::
::	ORG	20:
::
::*********************************************************************

	ORG	20
MLOPSW	WC	0,0		:20 - MALFUNCTIONS OLD PSW
	WC	0,0		:28 - MUST BE ZERO

IINPSW	WC	0200,ILINST	:30 - ILL INSTRUCTION NPSW
MLNPSW	WC	0200,MALINT	:38 - MACHINE MALFUNCTION NPSW
	WC	0,0		:40 - MUST BE ZERO
AFNPSW	WC	8048,0BAD00	:48 - ARITH FAULT NPSW			###JHL

::*********************************************************************
::
::	ORG	50:
::
::*********************************************************************

	ORG	50
	HC	0D500,280	:50 LOAD SEQUENCE
	HC	4300,080

::*********************************************************************
::
::	ORG	6C:
::
::*********************************************************************

	ORG	6C
	WC	PHCRHD		:6C - POINTER TO START OF CRASH TABLE ###wjl
	GL	PHCRHD		:LOADII Crash Dump Option expects abs address

::*********************************************************************
::
::	ORG	70:
::
::*********************************************************************

	ORG	70
	J	SSTART		:70 - NORMAL START AND RUN
	J	SSTAR1		:74 - START X-RAY ONLY
	HC	294		:78 - LOAD SEQUENCE

::*********************************************************************
::
::	ORG	80:
::
::*********************************************************************

	ORG	80
	HC	0		:80 - SYS QUEUE ADDR
	HC	0		:82 - UNUSED
	HC	PFPSW		:84 - ADDR OF PWR FAIL PSW

	HC	PFREG		:86 - ADDR OF PWR FAIL REGISTERS

	WC	8200,88		:88 - SYS QUEUE NEW PSW
MCNPSW	WC	0200,SMACNT	:90 - MAC INT NPSW
	WC	4200		:98 - SVC NEW STATUS ASYNC INTERRUPTS ON
				:AND ESYNC MICROCODE. DOES THIS MAKE ANY
				:DIFFERENCE? ???###TZ

:	START OF SVC VECTORS
	RE 0F
	HC SVCXX		:9C - START OF SVC VECTORS
	NOLIST
	ER
	LIST
FSVCST	HC	SKSVC		:BA - '0F' SVC VECTOR START

::*********************************************************************
::
::	ORG	0D0:	I/O INTERRUPT PSW'S.
::	THE ENGINE COMPUTES THE INTERRUPT PSW AS 2*(DEVICE ADDRESS) + D0
::
::*********************************************************************

:	BASE OFFSETS FOR READING AND WRITING STATE ROUTINE PTRS
:	Use INTVEC (0D0) as base address if indexing by device #
:	Sync line 0 corresponds to device number x20 (Rcv) x21 (Xmt)
INTVRL	EQ	110		:BASE ADDRESS RECEIVE IF INDEXING BY LINE #
INTVXL	EQ	112		:BASE ADDRESS TRANSMIT BY LINE #

	ORG	0D0
INTVEC	HC	ILLDEV		:D0 - START OF INTERRUPT VECTORS
	HC	ILLDEV		:D2 - CONSOLE
	HC	TTYINT		:D4 - TELETYPE CARD
	RE	(1B0-.)/2	:D6 - UNUSED TO 1B0
	HC	ILLDEV
	NOLIST
	ER
	LIST

SYNST1	EQ	0BF	:24E device addr CONTROL REGISTER FOR FIRST SYNC CARD
SYNST2	EQ	0FF	:2CE device addr CONTROL REGISTER FOR SECOND SYNC CARD

:	ENGINES WITH ASYNC ENHANCEMENTS TAKE CLOCK INTERRUPTS
:	AT LPSW(R) -- NOT THROUGH VECTORS.

	RE 6
	HC	ILLDEV		:1B0 - 3600 baud interrupter
	NOLIST
	ER
	LIST
	RE	(2D0-.)/2	:1BC - REST INITIALIZED BY SSTART
	HC	ILLDEV
	NOLIST
	ER
	LIST

::*********************************************************************
::
::	ORG	300:	THE FOLLOWING REGION OF UNMAC'ED MEMORY IS FOR
::			ACCESSING THE MAC BOARD.
::
::*********************************************************************

	ORG	300
MACREG	WS	10	:MAC RELOCATION REGISTERS((300 TO 33F)
MACSTR	WS	1	:MAC STATUS REGISTER (HALFWORD AT 342)
MCNFTH	WS	1	:ADDRESS OF LAST FETCH (21 BITS -- UNMAC'ED)(344)
MCPARI	WS	1	:21 BIT ADDRESS OF PARITY ERROR(348)
MCFTCH	WS	1	:ADDRESS OF LAST FETCH (19 BITS -- MAC'ED)(34C)
	IF	ZITEL	:###JHL
MCTRCW	WS	1	:TRACE CTL WORD (MOST SIG 11 BITS)(350)
MCLTBD	WS	1	:LOWER TRACE ADDR BOUND(LOW ORDER 22 BITS)(354)
MCUTBD	WS	1	:UPPER TRACE ADDR BOUND(LOW ORDER 22 BITS)(358)
MCRGSS	WS	1	:MAC REG SET SELECT (LOW ORDER 4 BITS)(35C)
	ORG	380
MCTRBF	WS	20	:TRACE ADDRESS BUFFER (32 ADDRESSES)
:	NOTE--ADDRESSES WRITTEN HERE BY HW HAVE MSB SET--MUST BE STRIPPED.
	EI	:ZITEL	:###JHL

::*********************************************************************
::
::	ORG	400:	I/O CONTROL BLOCKS FOR SYNC LINES.
::
::	USED WITH ENHANCED SYNC MICROCODE ONLY.
::
::	STARTING AT LOC 400 THE ARE 32(DEC) AREAS OF TEN
::	BYTES EACH -- ONE FOR EACH SYNC LINE. THE FIRST
::	WORD POINTS TO THE INPUT RING. THE NEXT 1/2 WORD
::	CONTAINS THE NEGATIVE OUTPUT BYTE COUNT.
::	THE LAST WORD POINTS TO THE END OF THE OUTPUT
::	DATA.
::
::*********************************************************************

	IF	ESYNC

	ORG	400
SYLCTL	HS	0
	RE	20
	HS	5
	ER

SYLIDL	WC	-1	:INPUT RING ADR OF SYLIDL GIVES CONVENTIONAL INTS
	EI	:ESYNC

::*********************************************************************
::
::	ORG	600:	DATA SEGMENT 'E' DEFINITIONS
::
::*********************************************************************

	ORG	600		:PHYSICAL ADDRESS OF THIS SEGMENT
FASTC	WS	1		:FAST CLOCK (600/SEC)
	SYAD(FASTC ,1)
NRATE	WC	$A 600		:FASTC RATE/SEC (FOR SUP)
SLOWC	WS	1		:SLOW CLOCK (1/SEC)
HOSTX	HC	HST0
SNODEN	HC	MACHNM
MALADD	WC	MALPAR		:FOR THE KERNEL
PWFADD	WC	PREST
STIMEC	WS	1		:SLOWC CORRECTION FOR GMT
C3600	WS	1		:SUPERFAST CLOCK
KVERL	HS	1		:KERNEL VERSION LOCATION
PRESTA	HS	3		:KERNEL PRE-STATUS SAVE AREA

:	SUPER-KERNEL VARIABLES

:	INSURE THAT WE HAVEN'T OVERRUN LBOOT AREA. LBOOT ORG'S @ 700.
	IF	(.-700)
	REMARK %ASSEMBLED INTO LBOOT AREA%%
	EI	(.-700)

	SUBTTL	SHARE (Solo Privileged Code)

::*********************************************************************
::
::	ORG	VPHYS:	START OF PRIVILEGED CODE
::
::*********************************************************************

	ORG	VPHYS		:PRIVILEGED CODE BEGINS HERE

:	CURRENT 'USER' DISMISS ADRESS AND TIME SLICE STORED HERE

USRRET	HS	1		:ENTRY TO USER DISMISS ROUTINE
USRTIM	HS	1		:TIME-SLICE CLOCK

:	NODE USER BLOCK

ANFLGS	HS	1		:FLAGS - NODE CODE NOT RUN IF NONZERO
ANHALT	HC	-1		:NODE HALT FLAG IF POSITIVE
ANRSL	HC	ANRET,$A -24	:NODE DISM ADDR, TIME SLICE (SEC/600)

	IF	SOLOCS
ANIPSW	WC	6FF0,NSTART	:INITIAL PSW--ASYNC MICRO INSTRUCTIONS ENABLED
	GL	NSTART
ANCPSW	WC	6FF0,NSTART	:CURRENT PSW
	ELSE	:NOT SOLOCS
ANIPSW	WC	67F0,NSTART	:INITIAL PSW
ANCPSW	WC	67F0,NSTART	:CURRENT PSW
	GL	NSTART
	EI	:SOLOCS

	IF	SOLOCS
	IF	SVCCXT
ANSVCP	WS	2		:SVCPSW is part of context		###jhl
	EI	:SVCCXT
	EI	:SOLOCS
ANREG	WS	10		:ACTIVE REGISTERS
ANMACR	WC	ANMAC0		:MAC REGISTERS
	WC	ANMAC1,ANMAC2
	WC	ANMAC3,ANMAC4,ANMAC5,ANMAC6,ANMAC7
	WC	ANMAC8,ANMAC9,ANMACA,ANMACB,ANMACC
	WC	ANMACD,ANMACE,0
ANODMC	WC	ANMAC0		:BACKUP STORAGE FOR NODE MAC REGS
	WC	ANMAC1,ANMAC2
	WC	ANMAC3,ANMAC4,ANMAC5,ANMAC6,ANMAC7
	WC	ANMAC8,ANMAC9,ANMACA,ANMACB,ANMACC
	WC	ANMACD,ANMACE,0

	GL	ANMAC0		:BACKUP STORAGE FOR NODE MAC REGS
	GL	ANMAC1,ANMAC2
	GL	ANMAC3,ANMAC4,ANMAC5,ANMAC6,ANMAC7
	GL	ANMAC8,ANMAC9,ANMACA,ANMACB,ANMACC
	GL	ANMACD,ANMACE

:	X-RAY USER BLOCK...

AXFLGS	HS	1		:FLAGS -- XRAY DISABLED IF NONZERO
AXRSL	HC	AXRET,$A -3	:XRAY DISMISS ADDR, TIME SLICE

AXIPSW	WC	67F0,XRAY	:INITIAL PSW
	GL	XRAY
AXCPSW	WC	67F0,XRAY	:CURRENT PSW
	IF	SOLOCS
	IF	SVCCXT
AXSVCP	WS	2		:save area for SVCPSW		###jhl
	EI	:SVCCXT
	EI	:SOLOCS
AXREG	WS	10
AXMACR	WC	AXMAC0,AXMAC1,AXMAC2
	WC	AXMAC3,AXMAC4,AXMAC5,AXMAC6,AXMAC7
	WC	AXMAC8,AXMAC9,AXMACA,AXMACB,AXMACC
	WC	AXMACD,AXMACE,0

	GL	AXMAC0,AXMAC1,AXMAC2
	GL	AXMAC3,AXMAC4,AXMAC5,AXMAC6,AXMAC7
	GL	AXMAC8,AXMAC9,AXMACA,AXMACB,AXMACC
	GL	AXMACD,AXMACE

NRSPSW	WC	6FF0,SFAIL2	:RESTART PSW, ASYNC MICROCODE
:	INSTRUCTIONS ENABLED- BUG WAS CAUSING US NOT TO PUT HARDWRE
:	CRASHES IN CRYPTO LOG.###TZ
	GL	SFAIL2

:	KERNEL USER BLOCK

KRFLGS	HS	1		:FLAGS -- KERNEL DISABLED IF NONZERO
KRRSL	HC	KRRET,$A -12	:KERNEL DISMISS ADDR, TIME SLICE

:	DISMISS ADDRESS AND TIME SLICE FOR IDLING

IDRSL	HC	IDRET,-1		:IDLE DISMISS, TIME SLICE

:	SVC HANDLER VARIABLES:

SVCPSW	WS	2		:TEMP STORAGE FOR PSW
SVCCHR	WS	4		:DITTO FOR MISCELLANEOUS

:	SAVE CONTENTS OF ILLEGAL INSTRUCTION VECTOR, LOADER MAY HAVE CLOBBERED

ILPVEC	WC	0,ILINST

:	COMPUTE SIO DEVICE ADDRESSES

SIDEV	HS	0
R	EQ	0
	RE	0A		:MAX $A 10 SIO BOARDS
	IF	\M.NP|R|	:IF NUMBER OF PORTS FOR THIS BOARD DEFINED
	IF	(M.NP|R|)	:	AND NON-ZERO...
P	EQ	0
	RE	M.NP|R|	:DEFINE ADDRESS FOR EACH PORT THIS CARD
	HC	M.DA|R|+P
P	EQ	P+100
	ER
	EI	(M.NP|R|)
	EI	(\M.NP|R|)
R	EQ	R+1
	ER

:	TTY CARD ROUTINE VARIABLES:

TTYDA	EQ	2		:DEVICE ADDRESS OF TTY PORT
TVNBSZ	EQ	8		:SIZE OF INPUT BUFFER
TVNTBF	BS	TVNBSZ		:INPUT BUFFER
TVNTIP	HS	1		:INPUT BUFFER IN PTR
TVNTOP	HS	1		:DITTO OUT PTR
TVNTWC	HS	1		:CHAR TRANSMITTAL TIME

TXNBSZ	EQ	20		:SIZE OF OUTPUT BUFFER
TXNTBF	BS	TXNBSZ		:OUTPUT BUFFER
TXNTIP	HS	1		:OUTPUT BUFFER IN PTR
TXNTOP	HS	1		:DITTO OUT PTR

TTYIAD	HS	1		:ADDR OF INTERRUPT HANDLER
CARDLY	HS	1		:CARRIAGE RETURN DELAY CNT
	BC	0		:ENGINE REQUIRES OC FROM ODD LOC
TVNCLR	BC	0C4,0		:COMMAND TO CLEAR TTY INTS
TVNRCV	BC	064,0		:COMMAND TO SET RECEIVE MODE
TVNXMT	BC	058		:COMMAND TO SET TRANSMIT MODE
	HS	0

:	DATA AREA FOR TRAP SVC

TRPFLG	HS	1		:BIT ARRAY TELLS WHEN TRAP IS SPRUNG
TRPNXT	HS	1		:MOD 4 COUNTER STORED INTO TRPTIM
TRPSEQ	HS	4		:RECORDS ORDER THE TRAP WAS SPRUNG
TRPTIM	WS	4		:FASTC TIME TRAP WAS SPRUNG
TRPCNT	WS	4		:TRAP REPEAT COUNT
TRPSAV	WS	4		:SAVES COMMAND CLOBBERED BY TRAP SVC
TRPADR	WS	4		:ADDRESSES OF TRAPS
TRPXD	WS	4		:POINTER TO OWNER'S USER BLOCK
TRPREG	WS	40		:SAVE AREA FOR TRAP REGISTERS
TRPPSW	WS	8		:SAME FOR TRAP PSW AND PC

MMLFLG	HS	1		:USED IN SIZING MEMORY
MEMSIZ	WS	1		:MAX MEMORY ADDRESS

	SUBTTL	SHARE (ASYNC Microcode Parameters)

	IF	SOLOCS

::*********************************************************************
::
::	ASYNC MICROCODE PARAMETERS:
::
::*********************************************************************

:	THE BASIC UNIT OF MEMORY FOR DEFINING ASYNG RING SIZE IS THE
:	'TIKMEM' (frame-size).
:
:	ONE TIKMEM IS $A24*8*NACARD BITS, OR SIX BITS OF STORAGE PER
:	ASYNC PORT ( 32 PORTS/CARD ). STORAGE BITS ARE CONSUMED AT THE
:	MULTIFUNCTION CARD INTERRUPT RATE OF 3600/SEC OR 14400/SEC FOR
:	1200 BPS AND 4800 BPS TYMSATS RESPECTIVELY.
:
:	A SINGLE BAUD WILL GET A MINIMUM OF 3 BITS OF STORAGE IN THE
:	ASYNC RING, AND WILL GET CONSIDERABLY MORE FOR THE LOWER BAUD
:	RATES. THEREFORE, AT THE HIGHEST BAUD RATE SUPPORTED, THERE
:	ARE 2 BAUD PER TIKMEM.
:
:	THE ASYNC RING INTERRUPT FILL AND SOFTWARE EMPTY POINTERS MUST
:	NEVER COME CLOSER TOGETHER THAN ONE MAXIMUM-LENGTH 9 1/2 BIT
:	CHARACTER. THIS CHARACTER REQUIRES 'BITMIN' BITS (OR 'MXCL' TIKMEMS)
:	AND DEPENDS UPON THE BAUD RATE SUPPORTED. THE MAXIMUM TIME THAT
:	THE ASYNC RING MAY BE IGNORED IS DETERMINED BY THE NUMBER OF
:	BITS/PORT IN EXCESS OF 'BITMIN', DIVIDED BY THE INTERRUPT RATE.
:	THIS VALUE IS COMPUTED IN MILLISECONDS and equated to 'RNGWRP'
:	and computed in in FASTC and equated to 'RNWRFC'.
:
:	The ring is made up of three components:
:
:	1.  Input area:  this area must contain sufficient frames for the
:	    maximum length character (equivalent to the maximum of the RCHAR
:	    list, adjusted to frame-size).
:	2.  Output area:  This area must contain sufficient frames for the
:	    maximum output length (the maximum of the TCHAR list, including
:	    BREAK).
:	3.  Guard area:  This is the most complicated case.  See ENGINE.DOC,
:	    Appendix II - ASYNC Implementation, Section 6 - Determination of
:	    ring size.

:	DEFINE TERMS USED TO DETERMINE RING SIZE
:	    
:	FOR EACH FRAME OF ASYNC DATA, IT IS NECESSARY TO ALLOCATE 6
:	HALF-WORDS OF SPACE FOR EACH GROUP OF 16 ASYNC PORTS
TIKMEM	EQ	18*NACARD	:FRAME SIZE (bytes)
TIK5	EQ	5*TIKMEM

:	DEFINE INPUT, OUTPUT, AND GUARD AREA TERMS FOR VARIOUS INTERRUPT SPEEDS
	IF	(BAUDR-1)	:4800 BAUD
MXCL	EQ	$A 77		:maximum character length in TIKMEM units
MXOL	EQ	$A 80		:maximum output length in TIKMEM units
	DEFAULT(GUARD,$A 12)	:Guard area term
FSAMPL	EQ	$A 14400	:SAMPLES/SECOND

	ELSE
	  IF	BAUDR		:2400 BAUD--never implemented
MXCL	EQ	$A 39		:maximum character length in TIKMEM units
MXOL	EQ	$A 40		:maximum output length in TIKMEM units
	DEFAULT(GUARD,$A 11)	:Guard area term
FSAMPL	EQ	$A 7200		:SAMPLES/SECOND

	  ELSE
	    IF	LOWSPD		:50 BAUD TELEX support
MXCL	EQ	$A 115		:maximum character length in TIKMEM units
MXOL	EQ	$A 85		:maximum output length in TIKMEM units
	DEFAULT(GUARD,$A 12)	:Guard area term
FSAMPL	EQ	$A 3600		:SAMPLES/SECOND

	    ELSE		:1200 BAUD
MXCL	EQ	$A 53		:maximum character length in TIKMEM units
MXOL	EQ	$A 60		:maximum output length in TIKMEM units
	DEFAULT(GUARD,$A 12)	:Guard area term
FSAMPL	EQ	$A 3600		:SAMPLES/SECOND
	    EI	:LOWSPD
	   EI	:BAUDR
	EI	:(BAUDR-1)

	IF	DB.TRC
EXPAND	EQ	5		:IF UPSW TRACE, MAKE ASYNC RING LARGER	###wjl
	ELSE	(BAUDR-1)	:					###wjl
EXPAND	EQ	2		:IF 4800 BAUD, make async ring larger	###wjl
	ELSE			:					###wjl
EXPAND	EQ	1		:					###wjl
	EI	:DB.TRC

:	DEFINE SIZE OF RING STORAGE
RINGS	EQ	$A((MXCL+MXOL)*TIKMEM+GUARD*TIK5)*EXPAND

	IF	(RINGS-10000)	:IF RING SIZE EXCEEDS ONE SEGMENT...
	REMARK	%ERROR...ASYNC RING EXCEEDS 1 SEGMENT!!!!
	KILLER(1)		:kill assembly				###wjl
	EI	:(RINGS-10000)

:	DEFINE TIME BETWEEN ASYNC RING WRAPS
BITPRT	EQ	(RINGS*8)/NAPORT:BITS OF STORAGE ALLOCATED PER ASYNC PORT
BITMIN	EQ	6*MXCL		:MINIMUM BIT SEPERATION, FILL TO EMPTY POINTERS
BITLFT	EQ	BITPRT-BITMIN	:EXCESS BITS FOR SAFETY
RNGWRP	EQ	$A(1000*BITLFT)/FSAMPL	:TIME BETWEEN ASYNC RING WRAPS
RNWRFC	EQ	$A(600*BITLFT)/FSAMPL	:time between async ring wraps in FASTC

::*********************************************************************
::
::	IREG1:/IREG2:/IREG34:	VALUES FOR INITIALIZING REGISTER SETS
::	REGISTER SETS 1,2,3,4 ARE THE REGISTERS USED BY THE MICROCODE
::	IN PROCESSING THE ASYNC RING.
::
::*********************************************************************

:	INITIALIZATION FOR REGISTER SET 1
				:R0 - PSW Save
				:R1 - Working
				:R2 - Port-number
				:R3 - Offset
IREG1	WS	0		:REGISTER SET 1
	WC	0		:R4 - USED AS INDEX INTO CONTROL RING
	WC	CONTRL		:R5 - ADDRESS OF CONTROL RING
	GL	CONTRL
	WC	4		:R6 - COUNTS DOWN TO ZERO
	WC	-RINGS+TIKMEM/6	:R7 - START BAUD INDEX (SBX)
	WC	-RINGS+TIKMEM/6	:R8 - (RGX1) TRAILS RING INDEX, UPPER
					:	LIMIT FOR SBX
	WC	-RINGS+MXCL*TIKMEM	:R9 - RING INDEX (RGX)
	WC	(TIKMEM/6)^10+TIKMEM/3	:R10 - TIKMEM/6, TIKMEM/3
	WC	(TIKMEM/2)^10+4*TIKMEM/6	:R11 - 3/6TIKMEM, 4/6TIKMEM
	WC	(5*TIKMEM/6)^10+TIKMEM	:R12 - 5/6TIKMEM, 6/6TIKMEM
	WC	RINGS		:R13 - SIZE OF RING
	WC	RINGE		:R14 - ADDRESS OF END OF RING
	GL	RINGE
	IF	(1-NACARD)
	WC	80100000+ASYNDA	:R15 - HI-ORDER BIT SET IF NO ASYNC CARDS
	ELSE			:NACARD>0
	WC	(10-2*NACARD)^10+ASYNDA	:R15 - ADDRESS OF FIRST SBA/TAM
					:	REGISTER IN SETS 3 AND 4.
	EI	(1-NACARD)

:	INITIALIZATION FOR REGISTER SET 2
				:R0 - PSW Save
				:R1 - Working
				:R2 - Port Number
				:R3 - Working
				:R4 - Working
IREG2	WS	0		:REGISTER SET 2
	WC	-TIKMEM		:R5 - MISC RING INDEX (RGI)
	WC	-TIKMEM		:R6 - MISC RING INDEX (RGS)
	WC	RINGE		:R7 - ADDRESS OF END OF RING
	WC	0		:R8 - COUNTER COUNTS UP TO 4
	WC	-RINGS+MXCL*TIKMEM+TIK5-TIKMEM/6	:R9 - (RGX5) 
					:INCREMENTS 120 TIMES PER SECOND
	WC	10-2*NACARD	:R10 - ADDRESS OF FIRST SBA/TAM REGISTER
	WC	RCHAR		:R11 - TABLE OF RECEIVER CHARACTER LENGTHS
	WC	TCHAR		:R12 - TABLE OF TRANSMITTER CHARACTER LENGTHS
	WC	RINGS		:R13 - SIZE OF ASYNC RING
	WC	4*TIK5^10+TIK5	:R14 - 20*TIKMEM, 5*TIKMEM
	WC	LCTIME		:R15 - ADDRESS OF LCTIME ARRAY
	GL	LCTIME

:	REGISTER SET 3 CONTAINS THE SBA/TAM ARRAYS FOR ALL ASYNC PORTS.
:	EACH REGISTER IS ASSOCIATED WITH 16 PORTS - THE HI-ORDER HALFWORD
:	CONTAINS THE SBA DATA, THE LO-ORDER CONTAINS THE TAM DATA.
:	REGISTER SET 4 CONTAINS THE DATA OUT BITS IN THE RIGHT HALFWORD OF
:	EACH REGISTER. DATA OUT IS INITIALIZED TO ALL ONES.

IREG34	WC	0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF
	WC	0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF

::*********************************************************************
::
::	ASYNC MICROCODE TABLES:
::
::*********************************************************************

Q	EQ	TIKMEM/2
	IF	(BAUDR-1)
:	4800 BAUD 
:	CPS	X	X	30	X	60	120	X	X
:		30/30	120/30	240	480	X	34MS BK	1/30DLY	1/30DLY
:	Q = 1/4800 SEC
TCHAR	HC	$A80*Q,80*Q,160*Q,2*Q,80*Q,40*Q,80*Q,80*Q
	HC	$A160*Q,160*Q,20*Q,10*Q,80*Q,162*Q,160*Q,160*Q
:	BAUD LENGTH
	HC	$A1*Q,1*Q,16*Q,1*Q,8*Q,4*Q,1*Q,1*Q
	HC	$A16*Q,4*Q,2*Q,1*Q,1*Q,18*Q,0*Q,0*Q
:	HALF BAUD LENGTH FOR CENTERING
Q	EQ	TIKMEM/6	:1/14400 SEC
	HC	$A0*Q,0*Q,24*Q,0*Q,12*Q,6*Q,0*Q,0*Q
	HC	$A0*Q,0*Q,3*Q,1*Q,0*Q,0*Q,0*Q,0*Q
:	RECEIVE CHAR LENGTH IN 2*1800 UNITS
RCHAR	HC	$A0,0,456,0,228,114,0,0
	HC	$A0,0,56,28,0,0,0,0

	ELSE
	IF	(BAUDR)
:	2400 BAUD
:	CPS	X	X	30	X	60	120	X	X
:		30/30	120/30	240	X	X	30MS BK	1/30DLY	1/30DLY
:	Q = 1/2400 SEC
TCHAR	HC	$A80*Q,80*Q,80*Q,80*Q,40*Q,20*Q,80*Q,80*Q
	HC	$A80*Q,80*Q,10*Q,80*Q,80*Q,72*Q,80*Q,80*Q
:	BAUD LENGTH
	HC	$A1*Q,1*Q,8*Q,1*Q,4*Q,2*Q,1*Q,1*Q
	HC	$A8*Q,4*Q,1*Q,1*Q,1*Q,9*Q,0*Q,0*Q
:	HALF BAUD LENGTH FOR CENTERING
Q	EQ	TIKMEM/6	:1/7200 SEC
	HC	$A0*Q,0*Q,12*Q,0*Q,6*Q,3*Q,0*Q,0*Q
	HC	$A0*Q,0*Q,1*Q,0*Q,0*Q,0*Q,0*Q,0*Q
:	RECEIVE CHAR LENTTH IN 2*1800 UNITS
RCHAR	HC	$A0,0,228,0,114,56,0,0
	HC	$A0,0,28,0,0,0,0,0
	ELSE
	IF	(1-LOWSPD)	:###wjl
:	1200 BAUD
:	CPS	10	15	30	40	60	120	30	14.7
:		30/10	120/10	X	X	X	75MS BK	1/30DLY	1/10DLY
:	Q = 1/1200 SEC

TCHAR	HC	$A120*Q,80*Q,40*Q,30*Q,20*Q,10*Q,40*Q,90*Q
	HC	$A120*Q,120*Q,2*Q,2*Q,2*Q,90*Q,40*Q,120*Q
:	BAUD LENGTH
	HC	$A11*Q,8*Q,4*Q,3*Q,2*Q,Q,4*Q,9*Q
	HC	$A4*Q,Q,Q,Q,Q,10*Q,0,0
:	HALF BAUD LENGTH FOR CENTERING
Q	EQ	TIKMEM/6
	HC	$A15*Q,12*Q,6*Q,4*Q,3*Q,Q,6*Q,14*Q
	HC	0,0,0,0,0,0,0,0
:	RECEIVE CHARACTER LENGTH IN 2*1800 UNITS
RCHAR	HC	$A312,228,114,86,56,28,114,230
	HC	0,0,0,0,0,0,0,0

	ELSE	:###wjl
:	LOWSPD
:	CPS	10	15	30	40	60	120	30	14.7
:		30/10	120/10	75MS BK	1/30DLY	1/10DLY	50	75	75
:	Q = 1/1200 SEC

BRKNDX	EQ	0A	:index into TCHAR table for break output
T50BOD	EQ	0D	:TCHAR index for 50 baud BAUDOT

TCHAR	HC	$A120*Q, 80*Q,40*Q,30*Q, 20*Q, 10*Q, 40*Q, 90*Q
	HC	$A120*Q,120*Q,90*Q,40*Q,120*Q,190*Q,130*Q,160*Q
:	BAUD LENGTH
	HC	$A 11*Q,  8*Q, 4*Q, 3*Q,  2*Q,    Q,  4*Q,  9*Q
	HC	$A  4*Q,    Q,10*Q,   0,    0, 24*Q, 16*Q, 16*Q
:	HALF BAUD LENGTH FOR CENTERING
Q	EQ	TIKMEM/6
	HC	$A 15*Q, 12*Q, 6*Q, 4*Q,  3*Q,    Q,  6*Q, 14*Q
	HC	$A    0,    0,15*Q,   0,    0, 36*Q, 24*Q, 24*Q		:###wjl
:	RECEIVE CHARACTER LENGTH IN 2*1800 UNITS
RCHAR	HC	$A  312,  228, 114,  86,   56,   28,  114,  230
	HC	$A    0,    0, 468,   0,    0,  468,  312,  456		:###wjl

	EI	:(1-LOWSPD)
	EI	(BAUDR)
	EI	(BAUDR-1)
	EI	:SOLOCS

	SUBTTL	SHARE (SSTART)

::*********************************************************************
::
::	SSTART:		NODE INITIALIZER
::	CALLS:	JAL	R8,HCSETS
::		JAL	R6,IZSYLL
::
::*********************************************************************

SSTART	HS	0		:HERE FROM STARTING ADDRESS 70 - RUN NODE CODE
	LIS	R0,0
	JFS	SSTAR2
SSTAR1	HS	0		:HERE FROM STARTING ADDRESS 74 - RUN XRAY ONLY
	LIS	R0,SLEEPF
SSTAR2	STH	R0,ANFLGS		:0=>RUN NODE CODE, NON-ZERO =>DON'T RUN
	LM	R14,ILPVEC		:RESTORE ILLEGAL INSTRUCTION VECTOR IN
	STM	R14,30			: CASE LOADER STORED INTO IT...
	LHI	R0,TTYINT		:SAME FOR TTY INTERRUPT VECTOR
	STH	R0,0D4

:	SIZE MEMORY BY DOING READ-MODIFY-WRITE CYCLES

	LIS	R1,0
	LIS	R2,0F
	TS	MMLFLG			:SET FLAG TO INTERPRET MAC INTERRUPT
SIZMEM	LHL	R3,0,R1			:SAVE OFF THE TRUE VALUE
	STH	R2,0,R1			:CLOBBER WHATEVER WAS THERE
	CH	R2,0,R1			:MAKE SURE IT WAS WRITTEN
	JNFS	SIZMAX			:NO, FOUND THE TOP OF MEMORY
	STH	R3,0,R1			:NOT FOUND THE TOP - RESTORE
	AI	R1,20000		:ADVANCE TO NEXT 128K INCREMENT
	CI	R1,100000		:ARE WE BEYOND ONE MEG?
	JLBS	SIZMEM			:NO, KEEP LOOKING
SIZMAX	ST	R1,MEMSIZ		:FOUND THE TOP

	LHI	R0,0F0			:GO TO SET F
	EPSR	R1,R0

:	IF	1-ISIS			:###wjl
	IF	ZITEL

:	It is an attempt to address the problem of having to set the
:	trace/stop bit and then reset it before it will work.
:	A scheme that might work would be--
:		1 -- set the MCTRCW bit
:		2 -- leave it set until we go MAC'ed
:		3 -- service possible the interrupt (might not be one)
:		4 -- execute SVC to reset the bit in MCTRCW
:	but I'm not sure.  Confer with Steve Berman.
:	set/reset trace enable bit (necessary for it to work)
:	CLEAR SEMI-MEM BIT ERROR LOG TO START

	GL	MEMIO1
	GL	MEMIO2
	LHI	R1,MEMIO1		:GET START OF DVC ADDR RANGE
	LHI	R3,4000
IZ5	OCR	R1,R3			:"SET FOR AN I/O OPERATION"
	WDR	R1,R3			:WRITE CLEAR COMMAND
	WDR	R1,R3			:AGAIN
	AIS	R1,1			:MOVE TO NEXT BOARD
	CLHI	R1,MEMIO2		:HAVE WE CLEARED ALL ADDRESSES?
	JLEBS	IZ5			:BRANCH UNTIL WE HAVE

	EI	:ZITEL
:	EI	:1-ISIS			:###wjl

	LHI	R0,ILLDEV		:INIT INTERRUPT VECTOR
	LHI	R1,1BC			:(SET TO ILLEGAL DEV HANDLER)
	LHI	R2,(2D0-1BC)/2
	JAL	R8,HCSETS

	IF	SILINS

:	HANDLE POTENTIAL SIO INTERRUPT
:	(ONE FOR EACH BOARD)

	LA	R0,INTSIO		:INTERRUPT HANDLER ROUTINE
	GL	INTSIO

Q	EQ	0

	RE	0A
	IF	\M.DA|Q|
	LHI	R1,M.DA|Q|*2		:DEVICE ADDR*2 (INTERRUPT VECTOR INDEX)
	STH	R0,INTVEC,R1
	EI	(\M.DA|Q|)
Q	EQ	Q+1
	ER
	EI	:SILINS

	IF	SIORNG
:	SET UP INTERRUPT VECTOR FOR SIO RING CARD
	LA	R0,INTSIR		:ADDRESS OF HANDLER ROUTINE
	GL	INTSIR
	LHI	R1,SIORNG*2
	STH	R0,INTVEC,R1		:STORE ROUTINE ADDR IN INTERRUPT VECTOR
	EI	:SIORNG

	JAL	R6,IZSYLL		:INIT SYNC LINE INTERRUPT CODE
	GL	IZSYLL

	LIS	R0,0			:CLEAR CLOCKS
	ST	R0,FASTC
	ST	R0,SLOWC
	LCS	R4,1			:INIT BASIC CLOCKS
	STH	R4,SBASCK
	GL	SBASCK
	STH	R4,SLBSCK
	GL	SLBSCK

	IF	EASYNC

:	DISABLE ASYNC INTERRUPTS ON ASYNC ENHANCED ENGINE

	IF	ESYNC
	LHI	R4,0210			:HIGH ORDER BIT SET IN
	ELSE	:
	LHI	R4,10			:HIGH ORDER BIT SET IN
	EI	:ESYNC
	EPSR	R5,R4			:R15 OF REG SET 1 DISABLES
	LI	R15,080000000		: ASYNC INTERRUPTS.

:	FOR ENGINES WITH ENHANCED ASYNC MICROCODE, THE ENGINE
:	MICROCODE DECREMENTS THE CONTENTS OF REG 14 OF REG SET 13
:	EVERY 1/600 SECONDS.  ADDITIONALLY, THE CONTENTS OF THAT
:	REGISTER ARE CHECKED EVERY TIME AN LPSW OR LPSWR IS
:	EXECUTED.  IF THE CONTENTS ARE <=0, THE INTENDED PSD IS
:	STORED IN R0 AND R1 OF REG SET 13 AND THE CURRENT
:	PROGRAM COUNTER IS SET TO THE CONTENTS OF R15 OF
:	REGISTER SET 13.

	IF	ESYNC
	LHI	R4,02D0			:SWITCH TO REG SET 13
	ELSE	:
	LHI	R4,INTVEC		:SWITCH TO REG SET 13
	EI	:ESYNC
	EPSR	R5,R4
	LA	R15,PHASE0		:SET R15 = CLOCK HANDLER ADDRESS
	GL	PHASE0
	LHI	R14,10			:WAIT 16/600 SEC BEFORE FIRST 'TICK'
					:AFTER THAT WE SET TO 1/600
	LIS	R13,1			:USED TO INCREMENT FASTC
	LHI	R4,0F0			:SWITCH BACK TO REG SET F
	EPSR	R5,R4

	EI	:EASYNC

	LIS	R0,0		
	ST	R0,MACSTR		:CLEAR MAC STATUS
	LA	R1,MACREG		:CLEAR MAC REGISTERS
	LHI	R2,20
	JAL	R8,HCLR

	LA	R1,TVNTBF		:CLEAR TTY VARIABLES
	LHI	R2,(TXNTOP+2-TVNTBF)/2
	JAL	R8,HCLR
	LA	R1,TXINT1		:SET ADDR OF TTY INT ROUTINE
	STH	R1,TTYIAD
	LIS	R2,TTYDA
	OC	R2,TVNCLR		:CLEAR PENDING INTERRUPTS FROM TTY PORT
	OC	R2,TVNRCV		: AND SET IT IN RECEIVE MODE

	LA	R1,SKSVC		:RESTORE SVC HANDLER ENTRY
	STH	R1,FSVCST

	LM	R14,ANIPSW		:SET NODE START ADDR
	STM	R14,ANCPSW

	LM	R14,AXIPSW		:SET XRAY START ADDRESS
	STM	R14,AXCPSW
	STH	R0,AXFLGS		:MAKE SURE XRAY IS ENABLED

	LHI	R0,ABSNTF		:KERNEL ASSUMED ABSENT
	STH	R0,KRFLGS
	J	ANCALL			:NODE CODE MUST HAVE FIRST SHOT TO
					:PREVENT MAC ERROR IN XRAY.

::*********************************************************************
::
::	SUBROUTINE:	HCLR: or HCSETS:
::	FUNCTION:	Clear and set block
::	CALLING SEQ:	JAL	R8,HCLR
::	DESTROYED:	R0,R1,R2
::
::*********************************************************************

HCLR	HS	0
	LIS	R0,0			:CLEAR AND SET BLOCK
HCSETS	STH	R0,0,R1
	AIS	R1,2
	SIS	R2,1
	JGBS	HCSETS
	JR	R8

	SUBTTL SHARE (Crash table structures)

::*********************************************************************
::
::	CRASH TABLES STRUCTURES:
::	DEFINED HERE BECAUSE CERTAIN VALUES ARE NEEDED BY SVC01.
::
::*********************************************************************

Q	EQ	.		:HERE WE ARE
	ORG 	0

:	SUMMARY TABLE STRUCTURE
CS.CNT	HS	1		:CRASH COUNT
CS.CID	HS	1		:CRASH ID
CS.PSD	WS	2		:CRASH PSD
CS.TIM	WS	1		:CRASH TIME (SUP GMT FORMAT)
CS.SIZ	EQ	.		:SIZE OF SUMMARY TABLE ENTRY

	ORG	0
:	DETAIL CRASH TABLE STRUCTURE
CD.CNT	HS	1		:CRASH COUNT
CD.CID	HS	1		:CRASH ID
CD.PSD	WS	2		:CRASH PSD
CD.TIM	WS	1		:CRASH TIME (SUP GMT FORMAT)
CD.RS0	WS	10		:SET 0 REGISTERS
CD.RSF	WS	10		:USER SET REGISTERS (USUALLY SET F)
CD.MAC	HS	30		:MAC REGISTERS (LOC'S 300-35F)
CD.SLT	HS	1		:LAST SLOT (NOT USED BY US - ISIS ONLY)
CD.SIZ	EQ	.		:SIZE OF DETAIL TABLE ENTRY

	ORG	Q		:BACK TO REALITY

	SUBTTL	SHARE (SVC'S)

::*********************************************************************
::
::	SKSVC:	SVC HANDLER
::		INITIALLY, ALL SVC'S OTHER THAN SVC 0F,XX WILL RETURN
::		IMMEDIATELY TO THE CALLER.  IF THE KERNEL IS
::		PRESENT, IT SETS UP THE OTHER SVC VECTORS.
::	
::*********************************************************************

MAXSVC	EQ	3F			:MAX SVC INDEX ALLOWED

SKSVC	HS	0
	NHI	R13,MAXSVC		:truncate our index
	LHL	R13,SKSVDS,R13,R13	:DISPATCH ON INDEX
	JR	R13

::*********************************************************************
::
::	SVC00:		SVC	0F,SV.ISY
::	FUNCTION:	Initialize the sync lines
::
::*********************************************************************

SV.ISY  EQ      0
SVC00	JAL	R6,IZSYLL		:00 - INIT THE SYNC LINES
SVCXX	LPSWR	R14

::*********************************************************************
::
::	SVC01:		SVC	0F,SV.SCR
::	FUNCTION:	Save reg set 0 crash registers and PSW in abs memory
::
::*********************************************************************

SV.SCR  EQ      1
SVC01	HS	0
	STM	R0,PHERG0,,		:SAVE SET 0 REGISTERS AT ERREG0
	GL	PHERG0
	ST	R14,PHCRPS,,		:SAVE CRASH PSW
	GL	PHCRPS
	LPSWR	R14			:AND RETURN

::*********************************************************************
::
::	SVC02:		SVC	0F,SV.RAB
::	FUNCTION:	READS A FW FROM THE ABSOLUTE ADDRESS PASSED IN R1 OF
::			SET F AND RETURNS IT IN R1 OF SET F.
::			Read word in absolute memory
::
::*********************************************************************

SV.RAB	EQ	2
SVC02	HS	0
	STM	R14,SVCPSW
	LHI	R0,0F0			:go to register set F
	EPSR	R1,R0
	L	R1,0,R1			:read the word into register 1 of set F
	LPSW	SVCPSW			:return to caller

::*********************************************************************
::
::	SVC03:		SVC	0F,SV.DSM
::	FUNCTION:	Dismiss current context, dispatch to Context Switcher
::
::*********************************************************************

SV.DSM	EQ	3
SVC03	HS	0
	IF	KERNEL
	LHL	R2,USRRET		:03 - DISMISS CURRENT USER
	CLHI	R2,ANRET		:IF NODE, CALL KERNEL
	JEFS	SVC03A
	LR	R0,R14			:ELSE PLAIN DISMISS
	LR	R1,R15
	JR	R2
SVC03A	STM	R14,ANCPSW		:NOTE--REGISTERS NOT SAVED...
	LHI	R0,0F0			:...WHEN NODE CALLS KERNEL
	EPSR	R1,R0
	LA	R2,KGO,,
	GL	KGO
	J	KRCALL

	ELSE	:NOT KERNEL

	LHL	R2,USRRET		:DISMISS CURRENT USER
	LR	R0,R14
	LR	R1,R15			:SAVE PSW
	JR	R2

	EI	:KERNEL

::*********************************************************************
::
::	SVC04:		SVC	0F,SV.IKR
::	FUNCTION:	Initialize the KERNEL
::
::*********************************************************************

SV.IKR	EQ	4
SVC04	STM	R14,ANCPSW		:04 - INITIALIZE THE KERNEL
	LIS	R0,0			:ENABLE KERNEL
	STH	R0,KRFLGS
	LA	R0,KNDR			:RETURN ADDR FOR KERNEL CALLS
	ST	R0,KRET,,
	GL	KRET
	LHI	R0,0F0			:go to set F, ints disabled
	EPSR	R1,R0
	LA	R2,KIZ,,
	GL	KIZ
	J	KRCALL

::*********************************************************************
::
::	SVC05:		SVC	0F,CSY
::	FUNCTION:	SYNC IN/OUT CONNECT
::	INPUT:		EXPECTS THE FOLLOWING SETUP IN REG SET F:
::			R0 = HANDLER CODE
::			R1 = LINE NUMBER
::			R2 = ADDRESS OF DATA TO BE OUTPUT
::			R3 = BYTE COUNT (IF APPROPRIATE)
::
::*********************************************************************

SV.CSY	EQ	5
SVC05	LHI	R0,0F0			:*0*GO TO REG SET F TO GET REGISTERS
	EPSR	R1,R0
	ST	R0,SVCCHR		:*F*SAVE R0
	ST	R1,SVCCHR+4		:*F*R1
	ST	R2,SVCCHR+8		:*F*R2
	ST	R3,SVCCHR+0C		:*F*AND BYTE COUNT
	LPSW	SVC05Z			:GO TO SVC05D, REG SET 0, INTERRUPTS ON
SVC05D	L	R0,SVCCHR		:*0*PICK UP THE VALUES
	L	R1,SVCCHR+4		:*0*
	L	R2,SVCCHR+8		:*0*
	L	R3,SVCCHR+0C		:*0*
	LR	R0,R0			:*0*TEST HANDLER CODE
	JGE	SVC05B			:IF R0 < 0, TIME TO XMIT DUMMY RECORD

	L	R4,RSENT+4		:YES, SEND DUMMY
	GL	RSENT
	ST 	R4,XDUMM+4	
	GL	XDUMM
	L	R4,RSENT+8
	ST 	R4,XDUMM+8
	LCS	R4,1			:LOAD THE RESET VALUE
	ST	R4,RSENT+4		:AND STORE IN RSENT
	ST	R4,RSENT+8
	LPSWR	R14			:RETURN TO CALLER

SVC05B	NHI	R0,7			:R0=HANDLER CODE #
	CI	R2,SEG1			:check if it's a SEG0 address	###wjl
	JGEFS	SVC05A			:no				###wjl
	AHI	R2,S0PH			:yes, CONVERT TO PHYSICAL ADDR	###wjl
	JFS	SVC05N			:				###wjl
SVC05A	AI	R2,S2PH-20000		:can't be SEG1, so must be SEG2	###wjl
SVC05N	SLL	R1,1			:SXOPTR IS FW BOUNDARY ##AL
	ST	R2,SXOPTR,R1,R1		:STORE RECORD POINTER ADDRESS
	SRL	R1,1			:RESUME R1 ##AL
	GL	SXOPTR
	STH	R3,SXOCNT,R1,R1		:STORE BYTE COUNT
	GL	SXOCNT
	CLHI	R0,4			:RESET HANDLER CODE?
	JNFS	SVC05R			:BRANCH IF NOT
	LIS	R4,0
	SR	R4,R3			:GET NEGATIVE COUNT
	STH	R4,SYRESZ		:AND SAVE FOR RESET TRANSMISSION LOGIC
	GL	SYRESZ
SVC05R	LR	R4,R0			:MOVE HANDLER CODE TO R4
	LHL	R4,SVC05T,R4,R4		:HANDLER ADDRESS FROM TABLE
	SLHLS	R1,2			:SCALE LINE NUMBER TO HW OFFSET
	STH	R4,INTVXL,R1		:STORE HANDLER ADDR AT INTERRUPT VECTOR

	IF	ESYNC

:	FOR ENGINES WITH ENHANCED SYNC MICROCODE, THE SYNC
:	LINE I/O CONTROL BLOCK AT LOC X'400' + LN*0A
:	CONTROLS I/O AND MUST BE UPDATED APPROPRIATELY.
:
:	NOTE:	HERE R1 = LINE # X 4

	SRHLS	R1,2			:GET LINE #
	LA	R4,SYLIDL		:ASSUME IDLING OUTPUT
	LR	R0,R0			:IF SO, IDLE INPUT TOO
	JEFS	SVC05C

	LHI	R4,(SVNBSZ+2)		:INPUT RING SIZE
	GL	SVNBSZ
	MHR	R4,R1			:RELATIVE START OF INPUT RING
	LA	R4,PHSVTP,R4,		:REAL START OF RING
	GL	PHSVTP

SVC05C	MH	R1,SVC05Y		:CALCULATE I/O CONTROL BLOCK ADDRESS
	ST	R4,0400,R1		:SET UP INPUT RING ADDR
	LPSWR	R14			:RETURN TO CALLER

SVC05X	HS	1
SVC05Y	HC	0A			:I/O CB SIZE
SVC05Z	WC	4000,SVC05D		:NEW PSW ENABLES INTERRUPTS 

	ELSE				:NOT ESYNC
	LA	R4,SVIRDL		:IF IDLE, IDLE INPUT ALSO
	LR	R0,R0			:TEST HANDLER CODE
	JEFS	SVC05A			:BRANCH IF CODE FOR SXIDL
	LR	R4,R1			:OTHERWISE SET SVINT
	SRHLS	R4,2
	MH	R4,CSVINZ
	AHI	R4,SVINT
SVC05A	STH	R4,INTVRL,R1		:UPDATE THE RECEIVE VECTOR PTR
	SRHLS	R1,2
	L	R4,SVCCHR		:GET RETURN PSW
	LPSW	SVCPSW			:AND RETURN TO CALLER
	EI	:ESYNC

:	SVC05 TABLE

SVC05T	HC	SXIDL,SXATT,SXRST,SXPAK,SXRSM,SXIDL,SXIDL,SXIDL
	GL	SXRST,SXRSM,SXIDL,SXATT,SXPAK

::*********************************************************************
::
::	SVC06:		SVC	0F,SV.SOI
::	FUNCTION:	SYNC OUTPUT IDLE
::			SKIP IF SYNC OUTPUT IDLE
::
::*********************************************************************

SV.SOI  EQ      6
SVC06	STM	R14,SVCPSW		:*0*SAVE RETURN PSW
	LHI	R0,0F0			:*0*SELECT USER REG SET F
	EPSR	R1,R0			:*0*IMMEDIATE RETURN IF LINE IS BUSY
	ST	R4,SVCCHR		:*F*WE'RE GOING TO CLBBER R4 SO SAVE IT
	NHI	R1,MLINEL		:*F*MASK LINE NUMBER
	GL	MLINEL
	LR	R4,R1			:*F*MOVE LINE # TO WORK REGISTER
	SLHLS	R4,2			:*F*DOUBLE FOR HW TABLE OFFSET
	LH	R4,INTVXL,R4		:*F*GET HW ENTRY OF INT STATE ROUTINE
	CLHI	R4,SXIDL		:*F*ARE WE IN IDLE STATE NOW?
	JNFS	SVC06A			:*F*IF NOT, TAKE IMMEDIATE RETURN
	LIS	R4,4			:*F*IF IDLE ALREADY, TAKE SKIP RETURN
	AM	R4,SVCPSW+4		:*F*BY ADDING IT TO RETURN PSW
SVC06A	L	R4,SVCCHR		:*F*RESTORE DESTROYED R4
	LPSW	SVCPSW			:*F*RETURN TO CALLER

::*********************************************************************
::
::	SVC07:		SVC	0F,SV.PTY
::	FUNCTION:	SKIP RETURN IF CHARACTER IN TTY BUFFER
::
::*********************************************************************

SV.PTY  EQ      7
SVC07	LHL	R1,TVNTOP		:READ TTY OUT PTR
	CLH	R1,TVNTIP		:COMPARE WITH IN PTR
	JEFS	SVC07R			:NORMAL RETURN IF OUT PTR = IN PTR
	AIS	R15,4			:ADD 4 TO PSW ADDR FOR SKIP RETURN
SVC07R	LPSWR	R14

::*********************************************************************
::
::	SVC08:		SVC	0F,SV.RTY
::	FUNCTION:	THIS SVC IS USED TO CHECK FOR THE PRESENCE OF
::			AN INPUT CHARACTER IN THE TTY INPUT BUFFER.
::			AN IMMEDIATE RETURN IS GIVEN IF NO CHARACTER
::			IS PRESENT. A SKIP RETURN IS GIVEN IF A CHARCTER
::			IS FOUND.  THE CHARACTER IS RETURNED IN R1
::			OF REG SET F.
::
::*********************************************************************

SV.RTY  EQ      8
SVC08	LHL	R1,TVNTOP		:08 - READ A CHAR INTO R1/SET 'F'
	CLH	R1,TVNTIP
	JNFS	SVC08A
	LPSWR	R14			:NO CHAR, ABORT (IMMEDIATE RETURN)
SVC08A	LH	R0,FASTC+2		:CHECK ARRIVAL TIME
	CH	R0,TVNTWC
	JGFS	SVC08B
	LPSWR	R14
SVC08B	AIS	R15,4			:INC RETURN ADDR BY 4
	STM	R14,SVCPSW		:SAVE PSW
	LB	R0,TVNTBF,1		:GET THE CHAR
	STH	R0,SVCCHR		:SAVE TEMPORARILY
	AIS	R1,1			:INC PTR
	NHI	R1,TVNBSZ-1
	STH	R1,TVNTOP
	LHI	R0,0F0			:RETURN CHAR IN R1/SET 'F'
	EPSR	R1,R0
	LHL	R1,SVCCHR
	LPSW	SVCPSW

::*********************************************************************
::
::	SVC09:		SVC	0F,SV.WTY
::	FUNCTION:	THIS SVC IS USED TO PLACE A CHARACTER IN THE TTY
::			OUTPUT BUFFER.  ON ENTRY, THE CHARACTER IS CONTAINED
::			IN R1 OF REG SET F. IF AFTER PLACING THE CHARACTER
::			IN THE BUFFER, THERE IS ROOM FOR MORE, CONTROL
::			IS GIVEN BACK TO THE USER. ELSE, XRAY GIVES UP
::			THE REMAINDER OF ITS TIME-SLICE, AND IS PUT INTO THE
::			OUTPUT WAIT STATE UNTIL AN INTERRUPT FROM THE TTY CARD
::			PUTS IT BACK INTO THE RUN STATE
::
::*********************************************************************

SV.WTY  EQ      9
SVC09	LHI	R0,0F0			:09 - WRITE A CHAR FROM R1/SET 'FF'
	EPSR	R1,R0
	ST	R1,SVCCHR		:SAVE THE CHAR
	LPSW	SVC09P			:GET BACK TO REG SET 0
SVC09A	LHL	R1,TXNTIP		:GET CURRENT POINTER INTO OUTPUT BUFFER
	LB	R0,SVCCHR+3		:RETRIEVE CHARACTER
	STB	R0,TXNTBF,R1		:AND PUT INTO OUTPUT BUFFER
	LHL	R0,TTYIAD		:IS THE TTY CURRENTLY IN TRANSMIT MODE?
	CLHI	R0,TXINT
	JEFS	SVC09B			:YES

	LA	R0,TXINT		:NO, PUT IT INTO TRANSMIT MODE
	STH	R0,TTYIAD
	LIS	R2,2
	OC	R2,TVNCLR		:CLEAR PENDING INTS
	OC	R2,TVNXMT		:SET TRANSMIT MODE

SVC09B	AIS	R1,1			:INC BUFFER POINTER
	NHI	R1,TXNBSZ-1		:MASK WITH OUTPUT BUFFER SIZE
	STH	R1,TXNTIP		:AND STORE BACK

	AIS	R1,1			:CHECK IF BUFFER IS FULL
	NHI	R1,TXNBSZ-1
	CLH	R1,TXNTOP
	JEFS	SVC09C			:YES
	LPSWR	R14			:NO,RETURN TO CALLER

SVC09C	LHL	R0,AXFLGS
	OHI	R0,OUTWTF		:SET OUTPUT WAIT FLAG
	STH	R0,AXFLGS
	LR	R0,R14			:AND DISMISS TO CONTEXT SWITCHER
	LR	R1,R15
	J	AXRET

SVC09P	WC	6000,SVC09A		:SET 0, PROCEED FROM SVC09A

::*********************************************************************
::
::	SVC0A:		SVC	0F,SV.O1M
::	FUNCTION:	Output 1 to modem signals
::
::*********************************************************************

SV.O1M  EQ      0A
SVC0A	LHI	R2,0BF			:0A - OUTPUT A 1 TO MODEM SIGS
	LCS	R3,1
	WDR	R2,R3
	IF	(10-NLINES-SILINS)	:IF 2ND SYNC CARD
	LHI	R3,0FF			:OUTPUT TO SECOND SYNC CARD
	WDR	R2,R3
	EI	((2ND SYNC CARD))
	LPSWR	R14

::*********************************************************************
::
::	SVC0B:		SVC	0F,SV.O0M
::	FUNCTION:	Output a 0 to modem signals
::
::*********************************************************************

SV.O0M  EQ      0B
SVC0B	LHI	R2,0BF			:0B - OUTPUT A 0 TO MODEM SIGS
	LIS	R3,0
	WDR	R2,R3
	IF	(10-NLINES-SILINS)	:IF 2ND SYNC CARD
	LHI	R3,0FF			:OUTPUT TO SECOND SYNC CARD
	WDR	R2,R3
	EI	((2ND SYNC CARD))
	LPSWR	R14

	IF	SILINS

::*********************************************************************
::
::	SVC0C:		SVC	0F,SV.CSI
::	FUNCTION:	CONNECT SVC FOR SIO
::
::	THIS SVC RE-CALLS ITSELF TO GO THROUGH THE THREE PHASES OF SIO
::	INITIALIZATION (DMA WINDOW, LOWER LIMIT AND RELOCATION CONSTANT)
::
::	SVC DOES A SKIP RETURN IF NO ERRORS.
::	SVC DOES AN IMMEDIATE RETURN IF ERROR, WITH UPPER HW OF R0
::	CONTAINING ERROR KEY. VALID KEYS ARE:	1	:BAD LINE NUMBER
::						4	:M-BOARD TIMEOUT
::	NOTE--THE WDR INSTRUCTION USES THE HIGH ORDER FOUR BITS OF THE 
::	REGISTER R0 TO SEND THE COMMAND (DEVICE.DOC P. 7) TO THE MOTHER 
::	BOARD.
::
::*********************************************************************

:	Equates for commands to Mother-Board via WDR

MBSTIN	EQ	0		:start input
MBSTOU	EQ	1000		:start output
MBSTRL	EQ	2000		:set rlocation
MBSTLL	EQ	3000		:set lower limit
MBSTWS	EQ	4000		:set window size
MBSTAT	EQ	5000		:read status
MBRSET	EQ	6000		:board reset
MBLNRS	EQ	7000		:line reset

SV.CSI  EQ      0C
SVC0C	JAL	R5,SIOCOM		:COMMON SETUP, INSURE MUX NOT BUSY
	LH	R6,SVCCHR		:HIGH-ORDER OF USER REG 0 DETERMINES...

:	...CURRENT STATE OF SVC. RETURNS BETWEEN EACH STATE.

	JE	SVC0C0			:STATE 0
	SIS	R6,2
	JL	SVC0C1			:STATE 1
	JE	SVC0C2			:STATE 2

:	STATE 3. SET WINDOW SIZE, THEN DONE WITH SVC.

	OHI	R0,MBSTWS		:DEVICE ADR, BITS 0-3 CMD "SET WNDW SZ"
	L	R1,SVCCHR+8		:USER REG 2 POINTS TO END OF DMA AREA
	S	R1,SVCCHR+4		:USER REG 1 POINTS TO BEGIN OF DMA AREA
	SRLS	R1,4
	WDR	R0,R1			:OUTPUT COMMAND TO SIO BOARD
	AIS	R15,4			:SET UP SKIP RETURN
	LPSWR	R14			:DONE WITH 0F,0C SVC - RETURN TO CALLER

:	STATE 0 - STOP CURRENT PROGRAM

SVC0C0	OHI	R0,MBLNRS		:CMD MB TO STOP CURRENT PROGRAM
SVC0CA	WDR	R0,R1			:OUTPUT COMMAND TO SIO BOARD
	SIS	R15,4			:SET UP TO REPEAT SVC
	STM	R14,SVCPSW
	LHI	R0,0F0
	EPSR	R1,R0			:SWITCH TO USER'S REGISTER SET
	AI	R0,10000		:ADVANCE STATE COUNTER IN USER REG 0
	LPSW	SVCPSW			:RETURN TO REPEAT THE SVC

:	STATE 1 - SET RELOCATION

SVC0C1	OHI	R0,MBSTRL		:WRITE OUT CMD TO MB	
	IF	SIBFRL			:SIO BUFFERS RELOCATION	###LSH
	LI	R1,(S2PH-20000)/10	:SIO DMA AREA IS IN SEGMENT 2 ###LSH
	ELSE	:NOT SIBFRL		:###LSH
	LI	R1,S0PH/10		:SIO DMA AREA IS IN SEGMENT 0
	EI	:SIBFRL			:###LSH
	J	SVC0CA			:COMMON EXIT

:	STATE 2 - BEGINNING OF DMA WINDOW

SVC0C2	OHI	R0,MBSTLL		:WRITE CMD TO MB
	L	R1,SVCCHR+4		:GET USER REG 1
	SRLS	R1,4
	J	SVC0CA			:COMMON EXIT

::*********************************************************************
::
::	SUBROUTINE:	SIOCOM:
::	FUNCTION:	SIO SVC common setup routine
::	CALLING SEQ:	JAL	R5,SIOCOM
::	DESTROYED:	R0,R1,R2,R3
::	RETURNS:	JFR	8,R5	or
::			LPSW	SVCPSW
::
::*********************************************************************

SIOCOM	HS	0
	LHI	R0,0F0
	EPSR	R1,R0			:SWITCH TO USER'S REGISTER SET
	ST	R0,SVCCHR		:SAVE USER'S REG 0..(DEVICE ADDRESS)
	ST	R1,SVCCHR+4		:R1...(POINTER TO CCW BLOCK)
	ST	R2,SVCCHR+8		:AND R2
	LPSW	SIOCP			:CONTINUE IN REG SET 0
SIOCA	LHL	R1,SVCCHR+2		:GET LINE NUMBER * 2 (USER R0)
	CLHI	R1,NLINES*2		:VALID LINE NUMBER?
	JGEFS	SIOPS2			:NO - TAKE DIRECT RETURN	###OAS
	SHI	R1,(NLINES-SILINS)*2	:BIAS FOR RELATIVE SIO LINE
	JLFS	SIOPS2			:NOT VALID SIO LINE		###OAS
	LH	R0,SIDEV,R1		:GET DEVICE ADDRESS FOR THIS SIO LINE
	LHI	R3,$A40			:TRY 40 TIMES MAX
SIOCO9	SSR	R0,R1			:SENSE DEVICE STATUS (PSW CC IS SET TO
					:STATUS)STATUS ALSO RETURNED IN REG R1.
	JT	4,SIOPS4		:MBOARD ERROR CHECK		###OAS
	JFR	8,R5			:RETURN TO SIOCOM CALLER IF NOT BUSY 

	SIS	R3,1			:RETRY THE I/O OPERATION IF POSSIBLE
	JGBS	SIOCO9
	JFS	SIOPS3			:TIMEOUT...RETURN WITH ERROR CODE###OAS

:	BAD LINE NUMBER...DO DIRECT RETURN

SIOPS2	STM	R14,SVCPSW		:###OAS
	LHI	R0,0F0
	EPSR	R1,R0			:GO TO SET F
	NI	R0,0000FFFF		:CLEAR POSSIBLE CONNECT STATE FLAG#OAS
	OI	R0,20000		:OR IN THE ERROR CODE		###OAS
	LPSW	SVCPSW			:AND RETURN TO USER

:	M-BOARD TIMEOUT...DO DIRECT RETURN

SIOPS3	STM	R14,SVCPSW
	LHI	R0,0F0
	EPSR	R1,R0
	NI	R0,0000FFFF		:CLEAR POSSIBLE CONNECT STATE FLAG#OAS
	OI	R0,30000
	LPSW	SVCPSW

:	M-BOARD ERROR...DO DIRECT RETURN ###OAS

SIOPS4	STM	R14,SVCPSW		:###OAS
	LHI	R0,0F0			:###OAS
	EPSR	R1,R0			:###OAS
	NI	R0,0000FFFF		:CLEAR POSSIBLE CONNECT STATE FLAG#OAS
	OI	R0,40000		:###OAS
	LPSW	SVCPSW			:###OAS

SIOCP	WC	6000,SIOCA		:ENABLE I/O AND MALFUNCTION INTS. AND
					:USE REGISTER SET 0.

::*********************************************************************
::
::	SVC0D:		SVC	0F,SV.ISI
::	FUNCTION:	START SIO INPUT
::
::*********************************************************************

SV.ISI  EQ      0D
SVC0D	HS	0
	JAL	R5,SIOCOM	:COMMON SETUP, TEST FOR MUX INTERFACE BUSY

:	NOTE--INPUT COMMAND IS ZERO, SO NO "OHI" NEEDED HERE FOR R0.

SVC0DA	L	R1,SVCCHR+4	:USER REG 1 CONTAINS ADDRESS OF CCW BLOCK
	SRLS	R1,4		:ALIGN TO QUAD WORD BND, M-B WANTS 16 BITS
	WDR	R0,R1		:OUTPUT COMMAND TO SIO BOARD
	AIS	R15,4		:SET UP SKIP RETURN
	LPSWR	R14		:RETURN TO SVC CALLER

::*********************************************************************
::
::	SVC0E:		SVC	0F,SV.OSI
::	FUNCTION:	START SIO OUTPUT
::
::*********************************************************************

SV.OSI  EQ      0E
SVC0E	HS	0
	JAL	R5,SIOCOM	:COMMON SETUP, TEST FOR MUX INTERFACE BUSY
	OHI	R0,MBSTOU	:OR "OUTPUT" CMD INTO DEVICE ADDRESS
	JBS	SVC0DA		:OUTPUT COMMAND AND EXIT

::*********************************************************************
::
::	SVC0F:		SVC	0F,SV.QSI
::	FUNCTION:	QUERY SIO STATUS
::
::*********************************************************************

SV.QSI  EQ      0F
SVC0F	HS	0
	JAL	R5,SIOCOM	:COMMON SETUP, TEST FOR MUX INTERFACE BUSY
	OHI	R0,MBSTAT	:OR "READ STATUS" COMMAND INTO DEVICE ADDR
	J	SVC0DA		:OUTPUT COMMAND AND EXIT

	EI	:SILINS

::*********************************************************************
::
::	SVC10:		SVC	0F,SV.EXR
::	FUNCTION:	ENABLES (IF R1 OF SET F =0) OR INHIBITS
::			(IF R1 OF SET F .NE. 0) RUNNING OF XRAY
::			CONCURRENTLY WITH THE NODE CODE.
::
::*********************************************************************

SV.EXR  EQ      10
SVC10	STM	R14,SVCPSW
	LA	R1,TVNTBF		:CLEAR TTY VARIABLES
	LHI	R2,(TXNTOP+2-TVNTBF)/2
	JAL	R8,HCLR
	LA	R1,TXINT1		:SET ADDR OF TTY INT ROUTINE
	STH	R1,TTYIAD
	LIS	R2,TTYDA
	OC	R2,TVNCLR		:CLEAR PENDING INTERRUPTS FROM TTY PORT
	OC	R2,TVNRCV		: AND SET IT IN RECEIVE MODE
	LM	R14,AXIPSW		:SET XRAY START ADDRESS
	STM	R14,AXCPSW
	LHI	R0,0F0			:GO TO SET F AND
	EPSR	R1,R0			:ENABLE OR DISABLE ???jhl
	STH	R1,AXFLGS
	LPSW	SVCPSW

::*********************************************************************
::
::	SVC11:		SVC	0F,SV.TRP
::	FUNCTION:	TRAPDOOR SVC FOR DEBUGGING SOLO NODE CODE
::
::*********************************************************************

SV.TRP  EQ      11
SVC11	LIS	R2,0
	SIS	R15,4			:BACK PC UP TO SVC INSTRUCTION
SVC11A	C	R15,TRPADR,R2		:FIND THE ADDRESS
	JEFS	SVC11B			:FOUND IT
	AIS	R2,4			:NO, INCREMENT INDEX
	CLHI	R2,10			:WE ALLOW 4 TRAPS MAX
	JLBS	SVC11A			:GO BACK AND KEEP LOOKING
	SIS	R2,4			:WE SHOULD NEVER COME HERE

SVC11B	LR	R3,R2
	AR	R3,R2			:8-BYTE INDEX FOR TRPPSW
	SRLS	R2,1			:2-BYTE INDEX FOR TRPTIM
	LR	R4,R3			:16-BYTE INDEX TO DISPATCH
	AR	R4,R4

	L	R0,FASTC		:GET TIME THE TRAP WAS SPRUNG
	ST	R0,TRPTIM,R2,R2		:	AND STORE IT
	SRLS	R2,1			:1-BYTE INDEX FOR TRPFLG, TRPSEQ
	SBT	R2,TRPFLG		:NOTE THE TRAP IS SPRUNG
	LHL	R0,TRPNXT		:GET TRAP 'TIME'
	STH	R0,TRPSEQ,R2,R2		:STORE TRAP TIME
	AIS	R0,1
	NHI	R0,0FF			:INCREMENT SEQ INDEX
	STH	R0,TRPNXT
	J	SVC11C,R4		:DISPATCH TO CORRESPONDING AREA

SVC11C	LHI	R0,0F0			:USER REG SET
	EPSR	R1,R0
	STM	R0,TRPREG,,		:SAVE THE REGISTERS
	LPSW	SVC11D			:RETURN TO REG SET 0

	LHI	R0,0F0			:USER REG SET
	EPSR	R1,R0
	STM	R0,TRPREG+40,,		:SAVE THE REGISTERS
	LPSW	SVC11D			:RETURN TO REG SET 0

	LHI	R0,0F0			:USER REG SET
	EPSR	R1,R0
	STM	R0,TRPREG+80,,		:SAVE THE REGISTERS
	LPSW	SVC11D			:RETURN TO REG SET 0

	LHI	R0,0F0			:USER REG SET
	EPSR	R1,R0
	STM	R0,TRPREG+0C0,,		:SAVE THE REGISTERS
	LPSW	SVC11D			:RETURN TO REG SET 0

SVC11E	STM	R14,TRPPSW,R3		:SAVE PSW AND PC FOR EXAMINATION
	LI	R12,SDPH-SEGD,R15	:GUESS THAT TRAP WAS IN SEGD
	GL	SDPH
	JGEFS	SVC11G			:CORRECT.
	LI	R12,S1PH-SEG1,R15	:WRONG, MUST BE IN SEG1
	GL	S1PH
SVC11G	SRLS	R3,1			:FORM WORD INDEX FOR INSTRUCTION
	L	R1,TRPSAV,R3		:GET THE INSTRUCTION STORED THERE
	ST	R1,0,R12		:RESTORE THE INSTRUCTION
	LHI	R1,01F-PXRAY		:SCHEDULE REMOTE XRAY TO DISPLAY TRAP
	GL	PXRAY
	SBT	R1,PHSQUE,,
	GL	PHSQUE
	LHL	R1,TRPXD+2,R3		:GET OWNER'S XD
	AHI	R1,XUSLTN		:POINT TO THIS USER'S SLOT NO.
	GL	XUSLTN
	LHL	R1,S0PH,R1,		:CONVERT TO OWNER'S XN
	JEFS	SVC11F			:SKIP IF 0 (TTY)
	SBT	R1,PHXQUM,,		:SET XRAY USER QUEUE
	GL	PHXQUM
SVC11F	LPSWR	R14			:RETURN TO SVC CALLER

SVC11D	WC	4000,SVC11E		:NEW PSW ENABLES ASYNC INTERRUPTS

::*********************************************************************
::
::	SVC12:		SVC	0F,SV.BOT
::	FUNCTION:	SENDS THE SOLO MACHINE INTO ITS BOOT
::
::*********************************************************************

SV.BOT  EQ      12
SVC12	HS	0
	L	R0,ADBOOT
	GL	ADBOOT
	SRLS	R0,4
	CI	R0,4300400		:MAKE SURE THE JUMP TO BOOT IS THERE
	JEFS	SVC12X			:IT IS, GO AHEAD WITH BOOT PROCEDURE
	LPSWR	R14			:IT ISN'T, SOMETHING WRONG. RETURN
SVC12X	HS	0

:	ANY ACTIVE MOTHERBOARDS MUST BE RESET. ELSE, OBLIVIOUS TO THE BOOT
:	AND SUBSEQUENT RELOAD, THEY WILL KEEP WRITING INTO MEMORY ACCORDING
:	TO THEIR ORIGINAL DMA CONFIGURATION

	IF	SILINS
	LHI	R3,(SILINS-1)*2		:DO OVER ALL SIO LINES
SVC12A	LH	R0,SIDEV,R3		:GET M-BOARD DEVICE ADDR FOR SIO LINE
	LHI	R4,1000			:SET MAXIMUM NUMBER OF ATTEMPTS
SVC12C	SSR	R0,R1			:READ DEVICE STATUS INTO PSW COND CODE
	JFFS	R8,SVC12B		:IF STATUS.NE.8, DEVICE IS NOT BUSY
	SIS	R4,1			:ELSE RETRY 1000H TIMES
	JGEBS	SVC12C			:OR JUST IGNORE AFTER 1000H TRIES
SVC12B	OHI	R0,MBRSET		:CODE 6 = RESET MOTHERBOARD COMMAND
	WDR	R0,R1			:OUTPUT TO BOARD
	SIS	R3,2			:DO FOR ALL SIO LINES
	JGEBS	SVC12A

	EI	:SILINS
	J	ADBOOT			:ADBOOT CONTAINS A JUMP TO BOOT PROGRAM

:	ASYNC I/O SVC'S

	IF	SOLOCS

::*********************************************************************
::
::	SVC13:		SVC	0F,SV.IZA
::	FUNCTION:	INITIALIZE ASYNC RING, MICROCODE REGS, MISC ARRAYS
::
::*********************************************************************

SV.IZA  EQ      13
SVC13	HS	0
	LIS	R0,0
	EPSR	R1,R0			:DISABLE INTERRUPTS
	STM	R14,SVCPSW		:SAVE PSW

:	INITIALIZE MICROCODE CONTRL, LCTIME, AND RING THRU RING+(MXCL*TIKMEM)
:	TO -1. CONTRL, LCTIME, AND RING MUST BE LOCATED IN CONSECUTIVE
:	MEMORY SPACE FOR THIS ROUTINE TO WORK. ONCE MAC IS ENABLED, THESE
:	FIELDS WILL BE INACCESSIBLE TO THE CODE.

	LCS	R1,1
	LHI	R2,BADNAD+(MXCL*TIKMEM)-4
	GL	BADNAD
IZR02	ST	R1,CONTRL,R2,		:STORE SOME ONES
	SIS	R2,4
	JGEBS	IZR02

:	INITIALIZE RING+(MXCL*TIKMEM) THRU RINGE TO ZEROS. MXCL*TIKMEM IS THE
:	LENGTH OF THE LONGEST ASYNC CHARACTER (110/300 BAUD). THE RING INDEX
:	(REGISTER 9 OF REGISTER SET 1) WILL BE INITIALIZED TO START AT
:	RING+(MXCL*TIKMEM), AND EXPECTS TO HAVE ONES BEHIND IT AND ZEROS
:	IN FRONT FOR ALL PORTS IDLE.

	LIS	R1,0
	LI	R2,RINGS-(MXCL*TIKMEM)-4
IZR04	ST	R1,RING+(MXCL*TIKMEM),R2,	:STORE ZEROS
	GL	RING
	SIS	R2,4
	JGEBS	IZR04

:	INITIALIZE REGISTERS USED BY ASYNC MICROCODE

	LPSW	IZRP1
IZRS1	LM	R4,IREG1		:INITIALIZE REGS 4-15 IN SET 1
	LPSW	IZRP2
IZRS2	LM	R5,IREG2		:INITIALIZE REGS 5-15 IN SET 2
	LPSW	IZRP3
IZRS3	LM	R0,IREG34		:INITIALIZE ALL REGS IN SET 3

:	THE NUMBER OF REGISTERS ACTUALLY USED DEPENDS ON THE NUMBER OF ASYNC
:	CARDS CONFIGURED ON THIS NODE, COUNTING DOWN FROM R15.

	LPSW	IZRP4
IZRS4	LM	R0,IREG34		:ALL REGS IN SET 4, SAME AS SET 3.
	LPSW	SVCPSW			:RETURN

IZRP1	WC	10,IZRS1
IZRP2	WC	20,IZRS2
IZRP3	WC	30,IZRS3
IZRP4	WC	40,IZRS4

::*********************************************************************
::
::	SVC14:		SVC	0F,SV.DTR
::	FUNCTION:	OUTPUT 16 BITS OF DATA TERMINAL READY
::	INPUT:		R1 = PORT GROUP INDEX (2 * PORT GROUP #)
::			R2 = DATA TO OUTPUT
::	DESTROYED:	R0
::
::*********************************************************************

SV.DTR  EQ      14
SVC14	STM	R14,SVCPSW		:SAVE RETURN PSW
	LHI	R0,00F0			:SET F, INTS DISABLED
	EPSR	R1,R0			:GO TO REG SET F
	LA	R0,ASYNDA+1,R1,R1	:CALC DEVICE ADDR
	WDR	R0,R2			:OUTPUT DATA IN R2
	LPSW	SVCPSW			:RETURN

::*********************************************************************
::
::	SVC15:		SVC	0F,SV.RTS
::	FUNCTION:	OUTPUT 16 BITS OF REQUEST TO SEND
::	INPUT:		R1 = PORT GROUP INDEX (2 * PORT GROUP #)
::			R2 = DATA TO OUTPUT
::	DESTROYED:	R0
::
::*********************************************************************

SV.RTS	EQ	15
SVC15	STM	R14,SVCPSW		:SAVE RETURN PSW
	LHI	R0,00F0			:SET F, INTS DISABLED
	EPSR	R1,R0			:GO TO REG SET F
	LA	R0,ASYNDA+2,R1,R1	:CALC DEVICE ADDR
	WDR	R0,R2			:OUTPUT DATA IN R2
	LPSW	SVCPSW			:RETURN

::*********************************************************************
::
::	SVC16:		SVC	0F,SV.PSR
::	FUNCTION:	INPUT 16 BITS OF DATA SET READY
::	INPUT:		R1 = PORT GROUP INDEX (2 * PORT GROUP #)
::	OUTPUT:		R2 = DATA READ
::	DESTROYED:	R0
::
::*********************************************************************

SV.PSR  EQ      16
SVC16	STM	R14,SVCPSW		:SAVE RETURN PSW
	LHI	R0,00F0			:SET F, INTS DISABLED
	EPSR	R1,R0			:GO TO REG SET F
	LA	R0,ASYNDA+1,R1,R1	:CALC DEVICE ADDR
	RDR	R0,R2			:INPUT DATA INTO R2
	LPSW	SVCPSW			:RETURN

::*********************************************************************
::
::	SVC17:		SVC	0F,SV.CP
::	FUNCTION:	INPUT 16 BITS OF CARRIER PRESENT
::	INPUT:		R1 = PORT GROUP INDEX (2 * PORT GROUP #)
::	OUTPUT:		R2 = DATA READ
::	DESTROYED:	R0
::
::*********************************************************************

SV.CP	EQ	17
SVC17	STM	R14,SVCPSW		:SAVE RETURN PSW
	LHI	R0,00F0			:SET F, INTS DISABLED
	EPSR	R1,R0			:GO TO REG SET F
	LA	R0,ASYNDA+2,R1,R1	:CALC DEVICE ADDR
	RDR	R0,R2			:INPUT DATA INTO R2
	LPSW	SVCPSW			:RETURN

::*********************************************************************
::
::	SVC18:		SVC	0F,SV.ESY
::	FUNCTION:	ENABLE ASYNC PORT
::	INPUT:		R14 = PORT #
::	DESTROYED:	R0,R1
::
::*********************************************************************

SV.ESY  EQ      18
SVC18	STM	R14,SVCPSW		:SAVE RETURN PSW
	LHI	R0,60F0
	EPSR	R1,R0			:GO TO REG SET F, INTERRUPTS ENABLED
	LR	R0,R14			:PORT NUMBER
	LR	R1,R14
	NHI	R0,0F			:PORT # MODULO 16
	NHI	R1,0F0			:PORT #/16
	AR	R1,R1			:X 2
	OR	R0,R1
	STH	R0,SBAFIX		:SBAFIX CONTAINS INDEX FOR THIS PORT'S
:	SBA EQUIVALENT IN REGISTER SET 3. EACH REGISTER IN SET 3 HOLDS THE
:	SBA/TAM DATA FOR 16 PORTS IN THE FORMAT SSSSTTTT, WHERE SSSS IS
:	THE SBA DATA, AND TTTT IS THE CORRESPONDING TAM INFORMATION.

	LHI	R0,030
	EPSR	R1,R0			:GO TO REG SET 3, INTERRUPTS DISABLED
	STM	10-2*NACARD,SBAFX	:STORE SBA/TAM DATA
	LH	R1,SBAFIX		:GET INDEX
	SBT	R1,SBAFX		:ENABLE SBA
	SBT	R1,SBAFX+2		:ENABLE TAM
	LM	10-2*NACARD,SBAFX
	LPSW	SVCPSW			:RETURN

::*********************************************************************
::
::	SVC19:		SVC	0F,SV.DSY
::	FUNCTION:	DISABLE ASYNC PORT
::	INPUT:		R14 = PORT #
::	DESTROYED:	R0,R1
::
::*********************************************************************

SV.DSY  EQ      19
SVC19	STM	R14,SVCPSW		:SAVE RETURN PSW
	LHI	R0,60F0
	EPSR	R1,R0			:GO TO REG SET F, INTERRUPTS ENABLED
	LR	R0,R14			:PORT NUMBER
	LR	R1,R14
	NHI	R0,0F			:PORT # MODULO 16
	NHI	R1,0F0			:PORT #/16
	AR	R1,R1			:X 2
	OR	R0,R1
	STH	R0,SBAFIX

:	SBAFIX CONTAINS THE INDEX FOR THIS PORT'S
:	SBA EQUIVALENT IN REGISTER SET 3. EACH REGISTER IN SET 3 HOLDS THE
:	SBA/TAM DATA FOR 16 PORTS IN THE FORMAT SSSSTTTT, WHERE SSSS IS
:	THE SBA DATA, AND TTTT IS THE CORRESPONDING TAM INFORMATION.

	LHI	R0,030
	EPSR	R1,R0			:GO TO REG SET 3, INTERRUPTS DISABLED
	STM	10-2*NACARD,SBAFX	:STORE SBA/TAM DATA
	LH	R1,SBAFIX		:GET INDEX
	RBT	R1,SBAFX		:DISABLE SBA
	LM	10-2*NACARD,SBAFX
	LPSW	SVCPSW			:RETURN

:	STORAGE FOR SVC18 AND SVC19
SBAFIX	HS	1			:INDEX INTO SBAFX
SBAFX	HS	NACARD*4		:STORAGE FOR SBA/TAM REGS
	SYAD(SBAFX ,1)
	
::*********************************************************************
::
::	SVC1A:		SVC	0F,SV.PRT
::	FUNCTION:	OUTPUT DATA TO A PRINTER.
::		Does its thing in set F, un-mac'd, but with interrupts enabled.
::	LINKSON:Saved PSD at SVC1AR.  Called by FLUSHP (ASYNC).
::	INPUT:		R9 = POINTER (SEG0 MAC'D) TO START OF BUFFER,
::				FIRST HW OF BUFFER CONTAINS BYTE COUNT.
::			R14(PN) = PORT NUMBER
::	OUTPUT:		R2 = STATUS (0 MEANS OK)
::	DESTROYED:	R3, R4, R2, R0
::
::	NOTE - EXECUTES IN SET F WITH INTERRUPTS ENABLED, MAC OFF.
::
::*********************************************************************

SV.PRT	EQ	1A
PRNDA	EQ	60			:DEVICE ADDR OF PRINTER
SVC1AR	HS	4			:STORAGE FOR RETURN PSW

SVC1A	HS	0			:Enter here
	STM	R14,SVC1AR		:SAVE RETURN PSD
	LHI	R0,6AF0			:WANT TO GO TO SET F WITH
	EPSR	R1,R0			:INTERRUPTS ENABLED BUT MAC OFF
	LHI	R4,PRNDA,PN		:R4=PRINTER DEVICE ADDRESS
	RDR	R4,R2			:CHECK PRINTER STATUS, old printer card
					:does not set CC so check status in R2
	LR	R2,R2			:R2=PRINTER STATUS
	JEFS	SVC1A0			:OK IF 0
	SBT	PN,PHFFLS,,		:Turn off forced flush flag, was it on?
	GL	PHFFLS
	JNFS	SVC1AF			:No, force flush not requested

:	FORCED FLUSH, PRETEND EVERYTHING OK.
	LIS	R2,0			:R2=STATUS OK
	STH	R2,S0PH,R9,		:R9=POINTER TO BUFFER, RESET COUNT
SVC1AF	HS	0		:FAILED, PRINTER NOT READY, or forced flush
	LPSW	SVC1AR			:RETURN WITH APPROPRIATE STATUS IN R2

SVC1A0	HS	0		:STATUS OK, check buffer contents
	LHL	R3,S0PH,R9,		:BUFFER BYTE COUNT
	JEBS	SVC1AF			:BUFFER EMPTY, return

SVC1A7	HS	0		:Status OK, buffer not empty, let's print
	STH	R2,S0PH,R9,		:MARK PRINTER BUFFER EMPTY
	SBT	PN,PHFLSH,,		:AND OUTPUT COMPLETE
	GL	PHFLSH
	AHI	R9,2,R3			:R9 NOW POINTS PAST LAST CHAR IN BUFFER
	SR	R2,R3			:NEGATIVE INDEX (R2=0)

SVC1A1	HS	0		:START OF OUTPUT LOOP
	LB	R3,S0PH,R9,R2		:GET A CHARACTER
	JEFS	SVC1A2			:EOL (0), go do write
	THI	R3,80			:DATA WILL HAVE THIS BIT SET
	JEFS	SVC1A3			:SOMETHING SPECIAL
	WDR	R4,R3			:OUTPUT CHAR.
SVC1AG	AIS	R2,1			:BUMP NEGATIVE INDEX
	JLBS	SVC1A1			:CONTINUE TILL DONE

SVC1A2	HS	0		:DONE WITH BUFFER, EITHER EXHAUSTED OR EOL (0)
	LHI	R3,8000			:PRINT COMMAND
	WDR	R4,R3			:SEND IT
	LPSW	SVC1AR			:RETURN (NOTE, R2=0 MEANS STATUS OK)

SVC1A3	HS	0		:HANDLE NON-DATA, non-EOL CHARACTER
	CLHI	R3,40			:What kind? R3 now a compression count.
	JLFS	SVC1A5			:BLANK COMPRESSION, most likely
	JGFS	SVC1A4			:Character compression

	HC	0		:ISIS treats R0=40 as a form-feed command,
				:but as far as I can tell, we can't get 
				:here, so crash.

SVC1A5	HS	0		:BLANK COMPRESSION
	LHI	R0,20			:ASCII BLANK

SVC1A6	HS	0		:PUT A BLANK OR CHARACTER
	WDR	R4,R0	
	SIS	R3,1			:SLIP COUNT
	JGBS	SVC1A6			:TILL DONE
	J	SVC1AG			:NEXT CHAR.

SVC1A4	HS	0		:CHARACTER COMPRESSION
	LB	R0,S0PH-1,R9,R2		:GET PREVIOUS BYTE
	JBS	SVC1A6

	EI	:SOLOCS

::*********************************************************************
::
::	SVC1B:		SVC	0F,SV.WEN
::	FUNCTION:	GIVES THE REMOTE X-RAY USER SEG1 WRITE ACCESS
::			AND MAPS PHYSICAL ADDRESS 0 INTO A0000
::
::*********************************************************************

SV.WEN  EQ      1B
SVC1B	STM	R14,SVCPSW		:SAVE RETURN
	LM	MRN,AXMACR
	STM	MRN,MACREG		:OUTPUT TO MAC
	STM	MRN,ANMACR		:AND TO NODE MAC REGS IN CASE DISMISSED
	LM	R14,SVCPSW		:RETURN TO CALLER
	LPSWR	R14

::*********************************************************************
::
::	SVC1C:		SVC	0F,SV.WOF
::	FUNCTION:	RESTORES SEG1 WRITE PROTECT
::
::*********************************************************************

SV.WOF  EQ      1C
SVC1C	STM	R14,SVCPSW		:SAVE RETURN
	LM	MRN,ANODMC		:GET NODE MAC REGGIES
	STM	MRN,MACREG		:OUTPUT TO MAC
	STM	MRN,ANMACR		:AND TO NODE MAC REGISTER AREA
	LM	R14,SVCPSW		:RETURN TO CALLER
	LPSWR	R14

::*********************************************************************
::
::	SVC1D:		SVC	0F,SV.SIR
::	FUNCTION:	SEND COMMANDS TO SIO RING CARD.
::	INPUT:		COMMAND IS IN R0 OF SET F.
::			ADDRESS IS IN R1 OF SET F.
::	RETURNS:	IF SIO RING CARD IS BUSY, SKIP RETURN.
::
::*********************************************************************

	IF	SIORNG

SV.SIR	EQ	1D
SVC1D	HS	0
	LHI	R0,0F0
	EPSR	R1,R0			:SWITCH TO REG SET F
	STH	R0,SVCCHR		:SAVE USER'S REG 0
	STH	R1,SVCCHR+2		: AND REG 1
	LPSW	SIRCP			:BACK TO REG SET 0
SIRCP	WC	0,SIRCA			:PSW TO BRANCH TO SIRCA IN SET 0,
					: INTERRUPTS OFF
SIRCA	LHI	R0,SIORNG		:SIO RING CARD DEVICE ADDRESS
	SSR	R0,R1			:SENSE STATUS,CAN'T OUTPUT IF CARD BUSY
	JFFS	8,SIROK			:NOT BUSY
	AIS	R15,4			:SET UP SKIP RETURN AND
	LPSWR	R14			: DO IT
SIROK	HS	0			:SIO RING CARD IDLE - OUTPUT COMMAND
	LH	R2,SVCCHR		:DEVICE ADDRESS + COMMAND
	LH	R3,SVCCHR+2		:QUAD-WORD ADDRESS IF ACTIVATE COMMAND
	WDR	R2,R3			:OUTPUT TO SIO RING CARD
	LPSWR	R14			:NON-SKIP RETURN
	EI	:SIORNG

::*********************************************************************
::
::	SVC1E:		SVC	0F,SV.SMI
::	FUNCTION:	SEND SIO M-BOARD AN INTERRUPT-REQUEST I/O CMD (TYPE 8)
::	INPUT:		USER R0 CONTAINS 2*LINE NUMBER,
::			R1 CONTAINS INTERUPT KEY
::
::*********************************************************************

SV.SMI  EQ      1E
SVC1E	HS	0
	IF	SILINS
	JAL	R5,SIOCOM		:ENSURE MUX BUS INTERFACE NOT BUSY
	OI	R0,8000			:OR IN INTERRUPT COMMAND
	J	SVC0DA			:OUTPUT COMMAND
	EI	:SILINS

::*********************************************************************
::
::	SVC1F:		SVC	0F,SV.SR4
::	FUNCTION:	Save register set 4 at SVC1FV
::	This is bogus--used by MC instruction and PA instruction,
::		neither of which really work. ###jhl
::
::*********************************************************************

SV.SR4  EQ      1F
SVC1F	STM	R14,SVCPSW
	LPSW	SVC1FA
SVC1FB	STM	R0,SVC1FV
	LPSW	SVCPSW
SVC1FV	WS	10
SVC1FA	WC	40,SVC1FB		:GO TO REG SET 4

	IF	ZITEL		:FOR ZITEL TRACE/STOP

::*********************************************************************
::
::	SVC20:		SVC	0F,SV.TCW
::	FUNCTION:	TO SET TRACE CONDITONS (R5) IN TRACE CONTROL WORD (350)
::			AND TO SET UP LOWER AND UPPER ADDRESS RANGES
::			(R10 AND R11 TO 354 AND 358, RESPECTIVELY).
::
::*********************************************************************

SV.TCW	EQ	20
SVC20	HS	0
	STM	R14,SVCPSW		:**0**store return PSW
	LHI	R0,0F0			:**0**prepare to read SET F regs
	EPSR	R1,R0			:**0**puts us in REG SET F
	ST	R5,MCTRCW		:**F**store TRACE CTRL word
	ST	R10,MCLTBD		:**F**store lower addr bound
	ST	R11,MCUTBD		:**F**store upper addr bound
	LIS	R5,0			:**F**init R5 for trace enable bit
	SBT	R5,MCTRCW		:**F**set bit 0 in trace ctrl word
					:	(trace enable)
	LPSW	SVCPSW			:**F**return to caller

::*********************************************************************
::
::	SVC21:		SVC	0F,SV.TCC
::	FUNCTION:	TO CLEAR TRACE CONDITONS IN TRACE CONTROL WORD (350)
::	AND IN LOWER AND UPPER ADDRESS RANGES (354 AND 358, RESPECTIVELY).
::
::*********************************************************************

SV.TCC	EQ	21
SVC21	HS	0
	STM	R14,SVCPSW		:**0**store return PSW
	LHI	R0,0F0			:**0**prepare to read SET F regs
	EPSR	R1,R0			:**0**puts us in REG SET F
	ST	R5,MCTRCW		:**F**store TRACE CTRL word
	ST	R10,MCLTBD		:**F**store lower addr bound
	ST	R11,MCUTBD		:**F**store upper addr bound
	LPSW	SVCPSW			:**F**return to caller

	EI	:ZITEL

::*********************************************************************
::
::	SVC22:		SVC	0F,SV.SAS
::	FUNCTION:	STORES THE REGISTER SET SPECIFIED IN R0 OF SET F
::		INTO ABSSAV IN SEG 0 FOR READING BY XRAY 'RG' COMMAND.
::
::*********************************************************************

SV.SAS  EQ      22
SVC22	HS	0
	STM	R14,SVCPSW
	LHI	R0,0F0			:GO TO SET F
	EPSR	R1,R0
	ST	R0,SVCCHR		:GET REG SET NO.
	LPSW	SVC22R			:RETURN TO SET 0, INTS DISABLED
SVC22R	WC	0,SVC22A
SVC22A	HS	0
	L	R0,SVCCHR		:GO TO REQUESTED REG SET
	SLLS	R0,4			:SHIFT INTO POSITION IN PSW
	EPSR	R1,R0			:INTERRUPTS STILL DISABLED
	STM	R0,PHABSV,,		:STORE IN SEG 0 AREA
	GL	PHABSV
	LPSW	SVCPSW			:RETURN

::*********************************************************************
::
::	SVC23:		SVC	0F,SV.WFA
::	FUNCTION:	WRITE FW FROM USER'S R3 INTO ABS ADDRESS IN R11
::
::**********************************************************************

SV.WFA	EQ	23
SVC23	HS	0
	STM	R14,SVCPSW
	LHI	R0,0F0
	EPSR	R1,R0
	ST	R3,0,R11
	LPSW	SVCPSW

::*********************************************************************
::
::	SVC24:		SVC	0F,SV.WHA
::	FUNCTION:	WRITE HW FROM R3 (SET F) INTO ABS ADDRESS IN R11
::
::*********************************************************************

SV.WHA	EQ	24
SVC24	HS	0	
	STM	R14,SVCPSW
	LHI	R0,0F0
	EPSR	R1,R0
	STH	R3,0,R11
	LPSW	SVCPSW

	IF	ZITEL	:Following are used by QE to read semi-mem errlog

::*********************************************************************
::
::	SVC25:		SVC	0F,SV.SSR
::	FUNCTION:	Sense Status Register
::			Used by QE to read semi-mem errlog
::
::*********************************************************************

SV.SSR	EQ	25
SVC25	HS	0
	STM	R14,SVCPSW		:**0**store return PSW
	LHI	R0,0F0			:**0**for reg set F in privileged mode
	EPSR	R1,R0			:**0**puts us in REG SET F
	SSR	R1,R3			:**F**execute privileged cmd 
	LPSW	SVCPSW			:**F**return to caller

::*********************************************************************
::
::	SVC26:		SVC	0F,SV.WDR
::	FUNCTION:	Write Data Register
::			Used by QE to read semi-mem errlog
::
::*********************************************************************
SV.WDR	EQ	26
SVC26	HS	0
	STM	R14,SVCPSW		:**0**store return PSW
	LHI	R0,0F0			:**0**for reg set F in privileged mode
	EPSR	R1,R0			:**0**puts us in REG SET F
	WDR	R1,R3			:**F**execute privileged cmd 
	LPSW	SVCPSW			:**F**return to caller

::*********************************************************************
::
::	SVC27:		SVC	0F,SV.RDR
::	FUNCTION:	Read Data Register
::			Used by QE to read semi-mem errlog
::
::*********************************************************************

SV.RDR	EQ	27
SVC27	HS	0
	STM	R14,SVCPSW		:**0**store return PSW
	LHI	R0,0F0			:**0**for reg set F in privileged mode
	EPSR	R1,R0			:**0**puts us in REG SET F
	RDR	R1,R3			:**F**execute privileged cmd 
	LPSW	SVCPSW			:**F**return to caller

::*********************************************************************
::
::	SVC28:		SVC	0F,SV.OCR
::	FUNCTION:	Output Command Register
::			Used by QE to read semi-mem errlog
::
::*********************************************************************

SV.OCR	EQ	28
SVC28	HS	0
	STM	R14,SVCPSW		:**0**store return PSW
	LHI	R0,0F0			:**0**for reg set F in privileged mode
	EPSR	R1,R0			:**0**puts us in REG SET F
	OCR	R1,R3			:**F**execute privileged cmd 
	LPSW	SVCPSW			:**F**return to caller

	EI	:ZITEL

::*********************************************************************
::
::	SVC29:	New trapdoor SVC ###tz (unimplemented)
::
::*********************************************************************

	IF	NEWTRP

TR.SEQ	HS	1		:SEQUENCE NO. OF NEXT TRAP TO SPRING

Q	EQ	.
	ORG	0
TR.ADR	HS	2		:TRAP ADDRESS
TR.INS	HS	2		:TRAP INSTRUCTION TO BE RESTORED
TR.CNT	HS	1		:REPEAT COUNT
TR.XD	HS	1		:POINTER TO USER'S XRAY BLOCK
TR.SIZ	EQ	.-TR.ADR	:SIZE OF TRAP BLOCK

	ORG	0
TR.NDX	HS	1		:TRAP INDEX
TR.PC	HS	2		:TRAP ADDRESS
TR.PSW	HS	2		:TRAP PSW
TR.SQN	HS	1		:TRAP SEQUENCE NUMBER
TR.COU	HS	1		:TRAP REPEAT COUNT
TR.TIM	HS	2		:TRAP TIME (FASTC)
TR.REG	HS	20		:REGGIE SAVE AREA
TR.SZE	EQ	.-TR.NDX	:SIZE OF TRAP SAVE AREA
TR.PSD	HS	4		:TRAP RETURN PSD
	ORG	Q

TR.BLK	BS	4*TR.SIZ

SVC29	HS	0
	SIS	R15,4			:BACK UP PC TO TRAP LOCATION
	LIS	R2,0			:INDEX TO LOCATE TRAP
SVC29A	HS	0
	C	R15,TR.BLK+TR.ADR,R2	:MATCH TRAP ADDRESS
	JEFS	SVC29B			:FOUND MATCH

	CLHI	R2,(TR.BSZ-TR.SIZ)	:LAST ONE?
	JEFS	SVC29B			:YES, MUST BE IT

	AHI	R2,TR.SIZ		:TRY AGAIN
	JBS	SVC29A

SVC29B	HS	0
	STM	R14,PHTRSV+TR.PSD,,	:SAVE RETURN ADDRESS
	LHL	R3,TR.SEQ
	STH	R3,PHTRSV+TR.SQN,,	:SEQUENCE NUMBER
	AIS	R3,1			:BUMP SEQUENCE COUNT
	STH	R3,@@@TZ

	EI	:NEWTRP

::*********************************************************************
::
::	SVC30:		SVC	0F,SV.REG
::	FUNCTION:	Refreshes registers to prevent degrading.
::		Called by G04MIN.  Reloads a CPU register set and every
::		sixteenth time reloads the MAC register set.  When called
::		every 4 min. all registers will be reloaded once every 64 min.
::
::*********************************************************************

SV.REG	EQ	30
SVC30	HS	0
	STM	R14,SVCPSW	:*0*store return PSW
	LH	R2,NXTREG	:*0*Load next CPU register set number
	AHI	R2,10		:*0*Increment
	NHI	R2,0F0		:*0*Mask for wrap
	STH	R2,NXTREG	:*0*Save for next time
	EPSR	R1,R2		:*0*Load PSW, go to reg set n, ints disabled
	STM	R0,HLDCPU	:*n*Save all CPU registers
	LH	R1,NXTREG	:*n*Load the set number again
	JN	SVC30A		:*n*refresh MAC registers every 16th time
	LM	R0,300		:*n=0*Load all MAC registers to CPU registers
	STM	R0,300		:*n=0*And then put them back
SVC30A	LM	R0,HLDCPU	:*n*Reload all of our CPU registers
	LPSW	SVCPSW		:*f*Switch back PSW, return to caller

:	DEFINE STORAGE
NXTREG	HS	1		:Save area for next register set number
HLDCPU	HS	20		:Save area for CPU registers

::*********************************************************************
::
::	SKSVDS:	SVC Dispatch Table
::
::*********************************************************************

SKSVDS	HS	0
SVQLOC	EQ	.
	HC	SVC00,SVC01,SVC02,SVC03,SVC04,SVC05,SVC06,SVC07

	IF	SILINS
	HC	SVC08,SVC09,SVC0A,SVC0B,SVC0C,SVC0D,SVC0E,SVC0F
	ELSE	:NOT SILINS
	HC	SVC08,SVC09,SVC0A,SVC0B,SVCXX,SVCXX,SVCXX,SVCXX
	EI	:SILINS

	HC	SVC10,SVC11,SVC12

	IF	SOLOCS
	HC	SVC13,SVC14,SVC15,SVC16,SVC17,SVC18,SVC19,SVC1A
	ELSE	:NOT SOLOCS
	HC	SVCXX,SVCXX,SVCXX,SVCXX,SVCXX,SVCXX,SVCXX,SVCXX
	EI	:SOLOCS

	HC	SVC1B,SVC1C

	IF	SIORNG
	HC	SVC1D
	ELSE	:NOT SIORNG
	HC	SVCXX
	EI	:SIORNG

	HC	SVC1E,SVC1F

	IF	ZITEL		:FOR ZITEL TRACE/STOP
	HC	SVC20,SVC21
	ELSE	:NOT ZITEL
	HC	SVCXX,SVCXX
	EI	:ZITEL

	HC	SVC22,SVC23,SVC24

	IF	ZITEL
	HC	SVC25,SVC26,SVC27,SVC28
	ELSE	:NOT ZITEL
	HC	SVCXX,SVCXX,SVCXX,SVCXX
	EI	:ZITEL

	IF	NEWTRP
	HC	SVC29
	ELSE	:NOT NEWTRP
	HC	SVCXX
	EI	:NEWTRP

	HC	SVC30

	NOLIST
	RE	MAXSVC+1-((.-SVQLOC)/2)
	HC	SVCXX
	ER
	LIST

	SUBTTL	SHARE (TTY Interrupt routines)

::*********************************************************************
::
::	TTY INTERRUPT ROUTINES:
::
::	THE TELETYPE CARD IS A SORT OF HALF-DUPLEX DEVICE -IT'S EITHER
::	SENDING OR RECEIVING, BUT NOT BOTH.
::	ENTRY POINTS:	TTYINT	ON INTERRUPT
::			TVINT	INPUT OR RECEIVE MODE
::			TXINT	OUTPUT OR TRANSMIT MODE
::
::*********************************************************************

TTYINT	HS	0		:ENABLE ASYNC MICROCODE INTERRUPTS
	LHI	R4,6200
	EPSR	R5,R4
	SSR	R2,R3			:TEST FOR BREAK
	THI	R3,20
	JNFS	TVIN2			:YES, RESTART XRAY
	LHL	R3,TTYIAD		:DISPATCH TO HANDLER
	JR	R3

TVINT	HS	0		:RECEIVE MODE - READ CHARACTER
	RDR	R2,R4
	NHI	R4,7F
	CLHI	R4,3			:IF ^C, RESTART XRAY
	JN	TVIN1			:NO

TVIN2	LM	R14,AXIPSW		:BREAK, GET INITIAL XRAY PSW
	STM	R14,AXCPSW		:AND STORE INTO CURRENT PSW
	LIS	R3,0		
	STH	R3,AXFLGS		:MAKE SURE XRAY IS CLEARED TO RUN
	TS	PHXBRK,,		:SUSPEND CRYPTO OUTPUT FOR 8 SEC
	GL	PHXBRK
	J	TXINT1

TVIN1	LHL	R3,TVNTIP		:PUT IT AWAY
	STB	R4,TVNTBF,R3
	AIS	R3,1			:INC PTR
	NHI	R3,TVNBSZ-1
	STH	R3,TVNTIP
	LH	R3,FASTC+2		:SET TRANSMITTAL TIME
	AIS	R3,8			:IT'S CURRENT TIME + 8/600
	STH	R3,TVNTWC
	LPSWR	0

TXINT	HS	0		:TRANSMIT MODE...COUNTING DOWN CARRIAGE RETURN?
	LHL	R4,CARDLY
	JEFS	TXINT2			:NO, OUTPUT NON-CR CHARACTER
	SIS	R4,1			:DECREMENT CR-DELAY COUNT
	STH	R4,CARDLY
	LIS	R4,0			:AND OUTPUT AN ASCII NULL TO TTY
	J	TXINT3

TXINT2	LHL	R3,TXNTOP		:TRANSMIT MODE - IS RING OUTPUT POINTER
	CLH	R3,TXNTIP		: EQUAL TO RING INPUT POINTER?
	JE	TXINT1			:YES, RING EMPTY.  RESTORE RECEIVE MODE

	LB	R4,TXNTBF,R3		:NO,GET NEXT CHARACTER
	AIS	R3,1			:INCREMENT RING OUTPUT POINTER
	NHI	R3,TXNBSZ-1
	STH	R3,TXNTOP
	LHL	R3,AXFLGS		:CLEAR THE WAIT FLAG
	NHI	R3,@OUTWTF
	STH	R3,AXFLGS

TXINT3	WDR	R2,R4			:OUTPUT CHARACTER TO TTY
	SIS	R4,0D			:SET CR DELAY IF NEEDED
	JNFS	.+8			:NOT NEEDED
	LIS	R4,2			:ALLOW 2 CHARACTERS OF CR DELAY
	STH	R4,CARDLY
	LPSWR	R0			:RETURN

TXINT1	LA	R3,TVINT		:RESTORE INPUT MODE
	STH	R3,TTYIAD
	OC	R2,TVNCLR		:CLEAR PENDING INTS
	OC	R2,TVNRCV
	LHL	R3,TXNTIP		:CLEAR OUTPUT BUFFER
	STH	R3,TXNTOP
	LPSWR	0			:ALSO USED FOR ILLEGAL INTERRUPTS

	SUBTTL	SHARE (Context Switcher)

::*********************************************************************
::
::	CONTEXT SWITCHER:
::
::	THIS SECTION SWITCHES CONTROL AMONG THE NODE CODE
::	(ALPHA NODE), THE LOCAL DEBUGGER (XRAY), AND THE KERNEL.
::	ANY OF THE THREE SECTIONS OF CODE MAY BE SHUT OFF
::	BY SETTING ITS ACTIVE FLAG (E.G. AXFLGS) TO A NONZERO VALUE.
::
::	WHEN A SECTION IS ENTERED, THE ADDRESS TO GO TO WHEN
::	IT IS DONE RUNNING IS STORED AT USRRET. A SECTION
::	RUNS UNTIL EITHER IT DISMISSES ITSELF OR UNTIL IT
::	USES UP ITS TIME SLICE. THUS EITHER THE CLOCK HANDLER
::	OR THE DISMISS SVC WILL BRANCH TO ANRET, AXRET, OR
::	KRRET WHEN CONTROL IS TO BE SWITCHED TO ANOTHER
::	SECTION. THE 'USER' PSW AND REGISTERS ARE SAVED
::	IN THE USER BLOCK SO THEY CAN BE RESTORED FOR THE NEXT TIME
::	SLICE.
::
::*********************************************************************

:	ANCALL:	RUN THE NODE CODE

ANCALL	HS	0		:RUN THE NODE CODE
	LHL	R0,ANFLGS
	JN	IDCALL			:SKIP IF NODE CODE DISABLED.
	L	R0,ANRSL		:SET TIME SLICE AND PLACE TO
	ST	R0,USRRET		: GO WHEN IT IS UP
	LM	MRN,ANMACR		:SET UP MAC REGISTERS
	STM	MRN,MACREG
	IF	SOLOCS
	IF	SVCCXT
	LM	R14,ANSVCP		:get SVCPSW from before in case int'ed
	STM	R14,SVCPSW		: in middle of an SVC		###jhl
	EI	:SVCCXT
	IF	(BAUDR-1)		:IF 4800 BAUD TYMSAT
:	this seems bad--what is going on?	???jhl
	LHI	R0,0F0
	EPSR	R1,R0			:GO TO SET F (disables I/O ints ???jhl)
	EI	(BAUDR-1 4800 TYMSAT)
	EI	:SOLOCS
	LM	R0,ANREG		:GET NODE REGISTERS
	LPSW	ANCPSW			:AND GO

ANRET	ST	R0,ANCPSW	:COME HERE WHEN TIME SLICE IS UP
	ST	R1,ANCPSW+4		:SAVE PSW FOR NEXT TIME
	LHI	R0,0F0			:GO TO REG SET F
	EPSR	R1,R0
	STM	R0,ANREG		:SAVE NODE REGISTERS
	IF	SOLOCS
	IF	SVCCXT
	LM	R14,SVCPSW		:save SVCPSW in case int'ed
	STM	R14,ANSVCP		: in middle of an SVC	###jhl
	EI	:SVCCXT
	IF	(BAUDR-1)		:IF 4800 BAUD TYMSAT
	LHI	R0,4000			:GO TO SET 0 WITH INTERRUPTS ON
	EPSR	R1,R0
	EI	(BAUDR 4800 TYMSAT)
	EI	:SOLOCS

:	AXCALL:	RUN XRAY

AXCALL	HS	0		:RUN XRAY
	LHL	R0,AXFLGS
	JN	ANCALL			:XRAY IN WAIT STATE, RUN NODE CODE
	L	R0,AXRSL
	ST	R0,USRRET

:	SET UP MACHINE MALFUNCTION INTERRUPT VECTOR FOR NODE CODE
:	INTERCEPT IN CASE KERNEL CHANGED IT.

	IF	KERNEL
	LM	R14,MLNPSW
	STM	R14,KRMMSV		:SAVE POSSIBLE KERNEL ROUTINE ADDRESS
	LM	R14,XRMMVC
	STM	R14,MLNPSW		:STORE X-RAY MACHINE MALFUNCTION VECTOR
	EI	:KERNEL

	LM	MRN,AXMACR		:restore user registers
	STM	MRN,MACREG
	IF	SOLOCS
	IF	SVCCXT
	LM	R14,AXSVCP		:get SVCPSW from before in case int'ed
	STM	R14,SVCPSW		: in middle of an SVC		###jhl
	EI	:SVCCXT
	IF	(BAUDR-1)		:IF 4800 BAUD TYMSAT
	LHI	R0,0F0			:go to set F
	EPSR	R1,R0
	EI	(BAUDR-1 4800 TYMSAT)
	EI	:SOLOCS
	LM	R0,AXREG		:GET XRAY REGISTERS
	LPSW	AXCPSW			:AND GO TO XRAY

AXRET	ST	R0,AXCPSW	:COME HERE WHEN TIME SLICE IS UP
	ST	R1,AXCPSW+4
	LHI	R0,0F0			:GO TO SET F
	EPSR	R1,R0
	STM	R0,AXREG		:SAVE XRAY REGISTERS
	IF	SOLOCS
	IF	SVCCXT
	LM	R14,SVCPSW		:sav SVCPSW in case int'ed
	STM	R14,AXSVCP		: in middle of an SVC		###jhl
	EI	:SVCCXT
	IF	(BAUDR-1)		:IF 4800 BAUD TYMSAT
	LHI	R0,4000			:GO TO SET 0 WITH INTERRUPTS ON
	EPSR	R1,R0
	EI	(BAUDR-1 4800TYMSAT)
	EI	:SOLOCS

	IF	KERNEL
	LM	R14,KRMMSV
	STM	R14,MLNPSW	:RESTORE PREVIOUS MACHINE MALFUNCTION VECTOR
	EI	:KERNEL

	J	ANCALL

:	KRCALL:	CALL THE KERNEL

KRCALL	HS	0		:CALL THE KERNEL (REACHED VIA SVC 0F,4)
	LHL	R0,KRFLGS
	JN	AXCALL			:KERNEL NOT PRESENT OR DISABLED
	L	R0,KRRSL		:THE USUAL
	ST	R0,USRRET
	LA	R0,SVCXX		:DISABLE NODE/XRAY SVC'S
	STH	R0,FSVCST
	JR	R2

KRRET	J	KND,,		:KERNEL WILL SAVE STATUS
	GL	KND
KNDR	LHI	R0,62F0			:SET REG SET F
	EPSR	R1,R0
	LA	R0,SKSVC		:RESTORE NODE/XRAY SVC'S
	STH	R0,FSVCST
	J	AXCALL			:AND CALL XRAY

:	IDCALL:	IDLE

IDCALL	HS	0		:IDLE FOR 1/600 SEC
	L	R0,IDRSL
	ST	R0,USRRET
	LHI	R0,62F0
	EPSR	R1,R0
	J	.

IDRET	LHI	R0,02F0		:RETURN TO REG SET F
	EPSR	R1,R0
	J	AXCALL

	SUBTTL	SHARE (Hardware Faults)

::*********************************************************************
::
::	ILINST:	ILLEGAL INSTRUCTION INTERRUPT
::
::*********************************************************************

:	LILARY:	ARRAY OF FFx BITS ONE FOR EACH POSSIBLE OP CODE.
:		1-BIT MEANS LEGAL OP CODE.

LILARY	HC	7FFF,0FE8C,0FF00,5FFB,0FFFC,0CFFC,4000,1F00,0
	HC	0FC76,0,0,3FFC,0FC22,0C23E,1FF0

:	LIRTRY:	ARRAY OF BITS REPRESENTING INSTRUCTIONS THAT
:		MAY BE RETRIED ON ILLEGAL INSTR INTERRUPT.
:	NOTE:	ENHANCED MICRO INSTRUCTIONS ARE MASKED OUT BECAUSE
:		IT IS POSSIBLE SOME OF THEM MAY GENERATE I/I INT'S
:		DURING EXECUTION. THIS TO BE INVESTIGATED.

LIRTRY	HC	7FFC,0E08C,0FF00,5800,0FFFC,0CFFC,4000,1F00,0
	HC	0FC76,0,0,3FFC,0FC22,0C23E,1FF0

:	ILLEGAL INSTRUCTION INTERRUPT HANDLING -
:
:	WHEN WE TAKE AN ILLEGAL INSTRUCTION INTERRUPT, WE IMMEDIATELY
:	SAVE THE SET 0 REGISTERS AT ERREG0 FOR LATER STORING IN THE
:	CRASH TABLE IF WE CRASH.  WE THEN CHECK TO SEE IF THE FAULT PC
:	IS IN FACT POINTING TO A BAD OP CODE.  IF THE OP CODE IS GOOD,
:	WE CHECK TO SEE IF IT HAPPENED WHILE WE WERE IN SET 0.  IF NOT
:	WE CHECK TO SEE IF WE'VE HAD AN ILLEGAL INSTRUCTION INTERRUPT
:	ALREADY IN THE LAST 4 MINUTES.  IF NOT, WE RETRY THE INSTRUCTION
:	WHICH SHOULD EITHER SUCCEED OR GENERATE ANOTHER ILLEGAL
:	INSTRUCTION INTERRUPT.  IF IT IS THE SECOND INTERRUPT WITHIN 4
:	MINUTES,

ILINST	HS	0		:HANDLE ILLEGAL INSTRUCTION INTERRUPT
	STM	R0,PHERG0		:SAVE SET 0 REGGIES.
	STM	R14,PHILIP,,		:SAVE USER PSD
	GL	PHILIP
	LR	R2,R15			:GET THE USER PC TO R2
	EXHR	R3,R2			:GET SEGMENT NUMBER TO LO HW OF R3
	LHR	R3,R3
	NI	R2,0FFFF
	SLLS	R3,2			:FW INDEX
	L	R1,300,R3		:GET SEGMENTATION REGISTER TO R1
	NI	R1,0FFF00		:ISOLATE PHYSICAL ADDRESS
	AR	R2,R1			:ADD IN OFFSET
	LB	R1,0,R2
	TBT	R1,LILARY		:SEE IF LEGAL
	JE	LIL01			:BRANCH IF NO
	LIS	R0,1			:BUMP COUNT OF OCCURENCES
	AHM	R0,PHLILC,,
	GL	PHLILC
	JG	LIL02			:CRASH IF TOO MANY
	TBT	R1,LIRTRY		:OTHERWISE SEE IF WE CAN RETRY IT?
	JEFS	LIL05			:NO, ENHANCED MICRO INSTR.
	LPSW	PHILIP			:GET USER PSW AND TRY IT AGAIN
LIL05	LHI	R0,0641		:SPURIOUS ILLEGAL INSTR ON ENHANCED INSTR.
	JFS	LIL03
LIL02	LHI	R0,0241		:LEGAL ILLEGAL INSTRUCTION > ONCE = 0241
	JFS	LIL03
LIL01	LHI	R0,0240		:ILLEGAL INSTR - MEMORY BAD = 0240
	JFS	LIL03

LIL03	HS	0
	LM	R14,PHILIP,,		:GET USER PSD

ILINS1	HS	0
	THI	R14,100			:TEST PRIVILEGED MODE BIT OF FAULT PSW
	JE	ANERNT			:WE WERE IN PRIVILEGED MODE, LET NODE
					: CODE HANDLE
	LHL	R3,USRRET
	CLHI	R3,KRRET		:WAS KERNEL RUNNING?
	JE	KRERNT			:BRANCH IF YES
	CLHI	R3,ANRET		:WAS NODE CODE RUNNING?
	JE	ANERNT			:JUMP TO NODE CODE CRASH HANDLER
	CLHI	R3,AXRET		:NO, WAS IT XRAY?
	JE	AXERNT			:BRANCH IF YES

:	IF HERE, NOBODY TOOK CREDIT FOR BEING IN CHARGE. HALT THE NODE.

	STB	R0,ILLHLT+7		:STORE CRASH CODE AS IT WOULD HAVE BEEN
	LPSW	ILLHLT			:NO, HALT NODE WITH WAIT-BAR AND '4F'

::*********************************************************************
::
::	ILLDEV: GETS CONTROL WHEN AN ILLEGAL I/O INTERRUPT HAS OCCURRED,
::		SUCH AS AN INTERRUPT FROM A NON-ACTIVE SYNC LINE.
::
::*********************************************************************

ILLDEV	HS	0
	STM	R0,PHERG0		:I/O INT HAS RETURN PSW IN R0 & R1
	LIS	R7,0
	STH	R2,PHILDA,,		:SAVE OFFENDING DEVICE ADDRESS
	GL	PHILDA
	STB	R2,IDHPSW+7		:STORE IN HALTPSW, SUBJECT TO EVENNESS
	L	R8,SLOWC		:IGNORE SPURIOUS INTERRUPTS WHICH OCCUR
	CLHI	R8,3			: WITHIN 3 SECONDS AFTER NODE STARTS
	JGEFS	ILLDV2
ILLDV0	LPSWR	R0			:INTERRUPT QUEUED FROM PREVIOUS S-WARE?
ILLDV2	HS	0
	LIS	R8,1
	AHM	R8,PHILDC,,		:COUNT OCCURRENCES OF ILL INTERRUPTS
	GL	PHILDC
	JLEBS	ILLDV0

	AHI	R2,3F00			:CRASH CODE COMBINED WITH DEVICE ADDR
	EXBR	R2,R2			:WANT CRSHDESC/CRSHTYP-SUBTYP	###JHL
	LR	R14,R0			:MOVE PSW TO R14 FOR ANERNT
	LR	R15,R1			:MOVE PC TO R15 FOR ANERNT
	LR	R0,R2			:MOVE CRASHID TO R0 FOR ANERNT
	EXBR	R0,R0			:TYPE/SUBTYPE IN LO BYTE FOR HLTPSW
	LA	R7,ILLDV3		:HALT UNCONDITIONALLY
	J	ANERNT			: AFTER DOING CRASH TABLE
ILLDV3	HS	0
	LIS	R7,0
	LPSW	IDHPSW			:HALT MACHINE (GET SOMEONE'S ATTENTION)

:	MAY BE NOP'D TO LPSWR R0, IN WHICH CASE MACHINE RUNS AND
:	MAC'D FIELD 'ILDVCT' RECORDS FREQUENCY.

::*********************************************************************
::
::	SUBROUTINE:	PCDTEN:
::	FUNCTION:	Make crash detail table entry for h/w interrrupts
::	CALLING SEQ:	JAL	R13,PCDTEN
::	DESTROYED:	R0,R2,R10
::	CALLS:		JAL	R10,NRGSA0
::
::*********************************************************************

PCDSAV	WS	3			:SAVE AREA FOR FOLLOWING

PCDTEN	HS	0
	STM	R13,PCDSAV		:SAVE LINK AND CRASH PSD
	STM	R14,PHCRPS,,		:SAVE CRASH PSD
	STH	R0,PHCRID		:SAVE CRASH ID CODE
	GL	PHCRID
	LR	R0,R14			:MOVE USER PSW TO R0 FOR NRGSAV
	NHI	R0,0F0			:GO TO CRASH REG SET(USER REG SET)
	JAL	R10,NRGSA0		:MOVE REGGIES TO ERRREG
	LPSW	GMTPCD
GMTPCD	WC	4F0,GMTPC1		:MOVES US TO MAC'ED CODE
	GL	GMTPC1			:--RETURNS TO PCTEN3

PCTEN3	L	R2,PGMTNO,,		:GET CRASH TIME JUST READ IN GMTCAL
	GL	PGMTNO
	ST	R2,PCRHTM,,		:STORE IN CRASH TABLE
	GL	PCRHTM

PCTEN2	HS	0
	LM	R13,PCDSAV		:RESTORE LINK AND USER PSD
	JR	R13			:RETURN TO CALLER

::*********************************************************************
::
::	COMMON CLOSING STUFF FOR NODE-CODE MAC, ILLEGAL INST AND PARITY
::	INTERRUPTS. EITHER HALT MACHINE OR PROCEED AT 'SFAIL2'
::
::*********************************************************************

MAC0SV	WS	1			:SAVE MAC REG 0 FROM TIME OF CRASH
MACASV	WS	1			:IS THIS EVER USED? ???JHL

ANERNT	HS	0

:	NEXT FOUR LINES WERE FOR CONTEXT SWITCHING IN CONSAT

	L	R13,MACREG		:READ MAC REG FOR SEG 0
	ST	R13,MAC0SV		:STORE IT FOR LATER REFERENCE
	LI	R13,ANMAC0		:MAKE SURE WE'RE DEALING WITH THE RIGHT
	ST	R13,MACREG		:SEGMENT 0! STORE ORIG MAC0 IN MACREG
	JAL	R13,PCDTEN		:DO CRASH TABLE
	LPSW	PCRASH			:MAKE CRASH TABLE ENTRIES
PCRASH	WC	4F0,CTEINT		: USE SET F MAC'D
	GL	CTEINT
INTPSD	WC	0,ANERN1		:THIS PSD UNUSED--CTEINT MAKES ITS OWN
ANERN1	HS	0			:CTEINT RETURNS HERE
	LHL	R4,PHCRID		:SET UP HALT DISPLAY IN CASE WE HALT
	STB	R4,HLTPSW+3		:CRASH TYPE/SUBTYPE IN LO BYTE
	EXBR	R4,R4			:CRASH DESCRIPTOR IN HO BYTE
	STB	R4,HLTPSW+7		:STORE FOR DISPLAY--MUST BE EVEN
	CI	R7,ILLDV3		:CRASH UNCONDITIONALLY FOR ILLGL DV?
	JER	R7			:YES--HALT VIA ILLHLT
	LIS	R1,0			:CLEAR XRAY RUN FLAG IN CASE XRAY WAS
	STH	R1,AXFLGS		: DISABLED BY NODE CODE VIA SVC10
	LB	R0,PHCRST,,		:CHECK NODE STOP OPTION
	GL	PHCRST
	SIS	R0,HLTNOD		:IS CRSTOP = 3XX? (HALT ON HARDWARE)
	JN	ANERN6			:NO, TRANSFER TO SFAIL2
	LPSW	HLTPSW			:HALT WITH APPROPRIATE INDICATION

ANERN6	HS	0
	GL	PHCRTY
	TS	PHCRTY			:INDICATE HARDWARE TYPE CRASH
	LPSW	NRSPSW			:HALT OPTION NOT SELECTED
					: - PROCEED AT SFAIL2

KRERNT	LPSW	KILL,,
	GL	KILL

::*********************************************************************
::
::	MAC INTERRUPT:
::
::	EITHER RELOCATION/PROTECTION VIOLATION OR DMA
::	TIMEOUT.  IF ZITEL, THEN MAC2 BOARD AND SEMI-CONDUCTOR MEMORY
::	(USUALLY). IN THAT CASE, THE INTERRUPT CAN BE ONE OF THREE
::	TIMEOUT ERRORS,  RELOCATION/PROTECTION VIOLATION, OR
::	STOP/TRACE DEBUG INTERRUPT. 
::
::*********************************************************************

MCIDBT	EQ	420		:MAC ID BIT IN STATUS REGISTER--SET IF 
				:MEMORY RELOCATION NOT IN EFFECT.
                                :BIT 26 (OR '20') IS ALSO FORCED TO '1'
				: FOR MAC3 AND NEEDS TO BE MASKED OUT    ###GT
MCTRBT	EQ	40		:TRACE INT BIT in MAC status register

.WPRER	EQ	50		:WRITE PROTECT ERROR
.LIMER	EQ	51		:LIMIT ERROR
.DM1TO	EQ	52		:DMA TIMEOUT ERROR 1 (SEE MAC SPEC)
.PREER	EQ	53		:PRESENCE ERROR
.WRTNT	EQ	54		:WRITE INTERRUPT (NOT AN ERROR, NECESSARILY)
.FTCER	EQ	55		:FETCH ERROR
.MEMTO	EQ	56		:MEMORY TIMEOUT
.DM2TO	EQ	57		:DMA TIMEOUT ERROR 2 (SEE MAC SPEC)
	IF	ZITEL		:###JHL--FOR REL 5.02
.STFTC	EQ	0F05F		:STOPPED ON INSTRUCTION FETCH
.STMRD	EQ	0F15F		:STOPPED ON MEMORY READ
.STMWR	EQ	0F25F		:STOPPED ON MEMORY WRITE
.STDRD	EQ	0F35F		:STOPPED ON DMA READ
.STDWR	EQ	0F45F		:STOPPED ON DMA WRITE
.MACID	EQ	0F55F		:MAC ID BIT--SET WHEN MAC INACTIVE
.TRINT	EQ	0F65F		:TRACE ADDRESS INTERRUPT
.STR10	EQ	0F75F		:UNUSED BIT10 IN MAC STATUS REGISTER

: 	THESE WILL ALL BE 0FE5F FOR RELEASE--THIS IS JUST FOR TESTING.

	ELSE	:ZITEL

.STFTC	EQ	0FE5F		:STOPPED ON INSTRUCTION FETCH
.STMRD	EQ	0FE5F		:STOPPED ON MEMORY READ
.STMWR	EQ	0FE5F		:STOPPED ON MEMORY WRITE
.STDRD	EQ	0FE5F		:STOPPED ON DMA READ
.STDWR	EQ	0FE5F		:STOPPED ON DMA WRITE
.MACID	EQ	0FE5F		:MAC ID BIT--SET WHEN MAC INACTIVE
.TRINT	EQ	0FE5F		:TRACE ADDRESS INTERRUPT
.STR10	EQ	0FE5F		:UNUSED BIT10 IN MAC STATUS REGISTER

:	THESE ARE ALL ILLEGAL MAC INTERRUPTS IF NOT ZITEL

	EI	:ZITEL

MACCOD	HC	.STFTC,.STMRD,.STMWR,.STDRD,.STDWR,.MACID,.MEMTO,.DM2TO
	HC	.DM1TO,.TRINT,.STR10,.LIMER,.PREER,.WPRER,.WRTNT,.FTCER

SMACNT	HS	0
	STM	R0,PHERG0		:save set 0 reggies
	LH	R0,MMLFLG		:MAC INTERRUPT FROM SIZING MEMORY?
	JEFS	SMACN1			:NO, A REAL ONE
:WITH MAC1 THIS WOULD BE PARITY ERROR--WITH MAC2 IT WOULD BE A TIMEOUT###jhl
	LIS	R0,0
	STH	R0,MMLFLG		:CLEAR THE CONDITION AND
	LPSWR	R14			:RETURN CONTROL TO INTERRUPTED PARTY

SMACN1	HS	0
:	THIS APPEARS TO BE AN OBSOLETE MECHANISM (e.g. MACNTF)	###JHL
	LIS	R4,MACNTF		:MAC INTERRUPT FLAG
	LHL	R3,USRRET		:CONTROL OF MACHINE AT TIME OF INTERRPT
	IF	KERNEL			:IF MACHINE WITH KERNEL, SEE IF KERNEL
	CLHI	R3,KRRET		: WAS IN KERNEL
	JE	KRMCNT			:...LET KERNEL HANDLE THE INTERRUPT
	EI	:KERNEL
	CLHI	R3,AXRET		:WAS XRAY CAUSE OF THE MAC INTERRUPT?
	JE	AXERNT			:YES, MUST KEEP XRAY,NODE CODE SEPARATE

:	MAC ERROR TAKEN WHILE NODE CODE WAS RUNNING. CHECK FOR DMA TIMEOUT,
:	SAVE MAC STATUS AND DIAGNOSTIC REGISTERS, AND TAKE RECOVERY ACTION

	STM	R14,PHMACP		:STORE LAST NODE CODE PSW INTO MACPSW
	GL	PHMACP
	LM	R12,MACSTR		:READ IN MAC STATUS AND DIAGNOSTIC REGS
	NHI	R12,0FFFF-MCIDBT	:CLEAR MAC INACTIVE BIT FOR JFFOH###JHL
	STM	R12,PHSMAC		: WRITE INTO SEG0 FROM LOCATION 7C ON
	GL	PHSMAC
	ST	R12,PHMCSR		:SAVE LOCATION 340 (MACSTR)
	GL	PHMCSR
	JFFOH	R12,SMACER		:FIND WHICH BIT IS SET
	IF	ZITEL			:WARNING--this switch ends at SMACER
	LIS	R13,5			:NO BIT SET,FAULTY INTERRUPT,LIKE MACID
SMACER	AR	R13,R13			:GET HW OFFSET FOR JUMP TABLE
	LHL	R11,NTHDTB,R13		:GET SEGMENT OFFSET TO HANDLER ROUTINE
	JR	R11			:JUMP TO HANDLER ROUTINE

SPURNT	HS	0
LOGWRT	HS	0
MCCRSH	HS	0
	ELSE	:ZITEL
	LIS	R13,0
SMACER	AR	R13,R13			:HW INDEX FOR CRASH CODE TABLE
	EI	:ZITEL
	LHL	R2,MACCOD,R13		:GET CRASH CODE

:	THE APPROACH HERE IS TO RETRY THE INSTRUCTION WHICH LED TO THE
:	MAC INTERRUPT ONCE.  THIS ALLOWS DMA TIMEOUTS, FOR EXAMPLE, TO
:	BE GIVEN ANOTHER CHANCE.  SOMETHING AS SERIOUS AS A PROTECTION
:	VIOLATION, HOWEVER, WILL FAIL AGAIN ON THE RETRY, AND WE WILL
:	RETURN HERE FOR A HARD CRASH.

	LH	R0,PHSFTD,,		:CHECK SFTDMA CELL, ONLY ONE DMA
	GL	PHSFTD			: TIMEOUT PER FOUR MINUTES CAN BE
	AIS	R0,1			: SOFT-RECOVERED
	STH	R0,PHSFTD,,		:SFTDMA IS SET TO -1 IN 4-MINUTE LOGIC	
	JGFS	SMACN6			:THIS IS A TIMEOUT TOO MANY, HARD CRASH
	TS	PHDMAF,,		:SOFT CRASH - NOTE EVENT FOR REPORTING
	GL	PHDMAF
	LPSW	PHMACP			:AND RETURN TO USER FOR RETRY

SMACN6	HS	0
	LM	R14,PHMACP		:RESTORE REG SET 0 AS IT WAS AT ENTRY
	LR	R0,R2			:CRASH CODE TO R0 FOR CRASH TABLE
	J	ANERNT			:  ROUTINE

:	ILLEGAL INSTRUCTION OR MAC ERROR WHILE XRAY WAS IN CONTROL
:	SAVE XRAY REGISTERS IN ERRREG AND TRANSFER TO LOCATION 'XERROR'

AXERNT	ST	R15,PHCRAD		:SAVE FAILURE ADDRESS
	GL	PHCRAD
	JAL	R10,NRGSAV		:AND REGGIES
	LI	R15,XERROR		:XRAY - TAKE ERROR RETURN
	GL	XERROR
	OHI	R14,400			:MAKE SURE MAC IS ON
	LPSWR	R14

	IF	KERNEL
KRMCNT	LPSW	KMAC,,			:HNDLR FOR MAC INT BY KERNEL USER
	GL	KMAC
	EI	:KERNEL

::*********************************************************************
::
::	MAC INTERRUPT HANDLER JUMP TABLE:
::
::*********************************************************************

	IF	ZITEL
NTHDTB	HS	0
	HC	TRCINT		:STOPPED ON INSTRUCTION FETCH
	HC	TRCINT		:STOPPED ON MEMORY READ
	HC	TRCINT		:STOPPED ON MEMORY WRITE
	HC	TRCINT		:STOPPED ON DMA READ
	HC	TRCINT		:STOPPED ON DMA WRITE
	HC	SPURNT		:MAC IN USE BIT--CLEARED ON ENTRY
	HC	MCCRSH		:MEMORY TIMEOUT
	HC	MCCRSH		:DMA2 (WRITE) TIMEOUT
	HC	MCCRSH		:DMA1 TIMEOUT
	HC	SPURNT		:TRACE INTERRUPT--should find one of
				: first five bits first.
	HC	SPURNT		:SPURIOUS MAC INTERRUPT (UNUSED)
	HC	MCCRSH		:LIMIT VIOLATION
	HC	MCCRSH		:PRESENCE VIOLATION
	HC	MCCRSH		:WRITE PROTECT VIOLATION
	HC	LOGWRT		:WRITE INTERRUPT--I-BIT FOR SEG CAUSES
				: WRITE TO SEG TO GEN INT.--NOT ABORT.
	HC	MCCRSH		:FETCH ERROR
	EI	:ZITEL

::*********************************************************************
::
::	TRCINT:	TRACE INTERRUPT HANDLER
::	HANDLING ROUTINE FOR THE VARIOUS KINDS OF TRACE INTERRUPTS.
::	INTERFACES WITH XRAY.
::	Read status halfword to be sure bit05 is set--if not, spurious.
::	Read and store set F registers and trace buffer area.
::	Read and store trace control word and type of stop, etc.
::
::*********************************************************************

	IF	ZITEL		:FOR ZITEL TRACE/STOP FUNCTION

TRNTOF	EQ	19	:offset of trace addr int bit in MAC st reg word

TRCINT	HS	0
	LHI	R0,TRNTOF	:get trace int offset into work register
	TBT	R0,PHSMAC	:ensure trace addr interrupt bit set 
	JGFS	TRCI10		:continue IF it looks like a real one
:	trace qualifying bit set w/o trace interrupt bit set--bad interrupt
	LHL	R0,PHBDTR,,	:increment "bad stop interrupt" cell
	AIS	R0,1
	STH	R0,PHBDTR,,
	LPSW	PHMACP		:just ignore for now
:	J	SPURIOUS	:error condition--what shall we do?
TRCI10	HS	0

	GL	NSTRCN,PHSTRG,PHSTPW,PHLTRC,PHLTRX
	LH	R0,PHLTRC,,	:is logging or springing requested?
	JL	TRCI50		:neg means logging requested		###OAS
:	Handler for springing on specified occurrence.
	LHL	R0,PHSTNM,,	:tst trggr occ wanted by user
	SIS	R0,1
	JEFS	TRCI20		:branch if time to collect stats
:	we're couting down to user's specified trigger occurrence
	STH	R0,PHSTNM,,	:save updated trigger count
	LIS	R0,0		:offset of trc enable bit
	SBT	R0,MCTRCW	:bit must be set again for antoher interrupt
	LPSW	PHMACP		:and resume with node software
:	Here for gathering relevant stats for the interrupt.
TRCI20	STH	R0,PHSTNM,,	:this is probably not needed
	TS	PHTRCF,,	:set flag for XLOOP to output data
TRCI30	J	TRCI32
	HS	10		:patch area for further qualifying trace
TRCI32	SRLS	R13,1		:now have offset of stop condition
	STH	R13,PHSTPS,,	:save the offset of the stop condition
	L	R13,FASTC	:record time of trigger
	ST	R13,PHMTRG,,	:save for later output
	LM	R14,PHMACP
	STM	R14,PHTSPS,,	:ditto for PSW at time of interrupt
	GL	PHTSPS
	LHI	R0,0F0		:we want set F unMAC'ed
	EPSR	R1,R0		:change PSW's
	STM	R0,PHTRCR,,	:store all registers from context of interrupt
	LPSW	TRCX35		:get back to reg set 0
TRCX35	WC	6000,TRCI35	:ena I/O and malfnctn ints, reg set 0
TRCI35	HS	0
	LM	R0,MCTRBF	:read 32 words from 380 to 39F
	STM	R0,PHTRCS,,
	LM	R0,MCTRBF+40
	STM	R0,PHTRCS+40,,	:record last qualified trace addresses
:	clear user's claim on TRACE interrupt
	LIS	R0,0
	ST	R0,MCTRCW	:zero out TRACE CTRL word
	ST	R0,MCLTBD
	ST	R0,MCUTBD	:zero out addr bounds
:	"resume after stop" set in XTRCBF (XRAY). 0 is "halt."
	TS	PHHLTO,,	:turn halt status to default "resume"
	JE	TRCSTP		:zero meant "halt"
	LHL	R1,PHTRCU,,	:get owner's XD
	AHI	R1,XUSLTN	:point to this user's slot no.
	LHL	R1,S0PH,R1,	:convert to owner's XN
	JEFS	TRCI40		:skip if 0 (TTY)
	SBT	R1,PHXQUM,,	:set XRAY user queue
	LHI	R1,01F-PXRAY	:schedule remote xray to display trap
	SBT	R1,PHSQUE,,
TRCI40	LPSW	PHMACP		:return to user execution

TRCI50	HS	0
	J	TRCI60		:jump around patch area
	HS	10		:patch area for refining qualifications
TRCI60	LHL	R12,PHLTRX,,		:GET TRACE TABLE INDEX		###OAS
	AR	R12,R12			:FORM HW INDEX			###OAS
	SRLS	R13,1			:OFFSET FOR STOP CONDITION	###OAS
	STH	R13,PHSTPS,R12,		:SAVE IN STOPTRACE TABLE	###OAS
	AR	R12,R12			:FORM FW INDEX			###OAS
	L	R13,MCTRBF		:GET ACCESSED MEMORY ADDRESS	###OAS
	ST	R13,PHTRCS,R12,		:STORE IN STOPTRACE TABLE
	L	R13,FASTC		:GET TIME OF STOP INTERRUPT	###OAS
	ST	R13,PHMTRG,R12,		:SAVE IN STOPTRACE TABLE	###OAS
	AR	R12,R12			:FORM 2*FW INDEX		###OAS
	LM	R14,PHMACP		:GET PSW CAUSING THIS INTERRUPT	###OAS
	STM	R14,PHTSPS,R12,		:SAVE IN STOPTRACE TABLE	###OAS
	IF	MEMMON
	LHI	R0,0F0			:SET UP TO			###OAS
	EPSR	R1,R0			:GO TO REG SET F		###OAS
	ST	R1,PHSTRG,,		:SAVE SET F R1 (NEED AN INDEX REG)#OAS
	LHL	R1,PHLTRX,,		:GET CURRENT STOPTRACE TABLE INDEX#OAS
	SLLS	R1,6			:FORM 16*FW INDEX		###OAS
	STM	R2,PHTRCR+8,R1,		:STORE R2-R15 IN STOPTRACE TABLE###OAS
	LR	R2,R1			:NOW USE R2 FOR THE INDEX	###OAS
	L	R1,PHSTRG,,		:RECOVER ORIGINAL SET F R1	###OAS
	ST	R0,PHTRCR,R2,		:STORE R0 IN STOPTRACE TABLE	###OAS
	ST	R1,PHTRCR+4,R2,		:STORE R1 IN STOPTRACE TABLE	###OAS
	L	R2,PHTRCR+8,R2,		:RECOVER ORIGINAL SET F R2	###OAS
	LPSW	TRCX52			:GET BACK TO REG SET 0		###OAS
TRCX52	WC	6000,TRCI52		:ENABLE I/O AND MALFNCTN INTS,REG SET 0
TRCI52	HS	0
	EI	:MEMMON
	LHL	R0,PHLTRX,,		:GET STOPTRACE TABLE INDEX	###OAS
	AIS	R0,1			:AND INCREMENT			###OAS
	CLHI	R0,NSTRCN		:CHECK FOR WRAP			###OAS
	JLFS	TRCI51			:NO WRAP			###OAS
	TS	PHSTPW,,		:INDICATE TABLE WRAP FOR DISPLAY###OAS
	LIS	R0,0			:WRAP				###OAS
TRCI51	STH	R0,PHLTRX,,		:AND RESTORE STOPTRACE TABLE INDEX#OAS
	LIS	R0,0			:BIT 0 = TRACE ENABLE BIT	###OAS
	SBT	R0,MCTRCW		:RE-ENABLE TRACE INTERRUPTS	###OAS
	LPSW	PHMACP			:RETURN TO INTERRUPTER		###OAS

TRCSTP	LB	R0,PHSTPS+1,,	:get offset of stop reason
	STB	R0,TRCHLT+7	:	and store in halt PSW
	LPSW	TRCHLT		:wait while the operator does his thing

TRCHLT	WC	805E,0BAD00	:halt--display reason

	GL	PHMTRG
	GL	PHLSTF
	GL	PHTRCR
	GL	PHTRCS
	GL	PHSTPS
	GL	PHTRMS
	GL	PHBDTR
	GL	PHTRIN
	GL	PHTROV
	GL	PHTRCF
	GL	PHTRCU
	GL	PHHLTO
	GL	PHSTNM

	EI	:ZITEL

::*********************************************************************
::
::	MACHINE MALFUNCTION INTERRUPT - POWER FAIL, POWER UP OR PARITY ERROR
::
::*********************************************************************

MALINT	JT	1,PFAIL			:POWER FAIL IF LT-bit set in CC
	JF	0F,PREST		:POWER RESTORE IF no bits set in CC
MALPAR	HS	0			:NOT POWER UP OR DOWN...MUST BE PARITY
	STM	R0,PHERG0		:save set 0 registers
	LM	R14,MLOPSW		:GET MACHINE MALFUNCTION OLD PSW
	STM	R14,PHMALP		: AND SAVE IN SEG0
	GL	PHMALP
	LHL	R3,USRRET		:FIND CULPRIT
	CLHI	R3,AXRET		:XRAY?
	JE	AXERNT			:YES
	LHI	R0,0020			:INDICATE PARITY ERROR FOR CRASH CODE
	LIS	R1,0
	TBT	R1,MCPARI		:TEST FOR DMA ACCESS
	JEFS	MALPR2			:NO
	AIS	R0,1			:INDICATE DMA
MALPR2	HS	0
:	THIS APPEARS TO BE AN OBSOLETE MECHANISM (E.G. MALNTF)	###JHL
	LHI	R4,MALNTF		:MACHINE MALFUNCTION INTERRUPT FLAG
	J	ANERNT

:	POWER FAIL INTERRUPT

PFAIL	LHI	R1,22F0			:LEAVE MMF INT BIT ON
	EPSR	R2,R1
	JFS	.			:LOOP UNTIL WE CAN LOOP NO MORE...

:	POWER RESTORE INTERRUPT

PREST	HS	0
	LHI	R14,0D0			:reset 3600 baud timer immediately
	EPSR	R0,R14			: after power-up, reg 0E of reg set 0D
	LHI	R14,7FFF		: must be positive or we'll crash...
	LHI	R1,200			: ###ed mooring###wjl
	EPSR	R0,R1			:
	LIS	R1,0
	EPSR	R2,R1
	LIS	R1,PWFLF		:POWER FAIL FLAG FOR XRAY
	STH	R1,ANHALT
	LIS	R0,0			:CLEAR HALT FLAGS
	STH	R0,AXFLGS		:CLEAR XRAY RUN FLAG IN CASE IT WAS SET
	LM	R0,ANODMC
	STM	R0,MACREG
	LIS	R0,0			:POWER FAIL CRASH CODE
	JAL	R13,PCDTEN
	LPSW	PFCRSH
PFCRSH	WC	4F0,CTEPFL
	GL	CTEPFL
PREST0	HS	0
	LHI	R1,22F0
	EPSR	R2,R1
	J	SSTAR2			:RESTART EVERYTHING

::*********************************************************************
::
::	SUBROUTINE:	NRGSAV: or NRGSA0:
::	FUNCTION:	Switch reg. set and save reg.s
::	CALLING SEQ:	JAL	R10,NRGSAV or 
::			JAL	R10,NRGSA0
::	DESTROYED:	R0,R1
::
::*********************************************************************

NRGSAV	LHI	R0,0F0
NRGSA0	EPSR	R1,R0			:GO TO REG SET F
	STM	R0,PHERRG		:SAVE NODE REGISTERS (-SEG0 IMPLIED)
	GL	PHERRG
	LPSW	NRGSA1			:AND RETURN
NRGSA2	JR	R10

NRGSA1	WC	0,NRGSA2

::*********************************************************************
::
::	MACHINE HALT PSW'S:
::
::*********************************************************************

:	REVERSED ORDER OF FIELDS IN DMTPSW	###JHL
HLTPSW	WC	8000,0BAD00	:FIELDS TO BE FILLED BY CRASH HANDLER
DMTPSW	WC	8052,0BAD02	:02 DESCRIPTOR FIELD FOR PATHOLOGICAL CASE
IDHPSW	WC	803F,0BAD00	:HALT ON ILLEGAL DEVICE INTERRUPT
ILLHLT	WC	804F,0BAD00	:ILLEGAL INSTRUCTION WITH NOBODY RUNNING

PFPSW	WS	2		:STORAGE FOR PSW $ REGS ON POW FAIL
PFREG	WS	20

KRMMSV	WS	2		:SAVE KERNEL MACHINE MALFUNCTION VECTOR
XRMMVC	WC	0,MALINT	:INSURE NODE MM HANDLER FOR X-RAY

PATCHP	WS	20		:PATCH AREA FOR PRIVILEGED CODE

	EI	(1-ISIS)
	EI	(1-KILLIT)

	KILMSG(SHARE)

:	***NOTHING PAST THIS POINT***

	SUBTTL	SYLVEX

:		 **** *   * *     *   * ***** *   *
:		*      * *  *     *   * *      * *
:		 ***    *   *     *   * ****    *
:		    *   *   *      * *  *      * *
:		****    *   *****   *   ***** *   *

::#####################################################################
::
::	MODULE: SYLVEX
::
::	FUNCTION:
::	Interrupt-level routines for SOLO node code.  (For ISIS, this code
::	is part of the Kernel.  If this code is changed, ISIS Kernel must
::	be changed too.)  All this code runs in privileged mode, un-MAC'd.
::	Common variables are referenced by their physical addresses.
::	Sync-line output routine and cksum are in this module, 
::	Sync-line input and sio-line input /output in LINKER module.
::
::	REGISTER CONVENTIONS:
::		LN  = R14
::	SUBTTLS:
::		Sync-line interrupt routines
::		INTSIO - SIO-line interrupt routines
::		INTSIR - SIO-ring card interrupt handler
::		PHASE0 - Clock interrupt handler
::	ROUTINES:
::		IZSYLL: init sync. line interrupt 
::	    SVC05T SYNC. INT. VECTOR
::		SVIDL:  idle line input
::		SXIDL:  idle output 16 bits worth of marks
::		SXRST:  output marks before a reset
::		SXRSM:  output marsk then continuous resets
::		SXPAK:  xmit block of data then idle
::		SXATT:  int. xmitter for attached lines
::	    LINE INIT. INTVEC ROUTINES
::		INTSIO: sio line mother bd int.s
::		SINTST: sio line test for version no.
::		SINERR: plain old err.
::		PHASE0: init. clock
::		INTSIR: if split-supervisor sio ring int.
::
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE

	IF	1-ISIS		:>>NOTE: THIS MODULE FOR SOLO NODES ONLY<<

:	SYLVEX constants

NSCRDS	EQ	(NLINES+0F)/10 	:# OF SYNC CARDS
MLINEL	EQ	3F		:FOR TRUNCATING LINE #
NRSMRK	EQ	$A 64		:Number of marks to precede reset
SCRATE	EQ	5		:Process clock (SCLOCK) rate
SVNBSZ	EQ	100		:SIZE OF SYNC INPUT BUFFERS

:	privileged code storage area
:	SYLVEX variables (also defined in EXEC??)

SXOPTR	WS	10*NSCRDS	:ADDR OF SXINT OPERAND ##AL FW
SXOCNT	HS	10*NSCRDS	:BYTE COUNT WHERE APROPRIATE
SXNTOP	HS	10*NSCRDS	:ADDR OF NEXT HW TO OUTPUT
SXNLST	HS	10*NSCRDS	:POINTS TO VERTICAL CHECKSUM
SXACK	HS	10*NSCRDS	:TO SAVE THE ACKNOWLEDGEMENT BEING SENT
SXRETN	HS	10*NSCRDS	:TEMPORARY STORAGE FOR SXINT
	HS	1		:DUMMY MARK FLAG (SEE SXAT2)
SXMRKF	HS	10*NSCRDS	:MARK FLAG
RSENT	WS	3		:0 IF RECORD SENT LAST 1-SEC PERIOD
XDUMM	WS	3		:1 IF LINE SHOULD XMIT DUMMY
SYRESZ	HS	1		:RESET BYTE SIZE
SYLDBG	HS	1
	SYAD(SYLDBG)

	IF	DB.TSN
CKERSV	WS	10		:REG SAVE AREA IF SYNC ANOMALY DETECTED
CKERCT	HC	0		:COUNT OF TIMES CKSUM NOT NEGATIVE (SEE SXAT4)
	EI	:DB.TSN

:	CLOCK VARIABLES:

SCLOCK	WS	1		:'PROCESS' CLOCK
SBASCK	HS	1		:FOR UPDATING SCLOCK
SLBSCK	HS	1		:FOR UPDATING SLOWC
SCHSAV	WS	2		:SAVE AREA FOR PC SWAP IN SCHED

	IF	ESYNC

:	PTRS TO I/O CONTROL BLOCKS, ADDRESSED BY (LINE#)*2
Q	EQ	0
SXIOCB	RE	20
	HC	SYLCTL+Q*0A
Q	EQ	Q+1
	ER

	ELSE	:NOT ESYNC

:	WRAP AROUND TABLE FOR SVINT:

	NOLIST
Q	EQ	2		:SVWRAP
	HC	SVNBSZ-4,SVNBSZ-2,0
SVWRAP	RE	(SVNBSZ/2)-1
	HC	Q
Q	EQ	Q+2
	ER
	HC	0,2,4,6,8,0A
	LIST
	EI	:ESYNC

:	DUMMY RECORD (ALSO DEFINED IN LINKER, Q.V.)

TWDUMS	WC	TWDMHD
	GL	TWDMHD
	HC	3069%78AB
	HC	3069^2%78AB^1%3069%78AB

	SUBTTL	SYLVEX (Sync-line interrupt routines)

::*********************************************************************
::
::	SUBROUTINE: 	IZSYLL:
::	FUNCTION:	Initializes the sync-line interrupt
::	CALLING SEQ:	JAL	R6,IZSYLL
::	DESTROYED:	R2,R3,R4,R5
::	CALLS:		none
::
::*********************************************************************

IZSYLL	HS	0
	IF	ESYNC

:	FOR ENGINES WITH ENHANCED SYNC MICROCODE, SET UP
:	THE I/O CONTROL BLOCKS FOR THE SYNC LINES TO
:	PRODUCE CONVENTIONAL INTERRUPTS.

	LA	R3,SYLIDL		:IDLE THE INPUT
	LIS	R2,0
	LHI	R5,(0A*(NSCRDS*10-1))	:HIGHLINE * 0A

IZSYL2	ST	R3,SYLCTL,R5		:SET UP INPUT
	STH	R2,SYLCTL+4,R5		: AND OUTPUT
	SIS	R5,0A			:LOOP TIL ALL LINES DONE
	JGEBS	IZSYL2

	EI	:ESYNC

:	idle all lines
IZSYL4	LA	R2,SVIDL		:GET PTR TO RCV IDLE STATE
	LA	R3,SXIDL		:GET PTR TO XMT IDLE STATE
	LIS	R4,0			:INIT LINE # INDEX
	LHI	R5,10*NSCRDS		:10*# OF SYNC CARDS
IZSYL6	STH	R2,INTVRL,R4,R4		:UPDATE RECEIVE VECTOR
	STH	R3,INTVXL,R4,R4		:UPDATE TRANSMIT VECTOR
	AIS	R4,2			:MOVE UP TO NEXT LINE
	SIS	R5,1			:COUNT DOWN NUMBER OF SYNC LINES
	JGBS	IZSYL6			:BRANCH UNTIL ALL SET TO IDLE

:	RAISE DTR AND RTS ON ALL LINES WITH THESE LEADS AVAILABLE.
:	NOTE THAT CONTROL BITS ARE INVERTED.
:	0 RAISES A SIGNAL -- 1 CLEARS IT.
:
:	FIRST SYNC CARD CONTROL REG ADDRESS IS BF.
:	SECOND SYNC CARD CONTROL REG ADDRESS IS FF.
:
:	BIT	LINE		SIGNAL
:	-----	------	-------------------------------
:	0	2		INPUT DSR	OUTPUT DTR
:	8	2		INPUT CTS	OUTPUT RTS
:	1	3		INPUT DSR	OUTPUT DTR
:	9	3		INPUT CTS	OUTPUT RTS
:	2	6		INPUT DSR	OUTPUT DTR
:	A	6		INPUT CTS	OUTPUT RTS
:	3	7		INPUT DSR	OUTPUT DTR
:	B	7		INPUT CTS	OUTPUT RTS
:
	LHI	R2,SYNST1		:CONTROL REG FOR FIRST SYNC CARD
	LIS	R4,0			:RAISE BOTH RTS AND DTR
	WDR	R2,R4			: ON ALL LINES
:
	LHI	R2,SYNST2		:REPEAT FOR SECOND SYNC CARD
	WDR	R2,R4
	JR	R6

::*********************************************************************
::
::	SVIDL:	SYNC LINE INTERRUPT RECEIVERS.
::	FOR EFFICIENCY, EACH LINE HAS A DEDICATED INTERRUPT RECEIVER.
::
::*********************************************************************

:	Idle line input routine.
SVIDL	HS	0
	RDR	R2,R4			:READ FROM DEVICE IN R2,16 BITS INTO R4
	LPSWR	R0			:RETURN TO USER LEVEL--IGNORE CHARCTER

	IF	1-ESYNC

Q	EQ	0

SVINT	RE	10*NSCRDS
	LHL	R3,PHSVTP+Q		:LOAD PTR TO NEXT SLOT
	RDR	R2,R4			:READ HW OF DATA INTO R4
	STH	R4,PHSVBF+Q,R3		:CAN'T BE DONE WITH AN RD
	LHL	R3,SVWRAP,R3		:BUMP PTR
	STH	R3,PHSVTP+Q
	LPSWR	R0

Q	EQ	Q+SVNBSZ+2
	NOLIST
	ER
	LIST

SVINSZ	EQ	(.-SVINT)/(10*NSCRDS)	:SIZE OF EACH RECEIVER
CSVINZ	HC	SVINSZ			:CONVENIENT CONSTANT

	EI	:1-ESYNC

::*********************************************************************
::
::	SXINT: SYNC LINE INTERRUPT TRANSMITTER.
::
::	EACH DEVICE GENERATES AN INTERRUPT EVERY SIXTEEN BIT TIMES
::	WHEN THE TRANSMIT HOLDING REGISTER IS EMPTIED INTO THE
::	TRANSMIT SHIFT REGISTER.  IF SYLCTL FOR THE LINE HAS BEEN
::	SETUP WITH POINTERS AND COUNTS AND IF THE ENHANCED ASYNC
::	MICROCODE IS IN EFFECT THEN THE INTERRUPTS ARE SERVICED BY THE
::	MICROCODE UNTIL THE GIVEN COUNT IS DEPLETED.
::
::	NOTE THAT ALL ADDRESSES ARE ASSUMED TO BE IN USER SEGMENT 0
::	EXCEPT FOR 'RECBUF' WHICH IS ASSUMED TO BE IN SEGMENT 2.  IN ADDITION,
::	LINK AND RECORD DESCRIPTORS ARE EXPECTED TO RESIDE IN THE FIRST
::	HEX 1000 BYTES OF SEGMENT 0.
::
::*********************************************************************

::*********************************************************************
::
::	ENTRY POINT:	SXIDL:
::	FUNCTION:	Idle line ... output 16 bits worth of mark line.
::
::*********************************************************************

SXIDL	HS	0
	LCS	R4,1			:READ "FF" FOR OUTPUT, WRITE TO DEVICE
	WDR	R2,R4			:INTERRUPTING LINE DEVICE ADDR IS IN R2
	LPSWR	R0			:RETURN TO USER LEVEL

::*********************************************************************
::
::	ENTRY POINT:	SXRST:
::	FUNCTION:	OUTPUT A SINGLE RESET PATTERN -- PRECEDED
::			BY ONE RECORD'S WORTH OF MARKS.
::	INPUT:		R0,R1 -- EXIT PSW
::			R2 -- INTERRUPTING DEVICE ADDRESS
::
::*********************************************************************

:	Output a full record's worth of marks before sending a reset (SXRST5).

SXRST	HS	0
	LHI	R3,NRSMRK+8		:SEND FULL RECORD OF MARKS
	LHL	R4,SXIOCB-21,R2		:GET IO CONTROL BLOCK ADDRESS
	STH	R3,4,R4			:SET # OF MARKS TO OUTPUT
	LA	R3,SXRST5		:WHEN THOSE ARE GONE, EXECUTE
	STH	R3,INTVEC,R2,R2		:	AT SXRSM5
	J	SXIDL			:EXIT FOR NOW

:	Send reset after outputting full record's worth of marks (SXRST).

SXRST5	HS	0	
	LHL	R4,SXIOCB-21,R2		:GET IO CONTROL BLOCK ADDRESS
:	LHL	R3,SXOPTR-21,R2		:ADDRESS OF RESET PATTERN
	LR	R3,R2			:R2 IS SYN XMIT DEV. ADDR. ##AL
	SI	R3,21			:DEV. ADDR. FOR LINE0 BASE 21
	SLLS	R3,1			:FW BOUNDARY FOR SXOPTR ##AL
	L	R3,SXOPTR,R3		:ADDRESS OF RESET PATTERN ##AL
	LH	R5,SYRESZ		:NEGATIVE RESET BYTE SIZE
	SR	R3,R5			:ADD RESET SIZE TO BASE ADDRESS
	ST	R3,6,R4			: AND STORE INTO IOCB
	STH	R5,4,R4			:AND COUNT
	LA	R3,SXIDL		:IDLE WHEN DONE
	STH	R3,INTVEC,R2,R2
	J	SXIDL			:START WITH 1/2 WD OF MARKS

::*********************************************************************
::
::	ENTRY POINT:	SXRSM:
::	FUNCTION:	OUTPUT CONTINUOUS RESET PATTERNS --
::			EACH PRECEEDED BY ONE RECORD'S WORTH OF MARKS.
::	INPUT:		R0,R1 -- EXIT PSW
::			R2 -- INTERRUPTING DEVICE ADDRESS
::
::*********************************************************************

:	Send full record's worth of marks before sending reset (SXRSM5).

SXRSM	HS	0
	LHI	R3,NRSMRK+8		:SEND FULL RECORD OF MARKS
	LHL	R4,SXIOCB-21,R2		:GET IO CONTROL BLOCK ADDRESS
	STH	R3,4,R4			:SET # OF MARKS TO OUTPUT
	LA	R3,SXRSM5		:WHEN THOSE ARE GONE, EXECUTE
	STH	R3,INTVEC,R2,R2		:	AT SXRST5
	J	SXIDL			:EXIT FOR NOW

:	Send reset after full record's worth of marks have been sent (SXRSM).

SXRSM5	HS	0
	LHL	R4,SXIOCB-21,R2		:GET IO CONTROL BLOCK ADDRESS
:	L	R3,SXOPTR-21,R2		:ADDRESS OF RESET PATTERN
	LR	R3,R2			:R2 IS SYN XMIT DEV. ADDR. ##AL
	SI	R3,21			:DEV. ADDR. FOR LINE0 BASE 21
	SLLS	R3,1			:FW BOUNDARY FOR SXOPTR ##AL
	L	R3,SXOPTR,R3		:ADDRESS OF RESET PATTERN ##AL
	LH	R5,SYRESZ		:NEGATIVE RESET BYTE SIZE
	SR	R3,R5			:ADD RESET SIZE TO BASE ADDRESS
	ST	R3,6,R4			: AND STORE INTO IOCB
	STH	R5,4,R4			:AND COUNT
	LA	R3,SXRSM		:LOOP WHEN DONE
	STH	R3,INTVEC,R2,R2
	J	SXIDL			:START WITH 1/2 WD OF MARKS

::*********************************************************************
::
::	ENTRY POINT:	SXPAK:
::	FUNCTION:	TRANSMIT A BLOCK OF DATA
::		SET COUNT AND ADDRESS. IDLE WHEN DONE.
::
::*********************************************************************

:	Transmit a block of data, then idle line (SXPAK1)

SXPAK	HS	0
	LHL	R4,SXIOCB-21,R2		:GET I/O CONTROL BLOCK ADDRESS
	LIS	R5,0			:GET NEG BYTE COUNT
	SH	R5,SXOCNT-21,R2 
	STH	R5,4,R4			:PUT IT IN CONTROL BLOCK
	LH	R5,SXOCNT-21,R2		:GET COUNT OF BYTES AGAIN
:	A	R5,SXOPTR-21,R2		:ADD IN START ADDRESS
	LR	R3,R2			:R2 IS SYN XMIT DEV. ADDR. ##AL
	SI	R3,21			:DEV. ADDR. FOR LINE0 BASE 21
	SLLS	R3,1			:FW BOUNDARY FOR SXOPTR ##AL
	A	R5,SXOPTR,R3		:ADDRESS OF DATA BLOCK ##AL
	ST	R5,6,R4			:PUT END ADDRESS IN IOCB
	LA	R3,SXPAK1		:GO IDLE WHEN COMPLETELY DONE --
	STH	R3,INTVEC,R2,R2		: SO SVC 6 WILL WORK
	J	SXIDL

:	Idle line after transmitting block of data (SXPAK).

SXPAK1	HS	0
	LA	R3,SXIDL		:GO IDLE
	STH	R3,INTVEC,R2,R2
	J	SXIDL

::*********************************************************************
::
::	ENTRY POINT:	SXATT:
::	FUNCTION:	Interrupt transmitter for attached lines.
::	INPUT:		R2 = sync line device address
::
::*********************************************************************

SXATT	HS	0
	RBT	R2,RSENT		:DO NOT SEND DUMMY RECORD
	RBT	R2,XDUMM		:AFTER RESET
	LA	R3,SXATT1		:SET NEW XMIT VECTOR FOR ATTACHED SYNC
	STH	R3,INTVEC,R2,R2		:LINE, SXATT FOR INITIAL INTERRUPT ONLY

:	SEND INITIAL RECORD OF MARKS TO ALLOW TIME FOR RECORD POINTERS
:	TO BE SET UP.

	LHI	R3,NRSMRK		:# OF HALFWORDS OF MARKS TO TRANSMIT
	LHL	R4,SXIOCB-21,R2		:GET IO CONTROL BLOCK ADDRESS
	STH	R3,4,R4			:STORE SIZE, POSITIVE = OUTPUT MARKS...
	J	SXIDL			:GO OUTPUT 16 BITS OF MARK

::*********************************************************************
::
::	ENTRY POINT:	SXATT1:
::	FUNCTION: 	FOR INTERRUPT TRANSMITTER AFTER INTIAL BLOCK OF
::			MARKS HAS BEEN SENT
::
::*********************************************************************

SXATT1	HS	0
:	L	R4,SXOPTR-21,R2		:GET LINK POINTER
	LR	R3,R2			:R2 IS SYN XMIT DEV. ADDR. ##AL
	SI	R3,21			:DEV. ADDR. FOR LINE0 BASE 21
	SLLS	R3,1			:FW BOUNDARY FOR SXOPTR ##AL
	L	R4,SXOPTR,R3		:ADDRESS OF LINK DESCRIP. ##AL
	LH	R5,KS.SEM,R4		:TEST SIO-LINE SEMAPHORE
	GL	KS.SEM
	JL	SXATT7			:<0 =SIO CODE IN CRITICAL SECTION.
					: IDLE LINE.
	LHL	R5,NRXM,R4		:ACTIVE LINE, GET PTR TO NEXT RECORD
	GL	NRXM
	LH	R6,PHRECN,R5		:RECORD #
	GL	PHRECN
	LR	R3,R6			:SAVE IT
	SH	R6,LAR,R4		:IS REC # GREATER THAN LAR?
	GL	LAR
	CHVR	R6,R6
	JG	SXAT2			:YES, RECORD UNACKED, NEEDS TO BE SENT
	TS	IDLE,R4			:NO, INDICATE LINK IDLE
	GL	IDLE
	RBT	R2,XDUMM		:IS IT TIME TO XMIT DUMMY
	JN	SXDUM			:YES
SXATT3	LCS	R5,1			:NO, OUTPUT 16 BITS OF MARKS
	WDR	R2,R5			:WRITE "FF" TO DEVICE
	LHL	R4,SXIOCB-21,R2		:SLEEP NEXT WORD TIME
	LIS	R5,1			:STORE A CHARACTER COUNT OF ONE
	STH	R5,4,R4			:WRITE IN IOCB SO ESYNC WILL COVER
	LPSWR	R0
SXATT7	LIS	R5,1
	AHM	R5,SYLDBG
	JBS	SXATT3

:	PERFORM MEASUREMENTS OF QUEUEING DELAY BETWEEN RMAKE
:	AND THE INTERRUPT ROUTINE. RMAKE RECORDS THE TIME A PACKET IS
:	MADE IN PKTTIM . THE INTERRUPT ROUTINE SUBTRACTS THAT
:	VALUE FROM THE CURRENT TIME AND ADDS THE RESULT INTO THE RUNNING
:	SUM ACCUMULATOR KS.PQC, AND ALSO WRITES THE
:	CURRENT TIME INTO PKTTIM. THE LATTER IS DONE SO THAT WHEN
:	A PACKET IS RETRANSMITTED THE TIME BETWEEN RETRANSMISSIONS
:	WILL BE ADDED INTO KS.PQC AS A QUEUEING DELAY.
:
:	THE CONTENTS OF KS.PQC, WHEN DIVIDED BY THE NUMBER OF
:	PACKETS MADE (KS.PKC), WILL GIVE THE AVERAGE DELAY UNTIL TRANSMISSION.

SXAT2	NHI	R3,PKTMSZ		:FORM INDEX INTO PACKET TIME TABLE
	GL	PKTMSZ
	AR	R3,R3			:AND FORM HW OFFSET
	LH	R7,FASTC+2		:GET CURRENT TIME
	LH	R8,PKTTIM,R3,R4		:GET TIME PACKET WAS MADE OR RE-XMITTED
	GL	PKTTIM
	STH	R7,PKTTIM,R3,R4		:STORE BACK CURRENT TIME
	SR	R7,R8			:COMPUTE TIME IN QUEUE
	JGEFS	SXAT6			:NO WRAP
	AI	R7,10000
SXAT6	AM	R7,KS.PQC,R4		:ADD CURRENT DELAY INTO RUNNING COUNT
	GL	KS.PQC

	LB	R3,PHLLXM,R5		:FIRST XMISSION OF RECORD?
	GL	PHLLXM			: (RMAKE CLEARS LLXM)
	JE	SXAT3			:YES, GO ADVANCE NRXM
					: (NEXT RECORD TO TRANSMIT)
	STH	R2,SXMRKF-21,R3		:REXMISSION,
					: FLAG PREVIOUS LINE TO SEND MARKS
	LHI	R3,1F
	STB	R3,PHLLXM,R5		:CHANGE TO DUMMY LINE
	TS	SXMRKF-21,R2		:WERE WE THE PREVIOUS LINE?
	JGE	SXAMK			:YES - GO MARK LINE
	LIS	R6,1			:NO, WE'RE ABOUT TO RETRANSMIT A RECORD
	AHM	R6,PHRXTR-21,R2,	: ...COUNT RETRANSMISSIONS BY LINE
	GL	PHRXTR
	JFS	SXAT4			:DONT ADVANCE NRXM FOR RETRANSMISSIONS

SXAT3	TS	SXMRKF-21,R2		:WERE WE FLAGGED?
	JGE	SXAMK			:YES - GO MARK LINE
	LH	R6,PHRLNK,R5		:ADVANCE NRXM
	GL	PHRLNK
	STH	R6,NRXM,R4

SXAT4	STB	R2,PHLLXM,R5		:REMEMBER WE SENT THIS ONE
	RBT	R2,RSENT		:NOTE NO NEED TO SEND DUMMY
	LIS	R6,1
	AHM	R6,PHRCTR-21,R2,	:COUNT PACKETS TRANSMITTED BY LINE
	GL	PHRCTR
	LHL	R6,LRT,R4		:UPDATE LAS
	GL	LRT
	STH	R6,LAS,R4
	GL	LAS
	NH	R6,AMSK,R4		:MASK IT FOR INCLUSION IN HEADER
	GL	AMSK
	IF	EXPWSZ
	L	R3,PHBREC,R5		:ADDR OF START OF RECORD
	ELSE
	LHL	R3,PHBREC,R5		:ADDR OF START OF RECORD
	EI
	GL	PHBREC
	LCS	R7,1
	XH	R7,AMSK,R4		:CLEAR ONLY ACK AREA IN HEADER
	NH	R7,PHRCBF,R3,		:				###wjl
	GL	PHRCBF			:physical address of RECBUF	###wjl
	OR	R6,R7			:OR IN NEW ACK
	WDR	R2,R6			:OUTPUT THE HEADER

	STH	R6,PHRCBF,R3,		:STORE IT AWAY FOR CHECKSUMMING	###wjl
	LR	R9,R0			:SAVE PSW

:	CALCULATE RECORD CHECKSUM

	IF	EXPWSZ
	LR	R0,R3			:COMPUTE NEGATIVE BYTE COUNT IN R0 BY
	S	R0,PHEREC,R5		:SUBTRACTING END FROM BEGINNING ADDRESS
	ELSE
	LHR	R0,R3			:COMPUTE NEGATIVE BYTE COUNT IN R0 BY
	SH	R0,PHEREC,R5		:SUBTRACTING END FROM BEGINNING ADDRESS
	EI
	GL	PHEREC
	IF	DB.TSN
	JLFS	SXAT5			:COUNT MUST BE NEG OR ELSE CKSUM
					: INSTRUCTION WILL CAUSE ILLEGAL
					: INSTRUCTION INTERRUPT
	STM	R0,CKERSV		:COUNT IN ERROR - SAVE ALL REGS AND
	LIS	R0,1			: INCREMENT ERROR COUNTER
	AHM	R0,CKERCT
	LR	R0,R9			:RESTORE PSW AND
	LPSWR	R0			:EXIT INTERRUPT ROUTINE
	EI	:DB.TSN

SXAT5	HS	0
	LIS	R6,0			:CLEAR VRC AND DRC ACCUMULATORS
	LIS	R7,0
	LA	R8,PHRCBF,R3,		:POINT TO START OF DATA		###wjl

	IF	SYNFCS		:SYNC LINE SOFTWARE FCS ERR CHECKING	##AL
	LHL	R10,KVERNO,R4		:CHECK VERSION NO. IF NEW, R4 IS KD
	GL	KVERNO			:IT WAS STORED AT TIME LINE ATTACHED
	CHI	R10,FCSVER		:FCSVER HAS NEW FCS CODE
	GL	FCSVER
	JN	SXAT66			:SKIP FCS ERR CHECKING IF OLD CODE
	LB	R10,0,R8		:CHECK BYTE CT.,
					: ONLY DATA PACKETS USE FCS
	NHI	R10,000F		:ONLY NON-ZERO BYTE CT. USE FCS
	CLHI	R10,0		
	JN	FCSCBL
	J	SXAT66

:	SOFTWARE FCS CALCULATN	##AL
:	ENTRY- R8:INPUT SECTOR ADDRESS
:	EXIT- 	LO HW OF R7 IS THE 16BIT FCS
:	DESTROYED- R1,R4,R6,R10,R7
FCSCBL	HS	0			:GET NEG. BYTE COUNT
	FCSINI(R7)			:GET FCS INIT VALUE
	XR	 R4,R4			:ZERO R4
FCSCB1	LB	 R10,0,R8,R4		:GET THE CHAR
	FCSACC(R7,R10,R6)		:ACCUMULATE THE FCS
	AIS	 R4,1			:INC CNT. TO NEXT CHAR.
	CLHI	 R4,3			:CMP. WITH THE LENGTH OF 3 BYTES
	JL	FCSCB1			:CONTINUE IF NOT END
	FCSEND(R7)			:1'S COMPLEMENT THE FINAL VALUE
					:3 BYTE FCS PUT AT 2ND 16BIT LOCATN
	IF	EXPWSZ
	L	R6,PHEREC,R5		:GET DATA PACKET FCS CKSM FROM O BUF
	ELSE
	LHL	R6,PHEREC,R5		:GET DATA PACKET FCS CKSM FROM O BUF
	EI
	LHL	R6,PHRCBF,R6,		:PUT IN 1ST 16BIT CKSM LOCATN LATER#wjl
	SIS	R0,2			:NEG. BYTE CT. -2 AS OLD LOGIC
	J	SXAT7
SXAT66	HS	0
	EI	:SYNFCS

	LR	R10,R0			:SAVE NEG BYTE COUNT
	CKSUM	R6,R8			:CHECK SUM
	LHI	R0,-2,R10		:RESTORE NEG COUNT FOR SYNC CONTROL BLK
SXAT7	HS	0
	LHI	R10,4000
	EPSR	R11,R10
	IF	EXPWSZ
	L	R8,PHEREC,R5		:END OF RECORD
	ELSE
	LHL	R8,PHEREC,R5		:END OF RECORD
	EI
	STH	R6,PHRCBF,R8,		:STORE 3 BYTE HEADER FCS CKSM	###wjl
	STH	R7,PHRCBF+2,R8,		:STORE TO NEXT HW		###wjl
	LHL	R4,SXIOCB-21,R2		:I/O CONTROL BLOCK ADDRESS
	STH	R0,4,R4			:NEGATIVE BYTE COUNT
	LI	R8,PHRCBF+4,R8		:GET PHYS ADDR OF END OF RECORD	###wjl
	ST	R8,6,R4			:POINT TO DIAG CHECKSUM
	LR	R0,R9
	LPSWR	R0			:DONE

	IF	ESYNC

:	SEND BLOCK OF MARKS BEFORE SENDING RECORD
:	COUNT CONSIDERED RETRANSMISSIONS ###JHL
SXAMK	HS	0
	LIS	R6,1			:WE'RE ABOUT TO SEND 128 BYTES OF MARK
	AHM	R6,PHLXMS-21,R2,	: ...COUNT MARKING STRINGS BY LINE
	GL	PHLXMS			:###JHL
	LHL	R4,SXIOCB-21,R2		:GET I/O CONTROL BLOCK ADDRESS
	LHI	R3,NRSMRK		:SEND FULL BLOCK OF MARKS(64 HW'S)
	STH	R3,4,R4			:SET COUNT IN IOCB
	J	SXIDL			:DONE FOR NOW

:	SEND DUMMY RECORD
SXDUM	HS	0
	LHL	R4,SXIOCB-21,R2		:GET I/O CONTROL BLOCK ADDRESS
	LA	R3,TWDUMS+8		:ADDRESS OF END OF DUMMY RECORD
	LCS	R5,8			:SEND 8 BYTES
	ST	R3,6,R4			:PUT END ADDR IN IOCB
	STH	R5,4,R4			:PUT COUNT IN IOCB
	J	SXIDL			:DONE FOR NOW

	ELSE	:not ESYNC

:	MARK A FULL RECORD TIME
SXAMK	HS	0
	LHI	R3,NRSMRK
	JAL	R6,SXMARK
	J	SXATT

:	SEND A DUMMY RECORD
SXDUM	HS	0
	LA	R3,TWDUMS
	STH	R3,SXNTOP-21,R2
	AIS	R3,8
	STH	R3,SXNLST-21,R2
	JAL	R6,SXBLOK
	LA	R3,SXATT
	STH	R3,INTVEC,R2,R2
	J	SXIDL

	EI	:ESYNC

::*********************************************************************
::
::	TABLE:		FCSTBL:
::	FUNCTION:	HDLC-FCS 16BIT CKSUM TABLE
::
::*********************************************************************

:	IT CAN BE GENERATED BY THIS SAMPLE ROUTINE IF NOT HARD CODED

:PLNM	WC	11021	:COEFFICIENT OF POLYNOMIAL X**16+X**12+X**5+1
:FCSTBL	HS	256
:START	HS	0
:	XR	R1,R1
:LOOP	EXHR	R2,R1
:LOOP1	JFFO	R2,LOOP2
:	J	LOOP3
:LOOP2	LIS	R5,0F
:	SR	R5,R3
:	JLFS	LOOP3
:	L	R4,PLNM
:	SLL	R4,0,R5
:	XRT	R2,R4
:	JBS	LOOP1
:LOOP3	STH	R2,FCSTBL,R1,R1
:	AIS	R1,1
:	CHI	R1,0FF
:	JLE	LOOP

FCSTBL	HS	0
	XC	0000891112239B322446AD573665BF74
	XC	488CC19D5AAFD3BE6CCAE5DB7EE9F7F8
	XC	8110080193331A22A5562C47B7753E64
	XC	C99C408DDBBF52AEEDDA64CBFFF976E8
	XC	02218B30100299132667AF763444BD55
	XC	4AADC3BC588ED19F6EEBE7FA7CC8F5D9
	XC	83310A2091121803A7772E66B5543C45
	XC	CBBD42ACD99E508FEFFB66EAFDD874C9
	XC	04428D5316619F702004A9153227BB36
	XC	4CCEC5DF5EEDD7FC6888E1997AABF3BA
	XC	85520C4397711E60A1142805B3373A26
	XC	CDDE44CFDFFD56ECE9986089FBBB72AA
	XC	06638F7214409D512225AB343006B917
	XC	4EEFC7FE5CCCD5DD6AA9E3B8788AF19B
	XC	87730E6295501C41A3352A24B1163807
	XC	CFFF46EEDDDC54CDEBB962A8F99A708B
	XC	088481951AA793B62CC2A5D33EE1B7F0
	XC	4008C919522BDB3A644EED5F766DFF7C
	XC	899400859BB712A6ADD224C3BFF136E0
	XC	C1184809D33B5A2AE55E6C4FF77D7E6C
	XC	0AA583B4188691972EE3A7F23CC0B5D1
	XC	4229CB38500AD91B666FEF7E744CFD5D
	XC	8BB502A499961087AFF326E2BDD034C1
	XC	C3394A28D11A580BE77F6E6EF55C7C4D
	XC	0CC685D71EE597F42880A1913AA3B3B2
	XC	444ACD5B5669DF78600CE91D722FFB3E
	XC	8DD604C79FF516E4A9902081BBB332A2
	XC	C55A4C4BD7795E68E11C680DF33F7A2E
	XC	0EE787F61CC495D52AA1A3B03882B193
	XC	466BCF7A5448DD59622DEB3C700EF91F
	XC	8FF706E69DD414C5ABB122A0B9923083
	XC	C77B4E6AD5585C49E33D6A2CF11E780F

	SUBTTL	SYLVEX (INTSIO - SIO-line interrupt routines)

	IF	SILINS

SINCNT	HS	8		:8 ENTRY WRAPAROUND TABLE FOR
	SYAD(SINCNT)		:SIO INTERRUPT STORAGE, EACH HW
				:CONTAINS STAT,PORT,0,CCODE
SINTDX	HS	1		:SIO INTERRUPT TABLE INDEX
SINNUM	HS	1		:SIO INTERRUPT COUNT

:	FORM LOOK-UP TABLE TO GO FROM MOTHER-BOARD DEVICE ADDRESS
:	TO BASE SIO LINE NUMBER.
SBASEX	EQ	NLINES-SILINS
LNDA	EQ	.-(2*M.DA0)
Q	EQ	00
QSUM	EQ	0
	RE	8		:UP TO 8 MOTHERBOARDS
	IF	\M.DA|Q|	:IF BOARD N IS DEFINED,
	HC	SBASEX+QSUM
QSUM	EQ	QSUM+M.NP|Q|
	EI
Q	EQ	Q+1
	ER

::*********************************************************************
::
::	INTSIO:	PROCESS MOTHER-BOARD INTERRUPTS
::
::	THE MOTHER-BOARD RESPONDS TO A SENSE-STATUS INSTRUCTION WITH
::	THE FOLLOWING HW:
::		<INTERRUPT KEY><PORT NUMBER>< -0- ><BUSY/AVAIL>
::	WHERE EACH < > REPRESENTS ONE NIBBLE.
::
::*********************************************************************

INTSIO	HS	0
	IF	HMICRO			:HDLC MICRO			###wjl
	LR	R3,R2			:save stat,port,0,ccode		###wjl
	NHI	R2,0FF			:mask off for device address	###wjl
	ELSE	:TYMNET ENGINE
	SSR	R2,R3			:READ INTERRUPTING DEVICE STATUS
	EI	:HMICRO
	LR	R5,R3			:SAVE STAT,PORT,0,CCODE		###OAS
	EXBR	R3,R3			:MOVE KEY AND PORT NUMBER TO LOW BYTE
	LR	LN,R3			:AND SAVE
	NHI	R3,0F0			:ISOLATE INTERRUPT CODE
					: (NIBBLE 2 FROM RIGHT)
	NHI	LN,0F			:ISOLATE PORT NUMBER
					: (NIBBLE 1 FROM RIGHT)
	AH	LN,LNDA,R2,R2		:ADD IN SIO OFFSET FOR THIS PORT
	AR	LN,LN			:FORM 2*LINE NUMBER
	ST	R0,PHSINS,,		:SAVE R0 AND R1
	GL	PHSINS
	ST	R1,PHSINS+4,,
	SRLS	R3,3			:FORM 2*(INTERRUPT KEY)
	LHL	R4,SINCOD,R3		:GET DISPATCH ADDRESS FOR INTERRUPT
	JR	R4			:AND GO PROCESS IT

::*********************************************************************
::
::	TABLE:		SINCOD
::	FUNCTION:	SIO INTERRUPT DISPATCH TABLE
::
::*********************************************************************

SINCOD	HS	0		:DISPATCH TABLE TO HANDLE INTERRUPT KEYS
	RE	9
	HC	SINERR		:0 TO 8 ARE STRAIGHT ERROR TYPES
	ER
	HC	SINTST		:9 IS RESERVED FOR TESTING MICROCODE VERSIONS
:	the following return codes have been implemented on special
:	test SIO boards only.
	HC	SRESE2		:10 IS FOR TIMING XMIT RESET PATTERNS
	HC	SDUMMY		:11 IS FOR SENDING DUMMY RECS
	HC	STEST		:12 IS FOR TESTS
	HC	SRMAKE		:13 IS USED BY RMAKE TO ACTIVATE OUTPUT
	HC	STEST		:14 UNUSED
	HC	STEST		:15 UNUSED

::*********************************************************************
::
::	SINTST:	Test SIO lines for version number.
::	Each line responding to an interrupt I/O command with key = 9
::	has its bit set in the SIONEW array. 
::
::*********************************************************************

SINTST	HS	0
	SBT	LN,PHSION,,		:MARK THE LINE AS NEW MICROCODE
	GL	PHSION
	LPSWR	R0			:AND RETURN TO CALLER

::*********************************************************************
::
::	SDUMMY:	Interrupt to transmit a dummy record for the line.
::	Not implemented -- Crash.
::
::*********************************************************************

SDUMMY	HC	0

::*********************************************************************
::
::	SRMAKE:	Transmission complete interrupt.  Activate receiver to
::	output	another record.  Not implemented -- Crash.
::
::*********************************************************************

SRMAKE	HC	0

::*********************************************************************
::
::	SRESE2:	MEASURE TRANSMISSION TIME OF RESET PATTERN
::	Not implemented -- Crash in SRESET.
::
::*********************************************************************

SRESE2	LPSW	SRESE1			:COMPLETION OF OUTBOUND RESET PATTERN
SRESE1	WC	4400,SRESET		:GO TO SEG1, MAC ON, ATN0 INTERRUPTS ON
	GL	SRESET

::*********************************************************************
::
::	SINERR:	PLAIN OLD ERROR
::
::*********************************************************************

SINERR	HS	0
	EXBR	R3,R3			:MOVE KEY UP
	OR	R3,LN			:COMBINE WITH 2*LINE
	SRLS	R3,1			:<KEY><LINE> IN R3
	LHI	LN,-SBASE,LN		:REMOVE SIO LINE BIAS
	SLLS	LN,3			:FORM QUAD-WORD ADDRESS
	STH	R5,PHSIOT+8,LN,		:STORE STAT,PORT,0,CC		###OAS
	GL	PHSIOT
	LHL	R4,SINTDX		:GET SIO INTERRUPT TABLE INDEX
	AIS	R4,1			:BUMP AND
	NHI	R4,7			:AND ADJUST FOR WRAP AT 8
	STH	R4,SINTDX		:AND RESTORE
	STH	R5,SINCNT,R4,R4		:STORE STAT,PORT,0,CC		###OAS
	LIS	R4,1
	AHM	R4,SINNUM		:BUMP SIO INTERRUPT COUNT
	LPSWR	R0

::*********************************************************************
::
::	STEST:
::
::**********************************************************************

STEST	LPSWR	R0

	EI	:SILINS

	SUBTTL	SYLVEX (INTSIR - SIO ring card interrupt handler)

	IF	SIORNG

::*********************************************************************
::
::	INTSIR:	HANDLE INTERRUPT FROM SIO RING CARD.
::		STATUS IS STORED IN CIRCULAR RING, SO MULTIPLE INTERRUPTS
::		CAN BE DETECTED BY BACKGROUND LOGIC.
::
::*********************************************************************

INTSIR	HS	0
	SSR	R2,R3			:READ SIO STATUS INTO R3
	LHL	R4,PHSIRI,,		:GET RING IN POINTER
        GL	PHSIRI 
	STH	R3,PHSIRX,R4,		:STORE STATUS IN RING
	GL	PHSIRX
	AIS	R4,2
	NHI	R4,SIRXSZ-1		:ADVANCE RING POINTER
	GL	SIRXSZ
	CLH	R4,PHSIRO,,		:RING FULL?
	GL	PHSIRO
	JEFS	INTSR4			:YES - DON'T UPDATE POINTER
	STH	R4,PHSIRI,,		:STORE UPDATED POINTER
INTSR4	LPSWR	R0			:DONE

	EI	:SIORNG

	SUBTTL	SYLVEX (PHASE0 - Clock interrupt handler)

::*********************************************************************
::
::	PHASE0:	CLOCK INTERRUPT HANDLER
::
::	PHASE0 HANDLES INTERRUPTS GENERATED BY THE MICROCODE AS A
::	RESULT OF R14 IN REG SET 13 BEING DECREMENTED TO A VALUE <= 0.
::
::	Come here in register set 13, with R14 zero (or neg?), R15
::	vector pointing to here, and R13 containing 1 (apparently).
::
::	Comment in SHARE--Engines with enhanced async microcode take
::	clock interrupts at LPSW(R)--not through vectors.
::
::	IF THE MACHINE IS A SOLO TYMSAT SUPPORTING 4800 BAUD TERMINALS,
::	INTERRUPTS ARE ENABLED PRIOR TO DOING A CONTEXT SWITCH OR PROCESS
::	SCHEDULE. SINCE THIS COSTS SEVERAL EXTRA INSTRUCTIONS, INTERRUPTS ARE
::	NOT ENABLED FOR SWITCHERS OR 1200 BAUD TYMSATS.
::
::	THE FOLLOWING SOFTWARE CLOCKS EXIST:
::
::	NAME	TICK TIME (SEC)		RESET TO (TICS)
::	------	----------------	-----------------
::	SBASCK	1/600			5	counter for running SCHED
::	SLBSCK	5/600			120	counter for inc'ing SLOWC
::	SLOWC	1			N/A	1 sec sys clock
::	FASTC	1/600			N/A	highest resolution sys clock
::	SCLOCK	5/600			?N/A	for scheduling periodics
::
::************************************************************************

	IF	SOLOCS		:IF ASYNC TYMSAT
PHSTIK	EQ	1^BAUDR		:ALLOW FOR 3660 HZ AND 14400 HZ INTERRUPTS
	ELSE			:IF NOT ASYNC TYMSAT
PHSTIK	EQ	1		:EXPECT INTERRUPTS AT 3660 HZ ONLY
	EI	:SOLOCS

:	CLOCK HANDLER ROUTINE
PHASE0	HS	0
	AIS	R14,PHSTIK		:INC CLOCK TO TICK EVERY 1/600 SEC
	IF	WHEREE
	LR	R3,R1
	NI	R3,0FFFF		:STRIP OFF SEG1
WSHFT	SRLS	R3,4			:RESOLUTION TO 16 BYTES
	AHM	R13,PHWHTA,R3,R3
	EI	:WHEREE
	AM	R13,FASTC		:INCREMENT FASTC CELL
	AHM	R13,SBASCK		:AND SCHED ROUTINE TIMER
	JGE	SCHED			:TIME TO RUN SCHED, BRANCH
	AHM	R13,USRTIM		:SEE IF CURRENT USER'S TIME IS UP
	JGEFS	PHASEB			:YES, GO DISMISS
	LPSWR	R0			:NO, RETURN TO CURRENT USER

PHASEB	HS	0
	ST	R0,SCHSAV		:save PSW and PC for reg set swap
	ST	R1,SCHSAV+4
	LHI	R3,4000
	EPSR	R4,R3			:GO TO SET 0 WITH INTERRUPTS ON
	LHL	R3,USRRET		:ADDR OF DISMISS-SERVER, CURRENT USER
	L	R0,SCHSAV		:recover PSW and PC
	L	R1,SCHSAV+4
	JR	R3			:AND GO TO IT

:	PATCH AREA FOR PERFORMANCE MEASUREMENT

	HS	80			:PATCH AREA FOR PERFORMANCE MEASUREMENT

::*********************************************************************
::
::	SCHED:
::	PHASE0 TRANFERS HERE AFTER IT HAS TAKEN 'SCRATE' CONSECUTIVE
::	INTERRUPTS, SO SCHED RUNS EVERY 'SCRATE'/600 SECONDS.
::
::	SCHED SCHEDULES THE NODE CODE PERIODIC ROUTINES AND INCREMENTS
::	SLOWC IF ONE SEC HAS PASSED SINCE THE LAST INCREMENT.
::
::*********************************************************************

SCHED	HS	0
	IF	BAUDR-1			: (SOLOCS) 4800 BAUD
	ST	R0,SCHSAV
	ST	R1,SCHSAV+4
	LHI	R3,4000
	EPSR	R4,R3			:GO TO SET 0 WITH INTERRUPTS ON
	LIS	R13,1
	EI	:(SOLOCS) BAUDR-1 4800 TYMSAT
	LCS	R4,SCRATE		:SET NEW TIME FOR SCHED TO RUN...
	STH	R4,SBASCK		:...BY REINITIALIZING SBASCK TO -SCRATE
	AHM	R13,SLBSCK		:UPDATE INTERMEDIATE CLOCK
	JN	SCHE2			:NOT TIME TO INCREMENT SLOWC YET

	LHI	R4,-$A600/SCRATE	:REINITIALIZE INTERMEDIATE CLOCK
	STH	R4,SLBSCK
	AM	R13,SLOWC		:AND INCREMENT SLOWC
	LHL	R4,PHCNSL+2		:CONSOL DISPLAY
	GL	PHCNSL
	LHL	R5,PHCNSL
	A	R5,PHCNSL+4
	CIO	R4,R4			:OUTPUT TO CONSOL
	LIS	R2,4			:READ TEMPERATURE, VOLTAGE, PRESSURE
	RDR	R2,R4			:TEMPERATURE FIRST, INTO R4
	STB	R4,PHTEMP		:STORE IT INTO 'TEMPER'
	GL	PHTEMP
	SSR	R2,R4			:VOLTAGE NEXT
	STB	R4,PHVOLT		:STORE IT INTO 'VOLTAGE'
	GL	PHVOLT
	LB	R4,PHWDOG,,		:SHOULD WE UPDATE WDOG TIMER?
	GL	PHWDOG
	JNFS	SCHE2			:NO,SKIP

	LIS	R4,2			:YES, COMMAND TO WATCHDOG (LO BIT 0)
	LIS	R2,5			:ADDRESS
	WDR	R2,R4

::*********************************************************************
::
::	SCHE2:
::	COME HERE EVERY SCRATE/600 SECOND TO SEE WHICH PERIODIC
::	ROUTINE NEEDS TO BE SCHEDULED. 
::
::	THIS IS DONE BY SETTING THE APPROPRIATE BIT IN
::	SQUEUE.  THE ACTUAL DISPATCHING OF THE TASKS IS DONE
::	IN THE NODE CODE EXEC LOOP.
::
::*********************************************************************

SCHE2	HS	0
	AHM	R13,SCLOCK		:INC THE PROCESS CLOCK 
	IF	SOLOCS
	LHI	R3,01F-PASYNC		:TYMSAT ASYNC ROUTINE GETS SCHEDULED
	GL	PASYNC
	SBT	R3,PHSQUE		:EVERY TICK OF SCLOCK (SCRATE/600 SEC)
	EI	:SOLOCS
	LB	R3,SCLOCK+1		:COMPUTE LOWEST ORDER BIT
	JEFS	SCHE1			:TRY HI-ORD BYTE
	LB	R3,SCHLBT,R3		:YIELDS INDEX INTO SCHEDULE
	L	R3,PHSCTB,R3		:SCHEDULE ENTRY
	GL	PHSCTB
	O	R3,PHSQUE
	ST	R3,PHSQUE
	IF	BAUDR-1			: (SOLOCS) IF 4800 BAUD TYMSAT
	LPSW	SCHSAV
	ELSE	:
	LPSWR	R0			:RETURN TO USER
	EI	:(SOLOCS) BAUDR-1 4800 TYMSAT

SCHE1	LB	R3,SCLOCK
	JEFS	SCHE3			:NOTHING TO DO THIS TIME
	LB	R3,SCHLBT,R3
	L	R3,PHSCTB-20,R3		:SCHEDULE
	O	R3,PHSQUE
	ST	R3,PHSQUE
SCHE3	HS	0
	IF	BAUDR-1			: (SOLOCS)IF TYMSAT AND 4800 BAUD
	LPSW	SCHSAV
	ELSE	:
	LPSWR	R0			:RETURN
	EI	:(SOLOCS) BAUDR-1 4800 TYMSAT

	BC	0
CONSCM	BC	40		:INCREMENTAL CONSOLE MODE

:	TABLE GIVING 4*(# OF LOW BIT)

	NOLIST
Q	EQ	0		:TABLE GIVING 4*(# OF LOW BIT)
SCHLBT	RE	100
XX	EQ	0
	IF	Q&80;XX EQ 08; EI
	IF	Q&40;XX EQ 09; EI
	IF	Q&20;XX EQ 0A; EI
	IF	Q&10;XX EQ 0B; EI
	IF	Q&08;XX EQ 0C; EI
	IF	Q&04;XX EQ 0D; EI
	IF	Q&02;XX EQ 0E; EI
	IF	Q&01;XX EQ 0F; EI

	BC	4*XX;Q EQ Q+1; ER
	LIST
VPHSIZ	EQ	.		:PRIVILEDGED CODE SIZE##AL
	EI	:1-ISIS

	EI	:1-KILLIT

	KILMSG(SYLVEX)

:	****NOTHING PAST THIS POINT****
  

	SUBTTL	DATA

:			****    *   *****   *
:			*   *  * *    *    * *
:			*   * *****   *   *****
:			*   * *   *   *   *   *
:			****  *   *   *   *   *

::#####################################################################
::
::	MODULE:		DATA
::
::	FUNCTION:	Define Data Storage areas, equates and constants,
::		tables structures, parameter defaults, crash codes,
::		crypto messages, etc.
::
::	SUBTTLS:
::		Crash Codes
::		Parameter Defaults
::		Equates and Constants
::		Crypto Messages
::		Table Structure Variables
::		Low Core SEG 0 Variables
::		Segment 0 -  Data Areas
::		Segments 2 & 3 - Buffer Descriptors
::		Segment 4 - Solo CONSAT or
::			  - Kernel Communications
::		Segment 5 - Supervisor Communications
::		Segment 6,7,8,9 - IOTAB and Bufferlets
::		Segment B - SYNC Input 
::		Segment C - Table Storage
::		Segment E - ISIS only
::		Segment F - ISIS only
::
::#####################################################################

	IF 1-KILLIT
	BEGMO.

::*********************************************************************
::
::	CRASH CODES:
::	All crash codes are defined here.  New crash codes should be added
::	at the end of this list, they must not be inserted since this would
::	change the definition of codes which follow the insertion.  They
::	should not be under any switches.
::
::*********************************************************************

.EXCRH	DFCRH.(.EXCRH,C.SWCE,0,EXCRH EXEC tried to dispatch to nonexistent process%(PROCID*2 in R2))
.BIDCR	DFCRH.(.BIDCR,C.INML,0,BIDCR BIDDY found nothing to do.%  (R1 = dispatch array - should be non-zero))
.YKMCR	DFCRH.(.YKMCR,C.HWCE,0,YKMCR YAKMAC tried to recover from MAC error`, failed.  %KD contains difference between expected and actual KD's.)
.BIDHC	DFCRH.(.BIDHC,C.INML,0,BIDHC JFFOH failure.)
.BIDC0	DFCRH.(.BIDC0,C.INML,0,BIDC0 JFFO error.)
.SV39C	DFCRH.(.SV39C,C.SVER,39*2,SV39C ISIS connect SIO line SVC error.)
.SV3BC	DFCRH.(.SV3BC,C.SVER,3B*2,SV3BC ISIS start SIO output SVC error.)
.SV3AC	DFCRH.(.SV3AC,C.SVER,3A*2,SV3AC ISIS start SIO input SVC error.)
.SV0CC	DFCRH.(.SV0CC,C.SVER,0C*2,SV0CC SOLO connect SIO line SVC error.)
.SV0EC	DFCRH.(.SV0EC,C.SVER,0E*2,SV0EC SOLO start SIO output SVC error.)
.SV0DC	DFCRH.(.SV0DC,C.SVER,0D*2,SV0DC SOLO start SIO input SVC error.)
.SV38C	DFCRH.(.SV38C,C.SVER,38*2,SV38C ISIS get SIO status SVC error.)
.SV0FC	DFCRH.(.SV0FC,C.SVER,0F*2,SV0FC SOLO get SIO status SVC error.)
.SV32C	DFCRH.(.SV32C,C.SVER,32*2,SV32C ISIS force SYNC output SVC error.)
.SV30C	DFCRH.(.SV30C,C.SVER,30*2,SV30C ISIS connect SYNC SVC error.)
.LKER0	DFCRH.(.LKER0,C.SWCE,0,LKER0 LINKER found more than 0 lines on inactive link.)
.O1263	DFCRH.(.O1263,C.SWCE,0,O1263 LINKER found active link with 0 lines.)
.O1463	DFCRH.(.O1463,C.SWCE,0,O1463 LINKER found KDKN/KDSVLN inconsistency.)
.O1663	DFCRH.(.O1663,C.SWCE,0,O1663 LINKER found active line marked inactive.)
.O1863	DFCRH.(.O1863,C.SWCE,0,O1863 LINKER found NLAT .NE. sum of lines fields.)
.SIER0	DFCRH.(.SIER0,C.SWCE,0,SIER0 SOLO SIO CCW chaining failure.)
.RTZC0	DFCRH.(.RTZC0,C.SWCE,0,RTZC0 RTD detected zapper for circuit with null P/T entry.)
.RMEB0	DFCRH.(.RMEB0,C.SWCE,0,RMEB0 RMAKE found buffer empty.)
.RMZLR	DFCRH.(.RMZLR,C.SWCE,0,RMZLR RMAKE couldn't find 2nd character of 00/01 pair.)
.RMZL3	DFCRH.(.RMZL3,C.SWCE,0,RMZL3 RMAKE couldn't find 2nd character of 03 pair.)
.RMNER	DFCRH.(.RMNER,C.SWCE,0,RMNER NEDOUT <= 0 in RMAKE.)
.RMKNE	DFCRH.(.RMKNE,C.SWCE,0,RMKNE RMAKE NEEDLE ERROR)
.RMKHS	DFCRH.(.RMKHS,C.SWCE,0,RMKHS RMAKE NEGATIVE LOGICAL RECORD COUNT)
.RMHS3	DFCRH.(.RMHS3,C.SWCE,0,RMHS3 RMAKE NEGATIVE LOGICAL RECORD COUNT)
.RMZL0	DFCRH.(.RMZL0,C.SWCE,0,RMZL0 RMAKE ZERO LENGTH RECORD)
.RMNE0	DFCRH.(.RMNE0,C.SWCE,0,RMNE0 RMAKE NEEDLE OUTSTANDING, NEEDOUT NOT POSITIVE)
.RMPER	DFCRH.(.RMPER,C.SWCE,0,RMPER RMAKE BAD PERF MON CHAR)
.RMZL1	DFCRH.(.RMZL1,C.SWCE,0,RMZL1 RMAKE ZERO LENGTH RECORD)
.RMBE0	DFCRH.(.RMBE0,C.SWCE,0,RMBE0 RMAKE BUFFER EMPTY)
.RMTIE	DFCRH.(.RMTIE,C.SWCE,0,RMTIE RMAKE BAD 03-PAIR TO T-I NEIGHBOR)
.RMTNS	DFCRH.(.RMTNS,C.SWCE,0,RMTNS RMAKE):???
.RMHS2	DFCRH.(.RMHS2,C.SWCE,0,RMHS2 RMAKE ILLEGAL 02 FOR HISTORY):###TZ
.KERIC	DFCRH.(.KERIC,C.INML,0,KERIC JFFO failure.)
.KERI0	DFCRH.(.KERI0,C.SWCE,0,KERI0 KERIN found 0 P/T entry.)
.KICTC	DFCRH.(.KICTC,C.SWCE,0,KICTC XHOSTS found invalid 03 pair from kernel.)
.KRCXC	DFCRH.(.KRCXC,C.SWCE,0,KRCXC XHOSTS detected invalid control record from kernel.)
.KRXCA	DFCRH.(.KRXCA,C.SWCE,0,KRXCA XHOSTS detected invalid ack from kernel.)
.SUPIC	DFCRH.(.SUPIC,C.SWCE,0,SUPIC XHOSTS supe interface - no circuit.)
.SUPI0	DFCRH.(.SUPI0,C.SWCE,0,SUPI0 XHOSTS supe interface 0 length record.)
.SUPI1	DFCRH.(.SUPI1,C.SWCE,0,SUPI1 XHOSTS supe interface empty buffer.)
.DISI0	DFCRH.(.DISI0,C.SWCE,0,DISI0 DISPI found no dispatcher circuit.)
.DISO0	DFCRH.(.DISO0,C.SWCE,0,DISO0 DISPI got RPORT out of range from dispatcher.)
.DSOC0	DFCRH.(.DSOC0,C.SWCE,0,DSOC0 DISPI dispatcher output msg type invalid.)
.DSZE0	DFCRH.(.DSZE0,C.SWCE,0,DSZE0 DISPI got junk from dispatcher on channel 0.)
.DSIO0	DFCRH.(.DSIO0,C.SWCE,0,DSIO0 DISPI invalid message from dispatcher)
.DSKP0	DFCRH.(.DSKP0,C.SWCE,0,DSKP0 DISPI DSK type too large.)
::*	Crash codes used in SWITCH
.WCIC0	DFCRH.(.WCIC0,C.SWCE,0,WCIC0 SWITCH illegal WCI to buffer 1 or 0.)
.WCIC1	DFCRH.(.WCIC1,C.SWCE,0,WCIC1 SWITCH invalid WCI buffer index.)
.WRECR	DFCRH.(.WRECR,C.SWCE,0,WRECR SWITCH reserve tank empty.)
.GCICR	DFCRH.(.GCICR,C.SWCE,0,GCICR SWITCH GCI buffer 0.)
.GCIC0	DFCRH.(.GCIC0,C.GCEB,0,GCIC0 SWITCH GCI for empty buffer or bad buffer index.)
.CBCLC	DFCRH.(.CBCLC,C.SWCE,0,CBCLC SWITCH CBCLR bad buffer index.)
.CBCL0	DFCRH.(.CBCL0,C.SWCE,0,CBCL0 SWITCH CBCLR invalid channel number.)
.RTBLC	DFCRH.(.RTBLC,C.SWCE,0,RTBLC SWITCH RETBLT BCT went < 0)
.CRQCR	DFCRH.(.CRQCR,C.SWCE,0,CRQCR SWITCH CRQ bad buffer index.)
.CRQC0	DFCRH.(.CRQC0,C.SWCE,0,CRQC0 SWITCH CRQ needle garbage.)
.LEPCR	DFCRH.(.LEPCR,C.SWCE,0,LEPCR SWITCH LEP invalid rebild reject.)
.INTCR	DFCRH.(.INTCR,C.SWCE,0,INTCR SWITCH INHST found no work to do.)
.SUPCR	DFCRH.(.SUPCR,C.SWCE,0,SUPCR SWITCH invalid accounting data type from supe.)
.CRQC2	DFCRH.(.CRQC2,C.SWCE,0,CRQC2 SWITCH CRQ buffer out of range.)
.ZAPCR	DFCRH.(.ZAPCR,C.SWCE,0,ZAPCR SWITCH ZAPX bad IOTAB entry.)
.ZAPC0	DFCRH.(.ZAPC0,C.SWCE,0,ZAPC0 SWITCH ZAPV bad IOTAB entry.)
.ZAPC1	DFCRH.(.ZAPC1,C.SWCE,0,ZAPC1 SWITCH ZAPV bad compementary BF.)
.GFCR0	DFCRH.(.GFCR0,C.SWCE,0,GFCR0 SWITCH GFCBUF no more buffers.)
.GFCR1	DFCRH.(.GFCR1,C.IFLP,0,GFCR1 SWITCH GFCBUF invalid free list pointer.)
.GFCR2	DFCRH.(.GFCR2,C.SWCE,0,GFCR2 SWITCH GFCBUF invalid link buffer pointer.)
.GFCR3	DFCRH.(.GFCR3,C.SWCE,0,GFCR3 SWITCH GFCBUF bad buffer index.)
.RFCR0	DFCRH.(.RFCR0,C.SWCE,0,RFCR0 SWITCH RFCBUF invalid buffer index.)
.FNCHC	DFCRH.(.FNCHC,C.SWCE,0,FNCHC SWITCH FNDCHN ACP consistency error.)
.FNCH0	DFCRH.(.FNCH0,C.SWCE,0,FNCH0 SWITCH FNDCHN ACP/IOTAB consistency error.)
.BUBCR	DFCRH.(.BUBCR,C.SWCE,0,BUBCR SWITCH BUBBLE BF/NIOTAB consistency error.)
.BUBC0	DFCRH.(.BUBC0,C.SWCE,0,BUBC0 SWITCH BUBBLE LKAPND consistency error.)
.BUBC1	DFCRH.(.BUBC1,C.SWCE,0,BUBC1 SWITCH BUBBLE IOTAB consistency error.)
.CBCT0	DFCRH.(.CBCT0,C.SWCE,0,CBCT0 SWITCH CBCCT-BCT consistency error.)
.ASLO0	DFCRH.(.ASLO0,C.SWCE,0,ASLO0 ASYNC ASYLOU no ANITAB entry for port.)
.ASLO1	DFCRH.(.ASLO1,C.SWCE,0,ASLO1 ASYNC ASYLOU ANITAB entry not complement of .LGBUF.)
.ASC20	DFCRH.(.ASC20,C.SWCE,0,ASC20 ASYNC 02 character pair toward port.)
.ASC30	DFCRH.(.ASC30,C.SWCE,0,ASC30 ASYNC invalid 03 character pair toward port.)
.ASY30	DFCRH.(.ASY30,C.SWCE,0,ASY30 ASYNC illegal ALIERR code.)
.GCHCR	DFCRH.(.GCHCR,C.SWCE,0,GCHCR ASYNC invalid prefix code.)
.PTSGC	DFCRH.(.PTSGC,C.SWCE,0,PTSGC ASYNC invalid signal from CONSAT.)
.ASLO2	DFCRH.(.ASLO2,C.SWCE,0,ASLO2 ASYNC)
.CPKCR	DFCRH.(.CPKCR,C.SWCE,0,CPKCR ASYNC)
:
:	NEW CRASH CODES TYPE C.SWCE ARE ADDED HERE REGARDLESS OF LOCATION
:	IN THE CODE IN ORDER TO LEAVE PREVIOUS C.SWCE CRASH SUBTYPES THE SAME
:	(C.SWCE CRASH SUBTYPES ARE SEQUENTIAL BY ORDER OF DFCRH. INVOKATIONS).
:
.RMHS4  DFCRH.(.RMHS4,C.SWCE,0,RMHS4 YAKYAK RMAKE LRC<0 after fat gob shrink.)
.NEGBF	DFCRH.(.NEGBF,C.SWCE,0,NEGBF YAKYAK BFLTSV<0 AFTER BUFFERLET ACQ OR REL)
.NEGHB	DFCRH.(.NEGHB,C.SWCE,0,NEGHB YAKYAK HBFTSV<0 AFTER HIST BUF ACQ OR REL)
.WREFL	DFCRH.(.WREFL,C.SWCE,0,WRE SWITCH ILLEGAL CALL TO WRE - POSSIBLE MACERROR)
.CSCRS	DFCRH.(.CSCRS,C.SWCE,0,CONSAT CRASH - R10 = CALLER)
.XSCRH	DFCRH.(.XSCRH,C.SWCE,0,XRAY set-by-user crash: SC command)
.SNICR	DFCRH.(.SNICR,C.SWCE,0,DISPI bad SNI recv'd from sup)

.STKOV	DFCRH.(.STKOV,C.SWCE,0,stack storage overflow)  :##AL
.STKUN	DFCRH.(.STKUN,C.SWCE,0,stack storage underflow) :##AL

:	The following crash codes are for solo consat.	###LSH

.GCBF0	DFCRH.(.GCBF0,C.SWCE,0,GETCHR negative buffer number)
.GCBF1	DFCRH.(.GCBF1,C.SWCE,0,GETCHR invalid buffer 0)
.GCBF2	DFCRH.(.GCBF2,C.SWCE,0,GETCHR BF of buffer is dead)
.GTCR1	DFCRH.(.GTCR1,C.SWCE,0,GETCHR negative value in PFXSIG table)
.GTCR2	DFCRH.(.GTCR2,C.SWCE,0,GETCHR illegal 02 pair)
.GTCR3	DFCRH.(.GTCR3,C.SWCE,0,GETCHR invalid 03 pair)
.PCBF1	DFCRH.(.PCBF1,C.SWCE,0,PUTCHR invalid buffer 0)
.PCBF2	DFCRH.(.PCBF2,C.SWCE,0,PUTCHR BF of buffer is dead)
.PSBF1  DFCRH.(.PSBF1,C.SWCE,0,PUTSIG invalid buffer 0)
.PSBF2	DFCRH.(.PSBF2,C.SWCE,0,PUTSIG BF of buffer is dead)
.PSGR0	DFCRH.(.PSGR0,C.SWCE,0,PUTSIG signal number too large)
.PSGR1	DFCRH.(.PSGR1,C.SWCE,0,PUTSIG invalid signal)
.SNDR0	DFCRH.(.SNDR0,C.SWCE,0,SNDLOG get a signal from .LGBUF)
.EMTR0	DFCRH.(.EMTR0,C.SWCE,0,EMPTY BF of buffer is dead)
.ASYRW	DFCRH.(.ASYRW,C.SWCE,0,ASYNC RING WRAP)

	SUBTTL	DATA (Parameter DEFAULTs)

::*********************************************************************
::
::	PARAMETER DEFAULTS:
::
::*********************************************************************

	DEFAULT(NUMPRN,0)
	DEFAULT(NMPVC,0)
	DEFAULT(NSPORT,0)
	DEFAULT(NAPORT,0)
	DEFAULT(NPORT,0)
	DEFAULT(NRPORT,0)
	DEFAULT(NPGRP,0)
	DEFAULT(BKMPVC,0)
	DEFAULT(PRIMSG,0)	:PRIORITY CRYPTO MSG.
	IF	T2GATE
	IF	PRIMSG
	DEFAULT(CRYPPS,100)
	EI	:PRIMSG
	DEFAULT(CRYPRS,400)	:Gateway will always default to smaller buffers
	DEFAULT(TRRSIZ,200)
	DEFAULT(TRTBSZ,80)
	DEFAULT(HISTSZ,40)
	ELSE
	IF	PRIMSG
	DEFAULT(CRYPPS,400)	:SIZE OF PRIORITY MSG BUFFER (MUST BE PWR 2)
	EI	:PRIMSG
	DEFAULT(CRYPRS,1000)	:SIZE OF CRYPTOGRAM BUFFER (MUST BE PWR 2)
	DEFAULT(TRRSIZ,400)	:CHARACTER TRACE RING SIZE
	DEFAULT(TRTBSZ,100)	:UPSW TRACE CAN STORE $A 64 ENTRIES
	DEFAULT(HISTSZ,80)
	EI	:T2GATE

	IF	ISIS
	DEFAULT(DRSZ,400)	:!!!NOTE: MUST BE POWER OF 2!!!
	SYAD(DRSZ  )
	EI 	:ISIS

	IF	DB.CPU
	DEFAULT(CPUTNE,0)	:INIT COUNT OF CPUT ENTRIES
	DEFAULT(CPUTMX,$A50)	:MAX NO. ENTRIES IN CPUTLB
	DEFAULT(CPUTSZ,6)	:SIZE OF ENTRY IN CPUTTB
	DEFAULT(CPTBHW,2)	:COUNT OF TIMES PROCESS CPUTIL WAS TERMINATED
				:WITHOUT YIELDING OR DISMISSING, TO INDICATE
				:HOW NAMY FALSE DISMISSES WILL BE INDICATED.
				:USED TO RECONCILE DISPATCH COUNT WITH DISMISS
				:COUNT###OAS
	DEFAULT(CPTBCT,4)	:COUNT FIELD IN CPUTTB
	EI 	:DB.CPU

	SUBTTL	DATA (EQuates and constants)

::*********************************************************************
::
::	REGISTER DEFINITIONS:
::
::*********************************************************************

TC	EQ	R15		:FOR TRUNCATING RING POINTERS (POWER OF 2 MASK)
LRC	EQ	R14		:LOGICAL RECORD BYTE COUNT
PRC	EQ	R10		:PHYSICAL DITTO
CHN	EQ	R5		:CHANNEL #

TYC	EQ	R11		:HOLDS MAGIC CONSTANT (03 OR 07)
HN	EQ	CD		:HOST #
KP	EQ	R7		:KERNEL PORT BUFFER OFFSET

::*********************************************************************
::
::	EXEC PARAMETERS:
::
::*********************************************************************

	IF	SYNFCS 
VERSION	EQ	$8 0554!10000*ISIS!20000*SOLOCS!30000*T2GATE
				 	:VERSION NUMBER -- ???
	ELSE
VERSION	EQ	$8 0525!10000*ISIS!20000*SOLOCS!30000*T2GATE :VERSION NUMBER
	EI	:SYNFCS 

FCSVER	EQ	$8 0554			:TEST VERSN FOR FCS CKSM	##AL
REVLEV	EQ	(VERSION)&($877)	:REVISION LEVEL
CTBVER	EQ	1			:CRASH TABLE VERSION

	IF	ISIS
FASTC	EQ	0F0004		:FASTC
LO.CLK	EQ	0F001C		:SEGF HW REFERENCE PTR TO SLOT CLOCKS	###OAS
	SYAD(FASTC )
SLOWC	EQ	0F0008		:ISIS MAINTAINS SLOWC RESOLVED TO A SECOND
	SYAD(SLOWC )
     IF T2GATE                  :gateway has no kernel
IKERNL  EQ      0
     ELSE
IKERNL	EQ	1		:ENABLE ISIS KERNEL CODE
     EI
RKERNL	EQ	0		:DISABLE REAL KERNEL CODE
NHOSTS	EQ	NUMHST		:# OF HOSTS, TYMFILE SPEC (DEFAULTED 64 OR 128)
MLINEL	EQ	1F		:MASK FOR MAX NUMBER OF LINES

	ELSE	:(NOT) ISIS
FASTC	EQ	0E0000
	SYAD(FASTC )
SLOWC	EQ	0E0008		:VIRTUAL ADDRESS OF SLOWC
	GL	SLOWC
	SYAD(SLOWC )
C3600	EQ	0E001C		:SUPERFAST CLOCK
IKERNL	EQ	0		:NO ISIS KERNEL
RKERNL	EQ	KERNEL/KERNEL	:REAL KERNEL
NDP	EQ	0		:NO DISPATCHER PORTS
NHOSTS	EQ	1		:# OF HOSTS
	EI 	:(NOT) ISIS

:	OTHER DEFINITIONS:
RECBSZ	EQ	$A 128		:SIZE OF RECORD BUFFERS
SVNBSZ	EQ	100		:SIZE OF SYNC LINE INPUT BUFFERS
RATE	EQ	$A600		:FAST CLOCK TICKS/SEC

::*********************************************************************
::
::	LINKER PARAMETERS:
::
::*********************************************************************

	RA	0A		:SET DECIMAL RADIX

XGRP	EQ	0		:XGRP RECORDS THE NUMBER OF LINKS SPECIFYING
				: GREATER THAN 8 GROUPS AT ASSEMBLY TIME.

Q	EQ	0
	RE	NLINKS		:DEFINE # OF CHANNELS/LINK
	DEFAULT(NGRP|Q|,8)	:DEFAULT VALUE FOR NGRPx IS 8
NGRP|Q|	EQ	(NGRP|Q|+7)&$00F8 :NUMBER OF GROUPS MUST BE MULTIPLE OF 8
	IF	(NGRP|Q|-8)
XGRP	EQ	XGRP+1		:GREATER THAN 128 CHANNELS SPECIFIED FOR LINK
	EI 	:NGRP|Q|-8
NCH|Q|	EQ	16*NGRP|Q|	:16 CHANNELS PER GROUP
Q	EQ	Q+1
	ER

NRECDS	EQ	0		:COMPUTE TOTAL #PHYS RECORDS
Q	EQ	0
	RE	NLINKS
	DEFAULT(WSIZ|Q|,8)	: if not defined, Window size defaults to 8
	IF	((WSIZ|Q|+3)/4-(WSIZ|Q|)/4)
	REMARK	%%***WINDOW SIZE MUST BE MULTIPLE OF 4 !!!***%%
	KILLER(1)		:kill assembly
	EI
NRECDS  EQ      NRECDS+2*WSIZ|Q|
Q	EQ	Q+1
	ER

	RA	0		:RESTORE HEX RADIX
	IF	1-EXPWSZ
	IF	(NRECDS-200)	:TOTAL OF ALL WINDOW-SIZES MUST NOT
				: EXCEED 256d
	KILLER(1)
	REMARK	%!!!TOTAL OF WINDOW-SIZES FOR ALL LINKS
	REMARK	%!!!MUST NOT EXCEED 256d (100x).  THIS
	REMARK	%!!!CONFIGURATION REQUIRES A TOTAL WINDOW-
	REMARK	%!!!SIZE OF
	NUMBER	$ANRECDS/2
	REMARK	d.  MUST BE REDUCED!!!%

	EI 	:NRECDS-200
	EI	:1-EXPWSZ

:	CALCULATE PERMUTER TABLE SPACE - INCLUDE NSP IN CALCULATIONS	###gt
TCHANS	EQ	80*(NLINKS+2+2*NPTHR/80+NSP/80) :TOTAL NUMBER OF LINK CHANNELS

TINTCH	EQ	$A 16		:TOTAL NUMBER OF INTERNAL HOST CHANNELS
				:.... MUST BE POWER  OF 2

:	SYNC LINE TRACE OPTION:

	IF	DB.TSN
	IF	T2GATE
	DEFAULT(TSTSZE,80)
	ELSE
	DEFAULT(TSTSZE,200)	:200 BYTES, 200/TSESZE ENTRIES
	EI	:T2GATE
	ELSE	:NOT DB.TSN
TSTSZE	EQ	0		:IF NOT DB.TSN, TRACE-SYNC TABLE SIZE = 0
	EI 	:DB.TSN

:	NOTE THAT IF DB.TSN IS SPECIFIED AND TSTSZE IS DEFINED WITH
:	A ZERO VALUE, THE TRACE-SYNC OPTION IS NOT ENABLED. IF TSTSZE IS
:	SPECIFIED, IT MUST BE A POWER OF 2.

	IF	TSTSZE

:	TRACE-SYNC PACKAGE ENABLED. AN ENTRY IS MADE IN A TABLE FOR EACH
:	SYNC LINE EVENT DETECTED FOR A PARTICULAR LINK OF INTEREST. WHEN THE
:	OPTION IS ENABLED IN A NODE, THE TRACING BEGINS WHEN THE 'TSLINK'
:	HALFWORD IS PATCHED WITH THE NEIGHBOR NUMBER ON THE LINK TO BE TRACED.
:	SYNC LINE EVENTS FOR ALL LINES ON THE LINK ARE RECORDED. THE TRACING
:	ENDS WHEN THE NODE DECLARES THE LINK OUT, EITHER BY DETECTING A RESET
:	OR BY RECEIVING NO GOOD RECORDS IN A FOUR-SECOND INTERVAL. EACH SYNC
:	ENTRY IS TSESZE (8) BYTES LONG, WITH THE FORMAT:
:
:	______________________________________________________________
:
:	| TYPE | LINE |      PACKET HEADER     |      FASTC TIME     |
:	______________________________________________________________
:	   1       1	       3 BYTES		       3 BYTES
:
:	SINCE THE SYNC LINE RECEIVER ROUTINES (SYLVER) RUN AS A FOREGROUND
:	PROCESS IN ISIS, TWO TABLES ARE MAINTAINED: TSFTBL FOR FOREGROUND (LINE
:	RECEIVER) EVENTS, AND TSBTBL FOR BACKGROUND (ATTACH, DETACH, RTD, AND
:	RMAKE) EVENTS. THE EVENT TYPES ARE DEFINED AS FOLLOWS:
:
:	BACKGROUND:
TS.ATT	EQ	3	:LINE ATTACH - HAS 'NLAT' VALUE FROM LINK DESCRIPTOR
			: INSTEAD OF HEADER IN BYTES 2 AND 3.
TS.DET	EQ	2	:LINE DETACH - HAS 'LRT' VALUE FROM LINK DESCRIPTOR
			: INSTEAD OF HEADER IN BYTES 2 AND 3,
			: AND 'DREASON' IN BYTE 4.
TS.MAK	EQ	0	:PACKET QUEUED FOR TRANSMISSION BY RMAKE. BYTE 1 IS
			: 'LAS', BYTE 2 IS FIRST BYTE OF PACKET,
			: BYTE 3 IS 'LRT', BYTE 4 IS PACKET RECORD NUMBER.
TS.RTD	EQ	1	:PACKET TORN BY RTEAR. BYTE 1 IS 'LAS', BYTES 2 - 4
			: ARE ACTUAL PACKET HEADER.

:	FOREGROUND:
TS.HDR	EQ	0	:A ZERO BIT HAS BEEN DETECTED WHILE LINE IS IN MARKING
			: STATE. ALIGNED POTENTIAL HEADER IS IN FIRST 2
			: BYTES OF HEADER FIELD.
TS.RST	EQ	1	:RESET DETECTED ON ATTACHED LINE.
TS.DUM	EQ	2	:DUMMY RECORD DETECTED.
TS.REC	EQ	7	:ENTIRE RECORD RECEIVED WITH GOOD CHECKSUM.
TS.CSE	EQ	3	:ENTIRE RECORD RECEIVED, CHECKSUM ERROR DETECTED.
TS.BAK	EQ	4	:ENTIRE GOOD RECORD RECEIVED, BAD ACK. HAS 'LAR' VALUE
			: FROM LINK DESCRIPTOR IN BYTES 5 AND 6.
TS.RXC	EQ	5	:ENTIRE GOOD RECORD RECEIVED, RETRANSMISSION.
TS.BRN	EQ	6	:ENTIRE GOOD RECORD RECEIVED, BAD RECORD NUMBER.
TS.UAL	EQ	8	:HEADER RECEIVED ON UNASSIGNED LINE
	IF	NAKCOD
TS.NAK	EQ	9	:FORGOUND TRACE FOR NAK PACKET			###AL
	EI

:	NOTE THAT SOME EVENTS UTILIZE ONLY 2 BYTES OF HEADER FIELD
:	IN THAT CASE ALL FOUR BYTES OF FASTC APPEAR.

TSESZE	EQ	8		:ENTRY SIZE (IN BYTES)
	EI	:TSTSZE

WBORIM	EQ	$2 00100000     :T-II MASTER BORI
WBORIS	EQ	$2 00010000     :T-II SLAVE BORI
NAKORI	EQ	$2 01010000	:T-II STARLINK NEGATIVE ACK PACKET
SATSPD  EQ      $2 01000000     :FOR DENOTING SATELLITE TO SUP

RBOTHD	EQ	3010		:TYMSTAR HUB REMOTE-BOOT HEADER		###AL
:	RESET HEADERS

TTRSHD	EQ	30A0		:T-II RESET HEADER FOR NEW LINK
TSRSHD	EQ	30B0		:T-II RESET HEADER FOR SUBSEQUENT LINE ON LINK

TWDMHD	EQ	306978AB	:TYMNET-II DUMMY RECORD
DWNLHD	EQ	3232		:DOWNLINE LOAD RECORD HEADER

KDIGTM	EQ	$A 120		:NUMBER OF SECONDS TO IGNORE LINE WHICH DID
:	NOT PASS PROPER KEY IN RESET SEQUENCE, OR COULDN'T BE ATTACHED DUE TO
:	LACK OF PERMUTER TABLE SPACE.

:	SUP REPORTS ARE TYPE 14, SUBTYPE xx, WHERE xx IS:
LKOVMS	EQ	93		:LINK OVERLOADED SUBTYPE
LKSTMS	EQ	94		:LINK SATURATED SUBTYPE

:	DEFAULT THRESHOLDS ARE DEFINED AS FOLLOWS:

	DEFAULT(LKOVTH,$A 10)	:DEFAULT LINK OVERLOAD THRESHOLD TO 10
	DEFAULT(LKSTTH,$A70)	:DEFAULT SATURATED THRESHHOLD		###TZ

HISPD	EQ	0C		:FOR MS LINE/LINK SPEED REPORTING	###wjl

::*********************************************************************
::
::	YAKYAK PARAMETERS:
::
::*********************************************************************

	DEFAULT(TRIKLV,4)	:THRESHOLD FOR RTD TO DETERMINE 'GUSH' OR
				: 'TRIKLE' BACKPRESSURE REQUIREMENTS

	DEFAULT(T2SRVS,40)	:T-II THRESHOLD FOR SUCCESSIVE CHANNEL SERVICE
				: (SEE RMK10)

::*********************************************************************
::
::	XHOSTS PARAMETERS:
::
::*********************************************************************

:	HOST PID EQUATES
I2ISTP	EQ	37		:ISIS PID				###OAS
TIITYP	EQ	38		:SOLO NODE CODE PID			###OAS
CNSTYP	EQ	39		:SOLO CONSAT PID			###OAS
SUPTYP	EQ	43		:SUPVERSIOR KERNEL PID			###OAS
SKERTY	EQ	48		:SPLIT SUPERVISOR(KERNEL) PID		###OAS

	IF	KNRING
:	DEFINE MESSAGE TYPES FOR CONTROL RINGS
KR.ZAP	EQ	0		:ZAPPER
KR.GOB	EQ	1		:GOBBLER
KR.NLG	EQ	2		:NEWLOG SET-UP
KR.ACK	EQ	80		:INDICATES ACK RESPONSE
KR.ZAK	EQ	KR.ZAP+KR.ACK	:ZAPPER ACK
KR.GAK	EQ	KR.GOB+KR.ACK	:GOBBLER ACK

	IF 	SIORNG		:ALSO IF KNRING
SIRDIE	EQ	30^8+SIORNG	:COMMAND FOR SIO RING CARD TO DIE
SIRALV	EQ	31^8+SIORNG	:COMMAND FOR SIO RING CARD TO COME ALIVE
SIRDWN	EQ	30		:STATUS INDICATING SIO BOARD DOWN (LINE OUT)
SIRUP	EQ	70		:STATUS INDICATING SIO BOARD UP
SIRRM0	EQ	20		:STATUS FOR RING PAIR 0 MISMATCH FROM SIO CARD
STSRM0	EQ	3F		:'SIRFLG' VALUE FOR RING MISMATCH 0
SIRALD	EQ	403F		:'SIRFLG' VALUE FOR ACTIVE LOAD
SIRILN	EQ	3F		:'LINE NUMBER' FOR DOWN-LINE LOAD
SIRDLS	EQ	$A 66*2		:SIO LOAD RING SIZE
       IF       NOSEG           :noseg puts this in seg C
DWLKIB  EQ      SIRDLS+0C0000
       ELSE     :1-NOSEG
DWLKIB	EQ	SIRDLS+40000	:INPUT LOAD RING (NODE-->KERNEL)
       EI       :NOSEG
DWLKII	EQ	DWLKIB		:LOAD RING LOAD POINTER (NODE INDEXED)
DWLKIO	EQ	DWLKII+2	:LOAD RING TRAIL POINTER (KERNEL INDEXED)
DWLKOB	EQ	DWLKIO+2+SIRDLS	:OUTPUT LOAD RING (KERNEL-->NODE)
DWLKOI	EQ	DWLKOB		:OUTPUT RING LEAD POINTER (KERNEL INDEXED)
DWLKOO	EQ	DWLKOI+2	:OUTPUT RING TRAIL POINTER (NODE INDEXED)

SIRXSZ	EQ	80		:SIZE OF INTERRUPT COMMUNICATION RING
	EI	:SIORNG
	EI	:KNRING

::*********************************************************************
::
::	DISPI PARAMETERS:
::
::*********************************************************************

	IF	ISIS

:	Intra-node messages.  Compare with DSZETB jump table for
:	from-dispatcher messages.
INRSRQ	EQ	0	:restart request (unused)
INRSRP	EQ	1	:restart response (unused)
INTKVR	EQ	2	:node has been taken over (from node code)
INRPLG	EQ	3	:report to sup's log (from slot to node code)
INRPHT	EQ	4	:report host status (from ISIS or slot)
INRPAC	EQ	5	:report accounting (ISIS to node code)
INSTTM	EQ	6	:tell host what time it is (from node code)
INPNRQ	EQ	7	:pseudo-needle request (from slot to node code)
INACRQ	EQ	8	:aux-circuit request (from slot to node code)
INPNFL	EQ	9	:pseudo needle request failed (from ISIS or node code)
INRPPT	EQ	0A	:report host port availability (from slot)
INHTRJ	EQ	0B	:host unacceptable (from node code)
INRPCT	EQ	0C	:report host cost (from slot to node code)
INNOSP	EQ	0D	:no supervisor (node code to all slots)
IN1DWN	EQ	0E	:1_DOWN text follows (to slot)
INHTRQ	EQ	0F	:request for report of all hosts (from node code)
INRPHE	EQ	10	:extended host status report (from slot or ISIS)
NCHCST	EQ	88	:host status host cost message type
:	Host status codes for HSTAT
HANSW	EQ	0	:###EV
HDOWN	EQ	1
HSHUT	EQ	2
HGONE	EQ	3

:	Bits in HSTATN byte for EXPANDED HOST STATUS	###jhl
:	The format of this word matches the host status word in the
:	expanded takeover response, node-to-sup msg 19.
EHANSW	EQ	0
EHDOWN	EQ	40
EHSHUT	EQ	80
EHGONE	EQ	0C0
EHSTTS	EQ	0C0		:location of status bits
EHHOPT	EQ	20		:set if host out of ports
EHIIX	EQ	10		:IIX host
EHORGN	EQ	8		:origination only host
EHDSTN	EQ	4		:destination only host

:	Translated values of network messages to send to ISIS
ISDTCH	EQ	09E	:DETACH	###wjl
ISZAPR	EQ	09F	:ZAPPER
ISSTBP	EQ	0A0	:SET BACKPRESSURE
ISRLBP	EQ	0A1	:RELEASE BACKPRESSURE
ISGBLR	EQ	0A2	:GOBBLER
ISBLKB	EQ	0A4	:BLACK BALL
ISGRYB	EQ	0A5	:GREY BALL
ISEDEM	EQ	0A6	:ENTER DEFERRED ECHO MODE
ISLDEM	EQ	0A7	:LEAVE DEFERRED ECHO MODE
ISETRM	EQ	0A8	:ENTER TRM
ISLTRM	EQ	0A9	:LEAVE TRM
ISGRBL	EQ	0AA	:GREEN BALL
ISRDBL	EQ	0AB	:RED BALL
ISYLWB	EQ	0AC	:YELLOW BALL
ISRNGB	EQ	0AD	:ORANGE BALL
ISBRKD	EQ	0AE	:DETECTED BREAK
ISHANG	EQ	0AF	:HANG UP
ISQPRM	EQ	0B0	:QUERY PARAMETER
ISSPRM	EQ	0B1	:SET PARAMETER
ISLGCH	EQ	0B3	:LOGON CHAR
ISACCT	EQ	0B7	:ADDENDUM TO ACCOUNTING
ISHNG	EQ	0B8	:SUPERHANG
ISXLIM	EQ	0B9	:SET XMIT LIMIT
ISEBRK	EQ	0BA	:END OF BREAK
ISZACK	EQ	0BB	:ZAP ACK
ISEADM	EQ	0BC	:ENTER ALTERNATE DEVICE MODE
ISLADM	EQ	0BD	:LEAVE ALTERNATE DEVICE MODE
ISZRSN	EQ	0BE	:ZAP WITH REASON
ISSIIX	EQ	0BF	:ENTER IIX EXCHANGE
ISTIIX	EQ	0C0	:LEAVE IIX EXCHANGE

INXLIM	EQ	9D		:INITIAL XMIT LIMIT
DTDAT	EQ	9D		:LAST DATA TYPE
DTCON	EQ	0C0		:LAST CONTROL TYPE

:	SET DEFAULT VALUES FOR SCLTDF AND SMLTDF TO -1, INDICATING
:	NO LIMITS FOR CIRCUITS/MINUTE AND SLOT REPORTS/MINUTE BY SLOT.
	DEFAULT(SCLTDF,-1)
	DEFAULT(SMLTDF,-1)

:	SET VALUES FOR LIMITS FOR EACH SLOT TO THE DEFAULT IF NOT
:	ALREADY DEFINED.
	IF	(1-T2GATE)
Q	EQ	1
	RE	NUSLT
	DEFAULT(SCLT|$0Q|,SCLTDF)
	DEFAULT(SMLT|$0Q|,SMLTDF)
Q	EQ	Q+1
	ER
	EI	:(1-T2GATE)		###EV

	EI	:ISIS

::*********************************************************************
::
::	SWITCH PARAMETERS:
::
::*********************************************************************

LOGBUF	EQ	4

:	Number of real CONSAT ports for laying out flags arrays and IOTAB
NRPORT	EQ	NAPORT+NSPORT		:async ports and SIO async ports
BKMPVC	EQ	((NMPVC+0F)/10)*10	:size of MPVC bit arrays
NANIPT	EQ	NRPORT*2		:Number of login port keys
	IF	SOLOCS
NPORT	EQ	NAPORT+NSPORT+NMPVC	:# prt tbl blks and for NGRP
NPGRP	EQ	(NPORT+1F)/20*2		:must equal NGRP defined by CONSAT
	EI	:SOLOCS

:	TOTAL NUMBER OF CIRCUITS TERMINATING ON THE NODE
NLQ	EQ	8			:# of circuits to the LEPrechaun
NIQ	EQ	2*NLINKS		:# of Internode circuits (ILC, BPM)
	IF	ISIS			:ISIS Sup (private net)
	DEFAULT(NNODES,80)		:ISIS Sup/Node Code Tymfile parameter
NSPC	EQ	NNODES*SUPER/SUPER	:# of Sup circuits		###wjl
	ELSE	:NOT ISIS (SOLO)	:split-sup base (public net)
NSPC	EQ	NSP			:allow for max # of Sup circuits
	EI	:ISIS
NTERMS	EQ	NLQ+NIQ+NKU+NDP+NSPC+NAPORT	:# of terminations

:	NUMBER OF CIRCUITS PASSING THROUGH THE NODE
NPASTH	EQ	(1-PTHRU)*NPTHR		:number of passthroughs allowed

:	NUMBER OF EXTRA COMMAND CIRCUITS in case node goes out of passthrus
	DEFAULT(NXCMDC,20)		:Tymfile parameter 		###wjl

:	NUMBER OF EXTRA LOGIN CIRCUITS
	DEFAULT(NXLGCS,0)		:Tymfile parameter		###LSH
NLOGCS	EQ	NANIPT+NXLGCS		:# of login channels		###LSH

:	TOTAL NUMBER OF CIRCUITS ON THE NODE
	IF	T2GATE
NCIRCS	EQ	NLQ+NIQ+NDP+NXCMDC		:total cks thru gw node
	ELSE	:NOT GATEWAY
NCIRCS	EQ	NTERMS+NPASTH+NXCMDC+NLOGCS	:total circuits thru node##LSH
	EI	:T2GATE


CBSZL	EQ	4		:LOG2 OF BUFFERLET SI
CBSZ	EQ	1^CBSZL		:SIZE OF BUFFERLETS

:	DEFINE CIRCUIT BACKPRESSURE CONSTANTS FOR THROUGHPUT CLASSES 0 TO 3.
:	EACH CIRCUIT MAY MOVE THIS MANY CHARACTERS PER HALF-SECOND BEFORE
:	BEING BACK-PRESSURED.

CIRSP0	EQ	$A32		:BPS CONSTANTS FOR CIRCUIT SPEEDS
CIRSP1	EQ	$A80
CIRSP2	EQ	$A256
CIRSP3	EQ	$A1024

:	TYMNET CONTROL CHARACTERS AND CHARACTER PAIRS:

ZAPPH	EQ	0301	:HARD ZAPPER
ZAPMIN	EQ	0301	:SMALLEST ZAPPER
ZAPPS	EQ	0302	:SOFT ZAPPER
ZAPPN	EQ	0303	:NON-GOBBLING ZAPPER
ZAPMAX	EQ	0303	:LARGEST SKINNY ZAPPER
ZAPPF	EQ	0304	:FAT ZAPPER (NODE PAIR FOLLOWS)
GOBBL	EQ	0308	:GOBBLER
GOBBF	EQ	0309	:FAT GOBBLER (NEW SEQUENCE NUMBER IN SECOND HW)
SQSET	EQ	030A	:SQSET - FORCES RECEIVE SEQNUMBER TO FOLLOWING DATA HW
SQFIX	EQ	030B	:SQF - SEQUENCE NUMBER FIX FOR REBUILD
SQACK	EQ	030C	:SQACK - SEQUENCE NUMBER ACK FOR REBUILD
NEEDP	EQ	0310	:NEEDLE POINT
NEEDE	EQ	0311	:NEEDLE EYE
TILIM	EQ	0312	:MESSAGE FOR TERMINAL IN LOGIN
LOGRR	EQ	0313	:ERROR IN CIRCUIT REQUEST
COMET	EQ	0314	:buffer timer pair ###jhl

:	PERFORMANCE MONITORING CONTROL CHARACTERS
:	CONTROL CHAR PAIRS 03-20 TO 03-3F ARE RESERVED FOR THIS PURPOSE
:	THESE CHARS ARE THE SECOND BYTE IN A 03-XX CHAR PAIR

XLAX	EQ	20	:XLAX IS LIKE TIMER, BUT HOPS TO HEAD OF USER DATA
XLACK	EQ	21	:XLAX ACK IS RETURNED BY TERMINATING NODE
TIMER	EQ	22      :TIMER MEASURES DELAY ON USER CRQ, MOVES WITH USER DATA
TIMACK	EQ	23      :TIMER ACK IS RETURNED BY TERMINATING NODE
REJECT	EQ	24	:RESPONSE BY TERMINATING NODE TO UNKNOWN CHAR PAIR
REAMER	EQ	25	:REAMER OPENS UP A CRQ

:	DEFINE BIT POSITIONS IN NEEDLE FLAG:

NF.REB	EQ	1	:REBUILD CIRCUIT
NF.CMD	EQ	2	:COMMAND CIRCUIT
NF.T1O	EQ	4	:TYMNET-I ORIGINATION
NF.T1D	EQ	8	:TYMNET-I DESTINATION
NF.PRI	EQ	100	:PRIORITY CIRCUIT
NF.SMC	EQ	200	:SMART CIRCUIT (SIQ ORIGINATION, HIQ HOST)
	IF	EXPNDL
NF.SNI	EQ	4000	:set by sup if SNI list present in needle	###jhl
	EI	:EXPNDL
NF.INT	EQ	8000	:INTERNAL CIRCUIT IF RESET (SET, RESET BY NODE CODE)

:	Login state flags.  These values are stored in the BF of a
:	login input buffer and they indicate the state of the login.
LOGSUP	EQ	04		:Bit means OK to send data to sup
LOGNDC	EQ	02		:Bit means node code ready to xmit login data
LG.TID	EQ	01		:Bit means TID is still in login buffer (hasn't
				:been sent to the sup yet).
LGSNT.	EQ	10+LOGSUP+LG.TID+LOGNDC	:SUP=Y, NC=Y, TID=Y
LGST.N	EQ	10+LOGSUP+LG.TID	:SUP=Y, TID=Y, NC=N
LGN.ST	EQ	10+LOGNDC		:NC=Y, SUP=N, TID=N
LG.SNT	EQ	10			:SUP=N, NC=N, TID=N
LGSN.T	EQ	10+LOGSUP+LOGNDC	:SUP=Y, NC=Y, TID=N
LOGXMT	EQ	10+LOGSUP+LOGNDC	:SUP=Y, NC=Y, TID=N
LOGMIN	EQ	10			:Minimum valid state flag
LOGMAX	EQ	17			:Maximum valid state flag

:	EQUATES FOR ZITEL TRACE/STOP FUNCTION

	IF	ZITEL

NMCMSK	EQ	3FFFFF		:mask for stripping to 22 bits (unMAC'ed)
MACMSK	EQ	0FFFFF		:mask for stripping to 20 bits (MAC'ed)
R5BITS	EQ	1F		:mask for stripping to five rightmost bits

:	BITS IN TRACE CONTROL WORD--MUST THEN BE SHIFTED LEFT 21 PLACES
TRCENA	EQ	400		:TRACE ENABLE bit
TRFTCH	EQ	200		:TRACE-INSTRUCTION FETCH
TRDTRD	EQ	100		:TRACE-DATA READ
TRDTWT	EQ	80		:TRACE-DATA WRITE
TRDMRD	EQ	40		:TRACE-DMA READ
TRDMWT	EQ	20		:TRACE-DMA WRITE
STFTCH	EQ	10		:STOP-INSTUCTION FETCH
STDTRD	EQ	8		:STOP-DATA READ
STDTWT	EQ	4		:STOP-DATA WRITE
STDMRD	EQ	2		:STOP-DMA READ
STDMWT	EQ	1		:STOP-DMA WRITE

	EI 	:ZITEL

:	EQUATES FOR TEMPERATURE REPORTING--RANGES AND DELAY TIME.	###JHL
DLYTMP	EQ	$A 14		:INHIBIT TEMP RPT FOR 15 4 MIN INTERVALS
	IF	ISIS
TOOHOT	EQ	26		:ISIS CONVERTS MF READING TO CENTIGRADE
	ELSE	:SOLO
TOOHOT	EQ	62		:MULTIFUNCTION EQUIV OF 100 DEGREES F
	EI 	:ISIS							###JHL

:	HANDLE DATA FOR 'DETACHED PORTS'
:	THE FOLLOWING EQUATES IDENTIFY THE DETACH REASONS:
DETR00	EQ	0	:DISPATCHER OUT OF PORTS. DETECTED IN CRQ.
DETR01	EQ	1	:HOST OUT OF PORTS. DETECTED IN CRQ.
DETR02	EQ	2	:ZAP WITH REASON, HOST OUT OF PORTS. HANDLED IN DSOZWR
DETR03	EQ	3	:KERNEL OUT OF PORTS. DETECTED IN CRQ.
DETR04	EQ	4	:KERNEL SIO INTERFACE DOWN. SET UP IN KCQDET.

::*********************************************************************
::
::	SOLO CONSAT PARAMETERS:
::
::*********************************************************************

	IF	SOLOCS

	GL	.PVCLH

:	GLOBAL SYMBOLS
	DEFAULT(PCNDSW,0)

:	ASYNC - VARIABLE DATA AREA
	DEFAULT(A.DATA,0)
	DEFAULT(CSBASE,0)

	EI 	:SOLOCS

	IF	STRHUB!STRRMT	:STAR HUB OR REMOTE	###LSH
	IF	STRDCD		:SWITCH FOR TESTING BIT DCD BEFORE
				:SIO OUTPUT
SIODCD	EQ	8		:SIO MOTHER BOARD READ REGISTER 0 BIT DCD
	EI	:STRDCD
	EI	:STRHUB!STRRMT				###LSH


	SUBTTL	DATA (CRYPTO messages)

::*********************************************************************
::
::	CRYPTO MESSAGES:
::	HO NIBBLE MAPS BY BIT TO HW'S CONTAINING SIGNIFICANT DATA
::	2ND NIBBLE SPECIFIES CRYPTO MESSAGE CLASS:
::		0 = GENERAL, ALWAYS DISPLAYS
::		1 = CRYDIS, CIRCUIT BUILT, ZAPPED MESSAGES
::		2 = ASYDIS, ASYNC MESSAGES
::		3 = REBDIS, REBUILD MESSAGES
::		4-0F = RESERVED
::	LO BYTE IS MESSAGE NUMBER
::
::*********************************************************************

CRYE00	EQ	7000	:CRASH. HW1=CRSHID, HW2&3=CRASH ADDRESS
			:CRASH ID : 0=> OOPS, 1=> POWER FAIL, 2=>OPERATOR
			:HALT, 4=> ILLEGAL INST, 8=> MAC ERROR
CRYE01	EQ	3001	:LINK UP - HW2=LINK#, HW3=NEIGHBOR#
CRYE02	EQ	3002	:LINK DOWN. HW3 = NEIGHBOR NUMBER
CRYE03	EQ	3003	:NO PERMUTER TABLE HALF PAGES AVAILABLE FOR NEW
			: LINK - HW2=LINK#, HW3=NEIGHBOR#
CRYE04	EQ	7004	:LINE DETACHED. HW1=REASON, HW2=LINE#, HW3=NEIGHBOR#.
			:REASON : 1 => NO REC RECEIVED, 2=> NO GOOD REC
			: RECEIVED, 3=> RESET RECEIVED, 4 => BORI ZAP
CRYE05	EQ	4005	:TAKEOVER. HW1 = SUPERVISOR NUMBER
CRYE06	EQ	0006	:SUPERVISOR STOP
CRYE07	EQ	4007	:SUPERVISOR CRQ LOST. HW1 = SUPERVISOR NUMBER
CRYE08	EQ	5008	:NEEDLE GOBBLED IN CRQ. HW1= 03XX PAIR HW3= NEIGHBOR#
CRYE09	EQ	5009	:ZAPPER ON UNASSIGNED CHANNEL FROM T-I NEIGHBOR -
			:HW1=CHANNEL#, HW3=NEIGHBOR#
CRYE0A	EQ	100A	:NO NEIGHBOR - HW3=NEIGHBOR#
CRYE0B	EQ	0C10B	:CRQ BUILT. HW0&1 = NEEDLE ENTRY PORT, EXIT PORT
CRYE0C	EQ	0C10C	:CRQ ZAP. HW0&1 = ZAPPER ENTRY PORT, EXIT PORT
			:THE PRECEEDING TWO MESSAGES MUST BE MANUALLY ENABLED
			:BY LETTING CRYDIS > 0
CRYE0D	EQ	400D	:TERMINATING NEEDLE SPECIFIES A DESTINATION HOST NOT
			:ON THIS NODE. CRQ IS ZAPPED.  HW1 = HOST NUMBER
CRYE0E	EQ	500E	:GOBBLER OR OTHER CHARACTER PAIR FOLLOWS NEEDLE.
			:HW1 = CHARACTER. HW3=NEIGHBOR#
CRYE0F	EQ	400F	:TIMEOUT ON CHANNEL PROCESSING NEEDLE.
			:HW1=ABS CHN#
CRYE10	EQ	0C010	:CHANNEL IN USE - HW?= CHANNEL NUMBER
CRYE11	EQ	7311	:REBUILD REQUEST.
CRYE12	EQ	7312	:CRQ REBUILD COMPLETE.
CRYE13	EQ	0C013	:REBUILD REJECT
CRYE14	EQ	4014	:REBUILD DATA LOST
CRYE15	EQ	5015	:CHANGE IN HOST STATUS - HW1=STATUS, HW3=HOST #
CRYE16	EQ	7016	:NEW LINE ATTACHED. HW1=NLAT,HW2= LINE #, HW3= NGHBR
CRYE17	EQ	0C017	:OUT OF COMMAND PORTS, HW0= , HW1= .
CRYE18	EQ	0C018	:EARLY ZAPPER FOLLOWS NEEDLE.CHAN, NEIGHBOR
CRYE19	EQ	1019	:OUT OF CHANNELS TO NEIGHBOR. HW3= NEIGHBOR #
CRYE1A	EQ	401A	:BAD NEEDLE POINT RECEIVED. HW1= 'NEEDLE POINT'
CRYE1B	EQ	001B	:OUT OF PORTS TO NODE KERNEL
CRYE1C	EQ	501C	:NO MORE PORTS TO ISIS DISPATCHER. HW1=NDP, HW3=HOST#
CRYE1D	EQ	0F01D	:SIO INTERRUPT REPORT - HW1=INTERRUPT,
			: HW2=CONDITION CODE, HW3=LINE#, HW4=NEGHBR#
			: INTERRUPT CODE - 1 =ASYNC INTERRUPT, 2 =CCW ERROR,
			: 6 =UNDERRUN, 8 =I/O COMMAND ERROR, FFFF =BAD REC SIZE
			: CONDITION CODE - 0 = MBOARD AVAILABLE, 4 =NON-
			: FUNCTIONING BOARD, 8 =MBOARD BUSY		###OAS
CRYE1E	EQ	301E	:TYMNET-I LINE WENT 4 SECONDS WITH NO GOOD RECORDS
			: RECEIVED - HW2=LINE#, HW3=NEIGHBOR NUMBER
CRYE1F	EQ	401F	:RTD DETECTED NON-GOBBLING ZAPPER - HW1= NEIGHBOR
CRYE20	EQ	7020	:LINE SUSPENDED DUE TO RESET ERROR - HW1=NO. SEC'S
			:HW2=LINE#, HW3=NEIGHBOR#
CRYE21	EQ	5021	:LINK SHRINK - HW1=NCHN,  HW3=NEIGHBOR NUMBER
CRYE22	EQ	5022	:LINK BUBBLE - HW1=NCHN,  HW3=NEIGHBOR#
CRYE23	EQ	0C023	:INVALID LOGGER ENTRY - HW0=BUFFER,HW1=ILLEGAL BF
CRYE24	EQ	4024	:SUP DATA ON UNASSIGNED CHANNEL - HW1=CHN#
CRYE25	EQ	4025	:SUP ZAP ON UNASSIGNED CHANNEL - HW1=CHN#
CRYE26	EQ	5026	:INVALID MACHINE NUMBER ON SUP COMMAND CIRCUIT - HW1=
			: ERRONEOUS NEIGHBOR NUMBER (WE COULD BE OUT OF SYNC
			: ON COMMAND CIRCUIT)
CRYE27	EQ	0C027	:INVALID COMMAND TYPE FROM SUP - HW1=BAD COMMAND
CRYE28	EQ	5028	:DATA ON UNASSIGNED CHANNEL FROM NEIGHBOR - HW1=
			: CHANNEL NUMBER, HW3= NEIGHBOR #
CRYE29	EQ	5029	:NEEDLE ON ASSIGNED CHANNEL - HW1=CHANNEL NUMBER
			: HW3= NEIGHBOR NUMBER
CRYE2A	EQ	0C02A	:RECEIVED 03 CHARACTER PAIR WHICH IS INVALID -
			: HW0=2ND CHAR, HW1=ABS CHN#
CRYE2B	EQ	402B	:INTERNAL HOST CHANNEL TIMEOUT. A CHANNEL
			:WITH TIMEOUT ENABLED HASNT RECEIVED DATA FOR 30 SEC
			:CRQ IS ZAPPED. R0 =  FUNCTION BYTE, ABSOLUTE CH #
			:SEE INTHST IN SWITCH FOR FUNCTION BYTE MEANINGS
CRYE2C	EQ	602C	:A NEW DOWNLINE LOAD CRQ HAS BEEN ESTABLISHED.
			:R0 = TARGET LINE #,  ABSOLUTE CH # TO HOST.
CRYE2D	EQ	602D	:DOWNLINE LOAD LINE CRQ ZAP.  R0=LINE NUMBER,REASON.
			:REASON : 0=> ZAPPER, 1=> LINE # TOO BIG, 2=> LINE
			:ATTACHED, 3 => LINE ALREADY IN USE FOR DWL
CRYE2E	EQ	002E	:OUT OF INTERNAL HOST LOAD PORTS
CRYE2F	EQ	0C02F	:ISIS HOST OUT OF PORTS
CRYE30	EQ	0C030	:SYNC SCAN ERROR.  R0 - LN*2, SEGB OFFSET
CRYE31	EQ	0031	:DETDGN CALLING ERROR - R0 MEANINGLESS
CRYE32	EQ	0C032	:SIO BUFFER COUNT ERROR. R0 - LN*2, COUNT
CRYE33	EQ	0C033	:M-BOARD TIMEOUT. R0 - LN, SVC INDEX.
			:INDEX : 2 = CONNECT SVC, 3 = INPUT SVC, 4 = OUTPUT
			: 5 = STATUS SVC
CRYE34	EQ	0C034	:CIRCUIT BUILDING ERRORS. HW0=LEP ERRS, HW1=CRQ ERRS
CRYE35	EQ	0C035	:CIRCUIT COUNTING INCONSISTENCY. R0 HAS NUMBER
			: OF OCCURRENCES, MAGNITUDE OF INCONSISTENCY.
CRYE36	EQ	5036	:LINK OVERLOADED - R0 HAS COUNT, HW3 HAS NGHBR	###OAS
CRYE37	EQ	5037	:LINK SATURATED - R0 HAS COUNT, HW3 HAS NGHBR	###OAS
CRYE38	EQ	1038	:LINK ERROR - ILC BUF ZERO. HW3=NGHBR
CRYE39	EQ	5039	:LINK SNIP DUE TO LINK ERROR. HW3 HAS NEIGHBOR NUMBER
CRYE3A	EQ	403A	:SIO CARD BUSY. R0 HAS COMMAND
CRYE3B	EQ	403B	:SIO CARD RING INTERRUPT. R0 HAS STATUS
CRYE3C	EQ	0C23C	:TID RECEIVED FROM ASYNC PORT. R0 = PORT#, TYPE
CRYE3D	EQ	0C23D	:NEEDLE EYE RECEIVED FOR ASYNC PORT. R0 = PORT#
CRYE3E	EQ	0C03E	:SERIOUS TYMSAT ERROR
CRYE3F	EQ	0C23F	:ASYNC PORT ANSWERED
CRYE40	EQ	0F040	:TOTAL PACKETS REC'D/SENT
CRYE41	EQ	7041	:BAD BORI
CRYE42	EQ	7042	:BAD ACK
CRYE43	EQ	7043	:BAD REC NO.
CRYE44	EQ	7044	:BAD CHECKSUM
CRYE45	EQ	7045	:RETRANSMISSIONS REC'D
CRYE46	EQ	7046	:RETRANSMISSIONS SENT
CRYE47	EQ	7047	:4 SEC GAPS
CRYE48	EQ	7048	:CROSS-TALK
CRYE49	EQ	7049	:SPACING ON INPUT
CRYE4A	EQ	704A	:HDLC CHECKSUM ERRORS
CRYE4B	EQ	704B	:HDLC ABORTS
CRYE4C	EQ	104C	:UNTAKER TO TYMNET-I NEIGHBOR
CRYE4D	EQ	704D	:LINK OUT ZAP COUNT. HW1=CNT, HW2=KN, HW3=NGHBR
CRYE4E	EQ	704E	:CMD CT ZAP COUNT. HW1=CNT, HW2=KN, HW3=NGHBR
CRYE4F	EQ	0C04F	:ASYNC RING WRAP. HW0=MAX, HW1=WRAP		###wjl
CRYE50	EQ	4050	:BAD INTERNAL HOST FUNCTION
CRYE51	EQ	1051	:LINK FROZEN. HW3=NEIGHBOR
CRYE52	EQ	1052	:LINK THAWED. HW3=NEIGHBOR
CRYE53	EQ	3053	:BAD SIO RECORD LENGTH - HW2=LN, HW3=NEIGHBOR#

	IF	EXPSEC
CRYE54	EQ	0F054	:XRAY AUDIT. HW1=ASCII-CODED COMMAND
			:HW2,3,4=ASCII-CODED USERNAME
	ELSE	:EXPSEC
CRYE54	EQ	4054	:XRAY COMMAND AUDIT. HW1=ASCII-CODED COMMAND
	EI 	:EXPSEC

CRYE55	EQ	0C055	:TIMEOUT ON XMISSION OF SIO RECORD. HW0=FASTC, HW1=LN
CRYE56	EQ	4056	:SOFT RECOVERY FROM MAC ERROR. HW1=ADDRESS
CRYE57	EQ	4057	:DMA TIMEOUT CAUSED MAC INTERRUPT. HW1 = MAC STATUS
CRYE58	EQ	0C058	:SLOT REPORT LIMIT EXCEEDED
CRYE59	EQ	4059	:ASYNC DATA ON PORT WITH SBA OFF. HW1 = PORT NUMBER
CRYE5A	EQ	505A	:SLOT/HOST CIRCUIT LIMIT EXCEEDED - HW1=SLOT, HW3=HOST#
CRYE5B	EQ	505B	:INVALID HOST FOR RESTRICTED NODE
CRYE5C	EQ	505C	:INVALID 03-PAIR ON T-I CMD CIRCUIT
CRYE5D	EQ	505D	:T-I SUP RECORD WITH INVALID LENGTH
CRYE5E	EQ	405E	:INVALID 03-PAIR ON OUR COMMAND CIRCUIT
CRYE5F	EQ	505F	:CHANNEL IN USE - HW1=REL CHAN, HW3=NEIGHBOR
CRYE60	EQ	7060	:BUFFER ZAP - HW0=COUNT, HW1=CHAN, HW3=BUFFER
CRYE61	EQ	5061	:NEEDLE REJECTED BY SLOT - HW1= # PORTS, HW3=HOST
CRYE62	EQ	5062	:IMPOSTER HOST - HW1= SLOTS, HW3=HOST
CRYE63	EQ	0C063	:SQA ERROR - HW0=DIF, HW1=TERM CHAN
CRYE64	EQ	1064	:KERNEL PORT ZAP FAILED.
CRYE65	EQ	0F365	:RTDSQA - TERM PORT, NET PORT, SQA
CRYE66	EQ	0F366	:RECEIVED A SQACK
CRYE67	EQ	0F367	:CRQREB -  FIRST CHAR IN SEQ#, EXPECTED SEQN
CRYE68	EQ	3068	:NO P/T SPACE
CRYE69	EQ	3069	:NO L/D FOR NEW LINE
CRYE6A	EQ	736A	:GENERAL CIRCUIT STATUS - CHAN, HSEQN
CRYE6B	EQ	436B	:REBUILD DISABLED - CHAN
CRYE6C	EQ	406C	:EARLY REBUILD NEEDLE - CHAN			###CY
CRYE6D	EQ	0C06D	:INTERCEPT ABANDONED DUE TO STUB TIMEOUT	###CY
CRYE6E	EQ	0F36E	:CIRCUIT STATUS - VSEQN, XSEQN
CRYE6F	EQ	736F	:SQF SENT - CHAN, XSEQN
CRYE70	EQ	3070	:SIO ERROR MBOARD RC=4 HW2=LN#, HW3=NEIGHBOR	###OAS
CRYE71	EQ	0F071	:WILD-CARD MESSAGE
CRYE72	EQ	4072	:SIO PORT UNAVAILABLE HW1 = LN#			###OAS
CRYE73	EQ	4073	:BAD ZAP REASON FROM ISIS, HW1 = REASON		###GT
CRYE74	EQ	0C074	:TAKEOVER RESP #LNK NOT MATCH #NBR,HW0=#LNK,HW1=#NBR#AL
CRYE75	EQ	0C075	:NETID MISMATCH - HW0=LINE, HW1=NETID		###wjl
CRYE76	EQ	0C076	:WSIZ MATCH DOWN - HW0=LINE, HW1=WSIZ		###wjl
CRYE77	EQ	0C077	:XRAYS NETID MOD - HW0=LINE, HW1=NETID		###wjl
CRYE78	EQ	4078	:UNRECOGNIZED SIGNAL RECEIVED, HW1=CHN		###LSH
CRYE79	EQ	3079	:STARLINK REMOTE RESET RETRY FAILURE		###EV
CRYE7A	EQ	707A	:STAR REMOTE NBR# MISMATCH  KEY=HW1,HW2 NBR#=HW3###AL
CRYE7B	EQ	407B	:SIO INIT SOFTWARE TIMEOUT - HW1=LINE		###wjl
CRYE7C	EQ	407C	:NODE IN THE NETWK RCVED BOOT CMD - NBR#=HW1	###AL
CRYE7D	EQ	707D	:LINE WENT - HW1 SECONDS WITH NO GOOD RECORDS
			: RECEIVED - HW2=LINE#, HW3=NEIGHBOR NUMBER 	###AL

::*********************************************************************
::
::	LINK SNIP REASONS FOR XRAY, NODE REPORTS
::
::*********************************************************************

LS.SCP	EQ	01	:SPLIT CHARACTER PAIR - 00 OR 01
LS.I3P	EQ	02	:INVALID 03 CHARACTER PAIR
LS.S3P	EQ	03	:SPLIT 03 CHARACTER PAIR
LS.BPC	EQ	04	:BAD CHANNEL NUMBER DETECTED IN BACKPRESSURE REC
LS.COR	EQ	05	:CHANNEL NUMBER OUT OF RANGE
LS.ILC	EQ	06	:ILC PERMUTER TABLE ENTRY ZERO FOR T-II NEIGHBOR
LS.BPV	EQ	07	:BPMV PERMUTER TABLE ENTRY 0 FOR T-I NEIGHBOR
LS.UCR	EQ	08	:UNRECOGNIZED CONTROL RECORD RECEIVED
LS.SNC	EQ	09	:SHRINK FROM NEIGHBOR, NO CHANNELS TO SHRINK
LS.MCE	EQ	0A	:MICROCODE CLOBBERED R12 (PRD)

LS.ARC	EQ	10	:ARRAYAND ERROR, BOTH BITS NOT SET
LS.ACR	EQ	11	:ARRAYAND ERROR, CHANNEL OUT OF RANGE
LS.ZPT	EQ	12	:ZERO PERMUTER TABLE ENTRY FOR ACTIVE CHANNEL
LS.BPZ	EQ	13	:BPSCNT ZERO
LS.EBF	EQ	14	:EMPTY BUFFER BUT BUFFER FLAG SET
LS.ZLR	EQ	15	:ATTEMPT TO BUILD ZERO-LENGTH RECORD
LS.MAC	EQ	16	:RECOVERY FROM MAC INTERRUPT IN RMAKE OR RTEAR
LS.OOB	EQ	17	:out of buffers					###wjl

	SUBTTL	DATA (Table structure variables)

:	CRASH TABLE STRUCTURES

Q	EQ	.		:HERE WE ARE

::*********************************************************************
::
::	CRASH SUMMARY TABLES:
::
::*********************************************************************

	ORG	0
CS.CNT	HS	1		:CRASH COUNT
CS.CID	HS	1		:CRASH ID
CS.PSD	HS	4		:CRASH PSD
CS.TIM	HS	2		:GMT OF CRASH
CS.SIZ	EQ	.		:SIZE OF SUMMARY ENTRY

::*********************************************************************
::
::	CRASH DETAIL TABLES:
::
::*********************************************************************

	ORG 	0
CD.CNT	HS	1		:CRASH COUNT
CD.CID	HS	1		:CRASH ID
CD.PSD	HS	4		:CRASH PSD
CD.TIM	HS	2		:CRASH TIME (GMT)
CD.RS0	HS	20		:R-SET 0 REGISTERS
CD.RSF	HS	20		:R-SET F REGISTERS
CD.MAC	HS	30		:MAC REGISTERS (LOC'S 300-35F)
CD.SLT	HS	1		:NOT USED (USED BY ISIS)
CD.SIZ	EQ	.		:SIZE OF DETAIL TABLE
CS.NEN	EQ	10		:NUMBER OF ENTRIES IN SUMMARY TABLE
CSMTBS	EQ	CS.SIZ*10	:SIZE OF SUMMARY TABLE AREA
CDTTBS	EQ	CD.SIZ*2

::*********************************************************************
::
::	CRYPTO MESAGE FORMAT:
::
::*********************************************************************

	ORG	0
CRYGMT	WS	1
CRYFAS	HS	1
CRYFLG	BS	1
CRYTYP	BS	1
CRYHW0	HS	1
CRYHW1	HS	1
CRYHW2	HS	1
CRYHW3	HS	1

::******************************************************************
::
::	SIO TRANSMIT BLOCK LAYOUT:	###JOK
::	(See also SIORIZ, where this layout is used)
::
::******************************************************************

	IF	SILINS
	ORG	0
SB.CMD	HS	1			: CCW Command field
SB.DQA	HS	1			: CCW Data Quad-word Address
SB.CD2	HS	1			: Second CCW Command field
	HS	1			: init'ed to Quad-word addr of next CCW
SB.OBA	HS	1			: Output Buffer Address (Absolute)
SB.QBA	HS	1			: Quad-word Output Buffer Address
	BND	10			: extra padding to fill out to Quad-wrd
SB.SIZ	WS	0			: how big the entry is
	EI	:SILINS

::*********************************************************************
::
::	SIO STATUS BLOCK LAYOUT TABLE:		###wjl
::	Index into SIOSTT, three halfwords for engine, four halfwords
::	for HDLC micro	(See LDRPRT and XSIOST for usuage)
::
::*********************************************************************

	IF	SILINS
	ORG	0
SS.REG	HS	1	:read REG 0 on the SIO chip	(bits 0 - 7)
			:read REG 1 on the SIO chip	(bits 8 -15)
SS.IDL	BS	1	:idle line counter		(bits 16-23)
SS.CRC	BS	1	:CRC error counter		(bits 24-31)
SS.ABR	HS	1	:HDLC abort counter		(bits 32-43)
			:				(bits 44-47)
SS.HM1	BS	1	:HDLC MICRO-engine receive overrun counter
SS.HM2	BS	1	:HDLC MICRO-engine (reserved)
	EI	:SILINS

::*********************************************************************
::
::	LINK DESCRIPTOR VARIABLES:
::	(NOTE:	this data-structure is referenced by ISIS, but is defined
::		independently there...DO NOT CHANGE STRUCTURE AFFECTING THESE
::		ELEMENTS WITHOUT COORDINATION WITH ISIS.  ISIS assumes it
::		will be located in Segment 0.  Elements referenced by ISIS
::		are flagged with ":ISIS: ".)
::
::*********************************************************************

	ORG	0


NDID	HS	1		:NODE NUMBER
KTYP	BS	1		:LINK TYPE (***HWB)
BORI	BS	1		:RECEIVED B-O-R INDICATOR
NLAT	BS	1		:# OF LINES ATTACHED
WSIZ	BS	1		:WINDOW SIZE
KSPD	BS	1		:LINK SPEED
LKNM	BS	1		:LINK NUMBER
NCHN	HS	1		:NUMBER OF CHANNELS
ISEC	HS	1		:PTR TO START OF INPUT RING
NRTR	HS	1		:PTR TO NEXT RECORD TO TEAR
AMSK	HS	1		:ISIS: MASK FOR ACK TRUNCATION
OSEC	HS	1		:DITTO OUTPUT
NRMK	HS	1		:PTR TO NEXT RECORD TO MAKE
NRXM	HS	1		:ISIS: PTR TO NEXT RECORD TO TRANSMIT
LRT	HS	1		:ISIS: LAST RECORD TORN
LAS	HS	1		:ISIS: LAST ACKNOWLEDGEMENT SENT
LRM	HS	1		:LAST RECORD MADE
LAR	HS	1		:ISIS: LAST ACKNOWLEDGEMENT RECEIVED
NAS	HS	1		:NEXT ACKNOWLEDGEMENT TO BE SENT
ONDID	HS	1		:NODE NUMBER WHEN DOWN OR 0
IDLE	HS	1		:ISIS: FLAG FOR IDLE OUTPUT
PKTMSZ  EQ      1F
PKTTIM	HS	PKTMSZ+1	:FASTC TIME PACKET WAS MADE, INDEXED BY REC#
KS.PQC	HS	2		:RUNNING COUNT OF PACKET QUEUEING TIMES
	IF	NAKCOD		:NAK indicator		###ev
NAKFLG	BS	1		:1 if found sequence gap -  send NAK
SNDRSP	BS	1		:1 if sending NAK response rexmis pkt
LGRR	HS	1		:Last Good Record Received (for NAK)
NKTS	HS	1		:NaK To Send (RECN of first skipped pkt)
PRXM	HS	1		:Pending (next/latest) Record to XMit
	EI	:NAK
	IF	RBTHUB:STRHUB
RBTFLG	BS	1		:REMOTE-BOOT FLAG=1 WILL SEND OUT CMD	###AL
	EI
	IF	STRHUB
HRSERF	BS	1		:HUB RECVED RESET IN ERROR, FLAG FOR
	EI			: OUTPUT TO SEND 33A0 ###AL
	IF	APLYBP&MAKNUL	:Retransmission checking to send null rec
LRR	HS	1		:Last Retransmission Received
RRXCNT	BS	1		:Repeat Retransmission Count
NULFLG	BS	1		:SET if link should send null record
	EI	:MAKNUL					###EV 02/10/87
:	ISIS-INDEPENDENT DESCRIPTORS BEGIN HERE
RKEY	HS	2		:RESET KEY RECEIVED FROM NEIGHBOR FOR
				: MULTI-LINE ATTACHMENT VERIFICATION
SHSTAT	BS	1		:SHRINK STATE, VALUES AS FOLLOWS:
:	0     NO SHRINK ACTIVITY IN PROGRESS
:	1     RTD DETECTED SHRINK COMMAND FROM NEIGHBOR
:	2     MSHRINK FOUND MANY SPARE CHANNELS THIS LINK
:	3     RMAKE FROZEN WAITING FOR NEIGHBOR TO COMPLETE SHRINK

NEDSUS	BS	1		:NON-ZERO IF LINK SHRINK SUSPENDED DUE TO
				: NEEDLES OUTSTANDING
:	!! SHSTAT AND NEDSUS MUST BE IN SAME HALFWORD !!
:	SOME CODE DOES A LH OF SHSTAT TO TEST BOTH SHSTAT AND NEDSUS

NEDOUT	HS	1		:# OF NEEDLES OUTSTANDING BETWEEN CRQ AND RMAKE

ANCHN	HS	1		:NUMBER OF ACTIVE CHANNELS

KFROZN	HS	1		:INDICATE LINK'S NETWORK STATUS - 0 FOR UP,
				:-1 FOR FROZEN,LINK UP BUT REPORTED OUT TO SUP

:	THE FOLLOWING FIELDS EXIST TO RECORD LOAD STATISTICS FOR EACH LINK

KS.PCO	HS	2		:RUNNING COUNT OF PACKET CHARACTERS OUTPUT
KS.PMO	HS	2		:LAST MINUTE, COUNT OF PACKET CHARACTERS OUTPUT
KS.PHO	HS	2		:HI-WATER MARK OF PACKET CHARACTERS OUTPUT

KS.PCI	HS	2		:RUNNING COUNT OF PACKET CHARACTERS INPUT
KS.PMI	HS	2		:LAST MINUTE'S COUNT OF PACKET CHARACTERS INPUT
KS.PHI	HS	2		:HI-WATER MARK OF PACKET CHARACTERS INPUT

KS.LCO	HS	2		:RUNNING COUNT OF LOGICAL CHARACTERS OUTPUT
KS.LMO	HS	2		:LAST MINUTE, COUNT OF LOG CHARACTERS OUTPUT
KS.LHO	HS	2		:HI-WATER MARK OF LOGICAL CHARACTERS OUTPUT

KS.LCI	HS	2		:RUNNING COUNT OF LOGICAL CHARACTERS INPUT
KS.LMI	HS	2		:LAST MINUTE, COUNT OF LOGICAL CHARACTERS INPUT
KS.LHI	HS	2		:HI-WATER MARK OF LOGICAL CHARACTERS INPUT

KS.NPC	HS	2		:RUNNING COUNT OF TIMES NO PACKET MADE IN RMAKE
KS.NPM	HS	2		:SAVE AREA FOR KS.NPC
KS.NPH	HS	2		:HIGH-WATER MARK FOR NO PACKETS MADE

KS.RRC	HS	1		:COUNT FOR NUMBER OF ROUND ROBINS
KS.RRT	HS	1		:AVERAGE TIME PER ROUND ROBIN IN FASTC

KS.OVL	HS	1		:LAST MINUTE'S LINK OVERLOAD COUNT
KS.SAT	HS	1		:LAST MINUTE'S LINK SATURATED COUNT

KS.BAK	HS	1		:RUNNING COUNT OF BACKLOGS
KS.BAM	HS	1		:SAVE AREA

KS.PKM	HS	1		:COUNT OF PACKETS MADE
KS.ASZ	HS	1		:AVERAGE PACKET SIZE

KS.LRM	HS	1		:RMK COUNT OF LOGICAL RECORDS PUT INTO PACKETS
KS.LRA	HS	1		:MTRFIC STORAGE FOR LOG REC/PACKET	###jhl

	IF	BFLTMR		:###JHL for buffer delay timer pairs
BDLACC	HS	1		:buffer delay accumulator
BDLCNT	HS	1		:buffer timer-pair counter
KS.BFD	HS	1		:last minute's acc'ed bfr delay
KS.BFC	HS	1		:last minute's count of bfr pairs
	EI	:BFLTMR		:###JHL

KS.SRC	HS	2		:CUMMULATIVE SUM, SYLVER-RTEAR DELAYS
KS.SRA	HS	1		:AVERAGE TIME BETWEEN SYLVER AND RTEAR

KS.AQU	HS	1		:AVERAGE QUEUEING DELAY, RMAKE TO SYLVEX

KS.XMT	HS	1		:AVERAGE PACKET TRANSMISSION TIME

KS.SEM	HS	1		:SEMAPHORE BETWEEN INTERRUPT-DRIVEN SYLVEX AND SIO
				:ROUTINES IN SYLVER. NEEDED ONLY ON SIO-SYNC LINKS
	IF	STRHUB		:## AL
KS.TRF	HS	1		:REXMIT RECORDS COUNT FOR STRLINK
KS.TSV	HS	1		:SAVE AREA FOR LAST MINUTE REXMIT RCD
				: COUNT
KS.RRF	HS	1		:RECORD XMIT COUNT
KS.RSV	HS	1		:SAVE AREA FOR LAST MINUTE XMIT RCD CT.
	EI	:STRHUB
LRMSAV	HS	1		:SAVE AREA FOR LRM
LRTSAV	HS	1		:SAVE AREA FOR LRT

INTIME	HS	PKTMSZ+1	:SAME FOR TIME PACKET ARRIVED

KSSZ	EQ	.-KS.PCO	:SIZE OF STATISTICS AREA

	HS	0
KVERNO	HS	1		:NEIGHBOR VERSION NUMBER (-1 IF UNKNOWN)
	IF	XRESET		:**NO INSERTIONS BETWEEN KVERNO AND KNETID!!**
KNETID	HS	1		:Neighbor's NETID
KHOST0	HS	2		:Neighbor's Kernel Host Number
KLINE	BS	1		:Neighbor Line Number
	HS	0
	EI	:XRESET
KDSZ	EQ	.-NDID		:SIZE OF LINK DESCRIPTOR, NOT STRLNK
	IF	STRHUB
NXTLNK	WS	1		:POINTER TO NEXT LINK DESCRIPTOR IN CHAIN
LNKKEY	WS	1		:REMOTE EARTH STATION 24 BIT KEY ##AL
STAFLG	HS	0		:LNK STATES AND STATUS FLAG, HW BOUNDARY
	BS	1		:INIT BY 0
LNKSTA	EQ	1		:OFFSET VALUE FOR BIT OP. CONTENT 0=DOWN,1=UP
DWLSTA	EQ	2		:DOWN LINK LOAD STATE, LNK DOWN,NO RST
				: CONTENT 0=DOWN LINK LOAD DONE, WAIT FOR RESET
				:	  1=DOWN LINK LOAD ENGAGED
RSTSTA	EQ	4		:RESET MODE WHEN LNK DOWN, NOT DWL
				: CONTENT 0=RESET NOT ENGAGED, 1=ENGAGED
DETSTA	EQ	8		:1=LINK DETTACH STATE,WHEN LNK UP GOT
				: RESET
DWLXFL	EQ     	10		:DWL TRANSMIT FLAG 1=DATA READY - 0=NO DATA
DWLVFL	EQ	20		:DWL RECEIVE FLAG - DITTO
RSTXFG	EQ     	40		:RESET FLAG 1=RST XMIT BUF READY TO COPY
BUFADR	WS	0		:BUFFER ADDR. FULL WORD BOUNDARY
DWLXBF	WS	1		:DOWN LINK LOAD XMIT BUF ADDR
DWLVBF	WS	1		:DOWN LINK LOAD RCV BUF ADDR
RSTXBF	WS	1		:RESET XMIT BUF ADDR
RSTVBF	WS	1		:RESET RCV BUF ADDR
STRTIM	WS	1		:TIME OF STRLNK ATTATCH 
DWLNDX	HS	1		:DWL CHANNEL INDEX (RELATIVE INTHST CHN)
SKDSZ	EQ	.-NDID		:SIZE OF STRLNK DESCRIPTOR ##AL
	EI	:STRHUB
::**********************************************************************
::
::	 STARLINK CHAIN DESCRIPTOR LAYOUT  /  PER STARLINE
::
::**********************************************************************
	ORG	0
	IF	STRHUB
STHEAD	WS	1		:POINTER TO HEAD OF LIST OF STARLINKS
STNEXT	WS	1		:POINTER TO NEXT STARLINK TO SERVICE
CRSTKD	WS	1		:CURRENT RESET KD VALUE ##AL
TRYCNT	HS	1		:COUNT NUMBER OF INITIAL RESETS (33A0) RCVD
NASTLK	HS	1		:COUNT NUMBER OF ACTIVE STRLNKS / THIS LINE
SKTBSZ	EQ	.-STHEAD	:###LSH
	EI	:STRHUB

::*********************************************************************
::
::	MACROS:		LKD./LKD.2		(###JOK)
::	FUNCTION:	Load a link-descriptor pointer into register KD.
::	The global use of these macros centralizes the functionality,
::	and permits changes to data-structures [e.g. the KDKN pointer-array]
::	to be easily centralized in the macro-definition:
::
::	RS -	source register (containing link number)
::
::*********************************************************************

:	given actual link number:
LKD.	MACRO(RS)[ LHL	KD,KDKN,RS,RS ]

:	given twice actual link number:
LKD.2	MACRO(RS)[ LHL	KD,KDKN,RS, ]


::*********************************************************************
::
::	RESET BUFFER DESCRIPTOR:
::
::*********************************************************************

	ORG	0
	IF	XRESET		:###wjl
VRSTP	HS	1		:Received Reset Pattern
VNDID	HS	2		:Received Node Number
VVERNO	HS	1		:Received Version Number
VNETID	HS	1		:Received Network ID
VSUBNT	HS	1		:Received Subnet Number
VWSIZ	BS	1		:Received Link Window Size
VLINE	BS	1		:Received Line Number
VHOST0	HS	2		:Received Kernel Host Number
VRSRSN	BS	1		:Received Reset Reason
VKSPD	BS	1		:Received Link Capabilities
VKATTR	HS	2		:Received Link Attributes
VDIAL	HS	2		:Received Dial-Up Number
	HS	0
VSDSZ	EQ	.-VRSTP		:Size of Received Reset Buffer

XRSTP	HS	1		:Transmitted Reset Pattern
XNDID	HS	2		:Transmitted Node Number
XVERNO	HS	1		:Transmitted Version Number
XNETID	HS	1		:Transmitted Network ID
XSUBNT	HS	1		:Transmitted Subnet Number
XWSIZ	BS	1		:Transmitted Link Window Size
XLINE	BS	1		:Transmitted Line Number
XHOST0	HS	2		:Transmitted Kernel Host Number
XRSRSN	BS	1		:Transmitted Reset Reason
XKSPD	BS	1		:Transmitted Link Capabilities
XKATTR	HS	2		:Transmitted Link Attributes
XDIAL	HS	2		:Transmitted Dial-Up Number
XCKSUM	HS	2		:Transmitted Checksum
	HS	0
XSDSZ	EQ	.-XRSTP		:Size of Transmitted Reset Buffer
XSDCNT	EQ	((XSDSZ-1)/8)^8	:Reset Length Count Code for header 
TXRSHD	EQ	TTRSHD!XSDCNT	:T-II Expanded Reset Header for new link
TYRSHD	EQ	TSRSHD!XSDCNT	:T-II Expanded Reset Header for subsequent line

	ELSE
VRSTP	WS	2		:RECEIVED RESET PATTERN
XRSTP	WS	3		:TRANSMITTED RESET PATTERN
	EI	:XRESET

RSCNT	HS	1		:RESET COUNT
RSTIM	HS	1		:HOLDS TIMEOUT DURING RESET PROCEDURE
	HS	0
SDBSZ	EQ	.-VRSTP		:SIZE OF RESET DESCRIPTOR

::*********************************************************************
::
::	RECORD DESCRIPTOR:
::	(NOTE:	this data-structure is referenced by ISIS, but is defined
::		independently there...DO NOT CHANGE STRUCTURE AFFECTING THESE
::		ELEMENTS WITHOUT COORDINATION WITH ISIS.  ISIS assumes it
::		will be located in Segment 0.  Elements referenced by ISIS
::		are flagged with ":ISIS: ".)
::
::*********************************************************************

	ORG	0
RECN	HS	1		:ISIS: RECORD NUMBER
RLNK	HS	1		:ISIS: PTR TO NEXT RECORD IN BUFFER
	IF	EXPWSZ
EREC	WS	1		:###ISIS: PTR TO END OF DATA (FOLLOWS RLINK)
BREC	WS	1		:###ISIS: PTR TO BEGINNING OF DATA (VERT CHKSM)
	ELSE
EREC	HS	1		:ISIS: PTR TO END OF DATA (FOLLOWS RLINK)
BREC	HS	1		:ISIS: PTR TO BEGINNING OF DATA (VERT CHKSM)
	EI
RBSY	BS	1		:ISIS: BUSY FLAG (**PRECEDES LLXM, HWB)
LLXM	BS	1		:ISIS: LINE LAST TRANSMITTED BY (DEV NUM)
RSHF	BS	1		:SHIFT COUNT FOR DIAG CHKSM
	IF	STRHUB!STRRMT
SRXTIM	WS	1		:Tymstar paced retransmission transmit time
	EI	:STRHUB!STRRMT
CDSZ	EQ	.-RECN		:SIZE OF RECORD DESCRIPTORS

::*********************************************************************
::
::	DEFINE FORMAT OF XRAY GOODGUY LIST
::
::*********************************************************************

	IF	EXPSEC
	ORG	0
XGGPRV	BS	1		:USER'S PRIVILEGE CAPABILITY
XGGOVR	BS	1		:USER'S OVERRIDE CAPABILITY
XGGNAM	HS	6		:USER NAME (UP TO 12 CHARS)
XGGSIZ	HS	0		:GOODGUY ENTRY SIZE
	EI 	:EXPSEC

::*********************************************************************
::
::	DEFINE FORMAT OF XRAY USER BLOCK
::
::*********************************************************************

XBFSZE	EQ	10

	ORG	0
XUNAME	HS	1		:INDEX TO USER IN GOODGUY LIST	###OAS
XULGTM	WS	1		:LOG IN TIME
XUSLTN	HS	1		:XRAY USER SLOT NUMBER
XUINTH	HS	1		:XRAY USER INTERNAL HOST CHANNEL
XPOWER	HS	1		:XRAY USER POWER
CURCOM	HS	1		:SEG1 ADR OF COMMAND CURRENTLY EXECUTING
COMPWR	HS	1		:ORIGINAL POWER OF CURCOM
XRYBFO	HS	1		:OUTPUT BUFFER NO.
XRYPTF	HS	1		:FILL POINTER
XRYPTE	HS	1		:EMPTY POINTER
CRYMOD	HS	1		:AUTO CRYPTO DISPLAY MODE
EKOTYP	HS	1		:CHARACTER ECHO MODE
XRYADR	WS	1		:SCHEDUING ADDRESS
XHDSAV	WS	1		:LINK SAVE AREA
XRSAVE	WS	6
DPRSAV	WS	1
XREGSV	WS	10		:REGISTER SAVE AREA
ARGMAX	HS	1
ARGCT	HS	1
VALUE1	WS	8
CRYMSK	WS	8
CRYPPU	HS	1		:CRYPTO PRIO. BUF OUT PTR	###AL
CRYPTU	HS	1
XKNSAV	HS	1
:::
XKDSAV	WS	1
XPRTTP	WS	1
	GL XPRTTP
XRYBFI	BS	XBFSZE		:INPUT BRACELET
	HS	0
XNDSAV	HS	1		:NODE # SAVE AREA FOR ND COMMAND###SHM
xdjsav  hs      1               :port being traced
xdjsat  hs      1               :do node conversion for TD
	IF	XRYTMC		:###wjl
IIXNTC	HS	1		:Network Console/XRAY flag
IIXCID	HS	1		:IIX Command ID
IIXCMD	HS	1		:temp storage for command
IIXAID	HS	1		:IIX Auto CRYPTO Command ID
	EI	:XRYTMC
XUBSZ	EQ	.-XUNAME	:SIZE OF XRAY USER BLOCK

::*********************************************************************
::
::	DELAY-TABLE LAYOUT:	###JK
::
::*********************************************************************

	ORG	0
DLSTAT	HS	1		:STATUS OF DELAY MEASUREMENT PROCESS
DLYFLG	HS	1		:PRIORITY SELECT FOR TEST CHANNEL
DLYFIL	HS	1		:NUMBER OF FILL HW PER TEST PACKET
DLYPTF	HS	1		:FILL POINTER TO DLYTBL
DLYAV1	HS	1		:RUNNING AVERAGE OF SAMPLES
DLYAV2	HS	1		:RUNNING AVERAGE OF AVERAGES.
NODLST	HS	8		:NODE LIST FOR THIS PATH		###wjl
NODCNT	HS	1		:2 X NUMBER OF ONE WAY NODES IN THIS TEST PATH
DLYTSL	EQ	5		:LOG OF TABLE SIZE
DLYTSZ	EQ	40		:2 * DLYTBL SIZE
DLYTBL	HS	DLYTSZ/2	:32h DATA VALUES
DLYBSZ	HS	0		:TOTAL DELAY MEASUREMENT AREA

	ORG	Q		:RESTORE PC

::*********************************************************************
::
::	LINE DESCRIPTOR:
::	FUNCTION:	This section defines the layout of a line-descriptor.
::	This is used with RX1 references relative to register "L.".
::	All symbol names are prefixed with "L." to indicate line-parameters.
::
::	  The descriptor contains three subsections:
::	A.	parameters common to both SYNC and SIO
::	B.	parameters unique to SYNC
::	C.	parameters unique to SIO
::	The latter two overlay each other!
::
::	(NOTE...">name" corresponds to old usage!)
::
::*********************************************************************

Q	EQ	.			: remember where we are now
	ORG	0
L.STAT	HS	1			: Status-bits:
					: 8000 - set if SIO-line, reset if SYNC
L.NEIG	HS	1			: (last) neighbor on line	>NGSVLN
L.KDSV	HS	1			: (last) link line attached to 	>KDSVLN
					:  0 -	never attached
					: <0 -	detached
L.DRSN	BS	1			: Detach reason:		>DREASN
					: 2 -	No records
					: 3 -	Reset received
L.LNO	BS	1			: duplicate copy of line-number
L.RSE	HS	1			: Reset Key for step E		>RESETE
L.RSF	HS	1			: Reset Key for step F		>RESETF
L.BRAT	HS	1			: Line speed			>BAUDRT
L.RTIM	HS	1			: for computing line speeds 	>LNRTIM
L.RPOS	HS	1			: Ditto.			>LNRPOS
L.SYLP	HS	1			: SYLVER state-variables - P-counters
					: 				>QSYLVR
L.TIME	HS	2			: Line time			>LINTIM
:	The following are for gathering statistics:
L.LDAR	HS	1			: bit-array for error-history 	>LDARLN
L.RCVD	HS	1			: good records received 	>RCRCVD
L.TRNS	HS	1			: records transmitted		>RCTRNS
L.RRF	HS	1			: -- Count at end of last min 	>KL.RRF
L.RSV	HS	1			: -- Count during last min 	>KL.RSV
L.ERR	HS	1			: detected errors		>LINERR
L.SPAC	HS	1			: Spacing (all 0's) detected 	>SPACNG
L.BACK	HS	1			: Bad acknowledgements		>BADACK
L.BRNO	HS	1			: Bad record numbers		>BADRCN
L.BCSM	HS	1			: Bad checksum			>BADCSM
L.RTR	HS	1			: retransmissions received 	>RCRXMT
L.RTC	HS	1			: retransmissions considered 	>LXMSET
L.LRF	HS	1			: -- Count at end of last min	>KL.LRF
L.LSV	HS	1			: -- Count during last min 	>KL.LSV
L.CROS	HS	1			: cross-talk errors		>LCROSS
L.RTS	HS	1			: retransmissions sent		>TRRXMT
L.TRF	HS	1			: -- Count at end of last min 	>KL.TRF
L.TSV	HS	1			: -- Count during last min 	>KL.TSV
L.SIZE	HS	0			: size of (basic) descriptor

:	The following are SYNC-unique parameters:
L.TAIL	HS	1			: trailing pointer		>SYNTOP
L.SHFT	HS	1			: left-shift counter storage 	>SYLSHF
L.BCNT	HS	1			: record byte count		>SYBCNT
L.HEDR	HS	2			: record header			>SYHEDR
L.CNSG	HS	1			: # 4-sec gaps with no records received
					: 				>CONFSG
L.FRSG	HS	1			: total # 4-sec gaps with no records
					: received			>FOURSG
L.SYSZ	HS	0			: (total) size of SYNC descriptor

:	The following are SIO-unique parameters:
	ORG	L.SIZE			: back up for overlay
L.SIBF	HS	1			: Index into SIBUF		>SIBUFN
L.SIST	HS	1			: SIO Output-state		>SIOTST
L.SICO	HS	1			: SIO current output-block addr >SIOCO
L.SINO	HS	1			: SIO next output-block address >SIONO
L.SISZ	HS	0			: (total) size of SIO descriptor

L.SIZE	HS	0			: maximum size of descriptor
	IF	L.SYSZ-L.SIZE
L.SIZE	EQ	L.SYSZ
	EI

	ORG	Q			: return to real address-space

::*********************************************************************
::
::	MACROS:		LL./LL.2
::	FUNCTION:	Load a line-descriptor pointer into a register.
::	The global use of these macros centralizes the functionality,
::	and permits changes to data-structures [e.g. the L.POINT pointer-array]
::	to be easily centralized in the macro-definition:
::
::	RD -	destination register
::	RS -	source register (containing line number)
::	OFF -	offset to line-number
::
::*********************************************************************

:	given actual line number:
LL.	MACRO(RD,OFF,RS)[ LHL	RD,L.POINT+(2*OFF),RS,RS ]

:	given twice actual line number:
LL.2	MACRO(RD,OFF,RS)[ LHL	RD,L.POINT+(2*OFF),RS, ]

	SUBTTL	DATA (Low Core SEG 0 variables)

:	Memory Layout Summary

:	   The following table shows the (current) memory layout by SEGMENTS:

:	SEGMENT	Usage			Remarks
:	   0	Node code Data		RX1 addressible (+ catch-all for junk)
:	   1	Node code Code		RX2 addressible (most of the time)
:	   2	Buffer Descriptors
:	   3		do.		(soon to be cramped for space)
:	   4	Kernal Communications	(if ISIS or SUPERVISOR)
:		Port Descriptors	(SOLO CONSAT)
:	   5	ASYNC ring		(TYMSAT)
:		Supervisor ring		(SUPERVISOR)
:	   6	Permuter-tables and Bufferlets
:	   7		do.
:	   8		do.
:	   9		do.
:	  0A	Dummy for XRAY		(maps into absolute memory 0-FFFF)
:	  0B	SYNC Input rings
:	  0C	Data area
:	  0D	XRAY execute & data	(execute only)
:	  0E	CTA Table		(ISIS)
:		Dummy for variables	(Maps to 600 for FASTC, SLOWC)
:	  0F	SEGF			(ISIS)

:	THIS AREA RESERVED FOR DATA AREAS WHICH MUST BE ASSEMBLED
:	LOW IN SEG 0 FOR RX1 INDEXING.

::*********************************************************************
::
::	EXEC VARIABLES:
::
::*********************************************************************

	SEG.(0)				:DATA SEGMENT 0 BEGINS HERE
	ORG	0
SEG0	HS	0

:	***NOTE: FIRST 10x BYTES ARE UNUSED***

	ORG	10			:REQUIRED FOR MICROCODE TRACE INTERRUPT
TRPSW	WS      2       		:OLD PSW FOR TRACE ROUTINE
	WS	1			:POINTER TO TRACE ROUTINE

:	NODE DESCRIPTOR:

NODEID	HS	1			:NODE NUMBER
VERSID	HS	1			:VERSION NUMBER
CRHCNT	HS	1			:CRASH COUNT
CRSHID	HS	1			:CRASH ID #
	SYAD(CRSHID)
CRSHPS	WS	1			:CRASH PSW
CRSHAD	WS	1			:CRASH ADDRESS
	SYAD(CRSHAD)
CRSHTM	WS	1			:GMT OF LAST CRASH
ERRREG	WS	10			:CRASH REGISTERS
CRYPPI	HS	1			:Pointer into regular crypto buffer
CRYPRI	HS	1			:Pointer into priority crypto buffer

CRTYPE	HS	1			:CRASH TYPE (<0 =HRDWR, >=0 =SFTWR)##TZ

:	SAVE AREA FOR HARDWARE FAULTS FOR SOLO NODE
	IF	1-ISIS
ILIPSW	WS	2			:ILLEGAL INSTRUCTION OLD PSW
	SYAD(ILIPSW)
MACPSW	WS	2			:MAC INTERRUPT OLD PSW - MAC STATUS
	SYAD(MACPSW)
SMACSV	WS	4			:REGISTERS SAVED AT SMACSV
	SYAD(SMACSV)
MALPSW	WS	2			:MACHINE MALFUNCTION OLD PSW
	SYAD(MALPSW)
ILDVCT	HS	1			:COUNT OF ILLEGAL DEVICE INTERRUPTS
ILDVAD	HS	1			:DEVICE ADDRESS FROM LAST ILLEGAL
	SYAD(ILDVAD)			:DEVICE INTERRUPT
	EI 	:1-ISIS

CRASHX	WS	1			:CRASH ADDRESS FOR XRAY 'ND' COMMAND

TRRIX	HS	1			:INDEX FOR TRRING,
	SYAD(TRRIX )			:CHARACTER TRACE BY CHANNEL

XFIRST	WS	1			:FIRST TIME (GMT) NODE WAS TAKEN OVER

ABRSAV	WS	10			:REGISTER SAVE AREA FOR SOFT MAC CRASH
	SYAD(ABRSAV)
REBNEB	HS	1			:TEMPORARY,DELETE WHEN REBILD TEST OVER
CSMCNT	HC	0			:# OF SUMMARY TABLE ENTRIES MADE###GT
CDTPTR	HS	1			:OFFSET TO NEXT DETAIL TABLE ENTRY
CDTCNT	HS	1			:COUNT OF CRASH DETAIL ENTRIES

ERREG0	WS	10			:CRASH SAVE AREA FOR REG SET 0
	IF	DB.DEB
CRHSAV	HS	2
	EI	:DB.DEB
NXTCRP	HS	1			:OFFSET INTO CRASH SUMMARY TABLE FOR
					:NEXT CRASH TO REPORT TO SUPERVISOR

	IF	T2GATE
::	Gateway to Dispatcher port Zero Message templates
GAVPTS	HC	NDP		:gateway available ports,init by NDP##al
MG148F	BC	0		:TO HNET SUP MSG 148F SENT FLAG##AL
G0DFG	BC	0		:NO SUP 0D MSG FLAG
: Type 03,0A,0C,10 messages
GDZ03M	HC	00	:5 bytes message report to port 0 (msg 03)
	BC	03,00
	AC	/GW/	:DATA2 fld put an identifier, may change later
DZ03NR	HC	00	:Node Report parameter (msg subtype & DATA1)
DZ03LK	BC	8B	:product ID for T2G2
GDZ03L	EQ	.-GDZ03M	:msg length

GDZ0AM	HC	00	:8 sec. check for port sts chang (msg 0A)
	BC	0A,00	:Message type and key
DZ0AHN	HC	IHOST	:host number
	GL	IHOST
DZ0APT	HC	00	:ports available 
DZ0ARH	HC	00	:relative host number
GDZ0AL	EQ	.-GDZ0AM	:msg length

GDZ0CM	HC	00	:hst cost configuratn (msg 0C)
	BC	0C,00	:Message type and key
DZ0CHN	HC	IHOST	:host number
DZ0CCT	HC	INCOST	:tymfile defines isis netwk cost
DZ0CRH	HC	00	:relative host number
GDZ0CL	EQ	.-GDZ0CM

GDZ10M	HC	00	:report hst sts (msg 10)
	BC	10,00	:Message type and key
DZ10HN	HC	IHOST	:host number
DZ10PT	HC	00	:ports available 
DZ10RH	HC	00	:relative host number
DZ10ST	BC	0	:host status
GKEY	BC	0	:host key
GHIQ	BC	80	:host IQ,I bit set
GPID	BC	8B	:product ID code
GDZ10L	EQ	.-GDZ10M	:Length of mesage in Bytes

::Other control message tables for Gateway dispatcher
GDB7M	HS	0
GB7PRT	HC	00	:INsert Dispatchr port number
	BC	0B7,00	:Type B7 message
GB7INV	BC	0E0,00	:Addendum to accounting 
	BC	00	:use for invoice exchange or ....
GB7REA	BC	00	:Insert reason for disconnect
GDB7L	EQ	.-GDB7M	:Length of message

GD9FM	HS	0
	HC	00
	BC	9F	:Zapper
GD9FL	EQ	.-GD9FM

GDM07M	HC	00		:Port zero message
	BC	07		:Type 07 (Pseudo Needle Request)
GSLKEY	BC	00		:Key  (slot# * 4)
GLOKEY	HC	00		:Local Key (for Gateway is buffer #)
GIXELF	HC	00		:IIX and ELS field
	HC	IHOST		:always IHOST is circuit origin to INET
GHINID	BC	00		:TID (CCT) from HNET to INET
GDM07L	EQ	.-GDM07M	:Message length

::	IRC (International Record Carrier) report for T2GATE	###AL
Q	EQ	0
	RE	NLINKS		:LINK NUMBERS ASSIGNED
	IF	\IRC|Q|
IRC	EQ	1		:IRC VALUE DEFINED
	ELSE	:IRC|Q| NOT DEFINED
IRC|Q|	EQ	0
	GL	IRC|Q|
	EI	:IRC|Q|
Q	EQ	Q+1
	ER

	IF	IRC
IRCTBL	HS	0
Q	EQ	0
	RE	NLINKS		:LINK NUMBERS ASSIGNED
	BC	IRC|Q|
Q	EQ	Q+1
	ER
	EI	:IRC
	EI	:T2GATE		:not to be zeroed during init

	IF	STRHUB
NSTXK	HS	1		:NUMBER OF STAR-XLINKS AVAILABLE	###AL
	EI			:INIT IN EXEC TO STRXLK


RSEG0	HS	0			:**SEGMENT 0 WRITTEN OUT TO HERE**

:*******FROM HERE TO CLSEG0 (BELOW) FOR CRASH TABLE STUFF ONLY*******

:	COMMON CRASH TABLE AREAS

:	COMMON CRASH TABLE HEADER

CRSHDR	WS	0		:LOADII crash dump option expects FW bndry##wjl
NODENU	HS	1		:NODE NUMBER
NODETY	HS	1		:MACHINE TYPE
TABVER	HS	1		:COMMON CRASH TABLE VERSION
CODVER	HS	1		:CODE VERSION
TAKETI	HS	2		:GMT OF FIRST TAKEOVER
CRCNT	HS	1		:CURRENT CRASH COUNT

CSMTBL	BS	CSMTBS		:CRASH SUMMARY TABLE AREA (16d OF THEM)
CDTTBL	BS	CDTTBS		:CRASH DETAIL TABLE AREA (2 OF THEM)
:*******FROM RSEG0 (ABOVE) TO HERE FOR CRASH TABLE STUFF ONLY*******

CLSEG0	HS	0		:SEG0 CLEARED FROM HERE

SQNSAV	HS	1		:SEQUENCE NUMBER SAVE AREA
BUFSAV	HS	1		:BUFFER INDEX SAVE AREA
      IF REBTST
R1RBFT  WS      1               :return bufferlets routine
R0RBFT  WS      1               :return bufferlets routine
R4RBFT  WS      1               :return bufferlets routine
     EI
PROCID	HS	1		:CURRENT PROCESS NUMBER
::
ALINES	BS	LNSIZE		:ACTIVE LINES
ALINKS	BS	LKSIZE		:ACTIVE LINKS
	IF	APLYBP		:###ev 02/27
STLNKS	BS	LKSIZE		:Companion to ALINKS marks those Starlinks
	EI	:APLYBP		:for Apply Backpressure logic
NALNKA	WS	1		:STORAGE FOR BE ADDR. FOR NALINK FLD.	###AL
TEMPHS	HS	1		:TEMPORARY STORAGE FOR A HW		###AL
MXLINK	HS	1		:MAXIMUM NUMBER OF ACTIVE LINKS
NALINK	HS	1		:# OF ACTIVE LINKS
MXPASS	HS	1		:MAXIMUM NUMBER OF PASSTHRU CIRCUITS
PASTHR	HS	1		:# OF PASSTHRU CIRCUITS
PTHRPD	HS	1		:# of passthrus reported as available	###wjl
TERMIN	HS	1		:# OF CIRCUIT TERMINATIONS
MXPORT	HS	1		:PEAK ACTIVE KERNEL OR ISIS PORTS
CREPRT	HS	1		:CRASH REPORT INDICATOR, -1 IF REPORT SENT
CONSOL	WS	2		:CURRENT CONSOLE OUTPUT
ABEPSW	WS	1		:HOLDS MAC ERROR-RETURN ADDRESS
	SYAD(ABEPSW)
ABENPC	WS	1
DMAFLG	HS	1		:SET BY PRIVELEGED CODE IF DMA TIMEOUT
SFTDMA	HS	1		:COUNT BETWEEN PRIVELEGED CODE AND 4-MIN LOGIC
	SYAD(SFTDMA)
SFTMAC	HS	1		:LIKE SFTDMA FOR SOFT MAC FAILURES
	SYAD(SFTMAC)
MACISR	WS	1		:SAVE MAC INT STATUS REGISTER FOR CRASH TABLE

:	OTHER VARIABLES:

:	SCHEDULER CLOCKS AND QUEUE:

SQUEUE	WS	1		:PROCESS QUEUE

SCHTAB	WS	0		:SCHEDULER TABLE

T08MIN	WS	1		:SCHEDULE TABLE LABELS
T04MIN	WS	1
T02MIN	WS	1
T01MIN	WS	1

T30SEC	WS	1
T16SEC	WS	1
T08SEC	WS	1
T04SEC	WS	1

T02SEC	WS	1
T01SEC	WS	1
T500MS	WS	1
T250MS	WS	1

T125MS	WS	1
T064MS	WS	1
T032MS	WS	1
T016MS	WS	1

QEXEC	WS	20		:PROCESS P-COUNTERS
SQLAST	WS	1		:FOR SAVING LAST RUN QUEUE

PROTIM	WS	20		:FASTC TIME THAT PROCESS LAST RAN
PROHWM	WS	20		:HIGH-WATER MARK FOR EACH PROCESS'S EXECUTION
				: TIME (IN FASTC UNITS)
PROCNT	WS	20		:COUNT OF PROCESS EXECUTION OCCURRENCES
PACTIM	WS	20		:ACCUMULATOR FOR TIME SPENT IN A PROCESS
PSVTIM	HS	20		:SAVE AREA FOR PACTIM, SAVED IN 1-MIN LOGIC

EXLAVG	HS	1		:AVG EXEC LOOP ITERATIONS/SEC OVER LAST MINUTE
EXLALW	HS	1		:LOW-WATER AVG EXEC LOOPS/SECOND
EXLAHW	HS	1		:HIGH-WATER AVG EXEC LOOPS/SECOND
EXDHWM	HS	1		:DISMISS HIGH-WATER MARK (FASTC UNITS)
EXEHWM	HS	1		:EXEC LOOP HIGH-WATER MARK (FASTC UNITS)
SYLHWM	HS	1		:SYLVER INTERVAL HIGH-WATER MARK (FASTC UNITS)
NEDHWM	HS	1		:NEEDLE TRANSIT TIME HI-WATER MARK(FASTC UNITS)
	SYAD(NEDHWM)
NEDCNT	HS	1		:NUMBER OF NEEDLES THROUGH NODE
RMKRMS	HS	2		:NUMBER OF RMK CALLS LAST MINUTE AND
RMKNRS	HS	2		: NUMBER OF TIMES NO RECORD MADE

EXTIME	HS	2		:TIME OF ENTRY/EXIT FOR EXEC LOOP
EXLCNT	HS	2		:EXEC LOOP COUNT (RESET EACH MINUTE)
EXLTLA	HS	2		:SLOWC TIME OF LAST AVERAGE COMPUTATION
RMKRMW	HS	2		:WORKING FIELDS FOR RMK CALLS AND
RMKNRW	HS	2		: TIMES NO RECORD MADE
DISSAV	HS	2		:SAVE RETURN FOR FAST DISMISS

	IF	ISIS
DUESCH	WS	1		:SEE EXEC
EISECC	HS	1		:INC'D EVERY 1/8 SEC IF ISIS
TEMPER	EQ	0F0010		:ISIS-SUPPLIED TEMPERATURE
VOLTS	EQ	0F0011		:AND VOLTAGE
	ELSE
TEMPER	BS	1		:SOLO-SUPPLIED TEMPERATURE
VOLTS	BS	1		:AND VOLTAGE
	EI 	:ISIS
	SYAD(TEMPER)		:ADD TO XRAY SYMBOL TABLE FOR
				:  EASY REMOTE INSPECTION	###JHL	###wjl

CRYSAV	WS	10		:REG SAVE FOR CRYPTO
CRYSBF	WS	2		:CRYPTO MESSAGE BUFFER

HISTI	HS	1		:HISTORY BUFFER PTR

XLCRSH	WS	1		:TIME OF LAST CRASH FOR XRAY
CLKSAV	WS	1		:SAVE LOC FOR CLOCK TESTS
BIDDSV	WS	1		:SAVE LOC FOR BIDDY ADDRESS

DLDFLG	HS	1		:SET TO -1 IN LEP, CHECKED IN 4-SEC LOGIC
MTRTIM	WS	1		:TIME TO RUN NEXT 60 SECOND PERFORMANCE LOGIC
LDRTIM	HS	1		:SCHED LDRPRT EVERY 4 MTRFIC'S		###JHL
MININT	HS	1		:EXACT INTERVAL BETWEEN 1-MIN LOGIC EXECUTIONS
MINSAV	HS	1		:SAVE AREA USED IN COMPUTING MININT
S1SLOC	WS	1		:COUNTS OCCURRENCES OF 1-SECOND LOGIC.
				: DIFFERENCE BETWEEN 'S1SLOC' AND 'SLOWC'
				: INDICATES DRIFT IN 'G01SE1' SCHEDULING.

BFLTMX	WS	1		:14*(MAX NUMBER OF BUFFERLETS IN USE)
BFLTSV	WS	1		:RUNNING COUNT CELL FOR DETERMINING BFLTMX

	IF	REBILD
HBFTMX	WS	1		:14*(MAX NUMBER OF BUFFERLETS IN USE) HISTORY
HBFTSV	WS	1		:RUNNING COUNT CELL FOR DETERMINING HBFTMX
	EI 	:REBILD

::**********************************************************************
::
::	STARLINE LINK CHAIN DESCRIPTOR
::
::**********************************************************************
	IF	STRHUB
Q	EQ	0
SKDBLK	WS	0
	SYAD(SKDBLK)
	RE	NLINES
	IF	\NSTR|Q|
	WS	(SKTBSZ+3)/4
	EI
Q	EQ	Q+1
	ER
	EI	:STRHUB

::*********************************************************************
::
::	LINKER VARIABLES:
::
::*********************************************************************

SDSC	BS	NLINES*SDBSZ	:RESET DATA BUFFERS
KDLN	WS	NLINES		:LINK DESCRIPTOR POINTERS
	SYAD(KDLN  )
DWIBUF	BS	TINTCH*40	:DOWNLINE-LOAD BUFFERS - INPUT
DWOBUF	BS	TINTCH*42	:OUTPUT
::
INHRST	BS	LNSIZE		:INHIBIT RESETS ON THESE LINES
INHRLS	BS	LNSIZE		:PREVIOUS STATE OF INHRST
LINATT	BS	LNSIZE		:LINES TO BE ATTACHED
LINDET	BS	LNSIZE		:LINES TO BE DETACHED
LINKAS	BS	LNSIZE		:TEMP STORAGE FOR LINKER
VRSTDL	BS	LNSIZE		:RESET DETECTED ON DETACHED LINES
BORZAP	BS	LNSIZE		:1 TO CAUSE 'BORI ZAP'
LNSUSC	BS	LNSIZE		:CURRENT COPY OF LINES SUSPENDED
LNSUSO	BS	LNSIZE		:OLD (1-MINUTE) COPY OF LINES SUSPENDED

LINSPT	WS	1		:LINKER FLAGS LINES NEEDING LINE SPEED CALC
	SYAD(LINSPT)
LINSPD	WS	1		:1-SEC LOGIC FLAG LINES NEEDING LINE SPEED CALC

LNCHLR	WS	1		:LNCHCK LINK REG
IZLNLR	WS	1		:IZLNKR LINK REG
FREELR	WS	1		:HEAD OF FREE RECORD-BUFFER CHAIN
::
LNGREC	BS	LNSIZE		:GOOD RECORD RECEIVED ON LINE
LKGREC	BS	LKSIZE		:DITTO ON LINK
OLDKGR	BS	LKSIZE		:LAST 4 SECOND'S LKGREC

BGLSIZ  EQ      10
BGLIST	HS	BGLSIZ		:BAD GUY LIST (DO NOT TALK TO THEM)
MRESTZ	EQ	NLINKS/2+1
MRESET	HS	MRESTZ		:LIST OF LINES IN RESET STATE FOR WHICH
				: WE ARE MASTER

:	STORAGE SPACE FOR BUILDING RESET AND
:	NULL RECORDS DURING SYNC LINE INPUT.

	IF	XRESET		:###wjl
SYSTOR	WS	2*((XSDSZ+7)/8)	:Must be multiple of 8 bytes
SYSTSZ	EQ	(.-SYSTOR)/2	:Size of Sync Storage in HW
	ELSE
SYSTOR	WS	4		:ROOM TO SPARE
	EI	:XRESET

:	Line descriptor parameters
:	NOTE:  ">name" corresponds to proposed new usage
QSYLVR	HS	NLINES		:SYLVER STATE VARIABLES - P COUNTERS	>L.SYLP
LDARLN	WS	(NLINES+1)/2	:1 HW BIT ARRAY FOR EACH LINE KEEPS	>L.LDAR
				: TRACK OF ERRATE FOR ND DISPLAY

:	The following are for gathering statistics
RCRCVD	HS	NLINES		:GOOD RECORDS RECEIVED			>L.RCVD
RCTRNS	HS	NLINES		:NUMBER RECORDS TRANSMITTED		>L.TRNS

:	The following are sync-unique parameters
SVNTOP	HS	NLINES		:DATA BUFFER OUTPUT POINTER		>L.TAIL
SYLSHF	HS	NLINES		:LEFT SHIFT COUNT STORAGE		>L.SHFT
SYBCNT	HS	NLINES		:RECORD BYTE COUNT			>L.BCNT
SYHEDR	WS	NLINES		:RECORD HEADER				>L.HEDR

	IF	SILINS
:	The following are SIO-unique parameters
SIOPSZ	EQ	$A 128			: SIO packet size
SIOFSZ	EQ	SIOPSZ+2		: SIO Frame size (allow for size HW)
SOBFSZ	EQ	(SIOFSZ+0E)&0FFFF0	: SIO Output Buffer Size
SIBFSZ	EQ	(8*SIOFSZ)		: SIO Input Buffer size

:: SIBFSZ ADJUSTED IN RUNNING TIME IF IT IS STAR LIN BY SIBFSZ+20 ##AL

:	The following are SIO-unique storage
Q       EQ      (NLINES-SILINS)*2      	: 2*first line #
SIBUFN	EQ	.-Q			: INDEX INTO SIBUF		>L.SIBF
	SYAD(SIBUFN)
	HS	SILINS
SIOTST	EQ	.-Q			: SIO OUTPUT STATE		>L.SIST
	HS	SILINS
	IF	STRHUB			:FOR MULTI LINK SIOC/SION SWAPING
SIOCNS	EQ	.-Q			: SIO OUTPUT STATE		>L.SIST
	HS	SILINS
	EI	:STRHUB
	IF	SIBFRL			:SIO BUFFER RELOCATION ###LSH
	:SIO BUFFERS ARE RELOCATED TO SEG 2, SO NEED FULLWORD TO STORE
	:ADDRESS						###LSH
SIOCO	EQ	.-Q*2			: CURRENT OUTPUT BLOCK ADDRESS	>L.SICO
	WS	SILINS			:###LSH
SIONO	EQ	.-Q*2			: NEXT OUTPUT BLOCK ADDRESS	>L.SINO
	WS	SILINS			:###LSH
	ELSE	:NOT SIBFRL		:###LSH
SIOCO	EQ	.-Q			: CURRENT OUTPUT BLOCK ADDRESS	>L.SICO
	HS	SILINS
SIONO	EQ	.-Q			: NEXT OUTPUT BLOCK ADDRESS	>L.SINO
	HS	SILINS
	EI	:SIBFRL			:###LSH
	IF	STRRMT
STRRES	WS	(NLINES+1F)/20		:1 BIT FOR EACH LINE - SEND ONE RESET
RMTRSV	WS	1			:RETURN SAVE
RMRSCT	HS	1			:COUNTER FOR 4 SEC REMOTE RESET  LOGIC
	EI	:STRRMT
	IF	NGRDTM
LCRPCT	BS	NLINES			:LINE CHECK REPORT COUNT IF NOT 4-SEC
	EI				:				###AL
	HS	0	
SDUMM	WS	2			: DUMMY RECORD ARRAY
SSENT	WS	2			: RECORD SENT ARRAY
	IF	STRHUB
STDUMM	BS	(NLINKS+7)/8		: DUMMY RECORD ARRAY PER STRLNK
	HS	0			: HW BOUNDARY
STSENT	BS	(NLINKS+7)/8		: RECORD SENT ARRAY PER STARLINK
STXPTR	WS	1			:POINTER TO STRXLK FREE KD CHAIN##AL
	EI	:STRHUB
SIOBRS	HS	1			: BAD RECORD SIZE COUNTER
SIOBCS	HS	1			: BAD COMPUTED CHECKSUM COUNTER
	SYAD(SIOBCS)
SIOMIS	HS	1			: RECORD SIZE MISMATCH
SIONEW	EQ	.-SBASE			: BIT ARRAY IS 1 IF VERSION E MICROCODE
	SYAD(SIONEW)
	HS	1+SILINS/8		: BIT ARRAY IS ADDRESSED BY 2*LN
SIOIZL	HS	1			: SAVE AREA FOR RETURN LINK IN SIOIZ
SIOECT	HS	1			: NUMBER OF TIMES BUFFER COUNT INVALID
SIEREG	WS	8*4			: REGISTERS 8-F FOR LAST 4 INV BUFFER COUNTS
	IF	DB56KB			: IF SIO MONITORING OPTION
SEESAV	WS	2			: REGISTER SAVE AREA FOR SIOSEE
SIODMA	HS	SILINS			: USED FOR DMA TIMEOUTS ON SIO OUTPUT
DBSHUT	WS	3			: BIT ARRAY CORRESPONDING TO LINES
	SYAD(DBSHUT)
	EI	:DB56KB
	IF	SILINS
PKSVLH	EQ	20			: THE LENGTH OF THE SAVING BUFFER
PKSVCT	HS	1			: COUNT OF SIO BAD PACKETS SAVED ##AL
	SYAD(PKSVCT)
PSLNUM	HS	0			: FLAG SET WILL TURN-ON SIPKSV
	SYAD(PSLNUM)
	EI	:SILINS
	IF	ISIS
SIOPTA	WS	(NLINES+1F)/20		: SIO PORT AVAILABLE BIT ARRAY	###OAS
					: 0 = PORT AVAIL., USED FOR PORT SWITCH
	EI	:ISIS

:	HDLC micro SIO init software 'timeout' crpyto ignore flag	###wjl
	IF	HMICRO		:HDLC micro only			###wjl
SIOIGN	BS	LNSIZE		:bit array to ignore crypto 7B		###wjl
	EI	:HMICRO		:					###wjl

	EI	:SILINS

       IF       SPAM
SPMINI  HS      1               :used to tell spam when new Node CPS    ###sdw
       EI       :SPAM
SYLTIM	WS	1		:FASTC TIME TO CHECK FOR SYNC RING OVERRUN
SYLINT	HS	1		:FASTC INTERVAL FOR LINE SPEED CALC'S
LNKRET	HS	2		:RETURN LINK FOR LKVOLT
SYLXEC	HS	1		:COUNT OF NUMBER OF SYLVER EXECUTIONS
SYLXAV	HS	1		:AVERAGE INTERVAL BETWEEN SYLVER EXECUTIONS

ISECAD	WS	1		:I SEC ADDR. STORED##AL
FCSGOT	WS	1		:SOFTWARE SYNC FCS CKSM,HO HW IS DATA
				:FCS, LO HW IS 3 BYTE HEADER FCS##AL

:	TRACE-SYNC WORK AREAS:
	IF	TSTSZE
TSLINK	HS	1		:LINK OF INTEREST (TRACING ENABLED BY
	SYAD(TSLINK)		: PATCHING NEIGHBOR NUMBER IN THIS CELL
				: TSLINK ZEROED WHEN LINK GOES OUT.)
TSLINE	HS	1		:LINE OF INTEREST - SAME CONVENTION AS TSLINK
	SYAD(TSLINE,1)
TSRSVE	HS	4		:REGISTER SAVE - FOREGROUND
TSBSVE	HS	2		:REGISTER SAVE - BACKGROUND
TSFPTR	HS	1		:CURRENT ENTRY PNTR FOR FOREGROUND TRACE TBL
	SYAD(TSFPTR)
TSFTBL	BS	TSTSZE		:FOREGROUND EVENT TRACE TABLE
TSBPTR	HS	1		:CURRENT ENTRY POINTER FOR BACKGROUND TRACE TBL
TSBTBL	BS	TSTSZE		:BACKGROUND EVENT TRACE TABLE
	SYAD(TSBTBL)
	EI 	:TSTSZE

:	STORAGE AREA FOR SIO TIMEOUT CODE
SBZSAV	WS	10		:SAVE AREA FOR REGISTERS

LDRGSV	HS	2		:SAVE LINK REGISTER
TIK4MN	HS	2		:4-MINUTE TICKER (# OCCURRENCES OF LDRPRT)
LDTARY	HS	(NLINES+0F)/10	:SET BIT FOR LINE WHICH MADE DIAGNOSTIC REPORT

	IF	SILINS
SIOHCK	HS	SILINS		:SAVE CUMULATIVE # OF SIO HDLC CKSM ERRORS
SIOHAB	HS	SILINS		:SAVE CUMULATIVE # OF SIO HDLC ABORTS

MSBASE	EQ	(SILINS-NLINES)*2
	IF	DB56KB
SBASEA	EQ	(NLINES-SILINS)*10
	EI	:DB56KB
	EI	:SILINS

	DEFAULT(SCHFAS,0)
	IF	SCHFAS
	IF	SCHFAS-SILINS
	REMARK %FATAL ERROR--ASSEMBLY KILLED
	QUIT
	EI	:SCHFAS-SILINS
SCHCNT	HS	1
	EI	:SCHFAS

::*********************************************************************
::
::	YAKYAK VARIABLES:
::
::*********************************************************************
::
LKTEAR	BS	LKSIZE		:LINKS BEING PROCESSED BY RTEAR
LKMAKE	BS	LKSIZE		:DITTO RMAKE
LKSRVD	BS	LKSIZE		:LINKS BEING SERVICED BY RTD/RMK

NEWLNR	WS	1		:SAVE RETURN FOR NEWLNK/TRLINK
BPMPRC	WS	1		:TEMP STORAGE FOR BPMV
LKRR	BS	LKSIZE		:CLEARED WHEN LINK COMPLETES ROUND ROBIN
	DEFAULT(RTRMAX,7F)	: max. no. of chars RTEAR will do for one line
RTRCNT	HS	1		: where we keep track of the above

RMTSR1	HS	1		:TEMP STORAGE
RMTSR2	HS	1
RMTSR3	HS	1
RMTSR4	HS	1

RMT1SL	HS	1		:SAVE SIZE OF EACH T-I SUP RECORD HERE
RMT1SB	HS	1		:SAVE BUFFER# WHEN ZAPPING T-I COMMAND CRQ

MINLR	HS	1		:MINIMUM LOGICAL RECORD SIZE (3 FOR T-I,
				: 1 FOR T-II). USED BY RTD TO DETERMINE IF
				: ANY LOGICAL RECORDS REMAINING IN PACKET
LSNIPS	HS	1		:COUNT LINK SNIPS
	SYAD(LSNIPS)
ZAPCNT	HS	1		:COUNT ZAPPED CIRCUITS FOR LINK OUT NODE REPORT
CMDZCT	HS	1		:COUNT ZAPPED COMMAND CIRCUITS FOR REPORTING
TRREGS	WS	10		:REGISTER SAVE FOR CALLING TRACE, SUP12
LKSNRG	WS	10		:REGISTER SAVE FROM LINK SNIP
	SYAD(LKSNRG)

:	MISCELLANEOUS FLAGS:

:	GUSH AND TRIKLE ARE CHANNEL BIT ARRAYS WHICH INDICATE RATE OF DATA
:	FLOW INBOUND. RTD TESTS THE SIZE OF EACH LOGICAL RECORD TORN,
:	AND SETS THE GUSH ARRAY IF L.R. SIZE IS 'TRIKLV' OR GREATER.
:	IF L.R. SIZE IS LESS THAN 'TRIKLV', THE TRIKLE ARRAY IS SET
:	FOR THAT CHANNEL. EVERY 2 SECONDS THE TRIKLE ARRAY IS OR'D
:	INTO THE GUSH ARRAY. WHEN RMAKE SENDS BACKPRESSURE RECORDS, IT
:	WILL ONLY TEST THE CHANNELS WITH GUSH SET TO SEE IF
:	BACKPRESSURE MAY BE RELIEVED.

	IF	APLYBP!STRHUB!STRRMT
RMKRSV	WS	1		:NO BACK PRESSURE RELIEF EXCHANGE ##EV
RMKBSV	WS	1
PRCSAV	WS	1		:Count of packet bytes 
	EI	:STRHUB!STRRMT
RTMXSV	WS	1		:TEMP STORAGE FOR RTD/RMK
RTMT1	WS	1
RTMT2	WS	1
RTMT3	WS	1
RMTNSV	WS	1
RMTNFL	HS	1
RMKFLG	HS	1		:FLAG TO ENSURE ONLY PROCESSING ARRAYS ONCE
	IF	DB.DEB
RMKHWM	HS	1		:HIGH-WATER MARK FOR INTERVALS BETWEEN
				: RMAKE EXECUTIONS (IN FASTC UNITS)
RMKTIM	HS	2		:TIME OF LAST RMAKE EXECUTION
	EI	:DB.DEB

CKOSAV	WS	1		:WORK SPACE FOR LINK OVERLOAD CHECKER

:	EQUATES FOR IMMEDIATE INSTRUCTIONS
:	(NEEDED BECAUSE OF NAD LIMITATION CONCERNING FORWARD-REFERENCED
:	LABELS IN IMMEDIATE INSTRUCTIONS)

XCBSZL	EQ	4		:BFLET SHIFT FACTOR -- ALSO IN SWITCH
XCBSZ	EQ	1^XCBSZL	:BUFFERLET SIZE

:	Consider for possible future additions to link descriptor


	DEFAULT(SQNUMB,200)	:###TZ

::*********************************************************************
::
::	XHOSTS VARIABLES:
::
::*********************************************************************

:	HOST TABLES
:	Consider for possible future Host descriptor
HSTPTA	HS	NHOSTS		:# OF HOST PORTS AVAILABLE
HNPORT	HS	NHOSTS		:# OF HOST PORTS ACTIVE
:	NOTE:  Portions of host table not cleared at restart.	
:	The previous two entries MUST precede HOSTN for the
:	reinitialization of the host tables at (re)start to work
:	properly in NSTART.###jhl (this is not real smooth)
:	We zero out HNPORT and reset HSTPTA to HMAXP.

:*******FROM HERE TO NEWSUP LABEL (BELOW) FOR HOST TABLE STUFF ONLY****

HOSTN	HS	NHOSTS		:HOST #S
HMAXP	HS	NHOSTS		:MAX # OF PORTS
	HS	0		:HSTAT STARTED AT HW BOUNDARY		##AL
HSTAT	BS	NHOSTS		:STATUS BITS
HSTKEY	BS	NHOSTS		:KEY (4*SLOT #), FOR EACH HOST
:	EXPANDED HOST STATUS INFORMATION
HSTMBK	BS	NHOSTS		:MULTI-BASED HOST KEY			###OAS
	IF	T2GATE
HSTATN	EQ	HSTAT		:ONLY ONE SLOT HOST & STATUS FOR T2G	##AL
	ELSE
HSTATN	BS	NHOSTS		:EXPANDED HOST STATUS(sup19 status byte)###OAS
	EI	:T2GATE##AL	:BITS 0,1 - STATUS (SAME AS HSTAT 6,7)
				:BIT 2 SET IF OUT OF PORTS
				:BIT 3 SET INDICATES IIX
				:BIT 4 SET - ORG ONLY HOST
				:BIT 5 SET - DEST ONLY HOST
				: (IF 4 AND 5 SET, SAME AS BOTH NOT SET)
				:Bits 6,7 - unused
HSTYPE	BS	NHOSTS		:HOST TYPE (PID)			###OAS
HSTCST	BS	NHOSTS		:HOST COST (MULTI TARGET HOST)		###OAS
HSTTIM	WS	NHOSTS		:TIME OF LAST HOST STATUS UPDATE	###OAS
HSTAT3	BS	NHOSTS		:Additional host status byte		###wjl
				:Bits 0,1,2 - unused			###wjl
				:Bit 3 - set if proxy host		###wjl
				:Bits 4,5 - Collect-calls		###wjl
				: 00 = never accept Collect-calls	###wjl
				: 01 = only accept calls		###wjl
				: 10 = leave decision to destination host##wjl
				: 11 = unused				###wjl
				:Bits 6,7 - unused			###wjl

:*******FROM HOSTN (ABOVE) TO HERE FOR HOST TABLE STUFF ONLY***********

:	NEWSUP label used by NSTART to resume clearing
NEWSUP	HS	1		:NEW/OLD (1/0) SUPERVISOR FLAG		###OAS

	IF	ISIS
HSTFLG	HS	(NHOSTS+0F)/10	:FLAG INDICATING NODE CODE HAS GOT HOST
:	STATUS REPORT (MESSAGE 04 OR 10) FROM ISIS FOR SPECIFIC HOST.
:	ONE BIT FOR ONE HOST.  ***NEED CLEAR ALL FLAGS WHEN RESTART***
HSTSAV	WS	1		:TEMP. STORAGE TO SAVE R2
	EI	:ISIS

	IF	RESHST		:RESTRICTED HOST STUFF
HCTSM	HS	NHOSTS		:CIRCUITS/MINUTE LIMIT
HCTSCT	HS	NHOSTS		:CIRCUITS/MINUTE COUNT
RESHMS	HS	(NHOSTS+0F)/10	:BIT ARRAY TO THROTTLE NODE REPORTS FOR
				: RESTRICTED HOST VIOLATIONS
	EI	:RESHST

	IF	RKERNL!IKNRNG	:REAL KERNEL OR ISIS KERNEL W NEG RING
KERNWL	WS	(NKU+1F)/20	:NEW CIRCUITS TO KERIO
KERBPX	WS	(NKU+1F)/20	:BACKPRESSURE OUTBOUND DATA FROM KERNEL IF ZERO

	ELSE	:NOT RKERNL!IKNRNG
KERBPX	HS	8		:BP FLAGS, ISIS VERSION
KERNWL	HS	8		:NEW CIRCUITS
	EI 	:(NOT) RKERNL!IKNRNG

	IF	KNRING

KOFSAV	WS	1		:BIT SET FOR POTENTIAL ACTIVE PORT
KRZAPI	WS	1		:BIT SET FOR ZAPPER SENT TO KERNEL
KRGOBI	WS	1		:BIT SET FOR GOBBLER SENT TO KERNEL
NLOGDF	WS	1		:BIT SET FOR DEFERRED NEWLOG REPORT TO KERNEL
NLOGCT	WS	1		:BIT SET FOR NEWLOG CONTROL TO KERNEL
NLOGOK	WS	1		:BIT SET IF O.K. TO HANDLE NEW LOGIN
KERSTT	HS	1		:KERNEL STATUS				###GT

	IF	DB.DEB
KRNRPS	HS	1		:SAVE ORIGINAL PRD (NODE INDEX)
KRNLRS	HS	1		:SAVE ORIGINAL LRC (KERNEL INDEX)
KNLRCS	HS	1		:SAVE COMPUTED ROOM AVAILABLE
	EI 	:DB.DEB

	IF	SIORNG
:	INTERRUPT COMMUNICATION RING
SIRI	HS	1		:IN POINTER (INDEXED BY INTERRUPT ROUTINE)
	SYAD(SIRI  )
SIRO	HS	1		:OUT POINTER (INDEXED BY SIRCIN)
SIRX	BS	SIRXSZ		:INTERRUPT COMMUNICATION RING

SIRXIZ	HS	1		:INITIALIZE INTERFACE IF NON-ZERO
	SYAD(SIRXIZ)
SIRFLG	HS	1
	SYAD(SIRFLG)
:	SIO RING FLAG, STATE VALUES AS FOLLOWS:
:	=0	SIO CARD IS DEAD (DOWN)
:	-1	SIO CARD IS ALIVE (UP)
:	>0	SIO CARD TIMED-OUT. SIRFLG CONTAINS COMMAND WHICH TIMED-OUT.
:		STSRM0 KERNEL IN BOOT, AWAITING SIO RING LOAD.

SIRDLD	HS	1		:SIO RING DOWN-LINE LOAD FLAG:
:	=0	NO SIO RING LOAD IN PROGRESS
:	-1	SIO RING LOAD IN PROGESS

	EI 	:SIORNG
	EI 	:KNRING

:	COMMON STUFF

FASSAV	WS	1		:FASTC AT TIME OF SUP CRASH
KERSVD	WS	(NKU+1F)/20	:KERNEL PORTS BEING PROCESSED BY KERIO
SUPSVD	WS	NSP/20		:SUP SIMILAR

XHSVRT	WS	1		:SAVE RETURNS
SBPTMP	WS	1		:TEMP STORAGE
XHPRCS	HS	1		:PRC SAVE
KR4SAV	HS	1		:SAVE AREA FOR R4 (FW INDEX TO FIND PORT)

KERICC	HS	2		:COUNT OF CHARS INTO THE KERNEL
KEROCC	HS	2		:DITTO OUT
SUPICC	WS	1		:GUESS
SUPOCC	WS	1
suocct  hs      1               :running cps
suicct  hs      1               :running cps
suoccw  hs      1               :highwater
suiccw  hs      1               :highwater

SUICHR	HS	1		:SAVE AREA FOR INVALID CHARACTER PAIRS
				: ARRIVING AT A SUP PORT
SUERCH	HS	1		:SAVE CHANNEL FOR ERRONEOUS NETWORK CHARACTERS
SUERTP	HS	1		:SAVE TYPE OF ERRONEOUS CHARACTERS DETECTED

	IF	SIORNG
SIRCSV	WS	1		:SAVE LINK FOR SIRSCK
	EI 	:SIORNG

	IF	SNRING
SUPBPV	WS	NSP/20		:RESET IF BP'D FROM NODE-->SUP
SUPBPX	WS	NSP/20		:RESET IF BP'D FROM SUP-->NODE
	IF	DB.DEB
SRNRPS	HS	1		:SAVE ORIGINAL PRD (NODE INDEX)
	SYAD(SRNRPS)
SRNPRS	HS	1		:SAVE ORIGINAL PRC (SUP INDEX)
	SYAD(SRNPRS)
SRNRCS	HS	1		:SAVE COMPUTED ROOM
	SYAD(SRNRCS)
	EI 	:DB.DEB
	EI 	:SNRING

        if      nku
kricct  hs      1
krocct  hs      1
kroccw  hs      1
kriccw  hs      1
        ei      :nku

::*********************************************************************
::
::	DISPI VARIABLES:
::
::*********************************************************************

	IF	ISIS		:COMMON STORAGE FOR ISIS AND TYMSAT
DSOLGH	HS	2		:'HOST #', 'TID', 'ESC' FOR DSOLGC
DSOSPC	WS	1		:CONTROL CHARACTER ARRAY FOR LOGIN STRING

DIXLIM	HS	NDP		:TRANSMIT LIMITS (PER PORT)

DISBPV	WS	(NDP+1F)/20	:RECEIVED BACKPRESSURE FLAGS
	SYAD(DISBPV)
DISBPX	WS	(NDP+1F)/20	:TRANSMITTED SUCH
	SYAD(DISBPX)
DISSVD	WS	(NDP+1F)/20	:PORT SERVICED FLAGS

DISAUX	WS	(NDP+1F)/20	:AUX CIRCUIT REQUEST FLAGS
DISHNG	WS	(NDP+1F)/20	:HANG SENT TO DISP PORT, NOT YET ZAPPED
	SYAD(DISHNG)
DISZNK	WS	(NDP+1F)/20	:ZAP SENT TO DISP PORT, AWAITING ZAP ACK
	SYAD(DISZNK)
DISELS	WS	(NDP+1F)/20	:REQUEST EXTENDED LOGIN STATUS FLAGS

	IF	EXPNDL		:###jhl
DISUUN	WS	(NDP+1F)/20	:bit set when circuit requests UUN	###jhl
LNDLSV	WS	1		:saves BB ptr for LEP09 PEEKing at SNI's###jhl
SNCSV1	WS	1		:saves BE ptr for LOGGER to fill msg length
SNIBUF	WS	1		:holds buffer number containing SNI list
SNCTSV	WS	1		:save SNI-length subcount in LOGGER

:	equates for SNI (supplementary needle items) and their types
SNIUUN	EQ	08		:request for UUN or "follows UUN"
SNIPRX	EQ	0C		:proxy login token
SNIHST	EQ	10		:originating host number
SNIIIX	EQ	14		:request for IIX circuit
SNILGC	EQ	18		:login characters
SNINOP	EQ	0F4		:SNI no-op
SNITRM	EQ	0FC		:terminates SNI list
SNTYP0	EQ	0		:bits for type 0
SNTYP1	EQ	1		:bits for type 1
SNTYP2	EQ	2		:bits for type 2
SNTYP3	EQ	3		:bits for type 3
SNITYP	EQ	3		:mask to isolate type bits
	EI	:EXPNDL

DSSVRT	WS	1		:FOR SAVING RETURN

DIDTIM	WS	1		:DISPATCHER PROCESS DISMISS TIME

:	THE FOLLOWING 8 HALFWORD FIELDS MUST REMAIN IN CONTIGUOUS
:	LOCATIONS FOR XRAY 'IS' COMMAND. ###SLH
DISICC	HS	1		:CHARACTER COUNTS - INTO DISPATCHER
DISOCC	HS	1		:FROM DISPATCHER
DSICHN	HS	1		:NEW NEEDLE CHANNEL NUMBER
				: (SEE 0310 MESSAGE)
DSINOD	HS	1		:CIRCUIT ORIGINATING NODE NUMBER
				: (SEE 0310 MESSAGE)
DORHST	HS	1		:ORIGINATING HOST NUMBER
				: (SEE 07 MESSAGE)
DOILLG	HS	1		:NUMBER OF ILLEGAL LOGIN CHARACTERS
				: FROM DISPATCHER PORTS NOT IN LOGIN MODE
				: (SEE B3 MESSAGE)
DIDISM	HS	1		:NUMBER OF FORCED DISMISSES FOR DISIN
DODISM	HS	1		:NUMBER OF FORCED DISMISSES FOR DISOUT

DORSLT	HS	1		:SLOT NUMBER * 2
				: LAST SLOT WHICH ORIGINATED CIRCUIT
RPSAV	HS	1		:TEMP STORAGE
DSIPRT	HS	1		:CIRCUIT ORIGINATING PORT NUMBER
DSIHST	HS	1		:CIRCUIT ORIGINATING HOST NUMBER
DSINFL	HS	1		:SAVE NEEDLE FLAGS
DSITLG	HS	1		:INDICATE TRANSPARENT LOGIN IF POSITIVE
DORSIQ	HS	1		:SAVE SIQ
DSOHYP	HS	1		:INDICATE IF HOST STATUS MESSAGE CONTAINS HYPE
	IF	(1-T2GATE)
SCLCNT	HS	NUSLT		:COUNT NUMBER OF CIRCUITS, BY SLOT
SMLCNT	HS	NUSLT		:COUNT NUMBER OF SLOT REPORTS, BY SLOT
	EI	:(1-T2GATE)		###EV
DIMMSV	HS	2*2		:SAVE FOR REG'S 14,15
	EI 	:ISIS

XFNDSV	WS	1	:XFNDLK ROUTINE
LILCNT	HS	1	:# OF LEGAL ILL INST OCCURENCES, ZEROED IN 4MIN LOGIC

::*********************************************************************
::
::	SWITCH VARIABLES:
::
::*********************************************************************

PFMTYP	HS	1		:RTD STORES ARRIVING PERF MON.CHAR HERE
ARRIVL	WS	1		:RTD STORES ARRIVAL TIME OF PERF MON CHAR PAIRS

TVRSUP	HS	1		:CONTAINS SUP # AFTER TAKEOVER
	SYAD(TVRSUP,1)
TVRBUF	HS	1		:SUP UPSTREAM BUFFER #
TVRSTT	HS	1		:SUPERVISOR STATUS (5=AWK,4=SLP,3=FRZN)
LOGZPF	HS	1		:TO CAUSE LOGGER TO ZAP CIRCUITS ON TVR
TAKOVR	HS	1		:SHOW RECENT TAKEOVER,DEFERRED RESOURCES REPORT
LEPINB	HS	1		:BUFFER BEING PROCESSED BY LEP
LEPNOD	HS	1		:BUFFER FOR LEP MESSAGES
LEPMES	HS	80
SUPMBF	HS	5		:BUFFER FOR SUP UPSTREAM MESSAGES
	IF	ISIS
	IF	IKNRNG
KDISP	HS	1		:FOR FLASHING DISPLAY OF NETWORK STATUS
	EI 	:IKNRNG
SUPIBF	HS	3		:TEMPORARY BUFFER FOR DIAGNOSTIC MESSAGES
				: GENERATED IN ISIS FOREGROUND ROUTINE
	EI 	:ISIS

LEPNPF	HS	2		:LEFT HALFWORD POSITIVE IF HANDLING SUP NOPP
:	COMMAND FOR LOAD TEST. RIGHT HALFWORD HAS LOOP COUNTER. SEE 'LEPNOP'.
LEPNSF	HS	2		:SUP FASTC SAVE AREA FOR SUP NOP
LEPXER	HS	1		:NUMBER OF LEP ERRORS (SEE LEPXMN, LEPXCM)



:	THE STORAGE FOR MPVC LOGIN TIME CHECKING		###LSH
DEFAULT(MPCCHK,0)
	IF	MPCCHK
HNGNB	WS	1		:TIME TO START EXECUTING HANGAN
ASYPB	WS	1		:TIME TO START EXECUTING ASYPOL
LGGOB	WS	1		:TIME TO START EXECUTING LGGO
MPSNB	WS	1		:TIME TO START EXECUTING MPSCAN
MPSTB	WS	1		:TIME TO START EXECUTING MPVCST
MMUXB	WS	1		:TIME TO START EXECUTING M.MUX
MPLNB	WS	1		:TIME TO START EXECUTING MPVCLN
LGERB	WS	1		:TIME TO START EXECUTING LOGGER
ASYLB	WS	1		:TIME TO START EXECUTING ASYLOU
ASYMB	WS	1		:TIME TO START EXECUTING ASYMPC

HNGNF	HS	1		:FLAG TO INDICATE ANSWER, HANG OR IDLE
ASYPF	HS	1		:FLAG TO INDICATE HAS ACTIVITY OR NOT
LGGOF	HS	1		:FLAG TO INDICATE HAS ACTIVITY OR NOT
MMUXF	HS	1		:FLAG TO INDICATE HAS ACTIVITY OR NOT
MPLNF	HS	1		:FLAG TO INDICATE HAS ACTIVITY OR NOT
LGERF	HS	1		:FLAG TO INDICATE HAS ACTIVITY OR NOT
ASYLF	HS	1		:FLAG TO INDICATE HAS ACTIVITY OR NOT

HNGNAN	WS	1		:TIME PERIOD FOR ANSWER LOGIC
	SYAD(HNGNAN)
HNGNHN	WS	1		:TIME PERIOD FOR HANG LOGIC
HNGNNO	WS	1		:TIME FOR HANGAN IDLE
ASYPIO	WS	1		:TOTAL TIME FOR ASYINP,ASYOUT,AND M.DMX
	SYAD(ASYPIO)
ASYPNO	WS	1		:TOTAL TIME FOR ASYPOL IDLE
LGGSND	WS	1		:TIME FOR LGGO -- (MPSCAN) -- SNDLOG LOGIC
	SYAD(LGGSND)
LGGNO	WS	1		:TIME FOR LGGO -- SNDLOG IDLE
MPSNYS	WS	1		:TIME FOR MPSCAN LOGIC
MPSTYS	WS	1		:TIME FOR MPVCST LOGIC
	SYAD(MPSTYS)
MMUXYS	WS	1		:TIME FOR M.MUX SUB PORT LOGIN LOGIC
				:(PSEUDO PORT CIRCUIT IS BUILT ALREADY)
	SYAD(MMUXYS)
MMUXNO	WS	1		:TIME FOR M.MUX IDLE
MPLNYS	WS	1		:TIME FOR MPVCLN LOGIC
	SYAD(MPLNYS)
MPLNNO	WS	1		:TIME FOR MPVCLN IDLE
LGERYS	WS	1		:TIME FOR LOGGER TIMEOUT LOGIC
	SYAD(LGERYS)
LGERNO	WS	1		:TIME FOR LOGGER IDLE
ASYLYS	WS	1		:TIME FOR ASYLOU -- ASYMPC LOGIC
	SYAD(ASYLYS)
ASYLNO	WS	1		:TIME FOR ASYLOU IDLE
ASYMYS	WS	1		:TIME FOR ASYMPC LOGIC
	EI	:MPCCHK



:	THE STORAGE FOR THE DEBUGGER				###LSH

:	TURN OFF ALL THE ASSEMBLY SWITCHES FOR  ALL THE DEBUGGERS
DEFAULT(LNFDBG,0)		:LOGON/LOGOFF DEBUGGER OFF
DEFAULT(CBZDBG,0)		:CIRCUIT BUILDING/ZAPING DEBUGGER OFF
DEFAULT(BFSDBG,0)		:BUFFER STRUCTURE DEBUGGER OFF
DEFAULT(LPGDBG,0)		:LEP/LOGGER DEBUGGER OFF
DEFAULT(AIODBG,0)		:ASYNC INPUT/OUTPUT DEBUGGER OFF
DEFAULT(DBGON,LNFDBG!CBZDBG!BFSDBG!LPGDBG!AIODBG)

REGSV1	WS	1		:TEMP STORAGE FOR REGISTERS
REGSV2	WS	1
REGSV3	WS	1
REGSV4	WS	1
REGSV8	WS	1
REGST	WS	1
RGST	WS	1
	IF	LPGDBG
LPGSSV	WS	1		:TEMP STORAGE FOR RING POINTER
	EI	:LPGDBG

	IF	LNFDBG
LGINUS	HS	1		:"LG" XRAY COMMAND IN USE INDICATOR
	EI	:LNFDBG
	IF	CBZDBG
CZINUS	HS	1		:"CZ"XRAY COMMAND IN USE INDICATOR
	EI	:CBZDBG
	IF	BFSDBG
BFINUS	HS	1		:"BF" XRAY COMMAND IN USE INDICATOR
	EI	:BFSDBG
	IF	LPGDBG
LLINUS	HS	1		:"LL" XRAY COMMAND IN USE INDICATOR
	EI	:LPGDBG
	IF	AIODBG		
	IF	SOLOCS
ADINUS	HS	1		"AD" XRAY COMMAND IN USE INDICATOR
	EI	:SOLOCS
	EI	:AIODBG


:	TURN OFF ALL THE ENABLE/DISABLE FLAGS FOR ALL THE DEBUGGERS

	IF	LNFDBG		:FOR LOGON/LOGOFF DEBUGGER
	IF	SOLOCS
LNFDIS	HS	1		:FLAG FOR IZ.PRT,ESTPRT,ASYLOU,DT.PRT,
				:AND CIRDIS.
	SYAD(LNFDIS)
SNDDIS	HS	1		:FLAG FOR SNDLOG.
	SYAD(SNDDIS)
ASMDIS	HS	1		:FLAG FOR ASYMPC.
	SYAD(ASMDIS)
	EI	:SOLOCS
LINDIS	HS	1		:FLAG FOR LOGIN. 
	SYAD(LINDIS)
	EI	:LNFDBG

	IF	CBZDBG		:FOR CIRCUIT BUILDING/ZAPPING DEBUGGER
CRQDIS	HS	1		:FLAG FOR CRQ, AND CRQHCR.
	SYAD(CRQDIS)
ZAPDIS	HS	1		:FLAG FOR ZAPHRD, AND ZAPV.
	SYAD(ZAPDIS)
	EI	:CBZDBG

	IF	BFSDBG		:FOR BUFFER STRUCTURE DEBUGGER
GRFDIS	HS	1		:FLAG FOR GFCBUF, AND RFCBUF.
	SYAD(GRFDIS)
WREDIS	HS	1		:FLAG FOR WRE, CKZB, REBZ, BUFZAP
	SYAD(WREDIS)
CBCDIS	HS	1		:FLAG FOR CBCLR.
	SYAD(CBCDIS)
	IF	SOLOCS
EMTDIS	HS	1		:FLAG FOR EMPTY
	SYAD(EMTDIS)
	EI	:SOLOCS
	EI	:BFSDBG

	IF	LPGDBG		:FOR LEP/LOGGER DEBUGGER
LPGDIS	HS	1		:FLAG FOR LEP AND LOGGER.
	SYAD(LPGDIS)
LPDDIS	HS	1		:FLAG FOR LEP0D, LEP09, AND LEPZLI
	SYAD(LPDDIS)
	EI	:LPGDBG

	IF	AIODBG		:FOR ASYNC INPUT/OUTPUT DEBUGGER
	IF	SOLOCS
GTCDIS	HS	1		:FLAG FOR GETCHR.
	SYAD(GTCDIS)
PTCDIS	HS	1		:FLAG FOR PUTCHR.
	SYAD(PTCDIS)
PTSDIS	HS	1		:FLAG FOR PUTSIG.
	SYAD(PTSDIS)
	EI	:SOLOCS
	EI	:AIODBG

:	THE END OF STORAGE FOR DEBUGGER		###LSH


LOGSAV	WS	1		:TEMP STORAGE FOR LOGIN
LOGTBF	WS	1
LOGTID	BS	1

LGCSAV	WS	1		:TEMP STORAGE FOR LOGCLR		###LSH
CRDSAV	WS	1		:TEMP STORAGE FOR CIRDIS		###LSH
CRDSSV	WS	1		:TEMP STORAGE FOR CIRDIS		###LSH
ASMSSV	WS	1		:TEMP STORAGE FOR ASYMPC		###LSH

FREELB	HS	1		:HEAD OF THE FREE BUFFER-PAIR LIST
	SYAD(FREELB)
FREELT	HS	1		:HEAD OF FREE BUFFERLET LIST
	SYAD(FREELT)
REBL	HS	1		:POINTER TO RESERVE TANK LIST
WRERET  WS      1       	:RETURN POINTER FOR WRE ROUTINE
SWIVSV	WS	1		:TEMPORARY STORAGE FOR SWITCH
YAKT1	WS	1		:TEMP
LEPSV1	WS	1		:DITTO
:::
BPMXSV	BS	LKSIZE		:DITTO BPMX
BPMTII	BS	LKSIZE		:DO FLOW CONTROL FOR TYMNET-II LINKS
	IF	APLYBP
BPMSTR	BS	LKSIZE		:Aply BP for Starlinks
	EI	:APLYBP		:###ev 02/27
CRQASV	WS	1		:SAVE LINK REG FOR CRQALT
BPMXSR	WS	1		:SAVE RETURN FOR BPMX
BPSHSV	WS	1		:TEMP STORAGE FOR BPMSHF
BPSHRT	WS	1
GETRSV	WS	1
RFCSAV	WS	1
TRCSV1	WS	1
TRCSV2	WS	1
HPRUNV	WS	1
ZAPXS1	WS	1		:SAVE AREA FOR CALLING LOGCLR FROM ZAPX
ZAPXS2	WS	1
BUBS1	HS	1		:WORK AREAS FOR BUBBLE
BUBS2	HS	1
BUBS3	HS	1
LNKRGS	WS	2		:REG STORAGE FOR SHRK4, FNDKNC, BUBBLE
WCDSAV	WS	1		:TEMP STORAGE FOR WCD
CHUSAV	WS	1		:TEMP STORAGE FOR SWRCHU

RFAT	WS	1		:DATA FROM FAT ZAPPER FOR REBUILD REQUEST

DETSVC	WS	1		:SERVICED FLAGS FOR 'DETACH'
DETMTY	BS	$A32		:MESSAGE TYPE FOR EACH DETACHED PORT
				: OUTPUT IT ON RECEIPT OF NEEDLE
DETTSV	HS	1		:TEMP AREA FOR ABOVE

ACT7	WS	3		:LAST '07' TYPE ACCOUNTING MESSAGES
ACTLST	BS	1		:INDEX TO LAST TYPE '07' MSG SENT

WATCHDOG BS	1		:WATCHDOG TIMER FLAG

NEDFLG	HS	1		:LEP SAVE NEEDLE FLAGS

:	CIRCUIT BUILDING CONSISTENCY FIELDS
NC.LPE	HS	1		:NUMBER OF LEP CHAN IN USE, NO NEIGHBOR ERRORS
NC.CRQ	HS	1		:TOTAL NUMBER OF CIRCUITS ATTEMPTED BY CRQ
NC.CRZ	HS	1		:NUMBER OF CIRCUITS ZAPPED BY CRQ
NC.CRC	HS	1		:TOTAL NUMBER OF CIRCUITS COMPLETED BY CRQ
NC.THS	HS	1		:CIRCUIT ERROR REPORTING THRESHOLD
NC.CER	HS	1		:TOTAL NUMBER OF CONSISTENCY ERRORS

PLISLT	HS	1		:STORAGE FOR ISIS SLOT NO. FOR PLI MESSAGE
PLICNT	HS	1		:BYTE COUNT IN PLI MESSAGE
PLINDX	HS	1		:CURRENT RECEIVED BYTE COUNT FOR PLI MESSAGE
PLIXOR	HS	1		:CHECKSUM
PLICN2	BS	1		:ANOTHER BYTE COUNT FIELD, FOR BUFCAN ROUTINE
PLIDAT	HS	100/2		:PLI MESSAGE DATA AREA (HW aligned)	###jhl

INTSAV	HS	4		:WORKING AREA FOR INTERNAL HOST PROCESSOR
	IF	EXPSEC
	HS	2		:ADDITIONAL TEMP STORAGE FOR INTHST
	EI 	:EXPSEC

INTTSV	WS	1
INTDWF	HS	1		:INTERNAL HOST DWL CHANNELS ARRAY
	SYAD(INTDWF)
INTOUT	HS	1		:INTERNAL HOST TIMEOUT ENABLE BIT ARRAY
SI1DBG	HS	1
SI2DBG	HS	1
INTUSE	HS	1		:INTERNAL HOST CHANNEL IN USE BIT ARRAY
	SYAD(INTUSE)
INTLST	HS	1		:WORKING AREA FOR INTERNAL HOST PROCESSOR
INTACT	HS	1		:INTERNAL HOST ACTIVE CHANNEL BIT ARRAY
INTWRN	HS	1		:INTERNAL HOST TIMEOUT WARNING BIT ARRAY
INT8MN	HS	1		:8-MINUTE CELL FOR INTTIM
INTXRF	HS	1		:INTERNAL HOST REMOTE XRAY CHANNEL BIT ARRAY
XUSIUA	HS	1		:XRAY USER SLOTS IN USE ARRAY
INTLPF	HS	1		:LOOPBACK TEST BIT ARRAY
	SYAD(INTLPF)

INTDSF	HS	1		:CRQ DELAY CHECK SOURCE CHANNEL BIT ARRAY
INTDRF	HS	1		:CRQ DELAY CHECK RECEIVING CHANNEL BIT ARRAY

XRYRUN	HS	1		:RUN FLAG FOR XRAY
XRYTTY	HS	1		:1 IF XRAY IN TTY MODE, 0 => NETWORK MODE

DWLCOU	HS	1		:THIS AND THE NEXT THREE LOCATIONS ARE FOR
	SYAD(DWLCOU)
DWLCLI	HS	1		:SPOTTING DWL PROBLEMS
DWLCIN	HS	1
DWLDSP	WS	2		:BIT ARRAY FOR SPEEDY DISPATCH OF DWL LINES
STDWDS	WS	2		:FOR STARLINE LOADS BOTH INDEXED BY 2*Line#
DWQUEU	HS	1		:DWL JOB QUEUE FOR DWLIN
DWTEST	HS	1		:SEMAPHORE BETWEEN LINKER AND DWLIN

DLYINT	HS	1		:INTERVAL (IN FASTC) BETWEEN TEST PACKETS

NETDCT	HS	2		:THROTTLE COUNTER FOR DIAGNOSTIC NODE REPORTS
NTDRET	HS	2		:SAVE LINK REGISTER FOR NETDGN

	WS	0		:WORKING STORAGE FOR CRQ
CQNBUF	HS	1		:NEEDLE BUFFER #

CQNLK	HS	1		:WORKING STORAGE FOR CRQ
GDNINV	WS	0		:Overlay invoice numbers
CQINV	WS	1		:INVOICE #
TSTSAV	WS	1		:###TESTING SAVE AREA
	IF	ACCT2
	HS	1		:Extra HW for Acct2 format
	EI	:ACCT2
	IF	ACCT
GASTOR	WS	1
	EI	:ACCT
CQNFLG	HS	1		:FLAGS
CQNODE	HS	1		:REQUESTING NODE
CQPORT	HS	1		:REQUESTING PORT
CQDHST	HS	1		:DESTINATION HOST IF INTERNAL CIRCUIT
CQTID	BS	1		:Originating TID (CCT)
	BS	1		:Could store User Flags if needed
CQONOD	HS	1		:TYMNET-I ORIGIN NODE
CQOCHN	HS	1		:DITTO CHANNEL
CQHOST	HS	1		:HOST # (DESTINATION NODE IF T-I)
CQDCHN	HS	1		:DESTINATION CHANNEL IF T-I

CQNSZ	HS	1
CQVSEQ	WS	1		:SEQN NUMBERS ARE NOW 32 BITS		###GT
	SYAD(CQVSEQ)
CQXSEQ	WS	1
	SYAD(CQXSEQ)

CRQARL	EQ	((NCIRCS+1F)/20)*4	:# BYTES IN CRQ BIT ARRAYS
CRQEND	WS	CRQARL/4	:EACH BIT REPRESENTS BUFFER PAIR, BIT SET FOR
	SYAD(CRQEND)		: CIRCUIT TERMINATION (INTERNAL OR T-1)
CRQBSY	WS	CRQARL/4	:EACH BIT REPRESENTS BUFFER PAIR, BIT SET FOR
	SYAD(CRQBSY)		: REBUILDABLE TERMINATION (NOT TPUT CLASS 3)
BURSAV	WS	1		:Register save area
REBTMO	WS	CRQARL/4	:CIRCUIT BUILDING TIMEOUT FLAGS
REBTMI	WS	CRQARL/4
	IF	REBILD
SQFIXV	WS	CRQARL/4	:SET IF REBILD QUAD EVER RECEIVED FOR THIS CRQ
SQFTMI	WS	CRQARL/4	:REBUILD TIMEOUT FLAGS			###GT
SQFTMO	WS	CRQARL/4
	EI 	:REBILD

CHNMPD	HS	NLINKS		:NODE NUMBERS FOR PROBE TRACE
CHNMAP	WS	NLINKS+4+SOLOCS+ISIS+SUPER+KERNEL :CHANNEL MAP FOR PROBE TRACE

	IF	SOLOCS
BEGZER	DFST.(WS,0,CSBASE)

LOWSPD	EQ	(1-BAUDR)
	EI 	:SOLOCS

	IF	ACCT!T2GATE
::	INTERNAL HOST ACCOUNTING PARAMETERS	###ev
::	DESCRIPTORS AND EQUATES
::	Accounting block descriptor per virtual circuit
Q	HS	0
	ORG	0
AAINV	HS	2		:Invoice number	
	IF	ACCT2
	HS  1			:expanded to 48 bits
	EI	:ACCT2
AAIC	HS	2		:Input character count
	IF	ACCT2
	HS  1			:with room to expand
	EI	:ACCT2
AAOC	HS	2		:Output character count
	IF	ACCT2
	HS  1			:with expansion
	EI	:ACCT2
AADSIZ	HS	0		:Size of block per circuit
	ORG	Q		: (in bytes)


::	Accounting logout and zap reason equates
AALR02	EQ	02		:Normal disconnect by host
AALR03	EQ	03		:Normal disconnect by user
AALR07	EQ	07		:Out of internal host ports
AALR11	EQ	11		:User-name rejected .. bad Xray username
AALR19	EQ	19		:Host rejected caller .. out of Xray slots
				:or invalid DWL or PLI Message Function
AALR24	EQ	24		:Circuit rejected as invalid .. bad control
				:character or bad Internal Host function
AALR25	EQ	25		:host not answering .. circuit timeout
AALR26	EQ	26		:Resource limit exceeded .. bumped by
				:higher status Xray user
	EI	:ACCT!T2GATE

::	ACCOUNTING VARIABLE PARAMETERS
::	Number of circuits to keep accounting for
	IF	T2GATE

	IF	INTACC		:Internal host accouting
NACCTS	EQ	TINTCH+NDP	:Internal host plus gateway ports
	ELSE	:NOT INTACC
NACCTS	EQ	NDP
	EI	:INTACC
	ELSE	:NOT T2GATE
	IF	ACCT
	IF	ISIS
NACCTS	EQ	TINTCH+NKU	:Internal Host ports plus Kernel ports
	ELSE	:NOT ISIS
NACCTS	EQ	TINTCH
	EI	:ISIS
	ELSE	:NOT ACCT
NACCTS	EQ	0
	EI	:ACCT

	EI	:T2GATE

::	STORAGE
	IF	T2GATE
AAREAS	WS	1		:Logout reason save area
AAR1SV	WS	1		:Return save
AAR2SV	WS	1		:Ditto
ININV	WS	1		:Store INET Invoice number for AASWAP
	EI	:T2GATE
::	Linear array to contain pointers to each accounting block
	IF	ACCT!T2GATE
AABPNT	WS	NACCTS		:Word address to each accounting block
AARGSV	WS	10		:Accounting routines register save area
AALINS	WS	1		:Last Invoice Number Sent save area
AA20MN	WS	1		:Timer count save area
AASVCT	WS	1		:Port counter for periodic report
::	end of accounting descriptions and parameter storage	###ev

	EI	:ACCT

	IF	T2GATE
::*********************************************************************
::
::	FUNCTION:	Data storage areas for gateway logon process
::*********************************************************************

::Bit arrays for Gateway ports
CCTTBL	BS	NDP		:Save area for CCT's for Gateway circuits
LOGING	WS	(NDP+1F)/20	:Ports marked when in Log-in mode
	SYAD(LOGING)
GDSTPT	WS	(NDP+1F)/20	:Ports marked as circuit destinations
GORGPT	WS	(NDP+1F)/20	:Ports marked as circuit origins
GTAUX	WS	(NDP+1F)/20	:Gateway circuits originated as Aux circuits
GIIXCT	WS	(NDP+1F)/20	:Circuits marked as IIX capable
GTTRNS	WS	(NDP+1F)/20	:Circuits originating as transparent log-ons
GTHDX	WS	(NDP+1F)/20	:Circuits originating from HDUX terminals
GTASCI	WS	(NDP+1F)/20	:Circuits determined as 2741 or 3767 origin
GTECHO	WS	(NDP+1F)/20	:Echo mask per port - primary Echo switch
GTLGEC	WS	(NDP+1F)/20	:Echo for log-on processing
GMSG0F	HS	0		:Companion array to mark log-on status
LOGDAT	WS	(NDP+1F)/20	:Ports with data for Log-in
GLGDAT	WS	(NDP+1F)/20	:Ports for more data log-in (B3)
::Storage areas for Gateway log-ins
GASAVE	WS	1		:Return save area
GDSAVE	WS	1		:Return save area
GESAVE	WS	1		:Return save area
GRSAVE	WS	1		:Return save area
GZSAVE	WS	1		:Return save area
GZAPSV	WS	1		:Return save area
GDPRD	HS	1		:Save area for Dispatcher ring pointer
GDDIAL	HS	1		:Saved from Needle - Dialect field
GDCCT	BS	1		:Saved from Needle - CCT field
GDUNSZ	BS	1		:Saved from Needle - Username size
GDSPED	BS	1		:From Needle - Speed bits ready in low nible
GDTPC	BS	1		:From Needle - Throughput class field
GDNLEN	BS	1		:From Needle - additional length of Needle
GDUSRF	HS	1		:From Needle - User Flags
GDFLGS	HS 	1		:From Needle - Needle Flags
GLGSTA	HS	1		:Log-on status storage
::Miscellaneous	Gateway variables and equates
DZLEN	WS	1		:Storage for message length reg	
UPDOWN	HS	1		:Storage for host status
GT.VER	EQ	((VERSION*4)&0FF00)!(REVLEV)
::Some equates
GAXTID	EQ	0CE		:Aux circuit TID (CCT) is '0E'
GXPRNT	EQ	0BF		:Test for transparent log-on is "?"
GLGTMR	EQ	$A120		:Log-on timer is two minutes

	EI	:T2GATE		:###ev

::*********************************************************************
::
::	ATTENTION FLAGS:
::
::*********************************************************************

	GL	BEGZRO,FLAGS,GOLOG,TOLOG,TOPORT
	IF	NMPVC
	GL	TOMPVC
	EI	:NMPVC

BEGZRO	WS	0
NFLAGS	WS	0
	SYAD(NFLAGS)
FLAGS	WS	0
CRQFLG	WS	1		:ALL SAVE LO-ORD BIT UNUSED
LEPFLG	HS	1		:LEPRECHAUN FLAGS
INTFLG	HS	1		:INTERNAL HOST FLAGS
ASYFLG	WS	(NPGRP+1)/2	:async port flags
TOPORT	EQ	ASYFLG
	IF	NMPVC
TOMPVC	WS	(NPGRP+1)/2	:for subports with data for pseudo port
	EI	:NMPVC
ALMFLG	WS	NANIPT/20	:ASYNC PORTS IN LOGIN MODE FLAGS
ANIFLG	WS	NANIPT/20	:INTERFACE FLAGS,NODE TO ASYNC PORTS IN LOGIN
GOLOG	WS	(NPGRP+1)/2	:data assembled for SNDLOG to pass to LOGGER
TOLOG	WS	(NPGRP+1)/2	:login data in .FTBUF for LGGO to investigate
KERFLG	WS	(NKU+1F)/20	:KERNEL PORT FLAGS (1/PORT)
SUPFLG	WS	NSP/20		:SUP FLAGS (1/PORT)
DISFLG	WS	(NDP+1F)/20	:DISPATCHER FLAGS (1/PORT)
LNKFLG	WS	TCHANS/20	:LINK CHANNEL ATTN FLAGS (1/CHAN)
ILCFLG	WS	1		:ILC FLAGS (1/LINK)
BPMFLG	WS	1		:BPM FLAGS (1/LINK)
DETFLG	WS	1		:DETACHED PORTS
ENDFLG	HS	0		:LAST FLAG ADDR+1

::*********************************************************************
::
::	aaaZFL:	Absolute channel numbers corresponding to processes'
::		relative channel 0.
::
::*********************************************************************

CRQZFL	EQ	(CRQFLG-NFLAGS)*8+1F	:CRQ.
STUBFL	EQ	CRQZFL-1		:Circuit stub in process of rebild.
INCPFL	EQ	STUBFL-1		:Circuits in intercept state (see CRQ)
EARLFL	EQ	INCPFL-1		:Early data from??? T-I z-flag.
ILCZFL	EQ	(ILCFLG-NFLAGS)*8	:Interlink control
BPMZFL	EQ	(BPMFLG-NFLAGS)*8	:Backpressure monitor
LEPZFL	EQ	(LEPFLG-NFLAGS)*8	:Leprechaun
KERZFL	EQ	(KERFLG-NFLAGS)*8	:Kernel
SUPZFL	EQ	(SUPFLG-NFLAGS)*8	:Supervisor
DISZFL	EQ	(DISFLG-NFLAGS)*8	:Dispatcher
	SYAD(DISZFL)
INTZFL	EQ	(INTFLG-NFLAGS)*8	:Internal host ports
LNKZFL	EQ	(LNKFLG-NFLAGS)*8	:Links
LNKLFL	EQ	LNKZFL+TCHANS	 	:Last link flag + 1
DETZFL	EQ	(DETFLG-NFLAGS)*8	:Detached ports
ASYZFL	EQ	(ASYFLG-NFLAGS)*8	:Async ports
ALMZFL	EQ	(ALMFLG-NFLAGS)*8	:Async login ports
ANIZFL	EQ	(ANIFLG-NFLAGS)*8	:Async login ports (node side)
GLGZFL	EQ	(GOLOG-NFLAGS)*8 	:GOLOG
TLGZFL	EQ	(TOLOG-NFLAGS)*8 	:TOLOG
	IF	NMPVC
TMPZFL	EQ	(TOMPVC-NFLAGS)*8	:TOMPVC
	EI	:NMPVC
ENDZFL	EQ	(ENDFLG-NFLAGS)*8	:Last flag +1

LOSEG0	HS	0	:END OF NODE CODE'S SHARE OF FIRST 16K OF SEG 0

::*********************************************************************
::
::	CSS0BG/CSS0ND:
::
::*********************************************************************

	IF	SOLOCS
CSS0BG	HS	0
CSS0ND	EQ	4000
	ORG	CSS0ND
	EI 	:SOLOCS

	SUBTTL	DATA (SEGMENT 0 - Data Areas)

	SEG.(0)			:DATA SEGMENT 0 RESUMES HERE

:	NOTE: DATA AREAS DEFINED FROM HERE CANNOT BE ASSUMED TO
:	BE RX1 ADDRESSABLE.

::*********************************************************************
::
::	SWITCH VARIABLES:
::
::*********************************************************************

:	ACP:	ACTIVE PORTS
:		ACtive-Port bit array, corresponds exactly to the node's
:		absolute channel numbers.  A set (1) bit means a port
:		(channel) is available.  A reset (0) bit means the channel
:		is in use.  Note that the negative portion of the ACP array
:		(from ACPBSE to ACP) is a mirror image of the positive
:		portion of ACP.  Negative ACP is used for top-down channel
:		assignment on T-II links on which we are the master.

ACPBSE	WS	0		:The bottom (lower limit) of negative ACP.
	SYAD(ACPBSE)
	WS	3		:DET, BPM, ILC
	WS	TCHANS/20	:NEGATIVE MIRROR OF LNKACP
EKNACP	WS	0		:End of link portion of negative ACP.
	WS	(NDP+1F)/20
	WS	NSP/20
	WS	(NKU+1F)/20
	IF	NEWALI
	WS	(NAPORT/20)*3	:ASYNC INTERFACE - ASY,ALM,ANI
	ELSE	:NOT NEWALI
	WS	(NPGRP+1)/2	:TOLOG
	WS	(NPGRP+1)/2	:GOLOG
	WS	(NANIPT+1F)/20	:ANI
	WS	(NANIPT+1F)/20	:ALM
	IF	NMPVC
	WS	(NPGRP+1)/2	:TOMPVC
	EI	:NMPVC
	WS	(NPGRP+1)/2	:ASY
	EI 	:NEWALI
	WS	2		:CRQ, LEP, INT HST
ACPSZN	EQ	.-ACPBSE	:Size of negative ACP (must = ACPSZP).

:	Why isn't ACP switched for NEWALI, too?  ###jhl

ACP	WS	0		:Start of positive ACP.
	SYAD(ACP   )
CRQACP	WS	1		:CRQ (unused).
LEPACP	HS	1		:Leprechaun.
INTACP	HS	1		:Internal host.
ASYACP	WS	(NPGRP+1)/2	:async ports, SIO, and MPVC pseudo-ports
	IF	NMPVC
TMPACP	WS	(NPGRP+1)/2	:MPVC sub-port to pseudo-port array
	EI	:NMPVC
ALMACP	WS	(NANIPT+1F)/20	:Login ports (async side).
ANIACP	WS	(NANIPT+1F)/20	:Login ports (node side).
GLGACP	WS	(NPGRP+1)/2
TLGACP	WS	(NPGRP+1)/2
KERACP	WS	(NKU+1F)/20	:Kernel
SUPACP	WS	NSP/20		:Supervisor
DISACP	WS	(NDP+1F)/20	:Dispatcher (ISIS only)
LNKACP	WS	TCHANS/20	:Link channels
ILCACP	WS	1		:Inter-link control (unused)
BPMACP	WS	1		:BPM??? (unused)
DETACP	WS	1		:Detached ports
ACPSZP	EQ	.-ACP		:Size of positive ACP (must = ACPSZN)

	IF	ACPSZN%ACPSZP
	REMARK	%!!ACP ALLOCATION ERROR!!%
	KILLER(1)		:kill assembly
	EI 	:ACPSZN%ACPSZP

:	CHS:	CHANNEL SUSPENDED ARRAY
:		CHannel-Suspended bit array.  Same structure as ACP
:		(positive and negative portions, a bit for each channel,
:		0-bit means channel suspended).  A channel is temporarily
:		suspended to allow a recent zapper to clear a circuit.
:		A link channel is considered available only if its ACP and
:		CHS bits are set.  SWITCH initialization expects CHS to
:		follow ACP.

CHSBSE	WS	0		:Bottom of negative CHS
	WS	3		:DET, BPM, ILC
	WS	TCHANS/20
EKNCHS	WS	0		:Top of links' negative CHS
	WS	(NDP+1F)/20
	WS	NSP/20
	WS	(NKU+1F)/20
	WS	(NPGRP+1)/2	:ASY
	IF	NMPVC
	WS	(NPGRP+1)/2	:TOMPVC
	EI	:NMPVC
	WS	(NANIPT+1F)/20	:ALM
	WS	(NANIPT+1F)/20	:ANI
	WS	(NPGRP+1)/2	:GOLOG
	WS	(NPGRP+1)/2	:TOLOG
	WS	2		:LEP, INTERNAL HOST
CHS	WS	0		:Beginning of positive CHS
	SYAD(CHS   )		:ORIGIN OF CHS ARRAY
	WS	2		:LEP, INTERNAL HOST
	HS	(NRPORT+0F)/10	:ASY
	IF	NMPVC
	HS	NRPORT/10	:TOMPVC
	EI	:NMPVC
	WS	(NANIPT+1F)/20	:ALM
	WS	(NANIPT+1F)/20	:ANI
	HS	(NRPORT+0F+BKMPVC)/10	:GOLOG
	HS	(NRPORT+0F+BKMPVC)/10	:TOLOG	###jhl
KERCHS	WS	(NKU+1F)/20	:KERNEL
	WS	NSP/20		:SUPERVISOR
	WS	(NDP+1F)/20	:DISPATCHER
LNKCHS	WS	TCHANS/20	:LINKS
	WS	3		:ILC, BPM, DET

:	CHS1, CHS2:
:		are used to cause a suspended channel (CHS) to become
:		available 30-60 seconds after a zapper has traveled.  When
:		CHS is reset, CHS1 is set.  Every 30 seconds, CHS2 is OR'd
:		into CHS and CHS1 is copied into CHS2.  Same layout as CHS.

	WS	0		:INSURE WORD ALIGNMENT
	BS	ACPSZP		:CORRESPOND TO NEGATIVE CHS
CHS1	HS	0		:Center (negative below here, positive above)
	BS	ACPSZP		:CORRESPOND TO POSITIVE CHS

	WS	0
	BS	ACPSZP
CHS2	HS	0		:Center (negative below here, positive above)
	BS	ACPSZP

:	DEFINE RINGS FOR NODE<-->ISIS DISPATCHER COMMUNICATIONS

	IF	ISIS
DIRING	WS	0		:Dispatcher input ring (node==>ISIS).
	SYAD(DIRING)		: Structure required by ISIS.
DRIF	HS	1		:Fill index (node indexed)
DRIE	HS	1		:Empty index (ISIS indexed)
DIRNG	BS	DRSZ		:The ring itself

DORING	WS	0		:Dispatcher output ring (ISIS==>node).
	SYAD(DORING)		: Structure required by ISIS.
DROF	HS	1		:Fill index (ISIS indexed)
DROE	HS	1		:Empty index (node indexed)
DORNG	BS	DRSZ		:The ring itself

DHSTIX	HS	NDP		:Host # associated with each Dispatcher port
	SYAD(DHSTIX)
	EI 	:ISIS

	IF	(1-NEWSYN)	:current ISIS&SYNC###wjl ##AL
	IF	STRHUB		:For STRHUB, the space allocated for link 
Q	EQ	0		:descriptors must be differentially assigned..
KDSC	BS	0		:..that is - a Starlink descriptor will be
	SYAD(KDSC  )
	RE	(NLINKS-1)	:larger than a normal link descriptor.  This
	IF	\K.S|$A Q|	:assembly time allocation checks K.S (Starlink
	BS	SKDSZ		:Keys) for each link.  If there is at least
	ELSE			:one defined then the link is a Starlink and
	BS	KDSZ		:a larger KD size will be allocated.
	EI
Q	EQ	Q+1
	ER
KDLST	EQ	.
	IF	\K.S|$A Q|	:K.S BASED ON RA DECIMAL
	BS	SKDSZ
	ELSE
	BS	KDSZ
	EI
	ELSE			:NON STAR HUB ALLOCATION
KDSC    BS      NLINKS*KDSZ	:Link descriptors
KDLST   EQ      KDSC+(NLINKS-1)*KDSZ :Address of last link descriptor
	EI	:STRHUB
	EI	:(1-NEWSYN)

CDSC	BS	NRECDS*CDSZ	:Packet record descriptors

DLYBSE	HS	DLYBSZ*TINTCH/2	:START OF DATA BLOCKS FOR DELAY MEASUREMENT

:	Internal host processor arrays

INTDSP	HS	TINTCH		:Dispatch vectors (less SEG1 offset)
INTUSR  WS      TINTCH		:Username save area
INTCHN	HS	1		:temp storage for INTHST channel number ###wjl
	IF	T2GATE
	IF	INTACC
MNACHN	EQ	INTZFL
	ELSE	:NOT INTACC
MNACHN	EQ	DISZFL		:Dispacher zero port flag
	EI	:INTACC
MXACHN	EQ	MNACHN+NACCTS	:Highest accountable  channel number
	ELSE	:NOT T2GATE
	IF	ACCT		:###EV
:	Accounting parameters  - Minimum and Maximum channel numbers
MNACHN	EQ	INTZFL		:INTZFL is always first accountable ch
MXACHN	EQ	MNACHN+NACCTS	:Highest accountable  channel number
	EI	:ACCT		###EV
	EI	:T2GATE

:	Downline load arrays, indexed by internal host channel number
	IF	STRHUB
DWLKDS	WS	TINTCH		:Starhub  array to store KD
	EI	:STRHUB
DWLNUM	HS	TINTCH		:Downline load line number (* 2)
DWLOPT	HS	TINTCH		:DWL output pointers
DWBUSY	HS	TINTCH		:DWL buffer busy flags

:	Data structures for buffer delay timer pairs
	IF	BFLTMR		:###JHL
BFDARY	WS	TCHANS/20	:a bit for each link channel
BFDEND	HS	0		:end marker for COPY instruction
BFDSCH	HS	1		:EXEC cell for scheduling from G08SEC
BFDFRQ	EQ	4		:# times G08SEC runs per sched of BFRUPD
BFDOPT	HS	1		:cell to select bfr timer use in XRAY
	EI	:BFLTMR		:###jhl

:	Delay measurement arrays, indexed by internal host channel number

CHNFIL	HS	TINTCH		:TABLE TELLS SOURCE ROUTN # OF FILL HW TO USE
CFLCNT	HS	TINTCH		:working FILL ch depletion array	###jhl
CHNDLY	HS	TINTCH		:INT HST CHAN # TO DELAY USER # PERMUTER TABLE
DLYCHN	HS	TINTCH/2	:DELAY USER # TO INT HOST CHANNEL # TABLE
INTNDX	HS	TINTCH		:DB-INDEX BY INTHST CHAN #
DB0USE	WS	1		:0 IF DLY CHN 0 NOT IN USE, ELSE XD OF USER
DB1USE	WS	1		:0 IF DLY CHN 1 NOT IN USE, ELSE XD OF USER
DB2USE	WS	1		:0 IF DLY CHN 2 NOT IN USE, ELSE XD OF USER
DB3USE	WS	1		:0 IF DLY CHN 3 NOT IN USE, ELSE XD OF USER
DB4USE	WS	1		:0 IF DLY CHN 4 NOT IN USE, ELSE XD OF USER
DB5USE	WS	1		:0 IF DLY CHN 5 NOT IN USE, ELSE XD OF USER
DB6USE	WS	1		:0 IF DLY CHN 6 NOT IN USE, ELSE XD OF USER
DB7USE	WS	1		:0 IF DLY CHN 7 NOT IN USE, ELSE XD OF USER

	IF (EXPSEC)
XUTMP	WS	3		:TEMP STORAGE FOR USERNAME VALIDATION
	EI 	:EXPSEC

:	Node performance statistics storage

TOTCHR	WS	1		:INPUT+OUTPUT LOGICAL CHARS FOR LAST MINUTE
NSCPSO	HS	1		:LAST MINUTE'S CPS OUT FOR NODE'S LINKS
NSCPSI	HS	1		:LAST MINUTE'S CPS IN FOR NODE'S LINK
NSCPHO	HS	1		:NODE'S CPS OUT HI-WATER MARK
NSCPHI	HS	1		:NODE'S CPS IN HI-WATER MARK
MTLTIM	HS	1		:LAST TIME LINK TRAFFIC MEASUREMENT WAS DONE
MTLFST	HS	1		:LIKE MTLTIM BUT IN FASTC UNITS
MTTINT	HS	1		:TIME INTERVAL BETWEEN TWO LINK TRAFFIC MEAS.

:	Physical addr of NS.PCO (PHPCPS) sent to ISIS in SVC SYS,$A 51
:	in NSTART if SPAM enabled.  Expects FW storage for NS.PCO and NS.PCI.
NS.PCO	WS	1		:last minute's Physical CPS Out		###wjl
NS.PCI	WS	1		:last minute's Physical CPS In		###wjl
NS.PHO	HS	1		:node's Physical CPS Out Hi-water mark	###wjl
NS.PHI	HS	1		:node's Physical CPS In Hi-water mark	###wjl
MTRSAV	WS	1		:register save area for MTRFIC routine	###wjl

BPMSAV	WS	10		:REGISTER SAVE AREA USED IN 'BPMV' (YAKYAK)

:	LINKER line descriptor arrays indexed by line number
:	NOTE:  ">name" corresponds to proposed new usage
NGSVLN	HS	NLINES		:LAST NEIGHBOR ON LINE			>L.NEIG
KDSVLN	WS	NLINES		:LINK TO WHICH LINE WAS LAST ATTACHED	>L.KDSV
DREASN	BS	NLINES		:REASON FOR DETACH 2= NO REC, 3= RESET	>L.DRSN
RREASN	BS	NLINES		:Reason for Reset **to be implemented**
RESETE	HS	NLINES		:RESET KEY FOR STEP E			>L.RSE
RESETF	HS	NLINES		:RESET KEY FOR STEP F			>L.RSF
BAUDRT	HS	NLINES		:LINE SPEEDS				>L.BRAT
LNRTIM	HS	NLINES		:FOR COMPUTING LINE SPEEDS		>L.RTIM
LNRPOS	HS	NLINES		:DITTO					>L.RPOS
LINTIM	WS	NLINES		:FOR EACH LINE, TIME OF LAST ATT/DET	>L.TIME
	IF	XRESET		:###wjl
LNETID	HS	NLINES		:NETID for each line
	EI	:XRESET

:	The following are for gathering statistics
KL.RRF	HS	NLINES		:REF COUNT AT END OF LAST MIN (RCTRNS)	>L.RRF
KL.RSV	HS	NLINES		:COUNT DURING LAST MINUTE (RCTRNS)	>L.RSV
LINERR	HS	NLINES		:LINE STATISTICS - NOISE		>L.ERR
SPACNG	HS	NLINES		:SPACING (ALL ZEROES) DETECTED ON INPUT	>L.SPAC
BADACK	HS	NLINES		:BAD ACKNOWLEDGEMENTS			>L.BACK
BADRCN	HS	NLINES		:BAD RECORD #'S				>L.BRNO
BADCSM	HS	NLINES		:BAD CHECKSUMS				>L.BCSM
RCRXMT	HS	NLINES		:RETRANSMISSIONS RECEIVED		>L.RTR
LXMSET	HS	NLINES		:NUMBER OF RETRANSMISSIONS CONSIDERED	>L.RTC
KL.LRF	HS	NLINES		:REF COUNT AT END OF LAST MIN (LXMSET)	>L.LRF
KL.LSV	HS	NLINES		:COUNT DURING LAST MINUTE (LXMSET)	>L.LSV
LCROSS	HS	NLINES		:CROSS-TALK ERRORS			>L.CROS
TRRXMT	HS	NLINES		:RETRANSMISSIONS SENT			>L.RTS
KL.TRF	HS	NLINES		:REF COUNT AT END OF LAST MIN (TRRXMT)	>L.TRF
KL.TSV	HS	NLINES		:COUNT DURING LAST MINUTE (TRRXMT)	>L.TSV

:	The following are sync-unique parameters
CONFSG	HS	NLINES		:# CONSECUTIVE 4-SEC GAPS WITH NO RECORDS RCVD
:	OVER TYMNET-I LINK (TAKE LINK OUT AFTER 16 SECONDS)		>L.CNSG
FOURSG	HS	NLINES		:TOT # 4-SEC GAPS WITH NO RECORDS RECEIVED
	IF	STRHUB		:STAR HUB PER STAR LINK ##AL
SCONFS	HS	NLINKS		:# CONSECUTIVE 4-SEC GAPS WITH NO RECORDS RCVD
SFOURS	HS	NLINKS		:TOT # 4-SEC GAPS WITH NO RECORDS RECEIVED
SRCTRS	HS	NLINKS		:NUMBER RECORDS TRANSMITTED FOR starlink
STRXMT	HS	NLINKS		:RETRANSMISSIONS SENT FOR strlink ##AL
	EI	:STRHUB
:	OVER TYMNET-I LINK (FOR STATISTICS)				>L.FRSG
	IF	XRESET		:###wjl
SYLLNK	WS	NLINES		:save return for SYLXRS
	EI	:XRESET
	
	IF	XRESET		:###wjl
XRSTBT	HS	(NLINES+7)/8	:bit array - index by LN*2 and (LN*2)+1
	EI	:XRESET

	IF	ISIS
ROTOR	HS	2*6*(NLINES-SILINS)	:ROTOR FOR SYNC LINE COMMANDS TO
					: RAISE RTS AND DTR BEFORE CONNECTING
	EI 	:ISIS
:::
	IF	APLYBP
APBPVD	WS	TCHANS/20	:RECEIVED APPLY BACK-PRESSURE FOR CHANNEL
	EI	:APLYBP
LNKBPV	WS	TCHANS/20	:RCVD BACK-PRESSURE RELIEF (ENABLE SERVICE)
BPSVCP	WS	TCHANS/20	:COPY OF RECEIVED BP FLAGS (UPDATE T-PUT COUNT)
CHSRVD	WS	TCHANS/20	:CHANNEL SERVICED FLAGS (1/CHAN)
PRIRTY	WS	TCHANS/20	:PRIORITY FLAGS
CMDCTS	WS	TCHANS/20	:COMMAND CIRCUITS
GUSH	WS	TCHANS/20	:SET FOR CHANNELS WITH DATA GUSHING IN
TRIKLE	WS	TCHANS/20	:SET FOR CHANNELS WITH DATA TRICKLING
EGUSH	EQ	GUSH+TCHANS/8
ETRIKL	EQ	TRIKLE+TCHANS/8

:	Misc. bit arrays indexed by channel number

TRCHAN	HS	ENDZFL/10	:ARRAY FOR CHARACTER TRACING BY CHANNEL
NEEDLE	HS	TCHANS/10	:ARRAY TO RECORD NEW NEEDLE ON LINK CHANNEL

	IF	SIORNG
DWSISV	HS	6		:CONTEXT SAVE FOR SIO DLD DISMISS
	EI 	:SIORNG

	IF	DB.TSN
LSNPSV	HS	40		:SAVE LINK SNIP PACKET HERE
	SYAD(LSNPSV)

:	ALLOCATE AREA FOR TSN TO STORE PACKETS WHEN LINK GOES OUT
TSNISV	HS	0		:SAVE INPUT PACKETS
	SYAD(TSNISV)
	BS	80*10		:CAN SAVE UP TO 10 PACKETS

TSNOSV	HS	0		:SAVE OUTPUT PACKETS
	SYAD(TSNOSV)
	BS	80*10
	EI 	:DB.TSN

:	DEFINE WORK AREAS ASSOCIATED WITH NEEDLE TIMING
	DEFAULT(NEDTSZ,RATE/4)	:DEFAULT SIZE OF NEEDLE TIME HISTOGRAM - ALLOW
				: FOR UP TO 1 SECOND, RECORDED IN FASTC/4 UNITS
NEDHST	HS	NEDTSZ/2	:NEEDLE TIME HISTOGRAM

	IF	KERNEL
KERUSR	BS	40		:USER NAME STRING OF LAST KERNEL LOGIN
	EI 	:KERNEL


:	HISTOGRAMS TO RECORD DISMISS AND EXEC LOOP TIMES.

EXEHSZ	EQ	80		:NUMBER OF BYTES IN EXEC DISMISS AND EXEC LOOP
				: HISTOGRAMS. NUMBER OF ENTRIES IS EXEHSZ/4
				: FULLWORD COUNTERS, RECORDS IN FASTC/4 UNITS.
EXDHGM	WS	EXEHSZ/4	:DISMISS TIME HISTOGRAM
EXEHGM	WS	EXEHSZ/4	:EXEC LOOP TIME HISTOGRAM

SYLHSZ	EQ	80		:NUMBER OF BYTES IN SYLVER INTERVAL HISTOGRAM.
				: NUMBER OF ENTRIES IS SYLHSZ/4, RECORDS IN
				: FASTC UNITS.
SYLHGM	WS	SYLHSZ/4	:RECORDS DISTRIBUTION OF TIME INTERVALS
				: BETWEEN SYLVER EXECUTIONS.

	IF	ZITEL		:FOR ZITEL TRACE/STOP FUNCTION

:	for semi-conductor memory error log (see MCHECK in LINKER)
NMTRC	EQ	10
MEMIN	HC	0
MEMTRC	HS	4*NMTRC

:	VARIABLES FOR ZITEL TRACE/STOP FUNCTION

TRCFLG	HS	1		:set by interrupt routine when sprung
TRCUSE	HS	1		:holds owner's XD
NSTRCN	EQ	20		:32 STOPTRACE TABLE ENTRIES
STPWFG	HS	1		:STOPTRACE TABLE WRAP FLAG ,-1 IF WRAP
LOGTRC	HS	1		:STOPTRACE FLAG, -1 IF STOPTRACE
LOGTRI	HS	1		:STOPTRACE TABLE INDEX (1 - NSTRCN)
STRRGS	WS	1		:TEMP STORAGE FOR REG USED AS INDEX WHILE
				:STORING REG F REGGIES.
MTRGTM	WS	1*NSTRCN	:holds time of trace trigger
TSPSW	WS	2*NSTRCN	:holds PSW from time of trace interrupt
	IF	MEMMON
TRCREG	WS	10*NSTRCN	:save set F regs from MAC int time
	ELSE	:MEMMON
TRCREG	WS	10		:save set F regs from MAC int time
	EI	:MEMMON
STPSAV	HS	1*NSTRCN	:save offset of stop condition
TRMSKS	HS	1*NSTRCN	:save user-specified trace mask
	IF	(1F-NSTRCN)	:MUST BE AT LEAST 32 FOR TRACE BUFFER USE
TRCSV	WS	1*NSTRCN	:save 32 trace buffer addresses OR
				:HOLD CONSECUTIVE STOP ADDRESS HITS
	ELSE	:(1F-NSTRCN)
TRCSV	WS	1*20
	EI	:(1F-NSTRCN)

LSTFSV	WS	3		:save last fetch and parity error addresses
TRINCT	HS	1		:count number of trace interrupts
BDTRNT	HS	1		:count bad trace interrupts
TROVRN	HS	1		:count new int before old one output
STPNMB	HS	1		:trggr occ to spring on
HLTOST	HS	1		:zero if "halt on trc int"

	EI	:ZITEL

:	VARIABLES FOR TEMPERATURE REPORTING--RANGES AND DELAY TIME.	###JHL
TMCHFG	HS	1		:FLAG TO DISABLE TEMP CHECK (NON-0 IS OFF)
INHTMP	HS	1		:FLAG FOR INHIBITING TEMP RPTING TO 1/HR
	SYAD(TMCHFG)		:LET USER FIND FLAG TO SET IT		###JHL

:	DATA AREAS FOR GMT ROUTINES
CYRCOD	HS	1		:=0 IF CURRENT YEAR IS LEAPYR,ELSE 1,2,OR 3
GMTSLC	WS	1		:SLOWC TIME AT TIME WE GOT BASE GMT
GMTHEX	WS	1		:BASE GMT SEC'S INTO CURRENT YEAR CORRESPONDS
				:TO GMTSLC + 1DAY
GMTNOW	WS	1		:CURRENT GMT
CYRMAX	WS	1		:NO. SEC'S IN CURRENT YEAR + 1 DAY
GETGMT	HS	1		:FLAG WHETHER TO GET GMT FROM SUP (ONLY IF
				:=0), IE ONLY AFTER CRASH/TAKEOVER.
NODSLC	WS	1		:SLOWC AT STARTUP
XYSAVE	WS	1		:SAVE AREA FOR CRYPTO/GMTCAL
SUPTIM	WS	1		:RAW GMT FROM SUP
SUPSLC	WS	1		:SLOWC EQUIVALENT OF SUPTIM

CNTXOR	HS	1		:FOR COUNT0/1 IN XRAY.
	if	1-alhub
XUBLK	BS	XUBSZ*NXUBLK	:XRAY USER BLOCK AREA
	SYAD(XUBLK )
	ei
XQUEC	HS	1		:CURRENT XRAY USER QUEUE
XQUEM	HS	1		:MASTER XRAY USER QUEUE
XNINT	BS	10		:XRAY USER SLOT NO. BY INTERNAL HOST PORT NO.

BFZPRS	HS	20		:REG SAVE AREA FOR BUFFER ZAP ROUTINE (BUFZAP)

::*********************************************************************
::
::	XRAY VARIABLES:
::
::*********************************************************************

BFLTHS	HS	10
BFLTHG	WS	10		:BUFFERLET USE HISTOGRAMS
BZAPCT	HS	1		:COUNT OF BUFFER ZAPS

XBREAK	HS	1		:PREVENTS TTY BEING SWAMPED BY RUNAWAY CRYPTO

	IF	WHEREE
WHTABL	HS	WHTSIZ
WHTABS	HS	WHTSIZ
WHESEM	HS	1
WHSEM2	HS	1
	EI 	:WHEREE

EXPSSV	HS	1		:SAVE AREA FOR EXEPSW FOR TR COMMAND

	IF	STRHUB
LNERFL	BS	1		:FLAG FOR STARLINE ERROR DISPLAY 	###AL
SLFLAG	BS	1		:SET FLAG IF 'SL' CMD INSTEAD OF 'ND'	###AL
	EI	:STRHUB

	IF	ISIS

        IF      SDW.TR          :do swedel isis traps

:	STORAGE AREA FOR ISIS-STYLE TRAPS
        IF      1-\NTRAP
NTRAP   EQ      4
        EI

        WS      0
TRPREG	WS	10*NTRAP	:SAVE AREA FOR TRAP REGISTERS
TRPPSW	WS	2		:how to return from a sprung trap
TRPADR	WS	NTRAP		:FOR TRAP PC
TRPXD	WS	NTRAP		:TRAP OWNER
TRPSAV	WS	2*NTRAP		:FOR CLOBBERED MEMORY
TRPTIM  WS      NTRAP           :time of trap springing
TRPCNT  HS      NTRAP           :how many springs left
TRPFLG	HS	1		:AND FOR TRAP SPRUNG INDICATION

        ELSE            :sdw.tr
:	STORAGE AREA FOR ISIS-STYLE TRAPS

TRPREG	WS	10		:SAVE AREA FOR TRAP REGISTERS
TRPPSW	WS	1		:FOR TRAP PSW
TRPADR	WS	1		:FOR TRAP PC
TRPXD	WS	1		:TRAP OWNER
TRPSAV	HS	3		:FOR CLOBBERED MEMORY
TRPFLG	HS	1		:AND FOR TRAP SPRUNG INDICATION

        EI      :sdw.tr

	EI 	:ISIS

XPWRCT	HS	1		:TIMEOUT CELL FOR ACCESS CONTROL

	IF	1-ISIS		:###wjl
XDSAVE	HS	1		:XD storage for SN command
	EI	:1-ISIS

	IF	EXPNDL
SNFGSV	WS	1		:holds ptr to B6-hdr for DSINDY
	EI	:EXPNDL

::*********************************************************************
::
::	SOLO CONSAT VARIABLES:
::
::*********************************************************************

	IF	SOLOCS		:SOLO CONSAT DATA AREA (SEG 0)
ASYAVE	HS	1		:SAVE AREA FOR AVERAGE ASYNC TIME
CSNEXT	HS	2		:ADDRESS OF NEXT PROCESS FOR CSDISM
CS16MN	HS	1		:16-MINUTE COUNTER FOR MPVC
FASTCH	HS	2		:ASYNC TIME HWM
ASYNXT	HS	1		:NEXT AVAILABLE LOGIN CHANNEL NUMBER
DSOLGH	HS	2		:FOR LOGCHR - SAVES HOST# AND tid
DSOSPC	HS	2		:CONTROL CHAR ARRAY FOR LOGCHR
RPOLSV	HS	2		:REGGIE SAVE AREA
ASYCNT	HS	1		:COUNT OF ASYNC EXECUTIONS
ALOCNT	HS	1		:COUNT OF NEEDLE EYES RECEIVED
LOGSTB	WS	(NANIPT+1F)/20	:bit array for hung ports in login mode	###jhl
IZITUP	HS	NPORT		:COUNT OF TIMES A PORT HAS BEEN UP
ASYLNK	BS	NPORT		:LINK COUNT FOR LAST CIRCUIT TO PORT
	IF	TELEX
SAVRET	HS	2		:SAVE RETURN FOR TELEX
	EI	:TELEX
EXCTST	HS	1		:???
FASTCX	HS	2		:LAST TIME AT TOP OF POLLING LOOP
QSECC	HS	2		:COUNT OF QUARTER SECOND EXECS
CTASYI	HS	2		:ASYNC INPUT CHAR COUNT
CTASYO	HS	2		:ASYNC OUTPUT CHAR COUNT
	IF	NUMPRN
CTPRNO	HS	2
NSPRNO	HS	1
NSPRHO	HS	1
	EI	:NUMPRN
CTASBK	HS	1
NSASYO	HS	1
NSASYI	HS	1
NSASHO	HS	1
NSASHI	HS	1
	EI 	:SOLOCS

DBCRSV	WS	2


ENDSG0	HS	0

	SUBTTL	DATA (SEGMENTS 2 & 3 - Buffer Descriptors)

::*********************************************************************
::
::	SEGMENT 2 & 3 - Buffer Descriptors, DMA Region, and Link Tables
::
::*********************************************************************

	SEG.(2)
SEG2	HS	0
	IF	(1-NEWSYN)	:current ISIS&SYNC###wjl ##AL
RECBUF  BS      NRECDS*RECBSZ   :ISIS WANTS RECBUF AT BEGINNING OF SEG2
	EI	:(1-NEWSYN)
CRQBUF	EQ	0		:CRQ LIST BUFFER
LOGBUF	EQ	4		:LOGGER DITTO
NCCBUF	EQ	8		:TEMPORARY BUFFER WHEN NO COMMAND CIRCUIT
ILCZBF	EQ	10		:# OF ILC BUFF FOR LINK 0
BPMZBF	EQ	ILCZBF+8*NLINKS	:# OF BPM BUFF FOR SAME
CIRZBF	EQ	BPMZBF+8*NLINKS	:# OF FIRST AVAILABLE BUFFER
HBUFN	EQ	8*NCIRCS	:NUMBER OF FIRST HISTORY BUFFER
	SYAD(HBUFN )
LBUFN	EQ	0C*NCIRCS	:LAST LEGAL BUFF # (PLUS 4)

:	CHARACTER BUFFERS:
:	IF CONFIGURATION HAS REBILD ENABLED, THE NUMBER OF BUFFERS REQUIRED
:	IS 3*NCIRCS. IF REBILD = 0, ONLY 2*NCIRCS BUFFERS REQUIRED.

	IF	REBILD
BUFFAC	EQ	3
	ELSE	:NOT REBILD
BUFFAC	EQ	2
	EI 	:REBILD

BB	WS	BUFFAC*NCIRCS	:NEXT CHARACTER OUT PTR
	SYAD(BB    )
BE	WS	BUFFAC*NCIRCS	:LAST CHARACTER IN PTR
	SYAD(BE    )
BBSIZE  EQ      BE-BB
BF	WS	BUFFAC*NCIRCS	:ATTENTION FLAG POINTER
	SYAD(BF    )
BCT	EQ	BF+2		:BYTE COUNT (INTERLEAVED W/ BF)

BUFTIM	WS	NCIRCS		:USED TO TIME NEEDLES IN FASTC UNITS. WHEN
:	NEEDLE COMPLETES CIRCUIT BUILDING, BUFTIM WILL CONTAIN SLOWC
:	TIME THAT CIRCUIT BUILDING WAS COMPLETED. ALSO USED TO TIME
:	OUT PORTS IN LOGIN THAT HAVE SENT FROM TID UP TO BUT NOT
:	INCLUDING SEMI-: OR 'CR'.  AFTER THAT THE SUP TIMES THEM OUT.
:	ALSO USED TO TIME OUT DETACHED PORTS DUE TO OUR DISCOVERY OF
:	'OUT OF DISPATCHER PORTS', ...

	IF	NEWSYN	:(NOT ISIS) OR (ISIS AND NOT SYNC)###wjl ##AL
RECBUF  BS      NRECDS*RECBSZ   :ISIS WANTS RECBUF AT BEGINNING OF SEG2
	SYAD(RECBUF)		:###wjl
	EI	:NEWSYN###wjl	###LSH

::*********************************************************************
::
::	Define the DMA region for SIO mother board interface.
::	To support more SIO lines, the DMA region is relocated 
::	from seg 0 (FIN module) to seg 2 here if switch 
::	SIBFRL is turned on. ###LSH
::
::	***********	NOTE	***********
::	Both of SIO DMA regions defined here and defined in FIN must be
::	the same.  Any change to them must be the same.
::	
::
::*********************************************************************
        IF      SILINS
	IF	SIBFRL		:SIO BUFFERS RELOCATION		###LSH

        BND     20              :QUAD WORD BOUNDARY
:	>>NOTE--FOLLOWING MUST NOT CROSS 100 BOUNDARY<<
SIOIPG  WS      8               :7 CCWS FOR HDLC INITIALIZATION
SIODUM  WS      4               :WILL CONTAIN DUMMY RECORD
	IF	STRHUB		:###LSH
STRDUM	WS	4		:WILL CONTAIN DUMMY RECORD FOR STARLINE
	EI	:STRHUB		:###LSH
	IF	RBTHUB		:###AL
STRRBT	WS	4		:WILL CONTAIN RMT-BOOT RECORD FOR STARLINE
STRRRS	WS	4		:WILL CONTAIN RMT-RESTART RECORD FOR STARLINE
	EI	:RBTHUB		:###AL
	IF	NAKCOD		:STRHUB!STRRMT
SIONAK	WS	4		:PUT IN QUAD STORAGE ANYWAY ##AL
	EI	:NAK 
SIOBLK  WS      8*SILINS        :CCW PAIR FOR OUTPUT
SIOBLI  WS      4*SILINS        :CCW FOR INPUT
	IF	XRESET		:###wjl
SIOBLR	WS	0C*SILINS	:for Expanded Reset
	ELSE
SIOBLR  WS      4*SILINS        :CCW FOR RESET
	EI	:XRESET
SIOSTT  WS      4*SILINS	:STATUS BLOCKS
SIDWCM	BS	10*SILINS	:SIO DWL CCW AREA
SIDWBF	BS	80*SILINS	:SIO DWL OUTPUT BUFFERS
SIOBLO  BS      90*2*SILINS  	:OUTPUT BUFFERS
	IF	STRHUB			
SIBUF	BS	(SIBFSZ+20)*SILINS	:INPUT BUFFERS	###LSH
	ELSE
SIBUF	BS	SIBFSZ*SILINS		:INPUT BUFFERS
	EI	:STRHUB
	SYAD(SIBUF )
	IF	DB56KB		:###LSH
	BND	20
SSTSAV	WS	4*SILINS	:ANOTHER SIO STATUS QUERY SAVE AREA
	EI	:DB56KB		:###LSH
SIOXQW	WS	4		:SIO MOTHER BOARD NEEDS EXTRA QUAD WORD###LSH
SIOEND	EQ	.		:END OF SIO DMA AREA
SIOKLG  EQ      SIOBLO^0C+SIOBLO/10     :KLUDGE TO HELP DUMB ASSEMBLER###LSH
					:BOTH OF LW AND HI HALF WD CONTAIN
					:QUAD ADDRESS OF SIOBLO ###LSH
	EI	:SIBFRL			:###LSH
	EI	:SILINS			:###LSH

	IF	NEWSYN		:(NOT ISIS) OR (ISIS AND NOT SYNC)	###wjl
	IF	STRHUB		:For STRHUB, the space allocated for link
Q	EQ	0		:descriptors must be differentially assigned..
KDSC	BS	0		:..that is - a Starlink descriptor will be
	SYAD(KDSC  )
	RE	(NLINKS-1)	:larger than a normal link descriptor.  This
	IF	\K.S|$A Q|		:assembly time allocation checks K.S (Starlink
	BS	SKDSZ		:Keys) for each link.  If there is at least
	ELSE			:one defined then the link is a Starlink and
	BS	KDSZ		:a larger KD size will be allocated.
	EI
Q	EQ	Q+1
	ER
KDLST	EQ	.
	IF	\K.S|$A Q|
	BS	SKDSZ
	ELSE
	BS	KDSZ
	EI
	ELSE			:NON STAR HUB ALLOCATION
KDSC	BS	NLINKS*KDSZ		:LINK DESCRIPTORS
	SYAD(KDSC  )			:###wjl
KDLST	EQ	KDSC+(NLINKS-1)*KDSZ	:ADDR OF LAST LINK DESCRIPTOR
	EI	:STRHUB
	EI	:NEWSYN###wjl


KNNLAT	HS	NLINKS			:USED BY LNCHCK TO DETERMINE MAX NUMBER
					:OF LINES PER LINK TO DETACH
PRICNT	HS	NLINKS			:COUNTERS FOR PRIORITY CHANNEL LOGIC
NRMCNT	HS	NLINKS			:MORE COUNTERS
RTPAGE	HS	NLINKS			:CHANNEL PAGE #'S
RMPAGE	HS	NLINKS
LKOVLD	HS	NLINKS			:LINK OVERLOAD COUNTERS
LKSTCT	HS	NLINKS			:LINK SATURATED COUNTERS
SNPTYP	HS	NLINKS			:LINK SNIP TYPE IF NON-ZERO
MASTKN	BS	NLINKS			:MASTER/SLAVE INDICATOR FOR T-II LINKS
LKZFKN	HS	NLINKS			:# OF CHANNEL 0 FLAG FOR EACH LINK
	SYAD(LKZFKN)
TBDPKN	HS	NLINKS+1		:START OF TABLES FOR EACH LINK (EXTRA
					:ONE NEEDED BY BUBBLE)
EBDPKN	HS	NLINKS			:END OF TABLES FOR EACH LINK
FLDPKN	HS	NLINKS			:START OF FLAGS FOR EACH LINK
LKFGND	HS	NLINKS			:PTR TO LAST HW OF ATTN FLAGS FOR LINK
LKSVND	HS	NLINKS			:PTR TO LAST HW OF SERVICE ARRAY
LKBPND	HS	NLINKS			:PTR TO LAST HW OF BACKPRESSURE ARRAY
LKAPND	HS	NLINKS			:PTR TO LAST HW OF ACTIVE PORT ARRAY
LKCSND	HS	NLINKS			:PTR TO LAST HW IN CHAN SUSP ARRAY
NUMPAG	HS	1			:NUMBER OF AVAILABLE HALF PAGES
LKNEDS	HS	NLINKS			:NO. OF TIMES NEEDLE GOBBLED BY ZAPPER

	IF	REBILD
:
:	NOTE THAT THERE IS ONLY A SINGLE 'SEQN' ARRAY, AND THE 'XSEQN',
:	'VSEQN' AND 'HSEQN' REDEFINITIONS ARE ONLY TO AVOID CONFUSION.
:
:	ALSO NOTE THAT SEQN IS A FULL-WORD ARRAY, SINCE BUFFER-NUMBERS
:	ARE DIVISIBLE BY 4. HOWEVER, NO GOOD USE HAS BEEN FOUND FOR THE UPPER
:	HW SINCE SEQUENCE NUMBERS ARE HW VALUES. THIS STORAGE COULD BE
:	COMPRESSED AT THE EXPENSE OF FREQUENTLY DIVIDING BUFFER NUMBER BY 2 AND
:	THEN RESTORING.
SEQN	WS	3*NCIRCS	:CHARACTER SEQUENCE #
	SYAD(SEQN  )
XSEQN	EQ	SEQN		:REDEFINITION - XMITTED SEQUENCE NUMBER
VSEQN	EQ	SEQN		:REDEFINITION - RECEIVED SEQUENCE NUMBER
HSEQN	EQ	SEQN		:REDEFINITION - HISTORY BUFFER SEQ NUMBER
HBSEQN	EQ	HSEQN+HBUFN	:CONVENIENCE CONSTANT
XBF	EQ	6
HBF	EQ	7		:R6,R7 USED IN CRQREB, CRQINT CODE
				: SPLIT ACROSS BUFFERLET

:	REBUILDABLE TERMINATION VARIABLES:

RBASE	EQ	.-HBUFN		:DESTINATION BASE
	SYAD(RBASE )
RHOSTN	EQ	RBASE+2		:DESTINATION HOST
	SYAD(RHOSTN)
	WS	NCIRCS
RNFLAG	EQ	.-HBUFN		:NEEDLE FLAGS
	SYAD(RNFLAG)
RHBSZ	EQ	RNFLAG+2	:SIZE OF HISTORY BUFFER
	SYAD(RHBSZ )
	WS	NCIRCS
RINVC	EQ	.-HBUFN		:INVOICE NUMBER INDEXED BY BUFFER NUMBER
	WS	NCIRCS

RBIBUF	EQ	RBASE		:TEMPORARY USE BY CRQREB
	SYAD(RBIBUF)
RBVSEQ	EQ	RINVC		:					###GT
	SYAD(RBVSEQ)
RBHIS	EQ	RHOSTN		:HIST BFR ASSOCIATED WITH RBIBUF	###CY
	SYAD(RBHIS )
RBKEY	EQ	HSEQN		:INVOICE ASSOCIATED WTIH RBIBUF		###CY
	SYAD(RBKEY )
	EI 	:REBILD

	IF	NOSEG
	IF	ISIS
::QQQ     EQ      .-SEG2
:	IF	(QQQ-20000)
:	REMARK	%%!!!!!NOT ENOUGH BUFFER SPACE!!!!!%%
:	KILLER(1)
:	EI	 :QQQ-20000
:	IF	(QQQ-10000)
	IF	1-SUPER
::S2SIZE  EQ      10000
:S3SIZE  EQ      QQQ-10000
:	ELSE
:S2SIZE  EQ      QQQ
:S3SIZE  EQ      0
:	EI	 :QQQ
::S3SIZE	EQ	10000		
	EI	:1-SUPER##AL
	EI	:ISIS##AL
	ELSE	:NOT NOSEG
QQQ     EQ      .-SEG2
	IF	(QQQ-20000)
	REMARK	%%!!!!!NOT ENOUGH BUFFER SPACE!!!!!%%
	KILLER(1)
	EI	 :QQQ-20000
	IF	(QQQ-10000)
S2SIZE  EQ      10000
S3SIZE  EQ      QQQ-10000
	ELSE
S2SIZE  EQ      QQQ
S3SIZE  EQ      0
	EI	 :QQQ
	EI	:NOSEG##AL

	SUBTTL	DATA (SEGMENT 4 - Solo CONSAT or KERNEL Communications)

::*********************************************************************
::
::	SEGMENT 4 - Solo CONSAT Area
::		    KERNEL Communication Area
::
::*********************************************************************

	IF	NOSEG		:take out segment limitatn		##al
	IF	ISIS 
:	SEG.(4)
:	ORG	40000
SEG4	HS	0
	EI	:ISIS##AL
	IF	SUPER
        IF      SIORNG
        SEG     0C              :solo supe must map logical seg 4 and 5 to
                                :to physical address KIOAR              ###sdw
        ORG     0C0000
       EI       :split supe
SEG4	HS	0
	EI	:SUPER##AL
	ELSE	:NOT NOSEG
	SEG.(4)
	ORG	40000
SEG4	HS	0
	EI	:NOSEG	##al

:	SOLO CONSAT AREA

	IF	SOLOCS

:	Now define the space for the port descriptors

PTBASE	WS	0			: The base address for this stuff

.PTABL	DFST.(HS,(NPORT*.PTLEN/2),CSBASE)

	EI 	:SOLOCS

:	KERNEL COMMUNICATION AREA

KBASE	WS	0			: The base address for this stuff###wjl

:	Supervisor Kernel

	IF	RKERNL

	IF	KNRING		:ALSO IF RKERNL
	IF	SIORNG		:AND IF KNRING
SIRGNF	EQ	4		:TWO POINTERS PER RING
	ELSE	:NOT SIORNG, AND IF KNRING
SIRGNF	EQ	6		:THREE POINTERS PER RING
	EI	:(NOT)SIORNG

:	KERNEL INTERFACE RING SET UP FOR NEGATIVE INDEXING

KBSZ	EQ	$A256		:DATA SIZE OF KIB AND KOB
KIB	BS	(KBSZ+SIRGNF)*NKU :SPACE FOR BUFFER, NII, NOI & NMI
KOB	BS	(KBSZ+SIRGNF)*NKU :SPACE FOR BUFFER, NIO, NOO & SPARE
	SYAD(KOB   )
KCNTLS	EQ	NKU*4+2		:DATA SIZE FOR KCNTLI AND KCNTLO
	BS	KCNTLS+4	:SPACE FOR CONTROL INPUT BUF & INDECIES
KCNTLI	BS	0
	SYAD(KCNTLI)
	BS	KCNTLS+4	:SPACE FOR CONTROL OUTPUT BUF & INDECIES
KCNTLO	BS	0
	SYAD(KCNTLO)
KOFSIZ	EQ	8		:DATA SPACE FOR KOF
	BS	KOFSIZ+4	:2 32 BIT ARRAYS & 2 PTRS
KOF	BS	0
	SYAD(KOF   )
NLOGSZ	EQ	4		:DATA SPACE FOR NEW LOG
	BS	NLOGSZ+4	:2 HALF WORD ENTRIES & 2 PTRS
NEWLOG	BS	0
	SYAD(NEWLOG)

:	KBTBL IN SEG1 FOR SIO RING INTERFACE, OTHERWISE IN SHARED MEMORY
	IF	(1-SIORNG)	:AND IF KNRING
KBNO	EQ	KBSZ+SIRGNF	:INIT TO SET UP TABLE FOR KIB & KOB
KBTBL	HS	0		:TABLE OF OFFSETS INTO KIB & KOB
	RE	NKU
	HC	KBNO
KBNO	EQ	KBNO+KBSZ+SIRGNF
	ER
	EI 	:1-SIORNG

NII	EQ	KIB-SIRGNF	:OFFSET FROM END OF KIB TO NII
NOI	EQ	KIB-(SIRGNF-2)	:OFFSET FROM END OF KIB TO NOI
NMI	EQ	KIB-(SIRGNF-4)	:OFFSET FROM END OF KIB TO NMI
NIO	EQ	KOB-SIRGNF	:OFFSET FROM END OF KOB TO NIO
NOO	EQ	KOB-(SIRGNF-2)	:OFFSET FROM END OF KOB TO NOO

	ELSE	:NOT KNRING AND IF RKERNL
KBSZL	EQ	6		:LOG2 OF KERNEL BUFFER SIZE
KBSZ	EQ	1^KBSZL		:SIZE OF KERNEL BUFFERS
KIB	BS	NKU*KBSZ	:KERNEL PORT INPUT BUFFERS
KOB	BS	NKU*KBSZ	:DITTO OUTPUT
	SYAD(KOB   )
NII	HS	NKU		:IN BUFF IN PTR
NMI	HS	NKU		:BETWEEN NII AND NIO
NOI	HS	NKU		:INBUFFER OUT PTR
NIO	HS	NKU		:OUTPUT BUFFER IN PTR
NOO	HS	NKU		:DITTO OUT PTR
KOF	WS	(NKU+1F)/20	:PORTS THAT HAVE CHARS FOR OUTPUT
NEWLOG	WS	(NKU+1F)/20	:NEW LOGIN FLAGS (1/PORT)
	SYAD(NEWLOG)

KQ	EQ	1		:POINTER OFFSET, DIFFERENT FOR ISIS
KBST	EQ	2*KBSZ-1	:FOR COMPUTING SPACE, DIFF FOR ISIS
	EI 	:KNRING

	EI 	:RKERNL

:	ISIS Kernel

	IF	IKERNL
KBSZL	EQ	6		:LOG2 OF KERNEL BUFFER SIZE
KBSZ	EQ	1^KBSZL		:SIZE OF KERNEL BUFFERS
	IF	(1-IKNRNG)	:AND IF IKERNL
KBASZ	EQ	8		:FIXED BIT ARRAY SIZE -
	EI 	:1-IKNRNG

KDISP	HS	1		:THIS HW FOR FLASHER

	IF	(1-IKNRNG)	:AND IF IKERNL
NEWLOG	HS	KBASZ		:NEW LOGIN FLAGS
	SYAD(NEWLOG)
ZAPPEM	HS	KBASZ		:TO ZAP KERNEL CIRCS
KOF	HS	KBASZ		:PORTS THAT HAVE CHARS FOR OUTPUT
KOFF	HS	KBASZ		:TO OVERRIDE BACKPRESSURE
	HS	2*KBASZ		:USED BY DISPATCHER
	ELSE	:IKNRNG AND IF IKERNL
NEWLOG	WS	(NKU+1F)/20	:NEW LOGIN FLAGS
	SYAD(NEWLOG)
KOF	WS	(NKU+1F)/20	:PORTS THAT HAVE CHARS FOR OUTPUT
KOFF	WS	(NKU+1F)/20	:TO OVERRIDE BACKPRESSURE
KPARMS	WS	3		:PARAMETER AREA FOR LOGON/ZAP SVC
KRINGS	BS	NKU*(KBSZ+4)*2	:KERNEL RINGS AREA
	EI 	:(NOT)1-IKNRNG

	IF (IKNRNG)	:AND IF IKERNL

:	DEFINE KERNEL RING STRUCTURE

Q	EQ	.		:REMEMBER WHERE WE ARE
	ORG 	0		:DEFINE KERNEL RING STRUCTURE
	BS	KBSZ		:OUTPUT RING (FROM KERNEL)
KOB	HS	0		:RING LABEL POINTS PAST END OF RING
	SYAD(KOB   )
NIO	HS	1		:OUT BUFF IN PTR (KERNEL INX)
NOO	HS	1		:OUT BUFF OUT PTR (NODE INX)
	BS	KBSZ		:INPUT RING (TO KERNEL)
KIB	HS	0		:RING LABEL POINTS PAST END OF RING
NII	HS	1		:IN BUFF IN PTR (NODE INX)
NOI	HS	1		:IN BUFF OUT PTR (KERNEL INX)
	ORG	Q		:GO BACK TO THE REAL WORLD
	WS	0

	ELSE	:NOT IKNRNG AND IF IKERNL
KIB	BS	(NKU+1)*KBSZ	:KERNEL PORT INPUT BUFFS
KOB	BS	(NKU+1)*KBSZ	:DITTO OUTPUT
	SYAD(KOB   )
NII	BS	NKU+1		:IN BUFF IN PTR (NODE INX)
NMI	BS	NKU+1		:BETWEEN NII AND NOI (KERNEL INX)
NOI	BS	NKU+1		:IN BUFF OUT PTR (KERNEL INX)
NIO	BS	NKU+1		:OUT BUFF IN PTR (KERNEL INX)
NOO	BS	NKU+1		:OUT BUFF OUT PTR (NODE INX)
	WS	0
	EI 	:(NOT)IKNRNG

KQ	EQ	0		:POINTER OFFSET
KBST	EQ	KBSZ-1		:FOR COMPUTING BUFF SPACE

	EI 	:IKERNL

	SUBTTL	DATA (SEGMENT 5 - Supervisor Communication Area)

::*********************************************************************
::
::	SEGMENT 5 - Supervisor Communication Area
::
::*********************************************************************

	IF	NOSEG		:##al
	IF	ISIS 
	IF	1-SUPER		:ISIS_SUP DEFINED IN FIN
::S4SIZE	EQ	10000
	EI	:1-SUPER##AL
	EI	:ISIS##AL
       IF       SUPER           :supe wants to be able to clear seg 4
SS4SIZ  EQ      .-SEG4
        BND     20              :let rings begin on nice boundary
       EI       :SUPER                                ###SDW
SEG5	HS	0
	ELSE	:NOT NOSEG
S4SIZE	EQ	.-SEG4
       IF       SUPER
SS4SIZ  EQ      S4SIZE
       EI       :SUPER          :supe clear seg 4 have same label       ###sdw
	SEG.(5)
SEG5	HS	0
	EI	:NOSEG

:	SUPERVISOR COMMUNICATION AREA

	IF	SUPER

        BND     20              :SIO stuff must be on quad word boundary
                                :###sdw

SUPBSZ	EQ	800		:SIZE OF SUP BUFFERS

	IF	SNRING		:AND IF SUPER
SIBPSZ	EQ	NSP*4+2
SOBPSZ	EQ	NSP*4+2
	IF	SIBPSZ-1FFE
SIBPSZ	EQ	1FFE		:SET THE UPPER LIMIT FOR RING SIZE
SOBPSZ	EQ	1FFE		:    TO ALLOW FOR MORE SUP PORTS   	###GT
	EI	:
SICSZ	EQ	10
SOCSZ	EQ	10

	WS	1		:RINGS START AFTER 1 WORD INTO SEGMENT!

SIBBSE	HS	0		:BASE OF SIB RING
	SYAD(SIBBSE)
	HS	SUPBSZ/2	:INPUT RING
SIB	HS	0
NISI	HS	1		:FILL INDEX FOR SIB
	SYAD(NISI  )
NOSI	HS	1		:EMPTY INDEX FOR SIB
	SYAD(NOSI  )

SOBBSE	HS	0		:BASE OF SOB RING
	SYAD(SOBBSE)
	HS	SUPBSZ/2	:OUTPUT RING
SOB	HS	0
NISO	HS	1		:FILL INDEX FOR SOB
	SYAD(NISO  )
NOSO	HS	1		:EMPTY INDEX FOR SOB
	SYAD(NOSO  )

SIBPBS	HS	0		:BASE OF SIBP RING
	SYAD(SIBPBS)
	HS	SIBPSZ/2	:BACKPRESSURE FROM NODE
SIBP	HS	0
NISIBP	HS	1		:FILL INDEX
	SYAD(NISIBP)
NOSIBP	HS	1		:EMPTY INDEX
	SYAD(NOSIBP)

SOBPBS	HS	0		:BASE OF SOBP RING
	SYAD(SOBPBS)
	HS	SOBPSZ/2	:BACKPRESSURE SET BY SUPERVISOR
SOBP	HS	0
NISOBP	HS	1		:FILL INDEX
NOSOBP	HS	1		:EMPTY INDEX


SICBSE	HS	0		:BASE OF SIC RING
	HS	SICSZ/2		:INPUT CONTROL RING
SIC	HS	0
NISIC	HS	1		:FILL INDEX
	SYAD(NISIC )
NOSIC	HS	1		:EMPTY INDEX
	SYAD(NOSIC )

SOCBSE	HS	0		:BASE OF SOC RING
	SYAD(SOCBSE)
	HS	SOCSZ/2		:OUTPUT CONTROL RING
SOC	HS	0
NISOC	HS	1		:FILL INDEX
	SYAD(NISOC )
NOSOC	HS	1		:EMPTY INDEX
	SYAD(NOSOC )

	ELSE	:NOT SNRING AND IF SUPER
SIB	BS	SUPBSZ		:SUP INPUT BUFFER
SOB	BS	SUPBSZ		:SUP OUTPUT BUFFER
NISI	HS	1		:IN PTR FOR SUP INPUT (NODE-INDEXED)
NOSI	HS	1		:OUT DITTO (SUP-INDEXED)
NISO	HS	1		:IN PTR FOR SUP OUTPUT (SUP-INDEXED)
	SYAD(NISO  )
NOSO	HS	1		:GUESS (NODE-INDEXED)
	SYAD(NOSO  )
SBUFS	HS	1		:ABSOLUTE CHAN # OF SUP CH 0
NODINF	HS	1		:SUPERVISOR STATE FLGA (1=SLEEP)
SUPBPV	WS	NSP/20		:SUP RESETS THESE TO STOP INPUT
SUPBPX	WS	NSP/20		:NODE RESETS THESE TO STOP OUTPUT
NODFRZ	HS	1		:IF NONZERO, FREEZE NODE
	EI 	:(NOT)SNRING

	EI 	:SUPER

       IF       NOSEG
        IF      SUPER
         IF     1-ISIS
SS5SIZ  EQ      .-SEG5          :where seg 5 ends
        SEG     2               :let the logical segments continue
         EI     :1-ISIS
        EI      :SUPER
       EI       :NOSEG

	SUBTTL	DATA (SEGMENTS 6,7,8,9 - IOTAB and Bufferlets)

::*********************************************************************
::
::	SEGMENT 6,7,8,9 - BULK STORAGE (BUFFERLETS AND IOTAB)
::
::*********************************************************************

	IF	NOSEG		:##al
	IF	ISIS
	IF	1-SUPER		:ISIS_SUPER DEFINED IN FIN
::S5SIZE	EQ	10000
	EI	:1-SUPER##AL
SEG6	HS	0
	EI	:ISIS##AL
	ELSE	:NOT NOSEG
S5SIZE  EQ	.-SEG5  	:END OF SEGMENT 5
	SEG.(6)
SEG6	HS	0
	EI	:NOSEG

:	PERMUTER TABLES AND CHARACTER BUFFERLETS:

:	THESE MUST CORRESPOND EXACTLY TO THE ATTENTION FLAGS DEFINED
:	PREVIOUSLY.

IOTAB	HS	20			:NOTE FIRST 20 CHANNS UNUSED
	SYAD(IOTAB )
LIOTAB	HS	10			:LEPRECHAUN PERMUTER TABLE
INTTAB	HS	10			:INTERNAL HOST PERMUTER TABLE
ASYTAB	HS	(NPGRP+1)/2*20		:async, SIO, and MPVC ports	###jhl
	IF	NMPVC
TMPTAB	HS	(NPGRP+1)/2*20		:MPVC subport to pseudo port PT	###jhl
	EI	:NMPVC
ALMTAB	HS	NANIPT
ANITAB	HS	NANIPT
GLGTAB	HS	(NPGRP+1)/2*20		:.LGBUF to .ALBUF Perm Tbl	###jhl
TLGTAB	HS	(NPGRP+1)/2*20		:.FTBUF to .LGBUF Perm Tbl	###jhl
KIOTAB	HS	((NKU+1F)/20)*20	:KERNEL PERMUTER TABLE
SIOTAB	HS	NSP			:SUPER PERMUTER TABLE
DIOTAB	HS	((NDP+1F)/20)*20	:DISPATCHER PERMUTER TABLE
NIOTAB	HS	TCHANS			:LINK PERMUTER TABLES
	SYAD(NIOTAB)
IIOTAB	HS	20			:ILC PERMUTER TABLES
BIOTAB	HS	20			:BPM PERMUTER TABLES
CIOTAB	HS	20			:DETACHED CIRCUITS

BPSCNT	HS	TCHANS			:LINK BACK PRESSURE COUNTERS
	SYAD(BPSCNT)

HISTBF	BS	HISTSZ			:HISTORY BUFFER
	IF	T2GATE
GDLGTB	HS	NDP		:Dummy permuter table for Gateway log-ins
GLGCNT	BS	NDP:Is this used:Log on char count storage I-net to H-net
	EI	:T2GATE

	if	alhub
XUBLK	BS	XUBSZ*NXUBLK	:XRAY USER BLOCK AREA
	SYAD(XUBLK )
	ei

:       added 7-27-89 to allow counting of needles, logon rejects and
:       input and output chars for supe.
        if      super
        ws      0

supned  hs      (nsp+4)*2               :total needles origing on this node
supcpo  hs      (nsp+4)*2               :total chars from sup
supcpi  hs      (nsp+4)*2               :total chars to supe
suprej  hs      (nsp+4)*2               :number of type 0d msgs from supe
supilc  ws      nsp+4                   :link count of needles starting here
supdlc  ws      nsp+4                   :dest link count
supdnd  hs      (nsp+4)*2               :dest needles for this nde
supind  hs      nsp+4                   :internal circuits for this node
        ws      0
        ei      :super

        if      nku
kerict  ws      nku+2
keroct  ws      nku+2
        ei      :nku

	IF	1-NOSEG		:NOT NOSEG
	ORG	(./CBSZ)*CBSZ+CBSZ
	HS	1			:**CHRBUF ADDR MUST BE 2 MOD CBSZ
CHRBUF	HS	0			:BUFFERLET STORAGE
	SYAD(CHRBUF)
	EI	:1-NOSEG##AL

	SUBTTL	DATA (SEGMENT B - SYNC Input rings)

::*********************************************************************
::
::	SEGMENT B - SYNC-LINE INPUT BUFFER
::
::*********************************************************************
	IF	NOSEG
	IF	ISIS		:##al
:	SEG.(0B)
:	ORG	0B0000
SEGB	HS	0
	EI	:ISIS##al
	ELSE	:NOT NOSEG
	SEG.(0B)
	ORG	0B0000
SEGB	HS	0
	EI	:NOSEG##AL
:	DATA SEGMENT 'B' VARIABLES

SVNTIP	HS	1		:BUFFER INPUT POINTER
SVNTBF	BS	SVNBSZ		:SYNC-LINE INPUT BUFFER
	BS	(NLINES-1)*(2+SVNBSZ)

	IF	ACCT		:###EV

:: Storage allocation for accounting blocks

AABLKS	HS	0		:Beginning of block storage
	BS	NACCTS*AADSIZ	:# of accountable circuits times
				:size of each block (bytes)
AABLSZ	EQ	.-AABLKS	:Total block space allocated

	EI	:ACCT	###EV

	SUBTTL	DATA (SEGMENT C - Table Storage)

::*********************************************************************
::
::	SEGMENT C - Table Storage
::
::*********************************************************************

	IF	NOSEG
SEGC	HS	0
	ELSE	:NOT NOSEG
SBSIZE	EQ	.-SEGB		:END OF SEGMENT B
	SEG.(0C)
	ORG	0C0000
SEGC	HS	1		:CAUTION -- COPY instruction will ALWAYS
:	access an additional half-word (this half-word is NOT copied)
:	BEFORE the beginning of the source block...if this block begins
:	on a segment boundary, this will cause a reference to the LAST
:	half-word of the previous segment, and will cause a MAC violation!!
:	CRYPRB below is COPYed to CRYPSV on crash.	###wjl
	EI	:NOSEG##AL
CRYPRB	WS	0		:CRYPTO BUFFER FOR PASSING MESSAGES TO XRAY
	BS	CRYPRS
CRYPSV	WS	0		:###LSH
	BS	CRYPRS		:SAVE AREA FOR CRYPTO (SAVED ON CRASH)
	SYAD(CRYPSV)

:	STORE PACKETS ON CRASH
      IF	PKTSAV		:###wjl
PCKTSZ	EQ	NRECDS*RECBSZ	:THE SIZE OF ALL THE PACKETS ###LSH
PCKTSV	WS	0		:###LSH
	BS	PCKTSZ		:SAVE AREA FOR PHYSICAL RECORD BUFFERS
	SYAD(PCKTSV)		:(SAVED ON CRASH)
      EI	:PKTSAV

	IF	SILINS
	DEFAULT(PKSVSZ,400)	:DEFAULTED 400X BYTES
PAKSAV	HS	0		:PACKET SAVING BUFFER FOR SIO LINE	###AL
	SYAD(PAKSAV)
	BS	PKSVSZ
	IF	STRHUB							###AL
SXLNKN	BS	NLINKS-XLINKS	:TYMSTAR-XLINK ARRAY FOR INSERTING STATNS	
SXNDID	HS	NLINKS-XLINKS	:NDID STORAGE TABLE FOR STRXLK		###AL
	EI	:STRHUB
	EI	:SILINS		:THE LAST WORD IS THE CALLER'S ADDR.
	DEFAULT(BUFZSZ,400)
BUFZSV	WS	0		:###LSH
	BS	BUFZSZ		:SAVE AREA FOR A BUFFER TO BE ZAPPED
	SYAD(BUFZSV)		:FOR DEBUGGING.
	IF	PRIMSG
CRYPPB	WS	0
	BS	CRYPPS
	EI	:PRIMSG
	IF	DB.TRC		:OPTION(UTRC) in Tymfile		###wjl
TRSTAB	WS	0		:JUMP TRACE TABLE - SAVED ON CRASH
	BS	TRTBSZ
	EI	:DB.TRC
TRRING	WS	0
	SYAD(TRRING)
	BS	TRRSIZ		:CHARACTER TRACE RING
TRIXSV	HS	1		:SAVE AREA FOR TRRIX (SAVED ON CRASH)
	SYAD(TRIXSV)
TRRSAV	WS	0
	BS	TRRSIZ		:SAME FOR TRRING
	SYAD(TRRSAV)
	IF	ISIS
DIRSAV	HS	0
	BS	DRSZ+4		:DIRING...
DORSAV	HS	0
	BS	DRSZ+4		:AND DORING

::	DISPATCHER RINGS DUMP ROUTINE STORAGE AREAS	###wjl
:	-------------------------------------------
IRING	WS	0		:STORAGE FOR DIRING OR DIRSAV
	BS	DRSZ+4
ORING	WS	0		:STORAGE FOR DORING OR DORSAV
	BS	DRSZ+4
	EI 	:ISIS


ABSSAV	WS	10		:SAVE AREA FOR DATA FROM ABSOLUTE MEMORY

RSEGC	HS	0	:SEGC INITED TO -1 UP TO THIS POINT, TO 0 AFTER HERE

	IF	DB.TRC		:OPTION(UTRC) in Tymfile		###wjl
TRSAVE	HS	6		:REG SAVE AREA FOR TRACE ROUTINE
TRCBEG	HS	2		:BEGINNING OF TRACE AREA
	SYAD(TRCBEG)
TRCEND	HS	2		:END OF TRACE AREA
TRCRFL	HS	1		:FLAG INDICATES IF PREVIOUS TABLE ENTRY WAS
				:IN RANGE (-1)
TRCRRQ	HS	1		:XRAY SETS TO -1 TO REQUEST SPECIAL TRACER
	SYAD(TRCRRQ)
TRNDEX  HS	1		:INDEX INTO TRACE TABLE
	SYAD(TRNDEX)
TRCTAB	BS	TRTBSZ
	SYAD(TRCTAB)
	EI	:DB.TRC

:	SUPERVISOR TRACE AREA:	>>MOVED FROM XHOSTS<<	###wjl

	IF	SIORNG
	IF	SNRING
	IF	SUPTRC

:	SIO RING TRACE TABLE ( 2X SUP RING SIZE)
:	FORMAT AS FOLLOWS -
:		N BYTES OF DATA
:		HW-BYTE COUNT OF DATA PRECEDING (N)
:		HW-FASTC MARK
:		HW-CHAN (OR 8000 - DATA TO BASE FROM SUP, OR 0000 - TO SUP)
SRNTBL	WS	SUPBSZ/2
SRNTSZ	EQ	.-SRNTBL		:BYTE SIZE OF SIO RING TRACE TABLE

:	SIO RING TRACE BYTE INDEX INTO SRNTBL
:	POINTS TO NEXT FREE ENTRY, WRAPS AT TABLE END
SRNTRX	HS	1

SRNSEC	HS	1			:SS COMMAND (0 = DISABLE, <>0 = ENABLE)
	SYAD(SRNSEC)

SRNSAV	WS	3			:SAVE AREA FOR SIO RING TRACE ROUTINE

:	BIT ARRAY FOR SUP PORT TRACE ENAB/DISAB (1/0)
:	IF BIT SET FOR THIS SUP PORT MAKE TRACE ENTRY
SRNTRE	WS	NSP/20
SRNBT1	EQ	.-SRNTRE		:SIZE OF SRNTRE ARRAY

:	BIT ARRAY FOR SUP PORT PRINT ENAB/DISAB (0/1)
:	IF BIT RESET FOR THIS SUP PORT DISPLAY ENTRY
SRNTRP	WS	NSP/20
SRNBT2	EQ	.-SRNTRP	:SIZE OF SRNTRP ARRAY
SRNBTZ	EQ	(.-SRNTRE)/2	:SIZE IN HW, FOR CLEARING BIT ARRAYS AT START

:	INPUT/OUTPUT MESSAGE TYPE CHECK BITS, 0=TRACE,
:	1=NO ENTRY, USED TO PARSE SUPIN/SUPOUT DATA.
SRNICK	WS	1
SRNOCK	WS	1

SRNCKN	EQ	20		:ALLOW THIS MANY INPUT/OUTPUT MESSAGE TYPES

	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

:	THE STORAGE FOR THE DEBUGGER		###LSH

HSUMRK	EQ	0BBBB		:HISTORY RING MARKER

	IF	SOLOCS
	DEFAULT(LNFSIZ,800)	:DEFAULT RING SIZE FOR SOLO CONSAT
	ELSE
	DEFAULT(LNFSIZ,400)	:DEFAULT RING SIZE FOR NON-SOLO CONSAT
	EI	:SOLOCS
	DEFAULT(CBZSIZ,800)	:DEFAULT RING SIZE
	DEFAULT(BFSSIZ,800)	:DEFAULT RING SIZE
	DEFAULT(LPGSIZ,800)	:DEFAULT RING SIZE
	DEFAULT(AIOSIZ,800)	:DEFAULT SIZE

SAVSIZ	EQ	LNFSIZ		:DEFINE SAVSIZ AS THE LARGEST SIZE
	IF	CBZSIZ-SAVSIZ	:IF CBZSIZ IS BIGGER
SAVSIZ	EQ	CBZSIZ		:SAVSIZ = CBZSIZ
	EI
	IF	BFSSIZ-SAVSIZ	:IF BFSSIZ IS BIGGER
SAVSIZ	EQ	BFSSIZ		:SAVSIZ = BFSSIZ
	EI	
	IF	LPGSIZ-SAVSIZ	:IF LPGSIZ IS BIGGER
SAVSIZ	EQ	LPGSIZ		:SAVSIZ = LPGSIZ
	EI	
	IF	AIOSIZ-SAVSIZ	:IF AIOSIZ IS BIGGER
SAVSIZ	EQ	AIOSIZ		:SAVSIZ = AIOSIZ
	EI	
	

	IF	LNFDBG		:LOGON/LOGOFF DEBUGGER
	IF	SOLOCS
DTPCAS	HS	1		:CASE # FOR ROUTINE DT.PRT
CRDCAS	HS	1		:CASE # FOR ROUTINE CIRDIS
	EI	:SOLOCS
LNFPTR	HS	1		:RING POINTER
	SYAD(LNFPTR)
LNFHST	BS	LNFSIZ		:LOGON/LOGOFF HISTORY RING
	SYAD(LNFHST)
	EI	:LNFDBG

	IF	CBZDBG		:CIRCUIT BUILDING/ZAPPING DEBUGGER
CBZPTR	HS	1		:RING POINTER
	SYAD(CBZPTR)
CBZHST	BS	CBZSIZ		:CIRCUIT BUILDING/ZAPPING HISTORY RING
	SYAD(CBZHST)
	EI	:CBZDBG

	IF	BFSDBG		:BUFFER STRUCTURE DEBUGGER
BFSPTR	HS	1		:RING POINTER
	SYAD(BFSPTR)
BFSHST	BS	BFSSIZ		:BUFFER STRUCTURE HISTORY RING
	SYAD(BFSHST)
	EI	:BFSDBG

	IF	LPGDBG		:LEP/LOGGER DEBUGGER
LPGPTR	HS	1		:RING POINTER
	SYAD(LPGPTR)
LPGHST	BS	LPGSIZ		:LEP/LOGGER HISTORY RING
	SYAD(LPGHST)
	EI	:LPGDBG

	IF	AIODBG		:ASYNC INPUT/OUTPUT DEBUGGER
	IF	SOLOCS
AIOPTR	HS	1		:RING POINTER
	SYAD(AIOPTR)
AIOHST	BS	AIOSIZ		:ASYNC INPUT/OUTPUT HISTORY RING
	SYAD(AIOHST)
	EI	:SOLOCS
	EI	:AIODBG

	IF	DBGON		:IF ANY DEBUGGER OPTION ON
SAVHST	BS	SAVSIZ		:TEMP. STORE THE DATA FROM A RING TO
	EI	:DBGON

:	THE END OF STORAGE FOR DEBUGGER		###LSH

STKSZ	EQ	$A 64		: 64 FW FOR STACK SIZE
STKPTR	WS	1		: STACK POINTER
TEMST	WS	1		: TEMPERARY STORAGE
STKSTR	WS	STKSZ		: TOP OF STACK

DEFAULT(SWITIM,0)		:SWITCH MAX PROCESS TIME debug switch	###wjl 
	IF	SWITIM		:					###wjl
PSVHWM	HS	20		:save area for PROHWM, saved at wrap time##wjl
	SYAD(PSVHWM)		:					###wjl
	EI	:SWITIM		:					###wjl

	IF	NOSEG
SCEND	HS	0
	ELSE	:NOT NOSEG
SCSIZE	EQ	.-SEGC
	EI	:NOSEG##AL

	IF	NOSEG

	ORG	(./CBSZ)*CBSZ+CBSZ
	HS	1			:**CHRBUF ADDR MUST BE 2 MOD CBSZ
CHRBUF	HS	0
	SYAD(CHRBUF)			:BUFFERLET STORAGE

	EI	:NOSEG##AL

	SUBTTL	DATA (SEGMENT E - ISIS only)

::*********************************************************************
::
::	SEGMENT E - ISIS only
::
::*********************************************************************

	IF (ISIS)

	SEG.(0E)

	ORG	0E0000
SEGE	HS	0

:	ISIS CONTROL TABLE:
CTA	WS	0		:ISIS CONTROL TABLE
	IF	T2GATE
DCNTRL	WC	892
	ELSE
DCNTRL	WC	80		:DISPATCHER CONTROL FLAGS
	EI	:T2GATE
	WC	SESZ		:SEGMENT '0E' SIZE
	GL	SESZ
	WC	S0SZ		:SEGMENT SIZES
	GL	S0SZ
	WC	S1SZ
	GL	S1SZ
	WC	S2SZ
	GL	S2SZ
	WC	S3SZ
	GL	S3SZ
	IF	IKNRNG!T2GATE	:ISIS KERNEL NEGATIVE RING OR GATEWAY	###AL
	WC	S4SZ
	GL	S4SZ
	ELSE	:NOT IKNRNG!T2GATE	
	WC	0
	EI 	:IKNRNG!T2GATE
	IF	NOSEG
	WC	S5SZ		:NO LIMIT FOR ISIS SEG5##AL
	GL	S5SZ
	ELSE	:NOT NOSEG
	WC	0
	EI	:NOSEG##AL
	WC	S6SZ
	GL	S6SZ
	WC	S7SZ
	GL	S7SZ
	WC	S8SZ
	GL	S8SZ
	WC	S9SZ
	GL	S9SZ
	IF	NOSEG
	WC	SASZ
	GL	SASZ
	ELSE	:NOT NOSEG
	WC	0
	EI	:NOSEG##AL
	WC	SBSZ
	GL	SBSZ
	WC	SCSZ
	GL	SCSZ
	WC	SDSZ
	GL	SDSZ
	HC	0E		:NPROT
	BC	6,5,6,6,6,6,6	:PROT
	BC	6,6,6,6,6,6,5
ISTART	WC	NSTART
	GL	NSTART
DSTART	WC	XRAY
	GL	XRAY
	WC	CONSOL+2
::	Gateway uses different Control Table Area
	IF	T2GATE
GATCTA	WC	G.HTBL		:Pointer to Host table
	WC	G.UTBL		:Pointer to user port table
	WC	PTABLE		:Pointer to termination table
	WC	DORING		:Ptr to IN ring (In to our slot)
				:but called by Node code as D's Oring
	WC	DIRING		:Slots OUT ring as called above
	WC	0
	WC	0		:Backpressure arrays not used
	WC	G.PCTB		:Project code terminator bits
	WS	1		:Future Expansion
	HC	1		:Allow only one slot host
	HC	NDP-1		:Maximum number of ports
	HC	DRSZ		:Ring sizes, I and O
	HC	DRSZ
	HS	1		:Slot number inserted by Dispatcher
	HC	GT.VER		:Version Number & Revision
	WS	10		:Future Expansion
G.HTBL	HC	IHOST		:Gateway uses IHOST only (fixed for now)
G.UTBL	HC	NDP		:Maximum port number
PTABLE	HS	NDP		:Table of ports for Dispatcher
G.PCTB	HC	4,0,0,10,0,0,0,0,4
	HC	0,0,10,0,0,0,0	:Project Code terminator bits

	ELSE	:IF NOT T2GATE THEN ...

	WC	HTBL		:HTBLPT
	WC	HTBL		:PTBLPT
	WC	PTABLE		:TTBLPT
	WC	DORING		:OUTPUT RING (NOTE REVERSED CONVENTION)
	WC	DIRING		:INPUT RING
	WS	4		:UNUSED
	HC	0		:HOSTN
	HC	NDP-1		:NPORTS
	HC	DRSZ		:OUTPUT RING SIZE
	HC	DRSZ		:INPUT RING SIZE
	HS	1		:SLOT NUMBER (PUT IN BY DISPATCHER)
	HC	((VERSION*4)&0FF00)!(REVLEV)	:VERSION/REVLEV FOR ISIS
	WS	10		:EXTRA SPACE FOR EXPANSION
HTBL	WC	0
PTABLE	HS	NDP		:PERMUTER TABLE
	EI	:T2GATE
SESIZE	EQ	.-SEGE
	EI 	:ISIS

	SUBTTL	DATA (SEGMENT F - ISIS only)

::*********************************************************************
::
::	SEGMENT F - ISIS only
::
::	T-II Gateway will not need Merlin checking on this.
::
::*********************************************************************

	IF	(1-T2GATE)		:Gateway does not use Merlin checks
	IF	ISIS

	SEG.(0F)
	ORG	0F0000
SEGF	HS	0
:	DEFINE CRITICAL PARAMETERS FOR MERLIN EDITS
NODEVR	EQ	VERSION&0FFF	:NODE'S VERSION NUMBER

	HC	NDEFN		:NUMBER OF DEFINED SYMBOLS
	SYMDEF(NODEVR)
NDEFN	EQ	NDEF

	HC	NREFN		:NUMBER OF REFERENCE SYMBOLS
	SYMREF(NDP,2,NDP,NDP)
	SYMREF(NSLOT,2,NSLOT,NSLOT)
	SYMREF(HST0,2,HST0,HST0)
	SYMREF(MICRO,2,MICRO,MICRO)
	SYMREF(MACHNM,2,MACHNM,MACHNM)
	IF	IKNRNG
	SYMREF(ISISVR,2,$A600,$A9999)
	ELSE	:NOT IKNRNG
	SYMREF(ISISVR,1,$A400,$A599)
	EI	:
	SYMREF(NKU,2,NKU,NKU)
NREFN	EQ	NREF
SFSIZE	EQ	.-SEGF
	EI 	:ISIS
	EI		:(1-T2GATE)

	ENDMO.(DATA)

	EI 	:1-KILLIT

	KILMSG(DATA)

:	***NOTHING PAST THIS POINT***

	
  	SUBTTL  EXEC

:			***** *   * *****  ***
:			*      * *  *     *   *
:			***     *   ***   *
:			*      * *  *     *   *
:			***** *   * *****  ***

::#####################################################################
::
::	MODULE:		EXEC
::
::	FUNCTION:	PROCESS EXECUTIVE AND OTHER SUPPORT SOFTWARE
::			FOR TYMNET-II NODE CODE. 
::
::	SUBTTLS:	Read/only data
::			NSTART - Init routine for node code
::			EXEC - Process, schedule, dispatch and dismiss
::			Process execution statistics
::			Various dismiss methods for various processes
::			SPIDER - Schedule RMAKE, RTD, DISPI, SUP and SWITCH
::			Periodic processes
::			Utility routines
::			OOPS - Software error handler
::			CRYPTO - Diagnostic message generator
::			
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.

::*********************************************************************
::
::	EXEC READ/ONLY DATA -- EQUATES, CONSTANTS AND DATA AREAS
::
::*********************************************************************

	SEG	1		:DATA SEGMENT 1 BEGINS HERE
	ORG	10000
SEG1	HS	0
VERSSV	WC	VERSION		:VERSION # ALWAYS AT 10000

CRACTN	HC	CRSTOP		:CRASH STOP OPTION

	IF	DB.CPU
CPUTLB	HC	0
	ORG	.+(CPUTMX*7)+1
	EI	:DB.CPU

::*********************************************************************
::
::	FAIL:	RESTART SVC FOR NODE
::
::*********************************************************************

	IF	ISIS

FAIL	WS	2			:PSW
	WS	2			:R0,R1
	STH	R1,CRSHID		:SAVE CRASH CODE
	SIS	R1,1			:IF POWER UP OR MANUAL RESTART, 
	JLE	NSTART			: INIT NODE WITHOUT SAVING REGS, ETC...
	TS	CRTYPE			:INDICATE NOT OOPS CRASH
	L	R1,FAIL+4		:SAVE CRASH ADDRESS
	ST	R1,CRSHAD		:AS SUPPLIED BY ISIS
	L	R1,FAIL			:CRASH PSW
	ST	R1,CRSHPS
	L	R0,FAIL+8		:SAVE REGISTERS
	L	R1,FAIL+0C
	J	SFAIL			:PROCEED AS USUAL
	EI	:ISIS

REBCEN	HC	REBILD			:REBUILD CONTROL CHARACTERS ENABLED
	SYAD(REBCEN)	
REBREN	HC	1			:REBUILD REQUESTS ENABLED
	SYAD(REBREN)	

::*********************************************************************
::
::	INITIAL PROCESS P-COUNTERS, PRIORITIES, AND FREQUENCIES.
::
::*********************************************************************

Q	EQ	1F

QEXECZ	WS	0	:BUFFER ZAPS GET THE HIGHEST PRIORITY
	WC CKZB					;PCKZB	EQ	Q;Q EQ Q-1
	GL	CKZB

	IF	SOLOCS
	WC ASYPOL				;PASYNC	EQ	Q;Q EQ Q-1
	GL	ASYPOL
	EI	:SOLOCS

	WC SYLVER	;TSYLVR EQ T016MS	;PSYLVR EQ	Q;Q EQ Q-1
	GL	SYLVER

	WC SPIDER	;TSPIDR EQ 0		;PSPIDR EQ	Q;Q EQ Q-1

	WC SWITCH	;TSWICH EQ T032MS	;PSWICH EQ	Q;Q EQ Q-1
	GL	SWITCH

	IF	1-ISIS						:###LSH
	IF	STRHUB!STRRMT
	WC SIQURY	;TSQURY EQ T064MS	;PSQURY EQ	Q;Q EQ Q-1
	GL	SIQURY						:###LSH
	EI	:STRHUB!STRRMT
	EI	:1-ISIS						:###LSH

	WC LINKER	;TLINKR EQ T125MS	;PLINKR EQ	Q;Q EQ Q-1
	GL	LINKER

	IF	SOLOCS
	WC G250MZ	;TG250M	EQ T250MS	;PG250M EQ	Q;Q EQ Q-1
	ELSE	:APLYBP	is only logic to also use 250 ms 
	IF 	APLYBP
	WC G250AB	;TG250M	EQ T250MS	;PG250M EQ	Q;Q EQ Q-1
	EI	:APLYBP
	EI	:SOLOCS

	WC G500MS	;TG500M EQ T500MS	;PG500M EQ	Q;Q EQ Q-1

	WC DWLIN	;TDWLIN EQ 0		;PDWLIN EQ	Q;Q EQ Q-1
	GL	DWLIN

	WC DLYSRC	;TDLYSR EQ 0		;PDLYSR EQ	Q;Q EQ Q-1
	GL	DLYSRC

	WC XRYSCH	;TXRAY  EQ 0		;PXRAY	EQ	Q;Q EQ Q-1
	GL	XRYSCH

	WC G01SEC	;TG01SC EQ T01SEC	;PG01SC EQ	Q;Q EQ Q-1

	WC G02SEC	;TG02SC EQ T02SEC	;PG02SC EQ	Q;Q EQ Q-1

	WC G04SEC	;TG04SC EQ T04SEC	;PG04SC EQ	Q;Q EQ Q-1

	WC G08SEC	;TG08SC EQ T08SEC	;PG08SC EQ	Q;Q EQ Q-1

	IF	SOLOCS
	WC G16SEC	;TG16SC EQ T16SEC	;PG16SC EQ	Q;Q EQ Q-1
	EI	:SOLOCS

	WC G30SEC	;TG30SC EQ T30SEC	;PG30SC EQ	Q;Q EQ Q-1

	WC G01MIN	;TG01MN EQ T01MIN	;PG01MN EQ	Q;Q EQ Q-1

	WC G02MIN	;TG02MN EQ T02MIN	;PG02MN EQ	Q;Q EQ Q-1

	WC G04MIN	:4 MINUTE ROUTINE	;PG04MN	EQ	Q;Q EQ Q-1

	WC	MSHRNK				;PGMSRK	EQ	Q;Q EQ Q-1
	GL	MSHRNK	:8 MINUTE CHECK FOR LINKS WHICH NEED SHRINKING

	RE 20-(.-QEXECZ)/4
	WC EXCRH; NOLIST; ER; LIST

::*********************************************************************
::
::	INITIAL PROCESS SCHEDULE:
::
::*********************************************************************

SCHTBZ	WC 1^PGMSRK			:T08MIN
	WC 1^PG04MN			:T04MIN
	WC 1^PG02MN			:T02MIN
	WC 1^PG01MN			:T01MIN

	WC 1^PG30SC			:T30SEC
	IF SOLOCS
	WC 1^PG16SC			:T16SEC (TYMSAT)
	ELSE
	WC 0				:T16SEC (ELSE)
	EI :SOLOCS
	WC 1^PG08SC			:T08SEC
	WC 1^PG04SC			:T04SEC

	WC 1^PG02SC			:T02SEC
	WC 1^PG01SC			:T01SEC
	WC 1^PG500M			:T500MS
	IF SOLOCS!APLYBP
	WC 1^PG250M			:T250MS (TYMSAT) OR APLYBP (TYMSTAR)
	ELSE
	WC 0				:T250MS (ELSE)
	EI :SOLOCS

	WC 0				:T125MS...UNUSED
	IF 1-ISIS			:			###LSH
	IF STRHUB!STRRMT		:			###LSH
	WC 1^PSQURY			:T064MS (SOLO STRHUB OR STRRMT)
	ELSE
	WC 0				:T064MS(ELSE)
	EI :STRHUB!STRRMT		:			###LSH
	EI :1-ISIS
	WC 1^PSWICH			:T032MS...SWITCH
	WC 1^PSYLVR			:TSYLVR = 16MS

::*********************************************************************
::
::	SIOINT:
::	A brief description of the initialization routine is as follows:
::	do a channel reset, reset external status latches, set SDLC
::	mode, reset external status latches, rcv interrupt disable,
::	null, set: (DTR, TX 8 bits/char, Tx enable, RTS, Tx CRC enable),
::	reset Tx CRC generator, enter flag char 7E, reset external 
::	status latches, set: (Rx 8 bits/char, enter hunt phase, Rx 
::	CRC enable, Rx enable), stop.
::
::*********************************************************************
SIOINT	IF	SILINS
	IF	HMITST			:New HDLC for TYMSTAR testing	###ev
	WC	30018,34420,38100,3177E,315EB,313D9,60000,0
	ELSE				:Not new HDLC for TYMSTAR
	WC	30018,31420,31100,303D8,305EB	:CHANNEL RESET,30018,ADDED#JHL
	WC	3877E			:HDLC INITIALIZATION PROGRAM	###TZ
	IF	HMICRO			:HDLC Micro			###wjl
	WC	613D9,0
	ELSE	:ENGINE
	WC	313D9,0
	EI	:HMICRO
	EI	:HMITST			:End New HDLC for TYMSTAR section
	IF	STRHUB			:DUMMY RCD SENT BY KEY ##AL
	HC	4			:DUMMY RECORD
	HC	TWDMHD^(-10),TWDMHD&0FFFF,0,0,0,0,0
	HC	8			:DUMMY RECORD
	HC	0,0,TWDMHD^(-10),TWDMHD&0FFFF,0,0,0,0
	ELSE	:NOT STRHUB
	HC	4			:DUMMY RECORD
	HC	TWDMHD^(-10),TWDMHD&0FFFF,0,0,0,0,0
	EI	:STRHUB
	IF	RBTHUB		:STRHUB
	WC	0,0,0,0		:QUAD WORD STORAGE FOR RBT CCW ##AL
	WC	0,0,0,0		:QUAD WORD STORAGE FOR RRS CCW ##AL
	EI	:RBTHUB
	IF	NAKCOD		:STRHUB!STRRMT
	WC	0,0,0,0		:QUAD WORD STORAGE FOR CCW ##AL
	EI	:NAK 
	EI	:SILINS

::*********************************************************************
::
::	MACHID:	DEFINE MACHID FOR CONSOLE DISPLAY.
::		UPPER HALFWORD HAS DECIMAL FORMAT HOST NUMBER,
::		LOWER HALFWORD HAS OCTAL FORMAT MACHINE NUMBER.
::
::*********************************************************************

	if	0
MACHID	HS	0
	RA	0A		:SET DECIMAL RADIX
Q4	EQ	HST0/1000		:THOUSANDS
Q4F	EQ	Q4*1000
Q3	EQ	(HST0-Q4F)/100		:HUNDREDS
Q3F	EQ	Q3*100
Q2	EQ	(HST0-(Q4F+Q3F))/10	:TENS
Q2F	EQ	Q2*10
Q1	EQ	HST0-(Q4F+Q3F+Q2F)	:ONES

	BC	(Q4^4)+Q3
	BC	(Q2^4)+Q1
	ei	:0

	RA	8		:SET OCTAL RADIX

MACHID	HS	0
	BC	0
	BC	((MACHNM&70000)^-14)
	BC	((MACHNM&7000)^-5)+((MACHNM&700)^-6)
	BC	((MACHNM&70)^1)+(MACHNM&7)

	RA	0		:RESTORE HEX RADIX

	SUBTTL	EXEC (NSTART)

::*********************************************************************
::
::	NSTART:		INITIAL ROUTINE RUN IN THE NODE CODE.
::	FUNCTION:	INITIALIZES ALL DATA AREAS AND VARIABLES FOR THE NODE
::		CODE AND THEN JUMPS TO THE MAIN NODE CODE EXEC LOOP (EXEC).
::
::*********************************************************************

NSTART	HS	0
	IF	ISIS
	LIS	R0,0
	STH	R0,DRIF,,		:INITIALIZE RING POINTERS
	STH	R0,DRIE,,
	STH	R0,DROF,,
	STH	R0,DROE,,
	LA	R0,FAIL			:FAIL SVC
	SVC	SYS,0
	HC	0,0
	IF	SUPER
	IF	IKNRNG			:BYPASS ONLY FOR ISIS SUPS
	IF	\MSLOT			:USING ISRS
	JFS	NST91
	EI	:\MSLOT
	EI	:IKNRNG
	SVC	SYS,$A 24		:FREEZE SUP
NST91	HS	0			:BYPASS FREEZE SUP
	EI	:SUPER

	IF	1-IKNRNG&(1-T2GATE)	:ISIS REGULAR KERNEL	###
:	STORE A 1 IN EACH BIT POSITION OF 'ZAPPEM' FOR A KERNEL PORT THAT WAS
:	ACTIVE WHEN THE NODE CRASHED.
	LHI	R0,(NKU+0F)/10		:# HALFWORDS OF KERNEL ACP
	LIS	R1,0			:ACP, ZAPPEM INDEX
	LCS	R2,1			:NEED TO COMPLEMENT ACP, 0 FOR ACTIVE
NST02	LHL	R3,KERACP,R1,		:0 FOR PORTS ACTIVE TO ISIS KERNEL
	XR	R3,R2			: WHEN NODE CODE CRASHED
	STH	R3,ZAPPEM,R1,		:KERNEL EXAMINES THIS ARRAY TO CLEAN UP
	AIS	R1,2
	SIS	R0,1			:MORE TO DO?
	JGBS	NST02			:YES - CONTINUE
	EI	:1-IKNRNG*(1-T2GATE)	
	ELSE	:NOT ISIS
	LIS	R1,1			:DISABLE XRAY
	SVC	0F,SV.EXR
	EI	:ISIS

:	NOW BEGIN CLEARING THE SEGMENTS
	LHI	R1,CLSEG0		:start clearing from CLSEG0	###jhl
	LHL	R2,CRHCNT		:if crash count zero, clear all
	JNFS	NST04			:else, clear around host tables
	LHI	R2,(S0SIZE-CLSEG0)/2	:get range to end of SEG 0
	JFS	NST08			:branch to do one fell clear
NST04	LHI	R2,(HOSTN-CLSEG0)/2	:clear up to host tables
	JAL	R8,HCLEAR		:there is info in host tables
					:that we must not lose		###jhl
	LHI	R1,NEWSUP		:resume clearing after host tables
	LHI	R2,(S0SIZE-NEWSUP)/2	:assumes NEWSUP doesn't move
	GL	S0SIZE
NST08	JAL	R8,HCLEAR		:clear rest of seg 0

:	now reset values of available ports to max for each host
	LHI	R10,NHOSTS-1		:init index into HW arrays
NSTH05	LHL	R1,HMAXP,R10,R10	:read host entries for max ports
	JEFS	NSTH10			:nothing doing if zero
	STH	R1,HSTPTA,R10,R10	:here's a value to move
NSTH10	SIS	R10,1			:decrement index to next host entry
	JGEBS	NSTH05			:loop for all possible entries	###jhl

	TS	SYLINT			:TO START SYNC SPEEDCALC	###OAS

	IF	SIORNG
	IF	SNRING
	IF	SUPTRC			:###OAS
	GL	SRNTRE,SRNBTZ,SRNSEC,SRNTRX,SRNICK,SRNOCK
	LA	R1,SRNTRE,,		:CLEAR SUP RING TRACE BIT FLAGS
	LHI	R2,SRNBTZ		:THIS MANY HW'S
					:DISABLES TRACE, ENABLES DISPLAY
	JAL	R8,HCLEAR
	STH	R0,SRNSEC,,		:DISABLE SS CMD (R0 HAS 0 AFTER HCLEAR)
	STH	R0,SRNTRX,,		:CLEAR TRACE TABLE INDEX
	ST	R0,SRNICK,,		:ENABLE TRACE OF ALL SUPIN MESSAGES
	ST	R0,SRNOCK,,		:ENABLE TRACE OF ALL SUPOUT MESSAGES
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	IF	TSTSZE
	TS	TSLINE			:TURN OFF LINE-LEVEL TRACING	###OAS
	EI	:TSTSZE

	GL	XUBLK,CRYMOD
	LIS	R1,1			:TURN OFF AUTO CRYPTO DISPLAY FOR TTY 
	LHI	R2,CRYMOD
	STH	R1,XUBLK,R2,

	L	R10,SLOWC,,		:REMOVED ISIS SWITCH,		###OAS
	ST	R10,NODSLC,,		:SEE COMMENT IN DATA AT NODSLC DEFN

	IF	DB.CPU
	GL	CPUTRQ
	TS	CPUTRQ,,		:MARK CPUTIL REQUEST OFF INITIALLY
	EI	:DB.CPU
	LHL	R10,CRHCNT
	AIS 	R10,1
	STH	R10,CRHCNT
	STH	R10,CRCNT		:CRASH TABLE'S COUNT
	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl
	LI	R10,TRACER
	GL	TRACER
	ST	R10,TRPSW+8		:POINTER TO JUMP TRACE
	EI	:DB.TRC
	LHL	R0,CRYPRI		:INITIALIZE CRYPTO POINTER FOR TTY
	LI	R1,TTYXD		:TTY USER BLOCK
	GL	TTYXD
	STH	R0,CRYPTU,R1
	IF	1-ISIS
	LIS	R1,0			:ENABLE LOCAL XRAY
	SVC	0F,SV.EXR
	EI	:1-ISIS

	IF	ISIS&(1-T2GATE)		:GET HOSTS STATUS		
	LHI	R0,INHTRQ^8		:HOST STATUS REQUEST MESSAGE	###jhl
	STH	R0,DIRNG+2,,		:STORE PORT #0/MESSAGE
	LHI	R0,INNOSP^8		:NO SUP MESSAGE			###jhl
	STH	R0,DIRNG+6,,
	LIS	R0,8
	STH	R0,DRIF,,		:SAVE FILL POINTER
	EI	:ISIS&(1-T2GATE)					
	IF	T2GATE	
	LIS	R3,HDOWN		:Pass host down during init.
	JAL	R10,GHSTST,,		:Send to dispatcher
	GL	GHSTST
	LHI	R3,INCOST		:Init send default hst cost##al
	JAL	R10,GHSTCT,,
	GL	GHSTCT
        LIS     R1,1                    :###sdw
        STB     R1,G0DFG                :init that we have an ISIS supe

	EI	:T2GATE	
	
	IF	NOSEG	:CLEAR DATA AREA EXCEPT SEGC ~ SCEND AREA ###LSH
	LA	R1,20000,,	
	LI 	R2,(SEGC-20000)/2  :CLEAR FROM 20000 TO SEGC   	:###LSH
	JAL	R8,HCLEAR

	LA	R1,SCEND,,	   :CLEAR FROM SCEND TO THE END  ###LSH
	LI 	R2,((CHRBUF-SCEND)+RCBFSZ)/2	:OF BUFFERLET    ###LSH
	GL	RCBFSZ				:AREA		 ###LSH
	JAL	R8,HCLEAR

	ELSE	:NOT NOSEG					:###LSH
	LA	R1,20000,,		:CLEAR DATA AREA 2
	LI 	R2,S2SIZE/2
	GL	S2SIZE			:##AL
	JAL	R8,HCLEAR

	LA	R1,30000,,		:CLEAR DATA AREA 3
	LI	R2,S3SIZE/2
	GL	S3SIZE			:##AL
	JEFS	NST05			:SKIP IF EMPTY SEGMENT
	JAL	R8,HCLEAR

NST05	HS	0			:				###wjl
	LA	R1,60000,,		:CLEAR SEGMENT 6
	LI	R2,S6SIZE/2
	GL	S6SIZE
	JEFS	NST20
	JAL	R8,HCLEAR

NST20	LA	R1,70000,,		:CLEAR SEGMENT 7
	LI	R2,S7SIZE/2
	GL	S7SIZE
	JEFS	NST25
	JAL	R8,HCLEAR

NST25	LA	R1,80000,,		:CLEAR SEGMENT 8
	LI	R2,S8SIZE/2
	GL	S8SIZE
	JEFS	NST30
	JAL	R8,HCLEAR

NST30	LA	R1,90000,,		:CLEAR SEGMENT 9
	LI	R2,S9SIZE/2
	GL	S9SIZE
	JEFS	NST40
	JAL	R8,HCLEAR

NST40	LA	R1,0B0000,,		:CLEAR SEGMENT B
	LI	R2,SBSIZE/2
	GL	SBSIZE			:##AL
	JEFS	NST45
	JAL	R8,HCLEAR
	

NST45	HS	0

	IF	(1-ISIS)!IKNRNG	:IF NOT ISIS OR IF ISIS WITH NEG KERNEL RINGS
	IF	KERNEL
	LA	R1,KBASE,,		:CLEAR KERNEL COMMUNICATIONS AREA
	IF	KNRING
	IF	1-SIORNG
:	DON'T CLEAR KBTBL...
	LHI	R2,(KBTBL-KBASE)/2
	ELSE	:SIORNG
	LHI	R2,S4SIZE/2		:KBTBL IN SEG 1 IF SIORNG
	GL	S4SIZE			:##AL
	EI	:1-SIORNG
	ELSE	:NOT KNRING
	LHI	R2,S4SIZE/2
	GL	S4SIZE			:##AL
	EI	:KNRING
	JAL	R8,HCLEAR
	EI	:KERNEL
	EI	:(1-ISIS)!IKNRNG

	IF	SUPER
	IF	ISIS
	IF	IKNRNG			:BYPASS CLEAR FOR ISIS SUPS
	IF	\MSLOT			:WITH ISRS
	JFS	NST92
	EI	:\MSLOT
	EI	:IKNRNG
	EI	:ISIS
	LA	R1,050000,,		:CLEAR DATA AREA 5
	LHI	R2,S5SIZE/2
	GL	S5SIZE			:##AL
	JAL	R8,HCLEAR

NST92	HS	0			:BYPASS CLEAR
	EI	:SUPER

	EI	:NOSEG						  :###LSH

	IF	ACCT			
	JAL	R8,AAINIT		:Initialize accounting block pointers
	EI	:ACCT						  :###LSH

	LHL	R0,CRHCNT		:TEST CRASH COUNT
	SIS	R0,1			:IF 1, WE'RE INITIALIZING FOR 1ST TIME
	JG	NST50			:NO, RESTART, LEAVE SEG C ALONE

:	INITIALIZE SEGMENT 'C'
	IF	NOSEG
	LA	R1,SEGC,,					  :###LSH
	LI	R2,(RSEGC-SEGC)/2	:FIRST PART OF SEG C TO -1:###LSH
	LCS	R0,1
	JAL	R8,HCSET		:CLEAR SEGMENT C
	LA	R1,RSEGC,,		:REST OF SEG C TO 0
	LI	R2,(SCEND-RSEGC)/2
	JAL	R8,HCLEAR
	ELSE	:NOT NOSEG
	LA	R1,SEGC,,
	LHI	R2,(RSEGC-SEGC)/2	:FIRST PART OF SEG C TO -1
	LCS	R0,1
	JAL	R8,HCSET		:CLEAR SEGMENT C
	LA	R1,RSEGC,,		:REST OF SEG C TO 0
	LHI	R2,(SCSIZE-(RSEGC-SEGC))/2
	JAL	R8,HCLEAR
	EI :NOSEG							###AL

:	STACK PTR & STORAGE AT SEG.C, INITIALIZE STKPTR HERE		###AL
	LA	R0,STKSTR,,		:STK STORAGE LOC.
	ST	R0,STKPTR,,		:INIT STKPTR			###AL

	IF	STRHUB						###AL
	LA	R1,SXLNIT		:STAR-XLINK INIT ARRAY
	GL	SXLNIT
	LA	R2,SXLNKN,,		:COPY TO SEGC AREA
	LHI	R3,NLINKS-XLINKS	:LINK ARRAY IN BYTES WITHOUT XLINKS
	JAL	R8,BCMOVE
	LHI	R0,STRXLK		:INIT NO. OF STRXLK		###AL
	STH	R0,NSTXK,,	
	EI	:STRHUB							###AL

	LIS	R0,0
	STH	R0,CRYPRI

:	Put the XRAY symbol table in (approximate) alphabetical order.
	GL	SYMTBL,SYMTSZ

	JAL	R11,XWRITE,,		:Need to write to segment D
	GL	XWRITE
	LIS	R2,0
NST60	HS	0
	LHI	R1,ADRESZ,R2
NST61	L	R10,SYMTBL,R1,
	C	R10,SYMTBL,R2,
	JGE	NST62

	LM	R13,SYMTBL,R2,
	L	R11,SYMTBL+4,R1,
	L	R12,SYMTBL+8,R1,
	STM	R13,SYMTBL,R1,
	ST	R10,SYMTBL,R2,
	ST	R11,SYMTBL+4,R2,
	ST	R12,SYMTBL+8,R2,

NST62	HS	0
	AHI	R1,ADRESZ
	CLHI	R1,SYMTSZ
	JL	NST61

NST68	HS	0
	AHI	R2,ADRESZ
	CLHI	R2,SYMTSZ-ADRESZ
	JL	NST60

	LIS	R0,0			:###TZ
	STH	R0,CRHCNT
	JAL	R10,CTENTR,,
	LIS	R0,1
	STH	R0,CRHCNT		:###TZ

	LIS	R0,0			:re-initialize
	STH	R0,CSMCNT		:crash summary count		###wjl

	JAL	R11,XPRTKT,,		:Protect segments 1 and D
	GL	XPRTKT

:	INIT CRASH TABLE STUFF
	LHI	R1,MACHNM
	STH	R1,NODENU	
	LIS	R1,9			:T-II NODE TYPE
	STH	R1,NODETY
	LIS	R1,CTBVER
	STH	R1,TABVER
	LHL	R1,VERSSV+2,,
	STH	R1,CODVER
NST50	HS	0
	IF	IKNRNG&(1-T2GATE)		
:	INITIALIZE ISIS KERNEL RING POINTERS
	LCS	R0,1			:SET POINTERS TO -1
	LIS	R1,0			:KERNEL PORT OFFSET
	LHI	R2,NII			:IN POINTER (FOLLOWED BY NOI)
NST02	ST	R0,KRINGS,R2,R1		:INITIALIZES IN AND OUT POINTERS
	AHI	R1,2*(KBSZ+4)		:SIZE OF PORT'S RING AREA
	CLHI	R1,NKU*(2*(KBSZ+4))
	JLBS	NST02
	EI	:IKNRNG&(1-T2GATE)		

	IF	RKERNL
	IF	1-SIORNG
EXKSVC	SVC	0F,SV.IKR		:INIT KERNEL (IF PRESENT)
	EI	:1-SIORNG
	EI	:RKERNL
	IF	ISIS
	IF	SUPER
	IF	IKNRNG			:BYPASS THAW FOR ISIS SUPS
	IF	\MSLOT			:USING ISRS
	JFS	NST93
	EI	:\MSLOT
	EI	:IKNRNG
	SVC	SYS,$A 25		:ANOTHER D-I-K
NST93	HS	0			:BYPASS THAW SVC
	EI	:SUPER
	EI	:ISIS
	IF	SILINS

:	INITIALIZE SIO LINES

	LA	R1,SIOINT		:SET UP INITIALIZATION CCWS
	LA	R2,SIOIPG,,		:AND DUMMY RECORD
	GL	SIOIPG
	IF	STRHUB&NAKCOD&RBTHUB
	LHI	R3,60			:ANOTHER 1 QUAD WD FOR RBTHUB ##AL
	ELSE	STRHUB&NAKCOD
	LHI	R3,50			:ANOTHER 2 QUAD WD FOR STRDUM&NAK ##AL
	ELSE	STRHUB!NAKCOD!STRRMT		:STRHUB!STRRMT
	LHI	R3,40			:ANOTHER QUAD WD FOR NAK ##AL
	ELSE	:Not Tymstar
	LHI	R3,30
	EI	:STRHUB&NAKCOD&RBTHUB
	JAL	R8,BCMOVE		:MOVE 30 BYTES FROM SIOINT TO SIOIPG
	LIS	R1,0			:NOW PREPARE ALL OTHER CCWS
 if	KOPFJ
	LM	R6,SIORIZ		: set up registers 6-15
 else	:not KOPFJ
	LI	R8,2000000
	LI	R9,(SIOBLK+10)/10	:STOP CODE PLUS POINTER TO NEXT BLOCK
	GL	SIOBLK
	LI	R10,SIOKLG		:TWO POINTERS TO OUTPUT BUFFER
	GL	SIOKLG
	LIS	R11,0			:LAST WORD NEVER USED
	LR	R12,8			:NEXT CCW
	LI	R13,SIOBLK/10		:POINT BACK TO CURRENT CCW
	IF	SIBFRL			:SIO BUFFER RELOCATION  ###LSH
	LI	R14,SIOKLG+90^0C+90/10	:			###LSH
	ELSE	:NOT SIBFRL					###LSH
	LI	R14,SIOKLG+90^10+90/10
	EI	:SIBFRL
	LIS	R15,0
	LI	R7,10000+SIBUF/10	:INPUT CCW WITH POINTER TO BUFFER
	GL	SIBUF
 ei	:KOPFJ
	LHI	R2,(NLINES-SILINS)*2	:USE R2 AS 1ST SIO LN ##AL

SIOIZP	IF	STRHUB
	LB	R0,LTYP,R2		:STAR LINE ?
	JEFS	SIBFZ1			:NO
	LI	R6,30000+(SIBFSZ+20)/2	:BUFFER SIZE FOR INPUT ###LSH
	JFS	SIBFZ2			:			###LSH
SIBFZ1	EI	:STRHUB
	LI	R6,30000+SIBFSZ/2	:BUFFER SIZE FOR INPUT ###LSH
SIBFZ2	LHI	R5,7C			:SIZE OF RESET PATTERN
:	RESET PATTERN MADE LONG TO ALLOW ACCURATE LINE SPEED CALCULATION
:	BUT ONLY FIRST 1C BYTES HAVE USEFUL DATA ###wjl
	STM	R8,SIOBLK,R1,R1		:CCW pair for output
	ST	R6,SIOBLI,R1,		:CCW for input
	ST	R7,SIOBLI+4,R1,
	GL	SIOBLI
	ST	R6,SIOSTT+8,R1,		: CCW for status
	GL	SIOSTT
	IF	XRESET			:###wjl
	IF	STRHUB
	LB	R0,LTYP,R2		:CHECK IF STR LINE ##AL
	GL	LTYP
	JEFS	SIZP1
	LHI	R5,80			:INIT SIO BYTE CT ##AL
	AHI	R7,2			:ADJUST INPUT QPOINTER SIBFSZ/10
					:BY 20/10 FOR STAR LINE ##AL
SIZP1	LR	R3,R1
	AR	R3,R1			:FOR 30H BLK IN XRESET
	AR	R3,R1			:FOR 30H BLK IN XRESET
	STH	R5,SIOBLR,R3,		: for Expanded reset ##AL
	ELSE	:NOT STRHUB
	LR	R3,R1
	AR	R3,R1			:FOR 30H BLK IN XRESET
	AR	R3,R1			:FOR 30H BLK IN XRESET
	STH	R5,SIOBLR,R3,		: for Expanded reset ##AL
	EI	:STRHUB
	ELSE	:NOT XRESET
	STH	R5,SIOBLR,R1,
	EI	:XRESET
	GL	SIOBLR
:	increment values for next set of stores
	AHI	R7,SIBFSZ/10		: input Qpointer
	AIS	R9,2			: output 1st CCW Qpointer

	IF	SIBFRL			:SIO BUFFER RELOCATION ###LSH
	AI	R10,(90*2)^0C+(90*2)/10
	ELSE				:NOT SIO BUFFER RELOCATION###LSH
	AI	R10,(90*2)^10+(90*2)/10
	EI	:SIBFRL

	AIS	R13,2			: output 2nd CCW Qpointer

	IF	SIBFRL			:SIO BUFFER RELOCATION ###LSH
	AI	R14,(90*2)^0C+(90*2)/10
	ELSE				:NOT SIO BUFFER RELOCATION###LSH
	AI	R14,(90*2)^10+(90*2)/10
	EI	:SIBFRL

	AIS	R2,2			:INC LN ##AL
	AHI	R1,10			:increment block offset for next line
	CLHI	R2,2*NLINES		:check the range
	JL	SIOIZP			:OK to do another set of stores
	EI	:SILINS

	JAL	R10,IZLNKR		:INIT LINKER
	GL	IZLNKR
	IF	SUPER
	JAL	R10,IZSUP,,		:INITIALIZE SUPERVISOR INTERFACE FIELDS
	GL	IZSUP
	EI	:SUPER
	IF	SIORNG
	JAL	R10,IZKNRG,,		:INIT NEGATIVE RINGS FOR INTERFACES
	GL	IZKNRG
	JAL	R10,IZSIRG,,		:INITIALIZE SIO RING CARD
	GL	IZSIRG
	EI	:SIORNG
	JAL	R10,IZSWIT,,		:INIT SWITCH
	GL	IZSWIT
	IF	SOLOCS			:###wjl
	JAL	R10,IZASYN,,		:INITIALIZE ASYNC RING
	GL	IZASYN
	EI	:SOLOCS
	JAL	R10,IZEXEC		:INIT EXEC
	L	R0,FASTC,,		:SAVE FASTC TIME FOR
	ST	R0,SYLTIM		: SYNC OVERRUN CALCULATION

	IF	ISIS
	LA	R0,SYLVER		:START FOREGROUND
	SVC	SYS,1

        IF      SPAM                    :                               ###dmj
        LIS     R0,0                    :                               ###dmj
        STH     R0,SPMINI               :RESET SPAM INITIALIZE FLAG     ###dmj
        EI      (SPAM)                  :                               ###dmj
	EI	:ISIS

	IF	DB.DEB
	L	R0,FASTC,,		:SAVE FASTC TIME FOR
	ST	R0,RMKTIM		: AND RMAKE INTERVAL CALCULATIONS
	EI	:DB.DEB

	L	R0,SLOWC,,		:SAVE SLOWC TIME FOR XRAY TO DISPLAY
	ST	R0,GMTSLC,,		:RESET BASE SLOWC

	IF	STRRMT
	LCS	R0,RSTFRQ		:Initialize remote reset timing counter
	STH	R0,RMRSCT		:for Starline reset		###ev
	EI	:STRRMT

	J	EXEC			:AND BEGIN EXECUTING

 if	KOPFJ
 if	SILINS				: ###JOK

:	The following is a set of initial values for registers, used for
:	SIO initialization. ("++" means reg. incremented for each line)
	GL	SIOBLK,SIOKLG,SIBUF
SIORIZ	WS	0		: Reg	Use
				:	Input CCWs
	HC	3,SIBFSZ/2	: R6	Set input-buffer- and record-size
	HC	1,SIBUF/10	: R7++	Input records (Qpointer to 1st buffer)

				:	Output CCWs
				:	(1st CCW image)
	WC	2000000		: R8	Halt Command
	WC	SIOBLK/10+1	: R9++	Halt Command + Qpointer to 2nd CCW
	WC	SIOKLG		: R10++	QPointer to 1st output buffer
	WC	0		: R11	Never used

				:	(2nd CCW image)
	WC	2000000		: R12	Halt Command
	WC	SIOBLK/10	: R13++	Halt Command + Qpointer back to 1st CCW
	WC	(SOBFSZ^10)+(SOBFSZ/10)+SIOKLG
				: R14++	Output buffer size,
				:	+ QPointer to 2nd output buffer
	WC	0		: R15	Never used
 ei	:SILINS
 ei	:KOPFJ
::*********************************************************************
::
::	SUBROUTINE:	IZEXEC:
::	FUNCTION:	INIT THE EXEC SEGMENT
::	CALLING SEQ:	JAL	R10,IZEXEC
::
::*********************************************************************

IZEXEC	HS	0
	LH	R0,VERSSV+2		:SET THE VERSION AND NODE #'S
	STH	R0,VERSID
	LHI	R0,MACHNM
	STH	R0,NODEID

	LA	R1,SCHTBZ		:INIT THE SCHEDULE TABLE
	LA	R2,SCHTAB
	LHI	R3,40
	JAL	R8,BCMOVE

	LA	R1,QEXECZ		:INIT THE PROCESS P-COUNTER TABLE
	LA	R2,QEXEC
	LHI	R3,80
	JAL	R8,BCMOVE

	L	R0,SLOWC,,		:INITIALIZE TIME TO COMPUTE AVERAGE
	ST	R0,EXLTLA		: # OF EXEC LOOP ITERATIONS PER SECOND
	LHI	R0,7FFF			:INSURE LOW-WATER MARK DOESN'T START
	STH	R0,EXLALW		: TOO LOW...
	L	R0,FASTC,,
	ST	R0,EXTIME		:MAKE TIME SINCE LAST EXEC REASONABLE

	IF	ISIS
	L	R0,FASTC,,		:SCHEDULING DUE TIMES
	AHI	R0,RATE			:BEGIN 1 SEC FROM NOW
	ST	R0,DUESCH
	LHI	R0,1F-PSYLVR		:DON'T SCHEDULE SYLVER
	RBT	R0,TSYLVR		: --IT'S THE FOREGROUND

	EI	:ISIS

	JR	R10

	SUBTTL	EXEC (Process schedule, dispatch and dismiss)

::*********************************************************************
::
::	EXEC:	DISPATCHES TO PROCESS OF HIGHEST PRIORITY
::
::*********************************************************************

EXE2	HS	0
	IF	DB.CPU
	LH	R1,CPUTRQ,,		:CPU UTIL JUST REQUESTED?
	JL	EXEC2A			:NO
	GL	CPUNRQ,CPUTFL,CPUTIN,CPUTTO
	GL	EXC1CT,EXC2CT
	LIS	R0,0			:				###OAS
	ST	R0,EXC1CT,,		:CLEAR DISPATCH COUNT		###OAS
	ST	R0,EXC2CT,,		:CLEAR DISPATCH THRU EXEC TOP COUNT#OAS
	IF	DB.CLK
	GL	EXCTIM,EXCTM1
	STH	R0,EXCTIM,,		:CLEAR TIME SPENT IN EXEC	###OAS
	EI	:DB.CLK
	TS	CPUTRQ,,		:MARK CPUTIL REQUEST OFF
	TS	CPUTFL,,		:MARK CPUTIL ACTIVE
	LHI	R0,$A600		:FASTC TICKS PER SECOND
	SLHL	R0,0,R1			:# OF FASTC TICKS TO BE MONITORED, LOG2
	STH	R0,CPUNRQ,,		:NO. FASTC REQUESTED
	L	R1,FASTC,,		:NOW
	ST	R1,CPUTIN,,		:INITIALIZE THE INTERVAL
	AR	R0,R1			:THIS IS WHEN WE TIME OUT
	ST	R0,CPUTTO,,		:SAVE IT
	IF	ISIS
	IF	DB.CLK
	LHL	R1,LO.CLK,,		:SEGF REFERENCE POINTER TO SLOT0 CLOCK
	LHL	R0,SEGF,R1,		:GET SLOT0 CLOCK
	GL	CPUTII
	STH	R0,CPUTII,,		:AND SAVE FOR SLOT TIME CALC.
	EI	:DB.CLK
	EI	:ISIS
	J	EXEC2B			:AND CONTINUE
EXEC2A	HS	0
	L	R0,CPUTTO,,		:TIMEOUT MARK
	JE	EXEC2B			:NOT SET, NOT MONITORING CPU UTIL###GT
	S	R0,FASTC,,		:TIMED OUT?
	JLEFS	EXEC2C			:YES				###OAS
	LIS	R0,1			:				###OAS
	AM	R0,EXC2CT,,		:BUMP TOP OF EXEC LOOP COUNT	###OAS
	J	EXEC2B			:AND CONTINUE			###OAS
EXEC2C	LIS	R0,0
	ST	R0,CPUTTO,,		:SET TIMEOUT <=0 TO MARK CPUTIL OFF##GT
	STH	R0,CPUTFL,,		:MARK CPUTIL INACTIVE
	L	R0,FASTC,,		:TIME NOW
	S	R0,CPUTIN,,		:SUBTRACT WHEN WE STARTED
	ST	R0,CPUTIN,,		:RECORD MEASUREMENT INTERVAL
	IF	ISIS
	IF	DB.CLK
	LHL	R1,LO.CLK,,		:SEGF REFERENCE POINTER TO SLOT0 CLOCK
	LHL	R0,SEGF,R1,		:GET SLOT0 CLOCK
	SH	R0,CPUTII,,		:COMPUTE SLOT0 INTERVAL
	JGEFS	EXEC9B			:CHECK FOR HW WRAP
	AI	R0,10000		:ADJUST FOR HW WRAP
EXEC9B	STH	R0,CPUTII,,		:RECORD SLOT0 MEASUREMENT INTERVAL
	EI	:DB.CLK
	EI	:ISIS
	IF	SUPER
	L	R0,SUPICC,,		:GET CURRENT SUPIN CHAR COUNT
	S	R0,SUICCT,,		:COMPUTE DIFFERENCE FROM START
	ST	R0,SUICCT,,		:AND STORE FOR DISPLAY
	L	R0,SUPOCC,,		:GET CURRENT SUPOUT CHAR COUNT
	S	R0,SUOCCT,,		:COMPUTE DIFFERENCE FROM START
	ST	R0,SUOCCT,,		:AND STORE FOR DISPLAY
	EI	:SUPER
EXEC2B	HS	0
	EI	:DB.CPU

	LA	R3,EXEHWM		:POINT TO FIELDS TO RECORD
	LA	R4,EXEHGM,,		: EXEC LOOP TIME
	JAL	R0,EXMTIM		:GO MEASURE TIME THROUGH EXEC LOOP

	IF	1-ISIS		:ISIS HAS SLIGHTLY DIFFERENT EXEC	##AL

	IF	KERNEL
	SVC	0F,SV.DSM		:DISMISS TO KERNEL
	LA	R3,EXDHWM		:POINT TO FIELDS TO RECORD
	LA	R4,EXDHGM,,		: DISMISS TIME
	JAL	R0,EXMTIM		:GO MEASURE TIME DISMISSED
	EI	:KERNEL
	AM	R5,EXLCNT		:COUNT EXEC LOOPS

	LHI	R0,1F-PSPIDR		:SCHEDULE SPIDER
	SBT	R0,SQUEUE
	LHI	R0,1F-PSYLVR		: AND SYLVER
	SBT	R0,SQUEUE

EXEC	HS	0
	L	R1,SQUEUE		:GET RUN QUEUE
	JFFO	R1,EXEC1		:ANYTHING TO DO?
	UPSW	EXEPSW			:NO, PICK UP NEW PSW, PROCEED AT EXE2

EXEC1	ST	R1,SQLAST		:YES, SAVE CURRENT STATE OF QUEUE
	SLLS	R2,2			:GET PROCESS # X4
	STH	R2,PROCID		:SAVE IT
	LIS	R0,1
	AM	R0,PROCNT,R2		:COUNT EXECUTIONS FOR EACH PROCESS
	L	R0,FASTC,,
	ST	R0,PROTIM,R2		:SAVE PROCESS EXECUTION BEGIN TIME

	IF	DB.CPU
	LH	R0,CPUTFL,,		:ARE WE MEASURING?		###OAS
	JGEFS	EXEC6C			:NO				###OAS
	LIS	R0,1			:				###OAS
	AM	R0,EXC1CT,,		:BUMP DISPATCH COUNT		###OAS
	IF	DB.CLK
	L	R0,FASTC,,		:GET TIME SPENT IN		###OAS
	S	R0,EXCTM1,,		:EXEC PROCESSING AND		###OAS
	AHM	R0,EXCTIM,,		:ACCUMULATE FOR THIS CPUTIL RUN	###OAS
	EI	:DB.CLK
EXEC6C	HS	0			:				###OAS
	EI	:DB.CPU

	ELSE	:NOT 1-ISIS	##AL

:	THE ISIS EXEC LOOP MAINTAINS ITS OWN TIME-OUT LIST. EVERY
:	1/8 SEC THE EXEC LOOP OR'S THE APPROPRIATE TIMEOUT
:	LOCATIONS T125MS-T08SEC INTO THE RUN QUEUE SQUEUE.
:
:	It does this by using the number of right-most 0-bits in EISECC
:	(which it increments every 125 ms) to select which timeout-period
:	bit to OR into the SQUEUE bit-array.  Thus only one get selected
:	on each pass, but all run at the appropriate rate, without imposing
:	bursts of load on the CPU.
:
:	NOTE THAT THE MOST FREQUENT PROCESS RUNS EVERY 1/8 SECOND

	SVC	FAST,0			:DISMISS TO ISIS KERNEL

	LA	R3,EXDHWM		:POINT TO FIELDS TO RECORD
	LA	R4,EXDHGM,,		: DISMISS TIME
	JAL	R0,EXMTIM		:GO MEASURE TIME DISMISSED
	AM	R5,EXLCNT		:COUNT EXEC LOOPS

EXIDL	LHI	R0,1F-PSPIDR		:SCHEDULE SPIDER 
	SBT	R0,SQUEUE

EXEC	HS	0
	L	R1,FASTC,,		:EVERY 16 TIKS, SCHEDULE SYLVER
	L	R0,DUESCH		:SCHED EVERYTHING EVERY 1/8 SEC
	SR	R0,R1			:DUESCH IS NEXT FASTC SCHEDULE TIME
	JG	EXE4			:1/8 SEC HAS NOT YET ELAPSED

	LHI	R0,RATE/8,R1		:GET NEW DUE TIME (FROM NOW)
	ST	R0,DUESCH		:AND STORE INTO DUESCH
	LH	R0,EISECC		:EISECC IS INCREMENTED EVERY 1/8 SEC
	AIS	R0,1
	STH	R0,EISECC
	L	R2,T125MS		:SCHED THESE PROCESSES
	O	R2,SQUEUE
	ST	R2,SQUEUE
	LA	R1,T125MS		:NOW SCHEDULE THE REST
	LA	R2,T08MIN
EXE5	CR	R1,R2			:AT END OF TIMEOUT LIST?
	JEFS	EXE4			:YES
	SIS	R1,4			:MOVE TO NEXT TIMEOUT LOCATION
	SRHLS	R0,1
	JNCBS	EXE5			:NOT TIME TO SCHEDULE THIS ONE
	L	R2,0,R1			:FOUND A PROCESS - READ THE TABLE ENTRY
	O	R2,SQUEUE		:MERGE WITH CURRENT RUN QUEUE
	ST	R2,SQUEUE

EXE4	L	R1,SQUEUE		:PICKUP RUN QUEUE
	JFFO	R1,EXE6
	UPSW	EXEPSW

EXE6	ST	R1,SQLAST		:SAVE CURRENT STATE OF QUEUE
	SLHLS	R2,2
	STH	R2,PROCID		:SAVE IT
	LIS	R0,1
	AM	R0,PROCNT,R2		:COUNT EXECUTIONS FOR EACH PROCESS
	L	R0,FASTC,,
	ST	R0,PROTIM,R2		:SAVE PROCESS EXECUTION BEGIN TIME

	IF	DB.CPU
	LH	R0,CPUTFL,,		:ARE WE MEASURING?		###OAS
	JGE	EXEC6C			:NO				###OAS
	LIS	R0,1			:				###OAS
	AM	R0,EXC1CT,,		:BUMP DISPATCH COUNT		###OAS
	IF	DB.CLK
	LHL	R1,LO.CLK,,		:GET SEGF OFFSET TO SLOT 0 CLOCK###OAS
	LHL	R0,SEGF,R1,		:GET SLOT 0 CLOCK VALUE		###OAS
	S	R0,EXCTM1,,		:EXEC PROCESSING AND		###OAS
	JGEFS	EXEC9C			:CHECK TO ADJUST FOR WRAP	###OAS
	AI	R0,10000		:YES, CORRECT FOR HW WRAP	###OAS
EXEC9C	AHM	R0,EXCTIM,,		:ACCUMULATE FOR THIS CPUTIL RUN	###OAS
	EI	:DB.CLK
EXEC6C	HS	0			:###OAS
	EI	:DB.CPU

	EI	:1-ISIS

	L	R0,QEXEC,R2		:DISPATCH TO PROCESS

	IF	DB.CPU
	IF	DSPTRC
	GL	EXADR0,EXCNT0,EXTBLE
	LH	R1,CPUTFL,,		:IS CPUTIL RUNNING?
	JGE	EXECT0			:NO
	LIS	R1,0			:INIT TABLE POINTER
EXECT1	L	R3,EXADR0,R1,		:SCAN TABLE FOR ADDRESS MATCH
	JEFS	EXECT3			:AT END OF TABLE, MAKE NEW ENTRY
	CR	R0,R3			:ADDRESS IN TABLE HERE?
	JEFS	EXECT4			:ADDRESS MATCHES, BUMP EXEC COUNT
EXECT2	AIS	R1,4			:NO MATCH, BUMP TABLE INDEX
	CLHI	R1,EXTBLE		:TABLE FULL?
	JLBS	EXECT1			:NO, CHECK SOME MORE
	JFS	EXECT0
EXECT3	ST	R0,EXADR0,R1,		:STORE DISPATCH ADDRESS
EXECT4	LIS	R3,1
	AM	R3,EXCNT0,R1,		:BUMP EXEC COUNT FOR THIS ADDRESS
EXECT0	HS	0
	EI	:DSPTRC
	EI	:DB.CPU

	JR	R0

	SUBTTL	EXEC (Process execution statistics)

::*********************************************************************
::
::	SUBROUTINE:	EXMTIM:
::	FUNCTION:	RECORD INTERVAL, EITHER EXEC LOOP TIME OR DISMISS TIME
::	CALLING SEQ:	JAL	R0,EXMTIM
::	INPUT:		R3 POINTS TO HIGH-WATER MARK FIELD
::			R4 POINTS TO HISTOGRAM
::	Returns:	R5 contains 1 (Used by callers for counting)
::
::*********************************************************************

EXMTIM	HS	0			:MEASURE TIME, MAKE MARK IN HISTOGRAM
	L	R1,FASTC,,
	LR	R2,R1
	S	R1,EXTIME		:COMPUTE TIME SINCE LAST EXEC OF EXMTIM
	ST	R2,EXTIME		:AND SAVE CURRENT TIME FOR NEXT TIME

	CLH	R1,0,R3			:TEST FOR NEW HIGH-WATER MARK
	JLEFS	EXMT10			:NO
	STH	R1,0,R3			:YES - SAVE IT

:	MAKE HISTOGRAM ENTRY. FULLWORD COUNTER RECORDS FASTC/4 UNITS.
EXMT10	CLHI	R1,EXEHSZ-1		:HISTOGRAM INDEX TOO LARGE?
	JLEFS	EXMT20			:NO
	LHI	R1,EXEHSZ-1		:YES - SET TO MAX
EXMT20	NHI	R1,-4			:MAKE FULLWORD INDEX FOR FASTC/4 UNITS
	LIS	R5,1
	AM	R5,0,R4,R1		:INCREMENT BUCKET IN HISTOGRAM
	JR	R0			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	EXCAVG:
::	FUNCTION:	COMPUTE AVERAGE NUMBER OF EXEC LOOPS/SECOND.
::			RECORD NEW HIGHS AND LOWS AS APPROPRIATE.
::	CALLING SEQ:	JAL	R10,EXCAVG
::
::*********************************************************************

EXCAVG	HS	0
:	REFRESH COUNTERS FOR RMK ITERATIONS AND RMK CALLS FOR NO RECORD MADE.
	LIS	R1,0
	L	R2,RMKRMW
	ST	R2,RMKRMS		:SAVE LAST MINUTE'S TOTALS AND
	ST	R1,RMKRMW		: CLEAR WORKING FIELDS
	L	R2,RMKNRW
	ST	R2,RMKNRS		:# TIMES RMK CALLED, NO RECORD MADE
	ST	R1,RMKNRW

	L	R1,SLOWC,,
	LR	R2,R1
	S	R1,EXLTLA		:COMPUTE TIME SINCE LAST AVERAGE TAKEN
	ST	R2,EXLTLA		: AND SAVE CURRENT TIME FOR NEXT TIME

        if      super
        LIS     R3,0                    :R3 & R2 ARE 64-BIT COUNT OF
        L       R2,supicc               : input cps from supe
        ST      R3,supicc 
        DHR     R2,R1                   :COMPUTE AVERAGE/SECOND
        STH     R3,suicct               : AND SAVE

        CLH     R3,suiccw               :TEST FOR NEW HIGH-WATER MARK
        JLEFS   EXCA20               :NO
        STH     R3,suiccw               :YES - SAVE IT
exca20
        LIS     R3,0                    :R3 & R2 ARE 64-BIT COUNT OF
        L       R2,supocc               : input cps from supe
        ST      R3,supocc
        DHR     R2,R1                   :COMPUTE AVERAGE/SECOND
        STH     R3,suocct               : AND SAVE

        CLH     R3,suoccw               :TEST FOR NEW HIGH-WATER MARK
        JLEFS   EXCA30               :NO 
        STH     R3,suoccw               :YES - SAVE IT
exca30
        ei      :super
        if      nku
        LIS     R3,0                    :R3 & R2 ARE 64-BIT COUNT OF
        L       R2,kericc               : input cps from supe
        ST      R3,kericc
        DHR     R2,R1                   :COMPUTE AVERAGE/SECOND
        STH     R3,kricct               : AND SAVE

        CLH     R3,kriccw               :TEST FOR NEW HIGH-WATER MARK
        JLEFS   EXCA40               :NO
        STH     R3,kriccw               :YES - SAVE IT
exca40
        LIS     R3,0                    :R3 & R2 ARE 64-BIT COUNT OF
        L       R2,kerocc               : input cps from supe
        ST      R3,kerocc
        DHR     R2,R1                   :COMPUTE AVERAGE/SECOND
        STH     R3,krocct               : AND SAVE
        CLH     R3,kroccw               :TEST FOR NEW HIGH-WATER MARK
        JLEFS   EXCA50               :NO
        STH     R3,kroccw               :YES - SAVE IT
exca50
      ei      :nku                      :only do if kernel ports

	LIS	R3,0			:R3 & R2 ARE 64-BIT COUNT OF
	L	R2,EXLCNT		: EXEC LOOP ITERATIONS
	ST	R3,EXLCNT		:REFRESH CNT FOR NEXT AVERAGING PERIOD
	DHR	R2,R1			:COMPUTE AVERAGE/SECOND
	STH	R3,EXLAVG		: AND SAVE

	CLH	R3,EXLAHW		:TEST FOR NEW HIGH-WATER MARK
	JLEFS	EXCA10			:NO
	STH	R3,EXLAHW		:YES - SAVE IT

:	Compare with low water mark in case we just did an NSZ.
EXCA10	CLH	R3,EXLALW		:NEW LOW-WATER MARK?
	JGER	R10			:NO - RETURN
	STH	R3,EXLALW		:YES - SAVE IT AND
	JR	R10			:RETURN

	SUBTTL	EXEC (Dismiss)

::*********************************************************************
::
::	EXDISM:/EXDIS:/EXYLDM:/EXYLD:  DISMISS METHODS FOR VARIOUS PROCESSES.
::
::*********************************************************************

:	Scheduled task may want to dismiss and yield to a higher
:	priority task if one is waiting, run again if not, or dismiss
:	and allow a lower priority task to run.  
:	Independent of either of these options, the dismissing task may
:	want to resume execution in its next scheduled time slot at the
:	top of the task, in which case no update of the PC in QEXEC is
:	needed, or it may want to resume at the point where it left off,
:	in which case an update the the PC table QEXEC is in order.
:	The fifth of these dismiss routines enables a mechanism from the
:	quarter second logic to schedule various of a sequence of
:	subtasks based upon the dismissing subtask updating a cell called
:	CSNEXT.

EXCRH	HS	0			:NON-EXISTENT PROCESS
	CRASH.(.EXCRH,R10)

:	The CONSAT dismisses here from various places.
:	Unfortunately, the EXEC process that got us to the CONSAT may not be
:	complete, so we have to see if there's anything more to be done.
	IF	SOLOCS
CSDISM	HS	0
	L	R2,CSNEXT,,		:Address of next sub-process to run,
	GL	CSNEXT			: or 0 if none.
	JNR	R2			:Go do it, or fall through to dismiss.
	EI	:SOLOCS

:	Dismiss without changing p-counter
EXDISM	HS	0
	IF	DB.CPU
	IF	DB.CLK
	IF	ISIS
	LHL	R10,LO.CLK,,		:UPDATE LAST DISMISS TIME FROM SLOT 0
	LHL	R10,SEGF,R10,		:LOCAL CLOCK
	ELSE	:not ISIS
	L	R10,FASTC,,		:UPDATE LAST DISMISS TIME	###OAS
	EI	:ISIS
	ST	R10,EXCTM1,,		:FOR TIME SPENT IN EXEC PROCESSING#OAS
	EI	:DB.CLK
	JAL	R10,CPUTCP		:RECORD CPUTIL STATS FOR ROUTINE
	EI	:DB.CPU			: JUST FINISHED			###OAS

	LHL	R2,PROCID		:DISMISS WITHOUT CHANGING P-COUNTER
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	SRLS	R2,2
	RBT	R2,SQUEUE
	J	EXEC

:	Here to dismiss - Update p-counter
EXDIS	HS	0
	IF	DB.CPU
	IF	DB.CLK
	IF	ISIS
	LHL	R10,LO.CLK,,		:UPDATE LAST DISMISS TIME FROM SLOT 0
	LHL	R10,SEGF,R10,		:LOCAL CLOCK
	ELSE	:not ISIS
	L	R10,FASTC,,		:UPDATE LAST DISMISS TIME	###OAS
	EI	:ISIS
	ST	R10,EXCTM1,,		:FOR TIME SPENT IN EXEC PROCESSING#OAS
	EI	:DB.CLK
	JAL	R10,CPUTCP		:RECORD CPUTIL STATS FOR ROUTINE
	EI	:DB.CPU			: JUST FINISHED			###OAS

	LHL	R2,PROCID		:HERE TO DISMISS - UPDATE P-COUNTER
	ST	R0,QEXEC,R2
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	SRHLS	R2,2			:CLEAR RUN BIT
	RBT	R2,SQUEUE
	J	EXEC

:	Here to yield - Don't update pc...and don't clear run bit
EXYLDM	HS	0
	IF	DB.CPU
	IF	DB.CLK
	IF	ISIS
	LHL	R10,LO.CLK,,		:UPDATE LAST DISMISS TIME FROM SLOT 0
	LHL	R10,SEGF,R10,		:LOCAL CLOCK
	ELSE	:not ISIS
	L	R10,FASTC,,		:UPDATE LAST DISMISS TIME	###OAS
	EI	:ISIS
	ST	R10,EXCTM1,,		:FOR TIME SPENT IN EXEC PROCESSING#OAS
	EI	:DB.CLK
	JAL	R10,CPUTCP		:RECORD CPUTIL STATS FOR ROUTINE
	EI	:DB.CPU			: JUST FINISHED			###OAS

	LHL	R2,PROCID		:HERE TO YIELD - DON'TUPDATE PC...
					:AND DONT CLEAR RUN BIT
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	J	EXEC

:	Here to yield - Update pc...but don't clear run bit
EXYLD	HS	0
	IF	DB.CPU
	IF	DB.CLK
	IF	ISIS
	LHL	R10,LO.CLK,,		:UPDATE LAST DISMISS TIME FROM SLOT 0
	LHL	R10,SEGF,R10,		:LOCAL CLOCK
	ELSE	:not ISIS
	L	R10,FASTC,,		:UPDATE LAST DISMISS TIME	###OAS
	EI	:ISIS
	ST	R10,EXCTM1,,		:FOR TIME SPENT IN EXEC PROCESSING#OAS
	EI	:DB.CLK
	JAL	R10,CPUTCP		:RECORD CPUTIL STATS FOR ROUTINE
	EI	:DB.CPU			: JUST FINISHED			###OAS

	LHL	R2,PROCID		:HERE TO YIELD - UPDATE PC...
	ST	R0,QEXEC,R2		:BUT DONT CLEAR RUN BIT
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	J	EXEC

	IF	DB.TRC
EXEPSW	WC	1000,EXE2		:ENABLE UPSW TRACE OPTION
	SYAD(EXEPSW)
	ELSE	:NOT DB.TRC
EXEPSW	WC	0,EXE2			:NORMAL MODE, NO TRACE
	EI	:DB.TRC
	
::*********************************************************************
::
::	SUBROUTINE:	CPRHWM:
::	FUNCTION:	COMPUTE PROCESS HIGH-WATER MARK.
::			THIS ROUTINE DETERMINES IF THE HIGH-WATER MARK
::			FOR A PROCESS HAS BEEN EXCEEDED, AND STORES A
::			NEW VALUE IF TRUE.
::	CALLING SEQ:	JAL	R8,CPRHWM
::	INPUT:		R2 = CURRENT PROCESS NUMBER
::	DESTROYED:	R1
::
::*********************************************************************

CPRHWM	HS	0
	L	R1,FASTC,,
	S	R1,PROTIM,R2		:COMPUTE PROCESS EXECUTION TIME
	AM	R1,PACTIM,R2		:AND ADD TO PROCESS TIME ACCUMULATOR
	C	R1,PROHWM,R2		:NEW HIGH-WATER MARK?
	JLER	R8			:NO
	ST	R1,PROHWM,R2		:YES - SAVE
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	MPRTIM:
::	FUNCTION:	SAVES THE CUMMULATIVE TIMES SPENT IN THE DIFFERENT
::			PROCESSES INTO PSVTIM, ZEROES OUT THE ACCUMULATORS
::			PACTIM, AND RETURNS.
::	CALLING SEQ:	JAL	R10,MPRTIM  CALLED BY THE 1-MINUTE PROCESS.
::
::*********************************************************************

MPRTIM	HS	0
	LIS	R0,0			:TO CLEAR ACCUMULATORS
	LHI	R1,1F*4			:MAX NUMBER OF PROCESSES
	LHI	R3,1F*2
MPRTI1	L	R2,PACTIM,R1
	STH	R2,PSVTIM,R3		:SAVE THE TIMES SPENT IN EACH PROCESS
	ST	R0,PACTIM,R1		:AND ZERO OUT ACCUMULATOR
	SIS	R1,4			:DECREMENT INDEX
	SIS	R3,2
	JGEBS	MPRTI1			:AND LOOP BACK IF MORE
	JR	R10			:RETURN

	SUBTTL	EXEC (SPIDER - Schedule RMAKE, RTD, DISPI, SUP and SWITCH)

::*********************************************************************
::
::	PROCESS:	SPIDER:
::	FUNCTION:	Main Node Code data handling process.
::			Schedules RMAKE, RTD, DISPI, SUP and SWITCH.
::	SCHEDULED:	Every pass through the top of the EXEC loop.
::
::*********************************************************************

SPIDER	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)			:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(SPIDER)			:DEFINE CPUTIL ENTRY		###OAS
	EI	:DB.CPU

	IF	SUPER
	JAL	R10,SUPOUT,,		:MOVE OUTBOUND SUP DATA
	GL 	SUPOUT
	EI	:SUPER

	IF	KERNEL&(1-T2GATE)	:Gateway has no Kernel I/O	
	JAL	R10,KEROPS,,		:MOVE OUTBOUND KERNEL DATA
	GL	KEROPS			:(KRORET MOVED TO XHOSTS)	###OAS
	EI	:KERNEL&(1-T2GATE)

	IF	ISIS
	JAL	R10,DISOUT,,		:MOVE OUTBOUND DISPATCHER DATA
	GL	DISOUT
	EI	:ISIS

	LIS	R2,0
SPD2	L	R3,ALINKS,R2		:COPY ALINKS TO LKMAKE
	ST	R3,LKMAKE,R2
	AIS	R2,4
	CI	R2,LKSIZE
	JL	SPD2

SPDRTD	LIS	R2,0
	LIS	R4,0
SPD3	L	R3,LKTEAR,R2		:COPY LKTEAR TO LKSRVD
	ST	R3,LKSRVD,R2
	OR	R4,R3
	AIS	R2,4
	CI	R2,LKSIZE
	JL	SPD3
	LR	R4,R4		:ALL ZERO ?
	JE	SPDRMK
:	standard set up for jump to biddy
	LI	R4,LKSIZE
	LA	R3,LKSRVD
	JAL	R9,BIDDY
	J	SPIRTR			:RTEAR NEEDS A FAR JUMP WHEN
	J	SPDRMK			: CONFIG. IS BIG		###AL
SPIRTR	J	RTEAR,,			:				###AL
	GL	RTEAR

SPDRMK	LIS	R2,0
	LIS	R4,0
SPD4	L	R3,LKMAKE,R2		:COPY LKMAKE TO LKSRVD
	ST	R3,LKSRVD,R2
	OR	R4,R3
	AIS	R2,4
	CI	R2,LKSIZE
	JL	SPD4
	LR	R4,R4			:ALL ZERO ?
	JE	SPIDE1
:	standard set up for jump to biddy	
	LI	R4,LKSIZE
	LA	R3,LKSRVD
	JAL	R9,BIDDY
	J	SPIRMK			:IMME. RET CALL RMAKE ##AL
	J	SPDRTD
SPIRMK	J	RMAKE,,			:CALL RMAKE
	GL	RMAKE

SPIDE1	LIS	R2,0
	LIS	R4,0
SPD5	O	R4,LKTEAR,R2		:CHECK RTEAR
	AIS	R2,4
	CI	R2,LKSIZE
	JL	SPD5
	LR	R4,R4			:ALL ZERO ?
	JN	SPDRTD			:NO, LOOP

	IF	KERNEL&(1-T2GATE)	:Gateway has no Kernel I/O	
	JAL	R10,KERIPS,,		:MOVE INBOUND KERNEL DATA
	GL	KERIPS

	IF	DB.CPU
	JALMAC(CPUTIZ)			:CATCH KERIN RETURN DISPATCH
	CPUTNM(KRIRET)			:CREATE CUPTIL ENTRY FOR KERIN RETURN
	EI	:DB.CPU
	EI	:KERNEL&(1-T2GATE)

	IF	SUPER
	JAL	R10,SUPIN,,		:MOVE INBOUND SUP DATA
	GL	SUPIN
	JAL	R10,SUPBPS,,		:RELIEVE BACKPRESSURE ON SUP PORTS
	GL	SUPBPS
	EI	:SUPER

	IF	ISIS
	JAL	R10,DISIN,,		:MOVE INBOUND DISPATCHER DATA
	GL	DISIN
	IF	T2GATE
	JAL	R10,GDB3IN,,
	GL	GDB3IN
	EI	:T2GATE
	EI	:ISIS

	IF	DB.CPU
	JALMAC(CPUTIZ)			:START CPUTIL FOR SPIDER RETURN	###OAS
	CPUTNM(SPDRET)			:DEFINE SPDRET CPUTIL ENTRY	###OAS
	EI	:DB.CPU
 
	LHI	R1,01F-PSWICH		:SCHEDULE SWITCH
	SBT	R1,SQUEUE
	LA	R0,SPIDER
	J	EXDIS			:AND RETURN TO EXEC LOOP

SWIRET	HS	0			:SWITCH RETURNS HERE
	IF	DB.DEB
	L	R0,ALINKS		:ANY ACTIVE LINKS?
	JNFS	SPIDE2			:YES
	L	R0,FASTC,,		:NO - DON'T WANT RMAKE HIGH-WATER MARK
	ST	R0,RMKTIM		: BASED	ON NO LINKS ACTIVE...
	EI	:DB.DEB

SPIDE2	LA	R0,SWITCH,,
	J	EXDIS			:RETURN TO EXEC LOOP

	SUBTTL 	EXEC (Periodic processes)


::*********************************************************************
::
::	PROCESS:	G250MZ:
::	FUNCTION:	INITIAL RUN THROUGH Q-SEC LOGIC INITIALIZES ASYNC
::			OR RUN APPLY BACKPRESSURE 	7/02/87	###EV
::
::*********************************************************************
	IF	SOLOCS
G250MZ	HS	0
	JAL	R10,IZASYN,,		:INITIALIZE ASYNC
	IF	TELEX			:###wjl
	JAL	R0,TINIT,,		:BUILD TELEX PVC CIRCUITS
	GL	TINIT
	EI	:TELEX
	LA	R0,G250MS		:SUBSEQUENT EXECUTIONS AT G250MS
	J	EXDIS			:RETURN TO EXEC LOOP
	EI	:SOLOCS

	IF	APLYBP
G250AB	JAL	R10,APMX,,
	GL	APMX
	LA	R0,G250AB		:SUBSEQUENT EXECUTIONS AT G250AB
	J	EXDIS			:RETURN TO EXEC LOOP
	EI	:APLYBP			:7/14/87			###EV

	IF	SOLOCS			:continue Solo consat block
::*********************************************************************
::
::	PROCESS:	G250MS:
::	FUNCTION:	QUARTER-SECOND LOGIC USED BY THE SOLOCONSAT
::	Services performed are:
::		TLXBRK	check for TELEX ports in output break state
::		TYQSEC	checks green ball status
::		PVCCTL	service periodic PVC stuff
::		M.MUX	multiplex subport data into MPVC pseudo port stream
::
::*********************************************************************

G250MS	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)			:account for consat quarter sec logic
	CPUTNM(G250MS)			:define entry for consat qsec logic
	EI	:DB.CPU
	IF 	PVC:
	IF	TELEX			:###wjl
	LI	R0,G250MT		:RE-ENTRY POINT
	ST	R0,CSNEXT,,		:FOR CSDISM
	J	TLXBRK,,		:TELEX BREAK
	GL	TLXBRK
	EI	:TELEX
G250MT	HS	0
	LI	R0,G250M0		:RE-ENTRY POINT
	ST	R0,CSNEXT,,		:FOR CSDISM
	EI	:PVC
	J	TYQSEC,,		:TYQSEC RETURNS WITH CSDISM
	GL	TYQSEC			: TO EXEC LOOP
G250M0	HS	0
	IF	PVC
	IF	NMPVC			:set resume addr to continue w/ M.MUX
	LI	R0,G250M1
	ELSE	:NOT NMPVC		:otherwise, end with PVCCTL
	LIS	R0,0
	EI	:NMPVC
	ST	R0,CSNEXT,,		:set resume address
	J	PVCCTL,,		:look for PVC ports timing out
	GL	PVCCTL
	EI	:PVC
	IF	NMPVC:
G250M1	HS	0
	LI	R0,G250M2		:resume after M.MUX call
	ST	R0,CSNEXT,,
	GL	MPVCST
	JAL	R10,MPVCST,,		:set up for MPVCLN--save LOGING array
	J	M.MUX,,			:service subports into pseudo port
	GL	M.MUX
G250M2	HS	0
	LIS	R0,0			:tell CSDISM to quit on this one
	ST	R0,CSNEXT,,
	J	MPVCLN,,		:check for LOGING bits that went down
	GL	MPVCLN			:and return .LGBUF's for such ports
	EI	:NMPVC
	EI	:SOLOCS

::*********************************************************************
::
::	PROCESS:	G500MS:
::	FUNCTION:	HALF-SECOND LOGIC
::
::*********************************************************************

G500MS	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)			:START CPUTIL FOR THIS ROUTINE
	CPUTNM(G500MS)			:DEFINE THIS CPUTIL ENTRY
	EI	:DB.CPU
	JAL	R10,CKOVLD,,		:CHECK FOR OVERLOADED LINKS
	GL	CKOVLD
	JAL	R10,BPMX,,		:SYNC-LINE BACKPRESSURE
	GL	BPMX
	IF	ISIS			:DISPATCHER PORT BACKPRESS
	JAL	R10,DISBPS,,
	GL	DISBPS	
	EI	:ISIS
	IF	APLYBP
	JAL	R10,STRBPR,,		:Starlink Apply Backpressure (relief)
	GL	STRBPR
	EI	:APLYBP (STRHUB!STRRMT)
	IF	1-(STRRMT!STRHUB)	:EVERY 4 SEC SEND DUMMY IF
					: STRRMT OR STRHUB ##AL
	JAL	R10,LNXDUM		:FORCE XMISSION OF DUMMY RECS
	GL	LNXDUM
	EI	:1-(STRRMT!STRHUB)
	IF	SOLOCS
	IF	DB.CPU
	JALMAC(CPUTIZ)			:START CPUTIL FOR THIS ROUTINE
	CPUTNM(HANGAN)			:DEFINE HANGAN RETURN CPUTIL ENTRY
	EI	:DB.CPU
	J	HANGAN,,		:RUN TYMSAT HANG/ANSWER ROUTINE
	GL	HANGAN
HANRET	HS	0			:HANG/ANSWER RETURNS HERE
	EI	:SOLOCS
	LHL	R0,XRYRUN,,		:DOES XRAY WANT TO DUMP OUTPUT?
	JEFS	G500M1			:NO
	LHI	R0,01F-PXRAY		:YES, SCHEDULE IT
	SBT	R0,SQUEUE
	LHL	R0,XUSIUA,,		:PUT EVERY XRAY USER
	STH	R0,XQUEM,,		:INTO THE QUEUE
G500M1	HS	0
	IF	DB56KB
	JAL	R10,KB56DB		:CHECK ON SIO LINES EVERY 1/2 SEC
	EI	:DB56KB
	IF	DB.CPU
	JALMAC(CPUTIZ)			:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(G500RT)			:DEFINE G500RT RETURN CPUTIL ENTRY#OAS
	EI	:DB.CPU
	LA	R0,G500MS		:NECESSARY BECAUSE BPMX MODIFIES QEXEC
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G01SEC:
::	FUNCTION:	ONE SECOND LOGIC
::
::*********************************************************************

G01SEC	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)			:START CPUTIL FOR THIS ROUTINE
	CPUTNM(G01SEC)			:DEFINE THIS CPUTIL ENTRY
	EI	:DB.CPU
	IF	SOLOCS
	IF	NMPVC
	LI	R0,G1SECR
	ST	R0,CSNEXT,,
	J	M.PER,,			:MPVC PERIODIC LOGIC
	GL	M.PER
G1SECR	HS	0
	LIS	R0,0
	ST	R0,CSNEXT,,
	EI	:NMPVC
	EI	:SOLOCS
	L	R0,SLOWC,,
	C	R0,MTRTIM		:RUN PERFORMANCE MEASUREMENT LOGIC?
	JL	G01PER			:NO
GOPFM	HS	0	
	SYAD(GOPFM )
	AHI	R0,$A60			:YES, 60 SECONDS FROM NOW
	ST	R0,MTRTIM
	JAL	R10,EXCAVG		:COMPUTE EXEC LOOP AVERAGE
:       SPAM issues SVC immediately before value changes                ###sdw
        IF      SPAM                                                    ###dmj
        LH      R0,SPMINI               :Check if SPAM is initialized   ###dmj
        JNFS    SPMXIT                  :Skip if so                     ###dmj
        LA      R0,NS.PCO,,             :Address of physical CPS stats  ###dmj
        SVC     SYS,$A 53               :Inform Kernel of address       ###dmj
        HC      0,0                     :Immediate return - invalid addr###dmj
        LCS     R0,1                    :Set Initialize Complete        ###dmj
        STH     R0,SPMINI               :                               ###dmj
SPMXIT  EQ      .                       :                               ###dmj
        EI      (SPAM)                  :                               ###dmj
	JAL	R10,MTRFIC,,		:MEASURE LINK TRAFFIC
	GL	MTRFIC
	JAL	R10,MPRTIM		:MEASURE TIME SPENT IN EACH PROCESS
	JAL	R10,LKVOLT		:TEST FOR LINKS OVERLOADED
	GL	LKVOLT
:	SCHEDULE LDRPRT SYNCHRONOUSLY WITH MTRFIC FOR KS PKT STATS	###JHL
:	LDRINT is a Tymfile parameter when can be used to specify
:	line diagnostic reporting interval in testing environment.
	DEFAULT(LDRINT,4)		:LDRINT Tymfile parameter	###wjl
	LIS	R0,1			:SCHEDULE LDRPRT EVERY LDRINT MINS.
	AHM	R0,LDRTIM		:BUMP THE COUNTER
	JL	G01PER			:STILL NEG--DON'T RUN LDRPRT
	LCS	R0,LDRINT		:REINIT THE SCHEDULING CELL	###wjl
	STH	R0,LDRTIM		:STORE A MINUS LDRINT THERE
	JAL	R10,LDRPRT		:RUN LINE DIAGNOSTICS
	GL	LDRPRT
:	LDRPRT WAS SCHEDULED FROM G04MIN BEFORE 5.02			###JHL
G01PER	HS	0
	L	R1,LINSPT
	JEFS	G01PE1
	NI	R1,SYNLNA		:NO SIO LINES
	JEFS	G01PE1
	ST	R1,LINSPD		:ALERT SYLVER TO PREFORM LINE SPEED
					: CALC'S FOR LINES REQUESTED
	LIS	R1,0			:RESET SPEED REQUEST BITS
G01PE1	ST	R1,LINSPT
	LIS	R1,1
	AM	R1,S1SLOC		:INCREMENT OCCURRENCES OF 1-SEC LOGIC
	LHL	R1,S1SLOC+2

:	CONSOLE OUTPUT DONE IN 'SCHED' ROUTINE IF NOT ISIS, ELSE IN ISIS KERNEL
	THI	R1,3			:EVERY 4 SECONDS WANT TO FLASH 'MACHID'
	JN	G01SE0			:..NOT THIS TIME		###wjl
	IF	ISIS&(1-T2GATE)		:				###wjl
	LHL	R0,MACHID		:HO digit of node number	###wjl
	STB	R0,KDISP+1,,		:ISIS ver 5 (and for us)	###wjl
	IF	IKNRNG			:ISIS ver 6 and above uses SVC	###wjl
	SVC	SYS,$A40		:				###wjl
	EI	:IKNRNG			:				###wjl
	EI	:ISIS&(1-T2GATE)	:				###wjl
	IF	SOLOCS
	LI	R0,0C0000		:CONSAT DISPLAYS A 'C'
	ELSE
	LI	R0,0A0000		:SWITCHER DISPLAYS A 'A'
	EI	:CONSAT
	ST	R0,CONSOL+4
	L	R0,MACHID		:MAN-READABLE HOST, NODE NUMBER DISPLAY
	J	G01SE2			:DISPLAY COMPUTED, BRANCH

G01SE0	LHL	R0,CRHCNT		:COMPUTE CONSOLE DISPLAY
	THI	R0,0FFF0		:CRASH COUNT GREATER THAN 15D?
	JEFS	G01SE5			:NO
	LIS	R0,0F			:YES, JUST DISPLAY 15D
G01SE5	SLHLS	R0,4			:SHIFT UP ONE NIBBLE
	LH	R1,TVRSUP,,
	EXHR	R1,R1
	ST	R1,CONSOL+4		:STORE SUP NUMBER FOR CONSOL DISPLAY
	IF	ISIS&(1-T2GATE)		:Gateway has no Kernel I/O	
	LHL	R1,KDISP,,
	ELSE	:NOT ISIS
	LHL	R1,CONSOL+2
	EI	:ISIS&(1-T2GATE)
	THI	R1,0F
	JNFS	G01SE1

	IF	SUPER			:EVERY 4 SEC UPDATE NETWORK STATUS
	AH	R0,TVRSTT		: DISPLAY
	ELSE	:not SUPER
	AIS	R0,1
	LH	R1,TVRSUP		:IS NODE IN THE NET?
	JEFS	G01SE1			:NOT IN NET
	AIS	R0,1			:STATUS OF '2' FOR NODE IN THE NET
	EI	:SUPER

G01SE1	HS	0
	IF	KERNEL
	LB	R1,HNPORT+1		:NUMBER OF TERMINATIONS ON KERNEL HOST
	ELSE	:NOT KERNEL
	IF	SOLOCS
	LA	R4,ASYACP,,		:COUNT NUMBER OF ASYNC PORTS ACTIVE
	LHI	R2,NACARD*2		:(# OF HALFWORDS TO COUNT ZERO BITS)
	LR	R5,R0			:PRESERVE R0, USED BY 'COUNT0'
	JAL	R9,COUNT0,,		:COUNT NUMBER OF ASYNC PORTS ACTIVE
	GL	COUNT0
	LR	R0,R5
	LR	R1,R3			:COUNT RETURNED IN R3...
	ELSE	:NOT SOLOCS
	LB	R1,TERMIN+1
	EI	:SOLOCS
	EI	:KERNEL
	EXBR	R1,R1			:INCLUDE TERMINATIONS
	OR	R0,R1			: IN WORKING DISPLAY
	LHL	R1,PASTHR
	EXHR	R1,R1			:# PASSTHROUGHS IN HIGH-ORDER HALFWORD
	OR	R0,R1			: OF CONSOLE DISPLAY
	IF	ISIS&(1-T2GATE)		:Gateway does not use		
	IF	IKNRNG
	SVC	SYS,$A40		:DISPLAY CRASH COUNT, STATUS
	EI	:IKNRNG
	STB	R0,KDISP+1,,		:CRASH COUNT, NET STATUS FLASHER
	SRLS	R0,8			:PASSTHRU, PORT COUNTS TO LO-ORDER HW
	EI	:ISIS&(1-T2GATE)
G01SE2	ST	R0,CONSOL		:CONSOLE OUTPUT DONE IN 'SCHED' ROUTINE
					:IF NOT ISIS, ELSE HANDLED BY ISIS KERN
	IF	1-ISIS			:ONLY PROCESS DMA TIMEOUTS ON SOLO MACH
	LH	R0,DMAFLG		:MAC INTERRUPTS CAUSED BY DMA TIMEOUTS?
	JE	G01SE3			:NOTHING
	LIS	R0,0			:YES, CLEAR DMA CELL
	STH	R0,DMAFLG
	IF	SILINS
	LHI	R1,SILINS*10
	LCS	R0,4			:STORE A -4
G01SE4	STH	R0,SIOSTT+8,R1,		: INTO SIOSTT FOR EVERY SIO LINE
	SHI	R1,10
	JGEBS	G01SE4
	JAL	R10,SIOIZ		:REINITIALIZE ALL SIO LINES
	GL	SIOIZ
	EI	:SILINS
	LHI	R0,NR.DMA		:MAKE REPORT TO SUPERVISOR AND CRYPTO
	STH	R0,SUPMBF
	LHI	R0,SILINS+8000		:SEND NUMBER OF SIO LINES
	STH	R0,SUPMBF+2
	LHL	R0,SMACSV+2		:GET LO HW OF MAC INTERRUPT STATUS REG
	STH	R0,SUPMBF+4		:AND SEND THAT TO SUP
	JAL	R10,SUP12,,
	EI	:1-ISIS
	GL	SUP12
G01SE3	LA	R0,G01SEC
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G02SEC:
::	FUNCTION:	TWO-SECOND LOGIC
::
::*********************************************************************

G02SEC	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)
	CPUTNM(G02SEC)
	EI	:DB.CPU
	JAL	R10,G02SLK		:TEST FOR INOPERATIVE LINES
	GL	G02SLK
	IF	SILINS
	JAL	R10,SIOIZ		:SEE IF ANY SIO LINES NEED
	GL	SIOIZ			: INITIALIZATION
	EI	:SILINS
:	UPDATE GUSH AND TRIKLE ARRAYS. TRIKLE GETS OR'D INTO GUSH
:	AND THEN CLEARED.
	LIS	R0,0
	LHI	R1,-TCHANS/8
G02SC1	L	R2,EGUSH,R1,
	O	R2,ETRIKL,R1,
	ST	R2,EGUSH,R1,		:GUSH = GUSH + TRIKLE
	ST	R0,ETRIKL,R1,		:CLEAR TRIKLE
	AIS	R1,4
	JLBS	G02SC1
	IF	SOLOCS			:CONSAT				###wjl
	DEFAULT(NHNGBK,0)		:TYMFILE parameter		###wjl
	IF	1-NHNGBK		:Hang-on-break logic		###wjl
	LI	R0,G02SC2		:re-entry point			###wjl
	ST	R0,CSNEXT,,		:for CSDISM			###wjl
	J	TWOSEC,,		:TWOSEC returns with CSDISM	###wjl
	GL	TWOSEC			:to EXEC loop			###wjl
G02SC2	HS	0			:				###wjl
	LIS	R0,0			:clear CSDISM			###wjl
	ST	R0,CSNEXT,,		:				###wjl
	EI	:1-NHNGBK
	EI	:SOLOCS
	IF	1-ISIS			:ISIS KEEPS THE LOG IF IT CAN
	IF	ZITEL			:ITS A MAC2 FUNCTION
	JAL	R0,MCHECK		:READ MEMORY BIT ERROR LOG
	GL	MCHECK
	EI	:ZITEL
	EI	:1-ISIS
	IF	1-BUBLAB		:ONLY IF NOT LAB MACHINE
	LCS	R0,1
	AHM	R0,XPWRCT,,
	JGFS	G02BL2			:BUMP TIMEOUT, TTY USER ACCESS CONTROL
	LI	R1,TTYXD		:POINTER TO TTY USER'S DATA BLOCK
	LIS	R0,1
	STH	R0,XPOWER,R1
	EI	:1-BUBLAB
G02BL2	LIS	R0,0			:UPDATE BUFFERLET USAGE HISTOGRAMS
	LHI	R1,$A30			:HW INDEX FOR 16 SAMPLES OF BFLTHS
G02BL1	LHL	R2,BFLTHS,R1,		:GET NEXT HISTOGRAM
	STH	R0,BFLTHS,R1,		:CLEAR LITTLE HISTOGRAM
	AM	R2,BFLTHG,R1,R1		:AND ADD INTO BIG HISTOGRAM
	JLFS	G02BLT			:HISTOGRAM WRAPPED, CLEAR IT
	SIS	R1,2			:DECREMENT INDEX
	JGEBS	G02BL1			:AND REPEAT
	J	EXDISM

G02BLT	LHI	R1,$A30			:CLEAR OUT BIG HISTOGRAM
G02BL3	ST	R0,BFLTHG,R1,R1
	SIS	R1,2
	JGEBS	G02BL3
	J	EXDISM

::*********************************************************************
::
::	PROCESS:	G04SEC:
::	FUNCTION:	4-SECOND LOGIC
::
::*********************************************************************

G04SEC	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)
	CPUTNM(G04SEC)
	EI	:DB.CPU


	JAL	R10,LNCHCK		:CHECK FOR NO RECORDS RECEIVED
	GL	LNCHCK
	IF	SCBSYO			:enable-busy-out switch
	IF	SOLOCS
	JAL	R10,A.BUSY,,		:ASYNC PORT-BUSY PROCESSING
	GL	A.BUSY
	EI	:SOLOCS
	EI	:SCBSYO

	IF	STRRMT!STRHUB		:EVERY 4 SEC SEND DUMMY IF
					: STRRMT OR STRHUB ##AL
	JAL	R10,LNXDUM		:FORCE XMISSION OF DUMMY RECS
	GL	LNXDUM
	EI	:STRRMT!STRHUB

	IF	1-T2GATE		:no down line loading for GW
	LH	R0,DLDFLG		:DID LEP REQUEST A NODE BOOT?
	JGE	G04S00			:NO
	SIS	R0,1			:DECREMENT FLAG
	STH	R0,DLDFLG		:AND RESTORE IT
	AIS	R0,2			:FIRST TIME G04SEC HAS NOTICED THIS?
	JEFS	G04S00			:YES, DEFER BOOT FOR NEXT 4-SEC PERIOD
	LIS	R0,0			:FLAG MUST HAVE BEEN -2...CLEAR IT
	STH	R0,DLDFLG
	IF	ISIS	
	IF	IKNRNG
	SVC	SYS,$A39
	ELSE	:not IKNRNG
	SBT	R0,KDISP,,		:DISABLE ISIS UPDATE OF WATCHDOG TIMER
	EI	:not IKNRNG
	ELSE	:not ISIS
	SVC	0F,SV.BOT		:SOLO SVC ATTEMPTS JUMP TO ABSOLUTE 5A
	LIS	R0,1			:HERE IF SVC FAILED
	STB	R0,WATCHD		:DISABLE UPDATE OF WATCHDOG TIMER
	EI	:ISIS
	EI	:1-T2GATE		:##al

G04S00	IF	STRRMT
	LHL	R0,RMRSCT		:Remote reset timing counter
	JEFS	GRMRES
	AIS	R0,1			:Not ready to send reset yet
	STH	R0,RMRSCT		:Decrement counter and store
	JFS	G04SE1
GRMRES	LCS	R0,RSTFRQ		:re-initialize counter
	STH	R0,RMRSCT
	JAL	R10,SNDRST		:Send initial reset
	GL	SNDRST			:## AL
	EI	:STRRMT			:Continue
G04SE1	LA	R0,G04SEC
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G08SEC:
::	FUNCTION:	8-SECOND LOGIC
::
::*********************************************************************

G08SEC	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)
	CPUTNM(G08SEC)
	EI	:DB.CPU
	IF	SUPER
	JAL	R10,G08SUP,,		:TEST FOR LAZY SUPER
	GL	G08SUP
	EI	:SUPER
	IF	SIORNG
	JAL	R10,SIRSCK,,		:REPORT KERNEL HOST DOWN
	GL	SIRSCK			: IF SIO RING FAILS
	EI	:SIORNG
	IF	BFLTMR			:buffer delay timing by spec char pairs
	LHL	R0,BFDSCH,,		:###JHL
	SIS	R0,1			:decrement scheduling cell
	JGFS	G08S10			:spring when reaches zero, and reset it
	JAL	R10,BFRUPD		:update the channel array
	GL	BFRUPD			: for sending pairs
	LIS	R0,BFDFRQ		:reset to top value
G08S10	STH	R0,BFDSCH,,		:store current value
	EI	:BFLTMR			:###jhl
	LIS	R0,0			:CLEAR COUNTERS FOR PRIORITY
	LHI	R1,NLINKS*2-2		:CIRCUIT LOGIC
G08S20	STH	R0,NRMCNT,R1,
	STH	R0,PRICNT,R1,
	SIS	R1,2
	JGEBS	G08S20			:.-0A
	STH	R0,XBREAK,,		:XBREAK SET WHEN XRAY SENSES BREAK
	IF	SOLOCS
	GL	RBTIME
	J	RBTIME,,		:DISMISSES TO EXEC
	EI	:SOLOCS
	IF	T2GATE
	LHI	R5,DISZFL		:Start at dispatcher range
	LHI	R1,NDP			:and check all the dispatcher ports
	JAL	R10,CNTPRT,,		:Count available ports	###ev
	GL	CNTPRT
	STH	R3,GAVPTS		:and store new available port count
        LB      R1,G0DFG                :have Inet supe?
        JEFS    G08S22                  :nope
        LHL     R1,TVRBUF               :have Hnet supe?
        JN      G08S23                  :skip if yes
G08S22  LIS     R3,2                    :save host is shut
        CLB     R3,HSTAT                :what was old status
        JE      G08EXI                  :nope already reported shut
        STB     R3,HSTAT                :save new
        JAL     R10,GHSTST,,            :report as shut
        JAL     R10,SUP11,,             :to both supes
        GL      SUP11
        JFS     G08EXI
G08S23	JAL	R10,GCKPST,,		:report msg to disp. port 0
	GL	GCKPST			: (Inet sup) if changed. Report
G08EXI
	EI	:T2GATE##AL		: to Inet sup if out of port.
	LA	R0,G08SEC
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G16SEC:
::	FUNCTION::	16-SECOND LOGIC (FOR CONSAT ONLY)
::
::*********************************************************************

	IF	SOLOCS
G16SEC	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)
	CPUTNM(G16SEC)
	EI	:DB.CPU
	J	SEC16,,
	GL	SEC16
	EI	:SOLOCS

::*********************************************************************
::
::	PROCESS:	G30SEC:
::	FUNCTION:	30-SECOND LOGIC
::
::*********************************************************************

G30SEC	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)
	CPUTNM(G30SEC)
	EI	:DB.CPU
	JAL	R0,CHSUPD,,		:UPDATE CHS ARRAY
	GL	CHSUPD
	JAL	R10,DETOUT,,		:CHECK DETACHED PORTS
	GL	DETOUT
	IF	WHEREE
	TS	WHESEM,,
	JNFS	G30WH1
G30WH4	LIS	R0,0
	LI	R1,WHTSIZ
G30WH2	SIS	R1,4
	JL	EXDISM
	ST	R0,WHTABL,R1,
	JBS	G30WH2
G30WH1	TS	WHSEM2,,
	JN	EXDISM
	LA	R1,WHTABL+(WHTSIZ-1)*2,,
	LA	R2,WHTABS+(WHTSIZ-1)*2,,
	LI	R3,10*(WHTSIZ-1)
	COPY	R1,R3
	EI	:WHERE
	J	EXDISM

::*********************************************************************
::
::	PROCESS:	G01MIN:
::	FUNCTION:	1-MINUTE LOGIC
::
::*********************************************************************

G01MIN	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)
	CPUTNM(G01MIN)
	EI	:DB.CPU
	LHL	R0,FASTC+2,,		:MEASURE INTERVAL, 1-MIN EXECUTIONS
	LHL	R1,MINSAV
	STH	R0,MINSAV
	SR	R0,R1
	JGEFS	G01MI2
	AI	R0,10000
G01MI2	STH	R0,MININT
	LHI	R0,-NR.DGN*6		:RE-INIT NETDGN COUNTER WHICH THROTTLES
	ST	R0,NETDCT,,		:DIAG NODE REPORTS (NR.DGN) AT 6/MIN
	JAL	R10,G01MLS		:REINSTATE SUSPENDED LINES
	GL	G01MLS
	JAL	R10,CRTOUT,,		:PROCESS CIRCUIT TIMEOUTS
	GL	CRTOUT
	IF	REBILD
	JAL	R10,RBDOUT,,		:REBUILD TIME-OUT		###GT
	GL	RBDOUT
	EI	:REBILD
	IF	ISIS
:	CLEAR ACTIVITY COUNTERS
	LIS	R0,0
	IF	(1-T2GATE)		:Exclude for Gateway
	LHI	R1,(NUSLT-1)*2		:            			###LH
G01MI4	STH	R0,SCLCNT,R1		:CLEAR CIRCUITS/MINUTE COUNT FOR SLOT
	STH	R0,SMLCNT,R1		:CLEAR SLOT REPORTS/MIN COUNT FOR SLOT
	SIS	R1,2
	JGEBS	G01MI4
	EI	:(1-T2GATE)		:end exclude, Gateway
	IF	RESHST
	LHI	R1,(NHOSTS-1)*2
G01MI6	STH	R0,HCTSCT,R1		:CLEAR CIRCUITS/MINUTE COUNT FOR HOST
	SIS	R1,2
	JGEBS	G01MI6
	LHI	R1,(((NHOSTS+0F)/10)*2)-2
G01MI8	STH	R0,RESHMS,R1		:CLEAR ARRAY WHICH THROTTLES NODE RPTS
	SIS	R1,2
	JGEBS	G01MI8
	EI	:RESHST
	EI	:ISIS
	LA	R0,G01MIN
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G02MIN:
::	FUNCTION:	TWO-MINUTE LOGIC
::
::*********************************************************************

G02MIN	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)
	CPUTNM(G02MIN)
	EI	:DB.CPU
	JAL	R10,SUP0B,,		:send Resources Report to Sup	###wjl
	GL	SUP0B
	IF	SIORNG
:	IF SIO RING DOWN, PERIODICALLY RE-INITIALIZE
	LH	R0,SIRFLG,,		:SIO RING STATUS FLAG
	JNFS	G02M10			:NON-ZERO IF SIO RING UP
	LIS	R0,2
	STH	R0,SIRXIZ,,		:FORCE INITIALIZATION IN 'KERIPS'
G02M10	EI	:SIORNG
:	TEST FOR RECENT TAKEOVER. WE WANT TO REPORT NODE'S LINE RESOURCES
:	2 - 4 MINUTES FOLLOWING TAKEOVER...
	LH	R0,TAKOVR		:CELL SET NEGATIVE WHEN TAKEN OVER
	JE	G02MEX			:NO RECENT TAKEOVERS
	JGFS	G02M20			:2 - 4 MINUTES AGO, MAKE REPORTS
	LIS	R0,1			:0 - 2 MINUTES AGO, SET CELL POSITIVE
	STH	R0,TAKOVR		: FOR NEXT TIME
	J	G02MEX

G02M20	LIS	R0,0
	STH	R0,TAKOVR
	LHL	R0,TVRBUF		:GOT A SUP?
	JE	G02MEX			:NO - DON'T BUFFER THESE...
:	MAKE NODE REPORT TO INDICATE NUMBERS OF--SIO LINES, SYNC LINES,
:	XLINKS, AND TOTAL LINKS.
	LI	R0,(SILINS^18)+((NLINES-SILINS)^10)+(XLINKS^8)+(NLINKS)+80808080
	ST	R0,SUPMBF+2
	LHI	R0,NR.SSX		:REPORT TYPE - NETWORK RESOURCES
	STH	R0,SUPMBF
	JAL	R10,SUP12,,
:	NOW REPORT PORTS AND PASSTHROUGHS
	IF	ISIS
	LI	R0,(NDP^10)+(NPTHR)+80008000
	ELSE	:NOT ISIS
	LI	R0,(NAPORT^10)+(NPTHR)+80008000
	EI	:ISIS
	ST	R0,SUPMBF+2
	LHI	R0,NR.PPT
	STH	R0,SUPMBF		:REPORT TYPE - PORTS AND PASSTHROUGHS
	JAL	R10,SUP12,,
:	REPORT UNUSED LINES...BIT ARRAY, 0 BIT FOR UNUSED
	LCS	R0,1
	ST	R0,SUPMBF+2		:ASSUME ALL LINES USED
	LHI	LN,NLINES-1
G02M22	LHL	R0,NGSVLN,LN,LN
	JNFS	G02M24			:LINE USED
	RBT	LN,SUPMBF+2		:INDICATE THIS LINE UNUSED
G02M24	SIS	LN,1
	JGEBS	G02M22
	LHI	R0,NR.UNL
	STH	R0,SUPMBF		:UNUSED LINES REPORT
	JAL	R10,SUP12,,
:	REPORT FOR EACH USED LINE:
:		HWXSSSSSLLLLLLLLUNNNNNNNNNNNNNNN
:	WHERE H = 1 FOR SIO LINES, 0 FOR SYNC
:	W = 1 FOR T-I WS8
:	X = 1 FOR SATELLITE LINK, 0 FOR TERRESTRIAL
:	SSSSS = LINK SPEED
:	LLLLLLLL = LINE NUMBER
:	U = 1 IF LINE UP, ELSE 0
:	NNNNNNNNNNNNNNN = NEIGHBOR NUMBER
	LHI	LN,NLINES-1
G02M30	LHL	R0,NGSVLN,LN,LN
	JE	G02M50			:LINE UNUSED
	STH	R0,SUPMBF+4		:NEIGHBOR, + 8000 IF UP
	SLL	LN,1
	L	KD,KDLN,LN,LN		:GET LINK DESCRIPTOR
	JGFS	G02M32			:LINK UP
	SRL	LN,1
	LHI	R0,80			:LINK NOT UP, ASSUME SIO LINE
	JFS	G02M34
G02M32	SRL	LN,1
	LB	R0,KSPD,KD		:LINK TYPE, SPEED + 80
G02M34	LHI	R1,-(NLINES-SILINS),LN
	JGEFS	G02M40			:SIO LINE
	NHI	R0,7F			:SYNC LINE, TURN OFF HI-ORDER BIT
G02M40	EXBR	R0,R0
	OI	R0,(NR.LNR^10)+80,LN	:NODE REPORT TYPE, LINE # + 80
	ST	R0,SUPMBF
	JAL	R10,SUP12,,
G02M50	SIS	LN,1			:DO FOR ALL LINES
	JGE	G02M30
:	REPORT TIILNK NEIGHBORS NOT UP...SAME FORMAT AS ABOVE, BUT THE
:	LINE NUMBER FIELD IS -1.
	LHI	KN,NLINKS-1
G02M60	SLL	KN,1
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR ADDRESS
	SRL	KN,1
	GL	KDKN
	LHL	R0,ONDID,KD		:IS THIS AN XLINK?
	JE	G02M70			:YES - IGNORE
	LB	R1,NLAT,KD		:IS LINK UP?
	JNFS	G02M70			:YES - DON'T REPORT
:	GOT TIILNK LINK WITH NO LINES ATTACHED - REPORT IT
	STH	R0,SUPMBF+4		:NEIGHBOR NUMBER
	LB	R1,KSPD,KD		:MAYBE LINK SPEED ALREADY DEFINED
	EXBR	R1,R1
	OI	R1,(NR.LNR^10)+0FF	:REPORT TYPE, LINE # FF
	ST	R1,SUPMBF
	JAL	R10,SUP12,,		:MAKE NODE REPORT
G02M70	SIS	KN,1
	JGE	G02M60			:DO FOR ALL LINKS
G02MEX	HS	0
	LA	R0,G02MIN
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G04MIN:
::	FUNCTION:	FOUR MINUTE LOGIC
::			CALLS LINE DIAGNOSTIC REPORTING PROCESS AND
::			TESTS INTERNAL HOST CRQS FOR TIMEOUTS
::
::*********************************************************************

G04MIN	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ)
	CPUTNM(G04MIN)
	EI	:DB.CPU
	JAL	R10,CKTCON,,		:TEST FOR CIRCUIT BUILDING ERRORS
	GL	CKTCON
	JAL	R11,INTTIM,,		:CHECK TIMEOUT ON INTERNAL HOST PORTS
	GL	INTTIM
	JAL	R11,TEMPRP,,		:TEST FOR TEMP IN ACCEPTABLE RANGE##JHL
	GL	TEMPRP
	IF	1-ISIS
	TS	SFTDMA			:ALLOW MAX OF 1 DMA TIMEOUT PER 4 MIN
	TS	SFTMAC			:ALLOW MAX 1 SOFT-MAC VIOLATION / 4 MIN
	TS	LILCNT			:ALSO LEGAL ILLEGAL INSTRUCTIONS
	TS	ILDVCT			:ALSO ILLEGAL DEVICE INTERRUPTS
	SVC	0F,SV.REG		:refresh registers		###wjl
	EI	:1-ISIS

:	PERFORM ACCOUNTING - EVERY 16 MIN FOR MPVC CONSAT OR 20 MIN FOR GATEWAY
	IF	SOLOCS			:CONSAT only
	IF	NMPVC			:MPVC only
	LHL	R0,CS16MN,,		:EVERY SIXTEEN MINUTES
	JEFS	G16MIN			:yes, perform MPVC accounting
	AIS	R0,1			:no
	STH	R0,CS16MN,,
	J	EXDISM			:dismiss to Exec loop
G16MIN	HS	0
	LCS	R0,3
	STH	R0,CS16MN,,
	J	M.ACCT,,		:MPVC ACCOUNTING, dismiss from CONSAT
	GL	M.ACCT
	ELSE	:NON MPVC CONSAT
	J	EXDISM			:dismiss to Exec loop
	EI	:MPVC

	ELSE	ACCT			:GATEWAY accounting

	LHL	R0,AA20MN,,		:Is it time for 20 minute accounting?
	JEFS	G20MIN			:Yes
	AIS	R0,1			:No, Decrement counter (yes decrement!)
	STH	R0,AA20MN,,
	J	EXDISM			:Dismiss to Exec loop
G20MIN	HS	0			:Accounting 20 minute report
	LCS	R0,4			:Init counter to -5
	STH	R0,AA20MN,,
	JAL	R11,AATIME,,		:Perform periodic accounting
	GL	AATIME
	J	EXDISM			:Dismiss to Exec loop

	ELSE	:NOT CONSAT OR GATEWAY

	J	EXDISM			:Dismiss to Exec loop

	EI	:CONSAT OR GATEWAY	

	SUBTTL  EXEC (Utility routines)

::*********************************************************************
::
::	SUBROUTINE:	BCMOVE:
::	FUNCTION:	MOVE N BYTES OF DATA FROM SOURCE TO DESTINATION
::	CALLING SEQ:	JAL	R8,BCMOVE
::	INPUT:		R1 = SOURCE ADDR
::			R2 = DESTINATION ADDR
::			R3 = BYTE COUNT
::	DESTROYED:	R0 = SCRATCH
::
::*********************************************************************

BCMOVE	HS	0
	LB	R0,0,R1			:MOVE BYTES
	AIS	R1,1
	STB	R0,0,R2
	AIS	R2,1
	SIS	R3,1
	JGBS	BCMOVE
	JR	R8

::*********************************************************************
::
::	SUBROUTINES:	HCLEAR:/HCSET:
::	FUNCTION:	SET N HALF-WORDS TO ZERO OR TO CONTENTS OF R0
::	CALLING SEQ:	R8 = LINK
::	INPUT:		R0 = CONSTANT
::			R1 = DESTINATION ADDR
::			R2 = HW COUNT
::
::*********************************************************************

HCLEAR	LIS	R0,0
HCSET	STH	R0,0,R1			:SET HALF-WORDS
	AIS	R1,2
	SIS	R2,1
	JGBS	HCSET
	JR	R8


::*********************************************************************
::
::	SUBROUTINE:	AAINIT:
::	FUNCTION:	Routine to initialize accounting block pointers array
::	CALLING SEQ:	JAL	R8,AAINIT
::	DESTROYED:	R1,R2
::
::*********************************************************************

	IF	ACCT			
AAINIT	HS	0
	LHI	R2,(NACCTS-1)*4		: Number of addresses to be loaded
	LA	R1,AABLKS,,		: Start of block storage area
AAIN1	ST	R1,AABPNT,R2,		: Store it, last first
	AHI	R1,AADSIZ		: Advance the pointer
	SIS	R2,4			: Move to next table entry
	JGEBS	AAIN1			: Repeat for entire table
	JR	R8
	EI	:ACCT			

::*********************************************************************
::
::	SUBROUTINE:	BIDDY:
::	FUNCTION:	MAGIC BID, DISPATCH, AND YIELD ROUTINE
::	CALLING SEQ:
::			LI	R4,SIZE OF ARRAY IN BYTES
::			LA	R3,ARRAY
::			JAL	R9,BIDDY
::			J	PROCESSING ROUTINE
::			RETURNS HERE IF DATA=0
::
::	OUTPUT:		R2 = LINE OR LINK NUMBER
::
::*********************************************************************

BIDDY	HS	0
	ST	R9,BIDDSV		:SAVE RETURN ADDR

	LIS	R5,0			:R5 = BYTE COUNT
BIDD2	L	R1,0,R3
	JFFO	R1,BIDDY2		:FIND FIRST BIT SET IN R1
	AIS	R3,4
	AIS	R5,4
	CR	R5,R4	
	JL	BIDD2
	J	4,R9			:NO BITS SET IN ARRAY
BIDDY2	RBT	R2,0,R3			:BIT FOUND
	SLLS	R5,3			:FORM LINK OR LINE NUMBER
	OR	R2,R5
	JR	R9
	IF	0:	ELSE
	L	R1,0,R3			:LOAD DATA
	JE	4,R9			:ZERO--no bits set in array.
					: Skip return.
	JFFO	R1,BIDDY2		:FIND FIRST 1 BIT IN R1,
	CRASH.(.BIDCR,R0)		: INDEX RETURNED IN R2
BIDDY2	RBT	R2,0,R3			:RESET IDENTIFIED BIT
	JR	R9			:DISPATCH TO PROCESSING ROUTINE
	EI	:TWONG

:	ENTRY POINT - RETURN FROM DISPATCH
BIDDRT	HS	0
	LIS	R0,0
	ST	R0,ABENPC		:CLEAR MAC INTERRUP HANDLER ADDRESS

	IF	REBILD
	L	R1,HBFTSV		:GET CURRENT CHAR CNT IN HIST BUFS#OAS
	C	R1,HBFTMX		:NEW PEAK			###OAS
	JLEFS	BIDBL2			:NO				###OAS
	ST	R1,HBFTMX		:YES, UPDATE MAX		###OAS
BIDBL2	HS	0
	EI	:REBILD

	L	R1,BFLTSV		:GET CURRENT COUNT OF BUFFERLETS IN USE
	C	R1,BFLTMX		:NEW PEAK?
	JLEFS	BIDBLT			:NO
	ST	R1,BFLTMX		:YES, STORE NEW PEAK
BIDBLT	LIS	R2,1
	SRLS	R1,2			:REDUCE TO HW
	EXBR	R1,R1			:ISOLATE DOWN UPPER BYTE (NOTE WE CAN
	LBR	R1,R1			: ONLY RESOLVE TO 256KB OF BUFFERLETS)
	SRHL	R1,ISCALE		:SCALE DOWN ACCORDING TO TOTAL B'LETS
	GL	ISCALE			: ALLOCATED
	AHM	R2,BFLTHS,R1,R1		:INCREMENT APPROPRIATE CELL
	L	R0,BIDDSV		:SAVE THE ADDR
	SIS	R0,0E			:SERVE NEXT LINK/LINE BY BACKING
					: 14 BYTE INSTRUCTIONS
:	SIS	R0,8
	J	EXYLD			:EXEC RETURNS TO INST PRECEDING CALL

	SUBTTL	EXEC (OOPS - Software error handler)

SVC1ER	TI	R0,0C00			:TEST FOR H-WARE
	JR	R0			:IGNORE IF TRUE
	JAL	R0,OOPS			:ELSE KAPUT

::*********************************************************************
::
::	SUBROUTINE:	OOPS:
::	FUNCTION:	Software error handler
::	CALLING SEQ:	CALL TO OOPS IS SET UP BY THE CRASH MACRO.
::			CALL TO OOPS WILL BE RX1/2 OR RX3 AS REQUIRED.
::	THE CRASH DATA ARE SET UP BY THE CRASH MACRO TO FOLLOW IMMEDIATELY THE
::	JAL,OOPS, AND CONSIST OF 1 OR 2 HW'S, AS FOLLOW:
::		FIRST HW = xxyy
::		WHERE: xx IS A 7-BIT (EVEN) SUBTYPE CODE, WITH THE LO BIT SET
::			IF ANY SPECIAL REGISTERS WERE SPECIFIED IN THE CRASH
::			MACRO CALL.
::			yy IS AN 8-BIT COMMON CRASH CODE
::		2ND HW = aabb ONLY IF THE LO BIT OF xx IS SET.
::			 ELSE IT ISN'T THERE.
::		WHERE: aa AND bb ARE REGISTER NO'S*4
::			aa IS ALWAYS MEANINGFUL
::			bb IS MEANINGFUL ONLY IF NON-0.
::		WE ALWAYS SAVE BOTH REGISTERS JUST BECAUSE IT TAKES LESS CODE.
::
::*********************************************************************

OOPS	HS	0
	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl
	LIS	R1,1			:STOP TRACER HARD
	STH	R1,TRCRRQ,,
	EI	:DB.TRC
	IF	1-ISIS
	SVC	0F,SV.SCR		:SAVES PSW AND SET 0 REGGIES
	EI	:1-ISIS
	ST	R0,CRSHAD		:Save crash address
	LR	R1,R0			:Get crash address to index register
	LHL	R1,0,R1			:Get offset to crash code
	LHL	R1,CRCDTB,R1,		:Crash code
	GL	CRCDTB
	STH	R1,CRSHID		:Save crash code
					:Continue...fall through

:	GET HERE FROM 'FAIL' FOR FAULTS DETECTED BY THE ISIS DISPATCHER
:	OR KERNEL, OR FALL THROUGH FROM 'OOPS'. SAVES REGISTERS,
:	COPIES POSSIBLE UPSW TRACE DATA TO 'TRSTAB', AND RESTARTS NODE
:	IF CRSTOP=0.  
SFAIL	HS	0
	STM	R0,ERRREG		:SAVE ALL REGISTERS
	JAL	R9,GMTCAL,,		:RETURNS CURRENT TIME (GMT+FASTC)
	GL	GMTCAL			: IN GMTNOW
	L	R2,GMTNOW,,
	ST	R2,CRSHTM		:SAVE IT
	JAL	R10,CTENTR		:MAKE CRASH TABLE ENTRIES
	UPSW	NOTRAC			:INSURE TRACE NOT ON, PROCEED AT SFAIL2

:	ENTRY POINT FOR MAC ERRORS AND ILLEGAL INSTRUCTIONS DETECTED BY
:	THE PRIVELEGED CODE IN A SOLO MACHINE.

SFAIL2	HS	0
	L	R0,CRSHAD		:CRASH ADDR IN HW2&3 OF CRYPTO REPORT
	ST	R0,CRYSBF,,
	LHL	R0,CRSHID		:CRASH ID IN HW1
	JAL	R8,CRYPTO
	HC	CRYE00			:MESSAGE = CRASH

SFAIL3	HS	0
	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl
	LHI	R1,TRTBSZ-2		:SET UP INDEX REG FOR TRSTAB.
:	MOST RECENT JUMP ADDRESS WILL BE LAST ENTRY IN TRSTAB.
	LR	R3,R1			:ALSO USEFUL AS WRAP MASK
	LHL	R2,TRNDEX,,		:REAL-TIME TRCTAB INDEX
SFAIL4	LHL	R15,TRCTAB,R2,		:GET CURRENT TRCTAB ENTRY AND
	STH	R15,TRSTAB,R1,		: STORE IN SAVE TABLE
	SIS	R2,2			:DECREMENT, AND
	NR	R2,R3			: MASK FOR WRAP
	SIS	R1,2
	JGEBS	SFAIL4			:FILL IN ALL ENTRIES
	EI	:DB.TRC

	LA	R1,TRRING+TRRSIZ-2,,	:LAST SOURCE HW
	LA	R2,TRRSAV+TRRSIZ-2,,	:LAST DESTINATION HW
	LHI	R3,10*(TRRSIZ/2-1)	:NUMBER OF HW'S TO MOVE INDICATOR
	HC	3F13			:SAVE TRRING--"COPY" MICROINSTRUCTION
	LHL	R1,TRRIX		:AND INDEX
	STH	R1,TRIXSV,,

	IF	ISIS
	LA	R1,DIRING+DRSZ+2,,
	LA	R2,DIRSAV+DRSZ+2,,
	LHI	R3,10*(DRSZ/2+1)
	HC	3F13			:SAVE DIRING
	LA	R1,DORING+DRSZ+2,,
	LA	R2,DORSAV+DRSZ+2,,
	LHI	R3,10*(DRSZ/2+1)
	HC	3F13			:AND DORING
	EI	:ISIS

	LA	R1,CRYPRB+CRYPRS-2,,	:LAST SOURCE HW ###LSH
	LA	R2,CRYPSV+CRYPRS-2,,	:LAST DESTINATION HW ###LSH
	LHI	R3,10*(CRYPRS/2-1)	:NUMBER OF HW'S TO MOVE ###LSH
	HC	3F13			:SAVE CRYPTO BUFFER -- "COPY"###LSH
	

	:STORE PACKETS ON CRASH
	:COPY 1000 BYTES EACH TIME

	IF	PKTSAV			:SAVE PACKETS ON CRASH	###LSH
	LI	R5,0			:DISPLACEMENT 
	LI	R4,PCKTSZ		:TOTAL BYTES TO BE COPIED
SFA0	CHI	R4,1000			:IS BYTE COUNT >= 1000 ?
	JL	SFA1			:NO, IT < 1000, COPY REST OF IT
	LHI	R6,1000			:YES, IT >= 1000, COPY 1000 BYTES
	JFS	SFA2			:GO TO COPY IT
SFA1	LR	R6,R4			:R6 = BYTES TO BE COPIED THIS TIME
SFA2	AR	R5,R6			:UPDATE DISPLACEMENT
	LA	R1,RECBUF-2,R5,		:LAST SOURCE HW
	LA	R2,PCKTSV-2,R5,		:LAST DESTINATION HW
	LR	R3,R6			:COMPUTE 10*(SIZE/2-1)
	SRHLS	R3,1
	SIS	R3,1		
	SLHLS	R3,4
	HC	3F13
	SR	R4,R6			:UPDATE TOTAL BYTES TO BE MOVED
	JG	SFA0			:KEEP MOVING
	EI	:PKTSAV			:			###LSH

	LM	R0,ERRREG		:RESTORE REGS IN CASE WE STOP ON CRASH

	LH	R1,CRTYPE		:HARDWARE OR SOFTWARE?		###TZ
	JGEFS	SFAIL7			:SOFTWARE			###TZ
	LB	R0,CRACTN		:HARDWARE, LOOK AT H-WARE FIELD
	STH	R0,CRTYPE		:RESET CRASH TYPE		###TZ
	JFS	SFAIL8
SFAIL7	LB	R0,CRACTN+1		:SOFTWARE, LOOK AT SOFTWARE FIELD
SFAIL8	LR	R0,R0
	JE	RESTRT			:CRACTN = 0 => RESTART
     IF T2GATE  :gateway can only restart or halt.
        J       CRPACH                  :then halt it
     ELSE   :T2GATE

	SIS	R0,1
	IF	ISIS			:###TZ
	JNFS	SFAILA
SFAIL9	HS	0			:STOP (LOOP) ON CRASH
	SVC	FAST,0			:DISMISS TO ISIS KERNEL SO OTHER SLOTS
	JBS	SFAIL9			: HAVE A CHANCE
SFAILA	HS	0
	ELSE	:NOT ISIS
	JE	.			:CRACTN = 1 => LOOP ON CRASH
	EI	:ISIS
	SIS	R0,1
	JNFS	CRPACH			:CRACTN > 2, PROVIDE PATCH AREA
:	EFFECTIVE FOR SFTWR CRASH ONLY AS HDW WOULD HAVE HALTED IN ANERNT.

:	CRACTN = 2 => BOOT MACHINE
	IF	ISIS	
	IF	IKNRNG
	SVC	SYS,$A39
	ELSE	:not IKNRNG
	LIS	R0,0			:IF ISIS INHIBIT UPDATE
	SBT	R0,KDISP,,		: OF WATCHDOG TIMER
	EI	:not IKNRNG
	ELSE	:not ISIS
	SVC	0F,SV.BOT		:IF SOLO, DO A SVC TO BOOT MACHINE
	LIS	R0,1			:HERE IF SVC FAILED DUE TO BAD 5A LOCAT
	STB	R0,WATCHD		:DISABLE 'SCHED' UPDATE OF WATCHDOG
	EI	:ISIS			: TIMER
	J	.			:LOOP TILL TIMER TAKES EFFECT
     EI  :T2GATE

RESTRT	UPSW	NSTPSW			:RESTART NODE CODE, POSSIBLY WITH TRACE
	SYAD(RESTRT)	
CRPACH	HS	0
	IF	ISIS
	SVC	SYS,$A32		:TRUELY HALT THE NODE CODE	###GT
					: - ONLY TO BE USED IN APSS SYSTEMS SO
					: THAT THE ISRM WILL UNSUSPEND THE
					: BACK-UP NODE CODE		###GT
	ELSE	:NOT ISIS
	JBS	.
	JAL	R0,PATCH1,,
	GL	PATCH1
	
	WS	4
	EI	:ISIS

NOTRAC	WC	0,SFAIL2		:TURN OFF TRACE FOR COPY OF TABLE

	IF	DB.TRC
NSTPSW	WC	1000,NSTART		:RESTART NODE CODE WITH UPSW TRACE
	ELSE	:NOT DB.TRC
NSTPSW	WC	R0,NSTART		:RESTART NODE CODE WITHOUT TRACE
	EI	:DB.TRC

:	MAC INTERRUPT HANDLERS. THE PRIVELEGED CODE TRANSFERS CONTROL
:	TO THE ADDRESS IN ABENPC (IF NON-ZERO)

::*********************************************************************
::
::	YAKMAK:	
::	RMAKE AND RTD MAC INTERRUPT HANDLER SNIPS LINK IF KD AND KN APPEAR
::	VALID, MAKES REPORT TO SUP AND XRAY, AND TRANSFERS TO EXEC LOOP
::
::*********************************************************************

YAKMAC	HS	0
	IF	1-ISIS
	STM	R0,ABRSAV		:SAVE OFF CRASH REGISTERS
	LIS	R0,0
	ST	R0,ABENPC		:CLEAR ERROR RETURN CELL
	L	R1,MACPSW+4		:GET ADDRESS OF MAC ERROR
	SLL	KN,1
	S	KD,KDKN,KN,KN		:MAKE SURE KD AND KN ARE CONSISTENT
	JEFS	RMKMA2			:SEEMS OK
	CRASH.(.YKMCR,R0)
RMKMA2	SRL	KN,1
	SBT	KN,BORZAP		:CAUSE THE LINK TO BE TAKEN DOWN
	LHI	R0,LS.MAC		:GET LINK-SNIP CODE
	STH	R0,SNPTYP,KN,KN		:AND SAVE IT
	ST	R1,SUPMBF+2		:SAVE MAC INTERRUPT ADDRESS
	LHI	R0,NR.MAC		:AND REPORT TYPE
	STH	R0,SUPMBF
	JAL	R10,SUP12,,		:TELL SUPERVISOR AND XRAY BOTH
	EI	:1-ISIS
	J	BIDDRT			:GO BACK TO EXEC LOOP

::*********************************************************************
::
::	SYLMAC:
::	SYLVER MAC INTERRUPT HANDLER SIMPLY CAUSES IMMEDIATE RETURN
::	TO THE EXEC LOOP
::
::*********************************************************************

SYLMAC	HS	0
	IF	1-ISIS
	STM	R0,ABRSAV
	LIS	R0,0			:CLEAR ERROR-RETURN ADDRESS
	ST	R0,ABENPC
	LHI	R0,NR.MAC		:NOTIFY SUPERVISOR
	STH	R0,SUPMBF
	L	R0,MACPSW+4
	ST	R0,SUPMBF+2		:SEND THE ERROR ADDRESS
	JAL	R10,SUP12,,
	J	EXDISM
	EI	:1-ISIS

::*********************************************************************
::
::	SUBROUTINE:	CTENTR:
::	FUNCTION:	MAKE AN ENTRY IN THE COMMON CRASH SUMMARY TABLE
::			AND IN DETAIL TABLE IF APPROPRIATE.
::	CALLING SEQ:	JAL	R10,CTENTR
::
::*********************************************************************

:	THE SUMMARY TABLE IS A PUSH-DOWN STACK WITH ROOM FOR 16d
:	ENTRIES.  WE WILL MAKE AN ENTRY IN THIS TABLE FOR EVERY CRASH UNTIL
:	THE FIRST CRASH NOT YET REPORTED TO THE SUPERVISOR REACHES THE BOTTOM
:	OF THE LIST.  AT THAT POINT WE STOP PUSHING THE STACK DOWN AND SIMPLY
:	ENTR ANY NEW CRASHES AT THE TOP.  THIS PRESERVES THE ORIGINAL CRASH
:	FOR REPORTING TO THE SUP.  WHEN THE NODE COMES BACK INTO THE NET FROM
:	A CRASH, WE WILL REPORT THIS 'OLDEST' CRASH (IF ANY) AS WELL AS THE
:	MOST RECENT CRASH. SIMILARLY, ENTRIES ARE MADE IN THE DETAIL TABLE ONLY
:	FOR THE CRASH OF INTEREST FOLLOWING A LOAD AND FOR THE FIRST MOST
:	RECENT CRASH OF INTEREST THAT OCCURED WHILE THE NODE WAS IN THE NET.

	IF	1-ISIS
CTEPFL	JAL	R10,CTENTR
	LA	R1,PREST0
	LIS	R0,0
	LPSWR	R0
CTEINT	JAL	R10,CTENTR	:INTERRUPT ROUTINES CALL CTENTR FROM HERE
	LA	R1,ANERN1
	LIS	R0,0
	LPSWR	R0
	EI	:1-ISIS

CTENTR	HS	0
	LHI	R1,((CS.NEN-1)*CS.SIZ)	:POINT TO LAST ENTRY IN SUMMARY TABLE
CTE10	LM	R12,CSMTBL-CS.SIZ,R1	:GET PREVIOUS ENTRY
	STM	R12,CSMTBL,R1		:MOVE IT DOWN ONE ENTRY
	SHI	R1,CS.SIZ		:POINT TO NEXT ENTRY UP
	JGBS	CTE10			:NO, CONTINUE
:	STACK PUSHED, NOW MAKE NEW ENTRY
	LM	R12,CRHCNT		:COUNT,ID,PSD,TIME
	STM	R12,CSMTBL		:MAKE ENTRY
	LIS	R3,1			:increment			###wjl
	AHM	R3,CSMCNT		:count of summary table entries	###wjl
:	NEW ENTRY MADE, NOW MAKE DETAILED ENTRY IF APPROPRIATE.
	IF	1-ISIS
	THI	R12,0E0			:WE WANT TO MAKE A DETAILED CRASH ENTRY
					: ONLY IF CRASH CODE
					: (LO BYTE OF CRASH ID) IS >= 20.
	JER	R10			:NOT OF INTEREST
	ELSE	:ISIS
	THI	R12,0E			:FOR ISIS, MAKE DETAIL ENTRY IF ID >1.
	JER	R10
	EI	:1-ISIS
	LHL	R3,CSMCNT		:ANY ENTRIES? 			###GT
	JER	R10			:NO, DON'T MAKE ANY ENTRIES
					: IN DETAIL TABLE		###GT
	LIS	R3,1			:				###GT
	AHM	R3,CDTCNT		:COUNT OF DETAIL ENTRIES	###GT
	LHL	R3,CDTPTR		:POINTER TO NEXT DETAIL ENTRY AREA
CTE20	HS	0
	STM	R12,CDTTBL,R3		:COUNT, CODE, PSD, TIME
	IF	1-ISIS
	LA	R0,ERREG0+3E		:FOR COPY - LAST SOURCE HW
	LA	R1,CDTTBL+CD.RS0+3E,R3	:FOR COPY - LAST DESTINATION HW
	LHI	R2,1F0			:FOR COPY - NO. OF HW'S -1 * 10
	COPY	R0,R2			:MOVE CONTENTS OF REGISTER SET 0
					:INTO CRASH TABLE.
	EI	:1-ISIS
	LA	R0,ERRREG+3E		:FOR COPY - LAST SOURCE HW
	LA	R1,CDTTBL+CD.RSF+3E,R3	:FOR COPY - LAST DESTINATION HW
	LHI	R2,1F0			:FOR COPY - NO. OF HW'S -1 * 10
	COPY	R0,R2			:MOVE CONTENTS OF USER REGISTER SET
					:INTO CRASH TABLE.
	IF	1-ISIS
:	GET MAC REGISTERS INTO CRASH TABLE
	LHI	R4,5C			:INDEX INTO CRASH TABLE AREA
	LHI	R0,35C			:END OF MAC REGGY AREA
CTE30	HS	0
	LR	R1,R0			:SAVE IT
	SVC	0F,SV.RAB		:GET 16d FW'S OF MAC REGGIES TO ABSSAV
	ST	R1,CDTTBL+CD.MAC,R3,R4
	SIS	R0,4
	SIS	R4,4
	JGEBS	CTE30
	L	R0,MACISR,,		:GET LOCATION 340 VALUE
	ST	R0,CDTTBL+CD.MAC+40,R3	: IN CASE 0'D BY MAC INT
	EI	:1-ISIS
	LR	R3,R3			:FIRST ONE?
	JNR	R10			:NO
	LHI	R3,CD.SIZ		:YES,POINT TO SECOND
	STH	R3,CDTPTR
	JR	R10			:RETURN

	SUBTTL	EXEC (CRYPTO - Diagnostic message generator)

::*********************************************************************
::
::	SUBROUTINE:	CRYPTO:
::	FUNCTION:	SENDS A CRYPTOGRAM TO XRAY
::	CALLING SEQ:	JAL	R8,CRYPTO
::			HC	CRYExx	:CRYPTO NUMBER AND MESSAGE FLAGS
::	INPUT:		R0=HW0 & HW1 OF CRYPTOGRAM DATA
::			CRYSBF=HW2,HW3 OF CRYPTOGRAM DATA
::
::*********************************************************************

:	STORES A CRYPTOGRAM AS FOLLOWS: FW OF GMT, LO HW OF FASTC, HW OF
:	FLAGS AND MESSAGE TYPE (CRYEnn), 4 HW'S OF DATA.

CRYPT0	HS	0			:ENTRY POINT WHEN R0 NOT SET UP
	L	R0,CRYSBF+4		:CRYPTO ASSUMES R0 HAS SOME DATA

CRYPTO	HS	0
	ST	R1,CRYSAV+4		:SAVE R1 IMMEDIATELY
	LB	R1,1,R8			:GET CRYPTO NUMBER
	TBT	R1,CRYARY		:SEE IF THIS MESSAGE IS DESIRED
	JN	CRYPNO			:NO, DO NOT DISPLAY IT

	LB	R1,0,R8			:GET MESSAGE FLAGS
	NHI	R1,0F			:ISOLATE MESSAGE CLASS
	JEFS	CRYPTX			:CLASS 0 IS ALWAYS DISPLAYED

	LHL	R1,CRYPCL,R1,R1		:GET FLAG FOR THIS CLASS
	JNFS	CRYPTX			:DISPLAY IF NOT ZERO

CRYPNO	L	R1,CRYSAV+4		:NO DISPLAY, RESTORE R1
	J	2,R8			:AND RETURN PAST CRYPTO DATA

CRYPTX	HS	0
	LHL	R1,0,R8			:CRYPTO MESSAGE NO. AND FLAGS
	AIS	R8,2			:SET UP TO RETURN PAST CRYPTO DATA HC
	
:	CRYPT1 IS ENTRY POINT FOR WHEN MESSAGE FLAGS ARE SUPPLIED IN R1
:	INSTEAD OF IN THE HALFWORD FOLLOWING THE CALL TO CRYPTO
CRYPT1	STM	R2,CRYSAV+8		:SAVE WORK REGS
	ST	R0,CRYSAV		:	AND CRYPTO DATA
	LHL	R2,CRYPRI		:Get pointer into regular buffer
:	L	R3,CRYPRB+CRYGMT,R2,	:Anything there now?
:	JE	CRYPT3			:No

:	LB	R3,CRYPRB+CRYTYP,R2,	:Get number of old message
:	GL	CRYPRY
:	TBT	R3,CRYPRY,,		:See if it should be saved
:	JE	CRYPT3			:No				###AL

:	LM	R12,CRYPRB,R2,		:Get old message
:	LHL	R3,CRYPPI		:Pointer to priority buffer
:	STM	R12,CRYPPB,R3,		:Save old message
:	AHI	R3,10			:Adjust priority pointer
:	NHI	R3,CRYPPS-1		:Max size
:	STH	R3,CRYPPI		:Done
	
CRYPT3	LHL	R6,FASTC+2,,		:GET LO HW OF FASTC
	EXHR	R6,R6			:SHIFT TO HO HW
	OR	R6,R1			:COMBINE FASTC
					: WITH CRYPTO NUMBER AND MESSAGE FLAGS
	ST	R6,CRYPRB+CRYFAS,R2,	:STORE IT AWAY
	IF	PRIMSG
	LBR	R3,R1			:GET MEG. # BYTE
	GL	CRYPRY
	TBT	R3,CRYPRY,,		:SEE IF PRIORITY ON
	JEFS	CRPT31
	LHL	R3,CRYPPI		:STORE TO CRYPPB ALSO
	ST	R6,CRYPPB+CRYFAS,R3,
CRPT31	HS	0
	EI	:PRIMSG
	LR	R6,R1			:SAVE R1			###AL
	JAL	R9,GMTCAL,,		:GET CURRENT GMT AT GMTNOW
	LR	R1,R6			:RESUME R1			###AL
	L	R6,GMTNOW,,		:GET IT AND
	ST	R6,CRYPRB+CRYGMT,R2,	:STORE IT AWAY
	ST	R0,CRYPRB+CRYHW0,R2,	:STORE CRYPTO DATA HW0&1
	L	R4,CRYSBF		:USE R4				###AL
	ST	R4,CRYPRB+CRYHW2,R2,	:HW2&3
	IF	PRIMSG
	LBR	R5,R1			:GET MEG. # BYTE
	TBT	R5,CRYPRY,,		:SEE IF PRIORITY ON
	JE	CRPT32
	LHL	R3,CRYPPI		:RESUME INDICATER
	ST	R6,CRYPPB+CRYGMT,R3,	:STORE IT AWAY
	ST	R0,CRYPPB+CRYHW0,R3,	:STORE CRYPTO DATA HW0&1
	ST	R4,CRYPPB+CRYHW2,R3,	:HW2&3

	AHI	R3,10
	NHI	R3,CRYPPS-1		:Update crypto message index
	STH	R3,CRYPPI
CRPT32	HS	0
	EI	:PRIMSG

	AHI	R2,10
	NHI	R2,CRYPRS-1		:Update crypto message index
	STH	R2,CRYPRI

CRYPT6	HS	0
	LHL	R14,INTXRF		:REMOTE XRAY USER?
	JEFS	CRYPT9			:NO
	LHI	R14,01F-PXRAY		:YES,SCHEDULE XRAY
	SBT	R14,SQUEUE
	LHL	R14,XUSIUA		:PUT ALL XRAY USERS
	STH	R14,XQUEM,,		:INTO MASTER QUEUE
CRYPT9	LM	R0,CRYSAV		:RESTORE WORK REGS
	JR	R8			:RETURN
	
CRYARY	HS	10		:INDIVIDUAL BITS ENABLE DISPLAY OF
				:INDIVIDUAL CRYPTO MESSAGES

CRYPCL	HS	0		:CLASSES OF CRYPTO MESSAGES
CRYDEF	HC	1		:CLASS 0 ALWAYS DISPLAYS
	SYAD(CRYDEF)
CRYDIS	HC	DB.CIR		:CLASS 1 - CIRCUIT BUILT, ZAPPED
	SYAD(CRYDIS)
	DEFAULT(ASYDIS,0)
ASYDIS	HC	ASYDIS		:CLASS 2 - ASYNC MESSAGES
	SYAD(ASYDIS)
REBDIS	HC	0		:CLASS 3 - REBUILD EVENTS
	SYAD(REBDIS)
	HC	0	:CLASS 4
	HC	0	:CLASS 5
	HC	0	:CLASS 6
	HC	0	:CLASS 7
	HC	0	:CLASS 8
	HC	0	:CLASS 9
	HC	0	:CLASS A
	HC	0	:CLASS B
	HC	0	:CLASS C
	HC	0	:CLASS D
	HC	0	:CLASS E
	HC	0	:CLASS F

	SUBTTL	EXEC

::*********************************************************************
::
::	SUBROUTINE:	HSTORY:
::	FUNCTION:	SAVES EVENT IN HISTORY BUFFER
::	CALLING SEQ:	JAL	R8,HSTORY
::	INPUT:		R0 = EVENT (PRESERVED)
::	DESTROYED:	R1
::
::*********************************************************************

HSTORY	HS	0
	LHL	R1,HISTI
	STH	R0,HISTBF,R1,
	AIS	R1,2
	NHI	R1,HISTSZ-1
	STH	R1,HISTI
	JR	R8

::*********************************************************************
::
::	SUBROUTINES:	BID:/BIDH:
::	FUNCTION:	ROUTINES TO FIND THE BIT NUMBER OF THE HIGH ORDER
::			NONZERO BIT IN A REGISTER. BIDH TESTS ONLY THE
::			RIGHTMOST 16 BITS OF THE REGISTER.
::	LINKS:		R8
::	INPUT:		R1 = NONZERO ARGUMENT REGISTER
::	OUTPUT:		R2 = # OF HIGHEST ORDER NONZERO BIT IN R1 (0-31)
::	DESTROYED:	NONE
::
::*********************************************************************

BIDH	HS	0
	JFFOH	R1,BIDR
	CRASH.(.BIDHC)
BID	HS	0
	JFFO	R1,BIDR
	CRASH.(.BIDC0)
BIDR	JR	R8

	IF	DB.CPU

::*********************************************************************
::
::	SUBROUTINE:	CPUTIZ:
::	FUNCTION:	SETS UP TO MEASURE CPU UTIL FOR ROUTINE ABOUT TO
::			EXECUTE. HW FOLLOWING CALL TO CPUTIZ CONTAINS THE
::			ROUTINE'S INDEX (RTN NO. * CPUTSZ) INTO THE STATS
::			TABLE (CPUTTB).
::	LINKS ON:	R1(+2)
::	DESTROYED:	R0,R2
::
::*********************************************************************

CPUTIZ	HS	0
	LH	R0,CPUTFL,,		:ARE WE MEASURING?
	JGE	2,R1			:NO, SKIP(+2) RETURN
	GL	CPUTCD,CPUTTB
	LH	R2,CPUTCD,,	:ARE WE COMING HERE WITHOUT YIELD OR DISMISS?
				:I.E. WILL WE GENERATE A DISMISS/YIELD COUNT
				:THAT HAS NO MATCHING DISPATCH COUNT?	###OAS
	JL	CPUTZ0		:NO PROCESS INDEX, START NEW MEASUREMENT###OAS

				:A PROCESS WAS BEING MEASURED ALREADY.	###OAS
	IF	DB.CLK
	IF	ISIS
	LHL	R2,LO.CLK,,		:GET SEGF OFFSET TO SLOT CLOCKS	###OAS
	LHL	R0,SEGF,R2,		:GET SLOT CLOCK			###OAS
	S	R0,CPUTFC,,		:SUBTRACT START TIME
	JGEFS	CPUTZ9			:CHECK FOR HW WRAP
	AI	R0,10000		:ADJUST FOR HW WRAP
CPUTZ9	LH	R2,CPUTCD,,		:RECOVER PREVIOUS PROCESS INDEX
	ELSE	:not ISIS
	L	R0,FASTC,,		:CURRENT TIME
	S	R0,CPUTFC,,		:SUBTRACT START TIME
	EI	:ISIS
	AHM	R0,CPUTTB,R2,		:ADD TO TIME CONSUMED FOR PREVIOUS
	EI	:DB.CLK			: ROUTINE			###OAS
	IF	DSPTRC
	LIS	R0,1			:				###OAS
	AHM	R0,CPUTTB+CPTBCT,R2,	:BUMP PREVIOUS PROCESS DISMISS	###OAS
	AHM	R0,CPUTTB+CPTBHW,R2,	:BUMP PROCESS CALLED W/O DSP CT ###OAS
	EI	:DSPTRC

CPUTZ0	HS	0
	IF	DB.CLK
	IF	ISIS
	LHL	R2,LO.CLK,,		:SEGF RELATIVE POINTER TO SLOT 0 CLOCK
	LHL	R0,SEGF,R2,		:GET SLOT 0 CLOCK
	ELSE	:not ISIS
	L	R0,FASTC,,		:GET THE TIME
	EI	:ISIS
	GL	CPUTFC
	ST	R0,CPUTFC,,		:START TIME
	EI	:DB.CLK

	LHL	R0,0,R1			:GET OUR TABLE INDEX
	STH	R0,CPUTCD,,		:SAVE IT
	J	2,R1			:SKIP(+2) RETURN

::*********************************************************************
::
::	SUBROUTINE:	CPUTCP:
::	FUNCTION:	RECORD CPU UTIL STATS FOR ROUTINE JUST ENDED
::	CALLING SEQ:	JAL	R10,CPUTCP
::	DESTROYED:	R1,R2
::
::*********************************************************************

CPUTCP	HS	0
	LH	R1,CPUTFL,,		:ARE WE MEASURING?
	JGER	R10			:NO, RETURN

	LH	R1,CPUTCD,,		:INDEX FOR ROUTINE JUST FINISHED
	JLR	R10			:NOT SET

	IF	DB.CLK
	IF	ISIS
	LHL	R2,LO.CLK,,		:SEGF RELATIVE POINTER TO SLOT0 CLOCK
	LHL	R2,SEGF,R2,		:GET SLOT0 CLOCK
	S	R2,CPUTFC,,		:SUBTRACT START TIME
	JGEFS	CPUTC9			:CHECK FOR HW WRAP
	AI	R2,10000		:ADJUST FOR HW WRAP
CPUTC9	HS	0
	ELSE	:not ISIS
	L	R2,FASTC,,		:CURRENT TIME
	S	R2,CPUTFC,,		:SUBTRACT START TIME
	EI	:ISIS
	AHM	R2,CPUTTB,R1,		:ADD TO TIME CONSUMED FOR THIS ROUTINE
	EI	:DB.CLK
	IF	DSPCNT
	LIS	R2,1			:INCREMENT COUNT OF DISMISSES/ENDS
	AHM	R2,CPUTTB+CPTBCT,R1,
	EI	:DSPCNT
	TS	CPUTCD,,		:MARK NOT MEASURING ANY ROUTINE
	JR	R10			:RETURN

	EI	:DB.CPU


	ENDMO.(EXEC)

:	***END EXEC***

	EI	:1-KILLIT

	KILMSG(EXEC)

:	***NOTHING PAST THIS POINT***



	SUBTTL	LINKER

:		*     ***** *   * *   * ***** ****
:		*       *   **  * *  *  *     *   *
:		*       *   * * * ***   ***   ****
:		*	*   *  ** *  *  *     *  *
:		***** ***** *   * *   * ***** *   *

::#####################################################################
::
::	MODULE:	 LINKER
::
::	FUNCTION:  Creates, monitors, maintains, and tears down links
::		to neighbor nodes.	###OSF 5/77
::
::	REGISTER CONVENTIONS:
::		CD  = R13	:pointer to reCord Descriptor
::		KD  = R15	:pointer to linK Descriptor
::		KN  = R11	:linK Number
::		LN  = R14	:Line Number
::		SD  = R12	:pointer to reSet Data buffer
::
::	ROUTINES:
::		IZLNKR - LINKER segment initializer
::		SIOIZ  - Initiialize SIO lines
::		SIQURY - Query SIO status			###LSH
::		LKVOLT - Test for network links overloaded or saturated
::		LINKER - Detach, attach scheduler
::		LNCHCK - 4 sec test for records received on lines
::		LDRPRT - Diagnostics and reporting
::		KB56DB - Monitor SIO lines
::		LNXDUM - Forces transmission of dummy records
::		ATTLIN - Line attach logic
::		DETLIN - Line detach logic
::		SYLVER - Dispatcher for input on sync lines
::			 SIO input processor
::			 SIO output processor
::			 Sync input processor
::
::#####################################################################

:	SYNC LINE FORMATS
:
:	TYMNET-II:
:
:	HEADER:		00TTSSSSAAAAAAAANNNNNNNN
:	NEW LINK RESET:	001100001010PPPP + NODE #
:	NEW LINE RESET:	001100001011PPPP + NODE # OR KEY
:	NULL:		0011000001101001 + 78AB + CHECKSUMS
:	DOWNLINE LOAD:	0011001000110010
:
:	T-II Expanded Reset Packet:###wjl
:
:	New Link Reset: 001100111010PPPP + NODE # +VERSION+NETID+SUBNET+
:			WSIZ+LN+HST0+RSRSN+KSPD+KATTR+DIALUP + CHECKSUMS
:	New Line Reset: 001100111011PPPP + NODE # OR KEY +(same as new link)
:
:	WHERE:	X=1 IF FROM SLAVE
:		S=HW COUNT OR LENGTH FACTOR
:		N=RECORD #
:		A=ACKNOWLEDGEMENT
:		P=PING-PONG COUNT
:		TT=10 IF FROM MASTER, 01 FROM SLAVE

	IF	1-KILLIT		:TO ASSEMBLE OR NOT TO ASSEMBLE
	BEGMO.

	SUBTTL	LINKER (Read-only data)

	SEG	1

Q	EQ	0
	SETRAD(0A)			:set decimal radix
WSZKN	RE	NLINKS			:WINDOW SIZE PER LINK
	HC	WSIZ|Q|
Q	EQ	Q+1
	ER

Q	EQ	0
NCHKN	RE	NLINKS			:# OF CHANNELS ON LINK
	HC	NCH|Q|
Q	EQ	Q+1
	ER

Q	EQ	0
NEIKN	HS	0
	SYAD(NEIKN )
	RE	NLINKS			:NEIGHBORS ON LINKS
	IF	\NEI|Q|
	HC	NEI|Q|
	ELSE
	HC	0
	EI
Q	EQ	Q+1
	ER
::Now some array allocations for Star Lines and Links
	IF	STRHUB!STRRMT
Q	EQ	0
LTYP	HS	0		:LINE TYPE (STRLINE OR NOT) / EACH LINE
	SYAD(LTYP  )
	RE	NLINES
	IF	\NSTR|$A Q|
	HC	$0 0100		:Uses first byte of HW
	ELSE
	HC	0
	EI
Q	EQ	Q+1
	ER
	EI	:STRHUB!STRRMT
	IF	STRHUB
P	EQ	SKTBSZ
Q	EQ	SKDBLK
R	EQ	0
SKDPTR	WS	0		:POINTER TO EACH STARLINE'S CHAIN DESCRIPTOR
	RE	NLINES		:This is a permanent pointer array used when
	IF	\NSTR|R|	:a line is not up.  also found in KDLN for
	WC	Q		:active lines.
Q	EQ	Q+P
	ELSE
	WC	0
	EI
R	EQ	R+1
	ER

Q	EQ	0
KEYKN	WS	0		:STARLINK KEYS PER ALL LINKS
	SYAD(KEYKN )		:Arranges all the keys for all the links
	RE	NLINKS		:in link order.
	IF	\K.S|$A Q|
	WC	K.S|$A Q|
	ELSE
	WC	0
	EI
Q	EQ	Q+1
	ER
	EI	:STRHUB


:	TYM FILE DECLARATION MAY INCLUDE LINK SPEEDS FOR SELECTED
:	LINKS.  THIS OPTION IS PROVIDED DUE TO THE NODE'S DIFFICULTY
:	COMPUTING LINE SPEEDS ON FAST SIO LINES.  A CONFIGURATION LINK
:	SPEED IS PRESENT IF THE SYMBOL 'KNSP|#|' IS DEFINED FOR LINK
:	NUMBER #.

Q	EQ	0		:LINK NUMBER
QQ	EQ	$0 80000000	:FOR SETTING BITS BASED ON LINK NUMBER
QQQ	EQ	0		:WORKING BIT ARRAY FOR LINKS WITH KNSP DEFINED
QQQQ	EQ	0		:WORKING BIT ARRAY FOR LINKS WITH TIWS8 SET
QQQQQ	EQ	0		:WORKING BIT ARRAY FOR LINKS WITH SAT SET

	RE	NLINKS
	IF	\KNSP|Q|		:THIS INDICATES HIGH SPEED CONFIGURED
QQQ	EQ	QQQ!QQ			:SET BIT FOR THIS LINK
KSAT|Q|	EQ	KSAT|Q|+(KNSP|Q|&$01F)	:ADD SPEED TO LINK SPEED FIELD
	EI	:\KNSP|Q|
	IF	\KSAT|Q|		:###jhl
	IF	KSAT|Q|&TIWS8
QQQQ	EQ	QQQQ!QQ			:SET TIWS8 BIT FOR THIS LINK
	EI	:KSAT|Q|&TIWS8
	IF	KSAT|Q|&$020		:IF SAT BIT SET IN KSAT BYTE
QQQQQ	EQ	QQQQQ!QQ		:SET SAT BIT FOR THIS LINK
	EI	:KSAT|Q|&$040
	EI	:\KSAT|Q|		:###jhl
Q	EQ	Q+1			:CHECK ALL LINKS
QQ	EQ	QQ^-1
	ER

KNCNSP	WC	QQQ		:BIT SET IF LINK SPD DEFINED BY CONFIG
KNCTI8	WC	QQQQ		:BIT SET IF TIWS8 SET BY CONFIG	###jhl
KNCNST	WC	QQQQQ		:BIT SET IF SAT SET BY CONFIG	###jhl

KNSAT	HS	0
Q	EQ	0
	RE	NLINKS
	IF	STRHUB
	IF	\KEYKN|Q|	:Initializes all Starlinks to default
	BC	KSAT|Q|		:Sattelite service
	ELSE
	DEFAULT(KSAT|Q|,$0 80)
	BC	KSAT|Q|
	EI
	ELSE	:NOT STRHUB
	DEFAULT(KSAT|Q|,$0 80)
	BC	KSAT|Q|
	EI
Q	EQ	Q+1
	ER

	RA	0			:RESTORE HEX RADIX

CCDSZ	HC	CDSZ

TTRSET	WS	0			:TYMNET-II INITIAL RESET PATTERN
	HC	TTRSHD			:HEADER
	HC	MACHNM			:NODE NUMBER
	HC	TTRSHD%MACHNM		:VERT CHKSM
	HC	TTRSHD^2%MACHNM^1%TTRSHD%MACHNM	:DIAG. CKSUM

VERCOM	EQ	((VERSION&0FFF)^10)!((@(VERSION&0FFF))&0FFFF)		:###wjl

Q	EQ	0			:DISPLACEMENT OF INPUT BUFFERS
SVBDIS	RE	NLINES
	HC	Q;Q EQ Q+2+SVNBSZ
	ER

Q	EQ	SDSC			:RESET BUFFER PTRS BY LINE #
SDLN	RE	NLINES
	HC	Q;Q EQ Q+SDBSZ
	ER

:	SET UP ARRAYS AND COUNTERS FOR SIO LINES

	IF	SILINS

Q	EQ	(NLINES-SILINS)*2	:FIRST SIO LINE NUMBER
SIBUFP	EQ	.-Q			:BASE ADDRESS FOR
	SYAD(SIBUFP)			:	SIO AREAS
R	EQ	0
Q	EQ	Q/2			:SINGLE SIO LINE NO. ##AL
	RE	SILINS
	HC	R
	IF	\NSTR|$A Q|	
	IF	STRHUB			:ONLY FOR HUB STAR LINE ##AL
R	EQ	R+SIBFSZ+20		:STAR LINE SIBFSZ+20
	ELSE
R	EQ	R+SIBFSZ
	EI	:STRHUB
	ELSE
R	EQ	R+SIBFSZ
	EI
Q	EQ	Q+1
	ER

Q	EQ	(NLINES-SILINS)*2	:FIRST SIO LINE NUMBER

	IF	SIBFRL			:###LSH
:	SIO BUFFERS ARE RELOCATED TO SEG 2, SO FULLWORDS ARE NEEDED
:	TO STORE ADDRESSES		:###LSH
	WS	0			:force to FW boundary!		###wjl
SIOIN	EQ	.-Q*2			:INPUT CCW BLOCK ADDRESSES
R	EQ	0
	RE	SILINS
	WC	SIOBLI+R
R	EQ	R+10
	ER

SIORSP	EQ	.-Q*2			:RESET BUFFER POINTERS
R	EQ	0
	RE	SILINS
	WC	SIOBLR+R
	IF	XRESET			:###wjl
R	EQ	R+30			:larger SIO reset buffer needed
	ELSE				: for expanded reset pattern
R	EQ	R+10
	EI	:XRESET
	ER

	ELSE	:NOT SIBFRL		:###LSH
SIOIN	EQ	.-Q			:INPUT CCW BLOCK ADDRESSES
R	EQ	0
	RE	SILINS
	HC	SIOBLI+R
R	EQ	R+10
	ER

SIORSP	EQ	.-Q			:RESET BUFFER POINTERS
R	EQ	0
	RE	SILINS
	HC	SIOBLR+R
	IF	XRESET			:###wjl
R	EQ	R+30			:larger SIO reset buffer needed
	ELSE				: for expanded reset pattern
R	EQ	R+10
	EI	:XRESET
	ER

	EI	:SIBFRL			:###LSH

	EI	:SILINS

	IF	STRHUB
NSTLIN	EQ	0		:NSTLIN IS NEEDED IN XRAY ND DISPLAY
NSTKDS	EQ	0
Q	EQ	0
:KEYSLN	HS	0		:KEYS LIST PER STARLINE
	RE	NLINES		:Sets up a list of all keys, in keys per
	IF	\NSTR|$A Q|	:Starline order .. that is each line's keys
R	EQ	0		:will be listed in order, followed by the next
	RE	NSTR|$A Q|	:line's keys etc.  for Starlines only.
	IF	\S.K|$A Q||R|
	WC	S.K|$A Q||R|
	EI
R	EQ	R+1
	ER
NSTLIN	EQ	NSTLIN+1
NSTKDS	EQ	NSTKDS+R
	EI
Q	EQ	Q+1
	ER

SXLNIT	BS	0		:STAR-XLINK LINE STATUS PER ALL LINKS INIT
	BS	NLINKS-NSTKDS-STRXLK-XLINKS	:TIILNKS PUT 00
Q	EQ	NLINKS-NSTKDS-STRXLK-XLINKS-1	:THEN FROM STRLNK
	RE	NSTKDS+1
R	EQ	0
	RE	NLINES		:FIND THE STARLINE#
	IF	\Y|$A Q|.|$A R|
	BC	$A R		:ARRAY HAS STARLINE# IF KEY DEFINED
	EI
R	EQ	R+1
	ER	:NLINES
Q	EQ	Q+1
	ER	:NSTKDS
S	EQ	0		:INIT STRXLK TO 0FF
	RE	STRXLK
	BC	$0 0FF
S	EQ	S+1
	ER	:STRXLK		:NO NEED FOR XLINKS IN THIS ARRAY	###AL
	EI	:STRHUB

STRTYP	EQ	0C			:STARLINK LINK TYPE
	IF	NAKCOD
NAKRSP	EQ	040		:Bit set in LLXM if a NAK Response reXmission
	GL	SIONAK
	EI	
DWICNT	EQ	1F0		:Count of halfwords for DWL input transfer
	SUBTTL	LINKER (IZLNKR - LINKER segment initializer)

::*********************************************************************
::
::	SUBROUTINE:	IZLNKR:
::	FUNCTION:	LINKER segment initializer
::	CALLING SEQ:	JAL	R10,IZLNKR	Called from NSTART. 
::	CALLS:		JAL	R9,GFRCHN
::			JAL	R8,HCSET
::			JAL	R9,RSTSTR
::			JAL	R8,HCLEAR
::
::*********************************************************************

IZLNKR	HS	0
	ST	R10,IZLNLR		:SAVE LINK REGISTER

	IF	STRHUB
::*********************************************************************
::	SECTION:	IZKDLN:
::	FUNCTION:	For STRHUB machines, initializes the array KDLN
::			to contain Zeroes for normal lines and a pointer
::			to the StarLink chain descriptor for that Star Line.
::*********************************************************************
	LI	R8,SKDBLK		:Starline link chain descriptor
	LHI	R9,SKTBSZ		:Size of each chain descriptor
	LHI	R3,NLINES-1		:Repeat for each line
	LIS	R2,0			:Index into Nkstln  
IZKDLN	LB	R1,LTYP,R3,R3		:Check if starline		###AL
	JE	IZKD99			:Zero means no Star Links
	ST	R8,KDLN,R2,R2		:Store descriptor pointer
	AR	R8,R9			:Increment address
IZKD99	AIS	R2,2			:increment pointer
	SIS	R3,1			:decrement  counter
	JGE	IZKDLN			:Loop or fall through
	EI	:STRHUB

::Now link the Record Descriptors together for each link
	LI	CD,CDSC			:LINK THE RECORD DESCRIPTOR CHAIN
	STH	CD,FREELR
	LI	R1,CDSZ+CDSC
	LIS	R2,0
	LHI	R3,NRECDS
IZLN1	STH	R1,RLNK,CD		:RLNK POINTS TO NEXT REC DESCR IN CHAIN
	IF	EXPWSZ
	ST	R2,BREC,CD		:BREC POINTS TO RECORD DATA BUFFER
	ELSE
	STH	R2,BREC,CD		:BREC POINTS TO RECORD DATA BUFFER
	EI
	LR	CD,R1			:ADVANCE TO NEXT RECORD DESCRIPTOR
	AHI	R1,CDSZ
	AHI	R2,RECBSZ		:ADVANCE TO NEXT DATA BUFFER
	SIS	R3,1			:REPEAT IF MORE RECORDS LEFT
	JG	IZLN1
	LCS	R0,1			:LAST RECORD GETS A -1 IN RLNK
	SHI	CD,CDSZ
	STH	R0,RLNK,CD
	IF	SILINS			:ONLY FOR SIO LINES
	STH	R0,PSLNUM		:PAKET SAVE FLAG INIT TO 0FFFF ###AL
	EI	:SILINS
:	THE RECORD DESCRIPTORS ARE ALL CHAINED. NEXT, ASSIGN 'WSIZE'
:	RECORD DESCRIPTORS TO EACH LINK FOR INPUT AND OUTPUT. THE 'RLNK'
:	FIELD OF THE LAST RECORD DESCRIPTOR ASSIGNED ON A LINK IS SET
:	TO POINT BACK TO THE FIRST RECORD DESCRIPTOR, FORMING A CLOSED
:	RING OF 'WSIZE' RECORD DESCRIPTORS.
::	LHI	KD,KDLST		:INIT LINK DESCRIPTORS

	LHI	R8,2*(NLINKS-1)		:2*LAST LINK #
IZLN2	L	KD,KDKN,R8,R8		:GET LINK DESCRIPTOR POINTER
	LHL	R1,WSZKN,R8		:WINDOW SIZE FOR THIS LINK
	NHI	R1,0FC			:MUST BE MULTIPLE OF 4
	JE	IZLN4			:ZIP
	JAL	R9,GFRCHN		:GET STRING OF RECORDS FROM FREE LIST
	NOP
	STH	R2,ISEC,KD		:ISEC PTS TO START OF CHAIN
	STH	R2,RLNK,R3		:LAST LINK NOW PTS TO FIRST REC
	JAL	R9,GFRCHN		:GET ANOTHER STRING
	NOP
	STH	R2,OSEC,KD
	STH	R2,RLNK,R3
IZLN4	STB	R1,WSIZ,KD		:SET WINDOW SIZE FOR THIS LINK
	LHL	R1,NEIKN,R8		:GET THE NODE #
	STH	R1,NDID,KD		:SAVE IT
	STH	R1,ONDID,KD
	LR	R1,R8			:GET LINK NUMBER TO R1
	SRHLS	R1,1
	STB	R1,LKNM,KD		:STORE LINK # FOR CONVENIENCE
	LB	R0,KNSAT,R1
	STB	R0,KSPD,KD		:INIT KSPD, INCLUDES SATELLITE BIT IF 

::If Star hub, must put Starlink Key into link descriptor
	IF	STRHUB
	L	R1,KEYKN,R8,R8		:Is there a Key for this link
	JEFS	SIZL50			:No, the FW is zero
	ST	R1,LNKKEY,KD		:Not zero, must be Key - store it!
	LIS	R1,STRTYP		:Starlink descriptors KTYP 
	STB	R1,KTYP,KD		:Store it
	EI	:STRHUB

SIZL50	SIS	R8,2			:Decrement HW index
	JGE	IZLN2

	IF	STRHUB
::*********************************************************************
::	SECTION:	IZSTKD:
::	FUNCTION:	Initialize the link descriptors for each Star Line,
::	to contain a pointer to the next KD in line for this Star Line.
::	Initialize the Starline Link chain descriptor block.
::
::	Repeat for each line.  If NKSTLN (number of starlinks for this line)
::	is greater than one, then this is a Star Line.  For this Star Line
::	get the last key for it and search through all the link descriptors
::	to match it.  When a match is found, save the pointer and find the 
::	next key.  Store the previous key in the current link descriptor's
::	pointer field.  When the last key for this line is found (actually
::	the first for the line, put that pointer in the Chain descriptor
::	block and go to the next line.
::
::	REGISTER USAGE:	R0, R1, R2, R3, R8, KD.
::
::*********************************************************************

::	The new starlink chaining logic is depending on an link array
::	SXLNKN, it's initialized to have starline# per starlink and
::	will not be affacted by node restart. Xray IK RK commands will
::	update the SXLNKN array.					###AL

	LHI	LN,(NLINES-1)*2		:Start with last line of all lines
EACHLN	LB	R3,LTYP,LN
	JE	NXTLN			:starline only
	L	R5,SKDPTR,LN,LN		:Use list head as pointer ##AL
	LIS	R0,0			:For each line, the last pointer
	ST	R0,STHEAD,R5,		:in each link chain is zero
	LHI	R8,2*(NLINKS-1)		:Start at last link descriptor
EACHKD	L	KD,KDKN,R8,R8
	LB	R0,KTYP,KD
	CLHI	R0,STRTYP		:Star Link 
	JN	NXTKD
	L	R0,LNKKEY,KD		:Compare Key from Descriptor
	CI	R0,0FFFFFFFF		:If star-xlink,skip
	JE	NXTKD
	SRLS	R8,1			:KN/2 ###AL
	LB	R0,SXLNKN,R8,		:Chain the same starline#
	SLLS	R8,1
	AR	R0,R0			:2*LN, key is not in the list but
	CR	R0,LN			: line# may by true after Xray IK
	JN	NXTKD
	LH	R0,SXNDID,R8,		:get ndid for the new starlink
	JL	KYMTCH			:if SXNDID=ffff, no Xray IK cmd
	STH	R0,NDID,KD		:store to NDID and ONDID fields
	LIS	R0,0			:this came from star-xlink
	STH	R0,ONDID,KD		: ONDID=0			###AL
KYMTCH	L	R0,STHEAD,R5,		:Following KD in chain (to follow )
	ST	R0,NXTLNK,KD		:This KD becomes the following one
	ST	KD,STHEAD,R5,		:to the next one we find
NXTKD	SIS	R8,2			:Go to next link descriptor pointer
	JGE	EACHKD
NXTLN	SIS	LN,2			:Continue for next line until all
	JGE	EACHLN			:lines are initialized for STRLNKS

::CREATE A FREE LIST OF STAR XLINKS FOR XRAY >IK CMD TO ENTER KEYS &
::CHAIN THEM TOGETHER
	LHI	R8,2*(NLINKS-1)		:Start at last link descriptor

STRXKD	L	KD,KDKN,R8,R8
	LB	R0,KTYP,KD
	CLHI	R0,STRTYP		:Star Link 

	JN	NXTXKD
	L	R0,LNKKEY,KD		:Compare Key from Descriptor
	CI	R0,0FFFFFFFF		: with 0ffffffff to identify STRXLK
	JEFS	KYMPTR			:If MATCH then process pointers

NXTXKD	SIS	R8,2			:Go to next link descriptor pointer
	JGE	STRXKD
	J	XKDFIN			:finish chaining

KYMPTR	L	R0,STXPTR,,		:Following KD in chain (to follow )
	ST	R0,NXTLNK,KD		:This KD becomes the following one
	LIS	R0,0			:Zero out ONDID
	STH	R0,ONDID,KD
	ST	KD,STXPTR,,		:store KD as the top of the list
	J	NXTXKD			:next chaining
XKDFIN	
	EI	:STRHUB

::Continue with sync line and SIO initialization
	LHI	R0,SYLMRK-SEG1		:INIT SYLVER P-COUNTERS
	LA	R1,QSYLVR
	LHI	R2,NLINES
	JAL	R8,HCSET

	IF	XRESET			:###wjl
	LHI	R11,NETID
	LHI	LN,(NLINES-1)*2		:reset all lines
IZLN3	STH	R11,LNETID,LN,		:init NETID for all lines
	ELSE
	LHI	LN,(NLINES-1)*2		:RESET ALL LINES
IZLN3	HS	0
	EI	:XRESET
	IF	STRHUB			:STRHUB INIT SIO AND RESET XMIT
					: BUFFER HERE, NO RSTSTR CALL
	LB	R9,LTYP,LN		:CHECK IF STR LINE ##AL
	JE	IZLNA			:SKIP IF NOT
	LCS	R0,2			:INIT LINE IN LIMBO
	ST	R0,KDLN,LN,LN
	LHL	R6,SDLN,LN		:GET SD
	JAL	R7,RSTORE		:INIT RESET XMIT BUFFER
	LR	R1,LN			:INIT SIO LINE
	SHI	R1,(NLINES-SILINS)*2
	SLLS	R1,3
	LCS	R0,3
	STH	R0,SIOSTT+8,R1,		:UPDATE SIOSTT+8
	JAL	R10,SIOIZ0
	LHI	R0,SIOIDL-SEG1		:1ST LINK SIO STATE IN IDLE
	STH	R0,SIOTST,LN,
	IF	SIBFRL			:###LSH
	L	R6,SIORSP,LN,LN		:###LSH
	ELSE	:NOT SIBFRL
	LHL	R6,SIORSP,LN
	EI	:SIBFRL			:###LSH

	SHI	R6,VSDSZ-6
	JAL	R7,RSTORE		:ALSO COPY TO SIORSP
	JFS	IZLNA1
IZLNA	EI	:STRHUB
	JAL	R9,RSTSTR
IZLNA1
	LHL	R1,SVBDIS,LN		:IGNORE ANY DATA IN INPUT BUFF
	LCS	R0,4
	NH	R0,SVNTIP,R1,
	STH	R0,SVNTOP,LN
	SIS	LN,2
	JGE	IZLN3			:##AL

	LA	R1,BGLIST		:CLEAR OUT BAD GUY LIST
	LHI	R2,BGLSIZ+MRESTZ	: AND RESET LIST
	JAL	R8,HCLEAR
	L	R10,IZLNLR		:RESTORE LINK REGISTER
	JR	R10

	SUBTTL	LINKER (SIOIZ - Initialize SIO lines)

	IF	SILINS

::*********************************************************************
::
::	SUBROUTINE:	SIOIZ:
::	FUNCTION:	Initialize SIO lines
::	CALLING SEQ:	JAL	R10,SIOIZ	Called from G02SEC.
::	CALLS:		JAL	R10,SIOIZ0
::
::*********************************************************************

:	SIOIZ IS CALLED FROM THE TWO-SECOND ROUTINE AND POLLS ALL SIO
:	LINES LOOKING FOR LINES WHICH HAVE HAD AN INTERRUPT AND NEED TO
:	BE RESTARTED.  THE INDICATION THAT AN SIO LINE NEEDS
:	RE-INITIALIZATION IS BASED ON A NON-ZERO VALUE IN SIOSTT+8.  IF
:	AN SIO INTERRUPT HAS OCCURRED, THE SIOSTT+8 VALUE IS THE STATUS
:	SENSED IN THE INTERRUPT ROUTINE.

SIOIZ	HS	0
	LHI	LN,SBASE		:CHECK ALL SIO LINES
	STH	R10,SIOIZL		:SAVE RETURN
SIOIZZ	JAL	R10,SIOIZ0		:ATTEMPT TO INITIALIZE LINE
	AIS	LN,2			:ADVANCE TO NEXT LINE
	CLHI	LN,NLINES*2		:ALL DONE?
	JLBS	SIOIZZ			:NO, LOOP ON
	LHL	R10,SIOIZL		:YES, RECOVER LINK
	J	SEG1,R10,,		:AND RETURN

::*********************************************************************
::
::	SUBROUTINE:	SIOIZ0:
::	FUNCTION:	Initialize SIO lines
::	CALLING SEQ:	JAL	R10,SIOIZ0
::	INPUT:		LN = 2*Line Number
::	CALLS:		JAL	R8,CRYPTO
::			HC	xxxx
::
::*********************************************************************

:	SIOIZ0 WILL INITIALIZE THE SIO LINE INDICATED BY LN IF THE
:	STATUS HW AT SIOSTT+8 IS NON-ZERO. THE INITIALIZATION CONSISTS
:	OF ISSUING CONNECT, START OUTPUT,AND START INPUT SVC'S.
:
:	SIOIZ0 IS FIRST INVOKED AT NODE STARTUP TIME (NSTART CALLS IZLINKR
:	CALLS RSTSTR CALLS SIOIZ0). RSTSTR WRITES A -3 INTO SIOSTT TO
:	CAUSE INITIALIZATION WITHOUT GENERATING CRYPTO MESSAGES

:	SIOIZT - SIO INITIALIZATION TIME EQUATE				###wjl
:	USED BELOW AS TIME TO WAIT FOR INITIALIZATION TO COMPLETE	###wjl
	IF	TSI		:					###wjl
SIOIZT	EQ	$A 8000		:WAIT 20 MS FOR TSI			###wjl
	ELSE	HMICRO		:					###wjl
SIOIZT	EQ	$A 4000		:WAIT 10 MS FOR HMICRO - 1ST LOOP	###wjl
SIOIZU	EQ	$A 1000		:WAIT 10 MS FOR HMICRO - 2ND LOOP	###wjl
	ELSE	:NOT TSI OR HMICRO					###wjl
SIOIZT	EQ	$A 800		:WAIT 02 MS FOR ENGINE			###wjl
	EI			:					###wjl

SIOIZ0	HS	0
	LHI	R6,MSBASE,LN	:SET R6 TO 2*(RELATIVE SIO LINE NUMBER)
	SLLS	R6,3		:AND MULTIPLY BY 8
	LR	R3,R6		:R3 = 16*(RELATIVE SIO LINE NUMBER)
	AR	R6,R6		:R6 = 32*(RELATIVE SIO LINE NUMBER)
	LR	R7,R6
	AI	R6,SIOBLK	:POINTER TO CURRENT OUTPUT CONTROL
	AI	R7,SIOBLK+10	:POINTER TO NEXT OUTPUT CONTROL
	LI	R2,SIOEND	:POINT TO END OF SIO DMA AREA
	GL	SIOEND
	AI	R3,SIOSTT	:POINTER TO CURRENT STATUS AREA

:	THE HALFWORD AT SIOSTT+8 IS NON-ZERO IF SIO INITIALIZATION IS
:	REQUIRED.  IF AN SIO INTERRUPT IS TAKEN, THE INTERRUPT ROUTINE
:	STORES THE POSITIVE STATUS WORD IN SIOSTT+8, SINCE
:	RE-INITIALIZATION IS NECESSARY AFTER AN SIO INTERRUPT.  IF THE
:	SOFTWARE DECIDES TO INITIALIZE, IT STORES A NEGATIVE VALUE INTO
:	SIOSTT+8.

SIOIZ2	LH	R1,8,R3		:SEE IF INITIALIZATION REQUIRED
	JER	R10		:NO, RETURN TO CALLER

	CLHI	R1,0FFFF	:BAD SIO RECORD LENGTH?			###OAS
	JE	SIOIZ8		:YES - SIOSTT+8 SET TO -1 IN SIORIN	###OAS
				:SEND CRYPTO MSG 53 AND INIT		###OAS
	CLHI	R1,0FFFE	:NO RECS RECEIVED FOR 4 SECS?		###OAS
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -2 IN LNCHCK	###OAS
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
	CLHI	R1,0FFFD	:LINE GONE TO RESET STATE?		###OAS
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -3 IN RSTSTR	###OAS
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
	CLHI	R1,0FFFC	:DMA TIME OUT?				###OAS
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -4 IN G01SEC	###OAS
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
	IF	ISIS
	CLHI	R1,0FFFB	:RE-INIT DUE TO PORT SWITCH?
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -5 IN SIOIZ0
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
	EI	:ISIS
	IF	HMICRO		:HDLC micro only			###wjl
	CLHI	R1,0FFFA	:re-init due to software init timeout?	###wjl
	JE	SIOIZC		:yes - SIOSTT+8 set to -6 in SIOIZ0	###wjl
	EI	:HMICRO		:					###wjl

:	NOT A SOFTWARE "INTERRUPT" BUT A REAL ONE, SIOSTT+8 CONTAINS
:	4 NIBBLES OF - INTERRUPT STATUS, PORT #, 0, CONDITION CODE.

SIOIZ3	IF	STRHUB
	LB	R8,LTYP,LN
	JEFS	SIOIZX
	LIS	R8,0		:NBR# 0000 FOR STAR LINE
	JFS	SIOIZY
SIOIZX	EI	:STRHUB
	LHL	R8,NGSVLN,LN,	:REAL INTERRUPT...GET LAST NEIGHBOR ON LINE
SIOIZY	LR	R0,R1		:R0 = INT. STAT, PORT#, 0, MBOARD STAT.	###OAS
	LR	R1,LN		:GET LINE#*2
	SLLS	R1,0F		:SHIFT TO HO HW
	OR	R1,R8		:COMBINE LINE# AND LAST NEIGHBOR
	ST	R1,CRYSBF,,	:FOR HW3&4 OF CRYPTO REPORT		###OAS
	LR	R1,R0		:R1 = STAT - PORT - 0 - CC		###OAS
	NI	R1,0000F000	:R1 = STAT - 0 - 0 - 0			###OAS
	SLLS	R1,4		:MOVE STATUS TO HO HW			###OAS
	NHI	R0,000F		:R0 = CC				###OAS
	OR	R0,R1		:AND COMBINE FOR CRYPTO HW1 & 2		###OAS
	JAL	R8,CRYPTO	:SEND CRYPTOGRAM
	HC	CRYE1D		:INDICATE SIO LINE INITIALIZATION

:	JUMP BACK HERE FROM SIOIZ8 or SIOIZC
:	SOFTWARE-INDUCED SINGLE LINE INITIALIZATION
SIOIZ4	LIS	R0,0		:CLEAR OUT INITIALIZATION CONDITION
	STH	R0,8,R3
	LR	R0,LN		:SIO LINE NUMBER * 2
	LI	R1,SIOIPG	:SIOIPG =START OF HDLC INITIALIZATION CCW BLOCK

	IF	ISIS
	SRLS	R0,1		:LINE NUMBER
	SVC	IO,90		:CONNECT SIO LINE. R0,R1,R2,R3 = PARAMETERS
	JAL	R12,SVCE39	:ERROR, CRASH
	LH	R8,0,R3		:SEE IF PORT AVAILABLE			###OAS
	CLHI	R8,0FFFF	:IF FFFF PORT NOT AVAILABLE
	JN	SIOPT1		:PORT AVAILABLE
	LCS	R8,5		:FLAG -5 IN SIOSTT+8 TO CAUSE
	STH	R8,8,R3		:RE-INIT TO OCCUR
	SBT	R0,SIOPTA	:FLAG PORT AS UNAVAILABLE
	JNFS	SIOPT2		:PREVIOUSLY FLAGGED, NO CRYPTO MESSAGE
	JAL	R8,CRYPTO	:REPORT SIO PORT UNAVAILABLE, R0 = LINE#
	HC	CRYE72
	JFS	SIOPT2		:AND CONTINUE
SIOPT1	RBT	R0,SIOPTA	:FLAG PORT AS AVAILABLE
	SVC	IO,0B0		:START OUTPUT - R1 CONTAINS CCW ADDRESS
	JAL	R12,SVCE3B	:ERROR, CRASH
SIOPT2	HS	0		:SKIP OUT SVC DUE TO PORT UNAVAILABLE	###OAS

	ELSE	:not ISIS
	SVC	0F,SV.CSI	:CONNECT SIO LINE--SKIP RETURN IF SUCCESS
	JAL	R12,SVCE0C	:IMMEDIATE RETURN IS ERROR, CRASH
SIOIZ5	SVC	0F,SV.OSI	:START OUTPUT--SKIP RETURN IF SUCCESS
	JAL	R12,SVCE0E	:IMMEDIATE RETURN IS ERROR, CRASH
	EI	:ISIS

SIOIZ6	HS	0
	LHI	R8,SIOIZT	:WAIT...				###wjl
SITTLP	SIS	R8,1		:...FOR INITIALIZATION TO COMPLETE
	JGEBS	SITTLP
	IF	HMICRO		:					###wjl
	LHI	R8,SIOIZU	:wait 10 MS more if necessary		###wjl
SIOIZ7	SIS	R8,1		:					###wjl
	JL	SIOIZD		:time to flag re-init??			###wjl
	LH	R4,SIOIPG+18,,	:					###wjl
	CLHI	R4,0200		:STATUS CHANGE				###wjl
	JNBS	SIOIZ7		:NO					###wjl
	LR	R8,LN		: (line#*2				###wjl
	SRLS	R8,1		:  line#				###wjl
	RBT	R8,SIOIGN	:  reset crypto flag bit for future use)###wjl
SIOIZ9	LHI	R8,0006		:YES, CHANGE TO ORIGINAL CCW		###wjl
	STH	R8,SIOIPG+18,,
	LCS	R8,1		:RESTORE -1 TO R8
	EI	:HMICRO
	LHL	R4,SIBUFP,LN	:GET RELATIVE INPUT BUFFER ADDRESS
	STH	R8,SIBUF,R4,	:	AND STORE A -1 IN FIRST HALFWORD (MEANS
STLP2	HS	0		:	READY FOR INPUT)
	LIS	R4,0
	STH	R4,0A,R3	:CLEAR SECOND HALF OF SIOSTT+8		###OAS
	STH	R4,SIBUFN,LN	:SET INDEX TO BEGINNING
	IF	SIBFRL		:SIO BUFFER RELOCATION ###LSH
	ST	R6,SIOCO,LN,LN	:CHAINING FOR CONTROL BLOCKS - SET CURRENT
	ST	R7,SIONO,LN,LN	:	AND NEXT OUTPUT POINTERS
	ELSE	:NOT SIBFRL	:###LSH
	STH	R6,SIOCO,LN	:CHAINING FOR CONTROL BLOCKS - SET CURRENT
	STH	R7,SIONO,LN	:	AND NEXT OUTPUT POINTERS
	EI	:SIBFRL
	LHI	R8,200
	STH	R8,0,R6		:IDLE CONTROL BLOCKS
	STH	R8,0,R7
	IF	SIBFRL		:###LSH
	L	R1,SIOIN,LN,LN	:POINT TO INPUT CCW BLOCK ADDRESS
	ELSE	:NOT SIBFRL
	LHL	R1,SIOIN,LN	:POINT TO INPUT CCW BLOCK ADDRESS
	EI	:SIBFRL		:###LSH
	IF	ISIS
	TBT	R0,SIOPTA	:IS SIO PORT AVAILABLE ?		###OAS
	JNFS	SIOPT3		:NO, SKIP SVC
	SVC	IO,0A0		:START INPUT
	JAL	R12,SVCE3A	:ERROR CRASH
SIOPT3	HS	0

	ELSE	:NOT ISIS
	SVC	0F,SV.ISI	:START INPUT
	JAL	R12,SVCE0D	:ERROR, CRASH
	EI	:ISIS

	JR	R10		:RETURN

:	REPORT SIO BAD RECORD LENGTH TO XRAY
SIOIZ8	LR	R0,LN
	SLLS	R0,0F			:ALIGN LINE NUMBER IN UPPER HW,
	IF	STRHUB
	LB	R8,LTYP,LN
	JEFS	SIOIZA
	LIS	R8,0
	JFS	SIOIZB
SIOIZA	EI	:STRHUB
	LHL	R8,NGSVLN,LN,		:	NEIGHBOR NUMBER IN LOWER HW
SIOIZB	OR	R0,R8
	ST	R0,CRYSBF		:STORE FOR CRYPTOGRAM
	JAL	R8,CRYPTO,,		:BAD SIO RECORD LENGTH
	HC	CRYE53
	J	SIOIZ4

:	REPORT SIO INITIALIZATION SOFTWARE TIMEOUT TO XRAY		###wjl
	IF	HMICRO		:HDLC micro only			###wjl
SIOIZC	HS	0		:					###wjl
	LR	R0,LN		:get line#*2				###wjl
	SRLS	R0,1		:line#					###wjl
	SBT	R0,SIOIGN	:flag for no crypto next time		###wjl
	JN	SIOIZ4		:previously flagged?			###wjl
	JAL	R8,CRYPTO	:report SIO init software timeout	###wjl
	HC	CRYE7B		: R0=line#				###wjl
	J	SIOIZ4		:continue...				###wjl

:	FLAG PORT FOR RE-INIT AND MARK AS UNAVAILABLE			###wjl
SIOIZD	HS	0		:					###wjl
	LCS	R8,6		:flag -6			 	###wjl
	STH	R8,8,R3		: in SIOSTT+8 to cause re-init		###wjl
	IF	ISIS		:					###wjl
	SBT	R0,SIOPTA	:flag port unavailable			###wjl
	EI	:ISIS		:					###wjl
	J	SIOIZ9		:continue...				###wjl
	EI	:HMICRO		:					###wjl	

::*********************************************************************
::
::	ABNORMAL RETURN FROM SIO SVC'S FOR CONNECT, OUTPUT AND INPUT
::	AND, FOR SOLO, QUERY SIO STATUS.	###OAS 3/9/83
::
::	RETURN CODES IN HO HW OF R0
::
::	ISIS -- CONNECT MBOARD	SVC IO,090
::		IMPROPER REGISTER USAGE		RC=0001
::		LU RANGE CHECK			RC=0002
::		NULL LU POINTER			RC=0002
::		BAD DEVICE TYPE			RC=0002
::		MBOARD RC=8, 35MS TIMEOUT	RC=0003
::		MBOARD RC=4, MBOARD ERROR	RC=0004
::		CCW NOT ON BND10		RC=0005
::		INVALID RETURN ADDRESS		RC=0005
::
::	ISIS -- OUTPUT, INPUT SIO  SVC IO,0B0	SVC IO,0A0
::		SAME RETURN CODES AS ABOVE, BUT IN ADDITION
::		SVC IO,090 NOT ISSUED YET	RC=0002
::
::	SOLO -- CONNECT, OUTPUT, INPUT SIO  SVC 0F,0C  SVC 0F,0E  SVC 0F,0D
::		QUERY SIO STATUS  SVC 0F,0F
::		BAD LINE NUMBER			RC=0002
::		MBOARD RC=8,	MS TIMEOUT	RC=0003
::		MBOARD RC=4, MBOARD ERROR	RC=0004
::
::*********************************************************************

	IF	ISIS

SVCE39	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE IN HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZC			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV39C)			:ALL OTHER RETURN CODES, CRASH	###OAS
SVCE3B	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE FROM HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZO			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV3BC)			:ALL OTHER RETURN CODES, CRASH	###OAS
SVCE3A	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE IN HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZI			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV3AC)			:ALL OTHER RETURN CODES, CRASH	###OAS

	ELSE	:not ISIS
SVCE0C	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE IN HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZC			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV0CC)			:ALL OTHER RETURN CODES, CRASH	###OAS
SVCE0E	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE IN HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZO			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV0EC)			:ALL OTHER RETURN CODES, CRASH	###OAS
SVCE0D	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE IN HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZI			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV0DC)			:ALL OTHER RETURN CODES, CRASH	###OAS
SVCE0F	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE IN HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZS			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV0FC)			:ALL OTHER RETURN CODES, CRASH	###OAS
	EI	:(NOT)ISIS

	EI	:SILINS

	SUBTTL	LINKER (SIQURY - Query SIO status)

::*********************************************************************
::
::	SUBROUTINE:	SIQURY:				###LSH
::	FUNCTION:	Query SIO status, and save it in SIOSTT.
::	CALLING SEQ:	Scheduled by 64 MS logic
::
::*********************************************************************

	IF	1-ISIS
	IF	STRHUB!STRRMT
SIQURY	HS	0
	LHI	LN,(NLINES-SILINS)*2	:NODE CODE 1ST SIO LINE #
	LA	R7,SIOSTT,,		:POINT TO SIO STATUS BLOCKS
	GL	SIOSTT
SIQHS1	LB	R1,LTYP,LN		:CHECK FOR STAR LINE
	JE	SIQHS2			:NOT STAR LINE, CHECK NEXT LINE
	LR	R0,LN			:SVC WANTS LINE #*2 IN R0
	LR	R1,R7			:POINT TO STATUS SAVE AREA
	SVC	0F,SV.QSI		:READ AND STORE THE STATUS
	JAL	R12,SVCE0F		:SVC SAW INVALID SET-UP, CRASH
SIQHS2	AHI	R7,10			:POINT TO NEXT LN'S AREA
	AIS	LN,2			:NEXT LINE #
	CLHI	LN,NLINES*2		:DONE ALL SIO LINES ?
	JL	SIQHS1			:NO - CONTINUE
	J	EXDISM			:RETURN TO EXEC LOOP
	EI	:STRHUB!STRRMT
	EI	:1-ISIS

	SUBTTL	LINKER (LKVOLT - Test for links overloaded)

::*********************************************************************
::
::	SUBROUTINE:	LKVOLT:
::	FUNCTION:	Test for network links overloaded or saturated
::	CALLING SEQ:	JAL	R10,LKVOLT	Called from G01SEC.
::	CALLS:		JAL	R10,SUP14,,	:to make overload reports
::			JAL	R8,CRYPTO
::			HC	xxxx
::
::*********************************************************************

:	TEST FOR NETWORK LINKS OVERLOADED (ALL ACTIVE CHANNELS NOT
:	BEING SERVICED FREQUENTLY ENOUGH) OR LINK SATURATED
:	(OUT OF BANDWIDTH). REPORT TO SUP IF THRESHOLD EXCEEDED.
:
:	COMPARE LINK LOAD COUNTS TO REPORTING THRESHOLDS, AND MAKE
:	REPORT IF THRESHOLDS EXCEEDED.  OVERLOAD COUNTS ARE MAINTAINED
:	IN LKOVLD, AND LINK SATURATED COUNTS IN LKSTCT.  BOTH LKOVLD AND
:	LKSTCT ARE UPDATED BY THE 'CKOVLD' ROUTINE WHICH RUNS EVERY 1/2
:	SECOND.
:
:	LINK NUMBER IN KN, LINK DESCRIPTOR IN KD.

:	PATCHABLE THRESHOLD REFERENCE VALUES
LKOVCT	HC	LKOVTH
	SYAD(LKOVCT)			:OVERLOAD THRESHOLD
LKSATC	HC	LKSTTH
	SYAD(LKSATC)			:SATURATED THRESHOLD

LKVOLT	HS	0
	ST	R10,LNKRET		:SAVE RETURN LINK
	LHI	KN,NLINKS		:LINK NUMBER - SCAN ALL LINKS
	LIS	R12,0			:FOR REFRESHING COUNTERS
	LHI	R7,8000			:R7 FOR OR'ING HI-ORDER BIT OF HALFWORD

LKOV02	SIS	KN,1			:TEST ALL LINKS
	JL	LKOVXT			:DONE

	TBT	KN,ALINKS		:ACTIVE LINK?
	JEBS	LKOV02			:NO
	SLL	KN,1
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR ADDRESS
	SRL	KN,1
	LB	R0,NLAT,KD		:ANY LINES ATTACHED?
	JEBS	LKOV02			:NO - LINK NOT UP
	LHL	R1,LKSTCT,KN,KN		:GET LAST MINUTE'S SATURATED COUNT
	STH	R1,KS.SAT,KD		:	AND SAVE IN LINK DESCRIPTOR
	LHL	R1,LKOVLD,KN,KN		:GET LAST MINUTE'S OVERLOAD COUNT
	STH	R1,KS.OVL,KD		:	AND SAVE IN LINK DESCRIPTOR
	STH	R12,LKOVLD,KN,KN	:CLEAR COUNTER FOR NEXT MINUTE
	CLH	R1,LKOVCT		:OVERLOAD THRESHOLD EXCEEDED?
	JLE	LKOV06			:NO -  CHECK LINK SATURATED COUNT

:	REPORT LINK OVERLOAD TO SUP...
	LHI	R5,LKOVMS		:TYPE 14, SUBTYPE LKOVMS
LKOV04	HS	0
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER FOR REPORT
	JE	LKOV02			:(IF ZERO, LINK NOT UP)
	IF	T2GATE			:##AL
	ST	R0,RTMT1
	ST	R1,RTMT2
	ST	R15,RTMT3
	LBR	R3,R5			:GET SUBTYPE
	OHI	R3,1400			:TYPE
	LBR	R1,KN			:LINK NO.
	JAL	R10,GSUPLG,,		:GATEWAY TO INET SUP LOG
	GL	GSUPLG
	L	R0,RTMT1
	L	R1,RTMT2
	L	R15,RTMT3		:###EV
	EI	:T2GATE##AL
	STH	R0,CRYSBF+2		:STORE NEIGHBOR # FOR CRYPTO	###OAS
	OR	R0,R7
	STH	R0,SUPMBF		:STORE NEIGHBOR NUMBER FOR REPORT
	OR	R1,R7
	STH	R1,SUPMBF+2		:AND NUMBER OF OCCURRENCES
	LIS	R6,2			:INDICATE 2 HALFWORDS
	JAL	R10,SUP14,,		:REPORT LINK CONDITION TO SUPERVISOR
	GL	SUP14
	LR	R0,R1			:SAVE COUNT FOR CRYPTO		###OAS
	NHI	R0,7FFF			:STRIP OFF HO BIT		###OAS
	CLHI	R5,LKOVMS		:CHECK WHICH CRYPTO TO SEND	###OAS
	JNFS	LKOV08			:SEND SATURATED			###OAS
	JAL	R8,CRYPTO		:LINK OVERLOAD			###OAS
	HC	CRYE36			:				###OAS
	LIS	R12,0			:RECOVER R12 IN CASE MESSED UP	###OAS
	JFS	LKOV06			:				###OAS
LKOV08	HS	0			:				###OAS
	JAL	R8,CRYPTO		:LINK SATURATED			###OAS
	HC	CRYE37			:				###OAS

LKOV06	LHL	R1,LKSTCT,KN,KN		:NUMBER OF LINK SATURATED OCCURRENCES
	STH	R12,LKSTCT,KN,KN	:CLEAR COUNTER
	CLH	R1,LKSATC		:SATURATED THRESHOLD EXCEEDED?
	JLE	LKOV02			:NO

:	REPORT LINK SATURATED TO SUP
	LHI	R5,LKSTMS		:TYPE 14, SUBTYPE LKSTMS
	J	LKOV04
LKOVXT	L	R10,LNKRET
	JR	R10			:RETURN

	SUBTTL	LINKER (Trace-sync set-up subroutines)

	IF	TSTSZE

::*********************************************************************
::
::	SUBROUTINE:	TSFUAL:
::	FUNCTION:	Check if tracing desired on unassigned line...
::	CALLING SEQ:	JAL	R2,TSFUAL
::	INPUT:		R4  = Header HW
::	PRESERVED:	R15
::	CALLS:		JAL	R0,TSFMRK
::
::*********************************************************************

:	COMMON FOR SYNC AND SIO LINES.
TSFUAL	HS	0
	CLH	LN,TSLINE		:TRACING ON THIS LINE DESIRED?
	JNR	R2			:NO, RETURN
	ST	R15,TSRSVE		:SAVE LINK REGISTER
	JAL	R0,TSFMRK		:SET UP ENTRY
	STH	R4,TSFTBL+2,R15		:STORE THE ENTRY (HEADER HALFWORD)
	LIS	R0,0
	STB	R0,TSFTBL+4,R15		:CLEAR RECN FIELD		###OAS
	LIS	R0,TS.UAL		:ENTRY - UNASSIGNED LINE
	STB	R0,TSFTBL,R15
	L	R15,TSRSVE
	JR	R2

:	TSFMRK (FOR FOREGROUND) AND TSBMRK (FOR BACKGROUND) SET UP EVENT
:	ENTRIES FOR CALLING PROCESS.  FASTC AND THE LINE NUMBER ARE
:	STORED, AND THE ENTRY INDEX REGISTER IS RETURNED (R15 FOR
:	FOREGROUND, R7 FOR BACKGROUND).

::*********************************************************************
::
::	SUBROUTINE:	TSFMRK:
::	FUNCTION:	Set up foreground event entry
::	CALLING SEQ:	JAL	R0,TSFMRK
::	INPUT:		LN  = Line Number*2
::	OUTPUT:		R15 = New entry index
::	PRESERVED:	LN  = Line Number*2
::
::*********************************************************************

TSFMRK	HS	0
	ST	R0,TSRSVE+4		:SAVE RETURN ADDRESS
	LHL	R15,TSFPTR
	AIS	R15,TSESZE		:COMPUTE NEW ENTRY ADDRESS
	NHI	R15,TSTSZE-1		:	(ALLOW FOR WRAP)
	STH	R15,TSFPTR
	L	R0,FASTC,,
	ST	R0,TSFTBL+4,R15		:STORE FASTC TIME
	SRLS	LN,1			:FORM TRUE LINE NUMBER
	STB	LN,TSFTBL+1,R15		:STORE LINE NUMBER
	AR	LN,LN			:RECOVER 2*LINE NUMBER
	L	R0,TSRSVE+4
	JR	R0			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TSBMRK:
::	FUNCTION:	Set up background event entry
::	CALLING SEQ:	JAL	R8,TSBMRK
::	INPUT:		LN  = Line Number*2
::	OUTPUT:		R7  = New entry index
::	PRESERVED:	LN  = Line Number*2
::
::*********************************************************************

TSBMRK	HS	0
	LHL	R7,TSBPTR
	AIS	R7,TSESZE		:COMPUTE NEW ENTRY ADDRESS
	NHI	R7,TSTSZE-1		:	(ALLOW FOR WRAP)
	STH	R7,TSBPTR
	L	R9,FASTC,,
	ST	R9,TSBTBL+4,R7		:STORE FASTC TIME
	SRLS	LN,1			:FORM TRUE LINE NUMBER		###OAS
	STB	LN,TSBTBL+1,R7		:STORE TRUE LINE NUMBER		###OAS
	AR	LN,LN			:RECOVER 2*LINE NUMBER		###OAS
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TSNSPK:
::	FUNCTION:	Save most recent packets when link goes out.
::	CALLING SEQ:	JAL	R8,TSNSPK
::	INPUT:		KD  = linK Descriptor
::	DESTROYED:	R2, R3, R4, and R5
::
::*********************************************************************

TSNSPK	HS	0
:	SAVE UP TO 10 INPUT PACKETS IN TSNISV
	LHL	R3,ISEC,KD	:INITIAL INPUT SECTOR (PACKET 0 MOD WSIZ)
	IF	EXPWSZ
	L	R3,BREC,R3
	ELSE
	LHL	R3,BREC,R3
	EI
	LA	R2,RECBUF,R3,	:R2 POINTS TO FIRST INPUT SECTOR
	LA	R3,TSNISV,,	:COPY DESTINATION IN R3
:	SINCE INPUT AND OUTPUT PACKETS ARE ASSIGNED CONTIGUOUS MEMORY,
:	MOVE ENTIRE SECTOR AREA FOR EACH...
	LB	R5,WSIZ,KD	:NUMBER OF PACKETS TO MOVE
	CLHI	R5,10		:ENFORCE REASONABLE LIMIT - NO
	JLEFS	TSNSP2		:	MORE THAN 10 PACKETS SAVED
	LHI	R5,10
TSNSP2	SLLS	R5,7		:SUM OF BYTES IN ALL PACKETS (WSIZ*80)
	SIS	R5,2		:ADDRESS LAST HALFWORD
	AR	R2,R5		:	OF SOURCE AND
	AR	R3,R5		:	DESTINATION FOR COPY
	LR	R4,R5
	SLLS	R4,3		:NUMBER OF BITS TO COPY
	SHI	R4,10		:DON'T COPY ALL DUE TO MICROCODE PRE-FETCH

	COPY	R2,R4		:SAVE MOST RECENT INPUT PACKETS IN TSNISV
	LHL	R0,,R2
	STH	R0,-2,R3,	:FINISH COPY...

	LHL	R3,OSEC,KD	:INITIAL OUTPUT SECTOR (PACKET 0 MOD WSIZ)
	IF	EXPWSZ
	L	R3,BREC,R3
	ELSE
	LHL	R3,BREC,R3
	EI
	LA	R2,RECBUF,R3,	:POINTS TO FIRST OUTPUT SECTOR
	LA	R3,TSNOSV,,	:PACKET SAVE DESTINATION ADDRESS
	AR	R2,R5
	AR	R3,R5		:POINT TO END OF COPY FIELDS
	SLLS	R5,3

	COPY	R2,R5		:SAVE MOST RECENT OUTPUT PACKETS IN TSNOSV

	JR	R8		:RETURN

	EI	:TSTSZE

	SUBTTL	LINKER (LINKER - Detach, attach scheduler)

::*********************************************************************
::
::	PROCESS:	LINKER:
::	FUNCTION:	Detach, attach scheduler
::	CALLING SEQ:	LINKER is scheduled every 125 ms as a result of
::	a request for services (ie, when a reset is detected on any line)
::	and hara-kiri's when all its processing is done.
::	SUB-PROCESSES:	DETLIN, ATTLIN
::	RETURNS:	J	EXDIS
::
::*********************************************************************

:	ATTACHES NEWLY IDENTIFIED LINES TO EXISTING LINKS, OR, IF NO
:	LINKS EXIST TO THAT NEIGHBOR, CREATES ONE.  DETACHES FROM LINKS
:	LINES THAT HAVE GONE RESET, TEARING DOWN LINK IF NO ATTACHED LINES
:	REMAIN.

LINKER	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(LINKER)			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU
:	standard set up for jump to biddy	
	LI	R4,LNSIZE
	LA	R3,LINDET		:DETACH LINES
	JAL	R9,BIDDY
	J	DETLIN

	LIS	R2,0
LINKR2	L	R3,LINATT,R2		:COPY LINATT TO LINKAS
	ST	R3,LINKAS,R2
	AIS	R2,4
	CI	R2,LNSIZE
	JL	LINKR2
:	standard set up for jump to biddy
	LI	R4,LNSIZE
	LA	R3,LINKAS
	JAL	R9,BIDDY
	J	ATTLIN

	IF	DB.CPU
	JALMAC(CPUTIZ)			:START CPUTIL FOR LINKER RETURN	###OAS
	CPUTNM(LNKRET)			:CREATE CPUTIL ENTRY FOR LNKRET	###OAS
	EI	:DB.CPU

	LIS	R2,0
	LIS	R3,0
LNKD2	L	R3,LINATT,R2		:CHECK ARRAY
	O	R3,LINDET,R2
	AIS	R2,4
	CI	R2,LNSIZE
	JL	LNKD2
	LR	R3,R3			:ANY BITS SET ?
	JNFS	LNKDIS
	LHI	R0,1F-PLINKR
	RBT	R0,TLINKR
LNKDIS	LA	R0,LINKER
	J	EXDIS

	SUBTTL	LINKER (Periodic processes)

::*********************************************************************
::
::	SUBROUTINE:	G02SLK:
::	FUNCTION:	Two-second logic for the LINKER segment
::	CALLING SEQ:	JAL	R10,G02SLK	Called from G02SEC.
::
::*********************************************************************

G02SLK	HS	0
	LIS	R2,0
G02SL2	L	R0,INHRLS,R2		:CLEAR RESET INHIBIT (EVERY 2 SECS)
	N	R0,INHRST,R2
	X	R0,INHRST,R2
	ST	R0,INHRST,R2
	ST	R0,INHRLS,R2
	AIS	R2,4
	CI	R2,LNSIZE
	JL	G02SL2
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	G01MLS:
::	FUNCTION:	1-minute logic to examine lines suspended and
::			reinstate if appropriate.
::	CALLING SEQ:	JAL	R10,G01MLS	Called from G01MIN.
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R8,GMTLIN,,
::
::*********************************************************************

G01MLS	HS	0
	LIS	R5,0			:R5 = INDEX INTO ARRAY
G01ML1	L	R0,LNSUSO,R5
	JFFO	R0,G01ML2		:BIT SET
	AIS	R5,4			:NEXT WORD
	CLI	R5,LNSIZE		:DONE ?
	JLBS	G01ML1
	J	G01ML4			:NO MORE
G01ML2	RBT	R1,LNSUSO,R5		:FIRST BIT FOUND
	SLLS	R5,3			:FORM LINE NO.
	OR	R1,R5
	SLL	R1,1
	L	R0,KDLN,R1,R1		:LINK DESCRIPTOR INDEX FOR THIS LINE
	SRL	R1,1
	AIS	R0,1			:IF -1, LINE IS SUSPENDED
	JN	G01ML1			:LINE NOT SUSPENDED
	LCS	R0,2
	SLL	R1,1
	ST	R0,KDLN,R1,R1		:LINE WILL NOW LISTEN FOR RESETS
	SRL	R1,1
	LR	LN,R1			:LINE NO. FOR GMTLIN
	AR	LN,LN			:*DOUBLED
	JAL	R8,GMTLIN,,		:*GET TIME
	J	G01ML1
G01ML4	LIS	R2,0
G01ML5	L	R0,LNSUSC,R2		:COPY LNSUSC TO LNSUSO
	ST	R0,LNSUSO,R2
	LIS	R0,0
	ST	R0,LNSUSC,R2		:CLEAR LNSUSC
	AIS	R2,4
	CI	R2,LNSIZE
	JL	G01ML5
	JR	R10			:RETURN

	SUBTTL	LINKER (LNCHCK - 4 sec test for records received on line)

::*********************************************************************
::
::	SUBROUTINE:	LNCHCK:
::	FUNCTION:	Tests for records received on all lines.
::	CALLING SEQ:	JAL	R10,LNCHCK	Called from G04SEC.
::	CALLS:		JAL	R8,TSBMRK
::			JAL	R8,TSNSPK
::			JAL	R10,KSPEED
::			JAL	R10,SUP13,,
::			JAL	R10,SUP12,,
::			JAL	R8,CRYPTO
::			HC	CRYE1E
::			JAL	R10,SIOIZ0
::
::*********************************************************************

:	**RUNS EVERY 4 SECONDS**
:	FOR T-II LINK WITH MULTIPLE LINES, ALL LINES BUT ONE MAY BE
:	DETACHED EACH TIME THROUGH LNCHCK.  FOR SINGLE-LINE LINK, LINK
:	OUT REPORT IS MADE TO SUPERVISOR FIRST FOUR-SECOND INTERVAL WITH
:	NO RECORDS RECEIVED.  FOUR-SECOND GAPS ARE REPORTED TO XRAY, AND
:	CIRCUITS ARE ACTUALLY ZAPPED (AND RESETS EMITTED) ONLY AFTER
:	MULTIPLE FOUR-SECOND GAPS.
LNCHCK	HS	0
	ST	R10,LNCHLR		:SAVE LINK REG
	LHI	KN,NLINKS-1
LNCH02	SLL	KN,1
	L	KD,KDKN,KN,KN		:LINK DESCRIPTOR
	SRL	KN,1
	LB	R0,NLAT,KD		:NUMBER OF LINES ATTACHED TO THIS LINK
	SIS	R0,1
	JEFS	LNCH06			:SINGLE-LINE LINK - SET KNNLAT TO -1
	STH	R0,KNNLAT,KN,KN		:MAX NUMBER OF LINES TO BE DETACHED
					:	THIS EXECUTION OF LNCHCK
	JFS	LNCH08
LNCH06	TS	KNNLAT,KN,KN		:MAKE LINK OUT REPORT TO SUP IF NO
					:	RECORDS RECEIVED
LNCH08	SIS	KN,1
	JGE	LNCH02			:DO FOR ALL LINKS

	LHI	LN,NLINES-1		:TEST ALL LINES FOR GOOD RECS RECEIVED
LNCH1	SLL	LN,1
	L	KD,KDLN,LN,LN		:IS THIS LINE ATTACHED?
	SRL	LN,1			:RESTORE HALF WORD INDEX       ###SHM
	LR	KD,KD			:RESTORE CONDITION CODES       ###SHM
	JL	LNCH4			:NO			       ###SHM
LCH111	IF	STRHUB
	LB	R0,LTYP,LN,LN
	JE	LNCH11
	L	KD,STHEAD,KD		:1ST LINK KD
LNCHA1	LB	R0,STAFLG,KD		:ONLY WHEN LINK IS UP
	NHI	R0,LNKSTA
	JNFS	LNCH11
	L	KD,NXTLNK,KD		:CHECK ALL LINKS
	JE	LNCH44			:NEXT LINE
	J	LNCHA1			:OR NEXT LINK
LNCH11	EI	:STRHUB
LNCH1A	LB	KN,LKNM,KD		:GET LINK NUMBER

	IF	STRHUB		
	LB	R0,LTYP,LN,LN		:FOR HUB'S STARLINE, NO LNGREC CHECK
	JNFS	LNCH1B			: LKGREC IS CHECKED PER STARLINK ###AL
	EI	:STRHUB

	LIS	R0,1			:NO RECS ON LINE?
	RBT	LN,LNGREC
	JE	LNCH6			:NO RECORD RECEIVED ON LINE
LNCH1B	LIS	R0,4			:BORI ZAP?
	TBT	KN,BORZAP
	JN	LNCH3			:'BORI ZAP', DETACH
	LIS	R0,2
	TBT	KN,LKGREC		:GOOD RECORD RECEIVED ON LINK?
	JN	LNCH2			:YES, LINE OK.			###TZ
	TBT	KN,OLDKGR,,		:ANY GOOD RECORDS ON LINK LAST
					:	TIME THRU?		###TZ
	JE	LNCH6			:NO, DETACH THIS LINE		###TZ
	J	LNCH2			:OTHERWISE, LET IT LIVE		###TZ
LNCH3	STB	R0,DREASN,LN,		:SAVE REASON FOR OUTAGE
	LH	R1,KNNLAT,KN,KN
	SIS	R1,1			:DECREMENT NUMBER OF LINES DETACHED
	STH	R1,KNNLAT,KN,KN		:	THIS EXECUTION OF LNCHCK...
	LB	R1,NLAT,KD		:IS THIS SINGLE-LINE LINK?
	SIS	R1,1
	JNFS	LNCH22			:MULTIPLE LINES, LINK NOT GOING OUT,YET
	STH	R1,KFROZN,KD		:LINK IS GOING OUT...NO LONGER FROZEN
	IF	NGRDTM
	LB	R8,LTYP,LN,LN		:NON-4SEC REPORT, ZERO THE COUNT
	JEFS	LNCH31			:SPECIFIC LINE ONLY		###AL
	STB	R1,LCRPCT,LN,
LNCH31	EI	:NGRDTM
	IF	STRHUB
	LB	R8,LTYP,LN,LN		:For Starline only		###ev
	JEFS	LNC112
	LHI	R8,DETSTA		:SET DETTACH STATE IN THIS STAR
	STB	R8,STAFLG,KD		: LINK ##AL
LNC112	EI	:STRHUB
LNCH22	SBT	LN,LINDET		:DETACH THIS LINE

	IF	TSTSZE
	LHL	R8,NDID,KD
	CLH	R8,TSLINK		:IS THIS LINK OF INTEREST?
	JN	LNCHTX			:NO - NO TRACING
	SLLS	LN,1			:YES - SET UP LINE NUMBER*2 FOR
	JAL	R8,TSBMRK		:	CONSISTENCY AND MAKE NEW ENTRY
	SRLS	LN,1
	STB	R0,TSBTBL+4,R7		:STORE DETACH REASON
	LHL	R8,LRT,KD
	STH	R8,TSBTBL+2,R7		:STORE 'LAST RECORD TORN'
	LHI	R8,TS.DET
	STB	R8,TSBTBL,R7		:STORE ENTRY TYPE
	LIS	R8,0
	STH	R8,TSLINK		:INHIBIT FURTHER TRACING OF THIS LINK
	AIS	R7,TSESZE
	NHI	R7,TSTSZE-1		:ADVANCE INDEX TO NEXT ENTRY AND
	ST	R8,TSBTBL,R7		:	CLEAR FOR EASE IN FINDING
	ST	R8,TSBTBL+4,R7		:	END OF TRACE
	JAL	R8,TSNSPK		:SAVE MOST RECENT PACKETS IN AND OUT
LNCHTX	EI	:TSTSZE
	IF	STRHUB
	LB	R0,LTYP,LN,LN
	JN	LNCH3B			:STAR LINE SKIP THIS ##AL
	EI	:STRHUB
	LCS	R0,1			:PUT LINE IN LIMBO FIRST
	SLL	LN,1
	ST	R0,KDLN,LN,LN
	SRL	LN,1
	IF	SILINS
	CLHI	LN,NLINES-SILINS-1	:UP TO SIO LINES?
	JLEFS	LNCH3A			:NO
	LHI	R0,SIOIDL-SEG1
	STH	R0,SIOTST,LN,LN		:INITIALIZE OUTPUT STATE
	JFS	LNCH3B
	EI	:SILINS

LNCH3A	LR	R1,LN			:IDLE THE LINE
	LIS	R0,0

	IF	ISIS
	SVC	IO,60
	ELSE	:solo
	SVC	0F,SV.CSY
	EI	:ISIS

LNCH3B	LHI	R0,SYLMRK-SEG1		:SO SYLVER DOESN'T GET CONFUSED
	STH	R0,QSYLVR,LN,LN
	LHI	R0,1F-PLINKR		:SCHEDULE LINKER
	SBT	R0,TLINKR
LNCH2	LHI	R0,LNCKTM	:INITIALIZE CONFSG, SO WE CAN DETECT
				:WHEN A LINK GOES LNCKTM TIMES OF
				:4-SECONDS WITH NO RECORDS RECEIVED.	###LH
	IF	STRHUB
	LB	R10,LTYP,LN,LN
	JEFS	LNCH2A
	STH	R0,SCONFS,KN,KN		:PER STRLINK
	JFS	LNCH2B
LNCH2A	EI	:STRHUB
	STH	R0,CONFSG,LN,LN	
LNCH2B	IF	NGRDTM
	LB	R0,LTYP,LN,LN		:NON-4SEC REPORT, ZERO THE COUNT
	JEFS	LNCH2C			: WHENEVER RECVED A GOOD DATA	###AL
	LIS	R0,0
	STB	R0,LCRPCT,LN
LNCH2C	EI	:NGRDTM
	LH	R0,KFROZN,KD		:IS LINK CURRENTLY FROZEN?
	JE	LNCH4			:NO
:	GOOD RECORD RECEIVED FOR LINK WHICH HAS BEEN REPORTED FROZEN TO
:	SUPERVISOR. REPORT LINE ATTACH WITH PROPER LINK SPEED.
	JAL	R10,KSPEED		:RE-COMPUTE LINK SPEED
	LB	R4,KSPD,KD
	NHI	R4,1F			:ISOLATE LINK SPEED
	AHI	R4,13C0			:T-II NEIGHBOR, REPORT NEW LINE ATTACH
LNCH34	AR	LN,LN			:SUP13 EXPECTS LN TO BE LINE NUMBER * 2
	JAL	R10,SUP13,,		:SEND NEW LINE/LINK REPORT TO SUP
	GL	SUP13
LNCH35	SRLS	LN,1
	LIS	R0,0
	STH	R0,KFROZN,KD		:THAW LINK
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER FOR NODE REPORT
	LHL	R0,ANCHN,KD
	OHI	R0,8000			:INCLUDE NUMBER OF CIRCUITS SAVED
	STH	R0,SUPMBF+4
	LHI	R0,NR.LTH
	STH	R0,SUPMBF		:INDICATE LINK THAW NODE REPORT
	JAL	R10,SUP12,,		:SEND NODE REPORT
LNCH4
	IF	STRHUB
	LB	R0,LTYP,LN,LN		:IF STAR LINE GO TO NEXT LINK
	JE	LNCH44
	SLL	LN,1			:FULL WORD KDLN
	L	R0,KDLN,LN,LN
	SRL	LN,1			:BACK TO HALF WORD INDEX       ###SHM
	LR	R0,R0			:RESTORE CONDITION CODES       ###SHM
	JLFS	LNCH44						       ###SHM
	L	KD,NXTLNK,KD		:IF STAR LINE ATTACHED, NEXT   ###SHM
	JE	LNCH44			:LINK			       ###SHM
	J	LNCHA1						       ###SHM
LNCH44	EI	:STRHUB
	SIS	LN,1
	JGE	LNCH1
	LIS	R2,0
LNCH42	L	R0,LKGREC,R2		:UPDATE OLD LKGREC
	ST	R0,OLDKGR,R2
	LIS	R0,0
	ST	R0,LKGREC,R2		:CLEAR LKGREC
	AIS	R2,4
	CI	R2,LKSIZE
	JL	LNCH42
	L	R10,LNCHLR		:RESTORE LINK REG AND
	JR	R10			:	RETURN

:	NO RECORDS RECEIVED ON LINE THIS PAST 4-SECOND INTERVAL.
:	INCREMENT NUMBER OF CONSECUTIVE 4-SECOND GAPS, AND TEST FOR
:	DETACH/REPORTING ACTION TO BE TAKEN.
LNCH6	HS	0
	IF	DB56KB			:IF 56KB DEBUG OPTION
	SBT	LN,DBSHUT		:STOP UPDATING ABORT AND CKSUM HISTORY
	EI	:DB56KB
	LH	R1,KNNLAT,KN,KN		:IF MULTI-LINE LINK, DECREMENT
	JLFS	LNCH62			:SINGLE-LINE LINK
	SIS	R1,1
	JL	LNCH4		:ALREADY DETACHED MAX NUMBER OF LINES THIS LINK
	J	LNCH3		:GO DETACH THIS LINE
LNCH62
:	REPORT LINK FROZEN TO SUPERVISOR, BUT DO NOT ZAP CIRCUITS OR
:	DETACH LINE.  THIS PREVENTS SUP FROM BUILDING NEW CIRCUITS OVER
:	LINK WHILE WE GIVE IT MORE TIME TO RECOVER.

	IF	NGRDTM
	LB	R4,LTYP,LN,LN		:NON-4SEC REPORT, CHECK CT=NGRDTM-1
	JE	LNCH63			:SPECIFIC LINE ONLY		###AL
	LB	R4,LCRPCT,LN
	LHI	R8,NGRDTM
	SIS	R8,1
	CLR	R4,R8
	JN	LNCH70
LNCH63	EI	:NGRDTM
	TS	KFROZN,KD	:HAVE WE REPORTED LINK OUT TO SUPERVISOR?
	JL	LNCH70		:YES - LINK FROZEN
	LHI	R4,80		:SET LINK SPEED TO 0 FOR REPORT TO SUPERVISOR
	STB	R4,KSPD,KD	:	(INDICATES FROZEN LINK)
	LHI	R4,13A1		:INDICATE LINE DETACHED DUE TO NO
				:	RECORDS RECEIVED
	AR	LN,LN		:SUP13 EXPECTS LN TO BE LINE NUMBER * 2
	JAL	R10,SUP13,,	:SEND REPORT TO SUP (WITH LINK SPEED = 0)
LNCH64	SRLS	LN,1

:	NOW SEND NODE REPORT INDICATING LINK FROZEN

	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER
	OHI	R0,8000
	STH	R0,SUPMBF+2
	LHI	R0,10+8000
	STH	R0,SUPMBF+4		:NUMBER OF SECONDS BEFORE DETACH
	LHI	R0,NR.LFR
	STH	R0,SUPMBF		:INDICATE LINK FROZEN NODE REPORT
	JAL	R10,SUP12,,		:SHIP NODE REPORT TO SUPER

LNCH70	HS	0
:	4-SECOND INTERVAL WITH NO GOOD RECORDS. SEE IF LNCKTM 
:	CONSECUTIVE OCCURRENCES OF FOUR SECONDS WITH NO RECORDS RECEIVED
:	(4 * LNCKTM SECONDS) 
	LIS	R0,1		:R0 CONTAINS REASON FOR LINE DETACHMENT	###LH
				:REASON 1 ==> NO RECORDS RECEIVED.	###LH
	LCS	R8,1		:					###LH
	IF	STRHUB
	LB	R9,LTYP,LN,LN
	JEFS	LCH70A
	AHM	R8,SCONFS,KN,KN :CHECK IF HAS REACHED CONSECUTIVE 	###AL
				:4-SECONDS GAPS LIMIT.			###AL
	JLE	LNCH3		: YES, --- DETACH LINE			###AL
	AHM	R0,SFOURS,KN,KN	: NO, KEEP COUNT OF CONSECUTIVE		###AL
	JFS	LCH70B		: 4-SECONDS GAPS.			###AL
LCH70A	EI	:STRHUB
	AHM	R8,CONFSG,LN,LN :CHECK IF HAS REACHED CONSECUTIVE 	###LH
				:4-SECONDS GAPS LIMIT.			###LH
	JLE	LNCH3		: YES, --- DETACH LINE			###LH
:: The remote station receives the dummy packet every 8 secs to keep the
:: starlink up when no other data rcved. This is done by both hub and remote
:: to reduce the starlink traffic. Only remote's starline may have 4 sec gap
:: count which is not really an error. 12sec with no data rcved will add 3 to
:: FOURSG for remote's starline to elimilate the dummy error report.
:: This also requires that NGRDTM reporting time is set greater then 12sec##AL
	IF	STRRMT
	IF	NGRDTM
	LB	R8,LTYP,LN,LN
	JEFS	LNCH73
	LB	R8,LCRPCT,LN		:12 SEC WHEN COUNT=2		###AL
	CLHI	R8,2
	JLFS	LCH70B			:SKIP THE 4 SEC GAP CT. WITHIN NGRDTM
	JEFS	LNCH72
	JFS	LNCH73			:>12 SEC, ADD 1
LNCH72	LIS	R0,3			:=12 SEC, ADD 3
LNCH73	EI	:NGRDTM
	EI	:STRRMT
	AHM	R0,FOURSG,LN,LN	: NO, KEEP COUNT OF CONSECUTIVE		###LH
LCH70B				: 4-SECONDS GAPS.			###LH
	LHL	R8,NDID,KD		:GET NEIGHBOR NUMBER
	LR	R0,LN			:LINE NUMBER
	EXHR	R0,R0			:	ALIGNED IN UPPER HW
	OR	R0,R8			:*COMBINE W NEIGHBOR NUMBER
	ST	R0,CRYSBF		:*SAVE FOR CRYPTO
	IF	NGRDTM			:REPORT THE 4-SEC MSG BY NGRDTM
	LB	R9,LTYP,LN,LN		: FOR SPECIFIC LINE ONLY	###AL
	JE	LCH70C
	LB	R9,LCRPCT,LN		:CHECK COUNT IF MEET NGRDTM
	AIS	R9,1			:INCREASE COUNT BY 1
	STB	R9,LCRPCT,LN
	LHI	R0,NGRDTM		:DISPLAY FORMAT IN BYTE DECIMAL
	CLR	R9,R0
	JN	LCH70D
	SLLS	R0,2			:DISPLAY THE REAL NO. OF SECS
	LIS	R4,0			:ZERO OUT THE COUNT
	STB	R4,LCRPCT,LN
	JAL	R8,CRYPTO	
	HC	CRYE7D
	JFS	LCH70D
LCH70C	EI	:NGRDTM
	LIS	R0,0			:*NO DATA
	JAL	R8,CRYPTO	
	HC	CRYE1E
LCH70D
:	IF SIO LINE HAS GONE FOUR SECONDS WITH NO RECORDS RECEIVED,
:	MAYBE IT NEEDS TO BE RE-INITIALIZED...

	IF	SILINS
	LR	R9,LN
	SHI	R9,(NLINES-SILINS)	:COMPUTE RELATIVE SIO LINE NUMBER
	JL	LNCH4			:NOT AN SIO LINE
	IF	STRHUB
	LB	R0,LTYP,LN,LN		:NO INIT SIO LINE IF OTHER STR
	JEFS	LNCH77			: LINKS UP
	SLL	LN,1
	L	R10,SKDPTR,LN,LN
	SRL	LN,1
	LIS	R0,2			:SAVE REASON IF OUTRAGE ##AL
	LHL	R10,NASTLK,R10
	JG	LNCH4			:ONLY SCHEDULE DETLIN & TRLINK
LNCH77	EI	:STRHUB
	SLLS	R9,4			:SIO LINE * 10
	LCS	R0,2
	STH	R0,SIOSTT+8,R9,		:INDICATE INITIALIZATION DUE TO NO RECS
	AR	LN,LN
	JAL	R10,SIOIZ0		:RE-INITIALIZE SIO LINE
	SRLS	LN,1
	EI	:SILINS

	J	LNCH4

	SUBTTL	LINKER (LDRPRT - Diagnostics and reporting)

::*********************************************************************
::
::	TABLE:		LDERTB:
::	FUNCTION:	Line Diagnostic Event/Reporting Table.
::
::*********************************************************************

:	EACH ELEMENT HAS FIVE FIELDS, AS FOLLOWS:
:	EVENT,TOTAL(TRANSMIT OR RECEIVE),MSG TYPE,SHIFT FACTOR,REPORT TIME
:	FOLLOWED BY A JAL TO CRYPTO, A HW OF CRYPTO FLAGS/TYPE, AND A
:	RETURN VIA R11 TO THE CALLER.
LDERTB	HS	0
	if	alhub		:LDTIM not in SEG0 		###al
	HC	LINERR,RCRCVD,NR.BRI+06
	WC	LDTIM0 :BAD BORI
	JAL	R8,CRYPTO
	HC CRYE41
	JR R11
LDTESZ	EQ	.-LDERTB		:LDERTB ELEMENT SIZE
	HC	BADACK,RCRCVD,NR.ACK+10
	WC	LDTIM1 :BAD ACKS
	JAL	R8,CRYPTO
	HC CRYE42
	JR R11
	HC	BADRCN,RCRCVD,NR.RCN+10
	WC	LDTIM2 :BAD RECORD NUMBERS
	JAL	R8,CRYPTO
	HC CRYE43
	JR R11
	HC	BADCSM,RCRCVD,NR.CHS+06
	WC	LDTIM3 :BAD CHECKSUMS
	JAL	R8,CRYPTO		       : (PACKET W/ GOOD BORI)
	HC CRYE44
	JR R11
	HC	RCRXMT,RCRCVD,NR.RTR+03
	WC	LDTIM4 :RETRANSMISSIONS RECEIVED
	JAL	R8,CRYPTO
	HC CRYE45
	JR R11
	HC	TRRXMT,RCTRNS,NR.RTS+03
	WC	LDTIM5 :RETRANSMISSIONS SENT
	JAL	R8,CRYPTO
	HC CRYE46
	JR R11
	HC	FOURSG,RCRCVD,NR.4SG+10
	WC	LDTIM6 :FOUR SECOND GAP W/ NO RECORDS
	JAL	R8,CRYPTO
	HC CRYE47
	JR R11
	HC	LCROSS,RCRCVD,NR.CRS+10
	WC	LDTIM7 :LINE CROSS-TALK
	JAL	R8,CRYPTO
	HC CRYE48
	JR R11
	HC	SPACNG,RCRCVD,NR.SPC+10
	WC	LDTIM8 :SPACING ON INPUT
	JAL	R8,CRYPTO
	HC CRYE49
	JR R11
LDNEVT	EQ	(.-LDERTB)/LDTESZ 	:NUMBER OF TABLE ELEMENTS
	else	:not alhub
	HC	LINERR,RCRCVD,NR.BRI+06,LDTIM0 :BAD BORI
	JAL	R8,CRYPTO
	HC CRYE41
	JR R11
LDTESZ	EQ	.-LDERTB		:LDERTB ELEMENT SIZE
	HC	BADACK,RCRCVD,NR.ACK+10,LDTIM1 :BAD ACKS
	JAL	R8,CRYPTO
	HC CRYE42
	JR R11
	HC	BADRCN,RCRCVD,NR.RCN+10,LDTIM2 :BAD RECORD NUMBERS
	JAL	R8,CRYPTO
	HC CRYE43
	JR R11
	HC	BADCSM,RCRCVD,NR.CHS+06,LDTIM3 :BAD CHECKSUMS
	JAL	R8,CRYPTO		       : (PACKET W/ GOOD BORI)
	HC CRYE44
	JR R11
	HC	RCRXMT,RCRCVD,NR.RTR+03,LDTIM4 :RETRANSMISSIONS RECEIVED
	JAL	R8,CRYPTO
	HC CRYE45
	JR R11
	HC	TRRXMT,RCTRNS,NR.RTS+03,LDTIM5 :RETRANSMISSIONS SENT
	JAL	R8,CRYPTO
	HC CRYE46
	JR R11
	HC	FOURSG,RCRCVD,NR.4SG+10,LDTIM6 :FOUR SECOND GAP W/ NO RECORDS
	JAL	R8,CRYPTO
	HC CRYE47
	JR R11
	HC	LCROSS,RCRCVD,NR.CRS+10,LDTIM7 :LINE CROSS-TALK
	JAL	R8,CRYPTO
	HC CRYE48
	JR R11
	HC	SPACNG,RCRCVD,NR.SPC+10,LDTIM8 :SPACING ON INPUT
	JAL	R8,CRYPTO
	HC CRYE49
	JR R11
LDNEVT	EQ	(.-LDERTB)/LDTESZ 	:NUMBER OF TABLE ELEMENTS
	ei	:alhub
	HC	0			:END OF TABLE INDICATION

::*********************************************************************
::
::	TABLE:		LDTIME:
::	FUNCTION:	The LDTIME table is used to control the frequency of
::			line diagnostic reporting to the supervisor.
::
::*********************************************************************

:	EACH ARRAY LDTIMx RECORDS THE TIME (IN TIK4MN UNITS) THAT THE LAST
:	REPORT WAS MADE.  IF 2 CONSECUTIVE REPORTS ARE MADE, THEN SKIP 3
:	OCCURRENCES OF LDRPRT BEFORE REPORTING AGAIN.  WHEN A EVENT
:	THRESHOLD HAS BEEN EXCEEDED, TEST THE LDTIMx FIELD:
:
:	1. IF TIME OF LAST REPORT = CURRENT TIME MINUS 1, SET LDTIMx TO
:		CURRENT TIME + 3.
:	2. IF LDTIMx IS LESS THAN CURRENT TIME MINUS 1, SET LDTIMx TO CURRENT
:		TIME.
:	3. IF LDTIMx IS GREATER THAN OR EQUAL TO CURRENT TIME, MAKE NO REPORT.

	IF	alhub:0			:**LDTIME now located in FIN**
:	SEG	0
	RA	0
LDTIME	WS	0
Q	EQ	0
	RE	LDNEVT
LDTIM|Q| WS	NLINES			:ONE LDTIMx ARRAY PER EVENT
Q	EQ	Q+1
	ER
	SEG	1
	EI	:0

Q	EQ	0
	RE	LDNEVT
	GL	LDTIM|Q|
Q	EQ	Q+1
	ER

::*********************************************************************
::
::	SUBROUTINE:	LDRPRT:
::	FUNCTION:	Line diagnostic detection and reporting routine.
::	CALLING SEQ:	JAL	R10,LDRPRT	Called from G01SEC.
::	DESTROYED:	R4, R5, R6, R12, R13, R15
::	CALLS:		JAL	R0,SVCE38	:IF ISIS
::			JAL	R10,SUP12,,
::			JAL	R11,LDERTB+8,R6	:JAL R8,CRYPTO for line/event
::			JAL	R12,SVCE0F	:solo
::			JAL	R10,SIOSUR
::
::*********************************************************************

:	LINE EVENTS ARE COMPARED TO A THRESHOLD BASED ON NUMBER OF PACKETS
:	TRANSMITTED OR RECEIVED, AND REPORTED IF THRESHOLD EXCEEDED.  IN
:	ADDITION, REPORTS ARE THROTTLED FROM EXCESSIVE IDENTICAL
:	CONDITION REPORTING.
:
:	R10 = LINK
:	LN = 2*LINE #
:	R15 = 4-MINUTE TICKER (INCREMENTS EACH TIME THRU)
:	R6 = EVENT INDEX
:	R5 = POINTER TO EVENT ARRAY
:	R4 = POINTER TO TOTAL ARRAY (PACKETS SENT/RECEIVED)
:	R13 = SHIFT FACTOR FOR DETERMINING EVENT THRESHOLD
:	R12 = MSG TYPE FOR REPORT TO SUP
:
:	DIAGNOSTIC REPORTS ARE GENERAL 'REPORT TO LOG' FORMAT, WITH
:	3 HALFWORDS OF INFORMATION, AS FOLLOWS:
:
:	EVENT REPORT:
:	*HW1* TTLL
:	*HW2* NNNN+8000 IF LINE ATTACHED, ELSE NNNN FOR LAST NEIGHBOR ON
:		LINE (0 IF LINE NEVER ATTACHED)
:	*HW3* EEEE
:	WHERE TT IS MESSAGE TYPE, LL IS LINE NUMBER, NNNN IS NEIGHBOR NUMBER,
:		AND EEEE IS NUMBER OF EVENT OCCURRENCES.
:
:	IF AN EVENT REPORT IS MADE, IT IS USEFUL FOR ANALYSIS PURPOSES
:	TO KNOW THE TOTAL NUMBER OF PACKETS SENT/RECEIVED OVER REPORTING
:	PERIOD.  AFTER EVENT REPORTS (IF ANY) HAVE BEEN SENT, TOTAL
:	REPORTS ARE SENT FOR THOSE LINES WHICH REPORTED EVENTS.

:	TOTAL REPORT:
:	*HW1* 80LL
:	*HW2* RRRR
:	*HW3* TTTT
:
:	WHERE 80 IS THE MESSAGE TYPE, LL IS LINE NUMBER, RRRR IS TOTAL
:	NUMBER OF PACKETS RECEIVED OVER REPORTING PERIOD, AND TTTT IS
:	NUMBER OF PACKETS TRANSMITTED.

	IF	ISIS
SVCE38	CRASH.(.SV38C,R5)
	EI	:ISIS

LDRPRT	HS	0

	IF	ISIS			:NEED TO ISSUE SVC TO GET COUNTS
	LHI	LN,NLINES-SILINS-1
	JL	LDRP3A			:BUT ONLY IF THERE ARE SYNC LINES###GT
LDRP02	LR	R0,LN
	SVC	IO,80			:GET RE-XMIT AND TRANSMIT (IN R1)
	JAL	R0,SVCE38
LDRP03	STH	R1,RCTRNS,LN,LN
	EXHR	R1,R1
	STH	R1,TRRXMT,LN,LN
	SIS	LN,1
	JGE	LDRP02
LDRP3A	HS	0			:				###GT
	EI	:ISIS

	ST	R10,LDRGSV		:SAVE LINK REGISTER
	L	R15,TIK4MN
	AIS	R15,1			:INCREMENT TICKER
	ST	R15,TIK4MN

:	LDARLN IS AN ARRAY OF 16-BIT ARRAYS, ONE HW FOR EACH LINE. EVERY 4
:	MINUTES WHEN WE COME HERE WE RESET THE 'NEXT' BIT IN EACH ARRAY. THEN
:	BELOW, IF THERE ARE ANY ERRORS TO REPORT TO THE SUP, THIS BIT GETS SET
:	AGAIN. THUS, FOR EACH LINE THE CORRESPONDING BIT-ARRAY HAS A 1-BIT FOR
:	EACH OF THE PRECEDING 4-MINUTE INTERVALS DURING WHICH ERRORS OCCURED.
:	THIS IS USED IN THE ND DISPLAY TO GIVE A ROUGH SENSE OF ERRORS ON
:	EACH LINE DURING THE PREVIOUS HOUR.
	LHI	R4,(((NLINES+1)/2)*4)-4	:POINT TO THE LAST FW IN LDARLN
					: SO WE CAN FIGURE WHEN WE'RE THRU
LDRP04	L	R6,LDARLN,R4		:GET 2 HW BIT ARRAYS
	SRHLS	R6,1			:RESET OLDEST BIT FOR 1 LINE
	EXHR	R6,R6			:SET UP SECOND LINE
	SRHLS	R6,1			:RESET OLDEST BIT FOR 2ND LINE
	EXHR	R6,R6			:SWITCH THEM BACK
	ST	R6,LDARLN,R4		:STORE THEM AWAY
	SIS	R4,4			:REPEAT TILL DONE
	JGEBS	LDRP04
	LIS	R6,0
LDRP10	LHL	R5,LDERTB,R6		:POINTER TO ERROR COUNT ARRAY
	JE	LDRP50			:END OF TABLE
:	INITIALIZE REGISTERS WITH POINTERS, SHIFT VALUE & MSG TYPE BEFORE
:	ENTERING INNER LOOP
	LHL	R4,LDERTB+2,R6		:# PACKETS TRANSMIT/RECEIVED ARRAY
	LB	R13,LDERTB+5,R6		:SHIFT FACTOR. NOTE THAT A SHIFT
					:FACTOR OF 10 INDICATES THRESHOLD OF 0
	LB	R12,LDERTB+4,R6		:MESSAGE TYPE FOR SUP REPORT
	EXBR	R12,R12			:ALIGN FOR REPORT
	LHI	LN,(NLINES-1)*2		:LINE NUMBER * 2 INDEX
	IF	T2GATE			:##AL
	CLHI	R12,NR.CHS		:IF CKSM ERR, RPT TO INET SUP
	JNFS	LDRP11
	LHI	R3,NR.CHS		:OR
	JFS	LDRP12
LDRP11	CLHI	R12,NR.SPC		:IF SPACING ON INPUT ERR, RPT
	JN	LDRP20			:SKIP IF NOT THESE TWO ERR
	LHI	R3,NR.SPC		:R3 HAS ERR TYPE
LDRP12	LBR	R1,LN			:R1 HAS LINE NO.
	SRHLS	R1,1			:LN/2 IS REAL LINE NO.
	PUSH(R15)
	PUSH(R14)			:LN IS R14
	PUSH(R12)
	JAL	R10,GSUPLG,,		:REPORT TO INET SUP LOG
	GL	GSUPLG
	POP(R12)
	POP(R14)
	POP(R15)
	EI	:T2GATE##AL
LDRP20	LHL	R0,0,R5,LN		:GET NUMBER OF EVENTS
	LHL	R1,0,R4,LN		:	AND TOTAL NUMBER OF PACKETS
	SRL	R1,0,R13		:COMPUTE REPORTING THRESHOLD
	CR	R0,R1			:# EVENTS > THRESHOLD?
	JLE	LDRP40			:NO
	CLHI	R0,1
	JLE	LDRP40			:DON'T REPORT SINGLE EVENT

	LIS	R3,0			:POINTER TO HO BIT IN LD ARRAY
	SBT	R3,LDARLN,LN		:SET BIT INDICATING LD REPORT WOULD
					: HAVE BEEN SENT TO SUPE
:	SEE IF WE SHOULD THROTTLE REPORTING
	LHL	R11,LDERTB+6,R6
	AR	LN,LN			:FW INDEX
	L	R3,0,R11,LN		:GET TIME OF LAST REPORT
	SR	R3,R15			:IF TIME OF LAST REPORT .GE. CURRENT
	JGE	LDRP38			: TIME, WE'RE THROTTLED FOR THIS EVENT
					: ON THIS LINE			###wjl
	LR	R10,R15			:R10 IS NEW REPORT TIME
	AIS	R3,1			:TEST FOR CONSECUTIVE REPORTS
	JLFS	LDRP30			:NO
	AIS	R10,3			:THROTTLE REPORTS FOR 3 REPORT PERIODS
LDRP30	ST	R10,0,R11,LN		:SET NEW 'TIME OF LAST REPORT'
	SRLS	LN,1			:RESTORE HW INDEX
	IF	STRHUB
	LB	R7,LTYP,LN,		:NGR#=0000 IF STARLINE
	JEFS	LDRP31
	LIS	R7,0
	JFS	LDRP32
LDRP31	EI	:STRHUB
	LHL	R7,NGSVLN,LN,
LDRP32	STH	R7,SUPMBF+2		:NEIGHBOR NUMBER
	STH	R7,CRYSBF+2,,		:DITTO FOR CRYPTO BUFFER
	STH	R0,SUPMBF+4		:NUMBER OF EVENTS
	LR	R0,LN
	SRLS	R0,1			:LINE NUMBER
	SBT	R0,LDTARY		:INDICATE REPORT SENT FOR THIS LINE
	STH	R0,CRYSBF,,		:LINE# FOR CRYPTO
	OR	R0,R12
	STH	R0,SUPMBF		:MSG TYPE, LINE NUMBER
	JAL	R10,SUP12,,		:REPORT LINE DIAGNOSTIC TO SUP
	LHL	R0,0,R5,LN		:NO. EVENTS (AGAIN) FOR CRYPTO
	JAL	R11,LDERTB+8,R6		:JAL R8,CRYPTO FOR THIS LINE AND EVENT
	AR	LN,LN
LDRP38	SRLS	LN,1			:###wjl
LDRP40	CI      R5,TRRXMT               :this one has a history to worry about	
        JN      LDRP41                  :others to be simply cleared
        LHL     R0,TRRXMT,LN,           :this value is about to be cleared
        LHL     R1,KL.TRF,LN,           :keep same distance between old and new
        SR      R1,R0                   :if new=>0 then hist=>hist-new
        STH     R1,KL.TRF,LN,           :and done   ###sdw
LDRP41	LIS	R0,0
	STH	R0,0,R5,LN		:CLEAR EVENT COUNTER
	SIS	LN,2
	JGE	LDRP20			:MORE LINES TO CHECK FOR THIS EVENT
	AHI	R6,LDTESZ		:ADVANCE TO NEXT EVENT ARRAY
	J	LDRP10

:	THE FOLLOWING LOGIC QUERIES THE SIO CARD TO SEE IF ANY INTERNAL
:	ERRORS HAVE BEEN DETECTED. WE MUST MAINTAIN COUNTS FROM THE LAST
:	SIO CARD QUERY SINCE MOTHER BOARD'S COUNTS ARE CUMULATIVE.
:	R6 = SIO LINE NUMBER*2
:	R7 = SIOQRY POINTER (ADDRESS TO STORE SIO STATUS IN)

LDRP50	HS	0
	IF	SILINS
	LHI	LN,(NLINES-SILINS)*2	:NODE CODE LINE NUMBER
	LIS	R6,0			:SIO LINE NUMBER
	LA	R7,SIOSTT,,		:POINT TO SIO STATUS BLOCKS	###wjl
	GL	SIOSTT			:			###LSH###wjl
LDRP52	HS	0
	IF	1-ISIS			:###wjl
	LR	R0,LN			:SVC WANTS LINE NUMBER*2 IN R0
	LR	R1,R7			:POINT TO STATUS SAVE AREA FOR LINE
	SVC	0F,SV.QSI		:READ AND STORE SIO STATUS
	JAL	R12,SVCE0F		:SVC SAW INVALID SET-UP, CRASH
	EI	:1-ISIS
	LB	R0,SS.CRC,R7		:GET COUNT OF HDLC CHECKSUM ERRORS#wjl
	LR	R1,R0
	SH	R0,SIOHCK,R6		:GET DIFFERENCE FROM LAST STATUS PERIOD
	NHI	R0,0FF			:only low-order byte is meaningful#wjl
	JE	LDRP54			:NO CHECKSUM ERRORS THIS LINE	###wjl
	STH	R1,SIOHCK,R6		:SAVE NEW COUNT
	JAL	R10,SIOSUR		:SET UP NODE REPORT
	JAL	R8,CRYPTO,,		:REPORT TO CRYPTO-COUNT IN R0, LINE,
	HC	CRYE4A			: NEIGHBOR WERE SET UP IN SIOSUR
	LHI	R0,NR.HCK,R1
	STH	R0,SUPMBF		:INDICATE ERROR TYPE, LINE #
	JAL	R10,SUP12,,		:LINE DIAGNOSTIC NODE REPORT TO SUP
LDRP54	LHL	R0,SS.ABR,R7		:only positive values meaningful###wjl
	SRLS	R0,4			:ISOLATE SIO HDLC ABORT COUNTER
	LR	R1,R0
	SH	R0,SIOHAB,R6		:DIFFERENT THAN LAST TIME?
	NHI	R0,0FFF			:only 3 nibbles are meaningful	###wjl
	JE	LDRP58			:NO INCREASE			###wjl
	STH	R1,SIOHAB,R6		:SAVE NEW COUNT
	JAL	R10,SIOSUR		:SET UP NODE REPORT
	JAL	R8,CRYPTO,,		:CRYPTO REPORT-R0 IS COUNT, LINE &
	HC	CRYE4B			: NEIGHBOR WERE SET UP IN SIOSUR
	LHI	R0,NR.HAB,R1
	STH	R0,SUPMBF		:INDICATE ERROR TYPE, LINE #
	JAL	R10,SUP12,,		:SEND NODE REPORT TO SUP
LDRP58	AHI	R7,10
	AIS	R6,2			:BUMP INDEX REGS
	AIS	LN,2
	CLHI	LN,NLINES*2		:DONE ALL SIO LINES?
	JL	LDRP52			:NO - CONTINUE
	J	LDRP60			:YES - REPORT PACKET TOTALS

::*********************************************************************
::
::	SUBROUTINE:	SIOSUR:
::	FUNCTION:	SET UP NODE REPORT FOR SIO LINE ERROR
::	CALLING SEQ:	JAL	R10,SIOSUR
::	DESTROYED:	R1
::
::*********************************************************************

SIOSUR	HS	0
	OHI	R0,8000			:###wjl
	STH	R0,SUPMBF+4		:SAVE COUNT 
	LHL	R1,NGSVLN,LN,
	STH	R1,SUPMBF+2		:REPORT NEIGHBOR ON LINE
	STH	R1,CRYSBF+2,,		: AND SAVE FOR CRYPTO
	LR	R1,LN
	SRLS	R1,1			:LINE NUMBER
	SBT	R1,LDTARY		:REPORT PACKET TOTALS FOR THIS LINE
	STH	R1,CRYSBF,,		:LINE# FOR CRYPTO
	XI	R0,8000			:COUNT FOR CRYPTO, NO HOB	###wjl
	JR	R10			:RETURN
	EI	:SILINS

:	CLEAR PACKET TOTAL FIELDS AND REPORT TOTALS FOR LINES WHICH
:	REPORTED EVENTS.
LDRP60	LHI	R4,NLINES-1
	LHI	LN,(NLINES-1)*2
LDRP62	RBT	R4,LDTARY		:CLEAR AND TEST BIT...
	JE	LDRP70			:...NO REPORTS MADE FOR THIS LINE

:	REPORT PACKET TOTALS FOR INTERESTED OBSERVER
	STH	R4,CRYSBF		:LINE# FOR CRYPTO
	LHL	R0,NGSVLN,LN,		:NEIG# FOR CRYPTO
	STH	R0,CRYSBF+2
	LHI	R0,NR.SRT		:MSG TYPE FOR REPORTING TOTAL SENT&RCVD
	OR	R0,R4			:COMBINE LINE NUMBER WITH MESSAGE TYPE
	STH	R0,SUPMBF
	LH	R0,RCRCVD,LN		:TOT # PACKETS RECEIVED
	STH	R0,SUPMBF+2
	STH	R0,CRYSBF+4		:FOR CRYPTO
	LR	R10,R0			:(SAVE NUMBER OF PACKETS RECEIVED)
	LH	R0,RCTRNS,LN		:TOT # PACKETS TRANSMITTED
	STH	R0,SUPMBF+4
	STH	R0,CRYSBF+6		:FOR CRYPTO
	AR	R10,R0			:IF TOTAL PACKETS RECEIVED AND SENT
	JEFS	LDRP70			: =0, DO NOT MAKE TRIVIAL NODE REPORT
	JAL	R10,SUP12,,		:REPORT TOTALS TO SUP
	JAL	R8,CRYPT0,,
	HC	CRYE40
LDRP70	STH	R5,RCRCVD,LN		:CLEAR # PACKETS RECEIVED
	STH	R5,RCTRNS,LN		: AND NUMBER PACKETS TRANSMITTED
	STH	R5,KL.RRF,LN,		: AND REF CNTR FOR MTRFIC STATS	###JHL
	SIS	R4,1
	SIS	LN,2
	JGE	LDRP62			:CONTINUE
	L	R10,LDRGSV		:RESTORE LINK REG
	JR	R10			:RETURN




	SUBTTL	LINKER (KB56DB - Monitor SIO lines)

::*********************************************************************
::
::	SUBROUTINE:	KB56DB:
::	FUNCTION:	Monitor SIO lines
::	CALLING SEQ:	JAL	R10,KB56DB
::	CALLS:		JAL	R12,SVCE0F
::
::*********************************************************************

:	MONITOR SIO LINES BY READING EACH SIO PORT STATUS EVERY 1/2 SEC AND
:	KEEP A HISTORY OF THE LAST 128 SAMPLES FROM EACH PORT.
:
:	SVC 0F,0F INITIATES A DMA TRANSFER OF 3 HW INTO THE QUAD ADDRESS
:	IN R1. THE MOTHERBOARD TAKES AN UNSPECIFIED AMOUNT OF TIME TO
:	RESPOND TO THE DMA REQUEST, SO STATUS REQUESTED BY ONE
:	SVC CALL IS NOT READ UNTIL THE SUBSEQUENT EXECUTION OF THIS CODE.
:	THE STATUS RETURNED CONSISTS OF:
:	HW 1	= 	SIO CHIP REGISTERS 0, 1
:	HW 2	=	1 BYTE HDLC IDLE COUNT, 1 BYTE CHECKSUM COUNT
:	HW 3	=	12 BITS ABORT COUNTER, 4 BITS GENERAL
:	BIT 12 OF HW 3 IS ALWAYS 1, AND CAN BE USED AS A FLAG TO DETERMINE
:	WHETHER THE DMA OPERATION HAS COMPLETED.

	IF	SILINS
	IF	DB56KB
KB56DB	HS	0
	IF	1-ISIS			:ISIS DOES NOT HAVE A QUERY SIO SVC
	LHI	R0,SBASE		:2*ABSOLUTE LINE NUMBER OF SIO LINE 0

KB56D1	LR	R1,R0
	SRLS	R1,1			:TRUE LINE NUMBER
	TBT	R1,DBSHUT		:IS LINE BEING MONITORED?
DB56EN	JN	KB56D2			:NO, GO TO NEXT LINE
	AR	R1,R1
	LHL	R11,DEBPTR-SBASE,R1,	:POINTER TO DATA AREA
	SLLS	R1,2			:GET 8*LINE NUMBER
	LA	R1,SSTSAV-SBASEA,R1,R1	:GET POINTER TO DMA AREA

	LHL	R14,SIONDX,R11		:CURRENT POINTER TO DATA BUFFER
	LB	R12,3,R1		:READ CHECKSUMS (BYTE 4)
	LR	R13,R12			:SAVE THEM
	SH	R12,CKLAST,R11		:DELTA CKSUMS
	JGEFS	KB56D3			:NO WRAP
	LBR	R12,R12			:CORRECT FOR WRAP (MOD 256)
KB56D3	STH	R13,CKLAST,R11		:NEXT CKSUMS
	STH	R12,CKSUMS,R14,R11	:STORE THIS SECOND'S CKSUMS
	AHM	R12,CKACC,R11		:AND KEEP RUNNING COUNT

	LH	R12,4,R1		:NOW REPEAT FOR ABORTS AND IDLE COUNT
	LB	R9,2,R11		:BYTE 3 = HDLC IDLE COUNT (>= 15 MARKS)
	LR	R15,R12			:SAVE STATUS NIBBLE
	NHI	R15,0F
	STH	R15,SSTATS,R11,R14
	SRLS	R12,4			:ISOLATE ABORT COUNTER
	AR	R12,R9			:COMBINE ABORTS AND IDLES
	LR	R13,R12
	SH	R12,ABLAST,R11		:DELTA ABORTS+IDLES
	STH	R13,ABLAST,R11		:STORE LAST ABORT+IDLE COUNT
	STH	R12,ABORTS,R14,R11	:STORE THIS INTERVAL'S ABORT COUNTS
	AHM	R12,ABACC,R11		:KEEP TRACK OF ALL THESE DELTAS
	AIS	R14,2			:ADVANCE POINTER
	NHI	R14,SKBSIZ		:AND REDUCE
	STH	R14,SIONDX,R11	 	:SAVE POINTER
	JNFS	KB56D4			:NOT AT BEGINNING
	LHL	R5,CKACC,R11		:GET RUNNING SUMS
	STH	R5,CKSAVE,R11		:AND SAVE THEM
	LHL	R5,ABACC,R11
	STH	R5,ABSAVE,R11
	LIS	R5,0			:CLEAR RUNNING COUNT CELLS
	STH	R5,CKACC,R11
	STH	R5,ABACC,R11

KB56D4	LIS	R3,0			:RE-ISSUE STATUS SVC FOR THIS PORT
	STH	R3,4,R1			:M-BOARD SETS BIT 12 IN HW3 WHEN DONE
	LR	LN,R0			:MOVE R0 TO LN IN CASE WE TIME OUT
	SVC	0F,SV.QSI		:STATUS SVC (R0=2*LINE, R1=DMA ADDRESS)
	JAL	R12,SVCE0F		:ERROR, CRASH

KB56D2	AIS	R0,2			:ADVANCE LINE INDEX
	CLHI	R0,NLINES*2
	JL	KB56D1			:MORE LEFT, KEEP GOING
	EI	:1-ISIS

	JR	R10
	EI	:DB56KB
	EI	:SILINS

	SUBTTL	LINKER (LNXDUM - Transmit dummy record)

::*********************************************************************
::
::	SUBROUTINE:	LNXDUM:
::	FUNCTION:	Forces transmission of dummy records
::	CALLING SEQ:	JAL	R10,LNXDUM	Called from G500MS.
::
::*********************************************************************

:	RUNS EVERY SEC, FORCES TRANSMISSIONS OF DUMMY RECORDS
:	ON LINES WHICH HAVE SEEN NO ACTIVITY SINCE LAST SEC.

LNXDUM	HS	0
	LCS	R0,1			:R0 < 0 IS FLAG (SEE SVC05)

	IF	ISIS
	SVC	IO,60
	ELSE	:solo
	SVC	0F,SV.CSY
	EI	:ISIS

	IF	SILINS
	L	R0,SSENT		:SET UP THE BIT ARRAYS
	ST	R0,SDUMM		:FOR SIO LINES -- SAME THING SVC DOES
	L	R0,SSENT+4		:	FOR SYNC LINES ABOVE
	ST	R0,SDUMM+4
	IF	STRHUB		:COPY STSENT TO STDUM PER 4 SEC
	LA	R1,STSENT		:SOURCE ADDR.
	LA	R2,STDUMM		:DESTINATN ADDDR.
	LHI	R3,(NLINKS+7)/8		:BYTE COUNT TO MOVE
	JAL	R8,BCMOVE,,
	LHI	R3,(NLINKS+7)/8		:BYTE COUNT TO MOVE
	LCS	R0,1
STDLP	STB	R0,STSENT-1,R3		:RESET STSENT TO ALL 1'S
	SIS	R3,1
	JNBS	STDLP
	EI	:STRHUB
	LCS	R0,1			:AND RESET THE SSENT ARRAY
	ST	R0,SSENT
	ST	R0,SSENT+4
	EI	:SILINS
	JR	R10

	SUBTTL	LINKER (ATTLIN - Line attach logic)

::*********************************************************************
::
::	SUB-PROCESS:	ATTLIN:
::	FUNCTION:	Identifies and Attaches Lines.  Scheduled by LINKER
::	CALLING SEQ:	LA	R3,LINKAS
::			JAL	R9,BIDDY
::			J	ATTLIN
::	CALLS:		JAL	R9,FNDLNK
::			JAL	R8,WCI
::			JAL	R9,RSTSTR
::			JAL	R8,ATTMCL
::			JAL	R10,SUP12
::			JAL	R8,CRYPTO
::			JAL	R8,GMTLIN
::			JAL	R10,KSPEED
::			JAL	R10,SUP13
::			JAL	R8,TSBMRK
::			JAL	R11,LNKCON
::			JAL	R9,CLRCHN
::	RETURNS:	J	BIDDRT
::
::*********************************************************************

ATTLIN	HS	0
	IF	DB.CPU
	LR	R3,R2			:SAVE R2			###OAS
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR ATTLIN	###OAS
	CPUTNM(ATTLIN)			:DEFINE ATTLIN CPUTIL ENTRY	###OAS
	LR	R2,R3			:RESTORE R2			###OAS
	EI	:DB.CPU
	LR	LN,2			:COMPUTE LINE NUMBER
	AR	LN,LN
	IF	STRHUB			:###AL
	LB	R3,LTYP,LN
	JEFS	ATLIN1
	L	R3,SKDPTR,LN,LN
	L	KD,CRSTKD,R3		:KD IS LIVE FOR STARLINE ###AL
ATLIN1	EI	:STRHUB
	LHL	SD,SDLN,LN		:RESET BUFF PTR
	LHL	R3,RSTIM,SD		:IF FIRST TIME, SET TIMEOUT
	JN	ATTLI1			:NOT FIRST TIME
	IF	XRESET			:###wjl
	LH	R4,VRSTP,SD		:get Received Reset Header 
	NHI	R4,0FFE0		:mask off 'subsequent & count' bits
	CLHI	R4,TXRSHD		:compare with Expanded Reset Header
	JNFS	ATT000			:no, must be old version
	SBT	LN,XRSTBT,,		:yes, set bit indexed by LN*2
	L	R1,VNDID,SD		:get FW Machine Number from Reset
	JFS	ATT002
ATT000	RBT	LN,XRSTBT,,		:reset bit for old version
	LR	R1,LN
	AIS	R1,1			:bit indexed by (LN*2)+1
	RBT	R1,XRSTBT,,		:reset bit for first time 
	EI	:XRESET

	LH	R1,VRSTP+2,SD	:FIRST RESET - GET MACHINE NUMBER FROM RESET
ATT002
:	JLE	ATTLD4		:NOT A VALID NODE NUMBER
	JG	ATT003		:NOT A VALID NODE NUMBER ###AL
	JAL	R9,RSTSTR	:CALL RSTSTR HERE TO KNOW R9
	J	ATLD41
ATT003				:###AL
	CLHI	R1,MACHNM	:ARE WE TALKING TO OURSELVES?
	JE	ATTXTK		:CARELESS CONFIGURATION OR HARDWARE PROBLEM

:	VERIFY THAT LINK PERMUTER TABLE SPACE IS AVAILABLE BEFORE
:	ENTERING ATTACH PROCESS.  NOTE THAT ADDITIONAL P.T.  SPACE IS
:	NOT REQUIRED FOR MULTI-LINE ATTACH.
	LHI	R8,(NLINES-1)*2
ATPT10	LH	R0,NGSVLN,R8,	:SEE IF NEIGHBOR NUMBER IN RESET MATCHES
				:	ONE THAT IS ALREADY ATTACHED
	JLFS	ATPT30		:NEGATIVE IF LINE ATTACHED TO SOME LINK
ATPT20	SIS	R8,2
	JGEBS	ATPT10		:SCAN ALL LINES
:	RESET IS FOR NEW LINK - SEE IF AT LEAST 2 PAGES OF PERMUTER TABLES
:	ARE AVAILABLE FOR LINK INITIALIZATION
	LH	R0,NUMPAG,,	:NUMBER OF AVAILABLE PAGES
	SIS	R0,2
	JGEFS	ATPTND		:ENOUGH TO COMPLETE INITIALIZATION
	J	ATPTER		:POSSIBLY NOT ENOUGH P.T. SPACE FOR NEW
				:LINK.  SUSPEND LINE AND REPORT TO SUP LOG.
ATPT30	NHI	R0,7FFF		:FOUND ATTACHED LINE. SEE IF RESET'S NEIGHBOR
	CR	R0,R1		:	MATCHES FOR POTENTIAL MULTI-LINE LINK
	JNBS	ATPT20		:NO

ATPTND	STH	R1,NGSVLN,LN,	:SAVE MACHINE NUMBER FROM RESET
	LH	R4,VRSTP,SD	:RESET HEADER
	JFS	ATTLI0

:	CROSS-TALK ERROR - INCREMENT COUNTER AND TIME-OUT LINE
ATTXTK	LIS	R0,1
	AHM	R0,LCROSS,LN,		:NOTE CROSS-TALK ON THIS LINE
:	J	ATTLD4
	JAL	R9,RSTSTR	:CALL RSTSTR HERE TO KNOW R9
	J	ATLD41		:###AL

ATTLI0	CLHI	R1,$8 2000		:VALID T-II NODE NUMBER?
	JLBS	ATTXTK			:NO, SYNC CARD CROSSTALK (HARDWARE!!)

:	MUST BE TYMNET-II NEIGHBOR...

	IF	XRESET			:###wjl
	CLHI	R4,TTRSHD		:Original T-II Reset Header?
	JN	ATTL00			:jump if Expanded Header received
	L	R0,TTRSET+4
	ST	R0,XRSTP+4,SD		:store CKSUM
	LI	R0,VERCOM		:VERSION and Complement
	ST	R0,XRSTP+8,SD		:for backwards compatability!
:	mask off the remainder of the reset pattern with all F's
	LCS	R0,1			:				###cwc
	LHI	R2,XSDSZ-10		:byte count-4			###cwc
ATTLI3	ST 	R0,XRSTP+0C,SD,R2	:fill up one word at a time	###cwc
	SIS	R2,4			:back up one full-word		###cwc
	JGEBS	ATTLI3			:loop till done			###cwc

	IF	SILINS
	CLHI	LN,(NLINES-SILINS-1)*2
	JLEFS	ATTL00			:skip if not SIO line
	IF	SIBFRL			:###LSH
	L	R2,SIORSP,LN,LN		:get SIO Reset Buffer Pointer
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R2,SIORSP,LN		:get SIO Reset Buffer Pointer
	EI	:SIBFRL			:###LSH
	IF	STRHUB
	LB	R5,LTYP,LN		:IF STR LINE
	JEFS	ATL11
	ST	R0,8,R2			:store VERSION and Complement
	JFS	ATL12
ATL11	EI	:STRHUB
	ST	R0,6,R2			:store VERSION and Complement
ATL12	EI	:SILINS			:for backwards compatibility!
	EI	:XRESET

ATTL00	HS	0
	CLHI	R1,MACHNM	:TEST FOR NEIGHBOR WITH HIGHER MACHINE NUMBER
	JG	ATTA4		:YES - THAT MAKES US THE SLAVE FOR THIS LINK
	IF	STRHUB!STRRMT
	LB	R5,LTYP,LN
	JN	ATTA4		:STAR LINE NO MRESET ##AL
	EI	:STRHUB!STRRMT
	LHI	R5,-MRESTZ*2	:NO - WE'RE MASTER. SEE IF ANOTHER RESET TO
ATTA1	CLH	R1,MRESET+MRESTZ*2,R5 :	THIS NEIGHBOR IS IN PROGRESS
	JE	BIDDRT		:YES - DO NOT BEGIN ANOTHER RESET SEQUENCE
	AIS	R5,2
	JLBS	ATTA1		:SCAN ALL ENTRIES IN MRESET

:	NO RESET SEQUENCE CURRENTLY IN PROGRESS.  STORE NEIGHBOR NUMBER
:	IN MRESET TO PREVENT MULTIPLE SIMULTANEOUS RESET SEQUENCES TO
:	SAME NEIGHBOR.

	LHI	R5,-MRESTZ*2
ATTA2	LH	R6,MRESET+MRESTZ*2,R5	:SEARCH FOR ZERO ENTRY
	JEFS	ATTA3			:GOT ONE
	AIS	R5,2
	JLBS	ATTA2
	J	BIDDRT			:MRESET TABLE FULL. TRY AGAIN LATER...

ATTA3	STH	R1,MRESET+MRESTZ*2,R5	:STORE NEIGHBOR NUMBER IN MRESET

:	TEST FOR SUBSEQUENT LINE ON EXISTING LINK.  IF LINK UNDEFINED OR
:	IF NUMBER OF LINES ON LINK=0, THEN THIS IS THE FIRST LINE ON
:	THAT LINK.
:					First Line	Subsequent Line
:	Original T-II Reset Header	30A0 (TTRSHD)	30B0 (TSRSHD)
:	Expanded Reset Header		33A0 (TXRSHD)	33B0 (TYRSHD)

	IF	XRESET
	CLHI	R4,TTRSHD		:Original T-II Reset Header?
	JEFS	ATTA4			:yes
	LHI	R4,TXRSHD		:No, assume Expanded Reset for New Link
	ELSE
	LHI	R4,TTRSHD		:ASSUME NEW LINK
	EI	:XRESET

ATTA4	JAL	R9,FNDLNK,,		:SEE IF LINK EXISTS
	GL	FNDLNK
	J	ATTA5			:LINK UNDEFINED

	IF	XRESET
	CLHI	R4,TTRSHD		:Original T-II Reset Header?
	JE	ATTL01			:yes, skip WSIZ and KSPD
	LB	R7,WSIZ,KD		:get Window Size
	STB	R7,XWSIZ,SD		:store it in xmit reset pattern
	LB	R9,KSPD,KD		:get Link Speed for Sat Bit
	STB	R9,XKSPD,SD		:store Link Capability for xmit

	IF	SILINS
	CLHI	LN,(NLINES-SILINS-1)*2
	JLE	ATTL01			:skip if not SIO line
	IF	SIBFRL			:###LSH
	L	R1,SIORSP,LN,LN		:get SIO Reset buffer Pointer
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R1,SIORSP,LN		:get SIO Reset buffer Pointer
	EI	:SIBFRL			:###LSH
	IF	STRHUB
	LB	R2,LTYP,LN		:IF STR LINE
	JEFS	ATA411
	STB	R7,(XWSIZ-VSDSZ)+6,R1	:-offset for Received Pattern Size,
	STB	R9,(XKSPD-VSDSZ)+6,R1	:+HW storage for SIO Reset Buffer Size
	JFS	ATA412
ATA411	EI	:STRHUB
	STB	R7,(XWSIZ-VSDSZ)+2,R1	:-offset for Received Pattern Size,
	STB	R9,(XKSPD-VSDSZ)+2,R1	:+HW storage for SIO Reset Buffer Size
ATA412	EI	:SILINS
	EI	:XRESET

ATTL01	LB	R7,NLAT,KD		:GET NUMBER OF LINES ATTACHED TO LINK
	JE	ATTA5			:ZERO - NEW LINK
	LHL	R2,TBDPKN,KN,KN		:GET CHANNEL ZERO
	LHL	R2,NIOTAB,R2,		:	BUFFER NUMBER AND
	NHI	R2,-4			:	MASK OFF SPEED BITS
	XHI	R2,4			:SET UP OUTBOUND BUFFER INDEX
:	LINK'S CHANNEL ZERO EXISTS FOR INTER-LINK CONTROL. SEND NEIGHBOR
:	'FASTC' AS SECURITY KEY FOR BRINGING UP SUBSEQUENT LINE ON LINK.
	LIS	R1,6			:CHARACTER COUNT
	JAL	R8,WCI,,
	GL	WCI
	LIS	R1,1			:MESSAGE TYPE FOR SENDING KEY
	JAL	R8,WCI,,
	LH	R1,FASTC,,		:FIRST 2 BYTES OF KEY
	STH	R1,RESETE,LN,		:SAVE HERE FOR STEP 'E'
	EXBR	R1,R1
	JAL	R8,WCI,,		:DEPOSIT KEY 1 BYTE AT A TIME
	EXBR	R1,R1
	JAL	R8,WCI,,
	LH	R1,FASTC+2,,		:NEXT 2 BYTES OF KEY
	STH	R1,RESETF,LN,		:SAVE HERE FOR STEP 'F'
	EXBR	R1,R1
	JAL	R8,WCI,,
	EXBR	R1,R1
	JAL	R8,WCI,,
	LR	R2,LN			:RESTORE R2 TO ACTUAL LINE NUMBER
	SRLS	R2,1

	IF	XRESET
	CLHI	R4,TTRSHD		:check for original T-II Reset Header
	JNFS	ATTL02			:no, must be Expanded Reset header
	EI	:XRESET

	LHI	R4,TSRSHD		:RESET HEADER FOR SUBSEQUENT LINE

	IF	XRESET
	JFS	ATTA5
ATTL02
	IF	STRHUB
	LB	R3,LTYP,LN
	JNFS	ATTA5			:NO SUBSEQ LINE FOR TYMSTR LINE
	EI	:STRHUB
	LHI	R4,TYRSHD		:Expanded Reset Header for Subseq Line

ATTA5	HS	0
	TBT	LN,XRSTBT,,		:Expanded Reset received?
	JEFS	ATT004			:no
	STH	R4,XRSTP,SD		:yes, store header only
	JFS	ATTA6
ATT004	HS	0
	ELSE	:not XRESET
ATTA5	HS	0
	EI	:XRESET

	EXHR	R4,R4
	OHI	R4,MACHNM		:INCLUDE MACHINE NUMBER
	ST	R4,XRSTP,SD		:FIRST 32 BITS OF RESET

ATTA6	LH	R3,SLOWC+2,,		:START TIMER FOR RESET SEQUENCE
	IF	XRESET
	AHI	R3,$A40			:must complete within 40 seconds
	ELSE	:NOT XRESET
	AHI	R3,$A36			:MUST COMPLETE WITHIN 36 SECONDS
	EI	:XRESET
:	(INCREASED FROM 20 SECONDS TO ALLOW 2.4 LINES TO ATTACH)
	JNFS	ATTA7
	AIS	R3,1			:FORCE NON-ZERO SO WON'T BE INTERPRETED
					: AS FIRST RESET
ATTA7	STH	R3,RSTIM,SD
ATTLI1	LH	R1,SLOWC+2,,		:CHECK TIMEOUT
	SR	R1,R3
	CHVR	R1,R1
	JL	ATTLI2
	IF	STRHUB			:###EV
	LB	R1,LTYP,LN
	JEFS	ATTLD4
	L	R9,SKDPTR,LN,LN
	LIS	R1,0
	STH	R1,TRYCNT,R9		:ZERO RESET TRY COUNTER
	EI	:STRHUB

:	TIMEOUT OR OTHER ERROR, ABORT
ATTLD4	JAL	R9,RSTSTR
ATLD41	IF	STRHUB			:###AL
	LB	R1,LTYP,LN
	JEFS	ATLD42
	LIS	R1,1			:SET HUB RESET ERR FLAG ##AL
	STB	R1,HRSERF,KD		:KD IS LIVE FOR STARLINE ##AL
ATLD42	EI	:STRHUB
:	Nodes with 'old' reset code may 'suspend' line during multi-line###wjl
:	reset or if out of link descriptors.  After suspension they will###wjl
:	remain in 'single-reset' state.  As they will not recognize 33A0###wjl
:	as a reset they will never send another reset!!  To avoid this,	###wjl
:	store a 30A0.  It is not necessary to store the entire pattern	###wjl
:	as even an abort will cause the node to begin 'streaming' resets,##wjl
:	which will allow recovery. Note that R6 is required and is set up##wjl
:	in RSTORE (called by RSTSTR).					###wjl
	IF	XRESET			:				###wjl
	LH	R4,VRSTP,SD		:test for old type reset received##wjl
	NHI	R4,0FFE0		:mask off 'subsequent'&count bits##wjl
	CLHI	R4,TXRSHD		:compare with 'expanded' reset	###wjl
	JEFS	ATTL05			:new version reset...		###wjl
	LHI	R4,TTRSHD		:old version, store header	###wjl
	STH	R4,XRSTP,R6		:R6 set up in RSTORE (RSTSTR)	###wjl
	EI	:XRESET			:				###wjl
ATTL05	LH	R1,NGSVLN,LN,		:REMOVE NEIGHBOR NUMBER FROM MRESET
	NHI	R1,7FFF
	JAL	R8,ATTMCL
	J	BIDDRT

::*********************************************************************
::
::	SUBROUTINE:	ATTMCL:
::	FUNCTION:	REMOVE NEIGHBOR NUMBER FROM MRESET, (LIST OF
::			NEIGHBORS CURRENTLY ENGAGED IN RESET SEQUENCE)
::	CALLING SEQ:	JAL	R8,ATTMCL
::	INPUT:		R1  = NEIGHBOR NUMBER
::
::*********************************************************************

ATTMCL	HS	0
	LHI	R5,-MRESTZ*2		:MRESET INDEX
ATTMC1	CLH	R1,MRESET+MRESTZ*2,R5
	JEFS	ATTMC2			:NEIGHBOR NUMBER MATCH
	AIS	R5,2
	JLBS	ATTMC1			:SCAN ALL ENTRIES
	JR	R8			:NEIGHBOR NUMBER NOT IN LIST
ATTMC2	LIS	R0,0
	STH	R0,MRESET+MRESTZ*2,R5	:ZERO ENTRY
	JR	R8			:RETURN
::
::*********************************************************************

::Enter here, if reset is not timed out
ATTLI2	LHL	R0,RSCNT,SD		:NEEDED BELOW
	LHL	R1,VRSTP,SD		:DISPATCH ON NEIGHBOR TYPE
	J	ATTLDW

::Enter here, check reset retry count
	IF	STRHUB			:Check reset retry counter
ATCNT3	LB	R0,LTYP,LN		:For Starlines only
	JE	ATTLD3			:Otherwise skip directly to continue
	L	R5,SKDPTR,LN,LN		:Get the Starline block pointer
	LH	R0,TRYCNT,R5		:Check initial resets (33A0) rcvd
	JEFS	ATCN32			:None - just add to count
	CLHI	R0,RESTRY		:Reaced threshold yet?
	JGEFS	ATREDS			:If yes - discontinue this reset
ATCN32	AIS	R0,1			:Else add to count
	STH	R0,TRYCNT,R5
	J	ATTLD3			:and continue normally

::If remote has exceeded the RESTRY threshhold, DIScontinue this reset
::Send Node Report and Crypto Log message
ATREDS	LIS	R0,0			:Re-initialize Starline block pntr
	L	KD,CRSTKD,R5		:Get link pointer from reset
	ST	R0,CRSTKD,R5		:Free current reset KD pointer
	STH	R0,TRYCNT,R5		:Zero reset try counter
	STB	R0,STAFLG,KD		:Set link status to down
	LH	R1,NGSVLN,LN,		:and set up to remove this
	NHI	R1,7FFF			:link from current reset activity
	LHI	R0,NR.RRF		:Tymstar Remote reset failure
	STH	R0,SUPMBF
	OHI	R1,8000			:Store node # from NGSVLN 
	STH	R1,SUPMBF+2
	JAL	R8,ATTMCL		:Remove neighbor from reset
	LR	R0,LN
	SRLS	R0,1
	OHI	R0,8080			:Line number
	STH	R0,SUPMBF+4
	JAL	R10,SUP12,,
	J	BIDDRT			:Return
	EI	:STRHUB

:	PREPARE RESET FOR TRANSMISSON
ATTLD3	HS	0			:PREPARE RESET FOR XMIT
	IF	SILINS			:SIO LINE ??
	CLHI	LN,(NLINES-SILINS-1)*2
	JLE	ATTL3A			:SKIP IF NOT SIO LINE
	LHI	R0,SIORS-SEG1		:SET SINGLE RESET STATE
	STH	R0,SIOTST,LN

	L	R0,XRSTP,SD		:MOVE RESET PATTERN to SIO Reset Buffer
	IF	SIBFRL			:###LSH
	L	R6,SIORSP,LN,LN		:get SIO Reset Buffer Pointer
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R6,SIORSP,LN		:get SIO Reset Buffer Pointer
	EI	:SIBFRL			:###LSH
	IF	XRESET			:###wjl
	IF	STRHUB
	LB	R5,LTYP,LN			:IF STR LINE
	JE	ATLD11
	L	R5,SKDPTR,LN,LN		:IS LINE ATTACHED?
	L	KD,CRSTKD,R5		:IS 1ST RESET REVED?
	JE	BIDDRT			:RET IF NON RESET REVED
	L	R1,LNKKEY,KD		:GET STR LINK KEY FOR XMIT RESET
ATTLX4	SHI	R6,VSDSZ-6		:-offset for Received Pattern Size
	ST	R1,XRSTP-4,R6		:1ST BYTE OF KEY LOCATED
	ST	R0,XRSTP,R6		:+HW storage for SIO Reset Buffer Size
	JAL	R5,CCKSUM		:calculate and store checksum for xmit
	LHI	R0,RSTSTA+RSTXFG	:SET RESET STATE AND
					: RESET XMIT BUFFER COPIED
	STB	R0,STAFLG,KD
	J	BIDDRT
ATLD11	EI	:STRHUB
	SHI	R6,VSDSZ-2		:-offset for Received Pattern Size
ATLD12	ST	R0,XRSTP,R6		:+HW storage for SIO Reset Buffer Size
	JAL	R5,CCKSUM		:calculate and store checksum for xmit
	ELSE	:not XRESET
	ST	R0,2,R6
	EI	:XRESET

	J	BIDDRT
	EI	:SILINS

ATTL3A	HS	0			:SYNC LINE
	IF	XRESET
	TBT	LN,XRSTBT,,		:expanded reset?		###cwc
	JEFS	ATT005			:no				###cwc
	LR	R6,SD			:CCKSUM needs Reset Buffer Ptr in R6
	JAL	R5,CCKSUM		:calculate and store checksum for xmit
	ELSE	:not XRESET
	LCS	R1,1			:store marks over assembly-time cksum
	ST	R1,XRSTP+4,SD		:TRANSMIT SINGLE RESET PATTERN
	EI	:XRESET

ATT005	LIS	R0,2			:SET UP HANDLER CODE TO TRANSMIT RESET
	LR	R1,LN
	SRHLS	R1,1
	LA	R2,XRSTP,SD
	IF	ISIS
	SVC	IO,60
	ELSE	:(SOLO)
	SVC	0F,SV.CSY
	EI	:ISIS
	J	BIDDRT

ATTLDW	RBT	R2,VRSTDL		:TYMNET-II - DID WE GET A RESET?
	JE	ATTLD6			:WE DONT HAVE A RESET

	IF	XRESET
	TBT	LN,XRSTBT,,		:Expanded Reset Header?
	JEFS	ATTL03			:no
	CLHI	R1,TYRSHD+0E		:Expanded Reset for Subseq Line +0E?
	JL	ATTLW2			:still working or not Subsequent Line
	JE	ATTLW1			:Subsequent Line - Step 0E
	JFS	ATTL04			:Subsequent Line - Step 0F
ATTL03	HS	0
	EI	:XRESET

	CLHI	R1,TSRSHD+0E	:HAS PING-PONG COUNT FOR SUBSEQUENT LINE
				:	ADVANCED TO STEP 'E'?
	JL	ATTLW2		:STILL WORKING OR NOT SUBSEQUENT LINE...
	JE	ATTLW1		:YES - RESET STEP 'E'
ATTL04	HS	0		:SUBSEQUENT LINE, RESET STEP 'F'
	LH	R1,VRSTP+2,SD	:GET 2ND 2 BYTES OF KEY RECEIVED OVER NEW LINE
	CLH	R1,RESETF,LN,	:AND COMPARE TO KEY WE SENT OVER EXISTING LINK
	JN	ATTDIE		:MISMATCH - SECURITY VIOLATION OR DUMB NEIGHBOR
	LIS	R1,0F		:SET UP FOR PING-PONG COUNT OF 0F
	J	ATTLW3
ATTLW1	HS	0		:STEP 'E' - RESET SHOULD CONTAIN FIRST 2 BYTES
				:OF KEY SENT OVER LINK--SAVED IN RESETE
	LH	R1,VRSTP+2,SD	:GET FIRST 2 BYTES OF KEY RCV'D OVER LINE AND
	CLH	R1,RESETE,LN,	:COMPARE TO KEY WE SENT OVER EXISTING LINK
	JN	ATTDIE		:MISMATCH - MAYBE SLOW LINK RESPONSE OR 
				:	SECURITY VIOLATION
	LIS	R1,0E		:SET UP FOR PING-PONG COUNT OF 0E
	J	ATTLW3
ATTLW2	LH	R2,NGSVLN,LN,	:GET NEIGHBOR NUMBER

	IF	XRESET			:###wjl
	TBT	LN,XRSTBT,,		:Expanded Reset received?
	JEFS	ATT006			:no
	CL	R2,VNDID,SD		:yes, compare to FW from reset
	JFS	ATT008
ATT006	CLHI	R0,1			:expecting first reset?
	JLEFS	ATT010			:yes
	LCS	R3,1			:no
	ST	R3,XRSTP+4,SD		:store marks over checksum
ATT010	HS	0
	EI	:XRESET

	CLH	R2,VRSTP+2,SD		:COMPARE TO WHAT WE GOT FROM RESET
ATT008
:	JN	ATTLD4			:INCONSISTENT - MAYBE LINE NOISE
	JE	ATT081			:INCONSISTENT - MAYBE LINE NOISE
	JAL	R9,RSTSTR		:CALL RSTSTR HERE TO KNOW R9
	J	ATLD41			:###AL
ATT081
	NHI	R1,0F			:MASK OUT PING-PONG COUNT
ATTLW3	LHL	R2,NGSVLN,LN,		:GET NEIGHBOR NUMBER
	CLHI	R2,MACHNM		:DISPATCH ON MASTER/SLAVE
	JL	ATMAST			:WE'RE MASTER
ATSLAV	LR	R0,R0			:SLAVE, IF IN STATE 0...
	JNFS	ATNEXT1
	LR	R1,R1			:ACCEPT A 0 OR A 1
	IF	STRHUB
	JE	ATCNT3			:Check number of initial resets
	ELSE
	JE	ATTLD3			:IF 0, REMAIN IN STATE 0
	EI	:STRHUB
	LIS	R0,1			:TRY FOR A 1
ATNEXT	CR	R0,R1			:DID WE GET WHAT WE EXPECTED
:	JN	ATTLD4			:NO, RESTART
	JE	ATNEX1			:NO, RESTART
	JAL	R9,RSTSTR		:CALL RSTSTR HERE TO KNOW R9
	J	ATLD41			:###AL
ATNEX1
	IF	STRRMT
	SRLS	LN,1			:Make line number
	RBT	LN,STRRES		:Rcvd first reset response
	SLLS	LN,1			:Return line index
	EI	:STRRMT
	AIS	R0,1			:INCREMENT EXPECTED RESPONSE
	STH	R0,RSCNT,SD
	CLHI	R0,3			:TIME TO REQUEST SPEED CALCULATION?
	JNFS	ATNX01
	LR	R1,LN
	SRLS	R1,1			:GET LINE NO.
	SBT	R1,LINSPT		:REQUEST LINE SPEED CALC (SEE G01SEC)
ATNX01	LH	R0,XRSTP,SD
	AIS	R0,1			:INCREMENT PING-PONG COUNT
	STH	R0,XRSTP,SD
	CLHI	R0,TSRSHD+0E	:HAVE WE ADVANCED TO STEP 'E' OF RESET SEQUENCE
				: FOR SUBSEQUENT LINE ON LINK?
	JL	ATTLD3		:NO - NEW LINK OR STILL INCREMENTING PING-PONG

	IF	XRESET
	NHI	R0,0F0FF		:mask out expanded vs. t-ii bits
	CLHI	R0,TSRSHD+0E		:Step 0E, Subsequent Line?
	JL	ATTLD3			:no, Expanded new Link or incrementing
	EI	:XRESET

	LH	R1,NGSVLN,LN,		:GET NEIGHBOR NUMBER AND
	JAL	R9,FNDLNK,,		:	SET UP LINK DESCRIPTOR
:	J	ATTLD4			:NOT FOUND - LINK WENT DOWN OR...?
	J	ATNX1A			:ERR RETURN
	JFS	ATNX1B
ATNX1A	JAL	R9,RSTSTR		:CALL RSTSTR HERE TO KNOW R9
	J	ATLD41			:###AL
ATNX1B
	LH	R2,RKEY,KD		:ASSUME STEP 'E'
	CLHI	R0,TSRSHD+0E		:step 0E?
	JEFS	ATNX02			:YES - STEP 'E'
	LH	R2,RKEY+2,KD		:NO - STEP 'F'
ATNX02	STH	R2,XRSTP+2,SD		:STORE 2 BYTES OF KEY IN RESET XMIT BUF
	J	ATTLD3			:GO TRANSMIT RESET

ATMAST	LR	R0,R0			:MASTER, IF IN STATE 0...
	JE	ATTNXT			:RETURN A 0
	CLHI	R0,2			:IF IN STATE 2, IGNORE 0'S
	JNFS	ATMAS1
	LR	R1,R1
	JE	BIDDRT
ATMAS1	AIS	R1,1			:ELSE EXPECT WHAT WE SENT LAST
					:REDUCE PING-PONG COUNT TO 4
	IF	STRHUB!STRRMT		:FOR STAR LINE		###EV
	LB	R9,LTYP,LN		:CHECK FOR A STAR LINE
	JE	ATMAS2			:REGULAR LINE
	CLHI	R1,4			:IF WE GOT FINAL COUNT ...
	JE	ATTLN8			:ATTACH
	J	ATNEXT
ATMAS2	EI	:STRHUB OR STRRMT	:			###LSH	

	CLHI	R1,10			:IF WE GOT FINAL COUNT...
	JE	ATTLN8			:ATTACH
	J	ATNEXT

ATTNXT	HS	0
	IF	XRESET			:###wjl
	TBT	LN,XRSTBT,,		:Expanded Reset received?
	JNFS	ATT012			:Yes
	LR	R0,LN			:No, we want to send two 30A0's.
	AIS	R0,1			:(LN*2)+1
	TBT	R0,XRSTBT,,		:Have we already sent a 30A0?
	JEFS	ATT014			:No, don't bump count yet.
ATT012	HS	0
	EI	:XRESET

	LIS	R0,1
	STH	R0,RSCNT,SD		:SET RESET COUNT TO 1
	IF	STRHUB
	J	ATCNT3			:Check retry counter
	ELSE
	J	ATTLD3
	EI	:STRHUB

	IF	XRESET			:###wjl
ATT014	SBT	R0,XRSTBT,,		:Remember to bump count next time.
	J	ATTLD3
	EI	:XRESET

:	RESET RECEIVED FOR POTENTIAL NEW LINK AND NOT ENOUGH PERMUTER
:	TABLE SPACE AVAILABLE FOR INITIALIZATION. REPORT TO SUP LOG AND
:	SUSPEND LINE.  
ATPTER	HS	0
	LIS	R0,NR.NPT
	STH	R0,SUPMBF		:INDICATE NO PERMUTER TABLE SPACE
	OHI	R1,8000
	STH	R1,SUPMBF+2		:INCLUDE NEIGHBOR NUMBER FROM RESET
	LR	R0,LN
	SRLS	R0,1
	OHI	R0,8080			:OR'ING 80'S MEANS NO ESCAPES NECESSARY
	STH	R0,SUPMBF+4		:ALSO REPORT LINE NUMBER
	JAL	R10,SUP12,,		:SEND MESSAGE TO SUPERVISOR

:	IGNORE LINE FOR 'KDIGTM' SECONDS
ATTDIE	HS	0
	LHL	R2,NGSVLN,LN,		:get neighbor number		###wjl
	CLHI	R2,MACHNM		:dispatch on master/slave	###wjl
	JLFS	ATTD00			:we're master			###wjl
	LIS	R1,0			:slave should clear		###wjl
	STH	R1,RSTIM,SD		: reset timeout			###wjl
	JFS	ATTDIT			:				###wjl
ATTD00	LHI	R1,KDIGTM
	AHM	R1,RSTIM,SD
ATTDIT	LIS	R1,0
	STH	R1,RSCNT,SD		:CLEAR RESET COUNT
	LHL	R1,XRSTP,SD		:clear count from reset pattern	###wjl
	NHI	R1,3FB0			:so we start from zero		###wjl
	STH	R1,XRSTP,SD		:				###wjl
	LCS	R1,1			:CAUSE 'SYLUAL'
	ST	R1,KDLN,LN,LN		: TO IGNORE ANY RECEIVE DATA
ATTDIS	LR	R0,LN
	SLLS	R0,0F			:GET LINE NUMBER IN UPPER HALFWORD AND
	LHL	R8,NGSVLN,LN,		: GET NEIGHBOR NUMBER
	OR	R0,R8			: COMBINE AND
	ST	R0,CRYSBF		: SAVE FOR CRYPTO
	LHI	R0,KDIGTM		:NO. SEC'S SUSPENDED
	JAL	R8,CRYPTO		:REPORT TO XRAY
	HC	CRYE20			:	(LINE SUSPENDED)
	LR	R0,LN
	SRLS	R0,1			:LINE NUMBER
	SBT	R0,LNSUSC		:INDICATE LINE SUSPENDED AND
ATTDIN	RBT	R0,LINATT		:	END LINE ATTACH PROCESS...
	JAL	R8,GMTLIN		:SET TIME
	J	BIDDRT

ATLN8A	LHI	KN,NLINKS-1
ATLN8B	SLL	KN,1
	L	KD,KDKN,KN,KN
	SRL	KN,1
	LH	R0,NDID,KD
	JE	ATLN8C			:FOUND AN AVAILABLE LINK DESCRIPTOR
	SIS	KN,1
	JGE	ATLN8B
:	NO LINK DESCRIPTORS AVAILABLE TO ATTACH NEW LINE.
:	REPORT TO SUPERVISOR LOG.
ATL8CC	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER IN HW2
	LR	R0,LN
	SRLS	R0,1
	OHI	R0,8080
	STH	R0,SUPMBF+4		:'ESCAPED' LINE NUMBER IN HW3
	LIS	R0,NR.NKD
	STH	R0,SUPMBF		:INDICATE TYPE OF NODE REPORT
	JAL	R10,SUP12,,		:SEND MESSAGE TO SUPERVISOR LOG
	J	ATTDIE			:SUSPEND LINE

ATLN8C	STH	R1,NDID,KD
	LIS	R7,0
	J	ATLN8D
ATTLD6	LHL	R2,NGSVLN,LN,		:IF WE'RE SLAVE AND HAVE SENT
	CLHI	R2,MACHNM		:...FINAL RESET, ATTACH
	JL	BIDDRT

	IF	STRHUB!STRRMT		:FOR STAR LINE		###LSH
	LB	R9,LTYP,LN		:CHECK FOR A STAR LINE
	JE	ATTLD7			:REGULAR LINE
	CLHI	R0,4	
	JN	BIDDRT
	J	ATTLD8
ATTLD7	EI	:STRHUB OR STRRMT	:			###EV
	CLHI	R0,10
	JN	BIDDRT
ATTLD8	HS	0			:			###LSH

	IF	SILINS
	CLHI	LN,(NLINES-SILINS-1)*2	:PROCESSING SIO LINE?
	JLE	ATTL6			:NO, SKIP

	IF	STRHUB
	LB	R0,LTYP,LN
	JE	ATTL66
	L	R9,SKDPTR,LN,LN
	LH	R0,NASTLK,R9		:For Starhub, Starlink resets after
	JN	ATTLN8			:the first link do not care about LN
ATTL66	EI	:STRHUB			:SIOTST state .. continue

	LH	R0,SIOTST,LN		:GET CURRENT STATE
	CLHI	R0,SIOIDL-SEG1		:IDLING?
	JN	BIDDRT			:NO, DONE
	J	ATTLN8			:YES
	EI	:SILINS

ATTL6	LR	R1,LN
	SRHLS	R1,1
:	ARE WE DONE XMITTING RESET
	IF	ISIS
	SVC	IO,70
	ELSE	:(SOLO)
	SVC	0F,SV.SOI
	EI	:ISIS
	J	BIDDRT			:IMMED RETURN--NO

:	LINE HAS GONE THRU RESET PROCEDURE, NOW LOCATE CORRESPONDING
:	LINK AND COMPLETE ATTACHMENT.
ATTLN8	LHI	R5,(BGLSIZ-1)*2
	LHL	R1,NGSVLN,LN,		:GET NEIGHBOR NUMBER
ATTL06	CLH	R1,BGLIST,R5		:check bad guy list 
:	JE	ATTLD4
	JN	ATL061
	JAL	R9,RSTSTR		:CALL RSTSTR HERE TO KNOW R9
	J	ATLD41			:###AL
ATL061	SIS	R5,2
	JGEBS	ATTL06

	IF	XRESET			:###wjl
	TBT	LN,XRSTBT,,		:Expanded Reset Header?
	JEFS	ATTL07			:no
	LHL	R0,VNETID,SD		:get received NETID
	CLH	R0,XNETID,SD		:compare with xmitted NETID
	JN	ATTNID			:not equal!
ATTL07	HS	0
	EI	:XRESET

	JAL	R9,FNDLNK,,		:neighbor number (preserved) in R1
	J	ATLN8A			:immed return, nonexistent link
	LB	R7,NLAT,KD		:skip return if link found
	JE	ATLN8D			:SKIP IF NEW LINK COMING UP
:	SUBSEQUENT LINE ON LINK...CHECK IT OUT
	LH	R0,VRSTP,SD		:GET RESET HEADER BACK
	CLHI	R0,TTRSHD+0F		:TYMNET-II HEADER FOR NEW LINK?
:	JE	ATTLD4		:YES, MUST USE TSRSHD HEADER FOR SUBSEQ LINE
	JN	ATL071		:YES, MUST USE TSRSHD HEADER FOR SUBSEQ LINE
	JAL	R9,RSTSTR		:CALL RSTSTR HERE TO KNOW R9
	J	ATLD41			:###AL
ATL071
	IF	XRESET		:###wjl
	CLHI	R0,TXRSHD+0F	:T-II Expanded Reset Header for new link?
:	JE	ATTLD4		:yes, must use TYRSHD for subsequent line
	JN	ATTL08		:YES, MUST USE TSRSHD HEADER FOR SUBSEQ LINE
	JAL	R9,RSTSTR		:CALL RSTSTR HERE TO KNOW R9
	J	ATLD41			:###AL
:	J	ATTL08		:no KD updateV or WSIZ match down
	EI	:XRESET
ATLN8D	HS	0
	IF	XRESET			:###wjl
	TBT	LN,XRSTBT,,		:check for Expanded Reset Header
	JE	ATTL08			:no KD update or WSIZ matchdown
	L	R0,VVERNO,SD
	ST	R0,KVERNO,KD		:store VERNO and NETID
	L	R0,VHOST0,SD
	ST	R0,KHOST0,KD		:store neighbor's HOST0
	LB	R0,VLINE,SD
	STB	R0,KLINE,KD		:store neighbor's LINE
	LB	R1,VWSIZ,SD		:get received window size
	CLB	R1,XWSIZ,SD		:compare with transmitted window size
	JGE	ATTL08			:VWSIZ is > or = XWSIZ, no problem
	NHI	R1,0FC			:match down!  WSIZ must be mult of 4
	LHL	R2,ISEC,KD		:ISEC pts to start of chain
	JAL	R9,MCHDWN		:R2 stored in RLNK of last buffer
	LHL	R2,OSEC,KD		:OSEC now
	JAL	R9,MCHDWN
	STB	R1,WSIZ,KD		:set window size for this link
	LHI	R0,NR.WSZ		:send Node Report to Sup log
	STH	R0,SUPMBF		:indicate WSIZ match down in HW0
	LR	R0,LN			:line number * 2
	SRHLS	R0,1			:line number
	OHI	R0,8000			:avoid escapes
	STH	R0,SUPMBF+2		:include line number in HW1
	OHI	R1,8000
	STH	R1,SUPMBF+4		:include neighbor's WSIZ in HW2
	JAL	R10,SUP12,,		:send message to Sup and CRYPTO Logs
ATTL08	HS	0
	EI	:XRESET
	IF	STRHUB
	LB	R0,LTYP,LN		:TYMSTAR LINE ?
	JE	ATTL18			:NO
	L	R2,SKDPTR,LN,LN		:R2 = SKDBLK ADDR
	LHL	R0,NASTLK,R2		:FIRST LINK ON THIS LINE ?
	JEFS	ATTL18			:CONTINUE ON NEW LINK PROCESS
	LIS	R2,1			:UPDATE NLAT FOR NEW LINK
	STB	R2,NLAT,KD
	LHI	R0,LNCKTM		:LINK DOWN TIMER FOR STRLNK
	STH	R0,SCONFS,KN,
	SBT	KN,LKGREC
	JAL	R10,KSPEED		:LINK SPD FOR SAT.
	J	ATLNR0			:CONTINUE NEW LINK PROCESS
ATTL18	HS	0
	EI	:STRHUB ##AL
	LIS	R0,0			:CLEAR LINE STATISTICS
	STH	R0,LINERR,LN,
	STH	R0,BADACK,LN,
	STH	R0,BADRCN,LN,
	STH	R0,BADCSM,LN,
	STH	R0,RCRXMT,LN,
	STH	R0,RCRCVD,LN
	STH	R0,LCROSS,LN,
	STH	R0,RCTRNS,LN
	STH	R0,TRRXMT,LN,
	AIS	R7,1		:INCREMENT NUMBER OF ATTACHED LINES THIS LINK
	STB	R7,NLAT,KD
	STH	R0,KFROZN,KD		:LINK NOT FROZEN
	IF	STRRMT
	LB	R0,LTYP,LN		:REMOTE STAR LINE SET SATT. BIT
	JEFS	ATTLS8
	LB	R0,KSPD,KD
	OHI	R0,SAT
	STB	R0,KSPD,KD
ATTLS8	EI	:STRRMT
	IF	XRESET			:###wjl
	TBT	LN,XRSTBT,,		:Expanded reset Header?	
	JNFS	ATTL09			:neighbor version entered above
	EI	:XRESET

	TS	KVERNO,KD	:ASSUME NEIGHBOR VERSION NUMBER NOT KNOWN
ATTL09	HS	0

	IF	STRHUB
	LB	R0,LTYP,LN		:TYMSTAR LINE ?
	JE	ATTLX9			:NO
	L	R2,SKDPTR,LN,LN		:R2 = SKDBLK ADDR
	ST	R2,KDLN,LN,LN		:CHAIN KDLN
	L	R0,STHEAD,R2
	ST	R0,STNEXT,R2		:INIT STNEXT
	J	ATTLZ9
ATTLX9	HS	0
	ST	KD,KDLN,LN,LN
ATTLZ9	HS	0
	ELSE	:NOT STRHUB
	ST	KD,KDLN,LN,LN		:SET LINK PTR FOR LINE
	EI	:STRHUB

	ST	KD,KDSVLN,LN,LN		:SAVE IT IN CASE IT RESETS
	LHL	R1,NGSVLN,LN,		:get neighbor number
	JAL	R8,ATTMCL		:REMOVE NEIGHBOR NUMBER FROM MRESET
	LHI	R1,8000,R1		:SAVE THE CURRENT NEIGHBOR NUMBER
	STH	R1,NGSVLN,LN,
	LHI	R1,LNCKTM	:INITIALIZE CONFSG SO WE CAN DETECT WHEN
				:A LINE GOES LNCKTM TIMES OF 4-SECONDS
				:GAPS WITH NO GOOD RECORD.		###LH
	IF	STRRMT
	LB	R0,LTYP,LN		:				###AL
	JEFS	ATTLZ1
	SRLS	R1,2			:REMOTE STARLINE USE 16-SEC LINE CHECK
ATTLZ1	EI	:STRRMT
	IF	STRHUB
	LB	R0,LTYP,LN
	JEFS	ATTLZA
	STH	R1,SCONFS,KN,	:PER STAR LINK
	JFS	ATTLZB
ATTLZA	EI	:STRHUB
	STH	R1,CONFSG,LN,	
ATTLZB	LR	R1,LN
	SRHLS	R1,1
	LIS	R0,0
	STB 	R0,DREASN,R1,
	SBT	R1,ALINES		:LINE ACTIVE NOW
	RBT	R1,LINATT
	SBT	R1,INHRST		:PREVENT DETACHMENT BY STRAY RESETS
	SBT	KN,LKGREC
	JAL	R10,KSPEED		:DETERMINE THE SPEED OF THIS LINK
	SIS	R7,1			:IS THIS A NEW LINK?
	JGFS	ATLNR1		:NO - MORE THAN 1 LINE, SUBSEQUENT LINE ATTACH
ATLNR0	LHI	R4,13E0			:MESSAGE TYPE FOR NEW LINK REPORT
	LB	R0,KSPD,KD		:INCLUDE LINK SPEED IN REPORT	###OAS
	NHI	R0,001F			:MASK OFF SATELLITE BITS	###OAS
	AR	R4,R0			:				###OAS
	J	ATLNR2
ATLNR1	LHI	R4,13C0			:MESSAGE TYPE FOR NEW LINE REPORT
	LHL	R0,BAUDRT,LN,		:CHECK IF LINE IS HIGH SPEED	###OAS
	CLHI	R0,HISPD		:HIGH SPEED (0C) IS 28.8KB	###wjl
	JLFS	ATLNR9			:NOT HIGH SPD, REPORT CALCULATED SPEED
	TBT	KN,KNCNSP		:IS SPEED SPECIFIED IN TYMFILE?
	JEFS	ATLNR9			:NO, REPORT CALCULATED SPEED
	LB	R0,KSPD,KD		:HIGH SPD AND SPECIFIED, USE LINK SPEED
	NHI	R0,1F			:ISOLATE SPEED BITS
ATLNR9	AR	R4,R0			:INCLUDE IN REPORT
ATLNR2	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER		###OAS
	CLHI	R0,$8 2000		:BYPASS IF TYMNET-II LINK
	JGEFS	ATTLN9
	TS	KFROZN,KD		:DEFER LINK UP REPORT UNTIL GOOD RECORD
:	RECEIVED FROM TYMNET-I NEIGHBOR. PREVENTS CONTINUOUS UP/DOWN
:	REPORTS FOR TYMNET-I WINDOW SIZE MISMATCH CONFIGURATION ERRORS.
	J	ATTL8A
ATTLN9	JAL	R10,SUP13,,		:NOTIFY SUPERVISOR OF NEW LINE/LINK

:	THE 5TH AND 6TH HALFWORDS IN A RESET FROM THE NEIGHBOR MAY HAVE
:	THE NEIGHBOR'S VERSION NUMBER AND THE VERSION NUMBER COMPLEMENT.
:	THE COMPLEMENT IS TESTED. If -1, the Version is stored in the KVERNO
:	field of the Link Descriptor. If not, FFFF was stored above. THIS MAY
:	OCCUR BECAUSE VERSIONS OF NODE CODE PRIOR TO 5.00 DID NOT
:	PROVIDE THEIR VERSION NUMBER.

	LH	R0,VRSTP+4,SD	:GET POTENTIAL VERSION NUMBER FROM RESET
	JEFS	ATLN9A		:0 NOT LEGAL VERSION, DON'T LET SPACING FOOL US
	LH	R1,VRSTP+6,SD	:VERSION NUMBER COMPLEMENT
	XR	R1,R0		:VERIFY THAT VERSION WAS PRESENT IN RESET
	AIS	R1,1
	JNFS	ATLN9A		:NOPE - OLD VERSION IN NEIGHBOR
	STH	R0,KVERNO,KD	:YES - SAVE VERSION NUMBER IN LINK DESCRIPTOR
ATLN9A	LR	R1,LN
	SRLS	R1,1		:GET ACTUAL LINE NUMBER TO
	SBT	R1,LNGREC	:	PREVENT IMMEDIATE DETACH BY LNCHCK

	IF	SILINS
	CLHI	LN,(NLINES-SILINS-1)*2	:SIO LINE?
	JLE	ATTL8A			:NO, SKIP
	IF	STRHUB
	LB	R0,LTYP,LN		:TYMSTAR LINE ?
	JE	ATTL88			:NO
	L	R8,SKDPTR,LN,LN		:1ST STARLINK?
	LHL	R0,NASTLK,R8
	JE	ATTL88
	IF	TSTSZE
	LHL	R8,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R8,TSLINK		:	SEE IF WE'RE TRACING THIS LINK
	JNFS	ATTL87			:NO - CONTINUE
	JAL	R8,TSBMRK		:YES - SET UP NEW EVENT ENTRY
	LHI	R8,TS.ATT
	STB	R8,TSBTBL,R7		:STORE ENTRY TYPE
	LB	R8,NLAT,KD
	STH	R8,TSBTBL+2,R7		:SAVE NUMBER OF LINES CURRENTLY ON LINK
ATTL87	EI	:TSTSZE
	J	ATTLNK
ATTL88	EI	:STRHUB
	LHI	R0,SIOTT-SEG1		:SET ACTIVE OUTPUT STATE
	STH	R0,SIOTST,LN
	JFS	ATTL8B
	EI	:SILINS

ATTL8A	LIS	R0,1
	LR	R1,LN			:SET UP REGISTERS FOR CONNECT SVC
	SRHLS	R1,1
	LR	R2,KD
	IF	ISIS
	SVC	IO,60
	ELSE	:(SOLO)
	SVC	0F,SV.CSY
	EI	:ISIS
ATTL8B	HS	0
	IF	TSTSZE
	LHL	R8,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R8,TSLINK		:	SEE IF WE'RE TRACING THIS LINK
	JNFS	ATTL8T			:NO - CONTINUE
	JAL	R8,TSBMRK		:YES - SET UP NEW EVENT ENTRY
	LHI	R8,TS.ATT
	STB	R8,TSBTBL,R7		:STORE ENTRY TYPE
	LB	R8,NLAT,KD
	STH	R8,TSBTBL+2,R7		:SAVE NUMBER OF LINES CURRENTLY ON LINK
ATTL8T	EI	:TSTSZE
	LR	R0,LN			:GET LINE NUMBER * 2
	SLLS	R0,0F			:HI-ORDER HW NOW HAS LINE NUMBER
	IF	STRHUB
	LB	R8,LTYP,LN		:IF STARLINE NBR# 0000 ##AL
	JNFS	ATTL8X
	EI	:STRHUB
	AH	R0,NDID,KD		:INCLUDE NEIGHBOR NUMBER
ATTL8X	ST	R0,CRYSBF		:SAVE FOR CRYPTO
	LB	R0,NLAT,KD		:NO. OF LINES ON LINK
	JAL	R8,CRYPTO		:SEND CRYPTOGRAM FOR
	HC	CRYE16			:	NEW LINE ATTACHED
	JAL	R8,GMTLIN		:STORE TIME

:	TEST FOR SUBSEQUENT LINE ATTACH OR NEW LINK
	LB	R7,NLAT,KD		:GET NUMBER OF LINES ON LINK
	SIS	R7,1			:IF ONE LINE, THIS IS A NEW LINK
	JEFS	ATTLNK			:NEW LINK - SET IT UP

	IF	DB.TSN
	JAL	R11,LNKCON		:PERFORM LINE/LINK CONSISTENCY CHECK
	EI	:DB.TSN
	J	BIDDRT

:	NEW LINK HAS BEEN CREATED, INITIALIZE IT.

ATTLNK	LH	R0,NDID,KD
	LR	R6,0
ATTL10	STH	R0,CHNMPD,KN,KN		:SET UP CHANNEL MAP FOR TRACE LOGIC
ATTLTW	LHI	R0,WBORIM		:TYM-II - SET EXPECTED BORI
	CHI	R6,MACHNM
	JGFS	ATTL20			:.+6
	LHI	R0,WBORIS
ATTL20	STB	R0,BORI,KD
	LHI	R0,0FF			:SET ACK MASK
	STH	R0,AMSK,KD
:	SET LINK TYPE (KTYP).(*0 FOR T-I, 4 FOR T-1.5,*) 8 FOR T-II.
	IF	STRHUB!STRRMT		:###EV
	LB	R0,LTYP,LN		:If this is a Starline
	JE	STATT3
	LIS	R0,STRTYP		:then link type is STRTYP (=0C)
	J	ATTL30
	EI	:STRHUB!STRRMT		:###EV
STATT3	LIS	R0,8			:ASSUME T-II
ATTL30	STB	R0,KTYP,KD
ATTLN6	LCS	R0,1			:INIT OTHER VARIABLES
	ST	R0,LRT,KD		:SET LRT,LAS,LRM,LAR TO -1
	ST	R0,LRM,KD
	IF	APLYBP&MAKNUL
	STH	R0,LRR,KD		:Inits Last Rexmission Recvd
	EI	:STRHUB!STRRMT
	IF	NAKCOD
	STH	R0,LGRR,KD		:For Starlink SIO sequence 	###ev
	STH	R0,PRXM,KD
	STH	R0,NKTS,KD
	EI	:NAK
	LHL	R2,OSEC,KD		:SET NRXM=OSEC
	STH	R2,NRXM,KD		:NEXT REC XMITTED WILL BE THE FIRST
	STH	R2,NRMK,KD		:SO WILL NEXT REC MADE
	LB	R1,WSIZ,KD		:SET REC #'S TO -WSIZ TO -1
	JAL	R9,CLRCHN
	LHL	R2,ISEC,KD
	STH	R2,NRTR,KD
	JAL	R9,CLRCHN
	JAL	R8,GMTLIN		:SET TIME

	JAL	R10,NEWLNK		:SPIDER WILL COMPLETE INITIALIZING
	GL	NEWLNK
	LR	R2,LN			:LN MAY BE USED BY LNKCON##AL
	IF	DB.TSN
	JAL	R11,LNKCON		:PERFORM LINE/LINK CONSISTENCY CHECK
	EI	:DB.TSN
::	STAR LINK UP, RESET CRSTKD AND CHANGE RSTSTA TO LNKSTA
	LR	LN,R2			:GET LN BACK##AL
	IF	STRHUB
	LB	R0,LTYP,LN		:TYMSTAR LINE ?
	JE	ATTLN7			:NO
	JAL	R9,GMTCAL,,		:CATCH GMT WHEN STARLINK UP ##AL
	L	R0,GMTNOW,,
	ST	R0,STRTIM,KD		:STORE IN KD
	LHI	R0,LNCKTM		:INIT 4 SEC LOGIC COUNT ##AL
	LB	KN,LKNM,KD
	STH	R0,SCONFS,KN,KN
	RBT	KN,BORZAP		:LINK IS UP, NO BORIZAP ##AL
	L	R2,SKDPTR,LN,LN
	LHL	R0,NASTLK,R2
	AIS	R0,1			:INCR NO. OF LINKS
	STH	R0,NASTLK,R2
	LIS	R0,LNKSTA		:CHANGE RSTSTA TO LNKSTA
	STB	R0,STAFLG,KD
	LIS	R0,0
	ST	R0,CRSTKD,R2		:CLEAR KD PTR
	STH	R0,TRYCNT,R2		:CLEAR RESET TRY COUNTER
	LHL	R2,SDLN,LN		:RESET RSSET CNT & TIMER
	STH	R0,RSCNT,R2
	STH	R0,RSTIM,R2		: ##AL
	LR	R0,LN
	SRL	R0,1			:REAL LINE #
	RBT	R0,LINATT		:RESET ATTACH MODE ##AL
	JAL	R10,KSPEED		:CALCULATE NEW LINK SPEED,
ATTLN7	HS	0
	EI	:STRHUB

	J	BIDDRT

:	Reset received for potential new link, but neighbor
:	has different NETID.  Add neighbor (in R1) to Bad Guy List,
:	report to SUP Log, make CRYPTO Log entry, and remove neighbor number
:	from list of neighbors	currently engaged in reset sequence (MRESET).

	IF	XRESET
ATTNID	HS	0
	LHI	R5,(BGLSIZ-1)*2
ATTN02	LH	R2,BGLIST,R5
	JEFS	ATTN04			:if no entry, go make entry
	SIS	R5,2			:prepare to check next entry or
	JGBS	ATTN02			: if list full, reuse first entry
ATTN04	STH	R1,BGLIST,R5		:make entry in bad guy list
	OHI	R0,8000			:avoid escapes
	STH	R0,SUPMBF+4		:include neighbor's NETID in HW2
	LR	R1,LN			:line number*2
	SRHLS	R1,1			:line number
	OHI	R1,8000
	STH	R1,SUPMBF+2		:include line number in HW1
	LHI	R0,NR.NID
	STH	R0,SUPMBF		:indicate NETID mismatch in HW0
	JAL	R10,SUP12,,		:send message to Sup and CRYPTO Logs

:	J	ATTLD4
	JAL	R9,RSTSTR		:CALL RSTSTR HERE TO KNOW R9
	J	ATLD41			:###AL
	EI	:XRESET

	SUBTTL	LINKER (DETLIN - Line detach logic)

::*********************************************************************
::
::	SUB-PROCESS:	DETLIN:
::	FUNCTION:	Detaches lines placed in limbo after a valid
::	reset is detected.  Scheduled by LINKER.
::	CALLING SEQ:	LA	R3,LINDET
::			JAL	R9,BIDDY
::			J	DETLIN
::	CALLS:		JAL	R9,RSTSTR
::			JAL	R10,KSPEED
::			JAL	R8,CRYPTO
::			JAL	R8,GMTLIN
::			JAL	R10,TRLINK
::			JAL	R11,LNKCON
::	RETURNS:	J	BIDDRT
::
::*********************************************************************

DETLIN	HS	0
	IF	DB.CPU
	LR	R3,R2			:SAVE R2			###OAS
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR DETLIN	###OAS
	CPUTNM(DETLIN)			:DEFINE DETLIN CPUTIL ENTRY	###OAS
	LR	R2,R3			:RESTORE R2			###OAS
	EI	:DB.CPU

	LR	LN,R2			:GET 2*LINE NUMBER
	AR	LN,LN

	IF	STRHUB
	LB	R0,LTYP,LN		:TYMSTAR LINE ?
	JE	DETLY2			:NO
	L	R2,SKDPTR,LN,LN		:R2 = SKDBLK ADDR
	L	KD,STHEAD,R2		:CHECK DET STATE FLAG FOR ALL
DETLX0	LB	R0,STAFLG,KD		: ##AL
	SIS	R0,DETSTA
	JN	DETLX6
	STB	R0,STAFLG,KD		:Reset link status to zero
	LHL	R0,NASTLK,R2
	SIS	R0,1			:DECR NO. OF links
	STH	R0,NASTLK,R2
	JE	DETLY1			:LAST LINK ?
	LR	R4,LN			:NOT LAST LINK
	SRLS	R4,1
	LB	R4,DREASN,R4,
	AHI	R4,1380
	LIS	R0,0
	STH	R0,KFROZN,KD
	JAL	R10,SUP13,,		:REPORT LINK OUT
	J	DETLX5			:TEAR DOWN LINK
DETLY1	LIS	R9,0			:ZERO OUT CRSTKD BEFORE RSTSTR
	ST	R9,CRSTKD,R2		: ##AL
	JAL	R9,RSTSTR
	JFS	DETLY3
DETLY2	EI	:STRHUB
	JAL	R9,RSTSTR		:PUT LINE IN RESET MODE
	L	KD,KDSVLN,LN,LN		:RETRIEVE PTR TO FORMER LINK
DETLY3
	LIS	R0,0			:RESET HI-ORDER BIT OF THIS FOR PROBE
	RBT	R0,NGSVLN,LN,
	LB	R7,NLAT,KD		:DECREMENT ATTACHED-LINE COUNT
	SIS	R7,1			:R7=0 IF LINK MUST BE TORN
	STB	R7,NLAT,KD
	JAL	R10,KSPEED		:RECOMPUTE LINK SPEED
	LR	R4,LN
	SRLS	R4,1			:GET ACTUAL LINE NUMBER IN R4
	LB	R4,DREASN,R4,		:GET REASON FOR OUTAGE IN R4
	LR	R7,R7			:ANY LINES LEFT FOR THIS LINK?
	JNFS	DETLN2			:YES - LINK NOT OUT, REPORT LINE DETACH
DETLN1	AHI	R4,1380			:REPORT LINK OUT TO SUPERVISOR
	LIS	R0,0			:	AND INSURE LINK NOT MARKED AS
	STH	R0,KFROZN,KD		:	FROZEN
	JFS	DETLN3
DETLN2	AHI	R4,13A0			:REPORT LINE DETACH TO SUPERVISOR
DETLN3	JAL	R10,SUP13,,		:SEND MSG TO SUP
DETLN4	LR	R1,LN
	SRLS	R1,1			:GET ACTUAL LINE NUMBER IN R1
	LB	R0,DREASN,R1,		:TELL XRAY, REASON ON LEFT
	EXHR	R1,R1			:LINE NUMBER IN HO HW
	IF	STRHUB
	LB	R8,LTYP,LN
	JEFS	DETLNN
	LIS	R8,0			:PUT NBR# 0000 FOR STARLINE ##AL
	JFS	DETLNB
DETLNN	EI	:STRHUB
	LHL	R8,NGSVLN,LN,		:NEIGHBOR NUMBER
DETLNB	OR	R1,R8			:COMBINE AND
	ST	R1,CRYSBF		: SAVE FOR CRYPTO
	JAL	R8,CRYPTO
	HC	CRYE04			:LINE DETACHED
	JAL	R8,GMTLIN		:SET TIME
	LR	R7,R7
	JN	DETLN5			:NLAT > 0, LINK NOT GOING DOWN
	JAL	R10,TRLINK		:NON STR LINE TEAR LINK ##AL
	GL	TRLINK
	J	DETLN5
	IF	STRHUB
DETLX5	HS	0
	JAL	R10,TRLINK		:STR LINE TEAR LINK
	JAL	R9,GMTCAL,,		:CATCH GMT WHEN STARLINK DOWN
	L	R0,GMTNOW,,
	ST	R0,STRTIM,KD		:PUT IN KD ##AL
	LB	R0,STAFLG,KD		:RESET DETSTA FLAG
::	LIS	R0,0			:Link finally down - restore
::###EV	STB	R0,STAFLG,KD		:link down status
DETLX6	L	KD,NXTLNK,KD		:CHECK NEXT LINK DET?
	JE	BIDDRT
	J	DETLX0			:YES
	EI	:STRHUB

DETLN5	IF	DB.TSN
	JAL	R11,LNKCON		:PERFORM LINE/LINK CONSISTENCY CHECK
	EI	:DB.TSN
	J	BIDDRT

	SUBTTL	LINKER (Attach/Detach subroutines)

::*********************************************************************
::
::	SUBROUTINE:	GMTLIN:
::	FUNCTION:	Set time of line attach or detach
::	CALLING SEQ:	JAL	R8,GMTLIN
::	INPUT:		LN  =Line number*2
::	CALLS:		JAL	R9,GMTCAL
::
::*********************************************************************

GMTLIN	HS	0			:SET TIME OF LINE ATT/DET
	JAL	R9,GMTCAL,,		:GET CURRENT TIME
	L	R0,GMTNOW,,		:AND
	ST	R0,LINTIM,LN,LN		:STORE IT
	JR	R8			:RETURN TO THE SOURCE

	IF	STRRMT			:REMOTE CODE FOR TYMSTAR
::*********************************************************************
::
::	SUBROUTINE:	SNDRST:
::	FUNCTION:	Check time of remote station sending initial resets,
::			called from 04sec logic
::	CALLING SEQ:	JAL	R10,SNDRST
::	CALLS:		JAL	R9,RSTSTR
::
::*********************************************************************
::This routine checks to see if additional initial resets are needed to
::be sent on a Starline.
SNDRST	HS	0								
	ST	R10,RMTRSV		:Save return
	LHI	LN,NLINES-1		:Do for all lines
SNDR01	CLHI	LN,NLINES-SILINS-1	:Starline must be an SIO line
	JLE	SNDR09			:If not, just go to next line
	TBT	LN,STRRES		:else a bit on means send reset
	JE	SNDR09			:otherwise, next line
	SLLS	LN,1			:RSTSTR requires a line index
	JAL	R9,RSTSTR
	SRLS	LN,1			:Restore to real line number
SNDR09	SIS	LN,1
	JGE	SNDR01			:more lines to look at
	L	R10,RMTRSV		:restore return reg
	JR	R10			:and return
	EI	:STRRMT				:###EV


::*********************************************************************
::
::	SUBROUTINE:	RSTSTR:
::	FUNCTION:	Forces line to transmit stream of resets with
::	ping-pong count set to 0.  This is the normal state of lines
::	that have been detached but are not yet in process of identification.
::	CALLING SEQ:	JAL	R9,RSTSTR
::	PRESERVED:	R11= NETID (preserved for IZLNKR)
::	RETURNED:	R6 = RESET BUFFER POINTER (may be needed at ATTLD4)
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R6,R7,R8,R10
::	CALLS:		JAL	R7,RSTORE
::			JAL	R10,SIOIZ0
::			JAL	R0,SVCE32
::			JAL	R0,SVCE30
::
::*********************************************************************

	IF	XRESET			:Expanded Reset	###wjl

RSTSTR	HS	0
	LHL	SD,SDLN,LN		:PTR TO RESET BUFF
	IF	STRHUB
	LB	R0,LTYP,LN		:ONLY LAST STRLINK MAY PUT LINE
	JEFS	RSTSA1			: IN RESET MODE
	L	R6,SKDPTR,LN,LN
	LHL	R6,NASTLK,R6
	JNFS	RSTSA2
RSTSA1	EI	:STRHUB
	LCS	R0,2			:SET RESET MODE FLAG
	ST	R0,KDLN,LN,LN
RSTSA2	LR	R6,SD			:RSTORE needs Reset Buff Ptr in R6
	JAL	R7,RSTORE		:store Xmit Reset Pattern

	IF	SILINS
	LR	R1,LN
	SRLS	R1,1			:actual Line Number 
	CLHI	R1,NLINES-SILINS-1	:SIO Line?
	JG	RSTSIO			:yes - jump
	EI	:SILINS
					:SET UP FOR SYNC SVC IO,60/SV.CSY
	LIS	R0,4			:set R0=Reset Transmit Handler
	LR	R1,LN			:set R1=Line Number
	SRLS	R1,1			:set R2 below...
	LHI	R3,XSDSZ		:set R3=size of reset in bytes

	IF	ISIS
:	CONNECT SYNC LINE I/O, AND RAISE DTR AND RTS SIGNALS.
:	(FOR SOLO, DTR AND RTS HANDLED IN 'IZSYLL'.)
	LR	R2,LN			:GET LINE NUMBER * 2
	AR	R2,LN			:COMPUTE LINE NUMBER * 24 AS INDEX INTO
	AR	R2,LN			: ROTOR LIST.  ROTOR LIST HAS 3 8-BYTE
	SLLS	R2,2			: COMMAND ENTRIES PER SYNC LINE.
	LA	R2,ROTOR,R2,		:R2 NOW POINTS TO ENTRY FOR THIS LINE
	LIS	R8,4			:COMMAND TO RAISE RTS
	STH	R8,0,R2
	LIS	R8,9			:COMMAND TO RAISE DTR
	STH	R8,8,R2
:	NOTE THAT THE THIRD COMMAND ENTRY IS 0 FOR STOP OUTPUT. EXPLICIT
:	STORE NOT NECESSARY SINCE SEG 0 INITIALIZED TO ZERO.
	SVC	IO,20+1			:PROCESS COMMANDS IN ROTOR
:		(POINTED TO BY R2).  R1 = LOGICAL UNIT NUMBER (LINE NUMBER).
	JAL	R0,SVCE32		:ERROR, CRASH 

:	SVC IO,60>>R0=HANDLER CODE, R1=LINE NUMBER, R2=BUFFER ADDRESS, R3=COUNT
	LA	R2,XRSTP,SD		:POINT TO RESET TRANSMIT BUFFER
	SVC	IO,60			:T-II SYNC LINE CONNECT

	LHL	R2,SVBDIS,LN	:GET THIS LINE'S DISPLACEMENT INTO SYNC INPUT
	LA	R2,SVNTIP,R2,	: BUFFERS AND ADD TO BUFFER POOL START ADDRESS
	LHI	R3,SVNBSZ		:SYNC INPUT BUFFER SIZE
	SVC	IO,01			:CONNECT SYNC INPUT
	JAL	R0,SVCE30		:ERROR, CRASH

	ELSE	:(NOT ISIS)
	LA	R2,XRSTP,SD		:POINT TO RESET TRANSMIT BUFFER
	SVC	0F,SV.CSY		:CONNECT SYNC INPUT AND OUTPUT. SAME
					:SETUP AS FOR ISIS SVC IO,60 ABOVE.
	EI	:ISIS
	
	IF	SILINS
	J	RSTST2			:SKIP FOR SYNC LINE
RSTSIO
	IF	STRHUB
	LB	R2,LTYP,LN		:ONLY LAST STRLINK MAY INIT SIO
	JE	RSTSBB			: LINE
	L	R2,SKDPTR,LN,LN
	LHL	R0,NASTLK,R2
	JN	RSTSCC
RSTSBB	EI	:STRHUB
	LR	R2,LN
	SHI	R2,(NLINES-SILINS)*2
	SLLS	R2,3			:COMPUTE RELATIVE SIO LINE NUMBER * 10
	LCS	R0,3			:INDICATE SIO LINE BEING RE-INITIALIZED
	STH	R0,SIOSTT+8,R2,		: DUE TO LINE GOING TO RESET STATE
	JAL	R10,SIOIZ0		:INITIALIZE SIO LINE
	LHL	SD,SDLN,LN		:RESTORE POINTER TO RESET BUFFER
	LIS	R0,0
	STH	R0,BAUDRT,LN,		:CLEAR LINESPEED FOR DETECTING
				:CALCULATED MAXIMUM VALUE OVER 16d RESETS###OAS
	IF	STRHUB
	LB	R2,LTYP,LN		:ONLY LAST STARLINK MAY INIT SIO
	JE	RSTSCC			: ##AL
	LHI	R0,SIORS-SEG1		:SEND OUT ONE RESET ONLY
	STH	R0,SIOTST,LN
	JFS	RSTSDD
	EI	:STRHUB
	IF	STRRMT
::For remote Starlines only one initial reset (33A0) should be sent at each
::30 second interval.  Then wait for Hub reset to be received.
	LB	R0,LTYP,LN		:For Starlines only
	JE	RSRM03
	SRLS	LN,1			:make line number
	SBT	LN,STRRES		:and set bit to indicate that an
	SLLS	LN,1			:initial reset (33A0) has been sent
	LHI	R0,SIORS-SEG1		:Then set up for next one
	JFS	RSRM04			:and store it
RSRM03	EI	:STRRMT			:###EV

RSTSCC	LHI	R0,SIORR-SEG1		:SIO OUTPUT STATE = SEND
RSRM04	STH	R0,SIOTST,LN		: CONTINUOUS RESETS		###OAS
RSTSDD	IF	SIBFRL			:###LSH
	L	R6,SIORSP,LN,LN		:SIO RESET POINTER
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R6,SIORSP,LN		:SIO RESET POINTER
	EI	:SIBFRL			:###LSH

	IF	STRHUB	
	LB	R7,LTYP,LN			:IF STR LINE
	JE	RSTS11

	L	R7,SKDPTR,LN,LN		:IF FROM DETLIN, ONLY WHEN CRSTKD
	L	R5,CRSTKD,R7		: IS ZERO
	JEFS	RSTSB0			:O.W. SEND RESET TO CRSTKD
	LR	KD,R5			:KEEP KD ##AL
	LIS	R0,0			:ZERO OUT CRSTKD
	ST	R0,CRSTKD,R7
	L	R5,LNKKEY,R5
	JFS	RSTS10			:COPY RESET BUF ##AL

RSTSB0	L	R5,LNKKEY,KD		:FROM DETLIN, KD IS VALID
RSTS10	ST	R5,XRSTP-4,R6		:HALF WORD OF KEY LOCATED
	SHI	R6,VSDSZ-6		:-offset for received Pattern Size
	L	R0,KDLN,LN,LN		:NO NEED FOR STAFLG IF STARLINE
	JLFS	RSTS12			: IS NOT ATTACHED ##AL
	LHI	R0,RSTSTA+RSTXFG	:SET RST STATE & XMIT BUF COPIED
	STB	R0,STAFLG,KD		: FLAG ##AL
	JFS	RSTS12	

RSTS11	EI	:STRHUB
	SHI	R6,VSDSZ-2		:-offset for received Pattern Size
RSTS12	JAL	R7,RSTORE		:+HW storage for SIO Reset Buffer Size
	LR	R1,LN
	SRLS	R1,1			:restore R1 = actual Line Number
	EI	:SILINS

RSTST2	RBT	R1,ALINES		:MARK THE LINE AS NO LONGER ACTIVE
	RBT	R1,INHRST		:MAKE SURE RESETS SEEN
	RBT	R1,LINATT		:END ATTACHING PROCESS
	LIS	R0,0			:RESET THE RESET COUNT
	STH	R0,RSCNT,SD
	STH	R0,RSTIM,SD
	JR	R9

	ELSE	:not XRESET
RSTSTR	HS	0
	LHL	SD,SDLN,LN		:PTR TO RESET BUFF
	LCS	R0,2			:SET RESET MODE FLAG
	ST	R0,KDLN,LN,LN
	L	R0,TTRSET		:SET THE INITIAL PATTERN
	ST	R0,XRSTP,SD
	L	R0,TTRSET+4
	ST	R0,XRSTP+4,SD
	LI	R0,((VERSION&0FFF)^10)!((@(VERSION&0FFF))&0FFFF)
	ST	R0,XRSTP+8,SD		:VERSION NUMBER AND ITS COMPLEMENT
	LIS	R0,4			:SET R0=RESET TRANSMIT HANDLER
	LHI	R3,0C			:SET R3=SIZE OF RESET IN BYTES
	LR	R1,LN
	SRHLS	R1,1

	IF	SILINS
	CLHI	R1,NLINES-SILINS-1	:SIO LINE?
	JLE	RSTST1			:NO - SKIP
	LR	R2,LN
	SHI	R2,(NLINES-SILINS)*2
	SLLS	R2,3			:COMPUTE RELATIVE SIO LINE NUMBER * 10
	LCS	R0,3			:INDICATE SIO LINE BEING RE-INITIALIZED
	STH	R0,SIOSTT+8,R2,		: DUE TO LINE GOING TO RESET STATE
	JAL	R10,SIOIZ0		:INITIALIZE SIO LINE
	LHL	SD,SDLN,LN		:RESTORE POINTER TO RESET BUFFER
	LR	R1,LN
	SRLS	R1,1			:RESTORE R1 = ACTUAL LINE NUMBER
	LIS	R0,0
	STH	R0,BAUDRT,LN,	:CLEAR LINESPEED FOR DETECTING CALCULATED
				:MAXIMUM VALUE OVER 16d RESETS		###OAS
	LHI	R0,SIORR-SEG1		:SIO OUTPUT STATE = SEND
	STH	R0,SIOTST,LN		:CONTINUOUS RESETS###OAS
	IF	SIBFRL			:###LSH
	L	R2,SIORSP,LN,LN		:TYMNET II RESET PATTERN
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R2,SIORSP,LN		:TYMNET II RESET PATTERN
	EI	:SIBFRL			:###LSH
	L	R0,TTRSET
	ST	R0,2,R2
	LI	R0,((VERSION&0FFF)^10)!((@(VERSION&0FFF))&0FFFF)
	ST	R0,6,R2		:APPEND VERSION NUMBER AND ITS COMPLEMENT
	J	RSTST2
	EI	:SILINS

	IF	ISIS
:	CONNECT SYNC LINE I/O, AND RAISE DTR AND RTS SIGNALS. FOR SOLO
:	NODE, DTR AND RTSND RTS HANDLED IN 'IZSYLL'.
RSTST1	HS	0
	LR	R2,LN		:GET LINE NUMBER * 2
	AR	R2,LN		:COMPUTE LINE NUMBER * 24 AS INDEX INTO
	AR	R2,LN		:	ROTOR LIST. THE ROTOR LIST HAS 3 8-BYTE
	SLLS	R2,2		:	COMMAND ENTRIES PER SYNC LINE.
	LA	R2,ROTOR,R2,	:R2 NOW POINTS TO ENTRY FOR THIS LINE
	LIS	R8,4		:COMMAND TO RAISE RTS
	STH	R8,0,R2
	LIS	R8,9		:COMMAND TO RAISE DTR
	STH	R8,8,R2
:	NOTE THAT THE THIRD COMMAND ENTRY IS 0 FOR STOP OUTPUT. EXPLICIT
:	STORE NOT NECESSARY SINCE SEG 0 INITIALIZED TO ZERO.
	SVC	IO,20+1		:PROCESS COMMANDS IN ROTOR (POINTED TO BY R2).
				:R1 = LOGICAL UNIT NUMBER (LINE NUMBER).
	JAL	R0,SVCE32	:ERROR, CRASH 
	LA	R2,XRSTP,SD	:POINT TO RESET TRANSMIT BUFFER
	SVC	IO,60		:T-II SYNC LINE CONNECT. R0=HANDLER CODE,
				: R1=LINE NUMBER, R2=BUFFER ADDRESS, R3=COUNT
	LHL	R2,SVBDIS,LN	:GET THIS LINE'S DISPLACEMENT INTO SYNC INPUT
	LA	R2,SVNTIP,R2,	:BUFFERS AND ADD TO BUFFER POOL START ADDRESS
	LHI	R3,SVNBSZ		:SYNC INPUT BUFFER SIZE
	SVC	IO,01			:CONNECT SYNC INPUT
	JAL	R0,SVCE30		:ERROR, CRASH
	ELSE	:NOT ISIS
RSTST1	HS	0
	LA	R2,XRSTP,SD		:POINT TO RESET TRANSMIT BUFFER
	SVC	0F,SV.CSY		:CONNECT SYNC INPUT AND OUTPUT. SAME
					: SETUP AS FOR ISIS 'SVC IO,60' ABOVE.
	EI	:ISIS
RSTST2	RBT	R1,ALINES		:MARK THE LINE AS NO LONGER ACTIVE
	RBT	R1,INHRST		:MAKE SURE RESETS SEEN
	RBT	R1,LINATT		:END ATTACHING PROCESS
	LIS	R0,0			:RESET THE RESET COUNT
	STH	R0,RSCNT,SD
	STH	R0,RSTIM,SD
	JR	R9
	EI	:XRESET	###wjl

	IF	ISIS
SVCE32	CRASH.(.SV32C,R5)
SVCE30	CRASH.(.SV30C,R5)
	EI	:ISIS

::*********************************************************************
::
::	SUBROUTINE:	RSTORE:
::	FUNCTION:	Stores Reset Pattern for Transmit
::	CALLING SEQ:	JAL	R7,RSTORE
::	INPUT:		R6 =Pointer to reset buffer
::	PRESERVED:	R6 - may be needed at ATTLD4
::	DESTROYED:	R0, R1, R2, R3
::	CALLS:		JAL	R5,CCKSUM
::
::*********************************************************************

	IF	XRESET			:###wjl

RSTORE	HS	0
	LHI	R0,TXRSHD		:set the initial pattern
	STH	R0,XRSTP,R6		:store Expanded Reset Header
	LI	R0,MACHNM
	ST	R0,XNDID,R6		:store Machine Number
	LHI	R0,(VERSION&0FFF)
	STH	R0,XVERNO,R6		:store VERSION
	LHL	R0,LNETID,LN,
	STH	R0,XNETID,R6		:store NETID
	LHI	R0,SUBNET
	STH	R0,XSUBNT,R6		:store SUBNET
	LIS	R0,8			:ATTLIN will fill in WSIZ
	STB	R0,XWSIZ,R6		:for TIILNK during ping-pong
	LR	R2,LN			:Line Number*2
	SRLS	R2,1			:actual Line Number
	STB	R2,XLINE,R6		:store Line Number
	LI	R0,HST0
	ST	R0,XHOST0,R6		:store Kernel Host Number
	LB	R0,RREASN,R2,		:**Reason for Reset to be
	STB	R0,XRSRSN,R6		:implemented later**
	LIS	R0,0			:ATTLIN will fill in TIILNK
	STB	R0,XKSPD,R6		:Capabilities during ping-pong
:	LIS	R0,0			:**Link Attributes to be
	ST	R0,XKATTR,R6		:implemented later**
	LI	R0,DIALUP		:**Dial-up Number to be
	ST	R0,XDIAL,R6		:implemented later**
	JAL	R5,CCKSUM		:calculate and store checksum
	JR	R7

	EI	:XRESET

::*********************************************************************
::
::	SUBROUTINE:	CCKSUM:
::	FUNCTION:	Calculate and store checksum for reset pattern
::	CALLING SEQ:	JAL	R5,CCKSUM
::	INPUT:		R6 = Pointer to reset buffer
::	DESTROYED:	R0, R1, R2, R3
::
::*********************************************************************

	IF	XRESET

CCKSUM	HS	0			:SET UP FOR CKSUM
	LI	R0,-VSDSZ		:negative byte count in R0
	LA	R1,XRSTP,R6		: starting address
	LIS	R2,0			: clear accumulators
	LIS	R3,0			: for CKSUM instruction
	CKSUM	R2,R1			:calculate checksum
	STH	R2,XCKSUM,R6		:store vertical checksum
	STH	R3,XCKSUM+2,R6		:store diagonal checksum
	JR	R5

	EI	:XRESET

::*********************************************************************
::
::	SUBROUTINE:	KSPEED:
::	FUNCTION:	Computes the speed of a given link from the
::			speed of its attached lines.
::	CALLING SEQ:	JAL	R10,KSPEED
::
::*********************************************************************

:	THIS ROUTINE REWRITTEN TO CORRECT A BUG FROM VERSION 4.	###jhl 4/83
:	LOGIC CHANGED TO AVOID MISCONFIGURATION  		###OAS 2/83

KSPEED	HS	0
KSPEE0	LIS	R0,0			:INITIALIZE CUMULATIVE SPEED COUNTER
:	LHI	R1,2*NLINES-2		:COUNT BACKWARDS THROUGH THE LINES
	LI	R1,2*NLINES-2		:COUNT BACKWARDS THROUGH THE LINES
	IF	STRHUB!STRRMT
	LB	R3,LTYP,LN		:FOR STARLINE KSPD IS FIX	###AL
	JE	KSPEE1
	L	R3,KDLN,LN,LN		:IS THE LINE ATTACHED TO THIS LINK?
	JL	KSPE33			:NOT ATTACHED, RPT AS FROZEN
	AH	R0,BAUDRT,LN,		:ELSE ADD IN THE LINE SPEED
	J	KSPE33			:IF STAR LINE UP ALWAYS CALCULATE
	EI	:STRHUB
KSPEE1	L	R3,KDLN,R1,R1		:IS THE LINE ATTACHED TO THIS LINK?
	CR	R3,KD
	JNFS	KSPEE3			:IF NOT, GET PREVIOUS LINE
	AH	R0,BAUDRT,R1,		:ELSE ADD IN THE LINE SPEED
KSPEE3	SIS	R1,2			:STEP BACK TO PREVIOUS LINE
	JGEBS	KSPEE1			:LOOP AS LONG AS THERE ARE LINES
KSPE33
	CLHI	R0,1F			:HAS ACCUMULATED SPEED OVERFLOWED?
	JLFS	KSPEE4			:NO--IT'S OK
	LHI	R0,1F			:ELSE SET IT TO MAX
KSPEE4	LB	R1,LKNM,KD		:GET THE LINK NUMBER SET UP
	CLHI	R0,HISPD		:IF HIGH SPD, CHECK TYMFILE	###wjl
	JL	KSPEE5			:OTHERWISE USE ACCUMULATED SPEED

:	IF LINK SPEED ADDS UP TO BE HIGH SPEED (>19.2KB)
:	CHECK TYMFILE TO SEE IF CONFIGURED LINK SPEED SPECIFIED.
:	IF SO USE SPEC, IF NOT USE CALCULATED VALUE.

	TBT	R1,KNCNSP,,		:WAS LINK SPD SPEC IN TYMFILE?
	JEFS	KSPEE5			:NO.  USE CALCULATED SPEED.
	LB	R3,KNSAT,R1		:GET BYTE SET UP AT ASSEMBLY TIME
	STB	R3,KSPD,KD		:AND USE THAT FOR OUR KSPD BYTE
	JR	R10			:RETURN TO CALLER

:	SPEED NOT SPECIFIED IN TYMFILE.  USE THE CALCULATED LINK SPEED.
:	RESTORE PROPER BITS WITH RESPECT TO SAT AND TI WS 8.

KSPEE5	LB	R3,KNSAT,R1		:GET KSAT<LINK #>
	NHI	R3,0E0			:STRIP SPEED BITS
	OR	R0,R3			:MIX FLAGS AND SPEED
	STB	R0,KSPD,KD		:STORE IN LINK DESCRIPTOR
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	LSPEEZ:
::	FUNCTION:	Initializes input pointers for line speed calculations
::	CALLING SEQ:	JAL	R8,LSPEEZ
::	INPUT:		R13 = Bit array for sync lines requesting line
::				speed computation
::
::*********************************************************************

LSPEEZ	HS	0
	JFFO	R13,LSPEZ1		:YIELDS LINE NO. IN R14 (LN)
	JR	R8			:ALL DONE
LSPEZ1	HS	0
	SLLS	LN,1			:2 * LINE NO.
	LHL	R3,SVBDIS,LN		:COMPUTE <POSITION>
	LH	R3,SVNTIP,R3,
	STH	R3,LNRPOS,LN,		:UPDATE POSITION
	X	R13,WMSK,LN,LN		:TURN OFF THAT BIT
	GL	WMSK
	J	LSPEEZ			:DO NEXT ONE

::*********************************************************************
::
::	SUBROUTINE:	LSPEED:
::	FUNCTION:	Computes speed of line from the rate at which
::			data is being received at the interrupt buffers.
::	CALLING SEQ:	JAL	R8,LSPEED
::	INPUT:		R13 = bit array of lines requesting speed calculation
::			R4  =  FASTC interval to measure over
::
::*********************************************************************

LSPEED	HS	0
	JFFO	R13,LSPEE1		:YIELDS LINE NO. IN R14 (LN)
	ST	R13,LINSPD		:RESET LINE SPEED REQUEST BITS
	JR	R8			:ALL DONE
LSPEE1	HS	0
	SLLS	LN,1			:2 * LINE NO.
	LHL	R3,SVBDIS,LN		:COMPUTE <DELTA POSITION>
	LH	R2,SVNTIP,R3,
	LH	R3,LNRPOS,LN,
	STH	R2,LNRPOS,LN,		:UPDATE POSITION
	SR	R2,R3
	JGFS	LSPEE3
	AHI	R2,SVNBSZ
LSPEE3	SLLS	R2,2			:TIMES 4
	DHR	R2,R4
	CLHI	R3,0F			:DON'T LET IT OVERFLOW
	JLEFS	LSPEE2			:O.K.
	LIS	R3,0F			:MAX VALUE...
LSPEE2	LB	R3,LSPEET,R3
	STH	R3,BAUDRT,LN,
	X	R13,WMSK,LN,LN		:RESET THAT BIT
	J	LSPEED			:DO NEXT ONE

LSPEET	BC	1,1,1,2,2,2,3,4,4,4,6,6,6,8,8,8	:ADD 14.4 		###OAS

::*********************************************************************
::
::	SUBROUTINE:	LNKCON:
::	FUNCTION:	Consistency check for line and link fields.
::	CALLING SEQ:	JAL	R11,LNKCON
::	INPUT:		KD = Expects valid linK Descriptor
::	DESTROYED:	R12, R13, R14 (LN)
::
::*********************************************************************

:	ALL LINE FIELDS ARE EXAMINED FOR INDICATIONS OF BEING ATTACHED
:	TO THE LINK LAST OPERATED ON (THE CALLING ROUTINE PASSES A
:	VALID LINK DESCRIPTOR INDEX).  THE LINK DESCRIPTOR VALUES ARE
:	COMPARED TO THE	CUMULATIVE LINE FIELD VALUES, AND THE NODE IS
:	CRASHED IF AN INCONSISTENCY IS DISCOVERED.

	IF	DB.TSN

LNKCON	HS	0
	IF	STRHUB
	LB	R12,LTYP,LN,		:NO LNKCON CHECK FOR STAR LN/LK
	JEFS	LNKCA			:##AL
	JR	R11
LNKCA	EI	:STRHUB
	LIS	R12,0		:R12 COUNTS THE NUMBER OF LINES ASSOCIATED
				:	WITH THIS LINK.
	LHI	LN,(NLINES-1)*2		:SCAN ALL LINES
LNKC10	LH	R13,NGSVLN,LN,		:GET NEIGHBOR NUMBER FOR LINE
	JGE	LNKC20			:HI-ORDER BIT SHOULD BE SET FOR
	NHI	R13,7FFF		: ATTACHED LINE
	CLH	R13,NDID,KD		:LINE NEIGHBOR # = LINK NEIGHBOR #?
	JN	LNKC20			:NO - THIS LINE ATTACHED TO DIFFERENT
					:  LINK
	LR	R13,LN
	SRLS	R13,1			:GET ACTUAL LINE NUMBER
	TBT	R13,ALINES		:IS LINE MARKED AS ACTIVE?
	JE	OP1663			:NO - IT SHOULD BE ACTIVE

	SLL	LN,1
	L	R13,KDSVLN,LN,		:COMPARE KD TO THIS LINE'S KDSVLN
	SRL	LN,1
	CLR	R13,KD			:EQUAL?
	JN	OP1463			:NO - CRASH...

	AIS	R12,1			:INCREMENT COUNT OF LINES ATTACHED TO
					: LINK
LNKC20	SIS	LN,2			:CHECK ALL LINES
	JGE	LNKC10

:	ALL LINES SCANNED. NOW VERIFY THAT TOTAL NUMBER OF LINES
:	DISCOVERED EQUALS 'NLAT' LINK COUNT, AND THAT LINK IS ACTIVE IF
:	NLAT > 0.  
	LB	R13,NLAT,KD		:LINK FIELD FOR # OF LINES ATTACHED
	CLR	R13,R12			:COMPARE TO SUM OF LINE FIELDS FOR LINK
	JN	OP1863			:NOT EQUAL - CRASH

	LB	R13,LKNM,KD		:GET LINK NUMBER
	TBT	R13,ALINKS		:IS LINK ACTIVE?
	JNFS	LNKC30			:YES
	LR	R12,R12			:NO - NUMBER OF LINES SHOULD EQUAL 0
	JER	R11			:O.K.
	TBT	R13,BORZAP		:DON'T CRASH IF LINK BORI-ZAPPED...
	JNR	R11
	CRASH.(.LKER0,R0)
LNKC30	LR	R12,R12			:ACTIVE LINK SHOULD HAVE # OF LINES > 0
	JNR	R11			:O.K.

OP1263	CRASH.(.O1263,R0)
OP1463	CRASH.(.O1463,R0)
OP1663	CRASH.(.O1663,R0)
OP1863	CRASH.(.O1863,R0)

	EI	:DB.TSN

	IF	SILINS	:For SIO line only
::*********************************************************************
::
::	SUBROUTINE:	SIPKSV:			###AL
::	FUNCTION:	Save SIO line bad packets received 
::	CALLING SEQ:	JAL	R9,SIPKSV
::	INPUT:		R11,R13 are pointers for SIBUF, LN(R14) is line#
::	DESTROYED:	R0,R8
::
::*********************************************************************
SIPKSV	HS	0
	PUSH(R3)
	PUSH(R6)
	LHL	R3,PSLNUM	:CHECK IF SWITCH TURN-ON
	JL	SIPKS3		:SKIP IF NOT
	AR	R3,R3		:2*LINE#
	CR	R3,LN		:SKIP IF NOT THE LINE IN INTEREST
	JN	SIPKS3
	LHL	R3,PKSVCT	:NUMBER OF BYTES ALREADY SAVED
	CLHI	R3,PKSVSZ	:WRAP IF FULL
	JLFS	SIPKS1
	LIS	R3,0
SIPKS1	LR	R6,R11		:KEEP R11
	LR	R8,R3		:USE R8
	AHI	R8,PKSVLH-4	:TOTAL LENTH OF SAVING EXCEPT LAST 4
SIPKS2	L	R0,SIBUF,R6,R13
	ST	R0,PAKSAV,R3,
	AIS	R6,4		:4 MORE BYTES
	AIS	R3,4
	CR	R3,R8		:END OF THE PACK SAVE LENGTH?
	JL	SIPKS2
	ST	R9,PAKSAV,R3,	:SAVE CALLER ADDRESS IN THE LAST WORD
	AIS	R3,4		:INCREASE COUNT TO MEET 20X BYTES EA. PACKET
	STH	R3,PKSVCT
SIPKS3
	POP(R6)
	POP(R3)
	JR	R9
	EI	:SILINS

	SUBTTL	LINKER (SYLVER - Dispatcher for input on sync lines)

::*********************************************************************
::
::	PROCESS:	SYLVER:
::	FUNCTION:	Sync and SIO data handlers
::	CALLING SEQ:	SYLVER IS SCHEDULED TO BE RUN EACH 16 MILLISECONDS
::	OR EACH TIME THROUGH THE EXEC LOOP -- WHICHEVER IS MORE FREQUENT.
::
::		A SET OF ROUTINES PROCESS THE DATA RECEIVED ON THE NETWORK
::	SYNC LINES, MOVE THE DATA FROM THE INPUT RINGS TO SECTOR BUFFERS,
::	ALIGN THE DATA, PERFORM CHECKSUMMING, AND HANDLE SEQUENCING AND
::	ACKNOWLEDGING PACKETS.  EACH LINE 'CONTROL BLOCK' CONTAINS THE ADDRESS
::	OF THE CURRENTLY ACTIVE 'ROUTINE' AT QSYLVER.
::	THERE ARE THREE POSSIBLE ENTRY POINTS:
::	SYLMRK -- SEARCH FOR START BIT (BORI)
::	SYWAIT -- WAITING FOR RECEPTION OF COMPLETE DATA RECORD
::	SYLDWT -- WAITING FOR RECEPTION OF COMPLETE DOWNLINE LOAD RECORD
::
::		Then fall through to process I/O on SIO lines (if any).
::	
::	REGISTER USAGE:
::	R0  -- WORK REGISTER
::	R1  -- WORK REGISTER
::	R11 -- INPUT DATA LEAD POINTER
::	R12 -- INPUT DATA TRAILING POINTER
::	R13 -- INPUT RING ADDRESS
::	R14 -- LINE NUMBER X 2
::	R15 -- LINK DESCRIPTOR ADDRESS
::
::	CALLS:	JAL	R8,LSPEEZ
::
::*********************************************************************

SYLVER	HS	0			:IF ISIS, THIS IS FOREGROUND
	IF	1-ISIS
	IF	DB.CPU
:	FOR ISIS SYLVER MEASURES ITSELF INDEPENDENT OF THE BACKGROUND PROCESSES
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(SYLVER)			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU

	LI	R0,SYLMAC		:SET UP ERROR-RETURN ADDRESS FOR MAC
	ST	R0,ABENPC

	ELSE	:1-ISIS			:SYLVER MEASURES ITS OWN CPUTIL
	IF	DB.CPU
	GL	CSYTCT
	IF	DB.CLK
	GL	CSYTFC,CSYTSC,CSYTTM,CSYFRC
	L	R0,FASTC,,		:GET CURRENT TIME
	ST	R0,CSYTFC,,		:SAVE FOR SYLVER DURATION CALCULATION
	LHL	R1,LO.CLK,,		:GET SEGF RELATIVE POINTER TO SLOT0 CLK
	LHL	R0,SEGF,R1,		:GET SLOT0 CLOCK
	STH	R0,CSYTSC,,		:SAVE SLOT0 CLOCK
	EI	:DB.CLK
	EI	:DB.CPU
	EI	:1-ISIS

:	ASSEMBLE ONLY IF THERE ARE HIGH SPEED SIO LINES

	IF	SCHFAS
	LHI	LN,(NLINES-SCHFAS)*2
	LIS	R0,1
	AHM	R0,SCHCNT
	JL	SIO1
	LCS	R0,5
	STH	R0,SCHCNT
	EI	:SCHFAS

:	RECORD INTERVAL BETWEEN SYLVER EXECUTIONS IN HISTOGRAM AND TEST
:	FOR NEW SYLVER INTERVAL HIGH-WATER MARK.
	LIS	R0,1
	AHM	R0,SYLXEC		:INCREMENT COUNT OF SYLVER ECECUTIONS
	L	R2,FASTC,,
	LR	R1,R2
	S	R2,SYLTIM		:COMPUTE TIME SINCE SYLVER LAST RAN
	ST	R1,SYLTIM		: AND SAVE CURRENT FASTC FOR NEXT TIME
	JL	SYLV00			:IF FASTC WRAP, SKIP, DON'T CRASH!
	LR	R4,R2			:SAVE SYLVER INTERVAL:*Z
	CLH	R2,SYLHWM		:DOES SYLVER INTERVAL EXCEED PREVIOUS
					:	HIGH-WATER MARK?
	JLEFS	SYLT10			:NO
	STH	R2,SYLHWM		:YES - SAVE
SYLT10	CLHI	R2,SYLHSZ/4		:HISTOGRAM SIZE EXCEEDED?
	JLFS	SYLT20			:NO
	LHI	R2,SYLHSZ/4-1		:YES - SET TO MAX SIZE
SYLT20	LIS	R3,1
	SLLS	R2,2			:*4, MAKE HISTOGRAM INDEX
	AM	R3,SYLHGM,R2,		:RECORD SYLVER INTERVAL IN HISTOGRAM

SYLS00	HS	0		:COMPUTE LINE SPEED FOR ANY LINES REQUESTED
	L	R13,LINSPD	:BIT SET IN LINSPD EVERY SEC FOR EACH SYNC LINE
				: WHICH HAS RECEIVED 2 GOOD RESETS
	JE	SYLV00			:NONE
	LH	R3,SYLINT		:HAVE WE GOT A GOOD INTERVAL,15-100 MS?
	JL	SYLS03			:NOPE, HAVEN'T EVEN STARTED YET.
	AH	R4,SYLINT		:SEE IF WE'VE GOT A GOOD INTERVAL
	CLHI	R4,9			:MUST BE < 15 MS
	JLFS	SYLS02
	CLHI	R4,3C			:MUST BE < 100 MS
	JGEFS	SYLS03
	JAL	R8,LSPEED		:OK, GO MEASURE
	TS	SYLINT			:INDICATE NO MEASUREMENT IN PROGRESS
	JFS	SYLV00

SYLS02	HS	0			:NOT ENOUGH YET
	STH	R4,SYLINT		:TRY AGAIN NEXT TIME
	JFS	SYLV00

SYLS03	HS	0			:TOO MUCH OR JUST STARTING
	LIS	R4,0			:START OVER
	STH	R4,SYLINT
	JAL	R8,LSPEEZ		:INITIALIZE INPUT POINTER POSITIONS

SYLV00	HS	0
	LHI	LN,(NLINES-SILINS-1)*2	:PROCESS ALL SYNC LINES
	IF	SILINS
	JL	SYLRTX			:NO SYNC LINES CONFIGURED (ALL SIO)
	ELSE	:SILINS			:CHECK IF NO LINES AT ALL	###OAS
	JL	SDSMIS			:NO LINES AT ALL, SIMPLY DISMISS###OAS
	EI	:SILINS

SYLV01	HS	0
	LHL	R13,SVBDIS,LN		:RELATIVE START OF INPUT RING
	LHL	R11,SVNTIP,R13,		:RAW DATA LEAD POINTER
	LA	R13,SVNTBF,R13,		:INPUT RING FULL ADDRESS
	LHL	R12,SVNTOP,LN		:INPUT DATA TRAIL POINTER
	LHL	R1,QSYLVR,LN		:GET ROUTINE ADDRESS
	J	SEG1,R1,,		:GO TO IT

:	GENERAL EXIT POINT FOR SYNC LINE INPUT PROCESSOR. LOOP
:	BACK IF THERE ARE MORE SYNC LINES, OR ELSE FALL THROUGH
:	TO PROCESS I/O ON SIO LINES (IF ANY)

SYLRET	STH	R12,SVNTOP,LN		:SAVE TRAIL POINTER
	SIS	LN,2			:TRY NEXT LINE
	JGE	SYLV01			:LOOP BACK IF THERE IS A NEXT LINE

	SUBTTL	LINKER (SYLVER - SIO input processor)

::*********************************************************************
::
::	ROUTINE:	SYLRTX:
::	FUNCTION:	SCAN FOR INPUT AND OUTPUT TASKS TO BE PERFORMED
::			ON ALL SIO LINES.
::	CALLING SEQ:	Fall through from SYLVER loop above.  DO ALL INPUT
::	FOR A GIVEN LINE (UNTIL BYTE COUNT IS NEGATIVE), THEN DISPATCH TO
::	OUTPUT STATE (SIOUT) TO SEE WHAT THERE IS TO DO.
::	CALLS:		JAL	R9,NETDGN
::			JAL	R0,TSFMRK
::			JAL	R8,TSNSPK
::			JAL	R2,TSFUAL
::	RETURNS:	JL	SIOUT
::
::*********************************************************************

	IF	SILINS

SYLRTX	HS	0
	LHI	LN,(NLINES-SILINS)*2	:PROCESS ALL SIO LINES, FROM TOP DOWN
SIO1	LHL	R13,SIBUFP,LN		:GET POINTER TO INPUT BUFFER
	LH	R11,SIBUFN,LN		:OFFSET OF NEXT EXPECTED RECORD

SIOI1
	LH	R10,SIBUF,R13,R11	:GET THE BYTE COUNT
	JL	SIOUT			:NOT ALL IN YET IF NEG
	JE	SIOBER			:ERROR IF ZERO

	IF	STRHUB			:			###LSH
	LB	R0,LTYP,LN		:STAR LINE ?
	JE	SII11			:NO
	CLHI	R10,88			:SIO BOARD BYTE CT INCLUDES KEY
	JG	SIOBER			:GREATER THAN MAX RECORD SIZE
	CLHI	R10,4			:BYTE COUNT SHOULD GREATER THAN 4
	JLE	SIOBER			:			###LSH
	LB	R0,SIBUF+6,R11,R13	:IF FIRST BYTE OF DATA IS ZERO
	JE	SIOI2			:GARBAGE RECEIVED
	J	SII12			:COMPLETE RECORD RECEIVED
SII11	EI	:STRHUB
					:REGULAR SIO LINE
	CLHI	R10,84			:GREATER THAN MAX RECORD SIZE?
	JG	SIOBER			:YES - ERROR
	LB	R0,SIBUF+2,R11,R13	:IF FIRST BYTE OF DATA IS ZERO
	JE	SIOI2			:GARBAGE RECEIVED

:	COMPLETE RECORD RECEIVED
:	FIRST SEE IF THIS SIO LINE IS BEING USED FOR A DOWNLINE LOAD

SII12	TBT	LN,DWLDSP,,		:IS LN ON DWL LIST?
	JN	SIODWL			:YES, BRANCH AWAY TO SERVICE
:					:###LSH
:	FOR STARLINE, NEED TO CHECK IF IT IS SUBSEQUENT STARLINK
:	DOWN LINK LOAD.  DO NOT NEED TO CHECK CHECKSUM IF IT IS
:	DOWN LINK LOAD.
	LR	R0,R10			:R0= BYTE COUNT	###LSH
	IF	STRHUB	
	LB	R1,LTYP,LN		:STAR LINE ?
	JE	SIIX1			:NO
	LHL	R1,SIBUF+6,R11,R13	:GET RECORD HEADER
	CLHI	R1,DWNLHD		:IS IT A DOWN LINE LOAD HEADER?
	JE	SIOI4			:YES, DO NOT NEED CHECK CHECKSUM

:	NOT A DWL LINE

	SIS	R0,4			:SUBTRACT 4 BYTES OF KEY
	EI	:STRHUB			:###LSH
					:REGULAR LINE
SIIX1	LIS	R1,7			:FIND RECORD SIZE MOD 8
	NR	R1,R0			:ZERO MOD8 MEANS SOFTWARE ###LSH
	JE	SIOI3			:CHECKSUMS RECEIVED
	SIS	R1,4			:FOUR MOD8 MEANS NO SOFTWARE
	JE	SIOI4			:CHECKSUMS

SII16	LIS	R0,1			:BAD RECORD SIZE -- NOTE IT
	AHM	R0,SIOBRS
	JAL	R9,SIPKSV		:SAVE 28 BYTES OF THIS BAK PACKET

:	RE-INITIALIZE SIO INTERFACE IF BAD RECORD SIZE...
:	SETTING SIOSTT+8 TO NON-ZERO VALUE CAUSES SIOIZ TO INITIALIZE.
:	NOTE--SIOIZ IS CALLED FROM THE TWO SECOND LOGIC.

SIORIN	HS	0
	LR	R9,LN
	SHI	R9,(NLINES-SILINS)*2	:GET RELATIVE (SIO LINE NUMBER)*10
	SLLS	R9,3
	TS	SIOSTT+8,R9,		:-1 INDICATES SOFTWARE INITIALIZATION

:	ADVANCE TO NEXT RECORD

SIOI2	LCS	R0,1			:CLEAR COUNT IN CASE FIRST 1/2
	STH	R0,SIBUF,R13,R11	:	WORD IN BUFFER
	AR	R11,R10			:ADVANCE INPUT INDEX
	AIS	R11,3			
	NHI	R11,7FFE		:ALIGN TO HALFWORD BOUNDARY
	IF	STRHUB
	LB	R0,LTYP,LN
	JEFS	SII22
	CLHI	R11,SIBFSZ-88+20	:ROOM FOR ANOTHER RECORD?
					:SIBFSZ+20 FOR STAR LINE ##AL
	JFS	SII23
SII22	EI	:STRHUB
	CLHI	R11,SIBFSZ-84		:ROOM FOR ANOTHER RECORD?
SII23	JLFS	SIOI25			:YES, SKIP
	LIS	R11,0			:NO, GO BACK TO BEGINNING
SIOI25	STH	R11,SIBUFN,LN
	J	SIOI1

:	ERROR DETECTED IN FIRST HALFWORD OF SIO BUFFER - COUNT TOO LARGE
:	OR ZERO. INCREMENT ERROR COUNT, SAVE SOME REGISTERS.

SIOBER	HS	0
	LH	R7,SIOECT
	AIS	R7,1			:INCREMENT COUNT OF BUFFER ERRORS
	STH	R7,SIOECT

	NHI	R7,3			:ERROR COUNT MOD 4 TIMES 32 YIELDS
	SLLS	R7,5			:	REGISTER SAVE INDEX
:	SET UP R8 AND R9 TO CONTAIN FIRST 8 BYTES OF SIO BUFFER. NOTE
:	THAT THE LO-ORDER HW OF R10 FETCHES THE SAME MEMORY AS THE
:	HI-ORDER W OF R8, AND SHOULD BE THE SAME.
	L	R8,SIBUF,R11,R13
	L	R9,SIBUF+4,R11,R13
	STM	R8,SIEREG,R7		:SAVE USEFUL DATA

:	FORMAT DIAGNOSTIC NODE REPORT AND CRYPTOGRAM
	IF	ISIS
:	DON'T CALL NETDGN FROM HERE SINCE WE ARE IN FOREGROUND. FORMAT
:	MESSAGE IN SUPIBF, WITH FIRST HALFWORD USED AS SEMAPHORE FOR
:	SWITCH.  
	STB	LN,SUPIBF+3		:SAVE LINE NUMBER*2
	OHI	R10,8000
	STH	R10,SUPIBF+4		:REPORT BAD COUNT IN BUFFER###sn###wjl
	LIS	R8,DR.SIO
	STB	R8,SUPIBF+2		:DIAGNOSTIC SUB-TYPE FOR SIO ERROR
	STH	R8,SUPIBF		:ALERT SWITCH THAT NODE REPORT WAITING
	ELSE	:NOT ISIS
	STB	LN,SUPMBF+3		:SAVE LINE NUMBER*2
	OHI	R10,8000
	STH	R10,SUPMBF+4		:STORE BAD COUNT
	LIS	R8,DR.SIO		:GET DIAGNOSTIC SUB-TYPE
	JAL	R9,NETDGN,,		:FORMAT CRYPTOGRAM, NODE REPORT
	GL	NETDGN
	EI	:ISIS

	J	SIOI2			:GO RE-INITIALIZE SIO HARDWARE

:	COME HERE TO CHECK SOFTWARE CHECKSUMS

SIOI3	HS	0
	LIS	R2,0			:CLEAR ACCUMULATORS	###LSH
	LIS	R3,0
	IF	STRHUB
	LB	R1,LTYP,LN		:STAR LINE ?
	JE	SIIX2			:NO
					:STAR LINE		###LSH
	LIS	R0,8			:NEGATIVE BYTE COUNT IN R0 ###LSH
	SR	R0,R10			:DON'T INCLUDE CKSUM AND KEY
	LA	R9,SIBUF+6,R13,R11	:POINT TO BEGINNING OF DATA
				 	:OFF 4 BYTES OF KEY ###LSH
	LR	R1,R9			:VERS 18 MICROCODE SMASHES R2 OF CKSUM
	CKSUM	R2,R1			:CKSUM PACKET, STARTING AT R1 ADDRESS
	XH	R2,-8,R10,R9		:COMPARE CALCULATED AND RECEIVED
	XH	R3,-6,R10,R9		:CHECKSUMS		###LSH
					:R9 POINT TO BEGINNING OD DATA, OFF
					:4 BYTES OF KEY. R10 IS BYTE COUNT
					:INCLUDE KEY, SO NEED TO SUBTRACT
					:ANOTHER 4 BYTES
	J	SIIX3
SIIX2	EI	:STRHUB
					:REGULAR LINE		###LSH
	LIS	R0,4			:NEGATIVE BYTE COUNT IN R0
	SR	R0,R10
	LA	R9,SIBUF+2,R13,R11	:POINT TO BEGINNING OF DATA
	LR	R1,R9			:VERS 18 MICROCODE SMASHES R2 OF CKSUM
	CKSUM	R2,R1			:CKSUM PACKET, STARTING AT R1 ADDRESS
	XH	R2,-4,R10,R9		:COMPARE CALCULATED AND RECEIVED
	XH	R3,-2,R10,R9		:CHECKSUMS

SIIX3	OR	R3,R2
:	CHVR	R2,R2
	LHR	R3,R3			:###LSH
	JE	SIOI4			:GOOD CHECKSUM...

	LIS	R0,1			:SIO CARD SLIPPED US A BAD ONE
	AHM	R0,SIOBCS
	AHM	R0,BADCSM,LN,		:RECORD BAD CHECKSUM

	IF	TSTSZE			:IF SYNC TRACING ENABLED
	L	KD,KDLN,LN,LN		:LINK DESCRIPTOR ADDRESS
	JL	TSLB15			:UNASSIGNED LINE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB15			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	IF	STRHUB
	LB	R0,LTYP,LN		:STAR LINE ?
	JEFS	SIIX4			:NO
	LHL	R4,SIBUF+6,R11,R13	:GET RECORD HEADER IN R4###LSH
	LB	R0,SIBUF+8,R11,R13	:GET RECORD NUMBER 	###LSH
	JFS	SIIX5
SIIX4	EI	:STRHUB
	LHL	R4,SIBUF+2,R11,R13	:GET RECORD HEADER IN R4
	LB	R0,SIBUF+4,R11,R13	:GET RECORD NUMBER
SIIX5	LH	R2,LAS,KD
	SHI	R2,07F
	SR	R0,R2			:GET CURRENT 1/2 WORD
	LBR	R0,R0			:	RECORD NUMBER TO R2
	AR	R2,R0
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.CSE
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (CHECKSUM ERROR)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB15	EI	:TSTSZE

	J	SIOI2			:###LSH

:	RECORD RECEIVED WITH GOOD CHECKSUM -- SEE WHAT IT CONTAINS

SIOI4	IF	STRHUB			:		
	LB	R8,LTYP,LN		:STAR LINE ?
	JE	SII41
					:STAR LINE
	LHL	R4,SIBUF+6,R11,R13	:GET RECORD HEADER IN R4
	L	KD,KDLN,LN,LN		:LINK DESCRIPTOR ADDRESS
	JL	SILUAL			:HANDLE RECORD ON UNASSIGNED LINE
	L	R1,SIBUF+2,R11,R13	:GET LNK KEY
	LR	R5,KD			:R5=STARLINK CHAIN DESCRIPTOR PTR
	JAL	R8,KYMTKD		:MATCH KEY & FIND KD
	GL	KYMTKD
	J	SIOI2			:NO KEY MATCHED, THROW AWAY
	J	SI41			:KEY MATCHED, GO AHEAD
SII41	EI	:STRHUB	
	IF	RBTRMT:STRRMT
	LB	R0,LTYP,LN		:STARLINE ONLY
	JE	SII412
	L	R4,SIBUF+2,R11,R13	:GET FW RECORD HEADER IN R4
	LR	R0,R4			:IS IT RMT-BOOT/RESTART CMD?	###AL
	EXHR	R0,R0
	NI	R0,0FFFF		:MASK OUT HO HW
	CHI	R0,RBOTHD
	JN	SII412
	LHL	R0,TVRSUP		:IS THE NODE IN THE NETWORK?
	JLE	SII411
	LR	R0,R4			:LO HW WILL BE THE SENDER'S NBR#
	JAL	R8,CRYPTO
	HC	CRYE7C
	J	SIOI2
SII411	LHI	R0,-2
	STH	R0,DLDFLG		:SET DLDFLG TO -2 WILL BOOT IN 4 SEC.
	J	SIOI2
SII412	EI	:RBTRMT:STRRMT
					:REGULAR LINE
	LHL	R4,SIBUF+2,R11,R13	:GET RECORD HEADER IN R4
	L	KD,KDLN,LN,LN		:LINK DESCRIPTOR ADDRESS
	JL	SILUAL			:HANDLE RECORD ON UNASSIGNED LINE

SI41	EXBR	R0,R4			:ISOLATE BORI
	NHI	R0,0F0
	CLB	R0,BORI,KD		:GOOD BORI?
	JN	SIOI7			:NO

	EXBR	R1,R4			:GET BYTE COUNT
	NHI	R1,0F			:	VIA TABLE LOOKUP
	LB	R1,SYTWCN,R1
	LR	R0,R10			:COMPARE RECEIVED RECORD SIZE
	SR	R0,R1			:	AGAINST EXPECTED SIZE
	JEFS	SIOI41
	IF	STRHUB			:			###LSH
	LB	R8,LTYP,LN		:STAR LINE ?
	JEFS	SI411
					:STAR LINE, ALLOW FOR SOFTWARE
	SIS	R0,8			:CHECKSUM AND KEY
	JEFS	SIOI41			:SKIP IF VALID COUNT
	J	SI422			:INC BAD SIZE COUNTER
SI411	EI	:STRHUB
					:REGULAR LINE
	SIS	R0,4			:ALLOW FOR SOFTWARE CHECKSUMS
	JEFS	SIOI41			:SKIP IF VALID COUNTT

					
SI422	LIS	R0,1			:INC BAD SIZE COUNTER
	AHM	R0,SIOMIS
	J	SIOI2

SIOI41	IF	STRHUB
	LB	R8,LTYP,LN		:STAR LINE ?
	JEFS	SII41A
	LB	R0,SIBUF+8,R11,R13	:GET RECORD NUMBER
	JFS	SI42
SII41A	EI	:STRHUB
	LB	R0,SIBUF+4,R11,R13	:GET RECORD NUMBER
SI42	LH	R2,LAS,KD
	SHI	R2,07F
	SR	R0,R2			:GET CURRENT 1/2 WORD 
	LBR	R0,R0			:	RECORD NUMBER TO R2
	AR	R2,R0
	LB	R5,WSIZ,KD		:GET NUMBER OF SECTORS
	LHL	R6,ISEC,KD		:SECTOR 0 DESCRIPTOR ADDRESS
	LR	R0,R2
	SH	R0,RECN,R6		:DISTANCE TO SECTOR 0
	CHVR	R0,R0
	JGEFS	SIOI45			:AHEAD OF SECTOR 0
	AR	R0,R5			:ADJUST FOR WRAP AROUND
SIOI45	CR	R0,R5			:TOO FAR AHEAD?
	JLFS	SIOI46			:NO
	SR	R0,R5			:YES, BACK UP

SIOI46	MH	R0,CCDSZ		:GET RELATIVE SECTOR ADDRESS
	AR	R6,R0			:CORRECT SECTOR DESC ADDR TO R6
	LR	R0,R2			:MOVE REC # TO R0
	SH	R0,LRT,KD		:IS THIS REC # .LE. LAST REC TORN?
	CHVR	R0,R0
	JLE	SIOI6			:YES, THIS REC IS A RETRANSMISSION

	CR	R0,R5			:IS REC # .LE. LRT + WSIZ?
	JLE	SIOI5			:YES, OK

:	BAD RECORD NUMBER RECEIVED

SRXB00	LB	R0,NLAT,KD		:IF MULTIPLE-LINE LINK, DON'T COUNT
	CLHI	R0,1			:	BAD RECORD NUMBER...
	JNFS	SIOI48
	AHM	R0,BADRCN,LN,		:INC BAD RECORD COUNTER
	JAL	R9,SIPKSV		:SAVE THIS BAD PACKET ##AL

SIOI48	IF	TSTSZE			:IF SYNC EVENT TRACING ENABLED
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB14			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BRN
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD RECORD NUMBER)
	STH	R4,TSFTBL+2,R15		:STORE RECORD HEADER
	STB	R2,TSFTBL+4,R15		:	AND PACKET RECORD NUMBER
	LIS	R0,0			:PROVIDE OPPORTUNITY TO PATCH
	LHL	R0,TSLINK		:THIS 'LHL' TO A 'STH' TO TERMINATE
					:TRACING AND EXAMINE HISTORY
					:PRIOR TO BAD RECORD OCCURRENCE.
	L	R15,TSRSVE
TSLB14	EI	:TSTSZE

	J	SIOI2

:	COPY THE DATA TO THE INPUT SECTOR (IF NOT RETRANSMISSION)

SIOI5	CLH	R2,RECN,R6		:WAS RECORD RECEIVED?
	JE	SIOI6			:YES, NOTE RETRANSMISSION

:	NOW COPY THE DATA
:       copy moved to before setting LKTEAR and such since if background
:       interupts between setting the bits and the copy completes the RTEAR
:       will tear garbage instead of the record.                        ###sdw

	IF	STRHUB
	LB	R7,LTYP,LN		:IF STAR LINE
	JEFS	SIOI51
	LA	R7,SIBUF+4,R11,R13	:SET R7 TO ADDRESS OF LAST
	JFS	SIOI52
SIOI51	EI	:STRHUB
	LA	R7,SIBUF,R11,R13	:SET R7 TO ADDRESS OF LAST
SIOI52	AR	R7,R1			:	HALFWORD OF SOURCE
	IF	EXPWSZ
	L	R8,BREC,R6		:SET R8 TO ADDRESS OF LAST
	ELSE
	LHL	R8,BREC,R6		:SET R8 TO ADDRESS OF LAST
	EI
	LA	R8,RECBUF-2,R8,R1	:	HALFWORD IN DESTINATION BUFFER
	SLLS	R1,3			:NUMBER OF HALFWORDS * 8
	SIS	R1,1			:	MINUS 1

	HC	3F71			:COPY THE DATA

	LR	R0,LN			:GET LINE NUMBER
	SRHLS	R0,1
	SBT	R0,LNGREC		:NOTE GOOD REC REC'D ON LINE
       IF	NAKCOD			:Starlines ...
	LB	R0,LTYP,LN		:For  NAK protocol, keep track
	JE	SIOI55			:of last good record received
	LR	R3,R2		:Get RECN to work reg
	SH	R3,LGRR,KD
	SIS	R3,1		:Compare with LGRR+1
	CHVR	R3,R3		:R3 has HW value
	JE	SQPR2		:Normal sequence new RECN = LGRR+1
	JL	SIOI55		:Could be Nak Response .. copy it!
	LB	R7,NAKFLG,KD	:Skipped sequence - one or more records
	JN	SQPR2		:if NAK pending, do not NAK this one
	LIS	R7,1
	STB	R7,NAKFLG,KD	:Set NAK Flag
	LHL	R3,LGRR,KD
	AIS	R3,1		:Missed packet number is
	STH	R3,NKTS,KD	:LGRR+1, becomes record to NAK
SQPR2	STH	R2,LGRR,KD	:and store new LGRR
       EI	:NAK		:STRHUB!STRRMT	revised 7/2/87		###ev
	
SIOI55	LB	R3,LKNM,KD		:GET LINK NUMBER
	SBT	R3,LKTEAR		:"SCHEDULE RTD
	STH	R2,RECN,R6		:GIVE RECORD TO SECTOR
	SBT	R3,LKGREC		:NOTE GOOD REC ON LINK
SQIO66	LIS	R0,1			:BUMP COUNT OF GOOD
	AHM	R0,RCRCVD,LN		:	RECS RECEIVED ON THIS LINE

SIOI15	NHI	R2,PKTMSZ		:MASK REC NUMBER WITH BUFFER SIZE
	AR	R2,R2			:FORM HW INDEX
	LHL	R0,FASTC+2,,		:GET CURRENT TIME
	STH	R0,INTIME,KD,R2		:RECORD TIME OF PACKET ARRIVAL
	IF	STRHUB
	LB	R2,LTYP,LN		:IF STAR LINE
	JEFS	SI151
	LH	R2,SIBUF+6,R11,R13	:UPDATE LAST ACK RECEIVED
	JFS	SI152
SI151	EI	:STRHUB
	LH	R2,SIBUF+2,R11,R13	:UPDATE LAST ACK RECEIVED
SI152	LHL	R1,LAR,KD		:GET LAST ACKNOWLEDGEMENT
	SR	R2,R1			:IS NEW ACKNOLWEDGMENT
	LBR	R2,R2			:	WITHIN THE ALLOWABLE
	CLB	R2,WSIZ,KD		:	WINDOW SIZE?
	JG	SIOI5A			:NO, INC ERROR COUNTER
	AHM	R2,LAR,KD		:YES UPDATE LAR

SIOI16	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB16			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	LHL	R2,RECN,R6		:GET RECORD NUMBER
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LHI	R0,TS.REC
	STB	R0,TSFTBL,R15		:STORE EVENT (GOOD RECORD RECEIVED )
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB16	EI	:TSTSZE

	J	SIOI2

SIOI5A	LB	R0,NLAT,KD		:TEST FOR MULTI-LINE LINK -- BAD ACKS
	CLHI	R0,1			: CAN OCCUR DUE TO SHORTER PACKET
	JNFS	SIOI5B			: OVERTAKING PRIOR TRANSMISSION
					: - DON'T COUNT IT...
	AHM	R0,BADACK,LN,

SIOI5B	IF	TSTSZE			:IF SYNC EVENT TRACE ENABLED
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:TEST FOR LINK OF INTEREST
	JN	TSLB20			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BAK
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD ACK)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER 
	LR	R1,R15			:SAVE INDEX REGISTER AND
	L	R15,TSRSVE		:	RESTORE R15 (KD)
	LH	R0,LAR,KD		:GET LAST ACK RECEIVED AND
	STB	R0,TSFTBL+4,R1		:	STORE IN EVENT ENTRY	###OAS
	LIS	R0,0			:PROVIDE OPPORTUNITY TO PATCH
	LHL	R0,TSLINK		:THIS 'LHL' TO A 'STH' TO TERMINATE
					: TRACING AND EXAMINE HISTORY
					: PRIOR TO BAD ACK OCCURRENCE.  
TSLB20	EI	:TSTSZE
	J	SIOI2

:	NOTE RETRANSMISSION

SIOI6	LR	R0,LN
	SRHLS	R0,1			:GET TRUE LINE NUMBER
	SBT	R0,LNGREC		:NOTE GOOD REC RECVD ON LINE
					:ADDED 10/30/83 OMAR
	IF	STRHUB!STRRMT
	LB	R0,LKNM,KD		:Set good record received for Hub 
	SBT	R0,LKGREC		:and Remote  6/5/87		###ev
	EI	:STRHUB
	LIS	R0,1			:INC RETRANSMISSION COUNTER
	AHM	R0,RCRXMT,LN,
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB13			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RXC
	STB	R0,TSFTBL,R15		:STORE ENTRY TYPE
	STH	R4,TSFTBL+2,R15		:STORE FIRST 2 BYTES OF HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB13	EI	:TSTSZE

	IF	APLYBP&MAKNUL
::*********************************************************************
::
::	FUNCTION:	Checks to see if repeated retransmissions are
::			being received.  If so provide for Ack to be sent
::			in a Null record.
::	INPUT:		R2  =  RECN of most recently rcvd rexmitted record
::			KD  =  Link descriptor porinter
::			R6  =  Record descriptor pointer
::			R5  =  Window size
::	DESTROYED:	R0,R1
::
::*********************************************************************
SRXCHK	LB	R0,KTYP,KD	:Starlink only
	CLHI	R0,STRTYP
	JN	SRX090
	LR	R0,R2		:Get rexmisn RECN to work reg
	CLH	R0,LRR,KD	:Do we have a repeat retransmission?
	JN	SRX060		:No, then what do we have?

::  A repeat retransmission has been received - should we force an Ack?
	LB	R1,RRXCNT,KD	:Get current repeated retransmission count
	CLHI	R1,RRXLIM	:Has threshold been exceeded?
	JL	SRX050		:Not yet .. so continue and add to count

::A retransmission has been repeatedly received threshold times - force Ack
	LIS	R1,1
	STB	R1,NULFLG,KD	:Set flag for Rmake to send Null record
	LIS	R0,0		:Re-init rrxcnt here to throttle Null recs
	STB	R0,RRXCNT,KD
	J	SRX090

SRX050	AIS	R1,1
	STB	R1,RRXCNT,KD	:Add to RRX count
	J	SRX090		:and continue

SRX060	STH	R0,LRR,KD	:RRECN not eq to LRR so update LRR with it
	LIS	R0,0
	STB	R0,RRXCNT,KD	:Re-initialize rexmission counter
				:and fall through to continue processing
SRX090	EI	:APLYBP&MAKNUL
	J	SIOI15			:GO UPDATE LAR

:	RECORD WITH BAD BORI RECEIVED ON ASSIGNED LINE
:	CHECK IT OUT

SIOI7	HS	0
	IF	XRESET			:###wjl
	IF	STRHUB
	LB	R0,LTYP,LN		:ALL RESET P-P CT ACCEPTED FOR
	JEFS	SIOI72			: OTHER STATION RESETS ##AL
	CLHI	R4,DWNLHD		:Is it a Down line load header?
	JNFS	SIOI71			:NO .. so what is it
	J	STDWIN			:DWL record for subsequent Starlink
SIOI71	HS	0
	LR	R0,R4			:KEEP HEADER ##AL
	NHI	R4,0F0E0
	JFS	SIOI73
SIOI72	EI	:STRHUB
	NHI	R4,0F0EF		:mask out 'count code', 'subseq' bit
	ELSE
	NHI	R4,0FFEF		:MASK OUT 'subsequent' bit	###wjl
	EI	:XRESET
SIOI73	CLHI	R4,TTRSHD		:IS THIS ANY KIND OF TYMNET-II RESET?
	JE	SILRAL			:YES, GO TREAT IT
::Get full word header preserved in R4
	IF	STRHUB
	LB	R0,LTYP,LN		:IF STAR LINE
	JE	SIOI74
	L	R4,SIBUF+6,R11,R13	:GET FULL WORD
	JFS	SIOI75
	EI	:STRHUB
SIOI74	L	R4,SIBUF+2,R11,R13	:GET FULL WORD
SIOI75	IF	NAKCOD			:STRHUB!STRRMT
	LR	R0,R4
	NI	R0,0FF000000
	CI	R0,050000000	:Is this the NAK header (in HO of reg)
	JN	SIOI78
::NAK record received
NAKRCD	LR	R2,R4
	SRLS	R2,8
	NI	R2,0FFFF	:Use only LO HW containing NAK seq #
::Is the NAK within the current window?
	LB	R3,WSIZ,KD		:GET NUMBER OF SECTORS
	LHL	R6,OSEC,KD		:SECTOR 0 DESCRIPTOR ADDRESS
	LR	R0,R2
	SH	R0,RECN,R6		:DISTANCE TO SECTOR 0
	CHVR	R0,R0
	JGEFS	STRC02			:AHEAD OF SECTOR 0
	AR	R0,R3			:ADJUST FOR WRAP AROUND
STRC02	CR	R0,R3			:TOO FAR AHEAD?
	JLFS	STRC04			:NO
	SR	R0,R3			:YES, BACK UP

STRC04	MH	R0,CCDSZ		:GET RELATIVE SECTOR ADDRESS
	AR	R6,R0			:CORRECT SECTOR DESC ADDR TO R6
	LR	R0,R2			:MOVE REC # TO R0
	SH	R0,LAR,KD		:IS THIS REC # .LE. LAST ACK RECD?
	CHVR	R0,R0
	JLE	SIOI77			:YES, for NAK this is invalid - error
					:RETURN TO MAINLINE
	CR	R0,R3			:IS REC # .LE. LAR + WSIZ?
	JG	SIOI77			:NO - ERROR - RETURN TO MAINLINE
::	NAK record number is within our recently transmitted window.  
NAKPRO	LB	R1,SNDRSP,KD
	JN	SIOI77		:NAK sending is not available - go to mainline
	LIS	R1,1
	STB	R1,SNDRSP,KD	:NAK sending is busy until SI22TA
	LH	R1,NRXM,KD
	STH	R1,PRXM,KD	:Save current NRXM
	STH	R6,NRXM,KD	:This record descriptor becomes next to xmit
	LB	R0,LLXM,R6
	OHI	R0,NAKRSP
	STB	R0,LLXM,R6	:Mark this record as a NAK Response

SIOI77
:	NAK PACKET RECEIVED ON ATTACHED LINE, DO F.G. TRACE		###AL
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR TRACING DESIRED
	JN	TSLB12			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:MAKE NEW EVENT ENTRY
	LIS	R0,TS.NAK		:NAK FORGROUND TRACE		###AL
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE
	LHI	R0,NAKORI
	EXBR	R0,R0			:STORE NAK HEADER, 2ND BYTE 00	###AL
	STH	R0,TSFTBL+2,R15
	LHL	R0,RECN,R6		:STORE RECN AS THE 3RD BYTE
	STB	R0,TSFTBL+4,R15
	L	R15,TSRSVE		:RESTORE R15
	J	TSLB12			:GO TO SET GOOD RECORD ARRAY
	EI	:TSTSZE
SIOI78	EI	:NAK		:###EV

	CLI	R4,TWDMHD		:DUMMY RECORD?
	JN	SIOI8			:NO, ERROR
:	DUMMY RECEIVED ON ATTACHED LINE	
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR TRACING DESIRED
	JNFS	TSLB12			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:MAKE NEW EVENT ENTRY
	LIS	R0,TS.DUM
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE
	LIS	R0,0
	STH	R0,TSFTBL+2,R15		:NO DATA FOR HEADER FIELD
	L	R15,TSRSVE		:RESTORE R15
TSLB12	EI	:TSTSZE
	LR	R0,LN			:GET LINE NUMBER
	SRHLS	R0,1			:NOTE GOOD REC REC'D ON LINE
	SBT	R0,LNGREC
	IF	STRHUB!STRRMT
	LB	R0,LKNM,KD		:STAR LN/LK ACCEPT DUMMY RCD 
	SBT	R0,LKGREC		: AS LINK GOOD RCD ALSO ##AL
	EI	:STRHUB!STRRMT
	J	SIOI2			:DONE

:	GARBAGE RECEIVED ON ATTACHED LINE -- NOTE LINE ERROR

SIOI8	LIS	R0,1			:INC CONTER
	AHM	R0,LINERR,LN,
	J	SIOI2

:	RESET RECEIVED ON ATTACHED LINE -- HANDLE IT

SILRAL	HS	0
:	FOR TYMSTAR, STAR LINE AND FIRST STAR LINK IS UP ALREADY, RECEIVED
:	RESET PATTERN FOR OTHER STAR LINKS.
	IF	STRHUB
	LB	R1,LTYP,LN		:ONLY FOR STR LINE
	JE	SIRS1
	LR	R4,R0			:KEEP HEADER IN R4##AL
	L	R5,KDLN,LN,LN		:GET STRLN BLOCK PTR
	JL	SIOI2			:LINE IS BAD, CHECK NEXT LINE
SILR1S	L	R1,CRSTKD,R5		:IS ANY STAR LINK IN RESET STATE ?
	JN	SIRSA			:YES				###AL
:	CRSTKD WAS 0, THERE IS NO STAR LINK IN RESET STATE.
	L	R1,SIBUF+2,R11,R13	:GET FULLWORD KEY
	JAL	R8,KYMTKD		:1ST RESET CATCHED, MATCH KEY
	J	SIOI2			:COULD NOT FIND MATCHED KEY
	L	R1,SIBUF+8,R11,R13	:GET RECEIVED NDID, FW PATTERN	###AL
	CLH	R1,NDID,KD		:CHECK IF NDID MATCHED
	JEFS	SILR2S
	J	SILUA0
SILR2S	ST	KD,CRSTKD,R5		:SET CURRENT RESET KD AS THIS KD
	LB	R1,STAFLG,KD		:CHECK STATE AND SET FLAGS
	NHI	R1,LNKSTA		:IS LINK UP ?
	JE	SIRSX			:NO
:		LINK WAS UP, DETACH LINK NOW
	LIS	R1,DETSTA		:DETTACH LINK STATE
	STB	R1,STAFLG,KD
	LR	R1,LN
	SRHLS	R1,1			:GET LINE NUMBER
	J	SIRS4
:		LINK WAS DOWN, SET LINK AS RESET STATE NOW
SIRSX	LIS	R1,RSTSTA		:SET RESET STATE
	STB	R1,STAFLG,KD
	J	SIRS2			:COPY RESET BUF
SIRS1	EI	:STRHUB
	LR	R1,LN
	SRHLS	R1,1			:GET LINE NUMBER
	TBT	R1,INHRST		:RESET INHIBITED?
	JN	SIOI2			:YES, IGNORE IT

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB19			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RST
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (RESET RECEIVED)
	IF	STRHUB
	LB	R0,LTYP,LN		:IF STAR LINE
	JEFS	SILRA1
	L	R0,SIBUF+6,R11,R13	: GET 4 BYTES OF RESET AND
	JFS	SILRA2
SILRA1	EI	:STRHUB
	L	R0,SIBUF+2,R11,R13	: GET 4 BYTES OF RESET AND
SILRA2	ST	R0,TSFTBL+2,R15		: STORE (CLOBBER HI-ORDER HW OF FASTC)
	AIS	R15,TSESZE
	NHI	R15,TSTSZE-1		:ADVANCE TO NEXT ENTRY AND CLEAR
	LIS	R0,0			:	IT TO EASE FINDING END OF
	ST	R0,TSFTBL,R15		:	TRACE HISTORY
	ST	R0,TSFTBL+4,R15
	STH	R0,TSLINK		:INHIBIT FURTHER TRACING
	L	R15,TSRSVE

	JAL	R8,TSNSPK		:SAVE MOST RECENT PACKETS IN AND OUT

TSLB19	EI	:TSTSZE

	LCS	R0,1		
	ST	R0,KDLN,LN,LN		:PUT LINE IN LIMBO
	LHI	R0,SIOIDL-SEG1		:TURN OFF OUTPUT
	STH	R0,SIOTST,LN
SIRS4
	SBT	R1,LINDET		:TELL LINKER TO DETACH
	LIS	R0,3
	STB	R0,DREASN,R1,		:SET DETACH REASON
	LHI	R0,1F-PLINKR		:AND 'SCHEDULE' LINKER
	SBT	R0,TLINKR
	J	SIOI2			:DONE

:	DATA RECEIVED ON UNASSIGNED LINE -- CHECK FOR RESET
SILUAL	HS	0

	IF	STRHUB
	LB	R1,LTYP,LN		:ONLY FOR STR LINE
	JE	SIRS2
	L	R5,SKDPTR,LN,LN		:GET STARLINE LINK CHAIN PTR
SILU1S	L	KD,CRSTKD,R5		:IS ANY LINK IN RESET STATE ?
	JN	SIRSA			:YES, CHECK IF SAME LINK IN RESET
:	CRSTKD WAS 0, FIRST RESET CATCHED
SILUAA	L	R1,SIBUF+2,R11,R13	:GET FULLWORD KEY
	JAL	R8,KYMTKD		:1ST RESET CATCHED, MATCH KEY##LSH
	J	SIOI2			:ERR RETURN *
	L	R1,SIBUF+8,R11,R13	:GET RECEIVED NDID, FW PATTERN	###AL
	CLH	R1,NDID,KD		:CHECK IF NDID MATCHED
	JE	SILUA1	
SILUA0	L	R0,LNKKEY,KD		:KEY IN DISPLAY
	STH	R0,CRYSBF		:LO HW OF KEY IN HW2
	EXHR	R0,R0			:HO HW OF KEY PUT IN LO HW OF R0
	STH	R1,CRYSBF+2		:NBR# IN HW3
	JAL	R8,CRYPTO,,		:IF NOT MATCHED, GIVE A CRYPTO MSG
	HC	CRYE7A
	J	SIOI2			:AND SKIP THIS PACKET
SILUA1	ST	KD,CRSTKD,R5		:SET CURRENT RESET KD AS THIS KD
:	CRSTKD WAS NON-ZERO, THERE IS A LINK IN RESET STATE ALREADY,
:	CHECK IF IT IS THE SAME LINK IN RESET
SIRSA	L	R1,SIBUF+2,R11,R13	:GET FULLWORD KEY
	NI	R1,0FFFFFF00		:CHECK FOR MOST SIGNIFICANT 24-BITS
	CL	R1,LNKKEY,KD
	JN	SIOI2			:DOES NOT MATCH, IGNORE IT, EXIT

:	COPY FROM SIO INPUT BUFFER TO RESET BUFFER
SIRS2	EI	:STRHUB

	IF	TSTSZE
	JAL	R2,TSFUAL		:IS THIS LINE OF INTEREST?
	EI	:TSTSZE
	AIS	KD,1			:IF LINK ADDRESS = -1, FORGET
	JE	SIOI2			:	IT. LINK STILL IN DETACH
	LR	R2,LN			:GET LINE NUMBER
	SRHLS	R2,1
	TBT	R2,INHRST		:RESET INHIBITED?
	JN	SIOI2			:YES, IGNORE THIS
CPRSBF	LHL	R5,SDLN,LN		:GET RESET BUFFER ADDRESS
	NHI	R4,0FFE0		:MASK OUT 'subseq' bit and count###wjl

	IF	XRESET			:###wjl
	CLHI	R4,TXRSHD		:Is it an Expanded Reset?
	JN	SILU02			:no, check for old T-II Reset
	AHI	R5,VSDSZ-2		:address of last destination HW to R1+1
	IF	STRHUB
	LB	R4,LTYP,LN		:IF STAR LINE
	JEFS	SILU1
	LA	R4,(SIBUF+6)+(VSDSZ-2),R11,R13 :address of last source HW to R1
	JFS	SILU2
SILU1	EI	:STRHUB
	LA	R4,(SIBUF+2)+(VSDSZ-2),R11,R13 :address of last source HW to R1
SILU2	LHI	R1,10*((VSDSZ/2)-1)	:10*(number of HW'S -1)
	COPY	R4,R1			:copy Reset from temporary storage
	J	SILU04
	EI	:XRESET	###wjl

SILU02	CLHI	R4,TTRSHD		:IS IT A T-II RESET?		###wjl
	JN	SIOI2			:NO, FORGET IT
	IF	STRHUB
	LB	R4,LTYP,LN		:CHECK LTYP IF STAR LINE
	JEFS	SILU21
	L	R4,SIBUF+6,R11,R13	:GET FIRST FULLWORD OF RECORD
	ST	R4,VRSTP,R5		:SAVE FOR LINKER
	L	R0,SIBUF+0A,R11,R13	:NEXT FULLWORD MAY CONTAIN 
	JFS	SILU22
SILU21	EI	:STRHUB
	L	R4,SIBUF+2,R11,R13	:GET FIRST FULLWORD OF RECORD
	ST	R4,VRSTP,R5		:SAVE FOR LINKER
	L	R0,SIBUF+6,R11,R13	:NEXT FULLWORD MAY CONTAIN 
SILU22	ST	R0,VRSTP+4,R5		:	NEIGHBOR VERSION NUMBER

SILU04	SBT	R2,VRSTDL		:TELL LINKER TO LOOK AT IT
	SBT	R2,LINATT
	LHI	R0,1F-PLINKR		:SCHEDULE LINKER
	SBT	R0,TLINKR
	J	SIOI2			:DONE

:	DOWNLINE LOAD ON SIO LINE

SIODWL
	IF	STRHUB
	LB	R0,LTYP,LN
	JE	SIDWL1
	L	R5,SKDPTR,LN,LN		:Pointer to Starlink chain descriptor
	L	R1,SIBUF+2,R11,R13	:Gets Starlink Key
	JAL	R8,KYMTKD		:Match Key ###LSH
	J	SIOI2			:treats this as garbage
SISDW1	LHL	R0,SIBUF+6,R11,R13	:FIRST HALFWORD OF DATA
	JFS	SIDWL2
SIDWL1	EI	:STRHUB
	LHL	R0,SIBUF+2,R11,R13	:FIRST HALFWORD OF DATA
SIDWL2	LIS	R6,1
	AHM	R6,DWLCLI,,
	CLHI	R0,DWNLHD		:DWL HEADER?
	JN	SIOI2			:NO, IGNORE THE RECORD (GARBAGE?)
	IF	STRHUB
	LB	R1,LTYP,LN
	JE	SIDCM2
	LHI	R5,46			:Starline uses a 46x byte count
	JFS	SIDCMP
	EI	:STRHUB
SIDCM2	LHI	R5,42
SIDCMP	CR	R10,R5			:CORRECT BYTE COUNT?
	JN	SIOI2			:NO, IGNORE THE RECORD (GARBAGE?)
	LH	R6,DWTEST,,		:TEST DWLIN SEMAPHORE
	JL	SIOI2			:<0 MEANS DWLIN IS USING SQUEUE
	LIS	R1,0
SIODW1	CLH	LN,DWLNUM,R1,,		:FIND THE INTERNAL HOST CHANNEL INDEX
	JEFS	SIODW2
	AIS	R1,2
	CLHI	R1,TINTCH*2
	JLBS	SIODW1
SIODW2	LH	R6,DWBUSY,R1,		:TEST BUFFER BUSY FLAG
	JL	SIOI2			:<0 MEANS DWLIN IS USING DWIBUF
	LR	R5,R1			:NONE OF ABOVE, SO ALL CLEAR. FORM
	SLLS	R5,5			:DWIBUF OFFSET (64 x R1)
	IF	STRHUB
	LB	R2,LTYP,LN
	JEFS	SIDW21
	LA	R2,SIBUF+46,R11,R13	:LAST SOURCE HALFWORD
	JFS	SIDW22
SIDW21	EI	:STRHUB
	LA	R2,SIBUF+42,R11,R13	:LAST SOURCE HALFWORD
SIDW22	LA	R3,DWIBUF+40-2,R5	:LAST DESTINATION HALFWORD
	LHI	R4,1F0			:HALFWORD COUNT=(20 - 1) x 10
	HC	3F24			:COPY R2,R4
	LHI	R0,-1000		:MARK DWIBUF FULL
	STH	R0,DWBUSY,R1,		:BY SETTING DWBUSY NEGATIVE
	SRLS	R1,1
	SBT	R1,DWQUEU,,		:TELL DWLIN THERE IS A RECORD HERE
	LHI	R0,01F-PDWLIN
	SBT	R0,SQUEUE		:SCHEDULE DWLIN
	J	SIOI2			:AND RETURN



	IF	STRHUB
::*********************************************************************
::
::	ENTRY POINT:	STDWIN:	STarline DoWnline load INput 
::	FUNCTION:	Starline - Subsequent Starlink DW Loads.
::			Checks the status flags in the link to determine
::			if ok to copy data to the DWL input buffer.  If so,
::			performs copy to dwl in buffer.
::
::	INPUT:		Expects KD --  and Starlink Key has been matched.
::	RETURNS:	J	SIOI2
::
::*********************************************************************

STDWIN	HS	0			:DWLs after Starline first link up
	LB	R0,STAFLG,KD		:Check link status
	LR	R1,R0
	NHI	R0,DWLSTA		:Must be marked as DWL
	JE	SIOI8			:Is not - error
	NHI	R1,DWLVFL		:If DWL - is buffer ready for input
	JE	STDWCP			:Copy data to DWL input buffer
	J	SIOI2			:Buffer is busy - try again later

STDWCP	HS	0			:Star Downline input copy
	LA	R2,SIBUF+46,R11,R13	:copy from
	L	R3,DWLVBF,KD		:to
	AI	R3,40-2			:Make last destination halfword
	LHI	R4,DWICNT		:for DWICNT bytes
	HC	3F24
	LH	R4,DWLNDX,KD		:Get INTHST channel index
	SBT	R4,DWQUEU,,		:and tell DWLIN there is work to do
	LHI	R0,01F-PDWLIN
	SBT	R0,SQUEUE		:and schedule it
	J	SIOI2			:Return to mainline
	EI	:STRHUB

	SUBTTL	LINKER (SIO M-board report routines)

	IF	STRHUB
::*********************************************************************
::
::	SUBROUTINE:	KYMTKD:		###AL  ###LSH
::	FUNCTION:	RECEIVE TYM STAR LINK KEY, MATCH KEY IN KD
::	CALLING SEQ:	JAL	R8,KYMTKD
::	INPUT:		R1=LNKKEY (FW) 
::			R5=POINTER TO STARLINE LINK CHAIN DESCRIPTOR
::	OUTPUT:		KD(R15)=LINK DESCRIPTER PTR.
::	DESTROYED:	R1
::
::*********************************************************************
KYMTKD	HS	0
	L	KD,STHEAD,R5		:START FROM TOP OF THE LIST	
	NI	R1,0FFFFFF00		:CHECK THE 24-BIT KEY
KYM1	CL	R1,LNKKEY,KD
	JEFS	KYM2			:MATCHED
KYM11	L	KD,NXTLNK,KD		:NEXT STAR LINK PTR.
	JNBS	KYM1
	JR	R8			:ALL KEYS ARE NOT MATCHED, ERR
KYM2	J	4,R8
	EI	:STRHUB

::*********************************************************************
::
::	SUBROUTINE:	SIOBZY:
::	FUNCTION:	M-BOARD TIMEOUT. GENERATE A SUP REPORT AND CRYPTO
::			MESSAGE AND RETURN.
::	CALLING SEQ:	JAL	R12,SVCExx
::	INPUT:		DIFFERENT SVC'S ARE DISTINGUISHED BY THE VALUE IN R8
::	PRESERVED:	All registers
::	CALLS:		JAL	R9,NETDGN
::
::*********************************************************************

SIOBZS	LIS	R8,DR.SZS		:GET MESSAGE TYPE - INDICATE SVC STATUS
	JFS	SIOBZY
SIOBZO	LIS	R8,DR.SZO		:...OUTPUT
	JFS	SIOBZY
SIOBZI	LIS	R8,DR.SZI		:...INPUT
	JFS	SIOBZY
SIOBZC	LIS	R8,DR.SZC		:...CONNECT

SIOBZY	STM	R0,SBZSAV		:SAVE OFF REGISTERS (ESPECIALLY R9)
	LHL	R2,NGSVLN,LN,		:NEIGHBOR LAST ATTACHED TO THIS LINE
	STH	R2,SUPMBF+4
	SRLS	R14,1			:TRUE LINE NUMBER
	STB	R14,SUPMBF+3
	JAL	R9,NETDGN,,		:MAKE REPORT TO SUP AND XRAY
	GL	NETDGN
	LM	R0,SBZSAV		:RECOVER REGISTERS
	JR	R12			:RETURN TO CALLER

::*********************************************************************
::
::	SUBROUTINE:	SIOXXX:
::	FUNCTION:	MBOARD RC=4, ERROR. MAKE CRYPTO REPORT TO XRAY.
::	CALLING SEQ:	JAL	R12,SVCExx
::	INPUT:		LN  = R14
::	CALLS:		JAL	R8,CRYPTO
::			HC	CRYE70
::	###OAS 3/83
::*********************************************************************

SIOXXX	LR	R2,LN			:LINE NUMBER			###OAS
	SLLS	R2,0F			:IN HO HW			###OAS
	IF	STRHUB
	LB	R8,LTYP,LN
	JEFS	SIOX1
	LIS	R8,0			:NBR# 0000 FOR STARLINE ##AL
	JFS	SIOX2
SIOX1	EI	:STRHUB
	LHL	R8,NGSVLN,LN,		:NEIGHBOR NUMBER		###OAS
SIOX2	OR	R2,R8			:IN LO HW			###OAS
	ST	R2,CRYSBF		:STORE FOR CRYPTOGRAM		###OAS
	JAL	R8,CRYPTO		:SIO ERROR			###OAS
	HC	CRYE70			:				###OAS
	JR	R12			:RETURN TO SVC CALLER		###OAS

	SUBTTL	LINKER (SYLVER - SIO output processor)

::*********************************************************************
::
::	Jump here from INTSIO routine when get interrupt 0A.
::	THIS CODE IS NOT USED, PART OF NEW SIO I/O COMPLETE INTERRUPT.
::	INTERRUPT-LEVEL SIO OUTPUT ROUTINES.
::
::*********************************************************************

SINTPC	WC	0,0			:SAVE AREA FOR INTERRUPT PC AND PSW

SRESET	LH	R1,FASTC+2,,		:READ LOW ORDER HW OF CURRENT TIME
	SH	R1,LNRTIM,LN,		:CALCULATE TIME SINCE OUTPUT STARTED
	CHVR	R1,R1			:EXTEND SIGN BIT THROUGH FULL WORD
	LIS	R2,1			:PREPARE FOR SLOWEST POSSIBLE LINE
	CLHI	R1,0C4			:IF OVER C4 TICKS, 2.4KB
	JGEFS	SRESE4
	LB	R2,SIOSPD,R1		:LOOK UP LINE SPEED
SRESE4	STH	R2,BAUDRT,LN,		:AND SAVE IT IN BAUDRT
	LPSW	SINTPC			:RETURN TO INTERRUPT ROUTINE

::*********************************************************************
::
::	ROUTINE:	SIOUT:
::	FUNCTION:	OUTPUT HANDLER ROUTINES FOR ALL SIO LINES
::	CALLING SEQ:	JUMP HERE FROM SYLRTX (PART OF SYLVER LOOP)
::			WHEN BYTE COUNT NEGATIVE.
::	CALLS:		DISPATCH TO APPROPRIATE OUTPUT ROUTINE.
::			EACH SIO LINE'S OUTPUT STATE IS DEFINED BY THE
::			ROUTINE WHOSE ADDRESS IS STORED AT 'SIOTST'.
::
::	THE POSSIBLE OUTPUT STATES ARE:
::
::	SIOIDL	-- IDLE (GO IMMEDIATELY TO NEXT LINE)
::	SIOTT	-- LOOKING FOR A RECORD TO SEND
::	SION	-- SENDING ONE RECORD -- LOOKING FOR ANOTHER TO CHAIN IN
::	SIOC	-- WAITING FOR SUCCESS OR FAILURE OF CHAINING
::	SIORR	-- SEND REPEATED RESETS TO MAKE NEIGHBOR AWARE OF PRESENCE
::	SIORS	-- SEND SINGLE RESET FOR RESET SEQ AND SPEED CLOCKING	
::	SIORT	-- CLOCK IN THE LINE SPEED PATTERN AND GO TO SIOIDL	
::
::	RETURNS:	DISMISS SYLVER TO ISIS OR SOLO EXEC LOOP
::
::*********************************************************************
SIOUT	HS	0			:			###GT  ###LSH
	IF	STRHUB!STRRMT		:			###LSH
	LB	R1,LTYP,LN		:CHECK FOR A STAR LINE
	JE	SO22			:REGULAR LINE, GO TO SERVE
					:			###LSH
	IF	STRDCD		:SWITCH FOR TESTING DCD BIT BEFORE OUTPUT
	LR	R5,LN
	SHI	R5,(NLINES-SILINS)*2	:COMPUTE RELATIVE SIO LINE
	SLLS	R5,3			:NUMBER * 10
	LB	R1,SIOSTT,R5,		:1ST BYTE OF STATUS -- REG0 ON SIO CHIP
	NHI	R1,SIODCD		:CHECK FOR BIT DCD
	JE	SIOIDL			:NOT READY TO SEND, GO TO NEXT LINE
	EI	:STRDCD						###LSH
	EI	:STRHUB!STRRMT		:			###LSH

	IF	STRHUB			
	L	R5,KDLN,LN,LN		:STARLINE, CHECK IF LINE IS ATTACHED
	JL	SO22			:NO, 1ST LINK RESET XMIT, OLD LOGIC
:	STARLINE IS ATTACHED, LOOK FOR AN STARLINK TO SERVE
					:R5=STARLINK CHAIN DESCRIPTOR PTR
	L	R4,STNEXT,R5		:STNEXT,NEXT STAR LINK KD TO SERVE
					:R4=LINK DESCRIPTOR PTR
SO01	LB	R1,STAFLG,R4		:CHECK LINK STATE&FLAG
	JN	SO02			:DOES THIS STARLINK NEED SERVICE?
	IF	RBTHUB
	LB	R1,RBTFLG,R4		:IF STARLINK IS DOWN MAY SEND RBOOT
	JN	SO02			:				###AL
	EI	:RBTHUB
	L	R4,NXTLNK,R4		:NO,  FIND ANOTHER
	JNFS	SO04			:CHECK NEXT KDLN IN CHAIN
	L	R4,STHEAD,R5		:END OF CHAIN - BACK TO HEAD OF CHAIN
SO04	C	R4,STNEXT,R5		:THIS WHERE WE STARTED?
	JE	SIOIDL			:YES - NOTHING TO DO, GOTO NEXT LINE
	J	SO01			:CHECK NEXT LINK
:	FUND A STARLINK TO SERVE. UPDATE STNEXT
SO02	L	R1,NXTLNK,R4		:UPDATE PTR TO NEXT LINK TO SERVICE
	JNFS	SO022			
	L	R1,STHEAD,R5		:BACK TO HEAD OF CHAIN
SO022	ST	R1,STNEXT,R5		:SAVE PTR TO NEXT LINK TO SERVICE

:	STARLINE OUTPUT TO SERVE AN STARLINK EACH TIME. 
:	SIOCNS IS OUTPUT STATE ONLY FOR STARLINE AFTER LINE IS ATTACHED.
:	NOTE : R4 CONTAINS LINK DESCRIPTOR POINTER.
	LHL	R1,SIOCNS,LN		:CHECK STARLINE OUTPUT STATE
	JEFS	SITT1			:INIT STATE AFTER LINE IS ATTACHED 
	J	SEG1,R1,,		:GET ROUTINE ADDRESS, GO TO IT
	EI	:STRHUB

:	REGULAR SIO LINE OUTPUT, OR STARLINE OUTPUT TO SERVE AN STARLINK
:	EACH TIME.
:	SIOTST IS OUTPUT STATE FOR REGULAR LINE, OR FOR STARLINE BEFORE
:	LINE IS ATTACHED
:
SO22	LHL	R1,SIOTST,LN		:GET ROUTINE ADDRESS	###LSH
	J	SEG1,R1,,		:GO TO IT

::*********************************************************************
::
::	OUTPUT STATE:	SIOTT -	LOOKING FOR INITIAL RECORD TO SEND
::
::*********************************************************************

SIOTT	L	R4,KDLN,LN,LN		:GET LINK DESCRIPTOR ADDRESS
	JL	SIOIDL			:LINK DOWN,R4 WILL NOT BE NEG

:	STRLINE DATA XMIT ENTRY. FOR STARLINE, R4 HAS ALREADY CONTAINED
:	LINK DESCRIPTOR POINTER BEFORE JUMP TO HERE.		###LSH
SITT1	HS	0			:			###LSH
	IF	SIBFRL			:			###LSH
	L	R1,SIOCO,LN,LN		:SET R1 AS CURRENT CCW  ###LSH
	ELSE	:NOT SIBFRL		:BLOCK ADDR TO WRITE    ###LSH
	LHL	R1,SIOCO,LN		:OUTPUT PROGRAM (SEE	###LSH
	EI	:SIBFRL			:ROUTIEN SIOSND, SIOT4) ###LSH
	IF	STRHUB
	LB	R0,LTYP,LN		:ONLY FOR STARLINE
	JE	SITT2
	IF	RBTHUB:STRHUB
	LB	R0,RBTFLG,R4		:SEND RMT-BOOT?
	JE	SITT1B
	LB	R0,STAFLG,R4		:SKIP DWLSTA FOR BOOT
	NHI	R0,DWLSTA
	JN	SITT1A
	LHI	R5,8			:SEND RMT-BOOT PACKET
	STH	R5,STRRBT,,		:8 BYTES COUNT
	L	R5,LNKKEY,R4
	ST	R5,STRRBT+2,,		:STATION KEY
	LHI	R5,RBOTHD
	STH	R5,STRRBT+6,,		:HEADER
	LHI	R5,MACHNM
	STH	R5,STRRBT+8,,		:SENDER'S NODE#
	LIS	R0,0
	STB	R0,RBTFLG,R4		:RESET FLAG
	IF	SIBFRL			:SIO BUFFER RELOCATION
	LI	R5,STRRBT/10		:Make CCW point to STRRBT###LSH
	ELSE	:SIBFRL			:NOT SIBFRL
	LHI	R5,STRRBT/10		:Make CCW point to STRRBT
	EI	:SIBFRL			
	STH	R5,2,R1			:WRITE BUFFER ADDRESS TO CCW BLOCK
	J	SIOT4			:START OUTPUT
SITT1A	LIS	R0,0
	STB	R0,RBTFLG,R4		:RESET FLAG
	LB	R0,STAFLG,R4		:R0 IS THE STATE
	J	SITT14			:COPY DWL PACKET
SITT1B	EI	:RBTHUB:STRHUB
	EI	:STRHUB
	IF	NAKCOD			:STRRMT needs no special xmit
	LB	R0,LTYP,LN		:			###LSH
	JE	SITT2			:Check if Starline
	LB	R0,NAKFLG,R4		:Should we send a NAK?  ###LSH
	JE	SITT12			:NO
::Formulate NAK header with NAK sequence number
	LHL	R0,NKTS,R4		:Get RECN of record to NAK
	LHI	R5,NAKORI		:Get NAK header
	EXHR	R5,R5			:to upper hw of reg
	OR	R5,R0			:Put NAK sequence number in lo hw
	SLLS	R5,8			:Move entire 3 HW's to HO position

	IF	STRHUB			
	ST	R5,SIONAK+6,,
	L	R0,LNKKEY,R4		:FOR STAR LINK, PUT IN KEY ##AL
	ST	R0,SIONAK+2,,
	LIS	R0,8
	STH	R0,SIONAK,,		:and insert length at head of area
	ELSE				:non Hub
	ST	R5,SIONAK+2,,		:and store in output area
	LIS	R0,4
	STH	R0,SIONAK,,		:Insert length at head of area
	EI	:STRHUB

	LIS	R5,0			:###LSH
	STB	R5,NAKFLG,R4		:Reset  NAK flag
	IF	SIBFRL			:SIO BUFFER RELOCATION
	LI	R5,SIONAK/10		:Make CCW point to NAK###LSH
	ELSE	:SIBFRL			:NOT SIBFRL
	LHI	R5,SIONAK/10		:Make CCW point to NAK
	EI	:SIBFRL			
					:###LSH
	STH	R5,2,R1			:WRITE BUFFER ADDRESS TO CCW BLOCK
	J	SIOT4			:START OUTPUT
	EI	:NAK			:###EV	###LSH

SITT12 	HS	0
	IF	STRHUB
	LB	R5,LTYP,LN		:STRLINE ?
	JE	SITT2			:NO, GO AHEAD
:	STARLINE, CHECK ALL KIND OF LINK STATES		###LSH
	LB	R0,STAFLG,R4		
	CHI	R0,RSTSTA+RSTXFG	:READY TO XMIT RESET?		###GT1
	JN	SITT14			:NO - ON TO NEXT STATE
	IF	SIBFRL
	L	R2,SIORSP,LN,LN		:POINTER TO RESET PATTERN
	ELSE	:NOT SIBFRL
	LHL	R2,SIORSP,LN
	EI	:SIBFRL
	SRLS	R2,4			:SET UP QUAD ADDRESS FOR CCW
	STH	R2,2,R1			:AND STORE
	LB	R0,HRSERF,R4		:IS IT RESET ERR SEND 33A0?	###AL
	JEFS	SITT13			:NO
	LIS	R0,0			:RESET ALL FLAG AFTER SENDING  	###AL
	STB	R0,HRSERF,R4		:CLEAR FLAG
	JFS	SIT13A
SITT13	LHI	R0,RSTSTA		:KEEP RSTSTA
SIT13A	STB	R0,STAFLG,R4
	LH	R0,FASTC+2,,
	STH	R0,LNRTIM,LN,
	J	SIOT4			:AND XMIT ON LINE		###GT1
SITT14	CHI	R0,DWLSTA+DWLXFL	:READY TO XMIT DOWN LINK LOAD ?
	JN	SITT22			:NO, ON TO NEXT STATE
	JAL	R10,SIOSDW		:GO COPY DWL DATA
	J	SIOT4			:SEND DATA
SITT22	CHI	R0,LNKSTA		:IS THE LINK ACTIVE?
	JN	SIOIDL			:NO, GO TO NEXT LINE
	EI	:STRHUB

SITT2	TS	KS.SEM,R4		:SET SEMAPHORE FOR 'NRXM' FIELD
	LHL	R5,NRXM,R4		:DESCRIPTOR ADDR OF NEXT REC TO XMIT
	LH	R6,RECN,R5		:NUMBER OF NEXT REC TO XMIT ###LSH
	SH	R6,LAR,R4		:HAS IT BEEN ACKNOWLEDGED?
	CHVR	R6,R6			:EXTEND SIGN BIT THROUGH FULL WORD
	JG	SIOT2			:NO, MAYBE SEND RECORD

:	SEND A DUMMY RECORD IF IT IS READY TO SEND	###LSH

SITT2A	IF	STRHUB
	LB	R0,LTYP,LN		:STAR LINE ?
	JE	SDUM1A			:NO		###LSH
					:STAR LINE
	TS	IDLE,R4			:INDICATE LINK NOT SATURATED
	LB	R0,LKNM,R4		:GET LINK #
	RBT	R0,STDUMM		:NEED TO SEND DUMMY?
	JE	SIOIDS			:NO
	RBT	R0,STSENT		:YES, NOTE IT IS SENT	###LSH
	L	R5,LNKKEY,R4		:SEND DUMMY WITH KEY ##AL
	ST	R5,STRDUM+2,,
	IF	SIBFRL			:###LSH
	LI	R5,STRDUM/10		:MAKE CCW POINT TO DUMMY###LSH
	ELSE	:NOT SIBFRL		
	LHI	R5,STRDUM/10		:MAKE CCW POINT TO DUMMY
	EI	:SIBFRL			
	GL	STRDUM			:			###LSH
	STH	R5,2,R1			:STORE BUFFER ADDRESS INTO CCW
	J	SIOT4			:START OUTPUT
SDUM1A	EI	:STRHUB
					:REGULAR LINE
	TS	IDLE,R4			:INDICATE LINK NOT SATURATED
	RBT	LN,SDUMM		:NEED TO SEND DUMMY?
	JE	SIOIDS			:NO
	RBT	LN,SSENT		:YES, NOTE IT IS SENT ###LSH
	IF	SIBFRL			:###LSH
	LI	R5,SIODUM/10		:MAKE CCW POINT TO DUMMY###LSH
	ELSE	:NOT SIBFRL		
	LHI	R5,SIODUM/10		:MAKE CCW POINT TO DUMMY
	EI	:SIBFRL			
	GL	SIODUM
	STH	R5,2,R1			:###LSH
	J	SIOT4			:START OUTPUT

:	SEND A RECORD

SIOT2	LB	R0,LLXM,R5		:IS IT A RETRANSMISSION?
	JE	SIOT2A			:NO

	IF	STRHUB!STRRMT		:###EV	1/5/87
::  For Tymstar, all retransmissions are paced at interval RXTIME.
	LB	R7,LTYP,LN		:Starlines only
	JE	SPX090
	L	R0,FASTC,,		:Get current FastC time
	L	R7,SRXTIM,R5		:Get time to xmit this packet
	JNFS	SPX030			:If time is stored, process

	AHI	R0,RXTIME		:Else was Zero - add interval
	ST	R0,SRXTIM,R5		:to current time and store it
	J	SIOIDL			:Go away for service next time

SPX030	SR	R7,R0			:Check xmit time with current time
	JLEFS	SPX040			:Time yet?? Yes - transmit
	J	SIOIDL			:No - come back later

SPX040	LIS	R0,0			:Re-initialize xmit time to zero
	ST	R0,SRXTIM,R5		:and fall through to (re)transmit

SPX090	EI	:STRHUB!STRRMT


	LIS	R7,1			:YES - COUNT RETRANSMISSIONS
	AHM	R7,TRRXMT,LN,		:	BY LINE
	IF	STRHUB			:##AL FOR STRLINK
	LB	R6,LKNM,R4,		:GET LINK NUMBER
	AHM	R7,STRXMT,R6,R6		:COUNT REXMISSIONSS
	EI
	IF	NAKCOD			:Star NAK protocol
	LB	R0,LLXM,R5		:Get LLXM again
	NHI	R0,NAKRSP		:Check for being a NAK response pkt
	JE	SIOT3			:This is not a NAK response reXmsn
	LH	R6,PRXM,R4		:but if it is, replace the record
::	JGEFS	SI22TA			
::	J	SIOIDS
SI22TA	STH	R6,NRXM,R4		:sequence from PRXM and re-init PRXM
::	LCS	R7,2			:with a minus 2
::	STH	R7,PRXM,R4
	LIS	R7,0
	STB	R7,SNDRSP,R4		:Clear NAK sending 
	EI	:NAK			:###EV
	JFS	SIOT3			:DO NOT ADVANCE NRXM for normal rexms
SIOT2A	LH	R6,RLNK,R5		:ELSE DO SO
	STH	R6,NRXM,R4

SIOT3	JAL	R10,SIOSND		:START OUTPUTTING THE RECORD

:	WRITE OUTPUT PROGRAM INTO LINE'S CCW BLOCK 
:	(SEE DEVICE.DOC SEC 1.3.3 FOR DESCRIPTION OF CHANNEL PROGRAMS)

SIOT4	LIS	R0,0			:MAKE A STOP COMMAND
	STH	R0,4,R1			:PUT IT AFTER OUTPUT COMMAND
	LIS	R0,1			:MAKE AN OUTPUT COMMAND
	STH	R0,0,R1			:AND STORE IT

:	START OUTPUT CCW PROGRAM
	LR	R0,LN			:LINE NUMBER * 2
	IF	ISIS
	SRLS	R0,1			:LINE NUMBER
	TBT	R0,SIOPTA		:IS PORT AVAILABLE?		###OAS
	JNFS	SIOPT4			:NO, SKIP SVC
	SVC	IO,0B0			:START OUTPUT
	JAL	R12,SVCE3B		:ERROR, CRSH
SIOPT4	HS	0
	ELSE	:NOT ISIS		:SOLO SVC RETURNS IF M-BOARD BUSY
	SVC	0F,SV.OSI		:START OUTPUT
	JAL	R12,SVCE0E		:ERROR, CRASH
	EI	:ISIS
	LHI	R0,SION-SEG1		:SET NEW OUTPUT STATE
	STH	R0,SIOTST,LN
	IF	STRHUB
	STH	R0,SIOCNS,LN
	EI	:STRHUB
	J	SIOIDS			:GO PROCESS NEXT LINE

::*********************************************************************
::
::	OUTPUT STATE:	SION - ONE RECORD BEING SENT,
::			SEE IF WE CAN CHAIN IN ANOTHER
::
::*********************************************************************

SION	HS	0			:###LSH
	IF	SIBFRL			:###LSH
	L	R1,SIOCO,LN,LN		:CURRENT CCW BLOCK ADDRESS ###LSH
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R1,SIOCO,LN		:CURRENT CCW BLOCK ADDRESS
	EI	:SIBFRL			:###LSH
SIONA	LH	R0,0,R1			:GET STATUS OF CURRENT OUTPUT
	IF	STRHUB
	LB	R5,LTYP,LN
	JEFS	SIONB
	SIS	R0,1
	JE	SION2A
	LHI	R0,SITT1-SEG1		:SWITCH STATE TO OUTPUT RECORD
	STH	R0,SIOTST,LN
	STH	R0,SIOCNS,LN
	J	SITT1			:RESUME LOOKING FOR INITIAL
					:	RECORD TO SEND

SIONB	EI	:STRHUB
	SIS	R0,1			:IS IT DONE?

:	AFTER COMPLETION OF OUTPUT COMMAND THE MOTHER BOARD WRITES HW OF
:	200 IF NEXT COMMAND IS STOP, HW OF 100 IF NEXT COMMAND IS
:	SOMETHING ELSE.  

	IF	DB56KB
	JNFS	SION1			:YES
	JAL	R10,SIOSEE		:NO, CHECK FOR TIMEOUT
	J	SION2
	ELSE	:not DB56KB
	JE	SION2			:STATUS = 1, SKIP
	EI	:DB56KB

:	TOO LATE TO CHAIN THIS NEXT RECORD--SEND IT AS A SINGLE.
SION1	LHI	R0,SIOTT-SEG1		:SWITCH STATE TO OUTPUT RECORD
	STH	R0,SIOTST,LN
	J	SIOTT			:RESUME LOOKING FOR INITIAL
					:	RECORD TO SEND
SION2	L	R4,KDLN,LN,LN		:LINK DESCRIPTOR ADDRESS
	JL	SIOIDS			:LINK DOWN
SION2A	IF	STRHUB
	LB	R0,LTYP,LN
	JE	SION2B			:For starlines only
	IF	NAKCOD			:STRRMT needs no special xmit
	LB	R5,NAKFLG,R4		:Should we send a NAK?
	JE	SION22

::Formulate NAK header with NAK sequence number
	LHL	R0,NKTS,R4		:Get RECN of record to NAK
	LHI	R5,NAKORI		:Get NAK header
	EXHR	R5,R5			:to upper hw of reg
	OR	R5,R0			:Put NAK sequence number in lo hw
	SLLS	R5,8			:Move entire 3 HW's to HO position
	ST	R5,SIONAK+6,,
	L	R0,LNKKEY,R4		:FOR STAR LINK, PUT IN KEY ##AL
	ST	R0,SIONAK+2,,
	LIS	R0,8
	STH	R0,SIONAK,,		:and insert length at head of area

	IF	SIBFRL			:###LSH
	L	R1,SIONO,LN,LN
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R1,SIONO,LN
	EI	:SIBFRL			:###LSH
	LIS	R0,0
	STB	R0,NAKFLG,R4		:RESET NAK FLAG
	IF	SIBFRL			:###LSH
	LI	R0,SIONAK/10		:MAKE CCW POINT TO NAK###LSH
	ELSE	:NOT SIBFRL			:###LSH
	LHI	R0,SIONAK/10		:MAKE CCW POINT TO NAK
	EI	:SIBFRL			:###LSH
	J	SION5
	EI	:NAK
SION22	IF	SIBFRL			:###LSH
	L	R1,SIONO,LN,LN		:ADDR OF NEXT OUTPUT CCW BLOCK
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R1,SIONO,LN		:ADDR OF NEXT OUTPUT CCW BLOCK
	EI	:SIBFRL			:###LSH
	LB	R0,STAFLG,R4		:IF DWL, COPY DATA TO SIBUF
	CHI	R0,RSTSTA+RSTXFG	:READY TO XMIT RESET?		###GT1
	JN	SION2D			:NO RESETS
	IF	SIBFRL
	L	R2,SIORSP,LN,LN		:QUAD WORD POINTER TO RESET BUFFER
	ELSE	:NOT SIBFRL
	LHL	R2,SIORSP,LN
	EI	:SIBFRL
	SRLS	R2,4			:FORM ADDRESS FOR CCW
	STH	R2,2,R1			:AND STORE IN CCW
	LB	R0,HRSERF,R4		:IS IT RESET ERR SEND 33A0?	###AL
	JEFS	SION2C			:NO
	LIS	R0,0			:RESET ALL FLAG AFTER SENDING  	###AL
	STB	R0,HRSERF,R4		:CLEAR FLAG
	JFS	SIN2CC
SION2C	LHI	R0,RSTSTA		:KEEP RSTSTA
SIN2CC	STB	R0,STAFLG,R4
	LH	R0,FASTC+2,,
	STH	R0,LNRTIM,LN,
	J	SION5			:AND OUTPUT THE RESET PACKET	###GT1
SION2D	HS	0
	CHI	R0,DWLSTA+DWLXFL
	JN	SIONBB
	JAL	R10,SIOSDW		:COPY DWL DATA
	J	SION5			:SEND DATA
SIONBB	CHI	R0,LNKSTA		:IS THIS LINK EVEN ACTIVE?
	JN	SIOIDL
SION2B	EI	:STRHUB
	TS	KS.SEM,R4		:SET SEMAPHORE FOR 'NRXM' FIELD
	LHL	R5,NRXM,R4		:DESCRIPTOR ADDR OF NEXT REC TO XMIT
	LH	R6,RECN,R5		:NUMBER OF NEXT REC TO XMIT
	IF	STRHUB
	LB	R3,LTYP,LN		:ONLY FOR STAR LINE
	JE	SION3
	SH	R6,LAR,R4		:HAS IT BEEN ACKNOWLEDGED?
	CHVR	R6,R6			:EXTEND SIGN BIT THROUGH FULL WORD
	JG	SION4
	TS	IDLE,R4			:INDICATE LINK NOT SATURATED
	LB	R0,LKNM,R4		:GET LINK #
	RBT	R0,STDUMM		:NEED TO SEND DUMMY?
	JE	SIOIDS
	RBT	R0,STSENT		:YES, NOTE IT IS SENT

:	SEND A DUMMY RECORD

	L	R0,LNKKEY,R4		:SEND DUMMY WITH KEY ##AL
	ST	R0,STRDUM+2,,
SIDUM1	IF	SIBFRL			:###LSH
	LI	R0,STRDUM/10		:MAKE CCW POINT TO DUMMY###LSH
	ELSE	:SIBFRL			:###LSH
	LHI	R0,STRDUM/10		:MAKE CCW POINT TO DUMMY
	EI	:SIBFRL			:###LSH
	STH	R0,2,R1
	J	SION5			:GO START OUTPUT
SION3	EI	:STRHUB
	SH	R6,LAR,R4		:HAS IT BEEN ACKNOWLEDGED?
	CHVR	R6,R6			:EXTEND SIGN BIT THROUGH FULL WORD
	JLE	SIOIDS			:NO, MAYBE SEND RECORD
SION4	LB	R3,LLXM,R5		:NO, RETRANSMISSION?
	JN	SIOIDS			:YES - DO NOT CHAIN AHEAD
	LH	R6,RLNK,R5		:NO, ADVANCE NRXM
	STH	R6,NRXM,R4

:	HERE IF WE WANT TO CHAIN THE NEXT OUTPUT RECORD.

	IF	SIBFRL			:###LSH
	L	R1,SIONO,LN,LN		:ADDR OF NEXT OUTPUT CCW BLOCK
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R1,SIONO,LN		:ADDR OF NEXT OUTPUT CCW BLOCK
	EI	:SIBFRL			:###LSH
	JAL	R10,SIOSND		:SET RECORD UP
SION5	LIS	R0,0
	STH	R0,4,R1			:PUT STOP COMMAND AFTER OUTPUT
	LIS	R0,1
	STH	R0,0,R1			:SET UP THE OUTPUT COMMAND
	IF	SIBFRL			:###LSH
	L	R1,SIOCO,LN,LN		:NOW CHAIN TO CURRENT OUTPUT
	ELSE	:SIBFRL			:###LSH
	LHL	R1,SIOCO,LN		:NOW CHAIN TO CURRENT OUTPUT
	EI	:SIBFRL			:###LSH
	LIS	R0,2
	STH	R0,4,R1			:JUMP COMMAND
	LHI	R0,SIOC-SEG1		:SET NEW OUTPUT STATE
	IF	STRHUB
	STH	R0,SIOCNS,LN		:undefined symbol!!
	EI
	STH	R0,SIOTST,LN
	J	SIOIDS			:DONE

::*********************************************************************
::
::	SUBROUTINE:	SIOSND:
::	FUNCTION:	ROUTINE TO SET UP TO TRANSMIT A DATA RECORD.
::			MOVES IT FROM THE SECTOR TO AN OUTPUT BUFFER.
::			SETS UP THE APPROPRIATE HEADER, CALCULATES CHECKSUMS,
::			AND UPDATES LAS IN THE LINK DESCRIPTOR.
::	CALLING SEQ:	JAL	R10,SIOSND
::	INPUT:		R1 = POINTER TO CCW BLOCK TO OUTPUT NEXT RECORD
::			R5 = POINTER TO RECORD DESCRIPTOR
::
::*********************************************************************

SIOSND	HS	0
	IF	DB56KB			:IF SIO MONITORING OPTION
	LHL	R0,FASTC+2,,		:GET CURRENT TIME
	AHI	R0,$A60			:SET TIMEOUT FOR 100 MSEC FORM NOW
	STH	R0,SIODMA-SBASE,LN	:STORE AWAY THE TIMEOUT MOMENT
	EI	:DB56KB
	IF	EXPWSZ
	L	R7,EREC,R5		:GET RECORD BYTE COUNT BY SUBTRACTING
	S	R7,BREC,R5		:BEGINNING POINTER FROM END POINTER
	ELSE
	LH	R7,EREC,R5		:GET RECORD BYTE COUNT BY SUBTRACTING
	SH	R7,BREC,R5		:BEGINNING POINTER FROM END POINTER
	EI
	LR	R0,R7			:FORM 16*(#HW)-1 FOR MICROCODE
	SLLS	R0,3			:COPY INSTRUCTION LENGTH PARAMETER
	SIS	R0,1
	IF	EXPWSZ
	L	R2,BREC,R5		:START OF DATA
	ELSE
	LHL	R2,BREC,R5		:START OF DATA
	EI

	LA	R2,RECBUF-2,R2,R7	:SOURCE ADDRESS
	LHL	R3,8,R1			:GET OUTPUT BUFFER ADDRESS
					:###LSH
					:NOTE: IT CONTAINS QUAD ADDRESS
	IF	SIBFRL			:OF SIOBLO IF SIBFRL IS ON
	SLLS	R3,4			:SHIFT 4 BITS LEFT TO GET BACK
	EI	:SIBFRL			:OUTPUT BUFFER ADDRESS ###LSH

	LR	R6,R7			:LENGTH OF RECORD	###LSH

	IF	STRHUB!STRRMT		:			###LSH
	LB	R9,LTYP,LN		:CHECK IF STAR LINE SENDING
	JE	SIOS1
					:STARLINE,HAVE TO SEND CHECKSUM ###LSH
	IF	STRRMT			:STAR REMOTE ONLY	###LSH
	AIS	R6,4			:INCREMENT COUNT FOR CHECKSUM
	J	SIOHS3			:GO TO STORE BYTE COUNT	###LSH
	EI	:STRRMT

	IF	STRHUB			:STAR HUB ONLY		###LSH
	AIS	R6,8			:INCREMENT COUNT FOR KEY & CHECKSUM
	STH	R6,0,R3			:STORE BYTE COUNT	###LSH
	L	R6,LNKKEY,R4		:GET LNK KEY FROM KD
	ST	R6,2,R3			:STORE KEY
	AIS	R3,4			:COPY OFF 4 BYTE LOCATN	###LSH
	J	SIOS2
	EI	:STRHUB

SIOS1	EI	:STRHUB!STRRMT					###LSH
					:REGULAR LINE		###LSH
	IF	CKSM			:			###LSH
	AIS	R6,4			:INCREMENT COUNT FOR CKSUM ###LSH
	EI	:CKSM

SIOHS3	STH	R6,0,R3			:STORE BYTE COUNT	###LSH

SIOS2	LHI	R6,2,R3			:POINT PAST THE OUTPUT BYTE COUNT
					:R6 POINTS TO BEGINNING OF DATA
	AR	R3,R7			:DESTINATION ADDRESS TO R3

:	COPY	R2,R0			:COPY R0-1 HW'S FROM R2 TO R2+1 
					:	COUNTING BACKWARDS.
	HC	3F20			:MOVE SOURCE TO DESTINATION

	LH	R9,LRT,R4		:UPDATE LAS
	STH	R9,LAS,R4
	STB	R9,1,R6			:PUT ACK IN OUTPUT RECORD
	LIS	R0,0
	SR	R0,R7			:NEGATIVE BYTE COUNT FOR
	LIS	R2,0			:	CHECKSUM INSTRUCTION
	LIS	R3,0			:ALSO CLEAR ACCUMULATORS

	IF	STRHUB!STRRMT		:			###LSH
	LB	R9,LTYP,LN		:STAR LINE ?		###LSH
	JE	SIOHS1			:NO, 			###LSH
					:STARLINE, HAVE TO SEND CHECKSUM###LSH
	LR	R9,R6			:BASE ADDRESS FOR CHECKSUM INSTRUCTION
	CKSUM	R2,R9			:CALCULATE PACKET CHECKSUM ###LSH
	STH	R2,0,R7,R6		:VERTICAL CHECKSUM	###LSH
	STH	R3,2,R7,R6		:DIAGONAL CHECKSUM	###LSH
	J	SIOHS2			:			###LSH
SIOHS1	EI	:STRHUB!STRRMT		:			###LSH
	
					:REGULAR LINE, DEPEND ON SWITCH CKSM
	IF	CKSM			:SEND CHECKSUM		###LSH
	LR	R9,R6			:BASE ADDRESS FOR CHECKSUM INSTRUCTION
	CKSUM	R2,R9			:CALCULATE PACKET CHECKSUM
	STH	R2,0,R7,R6		:VERTICAL CHECKSUM	###LSH
	STH	R3,2,R7,R6		:DIAGONAL CHECKSUM	###LSH
	EI	:CKSM

SIOHS2	LH	R2,0A,R1		:PUT QUAD WORD BUFFER ADDRESS ###LSH
	STH	R2,2,R1			:	IN THE CCW

	RBT	LN,SSENT		:NOTE A RECORD IS SENT
	LIS	R0,1			:MARK RECORD AS BEING SENT
	STB	R0,LLXM,R5		
	AHM	R0,RCTRNS,LN		:UPDATE NUMBER OF RECORDS SENT
	IF	STRHUB			:##AL FOR STRLINK
	LB	R3,LKNM,R4,		:GET LINK NUMBER
	AHM	R0,SRCTRS,R3,R3		:UPDATE NUMBER OF RECORDS SENT
	EI
:	R3 gets record number, R4 has link descriptor pointer		###jhl
SIOSN2	LHL	R3,RECN,R5		:get record # from frame to be sent
	NHI	R3,PKTMSZ		:FORM INDEX INTO PACKET TIME TABLE
	AR	R3,R3			:AND FORM HW OFFSET
	LH	R7,FASTC+2,,		:GET CURRENT TIME
	LH	R8,PKTTIM,R3,R4		:GET TIME PACKET WAS MADE OR RE-XMITTED
	STH	R7,PKTTIM,R3,R4		:STORE BACK CURRENT TIME
	SR	R7,R8			:COMPUTE TIME IN QUEUE
	JGEFS	SIOS10			:NO WRAP
	AI	R7,10000
SIOS10	AM	R7,KS.PQC,R4		:ADD CURRENT DELAY INTO RUNNING COUNT
					: -- end --			###jhl
	JR	R10			:RETURN TO CALLER

::*********************************************************************
::
::	SUBROUTINE:	SIOSDW:
::	FUNCTION:	ROUTINE TO SET UP TO TRANSMIT A DWL DATA RECORD.
::			MAINLY COPY DATA FROM DWLXBF TO SIO XMIT BUF
::	CALLING SEQ:	JAL	R10,SIOSDW
::	INPUT:		R1 = POINTER TO CCW BLOCK TO OUTPUT NEXT RECORD
::
::*********************************************************************
	IF	STRHUB
SIOSDW	HS	0
	LHI	R7,42+4			:DWL DATA PATTERN LENGTH +KEY
	LHL	R3,8,R1			:GET OUTPUT BUFFER ADDRESS
	IF	SIBFRL			:SIO BUFFER RELOCATION ###LSH
	SLLS	R3,4			:SHIFT 4 BITS LEFT TO GET BACK
	EI	:SIBFRL			:OUTPUT BUFFER ADDRESS ###LSH
	STH	R7,0,R3			:STORE THE BYTE COUNT
	L	R6,LNKKEY,R4		:GET LNK KEY FROM KD
	ST	R6,2,R3			:STORE THE LNKKEY	
	AR	R3,R7			:DESTINATION ADDRESS TO R3
	L	R2,DWLXBF,R4		:SOURCE ADDR. NOT INCLUDE CT.
	AHI	R2,40			:POINT TO THE LAST HW
	LHI	R0,42			:DWL DATA PATTERN LENGTH
	SLLS	R0,3			:COPY INSTRUCTN LENGTH PARAMETER
	SIS	R0,1

:	COPY	R2,R0			:COPY R0-1 HW'S FROM R2 TO R2+1 
					:	COUNTING BACKWARDS.
	HC	3F20			:MOVE SOURCE TO DESTINATION
	LB	R6,STAFLG,R4
	XHI	R6,DWLXFL
	STB	R6,STAFLG,R4		:RESET THE FLAG
	LH	R2,0A,R1		:PUT QUAD WORD BUFFER ADDRESS
	STH	R2,2,R1			:	IN THE CCW
	JR	R10
	EI	:STRHUB
::*********************************************************************
::
::	OUTPUT STATE:	SIOC -	CHECK FOR SUCCESS OR FAILURE OF CHAINING
::
::*********************************************************************

SIOC	HS	0			:###LSH
	IF	SIBFRL			:###LSH
	L	R1,SIOCO,LN,LN		:CURRENT CCW BLOCK ###LSH
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R1,SIOCO,LN		:CURRENT CCW BLOCK
	EI	:SIBFRL			:###LSH
	LB	R2,0,R1			:GET STATUS
	IF	DB56KB			:IF SIO MONITORING
	JNFS	SIOC2			:SOMETHING HAS HAPPENED...
	JAL	R10,SIOSEE		:NOTHING YET, CHECK FOR TIMEOUT
	J	SIOIDL
	ELSE
	JE	SIOIDL			:CAN'T TELL -- WAIT, <100
	EI	:DB56KB
:	STATUS BYTE
:	0 --  WE'RE NOT SURE, 1 -- CHAINING SUCCEEDED, 2 -- FAILED
SIOC2	SIS	R2,1			:CHAINING SUCCEED?
	JE	SIOC1			:YES, =100
	SIS	R2,1			:FAILURE?
	JEFS	SIOC0			:YES, =200
	CRASH.(.SIER0)			:###wjl OTHERS, >200
:	CHAINING HAS FAILED--WE MUST RESTART OUTPUT FOR NEXT RECORD.
:	SIONO HAS OUTPUT PROGRAM SEQUENCE FROM SION STATE.
SIOC0	HS	0			:###LSH
	IF	SIBFRL			:###LSH
	L	R1,SIONO,LN,LN		:MUST START UP 2ND BLOCK
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R1,SIONO,LN		:MUST START UP 2ND BLOCK
	EI	:SIBFRL			:###LSH
	LB	R0,0,R1			:TEST FOR SIO LINE RE-INITIALIZED
	JNFS	SIOC1			:YES - CONTROL BLOCK IDLE
	LR	R0,LN			:LINE NUMBER * 2
	IF	ISIS
	SRLS	R0,1			:LINE NUMBER
	TBT	R0,SIOPTA		:IS PORT AVAILABLE?		###OAS
	JNFS	SIOPT5			:NO, SKIP SVC
	SVC	IO,0B0			:START OUTPUT
	JAL	R12,SVCE3B		:ERROR, CRASH
SIOPT5	HS	0
	ELSE	:NOT ISIS
	SVC	0F,SV.OSI		:START OUTPUT
	JAL	R12,SVCE0E		:ERROR, CRASH
	EI	:ISIS

:	COME HERE DIRECTLY IF WE CAN CHAIN THIS NEXT RECORD.
:	RECALL THAT SIONO HAS OUTPUT PROGRAM SEQUENCE FROM SION 
:	STATE, AND SIOCO HAS JUMP INSTRUCTION AT SIOCO+4.

SIOC1	HS	0			:###LSH
	IF	SIBFRL			:###LSH
	L	R0,SIOCO,LN,LN		:SWAP NEXT AND CURRENT
	L	R1,SIONO,LN,LN		:	OUTPUT CONTROL BLOCKS
	ST	R0,SIONO,LN,LN
	ST	R1,SIOCO,LN,LN
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R0,SIOCO,LN		:SWAP NEXT AND CURRENT
	LHL	R1,SIONO,LN		:	OUTPUT CONTROL BLOCKS
	STH	R0,SIONO,LN
	STH	R1,SIOCO,LN
	EI	:SIBFRL			:###LSH
	LHI	R0,SION-SEG1		:SET NEW OUTPUT STATE
	STH	R0,SIOTST,LN
	IF	STRHUB
	STH	R0,SIOCNS,LN
	EI	:STRHUB
	J	SIONA			:SEE IF MORE OUTPUT TO CHAIN IN

::*********************************************************************
::
::	OUTPUT STATE:	SIORT -- WAIT FOR RESET TO FINISH BEING SENT.
::	EACH TIME A PING-PONG RESET IS SENT, IT'S OUTPUT TIME IS
::	IS CLOCKED FOR LINE SPEED CALCULATION.  DUE TO THE POLLING
::	OF SIO FOR OUTPUT COMPLETE (WITHIN THE SYLVER LOOP), THERE
::	ARE ALWAYS OCCURENCES OF LATE OBSERVENCE OF OUTPUT COMPLETE.
::	FOR THE 16d RESETS CLOCKED DURING THE RESET SEQUENCE, THE
::	FASTEST CLOCKED SAMPLE IS USED FOR THE LINE SPEED CALCULATION
::	IN AN ATTEMPT TO SOMEWHAT ALLEVIATE THE INACCURACIES IN
::	CALCULATING LINE SPEEDS OF 28.8 AND GREATER.  NOTE -
::	THIS PROBLEM BECOMES MORE APPARENT ON HEAVILY LOADED NODES.
::	FOR ISIS NODES A FUDGE FACTOR IS INTRODUCED TO ATTEMPT TO OFFSET
::	THE EFFECT OF THE LONG TIME BETWEEN SYLVER (FOREGROUND) EXECUTIONS.
::	ISIS SIO SPEED CLOCKING SHOULD NOT BE SUBJECT TO VARIANCES WITH NODE
::	LOAD DUE TO GUARANTEED FOREGROUND FREQUENCY OF EXECUTION.  THE VALUE
::	OF THE FUDGE FACTOR WAS CHOSEN EMPIRICALLY.
::
::*********************************************************************

SIORT	HS	0			:###LSH
	IF	SIBFRL			:###LSH
	L	R1,SIOCO,LN,LN		:WAITING FOR RESET TO FINISH	
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R1,SIOCO,LN		:WAITING FOR RESET TO FINISH	
	EI	:SIBFRL			:###LSH
	LB	R0,0,R1			:STATUS 2 MEANS "FINISHED"
	SIS	R0,2			:IF IT'S NOT A 2 THEN RETURN 
	JN	SIOIDL			:	TO SERVICE NEXT LINE
	LH	R1,FASTC+2,,		:CALCULATE TIME SINCE OUTPUT
	SH	R1,LNRTIM,LN,		:WAS STARTED
	CHVR	R1,R1			:ADJUST TO HALFWORD VALUE

	IF	ISIS
	SIS	R1,6			:ISIS FUDGE FACTOR
	JGEFS	SIOR18			:CHECK FOR NEGATIVE INDEX
	LIS	R1,0			:DON'T LET IT GO BELOW 0
SIOR18	HS	0
	EI	:ISIS

	LIS	R2,1			:ASSUME SLOWEST SPEED
	CLHI	R1,0C4			:IF RESET TOOK OVER C4 CLOCK TICKS,
	JGEFS	SIOR1C			:IT'S 2.4KB, REPORT VALUE 01
	LB	R2,SIOSPD,R1,		:GET SIO LINE SPEED FROM TABLE
SIOR1C	LHL	R1,BAUDRT,LN,		:GET PREVIOUS SPEED CALCULATION
	CLR	R2,R1			:IF NEW CALC IS FASTER, USE IT
	JLEFS	SIOR19			:OTHERWISE LEAVE PREVIOUS CALC
	STH	R2,BAUDRT,LN,		:SAVE THE LINE SPEED
SIOR19	LHI	R0,SIOIDL-SEG1		:GO TO THE IDLE STATE
	STH	R0,SIOTST,LN
	J	SIOIDL

::*********************************************************************
::
::	TABLE:	 SIOSPD - INDEXED BY THE NUMBER OF FASTC CLOCK TICKS
::	TO TRANSMIT A 1000d-BIT RESET PACKET. THE TABLE VALUE IS SAVED
::	IN 'BAUDRT', THE LINE SPEED ARRAY.
::
::		600d/FASTCTICKS = KBS/SEC	
::
::	!! THIS TABLE ASSUMES RATE = $A 600 !!
::
::*********************************************************************

SIOSPD	HS	0
	NOLIST
	RE	0A-00; BC 1F; ER	:00 - 09, MS	 (UP     - 66.6 KB)
	RE	0D-0A; BC 17; ER	:0A - 0C, 56  KB (60  KB - 50   KB)
	RE	10-0D; BC 14; ER	:0D - 0F, 48  KB (46  KB - 40   KB)
	RE	15-10; BC 10; ER	:10 - 14, 38.4KB (37.5KB - 30   KB)
	RE	1C-15; BC 0C; ER	:15 - 1B, 28.8KB (28.5KB - 22.2 KB)
	RE	27-1C; BC 08; ER	:1C - 26, 19.2KB (21.4KB - 15.78KB)
	RE	36-27; BC 06; ER	:27 - 35, 14.4KB (15.0KB - 11.3 KB)
	RE	48-36; BC 04; ER	:36 - 47,  9.6KB (11.1KB - 8.4  KB)
	RE	63-48; BC 03; ER	:48 - 62,  7.2KB ( 8.3KB - 6.1  KB)
	RE	0C4-63; BC 02; ER	:63 - C3,  4.8KB (6.06KB - 3.07 KB)
	RE	0C5-0C4; BC 01; ER	:0C4 - UP, 2.4KB (3.06KB -    DOWN)
	HS	0
	LIST

::*********************************************************************
::
::	OUTPUT STATE:	SIORS - SEND SINGLE RESET FOR PING-PONG SEQ AND
::				 SPEED CLOCKING
::
::*********************************************************************

SIORS	LHI	R9,SIORT-SEG1		:CHANGE TO SIORT TO CLOCK SPEED
	J	SIOR1			:FINISH PREV OUTPUT, SEND RESET

::*********************************************************************
::
::	OUTPUT STATE:	SIORR - SEND CONTINUOUS STREAM OF RESETS
::
::*********************************************************************

SIORR	LHI	R9,SIORR-SEG1		:MAINTAIN SAME STATE

::*********************************************************************
::
::	COMMON SIO OUTPUT:
::	WAIT FOR PREVIOUS OUTPUT TO COMPLETE BY DISMISSING TO SIOIDL.
::	WHEN COMPLETE, CHANGE SIO OUTPUT STATE AS INDICATED BY R9 AND
::	START NEW OUTPUT.  ALSO MARK RESET OUTPUT START TIME.
::
::*********************************************************************

SIOR1	HS	0			:###LSH
	IF	SIBFRL			:###LSH
	L	R1,SIOCO,LN,LN		:GET CURRENT BLOCK ADDRESS
	ELSE	:SIBFRL			:###LSH
	LHL	R1,SIOCO,LN		:GET CURRENT BLOCK ADDRESS
	EI	:SIBFRL			:###LSH
	LB	R0,0,R1			:CHECK STATUS OF OUTPUT
	JE	SIOIDL			:CURRENT BLOCK IS BUSY
	SIS	R0,1
	JE	SIOIDL			:###wjl
	STH	R9,SIOTST,LN		:MAYBE CHANGE STATE
	IF	SIBFRL			:###LSH
	L	R2,SIORSP,LN,LN		:QUADWORD PNTR TO RESET PATTERN
	ELSE	:NOT SIBFRL
	LHL	R2,SIORSP,LN		:QUADWORD PNTR TO RESET PATTERN
	EI	:SIBFRL			:###LSH
	SRLS	R2,4
	EXHR	R2,R2			:STORE BOTH ADDRESS AND
	ST	R2,2,R1			:FOLLOWING STOP COMMAND
SIR12	LIS	R0,1			:SET OUTPUT COMMAND
	STH	R0,0,R1
	LR	R0,LN			:LINE NUMBER * 2
	IF	ISIS
	SRLS	R0,1			:LINE NUMBER
	TBT	R0,SIOPTA		:IS PORT AVAILABLE?		###OAS
	JNFS	SIOPT6			:NO, SKIP SVC
	SVC	IO,0B0			:START OUTPUT
	JAL	R12,SVCE3B		:ERROR, CRASH
SIOPT6	HS	0
	ELSE	:NOT ISIS
	SVC	0F,SV.OSI		:START OUTPUT
	JAL	R12,SVCE0E
	EI	:ISIS

	LH	R0,FASTC+2,,		:SAVE TIME FOR SPEED CALCULATION
	STH	R0,LNRTIM,LN,
	IF	STRHUB
	LB	R0,LTYP,LN		:IF STAR LINE
	JE	SOR22
	L	R0,KDLN,LN,LN		:IF LINE NOT ATTACHED,OLD LOGIC
	JLFS	SOR22
	LHI	R0,RSTSTA		:ONLY RSTSTA BIT ON
	STB	R0,STAFLG,R4		:RESET RSTXFG FLAG
SOR22	EI	:STRHUB
	JFS	SIOIDL

:	SWAP CURRENT AND NEXT OUTPUT CCW BLOCKS
	IF	0			:###wjl
SIOR2	HS	0			:###LSH
	IF	SIBFRL			:###LSH
	L	R0,SIONO,LN,LN
	L	R1,SIOCO,LN,LN
	ST	R0,SIOCO,LN,LN
	ST	R1,SIONO,LN,LN
	ELSE	:NOT SIBFRL		:###LSH
	LHL	R0,SIONO,LN
	LHL	R1,SIOCO,LN
	STH	R0,SIOCO,LN
	STH	R1,SIONO,LN
	EI	:SIBFRL			:###LSH
	EI	:0

:	LOOP TIL ALL SIO LINES CHECKED

SIOIDS	LIS	R0,0			:ENTRY POINT IF KS.SEM IS TO BE CLEARED
	STH	R0,KS.SEM,R4		:CLEAR SEMAPHORE WITH SYLVEX

SIOIDL	
	AIS	LN,2			:ADVANCE TO NEXT LINE
	CLHI	LN,NLINES*2		:DONE?
	JL	SIO1			:NO - CONTINUE
	J	SDSMIS			:ELSE DISMISS

::*********************************************************************
::
::	SUBROUTINE:	SIOSEE:
::	FUNCTION:	SEE IF A BUSY SIO LINE HAS TIMED OUT ON AN OUTPUT
::			DMA OPERATION INDICATING PROBABLE FAULTY HARDWARE
::	CALLING SEQ:	JAL	R10,SIOSEE
::	PRESERVED:	R1, R10
::	DESTROYED:	R0, R2, R3, R8, R9
::	CALLS:		JAL	R9,FSTMSC
::			JAL	R10,SUP12
::
::*********************************************************************

	IF	DB56KB

SIOSEE	LH	R3,SIODMA-SBASE,LN	:GET TIMEOUT TIME
	JER	R10			:IF 0, CRYPTO MSG HAS ALREADY BEEN SENT
	SH	R3,FASTC+2,,		:SUBTRACT FROM CURRENT TIME
	CHVR	R3,R3			:USE HW ARITHMETIC
	JGR	R10			:STILL NOT TIMED OUT, RETURN
	XHI	R3,-1			:COMPLEMENT R3 (APPROXIMATE -R3)
	AHI	R3,$A61			:GET TIMEOUT INTERVAL
	JAL	R9,FSTMSC,,		:CONVERT TO MSEC FOR REPORTING PURPOSES
	ST	R1,SEESAV		:SAVE R1 AND R10
	ST	R10,SEESAV+4
	STH	R3,SUPMBF+2		:STORE MILLISECONDS 
	SRLS	LN,1			:GET TRUE LINE NUMBER
	STH	LN,SUPMBF+4		:AND STORE IN HW3
	LHI	R0,NR.K56		:NODE REPORT, 56KB DMA TIMEOUT DIAGNSTC
	STH	R0,SUPMBF
	JAL	R10,SUP12,,		:REPORT BOTH TO SUP AND TO XRAY
	SLLS	LN,1			:RESTORE LINE NUMBER
	LIS	R0,0			:CLEAR SIODMA
	STH	R0,SIODMA-SBASE,LN	: SO ONLY ONE CRYPTO MSG IS SENT
	L	R1,SEESAV		:RESTORE R1, R10
	L	R10,SEESAV+4
	JR	R10			:RETURN
	EI	:DB56KB

	EI	:SILINS

:	DISMISS SYLVER TO ISIS OR SOLO EXEC LOOP

SDSMIS	HS	0
	IF	ISIS	
	IF	DB.CPU
	LH	R0,CPUTFL,,		:ARE WE MEASURING CPUTIL?
	JGE	SDSMS8			:NO
	IF	DSPCNT
	LIS	R0,1
	AHM	R0,CSYTCT,,		:BUMP SYLVER DISMISS COUNT
	EI	:DSPCNT
	IF	DB.CLK
	LHL	R1,LO.CLK,,		:GET SEGF RELATIVE POINTER TO SLOT0 CLK
	LHL	R1,SEGF,R1,		:GET SLOT0 CLOCK
	SH	R1,CSYTSC,,		:COMPUTE SLOT TIME DIFFERENCE
	JGEFS	SDSMS9			:CHECK FOR HW WRAP
	AI	R1,10000		:ADJUST FOR HW WRAP
SDSMS9	AHM	R1,CSYTTM,,		:AND ACCUMULATE
	LH	R0,CPUTCD,,		:IS A ROUTINE BEING MEASURED
	JLFS	SDSMS7			:NO, MUST BE MEASURING EXECTIME
	AHM	R1,CPUTFC,,		:THIS TIME NOT COUNTED BY BG (ROUTINE)
	JFS	SDSMS6
SDSMS7	AHM	R1,EXCTM1,,		:THIS TIME NOT COUNTED BY BG (EXEC)
SDSMS6	L	R0,FASTC,,		:GET CURRENT TIME
	S	R0,CSYTFC,,		:CALCULATE DURATION THIS PASS
	SR	R0,R1			:SEE IF SLOT0 CLK INTRVL SAME AS FASTC
	CLHI	R0,2			:WITHIN 1 FASTC CLOCK
	JLFS	SDSMS8			:DIFFERENCE CLOSE
	LIS	R1,1			:BIG DIF, MUST HAVE BEEN FG DISMISSED
	AHM	R1,CSYFRC,,		:BUMP FORCED FG DISMISS COUNT
	EI	:DB.CLK
SDSMS8	HS	0
	EI	:DB.CPU
	SVC	FAST,0
	J	SYLVER
	ELSE	:NOT ISIS
	LIS	R0,0
	ST	R0,ABENPC		:CLEAR ERROR-ROUTINE ADDRESS LOCATION
	J	EXDISM
	EI	:ISIS

	SUBTTL	LINKER (SYLVER - Sync input processor)

::*********************************************************************
::
::	ENTRY POINT:	SYLMRK:
::	FUNCTION:	COME HERE TO SEARCH FOR BEGINNING OF FRAME
::	CALLING SEQ:	LHL	R1,QSYLVR,LN
::			J	SEG1,R1,,
::	INPUT:		R11 = INPUT DATA LEAD POINTER
::			R12 = INPUT DATA TRAILING POINTER
::			R13 = INPUT RING ADDRESS
::			R14 = LN = LINE NUMBER * 2
::			R15 = KD = LINK DESCRIPTOR ADDRESS
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R9,NETDGN
::			JAL	R0,TSFMRK
::			JAL	R2,SYALGN
::	RETURNS:	J	SYLRET
::
::*********************************************************************

SYLMRK	HC	35BD			:SCAN R11,R13

	JFS	SYLHIT			:FOUND 'START BIT'
	J	SYLRET			:NOT YET, TRY NEXT LINE

:	FOUND START OF RECORD -- GUARANTEED AT LEAST 16 BYTES OF
:	DATA IN THE INPUT RING

SYLHIT	HS	0
	LHL	R3,0,R13,R12		:GET FIRST HALFWORD OF RAW DATA
	LCS	R1,1			:SET UP MASK
	XR	R1,R3			:SET MARK BITS TO ZERO

	JFFOH	R1,SYMK10		:GET LEFT SHIFT COUNT TO R2
	IF	DB.DEB
	DBOOPS
	ELSE	:NOT DB.DEB
:	SYNC RING SCAN INSTRUCTION INDICATES ZERO BIT FOUND, BUT LOAD
:	HALF-WORD YIELDS ALL ONES...FORMAT DIAGNOSTIC NODE REPORT.
	IF	ISIS
:	WE CAN'T CALL REPORTING ROUTINE SINCE WE ARE IN FOREGROUND. SET
:	UP RELEVANT DATA IN WORK AREA - SWITCH WILL TEST SEMAPHORE (SUPIBF).
	STB	LN,SUPIBF+3		:SAVE LINE NUMBER AND
	STH	R13,SUPIBF+4		:	ROUGH POINTER TO PROBLEM AREA
	LIS	R8,DR.SYM
	STB	R8,SUPIBF+2		:DIAGNOSTIC SUB-TYPE FOR SYNC SCAN ERR
	STH	R8,SUPIBF		:POSITIVE VALUE MEANS MSG READY TO SHIP
	ELSE	:NOT ISIS
	STB	LN,SUPMBF+3		:SAVE LINE NUMBER AND
	STH	R13,SUPMBF+4		:	ROUGH POINTER TO AREA OF MEMORY
	LIS	R8,DR.SYM		:GET DIAGNOSTIC SUB-TYPE
	JAL	R9,NETDGN,,		:FORMAT CRYPTOGRAM, NODE REPORT
	GL	NETDGN
	EI	:ISIS
	J	SYLRET			:AS IF NO START BIT FOUND
	EI	:DB.DEB

SYMK10	AIS	R12,2			:INC TRAILING POINTER
	NHI	R12,SVNBSZ-2		:CORRECT FOR WRAP AROUND
	LHL	R4,0,R13,R12		:PICK UP NEXT 16 BITS
	LR	R5,R3			:COPY OF FIRST 16 BITS
	SLL	R5,0,R2			:LEFT ALIGN THE BITS
	LIS	R10,0F			:GET COMPLEMENT OF LEFT
	SR	R10,R2			:	SHIFT COUNT TO R10
	SRL	R4,1,R10		:ALIGN REST OF BITS
	OR	R4,R5			:R4 CONTAINS HEADER
	NI	R4,0FFFF		:	HALFWORD -- RIGHT ALIGNED
	JNFS	SYMK12
	LIS	R0,1			:GOT 16 BITS OF ZEROES - INDICATE
	AHM	R0,SPACNG,LN,		:	SPACING DETECTED ON INPUT
	J	SYNEXT

SYMK12	L	KD,KDLN,LN,LN		:GET LINK DESCRIPTOR ADDRESS
	JL	SYLUAL			:GO TREAT RECORD ON UNASSIGNED LINE
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR TRACING DESIRED
	JNFS	TSLB01			:NO
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	STH	R4,TSFTBL+2,R15		:STORE POTENTIAL HEADER
	LIS	R0,TS.HDR
	STB	R0,TSFTBL,R15		:STORE ENTRY TYPE
	L	R15,TSRSVE		:RESTORE R15
TSLB01	EI	:TSTSZE

:	RECORD RECEIVED ON ATTACHED TYMNET-II LINK.
:	REGISTER 4 CONTAINS FIRST HALFWORD OF HEADER -- RIGHT ALIGNED.

SYBT2	EXBR	R0,R4			:ISOLATE BORI
	NHI	R0,0F0			:
	CLB	R0,BORI,KD		:IS IT BORI?
	JN	SYBT22			:NO, SKIP

:	TYMNET II RECORD RECEIVED. NOT RESET OR NULL.
:	MAKE SURE ALL THE DATA IS IN INPUT RING.

	EXBR	R1,R4			:EXTRACT BYTE COUNT INDEX
	NHI	R1,0F
	LB	R1,SYTWCN,R1		:GET ACTUAL COUNT FROM TABLE

:	SEE IF COMPLETE RECORD HAS BEEN RECEIVED

SYLCHK	LR	R0,R11			:COPY OF LEAD POINTER
	SR	R0,R12			:RECEIVED COUNT=LEAD-TRAIL
	JGEFS	SYCH10			:SKIP IF NO WRAP AROUND
	AHI	R0,SVNBSZ		:CORRECT FOR WRAP AROUND

SYCH10	SIS	R0,8			:NEED TWO WORDS BEYOND EOR
	CR	R0,R1			:GOT THEM?
	JG	SYWT20			:YES
					:NO, DONE FOR NOW

:	SAVE COUNT, SHIFT, HEADER, AND SET TO WAIT FOR RECEPTION
:	OF COMPLETE RECORD

SYLSAV	STH	R1,SYBCNT,LN		:SAVE BYTE COUNT
	STH	R10,SYLSHF,LN		:SAVE LEFT SHIFT -- COMPLEMENTED
	STH	R4,SYHEDR,LN,LN		:SAVE ALIGNED HEADER
	STH	R3,SYHEDR+2,LN,LN	:SAVE FIRST 16 BITS RAW DATA
	LHI	R0,SYWAIT-SEG1		:SET 'STATE'
	STH	R0,QSYLVR,LN
	J	SYLRET			:DONE

:	CHECK FOR EXPANDED RESET 
SYBT22	HS	0
	IF	XRESET			:###wjl
	CLHI	R4,TXRSHD		:Expanded Reset header?
	JN	SYBT25			:no
	JAL	R9,SYLXRS		:yes, store Reset in SYSTOR
	L	KD,KDLN,LN,LN		:restore link descriptor address
	LHL	R0,NDID,KD		:get neighbor # from link descriptor
	CL	R0,SYSTOR+2,,		:compare to FW following Reset header
	JE	SYLRAL			:equal-reset received on attached line 
	J	SYLERR			:no - line error

::*********************************************************************
::
::	SUBROUTINE:	SYLXRS:
::	FUNCTION:	Check to see if complete Expanded Reset has been
::			received and move to temporary storage.
::	CALLING SEQ:	JAL	R9,SYLXRS  Called from SYBT22 for reset
::			on assigned line and from SYLUAL for reset on
::			unassigned line.
::	INPUT:		R3, R4, R10, R11, R12, LN
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R2,SYALGN
::
::*********************************************************************

:	CHECK TO SEE IF COMPLETE EXPANDED RESET HAS BEEN RECEIVED
SYLXRS	HS	0
	EXBR	R1,R4			:extract byte count index
	NHI	R1,0F
	LB	R1,SYTWCN,R1		:get actual count from table
	LR	R0,R11			:make copy of lead pointer
	SR	R0,R12			:received count = lead-trail
	JGEFS	SYLX02			:skip if no wrap around
	AHI	R0,SVNBSZ		:correct for wrap around
SYLX02	SIS	R0,8			:need 2 words beyond EOR
	CR	R0,R1			:got them?
	JG	SYLX04			:yes

:	NO, SAVE RETURN, SHIFT, HEADER, AND SET TO WAIT FOR COMPLETION.
	ST	R9,SYLLNK,LN,LN		:save return
	STH	R1,SYBCNT,LN		:save byte count
	STH	R10,SYLSHF,LN		:save left shift -- complemented
	STH	R4,SYHEDR,LN,LN		:save aligned header
	STH	R3,SYHEDR+2,LN,LN	:save 1st 16 bits raw data
	LHI	R0,SRWAIT-SEG1		:set 'state'
	STH	R0,QSYLVR,LN
	J	SYLRET			:done for now

::*********************************************************************
::
::	ENTRY POINT:	SRWAIT:
::	FUNCTION:	Check to see if complete Expanded Reset has been
::			received
::	CALLING SEQ:	LHL	R1,QSYLVER,LN
::			J	SEG1,R1,,
::	INPUT:		R11, R12, LN
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R2,SYALGN
::	RETURNS:	JLE	SYLRET
::
::*********************************************************************

SRWAIT	HS	0
	LR	R0,R11			:make copy of lead pointer
	SR	R0,R12			:received count = lead-trail
	JGEFS	SRWA02			:skip if no wrap around
	AHI	R0,SVNBSZ		:correct for wrap around
SRWA02	SIS	R0,8			:need 2 words beyond EOR
	CH	R0,SYBCNT,LN		:got them?
	JLE	SYLRET			:not yet

	LHI	R0,SYLMRK-SEG1		:yes, next time look for start
	STH	R0,QSYLVR,LN		: of new record
	LHL	R4,SYHEDR,LN,LN		:get aligned HW of header
	LHL	R3,SYHEDR+2,LN,LN	:get 1st HW of raw data
	LHL	R10,SYLSHF,LN		:get left shift count (complemented)
	L	R9,SYLLNK,LN,LN		:get return
	LHL	R1,SYBCNT,LN

:	MOVE EXPANDED RESET INTO TEMPORARY STORAGE
SYLX04	SRHLS	R1,1			:convert to halfword count
	AIS	R1,1			:move VRC also
	CLHI	R1,SYSTSZ		:compare with sync storage size
	JG	SYLERR			:future reset may be too large for us
	LA	R8,SYSTOR		:put data in temp storage
	JAL	R2,SYALGN		:move the data
	JN	SYLERR			:CC<>0 => bad checksum
	JR	R9			:return
	EI	:XRESET	###wjl

:	MUST BE SHORT RECORD -- ALIGN IT AND LOOK FOR POSSIBLE RECORD TYPES

SYBT25	LIS	R1,3			:MOVE 4 HALFWORDS
	LA	R8,SYSTOR		:STORE IN TEMPORARY AREA

	JAL	R2,SYALGN		:MOVE THE DATA

	JN	SYLERR			:BAD CHECKSUM

:	GOOD CHECKSUMS -- R4 STILL HAS FIRST HALFWORD

SYBT27	LHL	R0,NDID,KD		:GET NEIGHBOR # FROM LINK DESCRIPTOR
	CLH	R0,SYSTOR+2,,		:COMPARE TO HW FOLLOWING RESET HEADER
	JE	SYLRAL			:RESET RECEIVED ON ATTACHED LINE
SYBT28	L	R4,SYSTOR		:GET FIRST 32 BITS OF DATA
	CLI	R4,TWDMHD		:DUMMY RECORD?
	JN	SYLERR			:NO - LINE ERROR

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR TRACING DESIRED
	JNFS	TSLB02			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:MAKE NEW EVENT ENTRY
	LIS	R0,TS.DUM
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE
	LIS	R0,0
	STH	R0,TSFTBL+2,R15		:NO DATA FOR HEADER FIELD
	L	R15,TSRSVE		:RESTORE R15
TSLB02	EI	:TSTSZE
	LR	R0,LN			:GET LINE NUMBER
	SRHLS	R0,1
	SBT	R0,LNGREC		:SET GOOD REC REC'D FLAG
	J	SYNEXT			:CHECK FOR MORE TO DO

::*********************************************************************
::
::	ENTRY POINT:	SYWAIT:
::	FUNCTION:	COME HERE TO SEE IF ENTIRE PHYSICAL RECORD
::			IS IN THE RING YET
::	CALLING SEQ:	LHL	R1,QSYLVR,LN
::			J	SEG1,R1,,
::	INPUT:		R11 = INPUT DATA LEAD POINTER
::			R12 = INPUT DATA TRAILING POINTER
::			R13 = INPUT RING ADDRESS
::			R14 = LN = LINE NUMBER * 2
::			R15 = KD = LINK DESCRIPTOR ADDRESS
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R9,SYFORM
::			JAL	R0,TSFMRK
::			JAL	R8,TSNSPK
::	RETURNS:	J	SYLRET
::
::*********************************************************************

SYWAIT	LR	R0,R11			:COPY LEAD POINTER
	SR	R0,R12			:BYTE COUNT=LEAD-TRAIL
	JGEFS	SYWT10			:ADJUST FOR WRAP AROUND
	AHI	R0,SVNBSZ

SYWT10	SIS	R0,8			:NEED TWO FULL WORDS AFTER EOR
	CH	R0,SYBCNT,LN		:GOT ENOUGH DATA?
	JLE	SYLRET			:NOT YET

	LHI	R0,SYLMRK-SEG1		:YES, NEXT TIME LOOK FOR
	STH	R0,QSYLVR,LN		:	START OF NEW RECORD

	LHL	R4,SYHEDR,LN,LN		:GET ALIGNED HALFWORD
	LHL	R3,SYHEDR+2,LN,LN	:FIRST HALFWORD OF RAW DATA
	L	KD,KDLN,LN,LN		:LINK DESCRIPTOR ADDRESS
	JL	SYNEXT			:LINK WENT OUT WHILE WE WERE WAITING...
	LHL	R1,SYBCNT,LN		:GET BYTE COUNT
	LHL	R10,SYLSHF,LN		:LEFT SHIFT COUNT (COMPLEMENTED)

SYWT20	SRHLS	R1,1			:CONVERT TO HALFWORD COUNT
	AIS	R1,1			:MOVE VRC ALSO

:	ALL DATA RECEIVED FOR RECORD ON TYMNET II LINK

SYFOT2	LHL	R0,0,R13,R12		:RECORD NUMBER IS THE BYTE
	LR	R2,R12			:FOLLOWING THE HALFWORD WE'VE ALREADY
	AIS	R2,2			:ALIGNED. EXTRACT ANOTHER HALFWORD
	NHI	R2,SVNBSZ-2		:HERE -- BUT DON'T MODIFY NORMAL
	LHL	R2,0,R13,R2		:POINTERS.
	EXHR	R0,R0
	OR	R0,R2
	SRL	R0,9,R10
	LBR	R0,R0			:R0=REC # -- RIGHT ALIGNED

	LH	R2,LAS,KD		:GET LAST ACK SENT
	SHI	R2,07F
	SR	R0,R2
	LBR	R0,R0
	AR	R2,R0			:R2= REC # -- SIGN EXTENDED

	JAL	R9,SYFORM

	IF	TSTSZE
	LR	R1,R4			:PRESERVE HEADER
	EI	:TSTSZE
	LH	R2,LAR,KD		:LAST ACK RECEIVED
	SR	R4,R2			:ACK OK IF
	LBR	R4,R4			:	LAR<=ACK<=LAR+WSIZ
	CLB	R4,WSIZ,KD		:IS ACK OK?
	JGFS	SYLBAK			:NO

:	GOOD ACK RECEIVED -- UPDATE 'NEXT REC TO XMIT'

SYLGDK	AR	R2,R4			:GET MOST RECENT ACK
	STH	R2,LAR,KD		:AND UPDATE LAR FIELD
	J	SYNEXT			:CONTINUE WITH NEXT PACKET OR LINK

:	BAD ACK REC'D -- RECORD AND FINISH UP

SYLBAK	HS	0
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB10			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BAK
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD ACK)
	STH	R1,TSFTBL+2,R15		:STORE PACKET HEADER (SAVED IN R1)
	LR	R1,R15			:SAVE INDEX REGISTER AND
	L	R15,TSRSVE		:	RESTORE R15 (KD)
	LH	R0,LAR,KD		:GET LAST ACK RECEIVED AND
	STB	R0,TSFTBL+4,R1		:	STORE IN EVENT ENTRY	###OAS
	LIS	R0,0		:PROVIDE OPPORTUNITY TO PATCH THIS 'LHL' TO A
	LHL	R0,TSLINK	: 'STH' TO TERMINATE TRACING AND EXAMINE
				: HISTORY PRIOR TO BAD ACK OCCURRENCE.
TSLB10	EI	:TSTSZE
	LB	R0,NLAT,KD		:BAD ACKS CAN OCCUR LEGITIMATELY ON
	SIS	R0,1			: MULTI-LINE LINKS IF SUBSEQUENT SHORT
	JG	SYNEXT			: PACKET OVERTAKES PRIOR PACKET W/ OLD
					: ACK. DON'T COUNT...
	LIS	R0,1
	AHM	R0,BADACK,LN,		:RECORD OCCURRENCE OF BAD ACK
	J	SYNEXT			:GO LOOK FOR NEXT RECORD

:	RESET RECEIVED ON EITHER T-II OR T-I ATTACHED LINE.
:	PUT LINE IN LIMBO AND TELL LINKER TO DETACH IT.

SYLRAL	HS	0
	LR	R1,LN			:GET LINE NUMBER
	SRHLS	R1,1
	TBT	R1,INHRST		:RESET INHIBITED?
	JN	SYNEXT			:YES

	LCS	R0,1			:NO, PUT LINE IN LIMBO
	ST	R0,KDLN,LN,LN
	LIS	R0,0
	IF	ISIS
	SVC	IO,60
	ELSE	:solo
 	SVC	0F,SV.CSY
	EI	:ISIS
	SBT	R1,LINDET		:TELL LINKER TO DETACH
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB09			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RST
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (RESET RECEIVED)
:	DETERMINE(* WHETHER TYMNET-I OR*) TYMNET-II LINK.(*T-I*)RESET
:	HEADER(*IS IN R4,*) T-II IS IN 'SYSTOR'.
	L	R0,SYSTOR		:NO, TYMNET-II - GET 4 BYTES OF RESET 
	ST	R0,TSFTBL+2,R15		:AND STORE (CLOBBER HI-ORDER
					:HALFWORD OF FASTC) 
TSLB08	AIS	R15,TSESZE
	NHI	R15,TSTSZE-1		:ADVANCE TO NEXT ENTRY AND CLEAR
	LIS	R0,0			:	IT TO EASE FINDING END OF
	ST	R0,TSFTBL,R15		:	TRACE HISTORY
	ST	R0,TSFTBL+4,R15
	STH	R0,TSLINK		:INHIBIT FURTHER TRACING
	L	R15,TSRSVE

	JAL	R8,TSNSPK		:SAVE MOST RECENT PACKETS IN AND OUT

TSLB09	EI	:TSTSZE
	LIS	R0,3			:SET DETACH REASON
	STB	R0,DREASN,R1,
	LHI	R0,1F-PLINKR		:SCHEDULE LINKER
	SBT	R0,TLINKR
	JFS	SYNEXT

:	COME HERE WHEN 'NOISE' SEEN ON LINE

SYLERR	HS	0
	LIS	R0,1			:INC COUNTER
	AHM	R0,LINERR,LN,		:INC ERROR COUNTER

:	COME HERE TO LOOK AT NEXT HALFWORD
:	R3 CONTAINS LAST HALFWORD OF RAW DATA
:	R10 CONTAINS LEFT SHIFT FACTOR -- COMPLEMENTED

SYNEXT	LCS	R1,1			:SET TO MASK BITS ALREADY USED
	SLL	R1,1,R10		
	LHL	R3,0,R13,R12		:GET LAST 1/2 WD LOOKED AT
	OR	R3,R1			:SET THEM TO MARKS
	STH	R3,0,R13,R12		:AND STORE FOR POSTERITY
	J	SYLMRK			:GO LOOK FOR NEW RECORD

:	DATA RECEIVED ON UNASSIGNED LINE -- SEE IF IT IS RESET,
:	DOWNLINE LOAD DATA, OR GARBAGE.  R4 contains first HW of Header.

SYLUAL	HS	0
	IF	TSTSZE
	JAL	R2,TSFUAL		:TEST IF THIS LINE IS OF INTEREST
	EI	:TSTSZE
	AIS	KD,1			:IF LINE IN LIMBO
	JE	SYNEXT			:	JUST IGNORE

	TBT	LN,DWLDSP,,		:IS THIS A DWL LINE?
	JN	SYLDLL			:YES, SKIP

	IF	XRESET			:Expanded Reset	###wjl
	LR	R0,R4			:copy header halfword
	NHI	R0,0FFE0		:mask out 'subseq' bit, ping pong count
	CLHI	R0,TXRSHD		:New Link Expanded Reset?
	JN	SYLRES			:no
SYLU02	JAL	R9,SYLXRS		:store Reset in SYSTOR
	LR	R2,LN			:Line Number*2
	SRHLS	R2,1
	TBT	R2,INHRST		:reset inhibited?
	JN	SYNEXT			:yes
	LHL	R5,SDLN,LN		:ok, get Reset descriptor address
	AHI	R5,VSDSZ-2		:address of last destination HW to R1+1
	LA	R4,SYSTOR+(VSDSZ-2)	:address of last source HW to R1
	LHI	R1,10*((VSDSZ/2)-1)	:10*(numberof HW's -1)
	COPY	R4,R1			:copy Reset from temporary storage
	J	SYLR02
	EI	:XRESET	###wjl

SYLRES
SYLUA5	LIS	R1,6			:MOVE 6 HALFWORDS OF RESET INTO SYSTOR
	LA	R8,SYSTOR		:PUT DATA IN TEMP STORAGE
	JAL	R2,SYALGN		:MOVE THE DATA
	LR	R0,R4			:COPY HEADER HALFWORD
	NHI	R0,0FFF0		:MASK OUT PING PONG COUNT
	CLHI	R0,TTRSHD		:TYMNET-II NEW LINK RESET?
	JE	SYLRDL			:YES
	CLHI	R0,TSRSHD		:TYMNET-II SUBSEQUENT LINE RESET?
	JEFS	SYLRDL			:YES
	L	R4,SYSTOR		:NO TRY T-II NULL RECORD
	CLI	R4,TWDMHD		:MIGHT RECEIVE WHILE WAITING ON LINKER
	JN	SYLERR			:NO, MUST BE NOISE
	J	SYNEXT			:YES, IGNORE IT

:	RESET RECEIVED

SYLRDL	LR	R2,LN			:LINE NUMBER
	SRHLS	R2,1
	TBT	R2,INHRST		:RESET INHIBITED?
	JN	SYNEXT			:YES
	LHL	R5,SDLN,LN		:NO, RESET DESCRIPTOR ADDRESS
	L	R4,SYSTOR		:SAVE FIRST WORD OF RESET FOR LINKER
	ST	R4,VRSTP,R5		:SAVE FOR USE BY LINKER
	L	R0,SYSTOR+8		:NEIGHBOR VERSION NUMBER FROM RESET,
	ST	R0,VRSTP+4,R5		:	IF PRESENT

SYLR02	SBT	R2,VRSTDL		:TELL LINKER TO LOOK AT IT
	SBT	R2,LINATT		:AND TO ATTACH THE LINE
	LHI	R0,01F-PLINKR		:AND SCHEDULE THE LINKER
	SBT	R0,TLINKR
	J	SYNEXT

:	DATA RECEIVED ON LINE BEING DOWNLINE LOADED

SYLDLL	CLHI	R4,DWNLHD		:DOWNLINE LOAD HEADER?
	JN	SYNEXT			:NO, IGNORE IT

	STH	R10,SYLSHF,LN
	LHI	R0,SYLDWT-SEG1		:AND SET TO WAIT FOR DATA
	STH	R0,QSYLVR,LN

::*********************************************************************
::
::	ENTRY POINT:	SYLDWT:
::	FUNCTION:	COME HERE WHEN WE ARE WAITING FOR THE TARGET MACHINE
::			TO COMPLETE TRANSMISSION OF A DWL RECORD.
::	CALLING SEQ:	LHL	R1,QSYLVR,LN
::			J	SEG1,R1,,
::	INPUT:		R11 = INPUT DATA LEAD POINTER
::			R12 = INPUT DATA TRAILING POINTER
::			R13 = INPUT RING ADDRESS
::			R14 = LN = LINE NUMBER * 2
::			R15 = KD = LINK DESCRIPTOR ADDRESS
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R2,SYALGN
::	RETURNS:	J	SYLRET
::
::*********************************************************************

SYLDWT	LR	R0,R11			:COPY OF LEAD POINTER
	SR	R0,R12			:WAIT FOR 42+8 BYTES
	JGEFS	SYLDW5			:SKIP IF NO WRAP
	AHI	R0,SVNBSZ
SYLDW5	SIS	R0,8
	CHI	R0,42			:GOT ALL THE DATA?
	JLE	SYLRET			:NO

	LHI	R0,SYLMRK-SEG1		:YES, NEXT TIME LOOK FOR NEW PACKET
	STH	R0,QSYLVR,LN
	LHL	R10,SYLSHF,LN		:GET SHIFT COUNT
	LIS	R8,1
	AHM	R8,DWLCLI,,
	LH	R8,DWTEST,,		:GET THE DWLIN SEMAPHORE
	JL	SYLDW7			:<0 MEANS DWLIN IS USING DWQUEQ..
					:...SO DON'T STORE
	LIS	R4,TINTCH-1
SYLDW6	CLH	LN,DWLNUM,R4,R4		:GET DWL LINE INDEX
	JEFS	SYLDW8			:FOUND IT
	SIS	R4,1
	JGEBS	SYLDW6			:HAVEN'T FOUND IT, KEEP LOOKING
	J	SYNEXT			:DLL LINE NOT THERE, PRESUMED ZAPPED

SYLDW8	LH	R8,DWBUSY,R4,R4		:R8<0 MEANS DONT STORE
	JL	SYLDW7			:-1000 MEANS BUFFER IS BUSY
	SLLS	R4,6			:FORM DWIBUF OFFSET (64 X R4)
	LA	R8,DWIBUF,R4		:SET BUFFER ADDRES
	SRLS	R4,6			:RESTORE R4

	LHL	R3,0,R13,R12		:SKIP OVER SYNCS
	AIS	R12,2			:BY RESETTING R3 AND
	NHI	R12,SVNBSZ-2		:INCREMENTING TRAIL POINTER

	LHI	R1,20			:MOVE 32 HALFWORDS
	JAL	R2,SYALGN

	LHI	R0,-1000		:MARK BUFFER BUSY
	STH	R0,DWBUSY,R4,R4
	LHI	R0,01F-PDWLIN		:AND SCHEDULE TEAR DOWN OF
	SBT	R0,SQUEUE		:DOWNLINE RECORD BY DWLIN
	SBT	R4,DWQUEU,,		:SET BIT IN DWL JOB QUEUE FOR DWLIN
	J	SYNEXT

SYLDW7	LHL	R3,0,R13,R12		:SKIP OVER SYNCS
	AIS	R12,2			:	BY RESETTING R3 AND
	NHI	R12,SVNBSZ-2		:INCREMENTING TRAIL POINTER
	LHI	R1,20			:MOVE 32 HALFWORDS
	JAL	R2,SYALGN
	J	SYNEXT

::*********************************************************************
::
::	SUBROUTINE:	SYFORM:
::	FUNCTION:	PERFORMS CHARACTER FRAMING AND RECORD CHECKSUMMING
::			FOR SYLVER.
::	REGISTERS ON ENTRY:
::		R2  -- RECORD SEQUENCE NUMBER
::		R3  -- RAW DATA POINTED TO BY R12
::		R9  --*RETURN ADDRESS
::		R10 --*ALIGNMENT SHIFT FACTOR (COMPLEMENT)
::		R11 --*RELATIVE INPUT DATA LEAD POINTER
::		R12 --*RELATIVE INPUT DATA TRAIL POINTER
::		R13 --*START OF INPUT RING 
::		R14 --*LINE NUMBER X 2
::		R15 --*LINK DESCRIPTOR ADDRESS
::	* MUST BE PRESERVED ON RETURN (NOTE--R5 AND R11 RETURNED
::		IN UPDATED FORM)
::	REGISTER USAGE:
::		R0  -- WORK REGISTER
::		R1  -- NUMBER OF HALFWORDS TO MOVE
::		R2  -- RECORD SEQUENCE NUMBER
::		R3  -- FIRST 16 BITS OF RAW DATA
::		R5  -- VERTICAL CHECKSUM ACCUMULATOR
::		R6  -- SECTOR RECORD DESCRIPTOR ADDRESS
::		R7  -- DIAGONAL CHECKSUM ACCUMULATOR
::		R8  -- TARGET SECTOR ADDRESS (PHYSICAL RECORD BUFFER)
::		R9  -- RETURN ADDRESS
::		R10 -- ALIGNMENT SHIFT FACTOR (COMPLEMENTED)
::		R11 -- RELATIVE LEAD POINTER
::		R12 -- RELATIVE TRAIL POINTER
::		R13 -- START OF INPUT RING
::		R14 -- LINE NUMBER X 2
::		R15 -- LINK DESCRIPTOR ADDRESS
::	CALLS:	JAL	R0,TSFMRK
::		JAL	R2,SYALGN
::
::*********************************************************************

SYFORM	HS	0
	LB	R5,WSIZ,KD		:GET # SECTORS AVAILABLE
	LHL	R6,ISEC,KD		:SECTOR 0 PHYS REC DESCRIPTOR ADDR
	LR	R0,R2			:COPY OF RECORD NUMBER
	SH	R0,RECN,R6		:WE ARE THIS MANY AHEAD OR
	CHVR	R0,R0			:	BEHIND SECTOR 0
	JGEFS	SYFR10			:AHEAD OF SECT 0 -- SKIP

	AR	R0,R5			:CORRECT FOR WRAP AROUND
SYFR10	CR	R0,R5			:TOO FAR AHEAD
	JLFS	SYFR12			:NO, SKIP
	SR	R0,R5			:YES, BACK UP

SYFR12	MH	R0,CCDSZ		:GET RELATIVE SECTOR ADDRESS
	AR	R6,R0			:SECTOR ADDRESS TO R6

:	CHECK RECORD NUMBER FOR VALIDITY AND FOR RETRANSMISSION

	LHI	R8,-1000		:ASSUME BAD REC -- SET 'DON'T STORE'
	LR	R0,R2			:COPY RECORD #
	SH	R0,LRT,KD		:LRT < REC # ?
	CHVR	R0,R0			:	(NOTE--LRT = LAST REC TORN)
	JG	SYFR20			:YES, SKIP

:	RECEIVED RETRANSMISSION -- NOTE IT

SYFR15	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB03			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RXC
	STB	R0,TSFTBL,R15		:STORE ENTRY TYPE
	STH	R4,TSFTBL+2,R15		:STORE FIRST 2 BYTES OF HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB03	EI	:TSTSZE
	LIS	R0,1
	AHM	R0,RCRXMT,LN,		:INC RETRANSMISSION REC'D COUNT
	J	SYFR30			:AND GO 'MOVE' THE DATA

SYFR20	CR	R0,R5			:REC # <= LRT+WSIZ ?
	IF	TSTSZE
	JLE	SYFR25			:YES, GOOD RECORD NUMBER
	ELSE	:NOT TSTSZE
	JLEFS	SYFR25			:RECORD NUMBER O.K.
	EI	:TSTSZE

:	BAD RECORD NUMBER (TOO HIGH) -- NOTE IT

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB04			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BRN
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD RECORD NUMBER)
	STH	R4,TSFTBL+2,R15		:STORE RECORD HEADER
	STB	R2,TSFTBL+4,R15		:	AND PACKET RECORD NUMBER
	LIS	R0,0			:PROVIDE OPPORTUNITY TO PATCH
	LHL	R0,TSLINK		:	THIS 'LHL' TO A 'STH' TO
					:	TERMINATE TRACING AND
					:	EXAMINE HISTORY PRIOR TO
					:	BAD RECORD OCCURRENCE.  
	L	R15,TSRSVE
TSLB04	EI	:TSTSZE
	LB	R0,NLAT,KD		:BAD RECORD # CAN OCCUR ON MULTI-LINE 
	SIS	R0,1			:LNKS IF SUBSEQUENT SHORT PKT OVERTAKES
	JGFS	SYFR30			:PRIOR PKT. DON'T COUNT THIS ONE

	LIS	R0,1
	AHM	R0,BADRCN,LN,		:INC BAD RECORD COUNTER
	JFS	SYFR30			:AND GO 'MOVE' THE DATA

SYFR25	CLH	R2,RECN,R6		:SEE IF REC ALREADY REC'D
	JE	SYFR15			:YES, GO NOTE IT
	IF	EXPWSZ
	L	R8,BREC,R6		:GET PHYSICAL REC BUFFER ADDRESS
	ELSE
	LHL	R8,BREC,R6		:GET PHYSICAL REC BUFFER ADDRESS
	EI
	LA	R8,RECBUF,R8,		:'REAL'ADDRESS

:	SET UP TO ALIGN DATA AND DO BLOCK CHECKS
	
SYFR30	ST	R2,SYSTOR		:SAVE REC # ACROSS CALL
	IF	SYNFCS
	ST	R8,ISECAD,,		:SAVE INPUT BUF. ADDR. FOR LATER USAGE
	EI	:SYNFCS

	JAL	R2,SYALGN		:MOVE THE DATA AND CHECKSUM IT

:	AFTER DATA ALIGNMENT, CHECK SOFTWARE FCS ERR HERE		###AL
	IF	SYNFCS
	LHL	R1,KVERNO,KD	:USE OLD 32BIT CKSM TO TALK TO OLD NODE
	CHI	R1,FCSVER
	JL	SYFR35		:SKIP IF OLD VERSION ##AL
	L	R8,ISECAD,,	:GET INPUT BUF. ADDR.
	JLR	R9		:IF DATA ARR. NEG. NO STORE RETURN
	LB	R2,0,R8,	:IF BYTE COUNT IS NOT ZERO, DO FCS
	NHI	R2,000F		:GET BYTE CNT NIBBLE
	CLHI	R2,0
	JE	SYFR35		:ONLY DATA PACKET WITH NON-0 BYTE CT.
				:USE FCS CHECKING
	LB	R2,SYTWCN,R2	:EXACT BYTE CT. FROM TABLE
	AHI	R8,3		:WITHOUT 3 HEADER BYTES
	SIS	R2,3		:LESS 3 BYTE CT.
 	JAL	R0,FCSCA0	:CHECK SOFTWARE FCS ERR 
				:R7 LO HW HAS FCS
	NI	R7,0FFFF	:LO HW
	LHL	R0,0,R8,R2	:LET R0 HAS DATA PACK. FCS 
	CR	R7,R0		:COMPARE WITH THE FCS REVED AT EREC
				:R8 IS ISEC ADDR, R2 IS BYTE CT
	JN	SYFR37		:BAD FCS
	LIS	R2,3		:CHECK 3 BYTE HEADER FCS
	SIS	R8,3		:BACK TO THE 1ST BYTE
	JAL	R0,FCSCA0	:CALCULATE 3 BYTE FCS
	NI	R7,0FFFF	:LO HW
	LHL	R0,FCSGOT+2,,	:LET R0 HAS 3 BYTE HEADER FCS
	CR	R7,R0
	JE	SYFR40		:GOOD FCS CKSM
	J	SYFR37		:BAD FCS, SAME HANDLING			###AL
SYFR35	HS	0
	CHVR	R7,R7		:CKSM GOOD IF LO HW OF R7 STILL ZERO
	EI	:SYNFCS

	IF	1-TSTSZE
	JEFS	SYFR40			:SKIP IF GOOD CHECKSUM
	ELSE	:TSTSZE
	JE	SYFR40			:O.K. CHECKSUM CONDITION CODE RETURNED
SYFR37	HS	0
:	PACKET RECEIVED WITH BAD CHECKSUM
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB05			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.CSE
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (CHECKSUM ERROR)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	LHL	R2,SYSTOR+2
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	LIS	R0,0
	NOP	R0,TSLINK		:PATCH TO 'STH' TO TERMINATE TRACE HERE
	L	R15,TSRSVE
TSLB05	EI	:1-TSTSZE
	LIS	R0,1
	AHM	R0,BADCSM,LN,		:INC BAD CHECKSUM COUNTER
	J	SYNEXT			:AND SKIP TO NEXT LINE

:	GOOD CHECKSUM	-- RELEASE DATA TO RTD

SYFR40	LR	R8,R8			:SEE IF RECORD STORED
	JLR	R9			:NO, SIMPLY RETURN
	LR	R0,LN
	SRHLS	R0,1			:SET BIT INDICATING GOOD
	SBT	R0,LNGREC		:	REC RECEIVED ON LINE

	L	R2,SYSTOR		:RETRIEVE SAVED RECORD NUMBER
	STH	R2,RECN,R6		:REC # TO RECORD DESCRIPTOR
	LR	R1,R2			:COPY RECORD NUMBER OVER
	NHI	R1,PKTMSZ		:MASK WITH BUFFER SIZE
	AR	R1,R1			:FORM HW INDEX
	LHL	R0,FASTC+2,,		:GET CURRENT TIME
	STH	R0,INTIME,KD,R1		:AND RECORD TIME OF PACKET ARRIVAL

	LB	R1,LKNM,KD		:GET LINK NUMBER
	SBT	R1,LKGREC		:NOTE GOOD REC REC'D ON LINK
	SBT	R1,LKTEAR		:'SCHEDULE' RTD

	LIS	R0,1			:INC COUNT OF GOOD
	AHM	R0,RCRCVD,LN		:	RECORDS REC'D ON THIS LINE
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JNR	R9			:NO - DONE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LHI	R0,TS.REC
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (GOOD REC RECEIVED)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	LHL	R2,RECN,R6
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB06	EI	:TSTSZE
	JR	R9			:DONE

	IF	SYNFCS
FCSTBL	HS	0
	XC	0000891112239B322446AD573665BF74
	XC	488CC19D5AAFD3BE6CCAE5DB7EE9F7F8
	XC	8110080193331A22A5562C47B7753E64
	XC	C99C408DDBBF52AEEDDA64CBFFF976E8
	XC	02218B30100299132667AF763444BD55
	XC	4AADC3BC588ED19F6EEBE7FA7CC8F5D9
	XC	83310A2091121803A7772E66B5543C45
	XC	CBBD42ACD99E508FEFFB66EAFDD874C9
	XC	04428D5316619F702004A9153227BB36
	XC	4CCEC5DF5EEDD7FC6888E1997AABF3BA
	XC	85520C4397711E60A1142805B3373A26
	XC	CDDE44CFDFFD56ECE9986089FBBB72AA
	XC	06638F7214409D512225AB343006B917
	XC	4EEFC7FE5CCCD5DD6AA9E3B8788AF19B
	XC	87730E6295501C41A3352A24B1163807
	XC	CFFF46EEDDDC54CDEBB962A8F99A708B
	XC	088481951AA793B62CC2A5D33EE1B7F0
	XC	4008C919522BDB3A644EED5F766DFF7C
	XC	899400859BB712A6ADD224C3BFF136E0
	XC	C1184809D33B5A2AE55E6C4FF77D7E6C
	XC	0AA583B4188691972EE3A7F23CC0B5D1
	XC	4229CB38500AD91B666FEF7E744CFD5D
	XC	8BB502A499961087AFF326E2BDD034C1
	XC	C3394A28D11A580BE77F6E6EF55C7C4D
	XC	0CC685D71EE597F42880A1913AA3B3B2
	XC	444ACD5B5669DF78600CE91D722FFB3E
	XC	8DD604C79FF516E4A9902081BBB332A2
	XC	C55A4C4BD7795E68E11C680DF33F7A2E
	XC	0EE787F61CC495D52AA1A3B03882B193
	XC	466BCF7A5448DD59622DEB3C700EF91F
	XC	8FF706E69DD414C5ABB122A0B9923083
	XC	C77B4E6AD5585C49E33D6A2CF11E780F
	EI	:SYNFCS	###AL

::*********************************************************************
::
::	SUBROUTINE:	FCSCA0 WITH R2 AS BYTE CT. INPUT
::	FUNCTION:	SOFTWARE FCS CALCULATION
::	CALLING SEQ:	JAL	R0,FCSCA0
::	INPUT:		R8 = INPUT SECTOR ADDRESS
::	OUTPUT: 	R7 = 16-BIT FCS IN LO HW
::	DESTROYED:	R0,R1,R2,R3,R5,R7
::
::*********************************************************************

	IF	SYNFCS		:###AL
:FCSCAL	HS	0		
:	LB	R2,0,R8,	:GET FIRST BYTE
:	NHI	R2,0F		:GET 2ND NIBBLE, IT'S OFFSET TO THE TABLE
:	LB	R2,SYTWCN,R2	:BASE ON BYTE CT. TABLE
FCSCA0	HS	0
	FCSINI(R7)		:GET FCS INIT VALUE
	XR	R1,R1		:ZERO R1
FCSCA1	LB	R3,0,R8,R1	:GET THE CHAR.
	FCSACC(R7,R3,R5)	:ACCUMULATE THE FCS
	AIS	R1,1		:INC CNT. TO NEXT CHAR.
	CR	R1,R2		:CMP. WITH THE LENGTH
	JL	FCSCA1		:CONTINUE IF NOT END
	FCSEND(R7)		:1'S COMPLEMENT THE FINAL VALUE
				:LO HW OF R7 HAS 16BIT FCS
	JR	R0
	EI	:SYNFCS

::*********************************************************************
::
::	SUBROUTINE:	SYALGN:
::	FUNCTION:	ACTUALLY PERFORMS THE CHARACTER ALIGNMENT,
::			MOVING, AND CHECKSUMMING.
::	CALLING SEQ:	JAL	R2,SYALGN
::	INPUT:		R1  -- NUMBER OF HALFWORDS TO MOVE
::			R2  -- RETURN ADDRESS
::			R3  -- FIRST 16 BITS OF RAW DATA
::			R8  -- WHERE TO STORE DATA (IF NEG -- NO STORE)
::			R10 -- ALIGNMENT SHIFT FACTOR
::			R11 -- INPUT LEAD POINTER
::			R12 -- INPUT TRAIL POINTER
::			R13 -- INPUT RING ADDRESS
::	OUTPUT:		R12 -- NEW TRAIL POINTER
::	DESTROYED:	R0,R1,R3,R5,R7,R8
::	ALSO:		CC=0 => GOOD CHECKSUMS
::			CC<>0 => BAD CHECKSUMS
::
::*********************************************************************

SYALGN	HS	0
	LIS	R5,0			:SET VRC AND DRC ACCUMULATORS
	LIS	R7,0
	HC	36DC			:ALIGN R13,R12
	EXHR	R0,R3			:BUILD DRC
	LHL	R3,0,R13,R12
	OR	R0,R3			:	
	SRL	R0,1,R10		:GOT CALCULATADED DRC IN R0
	IF	SYNFCS
	STH	R0,FCSGOT+2,,		:STORE THE REV'ED HEADER FCS##AL
	EI	:SYNFCS
	XR	R7,R0			:XOR IT WITH RX'ED DRC IN LO HW R7
	OR	R7,R5			:INCLUDE VRC
	CHVR	R7,R7			:CHECKSUMS GOOD IF RIGHT HALF OF R7
	JR	R2			:	IS ZERO.  SET CONDITION CODE

	SUBTTL	LINKER (Miscellaneous subroutines...)

::*********************************************************************
::
::	TABLE:		SYTWCN:
::	FUNCTION:	TYMNET II BYTE COUNT TRANSLATION TABLE -
::			COUNT VALUE RECEIVED IN TYMNET-II PACKET HEADER IS
::			INDEX INTO THIS TABLE.  THE VALUE IN THE TABLE
::			IS THE NUMBER OF BYTES IN THE PACKET, INCLUDING
::			THE HEADER BUT NOT THE CHECKSUMS.
::
::*********************************************************************

SYTWCN	BC	04,0C,14,1C,24,2C,34,3C,44,4C,54,5C,64,6C,74,7C

::*********************************************************************
::
::	SUBROUTINE:	GFRCHN:
::	FUNCTION:	RETURNS CHAIN OF N FREE RECORD BUFFERS.
::	CALLING SEQ:	JAL	R9,GFRCHN
::	INPUT:		R1 = # BUFFS
::	OUTPUT:		R2 = RETURNS PTR TO FIRST BUFFER
::			R3 = RETURNS PTR TO LAST
::	PRESERVED:	R1
::	DESTROYED:	R4
::	RETURNS:	IMMEDIATE = INSUFFICIENT BUFFS IN FREE LIST
::			+4 = NORMAL
::
::*********************************************************************

GFRCHN	HS	0
	LR	R4,R1
	LHL	R2,FREELR
	JLR	R9			:FREE LIST EMPTY
	LR	R3,R2
	JFS	GFRC2
GFRC1	LHL	R3,RLNK,R3
	JLR	R9
GFRC2	SIS	R4,1
	JGBS	GFRC1

	LHL	R4,RLNK,R3		:NEW TOP OF FREE LIST
	STH	R4,FREELR
	J	4,R9

::*********************************************************************
::
::	SUBROUTINE:	MCHDWN:
::	FUNCTION:	Matches down window size
::	CALLING SEQ:	JAL	R9,MCHDWN
::	INPUT:		R1 = number of buffers, i.e. window size
::			R2 = pointer to first buffer
::	OUTPUT:		R3 = returns pointer to last buffer
::	PRESERVED:	R1, R2
::	DESTROYED:	R4
::
::*********************************************************************

	IF	XRESET			:###wjl
MCHDWN	HS	0
	LR	R4,R1			:preserve number of buffers (WSIZ)
	LR	R3,R2			:preserve pointer to first buffer
	JFS	MCHD04
MCHD02	LHL	R3,RLNK,R3		:get pointer to next buffer
MCHD04	SIS	R4,1			:decrement count
	JGBS	MCHD02			:done?
	STH	R2,RLNK,R3		:yes, store pointer to first buffer
	JR	R9
	EI	:XRESET

::*********************************************************************
::
::	SUBROUTINE:	CLRCHN:
::	FUNCTION:	INITIALIZES CHAIN OF RECORD BUFFERS.
::	CALLING SEQ:	JAL	R9,CLRCHN
::	INPUT:		R1 = # BUFFS
::			R2 = PTR TO FIRST BUFFER
::	PRESERVED:	R1
::	DESTROYED:	R0, R3
::
::*********************************************************************

CLRCHN	HS	0
	LIS	R0,0
	SR	R0,R1			:R0 = - # OF SECTORS
	LIS	R3,0
CLRC1	STH	R0,RECN,R2
	IF	STRHUB!STRRMT
	ST	R3,SRXTIM,R2		:Clears rexims time
	EI	:STRHUB!STRRMT
	STH	R3,RBSY,R2		:CLEARS RBUSY AND LLXM
	LHL	R2,RLNK,R2
	AIS	R0,1
	JLBS	CLRC1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	MCHECK:
::	FUNCTION:	Read ZITEL semiconductor memory bit error log
::	CALLING SEQ:	JAL	R0,MCHECK
::	
::*********************************************************************

	IF	1-ISIS			:ISIS WILL DO THIS FROM DDT (?MEM)
	IF	ZITEL
MEMIO1	EQ	0FF78			:FIRST MEMORY ERROR LOG ADDRESS
MEMIO2	EQ	0FF7F			:LAST MEMORY ERROR LOG ADDRESS
LOGSCN	EQ	8000			:SCAN LOG COMMAND 
CLRLOG	EQ	4000			:CLEAR LOG COMMAND
SYNMSK	EQ	0F800			:MASK FOR SYNDROME BITS
ROWMSK	EQ	0700			:MASK FOR ROW BITS IN ERRLOG DATA WORD

MCHECK	HS	0			:ROUTINE TO READ MEMORY BIT ERROR LOG
	LHI	R1,MEMIO1-1		:LOOP FROM START ADDRESS TO ...
MCHK0	AIS	R1,1
	CHI	R1,MEMIO2+1		:...LAST CHIP DEVICE ADDRESS
	JER	R0			:RETURN TO G02SEC WHEN THROUGH
MCHK1	HS	0
	LIS	R3,0
	SVC	0F,SV.OCR		:OUTPUT CMND IN R3 TO DVC R1
	SVC	0F,SV.RDR		:READS INTO R3
	JT	4,MCHK0			:SKIP IF NOT THERE
	THI	R3,1			:CHECK FOR ERROR
	JE	MCHK5			:JUST CLEAR IT,NO ERROR
MCHK2	HS	0
	LIS	R3,0
	SVC	0F,SV.OCR		:OUTPUT CMD IN R3 TO DVC R1
	LHI	R3,LOGSCN		:SET BIT 0
	SVC	0F,SV.WDR		:WRITES R3 TO R1
MCHK3	HS	0
	SVC	0F,SV.SSR		:GET STATUS FROM R1 BACK IN R3
	THI	R3,0A			:CHECK FOR ERROR OR END OF PASS
	JEBS	MCHK3
	THI	R3,2			:CHECK FOR ERROR
	JN	MCHK5			:LOOK FOR NEXT ADDRESS IF END OF PASS
	LR	R2,R3
	NHI	R2,ROWMSK		:ISOLATE ROW-ADDRESS BITS
	SRHLS	R2,8			:RIGHT JUSTIFY
	LB	R4,ROWTBL,R2		:LOOK UP ACTUAL ROW
	THI	R3,4			:CHECK IF DOUBLE BIT		###wjl
	JN	MCHK4
:	CALCULATE CHIP NUMBER	
	LHI	R2,$A 22		:22 BITS PER ROW		###wjl
	MHR	R4,R2			:				###wjl
	LR	R2,R3			:				###wjl
	NHI	R2,SYNMSK		:GET SYNDROME BITS		###wjl
	SRHLS	R2,0B			:ISOLATE,RIGHT JUSTIFY		###wjl
	LB	R5,COLTBL,R2		:GET COLUMN FROM TABLE		###wjl
	AR	R4,R5			:MAKE U NUMBER(POINT TO CHIP)
	CLHI	R5,0FF			:CHECK VALID SYNDROME
	JNFS	MCHK4			:.+6
	LHI	R4,0FF			:ELSE MARK BAD SYNDROME
MCHK4	LBR	R2,R1			:GET ADDRESS
	SLHLS	R2,8			:LEFT JUSTIFY
	OR	R2,R4			:INCLUDE BYTE OF CHIP #
	SVC	0F,SV.SSR		:READ STATUS OF DVC R1 INTO R3
	JFFS	4,MCHK02		:4,.+6 -IF DOUBLE BIT ERROR, OR IN 8000
	OHI	R2,8000			:SET HIGH ORDER BIT IF TWO BIT ERROR
:	SEE IF THIS IS RE-CURRANCE, THEN JUST BUMP COUNT
MCHK02	LIS	R4,0
MCHK04	CLH	R2,MEMTRC+2,R4,		:IS THIS IT
	JE	MCHK14			:YES
	AIS	R4,8
	CLHI	R4,NMTRC*8		:IS THIS ALL OF THEM
	JLBS	MCHK04
	LHL	R4,MEMIN,,		:GET CURSOR
	STH	R2,MEMTRC+2,R4,		:SAVE FOR USER
	LIS	R2,1
	STB	R2,MEMTRC+1,R4,		:RESET COUNT
	L	R2,SLOWC,,
	ST	R2,MEMTRC+4,R4,		:AND TIME TAKEN
	AIS	R4,8
	CLHI	R4,NMTRC*8		:CHECK FOLD
	JLFS	MCHK05			:.+4
	LIS	R4,0
MCHK05	STH	R4,MEMIN,,
	J	MCHK1
MCHK14	LB	R2,MEMTRC+1,R4,		:GET COUNT
	AIS	R2,1			:BUMP IT
	STB	R2,MEMTRC+1,R4,		:RESTORE IT
	J	MCHK1
MCHK5	LHI	R3,CLRLOG		:OUTPUT CLEAR LOG COMMAND
	SVC	0F,SV.WDR		:OUTPUT CMD IN R3 TO DVC R1
	SVC	0F,SV.WDR		:OUTPUT CMD IN R3 TO DVC R1
	J	MCHK0			:PROCEED TO LOOP FOR NEXT DEVICE

ROWTBL	BC	7,3,5,1,6,2,4,0

COLTBL	BC	11,16,15,08,14,0C,0FF,04,13,0E,0FF,6,0FF,0A,0FF,2,12,0F,0FF
	BC	7,0FF,0B,0FF,3,0FF,0D,0FF,5,0FF,9,10,1

	EI	:ZITEL
	EI	:1-ISIS

::*********************************************************************
::
::	SUBROUTINE:	BFRUPD:
::	FUNCTION:	Routine to copy ACP array to BFDARY (buffer
::			delay array) for the purpose of scheduling the
::			sending of buffer delay timing pairs (COMETS--0314).
::			Scheduled from the 30 second logic in EXEC, if
::			BFLTMR assembly switch is non-zero.
::	CALLING SEQ:	JAL	R10,BFRUPD
::
::*********************************************************************

	IF	BFLTMR

BFRUPD	HS	0		:###jhl
	LA	R0,ILCACP-2,,	:pointer to last halfword of source
	LA	R1,BFDEND-2,,	:pointer to last halfword of destination
	LHI	R2,10*(((ILCACP-LNKACP)/2)-1)	:number of hw's, etc
	COPY	R0,R2		:copy the bit array of active channels
	JR	R10

	EI	:BFLTMR

::*********************************************************************
::
::	SUBROUTINE:	TEMPRP:
::	FUNCTION:	CHECK REPORTED TEMPERATURE AND REPORT IF IT IS NOT IN
::			THE ACCEPTABLE RANGE.  CALLED FROM G04MIN.
::	CALLING SEQ:	JAL	R11,TEMPRP
::	DESTROYED:	R1
::
::*********************************************************************

TEMPRP	HS	0		:###JHL
	LH	R1,TMCHFG,,	:CHECK FLAG TO DISABLE TEMP CHECK
	JNR	R11		:IF SET NON-ZERO (BY USER) DON'T BOTHER
	LB	R1,TEMPER,,	:READ TEMPERATURE
	CHI	R1,TOOHOT	:IS TEMP TOO HIGH?
	JGFS	TMPRPT		:TRY TO SEND REPORT

:	NO REPORT NECESSARY, BUT CHECK INHIBIT FLAG IN CASE IT'S 
:	TIME TO CLEAR IT.
	LH	R1,INHTMP,,	:READ INHIBIT FLAG
	JGER	R11		:NEGATIVE VALUE INHIBITS
TMPR10	AHI	R1,1		:IF SET, THEN MARK ANOTHER PASS
	STH	R1,INHTMP,,	:UPDATE INHIBIT FLAG
	JR	R11

:	TEMPERATURE OUT OF RANGE.  SEE IF WE SHOULD REPORT IT.
TMPRPT	HS	0
	LH	R1,INHTMP,,	:READ INHIBIT FLAG
	JN	TMPR10		:IF NEG, THEN WE'RE INHIBITED
:	IF NOT INHIBITED, SET INHIBIT DELAY AND SEND THE REPORT
	LCS	R1,DLYTMP	:DELAY 14 MORE CALLS--ONE HOUR.	
	STH	R1,INHTMP,,	:THIS IS INC'ED EACH CALL
:	SEND THE REPORT TO SUP'S LOG
	LHI	R1,NR.TMP	:NODE REPORT #2E 
	STH	R1,SUPMBF	:STORE FOR SUP12 TO FIND
	LB	R1,TEMPER,,	:READ BYTE CONTAINING TEMPERATURE

:	CONVERT MF READING TO CENTIGRADE IF SOLO			###wjl
	IF	1-ISIS
	LHI	R10,$A 100
	MHR	R1,R10
	SRLS	R1,8
	EI	:1-ISIS							###wjl

	ST	R1,SUPMBF+2	:STORE IN REST OF 48 BITS OF MSG BUFFER
	JAL	R10,SUP12,,	:CALL ROUTINE TO SEND TO SUP LOG
EXIT	JR	R11		:RETURN TO G04MIN			###JHL	


:	***END LINKER***
	ENDMO.(LINKER)
	EI	:1-KILLIT
	KILMSG(LINKER)
:	***NOTHING PAST THIS POINT***
		

	SUBTTL  YAKYAK

:		*   *   *   *   * *   *   *   *   *
:		 * *   * *  *  *   * *   * *  *  *
:		  *   ***** ***     *   ***** ***
:		  *   *   * *  *    *   *   * *  *
:		  *   *   * *   *   *   *   * *   *

::#####################################################################
::
::	MODULE:	   Y A K   Y A K
::
::	FUNCTION:  Process data destined for or arriving from neighbor nodes
::
::	REGISTER CONVENTIONS:
::		R0,R1  	=  Work Registers
::		R2	=  Buffer number * 4  (Buffer Index)
::		R3	=  "In" pointer for buffer (BE)
::		R4	=  Work Register
::		R5	=  Channel Index (2* Channel Number)  (CHN)
::		R6	=  Relative start of 1/2 wd tables for this link 
::			   (IOTAB  Pointer)
::		R7	=  Relative start of bit arrays for this link
::			   (FLAGS Pointer)
::		R8,R9	=  Link and Work registers
::		R10	=  Physical Record Byte Count (PRC)
::		R11	=  Link Number (KN)
::		R12	=  Index into Physical Record (PRD)
::		R13	=  Record Descriptor Address (CD), also working LRC
::		R14	=  Logical Record Byte count (LRC)
::		R15	=  Link Descriptor address (KD)
::
::	SUBPROCESSES:	RTEAR  RMAKE
::	SUBROUTINES:	RTD RMK  ILC  BPMX
::
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.

	SEG	1

::*********************************************************************
::
::	XRAYGG:	USERNAME VALIDATION LIST
::
::*********************************************************************

	IF	EXPSEC
XRAYGG	HS	0
	BC	01,1F			:DLOAD DUMMY PRIV AND OVERRIDE
	AC	/DLOAD/			:DLOAD USERNAME
	BC	00,00,00,00,00,00,00	:PAD UP TO 12(D) CHARACTERS
XGGDLD	EQ	.			:DLOAD USERNAME UPPER INDEX

					:START OF XRAY ENTRIES
	IF	XRYTMC			:###wjl
XGGNTC	EQ	.-XRAYGG		:NETCON username GG list index
	BC	01,1F			:NETCON dummy priv and override
	AC	/OMNC/			:NETCON username
	BC	00,00,00,00,00,00,00,00	:padding
	EI	:XRYTMC

	IF	XGGCNT
QQ	EQ	0
	RE	XGGCNT
	XGGX|$0QQ|
QQ	EQ	QQ+1
	ER
	EI	:XGGCNT

	ORG	XGGDLD+(20*XGGSIZ)	:LEAVE ROOM FOR 32 XRAY GOODGUYS

XGGLEN	EQ	.-XRAYGG

	EI	:EXPSEC

::*********************************************************************
::
::	YAKBID:	FOR RX2 JAL TO BIDDY
::
::*********************************************************************

YAKBID	J	BIDDY,,		:FOR RX2 JAL TO BIDDY

::*********************************************************************
::
::	PFMRTD:	DISPATCH TABLE FOR PERFORMANCE MONITORING CONTROL CHARACTERS
::		MOVING ON PASSTHROUGHS, DETECTED IN RTEAR
::
::*********************************************************************

PFMRTD	HC	RTDXLA-SEG1	:XLAX	   03-20
	HC	RTDXAK-SEG1	:XLAX ACK  03-21
	HC	RTDALL-SEG1	:TIMER	   03-22
	HC	RTDALL-SEG1	:TIMER ACK 03-23
	HC	RTDALL-SEG1	:REJECT	   03-24
	HC	RTDALL-SEG1	:WILD CARD 03-25
	HC	RTDALL-SEG1	:WILD CARD 03-26
	HC	RTDALL-SEG1	:WILD CARD 03-27
	HC	RTDALL-SEG1	:WILD CARD 03-28
	HC	RTDALL-SEG1	:WILD CARD 03-29
	HC	RTDALL-SEG1	:WILD CARD 03-2A
	HC	RTDALL-SEG1	:WILD CARD 03-2B
PFMRTZ	EQ	(.-PFMRTD)/2	:NUMBER OF DEFINED PERFORMANCE MONITORING CHARS

::*********************************************************************
::
::	PFMTRM:	DISPATCH TABLE FOR PERFORMANCE MONITORING CHARACTER PAIRS
::		ARRIVING AT THE TERMINATING END OF A CIRCUIT
::		(INTERNAL OR TO A T-1 NODE)
::
::*********************************************************************

PFMTRM	HC	RTDXL1-SEG1	:XLAX
	HC	RTDSNK-SEG1	:XLACK ACK
	HC	RTDTM1-SEG1	:TIMER
	HC	RTDSNK-SEG1	:TIMER ACK
	HC	RTDSNK-SEG1	:REJECT
	HC	RTDREJ-SEG1	:WILD CARD
	HC	RTDREJ-SEG1	:WILD CARD
	HC	RTDREJ-SEG1	:WILD CARD
	HC	RTDREJ-SEG1	:WILD CARD
	HC	RTDREJ-SEG1	:WILD CARD
	HC	RTDREJ-SEG1	:WILD CARD
	HC	RTDREJ-SEG1	:WILD CARD
	HC	RTDREJ-SEG1	:WILD CARD
PFMMAX	EQ	PFMRTZ+1F	:UPPER LIMIT OF VALID PERF MONITORING CHARS
PFMRTB	EQ	PFMRTD-40	:PFMRTD ADDRESS WITH PERF. MONITOR BIAS REMOVED
PFMTRB	EQ	PFMTRM-40	:SAME FOR TERMINATION DISPATCH TABLE

::*********************************************************************
::
::	NEGBCR:	COMMON CRASH LOCATION FOR BFLTSV (BUFFERLET CHARS IN USE COUNT)
::	DETECTED NEGATIVE. ROUTINE IS CALLED BY JAL R7, SO R7 CONTAINS
::	THE LOCATION OF THE CRASH CAUSE. ###OAS
::
::*********************************************************************

NEGBCR	HS	0
	CRASH.(.NEGBF)

::*********************************************************************
::
::	NEGHCR:	COMMON CRASH LOCATION FOR HBFTSV
::	(HIST BUFFERLET CHARS IN USE COUNT) DETECTED NEGATIVE.
::	ROUTINE IS CALLED BY JAL R7, SO R7 CONTAINS
::	THE LOCATION OF THE CRASH CAUSE. ###OAS
::
::*********************************************************************

NEGHCR	HS	0
	CRASH.(.NEGHB)

	SUBTTL	YAKYAK (RTEAR - Record TEARdown)

::*********************************************************************
::
::	SUBPROCESS:	RTEAR:
::	FUNCTION:	RTEAR checks to see if a link is awaiting a BORI
::	Zap.  If not, it dispatches on link type.  For a T-II link it 
::	looks up the length of the packet based on PRD.  Then it points to 
::	the first logical record and calls RTD.  For a T-I link it distin-
::	guishes between a "sat" header and a "normal" header, then points
::	to the first logical record and calls RTD.  Both T-I and T-II 
::	return to update LRT and make entries in the Sync Line Trace Table.
::	A check is made to provide equal link service.  
::	CALLING SEQ:	J RTEAR  (called directly from SPIDER)
::	INPUT:		R2 contains link number
::	CALLS:		JAL  R9,RTD
::			JAL  R8,TSBMRK
::	RETURNS:	J  BIDDRT,,
::
::*********************************************************************

RTEAR	HS	0
	IF	DB.CPU
	LR	R3,R2			:SAVE R2			###OAS
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR RTEAR		###OAS
	CPUTNM(RTEAR )			:DEFINE RTEAR CPUTIL ENTRY	###OAS
	LR	R2,R3			:RESTORE R2			###OAS
	EI	:DB.CPU

	LI	R0,YAKMAC		:SET UP MAC INTERRUPT ERROR RETURN ADDR
RTRSFT	ST	R0,ABENPC		:NO-OP INSTRUCTION FOR DEFAULT HANDLING
	LR	KN,R2			:LOAD LINK #
	SLL	KN,1
	L	KD,KDKN,KN,KN		:GET DESCRIPTOR POINTER
	SRL	KN,1
	TBT	KN,BORZAP		:IS LINK AWAITING BORI ZAP?
	JNFS	RTEARZ			:YES (MAYBE LINK SNIP)
					: - TEAR NO PACKETS FOR THIS LINK
	LHL	CD,NRTR,KD		:PTR TO NEXT RECORD TO TEAR
	LH	R1,LRT,KD		:IF REC # = LRT+1, WE HAVE A RECORD
	AIS	R1,1
	CHVR	R1,R1
	CLH	R1,RECN,CD
	JEFS	RTEAR1
RTEARZ	RBT	KN,LKTEAR		:NO MORE, MARK THIS LINK AS SERVICED
	J	BIDDRT,,

RTEAR1	LHL	R2,RECN,CD		:GET RECORD NUMBER TO TEAR
	NHI	R2,PKTMSZ		:MASK WITH BUFFER SIZE
	AR	R2,R2			:FORM HW INDEX
	LH	R0,FASTC+2,,		:CURRENT TIME
	SH	R0,INTIME,KD,R2		:GET INTERVAL BETWEEN SYLVER AND NOW
	JGEFS	RPERF1			:NO WRAP
	AI	R0,10000
RPERF1	AM	R0,KS.SRC,KD		:AND ADD INTO RUNNING SUM

RTEARW
	IF	EXPWSZ
	L	PRD,BREC,CD		:TYMNET-II - PTR TO RECORD
	ELSE
	LHL	PRD,BREC,CD		:TYMNET-II - PTR TO RECORD
	EI
	LHL	PRC,RECBUF,PRD,		:SET PRC=PHYS BYTE CNT
	EXBR	PRC,PRC
	NHI	PRC,0F
	LB	PRC,SYTWCN,PRC
	AIS	PRC,4			:INCLUDE CHECKSUM AND COUNT
	AHM	PRC,RTRCNT		: IF CHAR'S PROCESSED THIS ROUND##TZ
	AM	PRC,KS.PCI,KD		:COUNT PACKET CHARACTERS INPUT
	SIS	PRC,7			:DON'T INCLUDE CHECKSUM, HEADER FOR RTD
	AIS	PRD,3			:INDEX PRD TO FIRST LOG REC
	LIS	R9,1			: minimum record size for T-II

RTEAR2	STH	R9,MINLR		: save minimum logical record size
	JAL	R9,RTD
	LIS	R0,1			:RECORD TORN, UPDATE LRT
	AHM	R0,LRT,KD
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND 
	CLH	R0,TSLINK		: TEST FOR LINK OF INTEREST
	JN	RTEART			:NO - CONTINUE
	JAL	R8,TSBMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RTD		:GET EVENT TYPE (RECORD TORN)
	STB	R0,TSBTBL,R7		: AND STORE IN ENTRY
	IF	EXPWSZ
	L	R8,BREC,CD
	ELSE
	LHL	R8,BREC,CD
	EI
	LHL	R0,RECBUF,R8,		:GET HEADER HALFWORD
	STH	R0,TSBTBL+2,R7		: AND STORE
	LB	R0,RECBUF+2,R8,
	STB	R0,TSBTBL+4,R7		:THIRD BYTE RECORD NUMBER
	LHL	R0,LAS,KD
	STB	R0,TSBTBL+1,R7		:STORE LAST ACK SENT
RTEART	EI	:TSTSZE
	LHL	R0,RLNK,CD		:INDEX NRTR
	STH	R0,NRTR,KD

:##TZ	THE FOLLOWING IS AN ATTEMPT TO ENSURE THAT LINKS GET ROUGHLY EQUAL
:##TZ	SERVICE BASED ON THE NUMBER OF PHYSICAL CHARACTERS PROCESSED. WE WILL
:##TZ	RESERVICE A LINK (BY SETTING ITS BIT IN LKSRVD) IF 1) THERE IS ANOTHER
:##TZ	PACKET WAITING TO BE TORN, AND 2) IF THE TOTAL NUMBER OF CHARACTERS 
:##TZ	TORN SO FAR FOR THIS LINK IN THIS ROUND OF RTEAR IS LESS THAN RTRMAX.
:##TZ	OTHERWISE, WE WILL GO ON TO THE NEXT LINK.
	LR	CD,R0			:PTR TO NEXT RECORD TO TEAR	##TZ
	LH	R1,LRT,KD		:IF REC # = LRT+1, WE HAVE A RECORD##TZ
	AIS	R1,1			:##TZ
	CHVR	R1,R1			:##TZ
	CLH	R1,RECN,CD		:DO WE HAVE ANOTHER RECORD?	##TZ
	JEFS	RTERT0			:YES, CONTINUE			##TZ
	RBT	KN,LKTEAR,,		:MARK THIS LINK COMPLETED	##TZ
RTEARX	TS	RTRCNT			:NO MORE RECORDS		##TZ
	J	BIDDRT,,		:AND RETURN			##TZ

RTERT0	LH	R1,RTRCNT		:COUNT CHARACTERS PROCESSED SO FAR##TZ
	CLHI	R1,RTRMAX		:THIS MANY ONLY			##TZ
	JGEBS	RTEARX			:ENOUGH FOR NOW			##TZ
	SBT	KN,LKSRVD,,		:DO THIS LINK AGAIN		##TZ
	J	BIDDRT,,		:RETURN				##TZ

	SUBTTL	YAKYAK  (RTD)

::*********************************************************************
::
::	SUBROUTINE:	RTD
::	FUNCTION:	Tears down all logical records in a physical 
::	record.  If logical records exist in a packet, RTD does a range
::	check on the channel number.  If chan # in range then checks 
::	throughput level and updates counter and does trace if necessary.
::	Then RTD copies from logical record to buffer, detects special
::	characters and link control messages, and acts accordingly.  
::	Shrinks the link if necessary.  Processes incoming  needles.
::	Bubbles if necessary.  If serious errors occur, the link
::	will be snipped.
::	CALLING SEQ:	JAL  R9,RTD
::	INPUT:		R2(KN) = Link Number
::			R10(PRC) = Physical Record byte count
::			R12(PRD) = Pointer to Physical Record
::		
::	CALLS:		JAL  R8,CHRTRC	: Make trace entry in TRRING
::			JAL  R9,W2CI	: Write 2 chars into buffer
::			JAL  R8,WCFRST	: Chain first bufferlet into buffer
::			JAL  R7,NEGBCR	: Crash
::			JAL  R0,BUFZAP	: Zap buffer specified by R2
::			JAL  R0,WRE	: Link reserve tank to freelist
::			JAL  R9,RSTRIP	: Return bufferlets to free pool
::			JAL  R9,GOBBLN	: Eat buffer, put Gobbler in
::			JAL  R8,WCI	: Write character into bufffer
::			JAL  R8,WCD	: Prefix character into buffer
::			JAL  R10,SUP12L	: Node report Bubble or Shrink
::			JAL  R9,CRYPTO	: Generate Xray diagnostic
::			JAL  R9,ZAPXNG	: Nongobbling Zapper detected
::			JAL  R9,ZAPHRD	: Force hard zap of circuit
::			JAL  R9,GFCBUF	: Get buffer index from FREELB
::			JAL  R9,CRQHCR	: Create half a circuit
::			JAL  R10,TRCIRC	: Tear circuit & reqest rebuild
::			JAL  R10,SUP08	: T-I Zapper sent or received
::			JAL  R8,PCIS	: Peak at first character
::			JAL  R8,PCI	: Peak at next character
::			JAL  R8,CBCLR	: Clear a buffer
::			JAL  R8,SPEED	: Expedite Zappers and Gobblers
::			JAL  R8,CHKTRM	: Test for terminating circuit
::			JAL  R8,RBFLTS	: 
::			JAL  R8,RETBLT	: Return first bbflt to free list
::			JAL  R9,RBCOUT	:
::			JAL  R7,NEGHCR	: Crash
::			JAL  R10,TRCRFT	: Tear circuit and request rebuild
::			JAL  R9,CRQALT	: Signal CRQ of Needle
::			JAL  R9,PHWI	: Peek at next halfword
::			JAL  R8,WCNXT	: Chain another bufferlet
::			JAL  R8,BUBBLE	: Link Bubble
::
::	RETURNS:	JR  R9
::
::*********************************************************************

RTD	HS	0
	ST	R9,RTMXSV		:SAVE RETURN
	LHL	R6,TBDPKN,KN,KN		:PTR TO IOTAB FOR THIS LINK
	LA	PRD,RECBUF,PRD,		:'REAL' RECORD ADDRESS
	LHL	R7,FLDPKN,KN,KN		:POINT TO HALFWORD WHERE THIS LINK'S
					: FLAGS BEGIN

RTD1	CLH	PRC,MINLR		:IS PACKET RECORD COUNT DEPLETED?
	JL	RTDXIT			:YES, NO MORE LOGICAL RECS IN PACKET
:	PROCESS THIS RECORD 
	LB	LRC,0,PRD		:GET LOGICAL REC COUNT
	JE	RTDXIT			:END-OF-PACKET INDICATION
	LB	CHN,1,PRD		:GET CHANNEL NUMBER FROM PACKET
	AIS	PRD,2			:BUMP PTR PAST CHAN # AND COUNT.
	THI	LRC,80			:IF LRC>7F, IT'S A PRIORITY MESSAGE
	JN	RTDPRI			:YES

	SHI	PRC,2,LRC		:NEW PRC = OLD PRC-LRC-2
	AH	CHN,RTPAGE,KN,KN	:ADD CHANNEL PAGE #

:	CONSISTENCY CHECK - RANGE CHECK CHANNEL NUMBER
	LH	R0,EBDPKN,KN,KN		:GET END OF TABLES POINTER AND
	SR	R0,R6			: SUBTRACT BEGINNING OF TABLE ADDRESS
	SRLS	R0,1			:NUMBER OF CHANNELS THIS LINK
	CR	CHN,R0
	JGE	RTDBIG			:CHANNEL NUMBER TOO LARGE,
					: INVESTIGATE FURTHER

:	GOT A LOGICAL RECORD WITH A REASONABLE CHANNEL NUMBER. PROCEED
:	WITH LOGICAL RECORD TEARDOWN

:	SEE IF DATA 'GUSHING' OR 'TRICKLING' IN FOR THIS CHANNEL...
	JFS	RTD01

	DEFAULT(TRKLVA,1)		:TPC-A ALWAYS GUSHING
	DEFAULT(TRKLVB,2)
	DEFAULT(TRKLVC,3)
	DEFAULT(TRKLVD,4)
TRKLVL	HC	TRKLVA,TRKLVB,TRKLVC,TRKLVD

RTD01	HS	0		:SEE IF DATA GUSHING OR TRICKLING BASED ON TPC
	DEFAULT(GSHTRK,1)		:remove after testing!		###wjl
	IF	GSHTRK			:				###wjl
	AR	CHN,CHN			:make halfword channel index	###wjl
	LHL	R1,NIOTAB,R6,CHN	:GET DESTINATION BUFFER #
	SRLS	CHN,1			:restore channel number		###wjl
	ELSE	:
	LHL	R1,NIOTAB,R6,CHN	:GET DESTINATION BUFFER #
	EI	:GSHTRK
	NHI	R1,3			:SPEED BITS ONLY
	CLH	LRC,TRKLVL,R1,R1	:COMPARE TO APPROPRIATE TRICKLE VALUE
	JLFS	RTD02
	SBT	CHN,GUSH,R7,		:DATA GUSHING IN ON THIS CHANNEL
	JFS	RTD04
RTD02	SBT	CHN,TRIKLE,R7,		:DATA MERELY TRICKLING IN
RTD04	AM	LRC,KS.LCI,KD		:COUNT LOGICAL CHARACTERS INPUT
	AR	CHN,CHN			:MAKE HALFWORD CHANNEL INDEX
RTD15	LHL	R2,NIOTAB,R6,CHN	:DESTINATION BUFFER # FOR THIS CHANNEL
	NHI	R2,-4			:STRIP OUT THE CIRCUIT SPEED BITS
	JE	RTDUAC			:UNASSIGNED CHANNEL
					: - EITHER NEEDLE OR BAD DATA
RTD6	HS	0			:				###GT
	IF	REBILD
	AM	LRC,VSEQN,R2,		:UPDATE THE RECEIVE SEQUENCE NUMBER
RTD6A	HS	0			: - NOTE THAT NEEDLES ARE NOT COUNTED
	EI	:REBILD

:	TEST FOR CHARACTER TRACING FOR THIS CHANNEL
	LHL	R1,BF,R2,		:DESTINATION ABSOLUTE CHANNEL NUMBER
	TBT	R1,TRCHAN,,		:TRACING DESIRED?
	JEFS	RTD610			:NO
:	TRACING FOR THIS CHANNEL. R9 SHOULD POINT TO BEGINNING OF LOGICAL
:	RECORD, R0=-2 INDICATES RECORDING DATA INTO NODE...
	LR	R9,PRD			:POINT TO FIRST BYTE OF DATA
	LCS	R0,2			: -2 =>INPUT
	JAL	R8,CHRTRC		:MAKE TRACE ENTRY FOR THIS LOGICAL REC

RTD610	HS	0
	IF	BFLTMR			:check for sending of buff timing pairs
	LHL	R1,BF,R2,		:scheduled by dest chan #
	SHI	R1,LNKZFL		:schedule array is for link chans only
	JLE	RTD620			:don't do it if bound for internal chn
	SBT	R1,BFDARY,,		:set and test scheduling bit
	JNFS	RTD620			:set (inactive) already,no pair for now
	TBT	R1,CMDCTS,,		:don't send pair on a cmd channel
	JNFS	RTD620
:	send a buffer delay timimg pair (COMET)
	LHI	R1,COMET
	JAL	R9,W2CI			:put pair in buffer (no escapes)
	GL	W2CI
	LHL	R1,FASTC+2,,
	JAL	R9,W2CI			:followed by halfword of FASTC
RTD620	HS	0	
	EI	:BFLTMR
	L	R3,BE,R2,		:LOAD THE BUFFER IN POINTER
	JNFS	RTD2			:BUFFERLET ALREADY ALLOCATED
	JAL	R8,WCFRST,,		:EMPTY BUFFER, GET FIRST BUFFERLET
	GL	WCFRST
	SIS	R3,1			:SET UP R3 (BE) FOR MICROCODE

:	HERE TO PROCESS A LOGICAL RECORD
:
:	RTD COPY MICROINSTRUCTION:
:		R1  = scratch
:		R14 = LRC = byte count of characters to move
:		R12 = PRD = address of the logical record
:		R3  = BE (address of the last character input)
:	NOTE THAT THE RTD COPY INSTRUCTION WAITS UNTIL IT HAS 2 BYTES
:	TO MOVE BEFORE IT ACTUALLY WRITES INTO THE BUFFERLET. THIS
:	MEANS THAT IF A SPECIAL CHARACTER IS ALSO THE LAST CHAR IN A
:	LOGICAL RECORD, IT MUST BE EXPLICITLY STORED WITH A STB INSTRUCTION
:	SINCE THE MICROCODE MAY NOT HAVE DONE SO.
:
:START	LB	RA,0,PRD	:GET NEXT BYTE 
:	INC	PRD	:ADVANCE PRD TO NEXT BYTE IN RAW PACKET (PRD=R12)
:	INC	BE		:ADVANCE BE TO SLOT WHERE BYTE WILL GO
:	END OF BUFFERLET?
:	YES => GET NEXT ONE, PROCEED AT 'NEXT'
:NEXT	'STORE' RA,0,BE		:STORE ONLY ON EVEN BE, USING HW WRITE
:	SPECIAL CHAR? (0-3)
:	IF YES, BRANCH OUT
:	DEC	LRC		:DECREMENT COUNT OF RAW BYTES REMAINING
:	LRC=0?
:	IF NOT, GOTO START
:	ELSE DONE

RTD2	LHL	R0,0,R3			:SET UP SCRATCH REGISTER
	EXHR	R0,R0			: FOR THE MICROCODE
	LHL	R1,0,PRD
	OR	R1,R0

RTD2A	HC	3B1E			:RTD Copy 1 - SCRATCH REG, BYTE COUNT 
RTD2B	HC	3C1E			:RTD Copy 2 - RESUME PROCESSING HERE
	HC	RTDNXT-RTD2B		:TO GET NEXT BUFFERLET
	HC	RTDC00-RTD2B		:TO HANDLE CHARACTER PAIRS
	HC	RTDC01-RTD2B		:TO HANDLE PREFIX CODES
	HC	RTDC2-RTD2B		:TO HANDLE GOBBLERS
	HC	RTDC3-RTD2B		:TO HANDLE ZAPPERS

:	WE'VE TORN DOWN A LOGICAL RECORD
RTD3 	HS	0
	ST	R3,BE,R2,		:COME HERE WHEN DONE -- SAVE END ADDR
	IF	DB.DEB
	LR	R2,R2			:VERIFY BUFFER INDEX INTEGRITY
	JN	RTD1			:NON-ZERO - MUST BE GOOD...
	DBOOPS
	ELSE	:NOT DB.DEB
	J	RTD1			:DONE WITH THIS LOGICAL RECORD
	EI	:DB.DEB

:	HERE TO SET UP A NEW BUFFERLET

RTDNXT	HS	0
	JAL	R8,NXTBLT
	IF	DB.DEB
	J	RTD2B
	ELSE	:
	JBS	RTD2B
	EI	:DB.DEB

::*********************************************************************
::
::	SUBROUTINE:	NXTBLT:
::	FUNCTION:	ALSO USED BY HISTORY-MAKER IN RMAKE
::	CALLING SEQ:	JAL	R8,NXTBLT
::
::*********************************************************************

NXTBLT	HS	0
	LIS	R0,XCBSZ-2		:COUNT OF BYTES IN BUFFERLET

	IF	REBILD
	CLI	R2,HBUFN		:IS R2 A HISTORY BUFFER INDEX	###OAS
	JLFS	RTDNX0			:NO				###OAS
	AM	R0,HBFTSV		:YES, UPDATE HISTORY BUFFER COUNT##OAS
	JGEFS	RTDNX0			:CHECK FOR HBFTSV GOING <0	###OAS
	JAL	R7,NEGHCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RTDNX0	HS	0
	EI	:REBILD
	AM	R0,BFLTSV		:UPDATE COUNT OF BUFFERLETS IN USE
	JGEFS	RTDNX9			:CHECK FOR BFLTSV GOING <0	###OAS
	JAL	R7,NEGBCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RTDNX9	AHM	R0,BCT,R2,		: AND COUNT FOR THIS BUFFER
	JG	RTDNX2			:BCT < 32K
	LHL	R0,BCT,R2,
	CI	R0,0FFF0		:ARE WE IN DANGER OF OVERFLOW?
	JL	RTDNX2			:NO
	ST	R4,REGST,,		:STORE R4 			###LSH
	JAL	R4,BFZDB2,,		:SAVE SOME DATA FOR DEBUGGING   ###LSH
	GL	BFZDB2			:BEFORE WE ZAP THE BUFFER 	###LSH 
	L	R4,REGST,,		:RESTORE R4 			###LSH
	JAL	R0,BUFZAP,,		:YES - ZAP BUFFER
	GL	BUFZAP
	L	R3,BE,R2,		:SET UP R3 FOR RE-ENTRY OF RTD INSTRUCT
	JR	R8

RTDNX2  LHL	R0,FREELT		:NEXT FREE BUFFERLET, PLEASE
	JNFS	RTDNX4			:SKIP IF SOMETHING THERE
	JAL	R0,WRE,,		:GET RESERVE TANK
	GL	WRE
	JBS	RTDNX2
RTDNX4	HS	0
	STH	R0,0,R3			:LAST 1/2 WD OF BUFFERLET IS LINK
	LR	R3,R0			:CURRENT BUFFERLET ADDRESS
	SLLS	R3,XCBSZL		:SHIFT APPROPRIATELY
	AI	R3,CHRBUF		:ADD IN START OF BUFFERLET AREA
	LHL	R0,CBSZ-2,R3		:NEXT BFLET FROM FREE LIST
	STH	R0,FREELT		:IS NOW FIRST IN QUEUE
	JR	R8			:GO CONTINUE PROCESSING
::
::***********************************************************************

:	HERE ON 02 CHARACTER DETECTION  ( TYMNET-I GOBBLER)

RTDC2	HS	0
	LIS	R0,2			:SET UP R0 FOR RTDIG
	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RTDIG			: CHANNELS 0 AND 1

	JAL	R9,RSTRIP,,		:TAKE CARE OF NEW BUFFLT ASSIGNED###GT
	SIS	LRC,1			:DECREMENT LOGICAL RECORD COUNT AND
	JAL	R9,GOBBLN,,		: GOBBLE DATA IN THE BUFFER
	GL	GOBBLN
	J	RTDTY1			:GO SKIP BY 2ND CHAR

:	HERE ON 00 CHARACTER

RTDC00	HS	0
	LIS	R0,0			:SET UP R0 IN CASE WE GO TO RTDIG
	JFS	RTDC0X

:	COME HERE FOR 01 CHARACTER

RTDC01	HS	0
	LIS	R0,1			:IN CASE WE GO TO RTDIG

RTDC0X	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RTDIG			: CHANNELS 0 AND 1.

	ST	R3,BE,R2,		:SAVE END POINTER
	STB	R0,0,R3			:STORE 1ST CHAR OF PAIR
:	NOTE:  R3 WAS ALREADY INC'D BY MICROCODE

	LB	R1,0,PRD		:GET NEXT CHAR (MICROCODE INC'D PRD)
	AIS	PRD,1
	JAL	R8,WCI,,		:STORE THE CHAR
	SIS	LRC,2			:DECREMENT COUNT FOR BOTH CHARACTERS

RTDTY1  L	R3,BE,R2,		:RESTORE BE POINTER
	LR	LRC,LRC			:DONE WITH LOGICAL RECORD?
	JG	RTD2			:MORE TO DO FOR THIS CHANNEL
	JE	RTD3			:DONE WITH THIS CHANNEL
:	NEIGHBOR SPLIT CHARACTER PAIR...SNIP THE LINK
:	IF NOT IN DEBUG MODE (DB.DEB SET)
	IF	DB.DEB
	DBOOPS
	ELSE	:NOT DB.DEB
	LIS	R0,LS.SCP		:INDICATE SPLIT CHARACTER PAIR RECEIVED
	EI	:DB.DEB
	J	RTDSNP			:GO SNIP THE LINK

:	HERE TO CONTINUE AS IF SPEC CHARACTER HADN'T BEEN DETECTED

RTDIG	SIS	LRC,1			:DECR LRC SINCE MICROCODE DIDN'T
	JG	RTD2A			:MORE FOR THIS CHANNEL, GO DO IT

	STB	R0,0,R3
	J	RTD3			:GO FINISH UP

RTDXIT  J	ILC			:PROCESS ANY ILC MESSAGE RECEIVED

ILCRET	HS	0			:RETURN FROM ILC PROCESS
BPVRET  L	R9,RTMXSV		:EXIT
	JR	R9

:	HERE ON 03 CHAR DETECTION (T-1 ZAPPERS, T-2 NETWORK CONTROL CHARACTERS)
:	R3	POINTS TO SLOT FOR '03' CHARACTER (BE)
:	LRC	HAS NOT BEEN DECREMENTED TO REFLECT '03'
:	PRD	POINTS TO SECOND CHARACTER IN 03-XX PAIR

RTDC3	HS	0
	LIS	R0,3			:SET UP R0 FOR RTDIG
	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RTDIG			: CHANNELS 0 AND 1
	SIS	LRC,1			:DECREMENT LRC TO ACCOUNT FOR 03 CHAR
	LB	R4,0,PRD		:TYM-II, CHECK SECOND CHAR
	AIS	PRD,1			:PRD ==> 1ST CHAR BEYOND 03-XX PAIR
	SIS	LRC,1			:DEC LRC, ACCNT FOR 2ND CHAR IN 03 PAIR
	CLHI	R4,01F			:IS CHAR A ZAPPER? ( 0301 TO 031F )
	JLE	RTDZPR			:YES
	CLHI	R4,03F			:IS CHAR A PERF MONITOR? (0320 TO 033F)
	JLE	RTDPFM			:YES

:	HERE IF INVALID 03 CHARACTER PAIR...

BADCTL	HS	0
	JAL	R9,GOBBLN,,		:CLEAR BUFFER OF SUSPICIOUS DATA
	LIS	R0,LS.I3P		:INDICATE LINK SNIP REASON
	J	RTDSNP			:INVALID 03 CHARACTER PAIR - SNIP LINK

:	HERE FOR TYMNET-II ZAPPER-LIKE CHARACTER PAIRS (03-01 TO 03-1F)

RTDZPR	HS	0
	LHL	R1,RTDZTB,R4,R4		:GET DISPATCH ADDRESS
	AHI	R4,300			:ROUTINES EXPECT WHOLE 03-CHAR PAIR
	J	SEG1,R1,		:GO HANDLE NETWORK 03-CHARACTER PAIR

::	HERE FOR PERFORMANCE MONITORING CHARACTER PAIRS (03-20 TO 03-3F)
::	THESE CHARACTER PAIRS !! MUST !! BE THE FIRST IN THE LOGICAL
::	RECORD. THIS PROPERTY IS GUARANTEED BY RMAKE.
::
::	THE PERFORMANCE-MONITORING LOGIC FIRST UNCONDITIONALLY STRIPS OUT
::	THE 03-XX CHARACTER PAIR, AND RETURNS TO THE FREE-LIST ANY BUFFERLET
::	THAT MAY HAVE BEEN ALLOCATED TO STORE THE PAIR. SUBSEQUENTLY,
::	ANOTHER 03-XX CHARACTER PAIR MAY BE WRITTEN INTO THE BUFFER BY
::	A SPECIFIC ROUTINE (IE, RTDXAK).

RTDPFM	CLHI	R4,PFMMAX		:MAKE SURE THE CHAR PAIR IS IN RANGE
	JG	BADCTL			:NO, BAD CONTROL CHARACTER
	JAL	R9,RSTRIP		:POSSIBLY DEALLOCATE A BUFFERLET
	LHL	R0,BF,R2,		:GET OTHER CHANNEL NUMBER
	LR	R1,R2
	SRLS	R1,3			:TEST FOR TERMINATION
	TBT	R1,CRQEND		:IF TERMINATION, THE BIT WILL BE SET
	JNFS	RTDPF3			:TERMINATION - T-I OR INTERNAL
	LHL	R1,PFMRTB,R4,R4 	:PASSTHROUGH, GET DISPATCH ADDRESS
	J	SEG1,R1,		:AND JUMP
RTDPF3	HS	0
	IF	REBILD
	LCS	R1,2			:TERMINATION, BACK UP SEQUENCE NUMBER
	AM	R1,VSEQN,R2,
	EI	:REBILD
	LHL	R1,PFMTRB,R4,R4		:GET DISPATCH ADDRESS
	J	SEG1,R1,		:AND JUMP

:	XLAX CHARACTER PAIR - PASSTHROUGH 

RTDXLA	SBT	R0,BPSVCP-LNKZFL/8,,	:OVERRIDE BACKPRESSURE
	LHI	R1,XLAX			:PASS ON XLAX CHARACTER PAIR
	JAL	R8,WCD,,
	GL	WCD
	LIS	R1,3
	JAL	R8,WCD,,
	J	PFMOUT			:CONTINUE WITH TEARDOWN OF LOGICAL REC

:	XLAX CHARACTER PAIR - TERMINATION OR T-1 NEIGHBOR

RTDXL1	XHI	R2,4			:TERMINATION, GET OTHER BUFFER
	LHI	R1,XLACK		:REFLECT XLAX ACK CHAR PAIR
	JAL	R8,WCD,,		:PREFIX INTO BUFFER
	LIS	R1,3
	JAL	R8,WCD,,
	SRLS	CHN,1			:GET TRUE CHANNEL NUMBER
	SBT	CHN,BPSVCP,,		:OVERRIDE BACKPRESSURE
	SLLS	CHN,1			:RESTORE CHN
	XHI	R2,4			:AND BUFFER NUMBER
	J	PFMOUT			:AND CONTINUE WITH TEARDOWN

:	XLACK CHARACTER PAIR - PASSTHROUGH

RTDXAK	SBT	R0,BPSVCP-LNKZFL/8,,	:OVERRIDE BACKPRESSURE
	LHI	R1,XLACK		:PASS ON XLACK CHARACTER PAIR
	JAL	R8,WCD,,		:PREFIX INTO BUFFER
	LIS	R1,3
	JAL	R8,WCD,,
	J	PFMOUT			:AND CONTINUE WITH TEARDOWN

:	GENERAL TERMINATION POINT NOTES TIME OF ARRIVAL OF CHAR PAIR

	SEG	0		:RELATED TO CHANGE DOCUMENTED BELOW	##TZ
ARRIVX	WS	1
ARRIVT	WS	1

	SEG	1
RTDSNK	L	R0,FASTC,,		:GET CURRENT TIME
	STH	R4,PFMTYP,,		:STORE THE PERFORMANCE MONITORING CHAR
	CLHI	R4,XLACK&0FF		:XLAX ACK?			##TZ
	JNFS	RTDSNT
	ST	R0,ARRIVX,,		:XLAX ACK TIME
	J	PFMOUT			:DONE
RTDSNT	HS	0			:MUST BE TIMER ACK
	ST	R0,ARRIVT,,		:RECORD TIME OF ARRIVAL TIMER ACK
	J	PFMOUT			:DONE				##TZ

:	GENERAL ALL-PASS ROUTINE SIMPLY PASSES ALL 03-XX PAIRS ALONG

RTDALL	LHI	R1,300,R4		:FORM 03-XX CHAR PAIR (2ND CHAR IN R4)
	JAL	R9,W2CI,,		:DEPOSIT INTO BUFFER
	GL	W2CI
	J	PFMOUT			:CONTINUE WITH TEARDOWN OF LOGICAL REC

:	TIMER CHARACTER PAIR - TERMINATION

RTDTM1	XHI	R2,4			:HERE IF TERMINATION,FLIP TO OTHER CHAN
	LIS	R1,3
	JAL	R8,WCI,,		:DEPOSIT 03
	LHI	R1,TIMACK
	JAL	R8,WCI,,		:AND TIMER ACK CHARACTER
	XHI	R2,4			:FLIP BACK TO ORIGINAL BUFFER
	J	PFMOUT			:CONTINUE WITH TEARDOWN OF LOGICAL REC

:	REJECT - HERE WHEN AN UNRECOGNIZED PERFORMANCE MONITORING PAIR
:	IS RECEIVED ON A CRQ THAT TERMINATES AT THE NODE (EITHER INTERNALLY
:	OR TO A T-1 NEIGHBOR). A REJECT CHARACTER PAIR IS SENT BACK TO THE
:	ORIGINATING END
RTDREJ	LIS	R1,3			:FORM 03
	XHI	R2,4			:FLIP TO OTHER BUFFER
	JAL	R8,WCI,,		:DEPOSIT 03
	LHI	R1,REJECT
	JAL	R8,WCI,,		:AND REJECT
	XHI	R2,4			:BACK TO ORIGINAL BUFFER
	J	PFMOUT			:CONTINUE TEARDOWN

:	CONTINUE WITH TEARDOWN OF LOGICAL RECORD AFTER PROCESSING
:	A PERFORMANCE-MONITORING CHARACTER PAIR, SQFIX QUAD OR SQACK QUAD

PFMOUT	LR	LRC,LRC			:MORE DATA IN LOGICAL RECORD?
	JE	RTD1			:NO, 03-XX CHAR PAIR (OR QUAD) WAS LAST
	JG	RTD610			:CONTIN WITH RTD COPY INSTRUCT FOR CHAN
	LIS	R0,LS.S3P		:LRC NEGATIVE, SPLIT 03-CHAR PAIR
	J	RTDSNP			:SNIP THE LINK...

RTDIGN	AR	PRD,LRC			:IGNORE REST OF RECORD
	J	RTD1			:BACK TO TOP OF RTD
					:--IS THERE ANOTHER RECORD?

::**********************************************************************
::	HANDLE LINK CONTROL MESSAGE
::  WE COME HERE IF HIGH ORDER BIT SET IN LOGICAL RECORD COUNT.
::  LINK CONTROL MSG FORMATS ARE:
::	40	PAGE CHANGE
::	20	BACKPRESSURE RELEASE(LOW 5 BITS HAVE COUNT OF NUMBER
::		OF CHANNELS TO BE RELIEVED.  REL CHNL #'S FOLLOW IN 
::		BYTES.)
::	00	SHRINK CMD, IF WE'RE SLAVE. REQUEST, IF WE'RE MASTER.
::	01	SHRINK ACK (OUR SLAVE HAS SHRUNK, SO WE FOLLOW)
::  NOTE--SLAVE DOES THE SHRINK BEFORE THE MASTER.
::	OTHER MSG'S UNKNOWN--SNIP THE LINK.
::**********************************************************************

RTDPRI	HS	0
	SIS	PRC,1			:DECREMENT PHYSICAL RECORD COUNT
	SIS	PRD,1			:BACK UP PRD SINCE 'RTD1' ASSUMED
					: LOGICAL RECORD HEADER LENGTH 2
	THI	LRC,40			:LRC CONTAINS CMD BYTE,
					: TEST FOR PAGE CHANGE
	JNFS	RTDP1			:NO
	NHI	LRC,3F			:PAGE CHANGE - ISOLATE NEW PAGE (BANK)
	STB	LRC,RTPAGE,KN,KN	: AND SAVE
	J	RTD1
RTDP1	THI	LRC,20			:TEST FOR BACKPRESSURE RELEASE
	JN	RTDP3			:NO
	NHI	LRC,1F			:BACKPRESSURE REC, ISOLATE LOGICAL REC
:	COUNT AND ADJUST PHYSICAL RECORD COUNT ACCORDINGLY
	SR	PRC,LRC
	LH	R0,RTPAGE,KN,KN		:GET CURRENT PAGE NUMBER. NOTE THAT
:	PAGE NUMBER IS LOADED INTO HI-ORDER BYTE OF HALFWORD.

:	COMPUTE MAXIMUM CHANNEL NUMBER FOR THIS LINK
	LH	R8,EBDPKN,KN,KN		:GET END OF TABLES ADDRESS AND
	SR	R8,R6			: SUBTRACT BEGIN ADDRESS
	SRLS	R8,1			:NUMBER OF CHANNELS THIS LINK
RTDP2	SIS	LRC,1			:COUNTER OF # CHNLS TO RELIEVE
	JL	RTD1			:DONE WITH BACKPRESSURE LOGICAL RECORD
	LB	R1,0,PRD		:GET NEXT BYTE FROM RECORD
	AIS	PRD,1			:INC TO READ NEXT CHANNEL # NEXT PASS
	STBR	R1,R0			:COMBINE PAGE NUMBER WITH RELATIVE
:	CHANNEL TO GET LINK'S ABSOLUTE CHANNEL NUMBER
	CR	R0,R8			:RANGE CHECK CHANNEL NUMBER
	JLFS	RTDP2A			:CHN # OK--SET BITS IN BIT ARRAYS
:	BACKPRESSURE RELIEVED FOR CHANNEL OUT OF OUR RANGE.
	IF	DB.DEB
	DBOOPS
	ELSE	:NOT DB.DEB
	LIS	R0,LS.BPC
	J	RTDSNP			:CHANNEL NUMBER OUT OF RANGE, SNIP LINK
	EI	:DB.DEB

RTDP2A	IF	APLYBP			:Apply BackPressure logic (Tymstar)
	LB	R3,KTYP,KD
	CLHI	R3,STRTYP		:Is this a Starlink ?
	JN	RTDP2B			:No .. just continue
	SBT	R0,APBPVD,R7,		:Mark as having rcvd Apply Backpressure
	RBT	R0,LNKBPV,R7,		:No channel service .. no tput refresh
	RBT	R0,BPSVCP,R7,		:For Starlink B.P. logic is reversed
	J	RTDP2			:Loop for rest of channels
RTDP2B	EI	:STRHUB!STRRMT

	SBT	R0,LNKBPV,R7,		:INDICATE BACKPRESSURE RECEIVED...
	SBT	R0,BPSVCP,R7,		: ...AND RELIEVED
	J	RTDP2			:LOOP TO SERVICE REST OF CHANNELS

RTDP3	NHI	LRC,1F			:LINK MESSAGE
	JE	RTDP4			:SHRINK COMMAND OR REQUEST
	SIS	LRC,1			:TEST FOR SHRINK ACKNOWLEDGE
	JEFS	RTDP3A			:YES
	LIS	R0,LS.UCR		:NO - UNKNOWN CONTROL RECORD RECEIVED
	J	RTDSNP			:SNIP LINK
RTDP3A	LIS	R0,0			:SLAVE ACKED SHRINK, NOW OUR TURN
	STB	R0,SHSTAT,KD		:THAW RMAKE

	SUBTTL	YAKYAK (SHRINK - Link shrink logic)

::*********************************************************************
::
::	SUBROUTINE:	SHRINK
::	FUNCTION:	Gives up half-page of permuter table space.  
::	Starting from highest channel on link, move permuter table entry
::	to lowest available channel.  Adjust necessary pointers, and 
::	report to Xray and Supervisor logs.
::	CALLING SEQ:	J SHRINK  (called from RTDP4A  shrink cmd or req)
::	INPUT:		KD,KN
::	PRESERVED:	R10
::	DESTROYED:	R-0,1,2,3,4,5,14,15.
::	CALLS:		JAL  R10,SUP12L
::	RETURNS:	J RTDXIT
::
::*********************************************************************

SHRINK	HS	0
	LHL	R0,NCHN,KD		:GET # OF CHANNELS ALLOCATED THIS LINK
	CLHI	R0,80			:DO WE HAVE MORE THAN 1 HALF-PAGE?
	JGFS	SHRK0			:YES - O.K.
	LIS	R0,LS.SNC		:NO - NOTHING TO SHRINK
	J	RTDSNP			:SNIP THE LINK
SHRK0	LHL	R1,TBDPKN,KN,KN		:R1 ==> BOTTOM OF LINK'S TABLE SPACE
	AIS	R1,2			:SKIP CHANNELS 0 AND 1
	LHL	R3,EBDPKN,KN,KN		:END OF IOTAB FOR THIS LINK
	J	SHRK2
SHRK1	THI	R3,0FF			:HALF PAGE BOUNDARY?
	JN	SHRK2			:NO - CONTINUE
	STH	R3,EBDPKN,KN,KN		:YES - DONE WITH SHRINK
	LHI	R0,-80
	AHM	R0,NCHN,KD		:DECREMENT # OF AVAILABLE CHANS ON LINK
	LHI	R0,-10			:# OF BYTES IN BIT ARRAY FOR 1/2 PAGE
	AHM	R0,LKFGND,KN,KN		:ADJUST 'PTR TO LAST HW' FIELDS FOR
	AHM	R0,LKSVND,KN,KN		: THIS LINK
	AHM	R0,LKBPND,KN,KN
	LB	R3,MASTKN,KN,		:ARE WE MASTER ON THIS LINK?
	JNFS	SHRK1A			:YES,NO NEED TO ADJUST ACP,CHS POINTERS
	AHM	R0,LKAPND,KN,KN
	AHM	R0,LKCSND,KN,KN
SHRK1A	LIS	R0,1
	AHM	R0,NUMPAG,,		:INCREMENT NUMBER OF PAGES AVAILABLE
	ST	R10,RTMT2		:SAVE PRC
	LIS	R0,NR.SHK		:INDICATE TYPE OF REPORT
	JAL	R10,SUP12L,,		:MAKE LINK SHRINK REPORT TO SUP LOG
	GL	SUP12L
	L	R10,RTMT2
	J	RTDXIT			:NOTHING ELSE IN THIS PACKET
SHRK2	SIS	R3,2			:DECREMENT TO NEXT CHANNEL
	LHL	R2,NIOTAB,R3,		:GET NEXT CHANNEL
	JE	SHRK1			:NULL ENTRY, NO MAPPING REQUIRED
SHRK3	AIS	R1,2			:WORKING FROM BOTTOM UP,
					: LOOK FOR NEW HOLE TO FILL
	LH	R0,NIOTAB,R1,
	JNBS	SHRK3			:ENTRY IN USE

:	FOUND AVAILABLE IOTAB ENTRY. MOVE BUFFER NUMBER AND SPEED BITS
:	TO NEW ENTRY, AND ADJUST BPSCNT, BF, AND ALL ATTENDANT BIT ARRAYS
:	FOR THIS CHANNEL.

	STH	R2,NIOTAB,R1,		:MOVE ENTRY FROM RETIRING HALF PAGE
	LIS	R0,0
	STH	R0,NIOTAB,R3,		:CLEAN UP BEHIND OURSELVES
	LH	R0,BPSCNT,R3,
	STH	R0,BPSCNT,R1,
	NHI	R2,-4			:ISOLATE BUFFER NUMBER
	XHI	R2,4			:GET BUFFER INDEX
	LH	R0,BF,R2,		: WHICH POINTS TO THIS IOTAB ENTRY
	JEFS	SHRK4			:DO NOT CHANGE IF 0
	LR	R4,R3			:COMPUTE GAP BETWEEN RETIRING IOTAB
	SR	R4,R1			: ENTRY AND NEW ENTRY
	SRLS	R4,1
	SR	R0,R4			:ADJUST BF BY CHANNEL DISPLACEMENT
	STH	R0,BF,R2,
	
:	THE FOLLOWING CODE RESETS THE BIT IN THE OLD POSITION, AND
:	SETS OR RESETS THE NEW CHANNEL BIT ARRAY AS NEEDED.

SHRK4	LR	R4,R1
	SRLS	R4,1			:NEW CHANNEL NUMBER
	LR	R5,R3
	SRLS	R5,1			:OLD CHANNEL NUMBER
	RBT	R5,GUSH,,			:RESET OLD GUSH
	JNFS	SHRK41			:IF SET, SET NEW TRIKLE
	RBT	R5,TRIKLE,,
	JEFS	SHRK42

:	SET NEW TRIKLE IF OLD GUSH OR TRIKLE SET
:	ALL OTHER BIT ARRAYS GET STRAIGHT COPY FROM OLD TO NEW
	
SHRK41	SBT	R4,TRIKLE,,	
SHRK42	RBT	R5,LNKFLG,,
	JEFS	SHRK43
	SBT	R4,LNKFLG,,
	JFS	SHRK44
SHRK43	RBT	R4,LNKFLG,,

SHRK44	IF	APLYBP		:For Apply Backpressure only
	RBT	R5,APBPVD,,
	JEFS	SHABP5
	SBT	R4,APBPVD,,
	JFS	SHABP6
SHABP5	RBT	R4,APBPVD,,
SHABP6	EI	:APLYBP

	RBT	R5,LNKBPV,,
	JEFS	SHRK45
	SBT	R4,LNKBPV,,
	JFS	SHRK46
SHRK45	RBT	R4,LNKBPV,,

SHRK46	RBT	R5,CHSRVD,,
	JEFS	SHRK47
	SBT	R4,CHSRVD,,
	JFS	SHRK48
SHRK47	RBT	R4,CHSRVD,,

SHRK48	RBT	R5,BPSVCP,,
	JEFS	SHRK49
	SBT	R4,BPSVCP,,
	JFS	SHRK50
SHRK49	RBT	R4,BPSVCP,,

SHRK50	RBT	R5,PRIRTY,,
	JEFS	SHRK51
	SBT	R4,PRIRTY,,
	JFS	SHRK52
SHRK51	RBT	R4,PRIRTY,,

SHRK52	RBT	R5,CMDCTS,,
	JEFS	SHRK53
	SBT	R4,CMDCTS,,
	JFS	SHRK54
SHRK53	RBT	R4,CMDCTS,,

SHRK54	RBT	R5,NEEDLE,,		:I THINK THIS FIXES A BUG	###TZ
	JEFS	SHRK55
	SBT	R4,NEEDLE,,
	JFS	SHRK56
SHRK55	RBT	R4,NEEDLE,,

SHRK56	SBT	R5,LNKACP,,
	JEFS	SHRK57
	SBT	R4,LNKACP,,
	JFS	SHRK58
SHRK57	RBT	R4,LNKACP,,

SHRK58	SBT	R5,LNKCHS,,
	JEFS	SHRK59
	SBT	R4,LNKCHS,,
	JFS	SHRK60
SHRK59	RBT	R4,LNKCHS,,

:	DETERMINE MAGNITUDE FROM BEGINNING OF ARRAY AND ADJUST ACP, CHS
:	IN NEGATIVE DIRECTION.

SHRK60	STM	R14,LNKRGS		:USE R14, R15 AS WORK REGS
	LCS	R14,1
	SR	R14,R4			:NEGATIVE NEW CHANNEL NUMBER
	LCS	R15,1
	SR	R15,R5			:NEGATIVE OLD CHANNEL NUMBER
	SBT	R15,EKNACP,,
	JEFS	SHRK61
	SBT	R14,EKNACP,,
	JFS	SHRK62
SHRK61	RBT	R14,EKNACP,,

SHRK62	SBT	R15,EKNCHS,,
	JEFS	SHRK63
	SBT	R14,EKNCHS,,
	JFS	SHRK64
SHRK63	RBT	R14,EKNCHS,,

SHRK64	LM	R14,LNKRGS
	J	SHRK1

:	GOT SHRINK COMMAND (OR REQUEST, IF NEIGHBOR IS SLAVE)
RTDP4	HS	0
	LHL	R0,NCHN,KD		:SHOULD WE EVEN CONSIDER SHRINK?
	CLHI	R0,80			:NEED MORE THAN 1/2 PAGE TO SHRINK
	JGFS	RTDP4A			:GOT IT
	LIS	R0,LS.SNC		:UNREASONABLE SHRINK REQUEST IF ONLY
	J	RTDSNP			: 80 CHANS ALLOCATED - SNIP THE LINK
RTDP4A	LH	R0,NEDOUT,KD		:ANY NEEDLES OUTSTANDING FOR THIS LINK?
	JN	RTDP6			:YES, DEFER SHRINK
					: UNTIL NEEDLES PROCESSED BY RMAKE
	STB	R0,NEDSUS,KD		:CLEAR SHRINK SUSPENDED INDICATION

	LH	R0,NDID,KD		:TEST FOR WHETHER WE'RE MASTER
	CLHI	R0,MACHNM		: OR SLAVE ON THIS LINK
	JLFS	RTDP5			:MASTER
	LIS	R0,1			:WE'RE THE SLAVE...
	STB	R0,SHSTAT,KD		:TELL RMAKE TO ACKNOWLEDGE SHRINK
	J	SHRINK			: AND GO DO IT
RTDP5	LB	R0,SHSTAT,KD		:WE'RE THE MASTER...
	JN	RTDXIT			:IGNORE IF SOMETHING IN PROGRESS
	LIS	R0,2			:TELL RMAKE
	STB	R0,SHSTAT,KD		: TO SEND SHRINK COMMAND TO NEIGHBOR
	J	RTDXIT			:NOTHING MORE IN THIS PACKET

::	WE RECEIVED SHRINK COMMAND/REQUEST FROM NEIGHBOR, BUT NEEDLES
:: FROM CRQ HAVE NOT YET BEEN PROCESSED BY RMAKE. WE MUST WAIT UNTIL
:: RMAKE PROCESSES ALL NEEDLES OUTSTANDING BEFORE SHRINKING LINK SO
:: THAT NEIGHBOR'S PERMUTER TABLES WILL MATCH OURS. WE STORE A NON-ZERO
:: VALUE IN 'NEDSUS' TO INDICATE SHRINK SUSPENDED UNTIL OUTSTANDING
:: NEEDLES PROCESSED BY RMAKE, AND EXIT RTD WITHOUT INCREMENTING 'LRT'
:: SO THAT WHEN RMAKE DRAINS OUTSTANDING NEEDLES AND RE-SCHEDULES RTD
:: WE WILL PROCESS SAME PACKET WHICH CONTAINS SHRINK COMMAND.

RTDP6	STB	R0,NEDSUS,KD	:NON-ZERO VALUE INDICATES SHRINK SUSPENDED
	J	RTEARZ		:RESET LKTEAR, DON'T INCREMENT LRT...

	SUBTTL	YAKYAK (RTD - ZAPPERS, GOBBLERS, NEEDLES, T-I SUP RECS)

:	MICROCODE HAS INCREMENTED 'BE' (R3) SO THAT NEXT BYTE SHOULD
: BE STORED WHERE R3 CURRENTLY POINTS. THIS ONLY MATTERS FOR NON-GOBBLING
: ZAPPERS SINCE OTHERS WILL CLEAR BUFFER BEFORE DEPOSITING ZAPPER CHARACTER
: PAIR.

:	RTDNGZ:
:	NON-GOBBLING ZAPPER. TEAR DOWN CIRCUIT BUT DON'T CLEAR BUFFER

RTDNGZ	HS	0
	ST	R3,BE,R2,		:SAVE CURRENT BE, POINTS TO SLOT FOR 03
RTDNG1	LHL	R0,NDID,KD		:REPORT ORIGINATING NEIGHBOR # TO X-RAY
	JAL	R8,CRYPTO,,		:DETECTED NON-GOBBLING ZAPPER
	HC	CRYE1F			: - PROBABLY FOLLOWS NEEDLE
	LIS	R1,3			:STORE 1ST BYTE OF NON-GOBBLING ZAPPER
	L	R3,BE,R2,		:RESTORE R3 FROM BE		###GT
	STB	R1,0,R3			: R3 ALREADY INCREMENTED
	JAL	R9,ZAPXNG,,		:ZAP WITHOUT CLEARING BUFFER
	GL	ZAPXNG			: AHEAD OF IT
	J	RTDZP2

::	RTDZPH:
::	HARD ZAPPER. TEAR DOWN CIRCUIT, CLEAR BUFFER, DON'T ATTEMPT REBUILD
::          IF A HARD ZAPPER IS RECEIVED, THE CIRCUIT IS NOT REBUILDABLE.
::          THEREFORE IT IS QUITE PERMISSIBLE TO CLEAR OUT THE NEEDLE
::          TO AVOID THE OVERHEAD OF REQUESTING REBUILD FOR THESE CIRCUITS.

	GL	PCIS
	GL	PCI
	
RTDZPH	HS	0
	IF	T2GATE
	LHL	R0,BF,R2,		:find destination chan numb
	CLHI	R0,DISZFL
	JL	GTZ006
	CLHI	R0,DISZFL+NDP		:If dispatcher, then account reason
	JGE	GTZ006
	AHI	R0,-DISZFL		:Get relativie port
	TBT	R0,GDSTPT		:and if we are a destination
	JEFS	GTZ002			:we will do accounting
	LHI	R0,AALR03
	JFS	GTZ004
GTZ002	LIS	R0,0
GTZ004	STH	R0,AAREAS,,		:Otherwise no accounting
GTZ006	HS	0
	EI	:T2GATE
	JAL	R9,ZAPHRD,,		:HARD-ZAP THE CIRCUIT
	GL	ZAPHRD
RTDZP2	LCS	R0,1
	AHM	R0,ANCHN,KD		:DECREMENT NUMBER OF ACTIVE CHANNELS
	LHL	R0,SLOWC+2,,
	STH	R0,BPSCNT,R6,CHN	:SAVE TIME THAT ZAPPER PASSED
	J	RTDIGN

:	RTDNAC:
:	NEEDLE POINT ON ASSIGNED CHANNEL. HARD-ZAP IN BOTH DIRECTIONS

RTDNAC	JAL	R9,ZAPHRD,,		:NEEDLE ON ASSIGNED CHANNEL
	JAL	R8,GFCBUF,,		:ZAP CIRCUIT IN BOTH DIRECTIONS
	GL	GFCBUF
	J	RTDOOB			:immed. return - out of buffers!###wjl
	SRHLS	CHN,1			:+4 return - got a buffer	###wjl
	AH	CHN,LKZFKN,KN,KN
	JAL	R9,CRQHCR,,
	GL	CRQHCR
	XHI	R2,4
	LHI	R1,ZAPPH
	EXBR	R1,R1
	JAL	R8,WCI
	EXBR	R1,R1
	JAL	R8,WCI
	LCS	R0,1
	AHM	R0,ANCHN,KD		:DECREMENT NUMBER OF ACTIVE CHANNELS
	LR	R0,CHN
	SH	R0,LKZFKN,KN,KN		:GET BACK RELATIVE CHAN FOR THIS LINK
	LHL	R8,NDID,KD		:NEIGHBOR#
	STH	R8,CRYSBF+2		:SAVE FOR CRYPTO
	JAL	R8,CRYPTO,,		:SEND CRYPTOGRAM FOR NEEDLE ON
	HC	CRYE29			: ASSIGNED CHANNEL
	J	RTDIGN

:	HANDLE SOFT ZAPPER ON TYMNET-II CHANNEL

RTDZPS	ST	R10,RTMT1		:SOFT ZAPPER
	ST	R3,BE,R2,		:SAVE CURRENT BE, POINTS TO SLOT FOR 03
	IF	REBILD
	LCS	R0,2			:BACK UP RECEIVE SEQUENCE NUMBER
	AM	R0,VSEQN,R2,		: - ZAPPERS ARE NOT COUNTED
	EI	:REBILD
	LR	R1,R4
	JAL	R10,TRCIRC,,		:TEAR DOWN CIRCUIT,
	GL	TRCIRC			: POSSIBLY REQUEST REBUILD
	L	R10,RTMT1
	J	RTDZP2			:GO DECREMENT ACTIVE CHANS, SAVE TIME

::	RTDGOB:
::	GOBBLER - CLEAR BUFFER AND PASS GOBBLER ALONG

RTDGOB	JAL	R9,GOBBLN,,		:GOBBLER
	J	RTDTY1

::	RTDFGB:
::	FAT GOBBLER. 6-WORD NETWORK CONTROL, THE FULLWORD FOLLOWING
::	THE 03-XX CONTAINS THE NEW SEQUENCE NUMBER.
::	CLEAR BUFFER EXCEPT FOR NEEDLES AND SEQUENCE FIXES.
::	IF PASSTHRU, PASS FAT GOBBLER ON.
::	IF TERMINATION, SHRINK FAT GOBBLER INTO SKINNY ONE AND ADJUST THE
::	VSEQN ACCORDING TO THE FW OF DATA.

RTDFGB	JAL	R9,RSTRIP		:UNCONDITIONALLY STRIP OUT NEW BUFFERLT
	LHL	R8,BCT,R2,		:IS BUFFER EMPTY?		###GT
	JEFS	RTFGB1			:YES, DON'T CHECK FOR NEEDLES/SQFIX#GT
	JAL	R8,PCIS,,		:CHECK BUFFER FOR NEEDLES & SQFIX###GT
	SIS	R1,3			:03-CHARACTER PAIR?		###GT
	JNFS	RTFGB1			:NO				###GT	
	JAL	R8,PCI,,		:YES - CHECK NEXT BYTE		###GT
	CLHI	R1,NEEDP&0FF		:NEEDLE POINT?			###GT
	JEFS	RTFGB2			:YES - DON'T GOBBLE		###GT
	CLHI	R1,SQFIX&0FF		:SEQUENCE FIX?			###GT
	JEFS	RTFGB2			:YES - DON'T GOBBLE		###GT
RTFGB1	JAL	R8,CBCLR,,		:UNCONDITIONALLY CLEAR OUT THE BUFFER
	GL	CBCLR
RTFGB2	LHL	R3,BF,R2,		:GET THE ONGOING CHANNEL NUMBER
	JAL	R8,SPEED,,		:SPEED THINGS UP, CLEAR BACKPRESSURE
	GL	SPEED
	JAL	R9,CHKTRM		:CHECK FOR TERMINATION
	J	RTPFGB			:NOT A TERMINATION, PASS GOBBLER ALONG
	JAL	R9,GOBBLN,,		:TERMINATION - WRITE IN A GOBBLER
	IF	REBILD
	AHI	R4,2,LRC		:FORM THE NEW SEQUENCE NUMBER	###GT
	ST	R4,VSEQN,R2,		:(R4 SET UP IN CHKTRM)		###GT
	EI	:REBILD
	J	PFMOUT			:AND PROCEED WITH RECORD TEARDOWN

::	RTDSQK:
::	REBUILD SEQUENCE NUMBER ACK - SENT BY FAR END IN RESPONSE TO A
::	SQFIX CHARACTER PAIR. SIMPLY PASSES ALONG QUAD IF A PASSTHRU, ELSE
::	PRUNES HISTORY BUFFER ON BASIS OF HW SEQUENCE NUMBER FOLLOWING
::	THE CHARACTER PAIR.
::	EXPECTS R2 = BUFFER NUMBER, R3 = SLOT FOR '03' CHARACTER

RTDSQK	JAL	R9,RSTRIP		:POSSIBLY DE-ALLOCATE
					: A NEWLY-ACQUIRED B'LET
	JAL	R9,CHKTRM		:DECIDE - TERMINATION OR PASSTHRU?
	J	RTKSQP			:PASSTHRU - JUST PASS QUAD ALONG
	IF	REBILD
	TBT	R1,CRQBSY		:IS REBUILD ENABLED FOR THIS CHANNEL?
	JE	PFMOUT			:NO, MUST HAVE BEEN TURNED OFF IN RMAKE
	SBT	R1,SQFIXV,,		:NOTE REBUILD QUAD RECEIVED
					: (R1 SETU IN CHKTRM)
	LCS	R0,6			:BACK UP VSEQN BY 6, SQACKS DON'T COUNT
	AM	R0,VSEQN,R2,		:VSEQN WAS ADVANCED BY 'LRC' AT RDT15
	SLLS	R1,2			:GET HISTORY BUFFER NUMBER
	LHL	R0,REBDIS,,		:DISPLAY THIS ACTIVITY?
	JE	RTDSQY			:NO
	L	R0,HBSEQN,R1,		:GET CURRENT HISTORY BUFFER SEQ#
	ST	R0,CRYSBF
	LR	R3,R4			:PRESERVE R4
	NHI	R3,0FFFF		:MASK OUT HO HW
	LHL	R0,BF,R2,		:GET DESTINATION CHANNEL
	EXHR	R0,R0
	OR	R0,R3			:COMBINE WITH DATA
	JAL	R8,CRYPTO,,		:AND REPORT
	HC	CRYE66
RTDSQY	HS	0
	S	R4,HBSEQN,R1,		:GET NUMBER OF CHARACTERS OUTSTANDING
	JLE	PFMOUT			:NO PRUNING POSSIBLE HERE
					: - CONTINUE TEARDOWN
      IF 1-REBTST        :much more efficient routine by sdw
	SRLS	R4,4			:AND DIVIDE BY 16
	JE	PFMOUT			:IF LESS THAN A BF'LET'S WORTH, DON'T
	STH	R2,BUFSAV		:SAVE ORIGINAL BUFFER INDEX
	LI	R2,HBUFN,R1		:FORM THE ASSOCIATED HISTORY BUFFER #
BFDUMP	JAL	R8,RETBLT,,		:DISCARD ONE BUFFERLET
	GL	RETBLT
	LIS	R0,0E			:EACH B'LET HAS THIS MANY BYTES
	AM	R0,HSEQN,R2,		:UPDATE SEQ# OF OLDEST CHAR IN H-BUFFER
	SIS	R4,1			:CAN MORE BUFFERLETS BE DISCARDED?
	JGBS	BFDUMP			:YES, KEEP DUMPING THEM
       ELSE  :sdww.2
        STH     R2,BUFSAV               :save original buffer index
        LI      R2,HBUFN,R1             :form the associated history buffer #
        LR      R0,R4                   :tell routine how many to remove
        JAL     R8,RTBFTS,,             :return all R4 number of chars
        GL RTBFTS
        AM      R0,HSEQN,R2,            :R0 gets number of chars returned
     EI :REBTST
	LHL	R2,BUFSAV		:RESTORE ORIGINAL BUFFER INDEX
	EI	:REBILD
	J	PFMOUT			:CONTIUE TEARDOWN

::	RTDSQF:
::	HANDLE SEQUENCE NUMBER FIX. IF NOT TERMINATION, JUST PASS ON
::	6-WORD NETWORK CONTROL. OTHERWISE TEST FOR SEQUENCE NUMBERS EQUAL.
::	EXPECTS R4 TO CONTAIN THE SQFIX DATA WORD.

RTDSQF	HS	0
	JAL	R9,RSTRIP		:POSSIBLY DE-ALLOCATE
					: NEWLY-ACQUIRED B'LET
	JAL	R9,CHKTRM		:SEE IF PASSTHRU OR TERMINATION
	J	RTDSQP			:PASSTHRU
					: - SIMPLY MOVE THE NETWORK QUAD ALONG
	IF	REBILD
	LR	R4,R4			:SEQ NO. RETURNED IN R4		###GT
	JGEFS	RTDSQ1			:NOT -1				###GT
	JAL	R9,RBCOUT,,		:SEQN=-1 IS A NAK, DISABLE REBUILD#GT
	GL	RBCOUT
	J 	PFMOUT			:CONTINUE WITH RECORD TEARDOWN
RTDSQ1	SBT	R1,SQFIXV,,		:NOTE SQF QUAD RECEIVED
					: (R1 SET UP IN CHKTRM)
	LR	R4,R4			:CHECK SEQN NO. AGAIN		###GT
	JNFS	RTDSQ3			:CONTINUE IF NE 0		###GT
	J 	RTDSQ2			:SQFIX 0 IS A SPECIAL CASE - DON'T
					:FIX UP SEQUENCE NUMBERS
RTDSQ3	LHL	R9,BF,R2,
	CLHI	R9,CRQZFL		:STUB, INTERCEPT, NEW CIRCUIT?
	JLE	RTDSQ2			:YES, IGNORE SQF, CRQ NOT FINISHED###CY
	LR	R9,R1			:SAVE REBUILD BUFFER BIT ARRAY INDEX
	LHI	R1,SQACK		:BOUNCE BACK SEQUENCE # WITH A SQACK
	XHI	R2,4			:THE OTHER BUFFER
	JAL	R9,W2CI,,
	LR	R1,R4			:SEQUENCE NUMBER (R4 SET UP IN CHKTRM)
	EXHR	R1,R1			:UPPER HW OF SEQUENCE NUMBER	###GT
	JAL	R9,W2CI,,		: (UPPER HW)
	EXHR	R1,R1			:LOWER HW OF SEQUENCE NUMBER	###GT
	JAL	R9,W2CI,,		:				###GT
	XHI	R2,4			:BACK TO THIS BUFFER
	LR	R0,R4			:VERIFY VSEQN INTEGRITY, R4 CONTAINS
	S	R0,VSEQN,R2,		:OLD VSEQN,PRIOR TO RTD15 UPDATE BY LRC
	AI	R0,6,LRC		:LRC HAS ALREADY BEEN REDUCED BY 6###GT
	JE	RTDSQ2			:OK, REBUILD STILL IN SYNC FOR THIS CRQ

	AM	R0,VSEQN,R2,		:ERROR,
					: PRESUME MOST RECENT SQFIX IS CORRECT
	NI	R0,0FFFF		:STRIP POSSIBLE SIGN EXTENSION
	STH	R0,SUPMBF+4		:STORE AWAY THE ERROR COUNT
	STH	R2,SUPMBF+2		:AND THE BUFFER NUMBER
	LHI	R1,NR.SQF		:MESSAGE TYPE - SQFIX ERROR
	STH	R1,SUPMBF
	STM	R0,TRREGS		:PRESERVE REGISTERS THROUGH SUP12 CALL
	JAL	R10,SUP12,,
	LM	R0,TRREGS
	LHL	R1,BF,R2,		:GET DESTINATION CHANNEL,
	EXHR	R0,R0			: ALIGN SQF DIFFERENCE IN UPPER R0,
	OR	R0,R1			: AND COMBINE
	JAL	R8,CRYPTO,,		:ADVISE XRAY - SQF ERROR
	HC	CRYE63

RTDSQ2	LCS	R0,6			:REDUCE VSEQN BY 6
					: SINCE SQFIX'S DON'T COUNT
	AM	R0,VSEQN,R2,
	LHL	R0,REBDIS,,		:DISPLAY SQF ACTIVITY?
	JE	PFMOUT			:NO, CONTINUE WITH LOGICAL REC TEARDOWN
	ST	R4,CRYSBF		:SAVE FOR XRAY (DISPLAY SQF # RECVD)
	LHL	R0,BF,R2,
	EXHR	R0,R0			:NOW GET CHANNELS FOR DISPLAY
	XHI	R2,4
	OH	R0,BF,R2,
	XHI	R2,4
	JAL	R8,CRYPTO,,
	HC	CRYE65
	EI	:REBILD
	J	PFMOUT			:CONTINUE WITH LOGICAL RECORD TEARDOWN

:	RTDSQP:
:	RTPFGB:
:	RTKSQP:
:	PASS SQACK, FAT GOBBLER OR SQFIX ALONG.  R4 = HW OF DATA

RTPFGB	LHI	R1,GOBBF		:ENTRY POINT FROM RTDFGB
	JFS	RTDSQZ
RTKSQP	LHI	R1,SQACK		:ENTRY POINT FROM RTDSQK - SET UP R1
	JFS	RTDSQZ
RTDSQP	LHI	R1,SQFIX		:ENTRY POINT FROM RTDSQF - SET UP R1
RTDSQZ	JAL	R9,W2CI,,		:SQF OR SQFIX PASS-THROUGH	###LH
	LR	R1,R4			:SQACK OR SQFIX DATA
	EXHR	R1,R1			:UPPER HW			###GT
	JAL	R9,W2CI,,		:				###LH
	EXHR	R1,R1			:LOWER HW			###GT
	JAL	R9,W2CI,,		:			###LH	###GT
	J	PFMOUT

::*********************************************************************
::
::	SUBROUTINE:	CHKTRM
::	FUNCTION:	Pre-processor for SQFIX and SQACK network quads.
::	read network quad from buffer, adjust LRC and PRD, test for
::	terminating circuit.  Skip return if termination, immediate return
::	if pass-thru.
::	CALLING SEQ:	JAL  R9,CHKTRM
::	INPUT:		PRD
::	OUTPUT:		R4 = FW following network character pair
::	DESTROYED:	R1
::	RETURNS:	JER  R9		: Passthrough
::			J    4,R9	: Termination
::
::*********************************************************************

CHKTRM	HS	0
	LB	R1,0,PRD		:COLLECT NEXT TWO BYTES FROM PACKET
	LB	R4,1,PRD
	EXBR	R1,R1
	OR	R4,R1			:ASSEMBLE HW DATA INTO R4
	EXHR	R4,R4			:SHIFT INTO UPPER HW		###GT
	LB	R1,2,PRD		:NOW THE LOWER HW		###GT
	EXBR	R1,R1			:				###GT
	OR	R4,R1			:				###GT
	LB	R1,3,PRD		:				###GT
	OR	R4,R1			:				###GT
	AIS	PRD,4			:ADVANCE PRD BEYOND THE CHARACTER QUAD
	SIS	LRC,4			:ADJUST COUNT,BYTES LEFT IN LOGICAL REC
	LR	R1,R2			:MOVE BUFFER NUMBER OVER TO R1
	SRLS	R1,3			:DIVIDE BUFF # BY 8 FOR CRQ ARRAY INDEX
	TBT	R1,CRQEND		:TEST FOR ENDPOINT ON THIS NODE
	JER	R9			:NO, A PASSTHRU - IMMEDIATE RETURN
	J	4,R9			:A TERMINATION - SKIP RETURN

::*********************************************************************
::
::	SUBROUTINE:	RSTRIP:
::	FUNCTION:	RSTRIP returns to free pool bufferlets that may
::	have been allocated by the RTD microcode in response to some 03
::	character pair that is	not to be written into the circuit buffer
::	(i.e. seq number acks).
::
::	This routine is necessary because the RTD microcode instruction
::	exits to allocate a new bufferlet before it exits for an 03-XX
::	character pair. Thus, an 03-XX char pair may trigger a bufferlet
::	allocation even though it may not actually be written into the 
::	bufferlet.
::
::	CALLING SEQ:	JAL  R9,RSTRIP
::	INPUT:		R2 = Buffer Number
::			R3 = Working 'BE'
::	DESTROYED:	R0,R3,R8
::	CALLS:		JAL  R8,CBCLR,,
::			JAL  R7,NEGBCR
::			JAL  R7,NEGHCR
::	RETURNS:	JR  R9
::
::*********************************************************************

RSTRIP	HS	0
	CL	R3,BB,R2,		:HAS 1ST BUFFERLET JUST BEEN ALLOCATED?
	JNFS	RSTRI1			:NOT FIRST BUFFERLET
	JAL	R8,CBCLR,,		:WE'RE NOT GOING TO USE BUFFRLT,DISCARD
	JR	R9			:RETURN
RSTRI1	LR	R0,R3			:IF RUNNING 'BE' IS
	NHI	R0,0F			: EQUAL TO 2 MOD 10,
	SIS	R0,2			: THEN WE'VE JUST ACQUIRED NEW BUFFERLT
	JGR	R9			:NO, GO AWAY
:	SPLICE NEW BUFFERLET BACK INTO FREE LIST, AND DECREMENT
:	BUFFER COUNTS
	LHL	R0,FREELT
	STH	R0,CBSZ-2,R3		:THIS BUFFERLET NOW 1ST IN LINKED LIST
	SI	R3,CHRBUF
	SRLS	R3,XCBSZL		:BUFFERLET INDEX
	STH	R3,FREELT		:FREE LIST ==> BUFFRLT WE'RE DISCARDING
	LCS	R0,0E			:(CBSZ-2, BUT NAD WON'T ALLOW)
	AHM	R0,BCT,R2,		:DON'T COUNT THIS BUFFERLET
	AM	R0,BFLTSV
	JGEFS	RSTRI9			:CHECK FOR BFLTSV GOING <0	###OAS
	JAL	R7,NEGBCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RSTRI9	HS	0
	IF	REBILD
	CLI	R2,HBUFN		:IS R2 A HISTORY BUFFER INDEX	###OAS
	JLFS	RSTRI2			:				###OAS
	AM	R0,HBFTSV		:YES, UPDATE HISTORY BUFFER COUNT##OAS
	JGEFS	RSTRI2			:CHECK FOR HBFTSV GOING <0	###OAS
	JAL	R7,NEGHCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RSTRI2	HS	0
	EI	:REBILD

	JR	R9			:DONE

::	RTDZPF:
::	FAT ZAPPER. 6-BYTE NETWORK CONTROL, SOFT ZAPPER FOLLOWED BY
::	OFFENDING NODE PAIR WHOSE LINK FAILED AND CAUSED ALL THIS...

RTDZPF	HS	0
	ST	R10,RTMT1		:PRESERVE R10 (PRC)
	JAL	R9,RSTRIP		:FREE UP ANY NEWLY-ACQUIRED BUFFERLET
	IF	REBILD
	LCS	R0,6
	AM	R0,VSEQN,R2,		:BACK UP SEQUENCE #, DON'T COUNT ZAPPER
	EI	:REBILD			:###GT
	LR	R1,R4			:TRCIRC EXPECTS RELEVANT ZAPPER IN R1
	JAL	R10,TRCRFT,,		:TEAR DOWN CIRC, CHECK FOR TERMINATION
	GL	TRCRFT
	L	R10,RTMT1
	LCS	R0,1
	AHM	R0,ANCHN,KD		:ONE LESS CHANNEL THIS LINK
	LHL	R0,SLOWC+2,,
	STH	R0,BPSCNT,R6,CHN	:SAVE TIME THAT ZAPPER PASSED
	LH	R0,TRCSV2		:DEPOSIT 'FAT' IN BUFFER?
	JL	RTFZ10			:NO, REBUILD REQUEST MADE
	LH	R0,BF,R2,		:WAS BUFFER RETURNED		###CY
	JL	RTFZ10			:DON'T WRITE INTO IT IF SO	###CY
	LB	R4,0,PRD
	LB	R1,1,PRD		:GET NEXT TWO BYTES
	EXBR	R4,R4
	OR	R1,R4			:FIRST NODE NUMBER FOLLOWING FAT ZAPPER
	JAL	R9,W2CI
	LB	R4,2,PRD
	LB	R1,3,PRD
	EXBR	R4,R4
	OR	R1,R4			:SECOND NODE # FOLLOWING FAT ZAPPER
	JAL	R9,W2CI
RTFZ10	AIS	PRD,4			:ADJUST RECORD POINTER PAST 'FAT'
	J	RTD1

:	HERE FOR DATA ON AN UNASSIGNED CHANNEL
RTDUAC	HS	0
	LB	R0,0,PRD		:T-II - IS IT A NEEDLE?
	EXBR	R0,R0
	LB	R1,1,PRD
	AR	R1,R0
	CLHI	R1,NEEDP
	JN	RTDUA2			:NOT A NEEDLE - REPORT AND TOSS

:	HERE WHEN A NEEDLE ARRIVES ON AN UNASSIGNED CHANNEL
RTDUAN	LIS	R0,1
	AHM	R0,ANCHN,KD		:INCREMENT NUMBER OF ACTIVE CHANNELS
RTDUA1	JAL	R8,GFCBUF,,		:SAVE DATA FOR CRQ
	J	RTDOOB			:immed. return - out of buffers!###wjl
	SRHLS	CHN,1			:+4 return, ok - COMPUTE ABSOLUTE CHN #
	AH	CHN,LKZFKN,KN,KN
	JAL	R9,CRQHCR,,		:BUILD 'HALF CIRCUIT'
	SH	CHN,LKZFKN,KN,KN
	SLHLS	CHN,1
	LHI	R0,CIRSP0		:GIVE IT SOME TRANSMIT CAPACITY
	STH	R0,BPSCNT,R6,CHN

	LR	R1,R2
	SRLS	R1,1			:SET UP BUFTIM INDEX
	L	R0,FASTC,,
	ST	R0,BUFTIM,R1,		:TIME THAT NEEDLE ORIGINATES IN NODE

	JAL	R9,CRQALT,,		:ALERT CRQ OF NEEDLE AND...
	GL	CRQALT
	LHI	R1,NEEDP		:INSERT NEEDLE POINT INTO BUFFER
	JAL	R9,W2CI
	AIS	PRD,2			:ADVANCE PRD PAST THE NEEDLE POINT
	LB	R0,0,PRD		:GET LENGTH ESCAPE		###GT
	EXBR	R0,R0			:				###GT
	LB	R1,1,PRD		:LENGTH OF NEEDLE		###GT
	LR	R4,R1			:SAVE TEMPORARILY		###GT
	AR	R1,R0			:				###GT
	JAL	R9,W2CI			:INSERT INTO BUFFER		###GT
	AIS	PRD,2			:ADVANCE PRD PAST 2 BYTES	###GT
	SIS	R4,4			:NEEDLE LENGTH - 4		###GT
	SIS	LRC,4			:DECR LRC TO ACCOUNT FOR NEEDLE+COUNT
RTDU10	LB	R1,0,PRD		:GET A BYTE			###GT
	JAL	R8,WCI,,		:WRITE INTO BUFFER		###GT
	AIS	PRD,1			:ADVANCE PRD PAST THIS BYTE	###GT
	SIS	LRC,1			:DECREMENT LRC TO ACCOUNT FOR BYTE#GT
	SIS	R4,1			:COPY OVER THE WHOLE NEEDLE	###GT
	JGBS	RTDU10
	
	JAL	R8,PCIS,,		:SKIP OVER NEEDLE POINT		###GT
	JAL	R8,PCI,,
	JAL	R8,PCI,,		:JUMP OVER ESCAPED LENGTH	###GT
	JAL	R8,PCI,,
	JAL	R8,PCI,,		:SKIP OVER LINK COUNT		###GT
	JAL	R8,PCI,,
	LIS	R5,5			:5 HALF-WORDS TO SKIP OVER	###GT
RTDU11	JAL	R9,PHWI			:SKIP OVER INVOICE #,FLAGS	###GT
	GL	PHWI
	SIS	R5,1			:REQUESTING NODE AND PORT#	###GT
	JGBS	RTDU11
RTDU12	JAL	R9,PHWI			:SKIP OVER 'CREAMED' NODE #'S	###GT
	CI	R1,0FFFF		:= -1?				###GT
	JEBS	RTDU12
	TI	R1,8000			:ARE WE THE TERMINATION NODE?	###GT
	JEFS	RTDU13			:NO - CARRY ON			###GT
	LR	R4,R2			:YES - SET BIT FOR TERMINATION	###GT
	SRHLS	R4,3
	SBT	R4,CRQEND
RTDU13	LR	LRC,LRC			:ANY DATA LEFT TO COPY?		###GT
	JE	RTD1			:NO, DONE WITH THIS LOGICAL RECORD#GT
	J	RTD6			:YES, REPEAT PASS THRU RTD TO COPY DATA

::	DATA RECEIVED ON UNASSIGNED CHANNEL FROM NETWORK NEIGHBOR.
::	REPORT TYPE 2 MESSAGE TO SUP LOG, WITH HIGH-ORDER BIT OF THIRD
::	HALFWORD SET IF DATA IS A ZAPPER. REPORT TO XRAY WITH NEIGHBOR
::	AND CHANNEL NUMBER. DISCARD DATA RECEIVED.

RTDUA2	HS	0
	LR	R0,CHN
	SRLS	R0,1			:SET UP TYPE 2 NODE REPORT
	RBT	R0,LNKCHS,R7,		:DON'T REPORT
					: IF ZAPPER RECENTLY TRAVELLED
	JE	RTDIGN			:CHANNEL SUSPENDED
	STH	R0,SUPMBF+4		:CHANNEL NUMBER IN HW 3
	LIS	R1,NR.UAC
	STH	R1,SUPMBF		:INDICATE TYPE 2
	LHL	R1,NDID,KD
	STH	R1,CRYSBF+2
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER IN HW 2
	LB	R1,0,PRD		:GET DATA RECEIVED AND
	SIS	R1,3			: TEST FOR ZAPPER
	JNFS	RTDUA4			:NO
	SBT	R1,SUPMBF+4		:YES - SET HI-ORDER BIT IN HW 3
	JAL	R8,CRYPTO,,		:REPORT ZAPPER ON UNASSIGNED CHANNEL
	HC	CRYE09
	JFS	RTDUA6
RTDUA4	JAL	R8,CRYPTO,,		:REPORT DATA ON UNASSIGNED CHANNEL
	HC	CRYE28
RTDUA6	ST	R10,RTMT1
	JAL	R10,SUP12,,		:SEND REPORT TO SUP LOG
	LIS	R0,NR.CTM		:NOW REPORT TIME SINCE CHAN WAS ZAPPED
	STH	R0,SUPMBF		:NODE REPORT TYPE
	LH	R0,SLOWC+2,,		:CURRENT TIME MINUS
	SH	R0,BPSCNT,R6,CHN	: TIME THAT ZAPPER PASSED YIELDS # OF
	STH	R0,SUPMBF+2		: SECONDS THAT CHAN HAS BEEN UNASSIGNED
	JAL	R10,SUP12,,		:REPORT IT TO SUP LOG
	L	R10,RTMT1
	IF	DB.DEB
	LHL	R0,NDID,KD
	CLHI	R0,$82000		:TYMNET-II NEIGHBOR?
	JL	RTDIGN			:NO, IGNORE T-I DATA ON UNASSIGNED CHAN
	LB	R0,0,PRD		:WAS DATA A ZAPPER?
	SIS	R0,3			:(IF SO, IT COULD HAVE GOBBLED NEEDLE)
	JE	RTDIGN			:O.K.
	DBOOPS				:CAN'T EXPLAIN IT FROM T-II NEIGHBOR...
	EI	:DB.DEB
	J	RTDIGN			:IGNORE DATA ON UNASSIGNED CHANNEL

::	RTDSNP
::	ERROR DETECTED IN PACKET FROM NEIGHBOR - SNIP THE LINK. SET 'BORI ZAP'
::	BIT TO CAUSE LINK TO GO OUT NEXT EXECUTION OF LNCHCK. SAVE LINK SNIP
::	REASON IN SNPTYP FOR NODE REPORT IN TRLINK, AND DON'T TEAR ANY MORE
::	PACKETS FOR THIS LINK.

:	entry for error return from GFCBUF when out of buffers		###wjl
RTDOOB	LHI	R0,LS.OOB		:out of buffers			###wjl
	JFS	RTDSN0			:R3 not set-up for unassigned chn##wjl

RTDSNP	HS	0
	CR	PRD,R3			:see if PRD has been clobbered
	JLFS	RTDSN0			:no
	LIS	R0,LS.MCE		:reg 12 got clobbered in RTD microcode
RTDSN0	STH	R0,SNPTYP,KN,KN		:SAVE REASON FOR LINK SNIP
	SBT	KN,BORZAP		:AND TAKE LINK OUT

:	SAVE SOME USEFUL DATA
	LHL	CD,NRTR,KD		:RECORD DESCRIPTOR INDEX
	LHL	R9,RECN,CD		: AND RECORD NUMBER
	STM	R0,LKSNRG		:MIGHT BE SOME INTERESTING CLUES HERE

	IF	DB.TSN
:	SAVE OFFENDING PACKET
	IF	EXPWSZ
	L	R1,BREC,CD
	ELSE
	LHL	R1,BREC,CD
	EI
	AI	R1,RECBUF		:PACKET BEGIN ADDRESS
	LHI	R2,7C
RTDSN2	L	R0,0,R1,R2
	ST	R0,LSNPSV,R2,		:SAVE LINK SNIP PACKET IN LSNPSV
	SIS	R2,4
	JGEBS	RTDSN2
	EI	:DB.TSN
	J	RTEARZ			:DONE WITH THIS LINK...

:	GOT CHANNEL NUMBER GREATER THAN MAX NUMBER ALLOCATED. IF CHN IS
:	GROSSLY HIGHER THAN CURRENT MAX, SOMETHING WRONG. OTHERWISE, T-II
:	NEIGHBOR MUST WANT US TO BUBBLE THE LINK.

RTDBIG	STH	CHN,RTMT3
	SR	CHN,R0
	CLHI	CHN,80			:HOW MUCH OVER IS IT?
	JLFS	RTD1C			:A LITTLE
	IF	DB.DEB
	DBOOPS				:	...ALOT
	ELSE	:NOT DB.DEB
RTD1B	LIS	R0,LS.COR		:CHANNEL OUT OF RANGE
	J	RTDSNP			:ERROR IN PACKET FROM NEIGHBOR
					: - SNIP THE LINK
	EI	:DB.DEB

:	CHN PROBABLY CARRIES NEEDLE FROM NEIGHBOR WHO JUST BUBBLED.
:	INCREASE CHANNEL ALLOCATION FOR THIS LINK.
RTD1C
:	ONLY BUBBLE FOR NEEDLES
	LB	R0,0,PRD
	EXBR	R0,R0
	LB	R1,1,PRD		:GET FIRST 2 BYTES OF LOGICAL RECORD TO
	AR	R1,R0			: CHECK FOR NEEDLE POINT
	CLHI	R1,NEEDP
	JEFS	RTD1D			:NEEDLE POINT - WE'LL BUBBLE LINK...
	IF	DB.DEB
	DBOOPS				:BAD CHANNEL NUMBER FROM NEIGHBOR
	ELSE	:NOT DB.DEB
	J	RTD1B			:BAD CHANNEL NUMBER, SNIP LINK
	EI	:DB.DEB

RTD1D	STH	PRC,RTMT3+2		:SAVE PHYS RECORD COUNT (R10)
	JAL	R8,BUBBLE,,		:FIND P.T. BUBBLE, ALLOCATE MORE CHANS
	GL	BUBBLE
	J	RTD1E			:NO P.T. SPACE AVAILABLE, TAKE LINK DWN
	LHL	R6,TBDPKN,KN,KN		:POSSIBLY NEW TABLES POINTERS
	LHL	R7,FLDPKN,KN,KN
	LHL	PRC,RTMT3+2		:RESTORE REGS
	LHL	CHN,RTMT3
	AR	CHN,CHN			:2*CHANNEL USEFUL INDEX
	J	RTDUAN			:GO HANDLE NEEDLE

:	OUT OF PERMUTER TABLE SPACE
RTD1E	RBT	KN,LKTEAR		:DO NO MORE FOR THIS LINK
	L	R10,RTMXSV		:CAUSE TRLINK TO EXIT RTD
	ST	R10,NEWLNR
	J	NEWLN8			:REPORT NO P.T. TO SUP LOG,
					: TEAR DOWN LINK

::*********************************************************************
::
::	RTDZTB:
::	DISPATCH TABLE FOR TEARING NETWORK 03-CHARACTER PAIRS
::
::*********************************************************************

RTDZTB	HS	0
	HC	RTDIGN-SEG1	:0300 RESERVED - IGNORE
	HC	RTDZPH-SEG1	:0301 ZAPPH - HARD ZAPPER
	HC	RTDZPS-SEG1	:0302 ZAPPS - SOFT ZAPPER
	HC	RTDNGZ-SEG1	:0303 ZAPPN - NON-GOBBLING ZAPPER
	HC	RTDZPF-SEG1	:0304 ZAPPF - FAT ZAPPER
	HC	RTDZPS-SEG1	:0305 RESERVED - SOFT ZAPPER
	HC	RTDZPH-SEG1	:0306 RESERVED - HARD ZAPPER
	HC	RTDZPH-SEG1	:0307 RESERVED - HARD ZAPPER
	HC	RTDGOB-SEG1	:0308 GOBBL - GOBBLER
	HC	RTDFGB-SEG1	:0309 GOBBF - FAT GOBBLER
	HC	BADCTL-SEG1	:030A UNUSED, RESERVED
	HC	RTDSQF-SEG1	:030B SQFIX - REBUILD SEQUENCE NUMBER FIX
	HC	RTDSQK-SEG1	:030C SQACK - REBUILD SEQUENCE NUMBER ACK
	HC	RTDGOB-SEG1	:030D RESERVED - GOBBLER
	HC	RTDGOB-SEG1	:030E RESERVED - GOBBLER
	HC	RTDGOB-SEG1	:030F RESERVED - GOBBLER
	HC	RTDNAC-SEG1	:0310 NEEDP - NEEDLE
	HC	BADCTL-SEG1	:0311 NEEDE - NEEDLE EYE
	HC	BADCTL-SEG1	:0312 TILIM - MESSAGE FOR PORT IN LOGIN MODE
	HC	BADCTL-SEG1	:0313 LOGRR - LOGON ERROR
	HC	RTDNAC-SEG1	:0314 RESERVED - NEEDLE
	HC	RTDNAC-SEG1	:0315 RESERVED - NEEDLE
	HC	RTDNAC-SEG1	:0316 RESERVED - NEEDLE
	HC	RTDNAC-SEG1	:0317 RESERVED - NEEDLE
	HC	RTDNAC-SEG1	:0318 RESERVED - NEEDLE
	HC	RTDNAC-SEG1	:0319 RESERVED - NEEDLE
	HC	RTDNAC-SEG1	:031A RESERVED - NEEDLE
	HC	RTDNAC-SEG1	:031B RESERVED - NEEDLE
	HC	RTDNAC-SEG1	:031C RESERVED - NEEDLE
	HC	RTDNAC-SEG1	:031D RESERVED - NEEDLE
	HC	RTDNAC-SEG1	:031E RESERVED - NEEDLE
	HC	RTDNAC-SEG1	:031F RESERVED - NEEDLE

	SUBTTL	YAKYAK (RMAKE - Record assembly)

::*********************************************************************
::
::	SUBPROCESS:	RMAKE:
::	FUNCTION:	RMAKE checks to see if a Bori Zap is pending.  If
::	not, it checks WSIZE to see if its ok to make a record.  If so it 
::	finds the Next Record to Make descriptor (NRMK), and dispatches
::	based on link type.  It loads the address of the record data buffer
::	to fill and calls RMK.  After logical data is assembled into the 
::	record buffer, RMAKE puts on the header and fills the frame to a
::	doubleword boundry.  The count field is filled in, and the  end of 
::	record pointer is updated.  Total characters is recorded and the 
::	BORI is inserted.  LRM is incremented and the trace tables are 
::	updated.  NAS is updated and the RECN is inserted, releasing the 
::	frame to the Sync transmitter.  If a serious error occurs, the
::	link will be snipped.
::	CALLING SEQ:	J RMAKE  (called directly from SPIDER)
::	INPUT:		R2 contains link number
::	CALLS:		JAL  R9,RMK
::			JAL  R8,TSBMRK
::	RETURNS:	J    BIDDRT
::
::*********************************************************************

RMAKE	HS	0
	IF	DB.CPU
	LR	R3,R2			:SAVE R2			###OAS
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR RMAKE		###OAS
	CPUTNM(RMAKE )			:DEFINE RMAKE CPUTIL ENTRY	###OAS
	LR	R2,R3			:RESTORE R2			###OAS
	EI	:DB.CPU

	LI	R0,YAKMAC		:SET UP MAC INTERRUPT ERROR RETURN ADDR
RMKSFT	ST	R0,ABENPC		:NO-OP INSTRUCTION FOR DEFAULT HANDLING
	IF	DB.DEB
:	DETERMINE HIGH-WATER MARK FOR INTERVAL BETWEEN RMAKE EXECUTIONS
	L	R0,FASTC,,
	LR	R3,R0			:GET CURRENT TIME AND COMPUTE
	S	R0,RMKTIM		:INTERVAL SINCE LAST RMAKE EXECUTION
	ST	R3,RMKTIM		:SAVE CURRENT TIME
	CLH	R0,RMKHWM		:IS THIS A NEW HIGH-WATER MARK?
	JLEFS	RMAKT1			:NO
	STH	R0,RMKHWM		:YES - SAVE
RMAKT1	EI	:DB.DEB

	LR	KN,R2			:LINK NUMBER TO MAKE LINK DESCRIPTOR
	SLL	KN,1
	L	KD,KDKN,KN,KN
	SRL	KN,1
	TBT	KN,BORZAP		:BORI ZAP PENDING?
	JNFS	RMAKE1			:YES - IGNORE THIS LINK, ITS GOING OUT

RMAKIT	LB	R1,WSIZ,KD		:IF LRM<LAR+WSIZ, MAKE RECORD
	AH	R1,LAR,KD
	SH	R1,LRM,KD
	CHVR	R1,R1
	JGFS	RMAKE2			:GO MAKE RECORD
	LIS	R0,1
	AHM	R0,KS.BAK,KD		:INC COUNT OF BACKLOG EVENTS
RMAKE1	RBT	KN,LKMAKE		:CAN'T HACK IT, MARK LINK AS SERVICED
RMAKEX	J	BIDDRT,,		:EXIT

:	THERE IS A RECORD TO MAKE.  MAKE THE RECORD
RMAKE2  LHL	CD,NRMK,KD		:POINT TO RECORD DESCRIPTOR
	LIS	R0,0
	STB	R0,LLXM,CD		:CLEAR RETRANSMISSION FLAG

:	HERE TO MAKE A FRAME FOR A T-II LINK

RMAKEW
	IF	EXPWSZ
	L	PRD,BREC,CD		:T-II - GET POINTER TO SEG2 DATA BUFFER
	ELSE
	LHL	PRD,BREC,CD		:T-II - GET POINTER TO SEG2 DATA BUFFER
	EI
:	Begin Scope of PRD containing POINTER to next char in buffer ##JOK
	LA	PRD,RECBUF+3,PRD,	:ADD IN SEG2 OFFSET.
					: RESERVE 3 BYTES FOR HDR
	LHI	PRC,$A121		:MAKE UP TO 121 DATA BYTES FRAME
					: - LEAVE 3 BYTES FOR HEADER
					: AND 4 BYTES FOR CHECKSUM
:	/////////////////////////////////////////////////
	JAL	R9,RMK			:GO MAKE A FRAME <
:	\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	CLHI	PRC,$A121		:DID RMK MAKE A FRAME?
	JN	RMAKW3			:YES, MAKE HEADER

	IF	STRHUB!STRRMT
	LB	R0,KTYP,KD		:Is this a Starlink?
	CLHI	R0,STRTYP
	JN	RMAKW2			:NO NORMAL LINK
	LHI	R1,ST.ACK		:GET THE ACK THRESHOLD FOR A STARLINK
	JFS	RMAK2A
RMAKW2	HS	0
	EI	:STRHUB!STRRMT
	LHI	R1,TH.ACK		:GET THE NULL REC ACK THRESHOLD
RMAK2A	LHL	R0,LRT,KD		:MAKE NULL REC
	SH	R0,NAS,KD		: IF UNACKED FRAMES OUTSTANDING
	CHVR	R0,0
	CR	R0,R1			:MORE THAN THRESHOLD FRAMES UN-ACKED?

	IF	APLYBP&MAKNUL
	JGE	RMAK2B			:Yes, definitley make a null rec
	ELSE
	JL	RMAKNO			:NO, MAKE NO FRAME THIS TIME
	EI	:MAKNUL			:###EV 02/17/87

	IF	APLYBP&MAKNUL		:Check if to make null rec anyway
	LB	R0,KTYP,KD
	CLHI	R0,STRTYP
	JN	RMAKNO			:For non-Starlines no null 2-17ev
	LB	R0,NULFLG,KD		:Is null flag set?
	JE	RMAKNO			:Not set .. so dont make null record
RMAK2B	LIS 	R0,0
	STB	R0,NULFLG,KD		:Reset null flag if sending null rec
	ELSE	:NOT 
	LIS	R0,0			:YES, NULL REC, LRC=0, CHN=0
	EI	:MAKNUL			:###EV 02/11/87

	STB	R0,0,PRD
 if	1-KOPFJ			: new code is much simpler	###JK
	STB	R0,1,PRD
	AIS	PRD,2
	SIS	PRC,2			: null record now 5-bytes long

RMAKW3	LIS	R0,0			:FILL OUT FRAME TO MULTIPLE OF 8 BYTES
	STB	R0,0,PRD		:3 ZERO BYTES TO INDICATE END OF FRAME
	STH	R0,1,PRD
	LIS	R1,7
	NR	R1,PRC			:ISOLATE LO 3 BITS OF FRAME BYTE COUNT
	AI	PRD,-RECBUF,R1		:ADD BITS, RESTORE PRD TO SEG2-REL. ADDR.
:	End Scope of PRD containing POINTER to next char in buffer ##JOK
	IF	DB.DEB
	THI	PRD,3			:LENGTH MUST BE MULTIPLE OF 4
	JEFS	RMAKW4			:IT IS
	DBOOPS				:IT ISN'T...
RMAKW4	EI	:DB.DEB
	SR	PRC,R1
	IF	EXPWSZ
	ST	PRD,EREC,CD
	ELSE
	STH	PRD,EREC,CD
	EI
	LR	R1,PRD
	NHI	R1,7F			:NUMBER OF BYTES IN PACKET JUST MADE
	AIS	R1,4			:INCLUDE CHECKSUM AND
	AM	R1,KS.PCO,KD		: COUNT PACKET CHARACTERS OUTPUT

	LHI	R1,$A124		:COMPUTE # HW IN PHYSICAL RECORD,
	SR	R1,PRC			: INCLUDING HEADER BUT EXCLUDING CKSUM
	SRLS	R1,3			:DISCARD LAST 3 BITS (SHOULD ALL BE 0)
	LB	R0,BORI,KD		:GET EXPECTED BORI
	XHI	R0,30			:COMPLEMENT MASTER/SLAVE FIELD
	AR	R0,R1			:INSERT LENGTH FACTOR
	EXBR	R0,R0
	LH	R1,LRM,KD		:(DIGRESS TO INDEX LRM)
	AIS	R1,1
	STH	R1,LRM,KD
	IF	EXPWSZ
	L	R9,BREC,CD		:PUT AWAY HEADER
	ELSE
	LHL	R9,BREC,CD		:PUT AWAY HEADER
	EI
 else	:KOPFJ			:###JK
	AIS	PRD,1			: null record now 4 bytes long

RMAKW3	LIS	R0,0			: pad frame with a zero
	STB	R0,0,PRD		: 1 zero byte to indicate end-of-frame
	AI	PRD,-RECBUF		: restore PRD to SEG2-rel. address
:	End Scope of PRD containing POINTER to next char in buffer ##JOK
	L	R9,BREC,CD		: get pointer to Beginning of record
	SR	PRD,R9			: compute (actual) packet-size
	AIS	PRD,4+7			: round up (4 for cksum, 7 to round up)
	NHI	PRD,-8			: number of bytes in packet (MOD 8)
	AM	PRD,KS.PCO,KD		: record statistics on packet sizes
	SIS	PRD,4			: size exclusive of Cksum
	LR	R1,PRD
	AR	PRD,R9			: compute pointer to Cksum
	ST	PRD,EREC,KD		: ...and save it away
	SRHLS	R1,3			: compute number of octets (excluding Cksum)
	LB	R0,BORI,KD
	XHI	R0,30,R1		: compute BORI, add # octets
	EXBR	R0,R0
	LH	R1,LRM,KD		: (digress to index LRM)
	AIS	R1,1
	STH	R1,LRM,KD
 ei	:KOPFJ			:###JK
	STH	R0,RECBUF,R9,		: put away header
	STB	R1,RECBUF+2,R9,		:INSERT TRUNCATED REC #

RMAKE3  HS	0			:COMMOM LOGIC FOR BOTH T-I AND T-II
	IF	TSTSZE
	LHL	R8,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R8,TSLINK		: TEST FOR LINK OF INTEREST
	JN	RMAKET			:NO - CONTINUE
	JAL	R8,TSBMRK		:SET UP NEW EVENT ENTRY
	LIS	R8,TS.MAK		:GET EVENT TYPE,
	STB	R8,TSBTBL,R7		: AND STORE IN EVENT ENTRY
	STH	R0,TSBTBL+2,R7  	:STORE RECORD HEADER
	STB	R1,TSBTBL+4,R7  	:STORE PACKET RECORD NUMBER
	LHL	R8,LAS,KD
	STB	R8,TSBTBL+1,R7  	:STORE LAST ACK SENT
	LHL	R8,LRT,KD
	STB	R8,TSBTBL+3,R7  	:STORE 'LRT' SINCE ACK FIELD LEFT BLANK
					:FOR INTERRUPT ROUTINE TO FILL IN...
RMAKET  EI	:TSTSZE
	IF	SYNFCS
	LHL	R8,KVERNO,KD		:CHECK IF OLD VERSION NODE SKIP
	CHI	R8,FCSVER		:FCSVER IS NEW FCS NODE
	JN	RMAKE4
	LR	R8,R0			:CALCULATE FCS CKSM WITHOUT 3 BYTE
					:HEADER HERE,SEND OUT BY SYLVEX WITH
					:HEADER##AL R0,R1,R2,R8,R9,R10 USED
	SRLS	R8,8			:CATCH BORI BYTE AFTER RMK'ED
	NHI	R8,0F			:BYTE CT. NIBBLE
	CLHI	R8,0			:SKIP THIS CALCULATION IF NOT DATA PACK
	JE	RMAKE4
	LB	R2,SYTWCN,R8		:NO. OF BYTES IN THIS PACKET
	SIS	R2,3			:LESS 3 HEADER BYTES
	FCSINI(R10)			:INIT ACCUMULATOR REG.
	IF	EXPWSZ
	L	R1,BREC,CD		:ADDR OF DATA BYTES
	ELSE
	LHL	R1,BREC,CD		:ADDR OF DATA BYTES
	EI
	LA	R1,RECBUF+3,R1,		:'REAL ADDRESS'
	XR	R9,R9			:A WORKING REG.
FCSCC1	LB	R0,0,R1,R9		:GET THE CHAR.
	FCSACC(R10,R0,R8)		:ACCUMULATE THE FCS
	AIS	R9,1			:INC. CT. TO NEXT CHAR.
	CR	R9,R2			:CMP. WITH THE LENGTH
	JL	FCSCC1			:CONTINUE IF NOT 
	FCSEND(R10)			:1'S COMPLETMENT THE FINAL VALUE
	NHI	R10,0FFFF		:LO 16BIT IS THIS FCS
	IF	EXPWSZ
	L	R2,EREC,CD		:STORE TO EREC LOCATN
	ELSE
	LHL	R2,EREC,CD		:STORE TO EREC LOCATN
	EI
	STH	R10,RECBUF,R2,		:STORED, SYLVEX WILL PICK-UP AS DATA
RMAKE4	HS	0
	EI	:SYNFCS
	LHL	R0,LRT,KD		:WE'LL BE ACKING THIS
	STH	R0,NAS,KD
	LHL	R0,LRM,KD		:GET RECORD NUMBER
	LR	R2,R0			:MEASURE QUEUE DELAY
	NHI	R2,PKTMSZ		:MASK WITH TABLE SIZE
	AR	R2,R2			:FORM HW INDEX
	LHL	R1,FASTC+2,,		:GET CURRENT TIME
	STH	R1,PKTTIM,KD,R2 	:AND STORE AWAY FOR INTERRUPT ROUTINE

::	A RECORD BUFFER NEED NOT BE MARKED BUSY WHILE BEING FILLED. IT BEARS A 
::	RECD # THAT IS LESS THAN LAR AND THEREFORE WILL NOT BE XMITTED.
	
	STH	R0,RECN,CD		:RELEASE RECORD TO SYNC XMITTER
	LHL	R2,RLNK,CD		:INDEX NRMK TO NEXT REC
	STH	R2,NRMK,KD
	J	BIDDRT,,		:YIELD,BUT LEAVE LINK BIT IN LKMAKE SET

RMAKNO	LIS	R0,1			:NO RECORD MADE,
	AM	R0,RMKNRW		: COUNT OCCURRENCES OF WHEEL SPINNING
	AM	R0,KS.NPC,KD		:LINK-BY-LINK COUNT OF NO RECORDS MADE
	RBT	KN,LKMAKE		:MARK LINK AS SERVICED
	J	BIDDRT,,		:EXIT

::	RMKSNP:
::	SOMETHING WENT WRONG. SNIPPING THE LINK IS LESS PAIN THAN CRASHING
::	NODE, AND PROBABLY ELIMINATES EXPOSURE TO POTENTIAL CROSSED CIRCUITS
::	EVEN IF WE DON'T REALLY KNOW WHAT'S GOING ON...
::
::	THE LINK SNIP REASON IS PASSED ON R0. SET THE BIT FOR THIS LINK
::	IN THE BORI ZAP ARRAY. TRLINK WILL MAKE REPORTS TO SUP LOG AND XRAY
::	AFTER ZAPPING ALL CIRCUITS ON LINK.

RMKSNP	HS	0
	SBT	KN,BORZAP		:LNCHCK WILL TAKE LINK OUT
	STH	R0,SNPTYP,KN,KN		: AND TRLINK WILL KNOW WHY
	STM	R0,LKSNRG		:MAYBE A GOOD CLUE HERE
	J	RMAKE1			:THAT'S ALL FOR THIS LINK

	SUBTTL	YAKYAK (RMK)

::*********************************************************************
::
::	SUBROUTINE:	RMK:
::	FUNCTION:	RMK assembles data from buffers which have been
::	flagged as needing attention.  If link undergoing shrink process,
::	RMAKE is frozen, return.  Otherwise, see if backpressure need be 
::	relieved.  Find next channel to service, range check channel number
::	and see if page change need be sent.  Get outbound buffer pointer
::	and dispatch based on link type.  See if # of chars in buffer will 
::	fit into frame, and if so copy from buffer to output record.  Count
::	logical characters output and update BPSCNT. Insert channel  number
::	and logical count into packet.  Trace channel if desired.  Make 
::	more packets if at least ten bytes remain in the frame.  Restore
::	record pointer and return to RMAKE.  If serious errors occur,
::	snip the link.
::	CALLING SEQ:	JAL  R9,RMK
::	INPUT:		KD   -- Link Descriptor address
::			KN   -- Link Number
::			PRD  -- Pointer to Physical Record
::			PRC  -- Physical Record byte count
::
::*********************************************************************
::
::	THIS ROUTINE ASSEMBLES DATA FROM BUFFERS WHICH HAVE BEEN
::	FLAGGED AS NEEDING ATTENTION.  THE DATA FROM THE BUFFER
::	IS BUILT INTO A LOGICAL RECORD WITHIN A PHYSICAL RECORD
::	WHICH IS TO BE TRANSMITTED ACROSS A LINK.  EACH TIME
::	THROUGH RMK, IT TRIES TO BUILD ONE PHYSICAL RECORD.
::
::	LNKFLG  -- IS THE ARRAY OF FLAGS INDICATING WHICH BUFFERS
::			NEED ATTENTION.
::
::	LNKBPV  -- IS THE ARRAY OF FLAGS INDICATING WHICH CHANNELS
::			RECEIVED BACKPRESSURE RELIEF.
::
::	CHSRVD  -- IS A WORKING COPY OF THE BACKPRESSURE ARRAY.
::			IT IS USED TO INSURE THAT CHANNELS ARE SERVICED
::			IN A ROUND ROBIN FASHION.
::
::	BPSVCP  -- IS AN ARRAY WHICH INDICATES WHETHER OR NOT THE
::			BACKPRESSURE COUNT FOR A CHANNEL SHOULD BE
::			RESET. 
::
::	PRIRTY  -- ARRAY WHICH INDICATES PRIORITY CHANNELS
::
::	GUSH	-- ARRAY INDICATING MUCH TRAFFIC (AT LEAST 8 CHARACTERS)
::			RECEIVED SINCE LAST BACKPRESSURE RELIEF
::
::	TRIKLE  -- ARRAY INDICATING A LITTLE TRAFFIC RECEIVED SINCE
::			LAST BACKPRESSURE RELIEF
::
::**********************************************************************

RMK	HS	0
	ST	R9,RTMXSV		:SAVE RETURN ADDRESS
	LIS	R0,1
	AM	R0,RMKRMW		:COUNT TOTAL RMK ITERATIONS

	LIS	R0,0			:SET FLAG SO THAT SUP DATA
	STH	R0,RMTNFL		:	WON'T FLOOD US
	STH	R0,RMKFLG		:FLAG TO STOP ARRAY SCAN

	LHL	R6,TBDPKN,KN,KN		:START OF 1/2 WD TABLES FOR LINK
	LHL	R7,FLDPKN,KN,KN		:START OF FLAGS FOR LINK
	LHI	R0,0C000		:ALWAYS LOOK AT CHANNELS 0 AND 1
	OH	R0,CHSRVD,R7,
	STH	R0,CHSRVD,R7,
	LB	R0,SHSTAT,KD		:TEST SHRINK STATE
	JE	RMKB0			:NO SHRINK ACTIVITY
	SIS	R0,2			:RMAKE FROZEN?
	JGR	R9			:YES,WAITING FOR NEIGHBOR TO ACK SHRINK
	JE	RMKSH2			:SEND SHRINK COMMAND OR REQUEST,
					: DEPENDING ON WHETHER WE ARE MASTER
					: OR SLAVE
	LHI	R1,0E1			:SHSTAT=1, SEND SHRINK ACKNOWLEDGE
RMKSH1	LIS	R0,0
	STB	R0,SHSTAT,KD		:THAW RMAKE
	STB	R1,0,PRD		:SEND SHRINK REQUEST/ACKNOWLEDGE
	STB	R0,1,PRD		:PACKET < 2 BYTES WON'T GET NOTICED
	AIS	PRD,2
	SIS	PRC,2			:INCR CURRENT POINTER, DECR PACKET CNT
	JR	R9			:SHRINK COMMANDS TRAVEL BY THEMSELVES
RMKSH2	LHI	R1,0E0			:SHRINK REQUEST/COMMAND
	LH	R0,NDID,KD
	CLHI	R0,MACHNM		:ARE WE SLAVE ON THIS LINK?
	JG	RMKSH1			:YES - SEND SHRINK REQUEST TO MASTER
	STB	R1,0,PRD		:NO - SEND SHRINK COMMAND TO SLAVE
	LIS	R0,0
	STB	R0,1,PRD		:MAKE 2-BYTE RECORD
	AIS	PRD,2
	SIS	PRC,2
	LIS	R0,3			:FREEZE RMAKE UNTIL SLAVE RESPONDS WITH
	STB	R0,SHSTAT,KD		: SHRINK ACKNOWLEDGE
	JR	R9

RMKB0	IF	BPFIX:APLYBP		:###EV 02/27
	LB	R0,KTYP,KD
	CLHI	R0,STRTYP		:For Starlinks with Aply backpressure
	JNFS	RMAP01
	RBT	KN,BPMSTR		:Set every quarter second
	JE	RMKNCH			:Not this time
	JFS	RMAP03			:Yes, make Aply BP record
RMAP01	EI	:APLYBP
	RBT	KN,BPMTII		:TIME TO SEND BACKPRESSURE RELIEF REC?
	JE	RMKNCH			:NO
RMAP03	LIS	R3,0			:INDEX INTO GUSH
	IF	APLYBP			:Apply BackPressure logic (Tymstar)
	ST	PRC,PRCSAV
	ST	PRD,RMKBSV		:In case no B.P. record to send
	EI	:STRHUB!STRRMT
	LR	R4,PRD			:POINTER TO BACKPRESSURE HEADER
	LHI	R0,0C0			:L.R. HEADER FOR BACKPRESSURE RECORD
	STB	R0,0,PRD		:L.R. COUNT=0 IS O.K., FORCES TRAFFIC
					: ON LIGHTLY LOADED LINK
	AIS	PRD,1
	SIS	PRC,1
	LHL	LRC,NCHN,KD		:MAX # OF CHANNELS ON LINK DIVIDED BY 8
	SRLS	LRC,3			: = # OF BYTES IN LINK ARRAYS (ie GUSH)
RMKB1	L	R0,GUSH,R3,R7		:EXAMINE GUSH ARRAY 1 WORD AT A TIME
RMKB2	JFFO	R0,RMKB3		:ONE FOR GUSHING CHANNEL - SEE WHETHER
					:BACKPRESSURE CAN BE RELIEVED
	AIS	R3,4
	CLR	R3,LRC			:DONE WITH THIS LINK?
	JLBS	RMKB1			:NO - CONTINUE

	J	RMKBND			:ALL DONE WITH BACKPRESSURE RECORD

RMKB3	ST	R0,RTMT1		:TEMPORARY STORAGE (WORKING GUSH)
	RBT	R1,RTMT1		:THIS CHANNEL SERVICED
	LR	CHN,R3
	SLLS	CHN,3			:FORM CHANNEL NUMBER
	OR	CHN,R1
	AR	CHN,CHN			:2 * CHANNEL NUMBER
	LH	R2,NIOTAB,R6,CHN	:PERMUTER TABLE ENTRY
	LIS	R1,3
	NR	R1,R2			:ISOLATE SPEED BITS IN R1
	NHI	R2,-4			:BUFFER INDEX IN R2
	LHL	R0,BCT,R2,		:GET BUFFER BYTE COUNT

	IF	APLYBP			:Apply BackPressure logic (Tymstar)
	LB	R8,KTYP,KD		:Is this a Starlink?
	CLHI	R8,STRTYP
	JN	RMKBS2			:No .. proceede with test
	CLH	R0,CIRSPK,R1,R1		:Test Starlink circuit buffer
	JL	RMKB6			:If BCT less than T.P. Class .. no
	SRLS	CHN,1
	J	RMKBS4			:Apply B.P.  .. else send Aply B.P. rec
	EI	:STRHUB!STRRMT

RMKBS2	CLH	R0,CIRSPK,R1,R1		: AND COMPARE TO CHANNEL CIRCUIT SPEED
	GL	CIRSPK
RMKBS3	JG	RMKB6			:BCT GREATER, DON'T RELIEVE BACKPRESSUR
	SRLS	CHN,1
	RBT	CHN,GUSH,R7,		:O.K. TO RELIEVE BACKPRESSURE
	RBT	CHN,TRIKLE,R7,
RMKBS4	EXBR	R1,CHN
	CLB	R1,RMPAGE,KN,KN		:ARE WE CHANGING PAGES?
	JE	RMKB5			:NOPE - STILL ON SAME ONE
	STB	R1,RMPAGE,KN,KN		:YES - SAVE NEW PAGE NUMBER
	OHI	R1,80
	STB	R1,0,PRD		:INSERT PAGE CHANGE COMMAND
	AIS	PRD,1
	SIS	PRC,1
RMKB4	LHI	R1,0C1			:BACKPRESSURE HEADER, LENGTH 1
	STB	R1,0,PRD
	STB	CHN,1,PRD		:CURRENT CHANNEL RELIEVING BACKPRESSURE
	SIS	PRC,2
	LR	R4,PRD			:R4 POINTS TO NEW B.P. RECORD HEADER
	AIS	PRD,2
	J	RMKB6
RMKB5	LB	R0,0,R4			:GET BACKPRESSURE HEADER
	AIS	R0,1			:INCREMENT SIZE FIELD
	THI	R0,20			:IF IS MAX SIZE - TEST FOR OVERFLOW
	JN	RMKB4			:YES, CLOSE OFF RECORD, START NEW ONE
	STB	R0,0,R4			:STORE HEADER BACK WITH UPDATED COUNT
	STB	CHN,0,PRD		:CURRENT CHANNEL RELIVING BACKPRESSURE
	AIS	PRD,1
	SIS	PRC,1
RMKB6	L	R0,RTMT1		:GET WORKING GUSH BACK
	CLHI	PRC,3			:ROOM FOR PAGE CHANGE, HEADER, CHANNEL?
	JGE	RMKB2			:YES - CONTINUE
	SBT	KN,BPMTII		:NO - FILLED PACKET.
					: SCHEDULE BACKPRESSURE AGAIN.
	J	RMKXIT

RMKBND	IF	APLYBP			:Apply BackPressure logic (Tymstar)
	LB	R8,KTYP,KD
	CLHI	R8,STRTYP		:Is this link a Starlink?
	JN	RMBN99
	L	R8,RMKBSV		:Get previous PRD
	AIS	R8,1			:and compare to present PRD
	CR	PRD,R8			:Have we advanced past the header?
	JG	RMBN99			:If so, just continue
	L	PRC,PRCSAV		:If not, restore previous values
	L	PRD,RMKBSV		:for PRD and PRC.
RMBN99	EI	:STRHUB!STRRMT		:In either case go to RMK17 to 
	J	RMK17			:continue RMK logic

:	FIND NEXT CHANNEL TO SERVICE. SCAN FOR CHANNEL WITH BUFFER FLAG
:	SET AND 'CHSRVD' SET.
RMKNCH	HS	0
	LHL	R0,LKFGND,KN,KN		:POINTER TO LAST HW IN 'ATTN' ARRAY
					: (FLAGS)
	LHL	R1,LKSVND,KN,KN		:POINTER TO LAST HW IN SERVICE ARRAY
					: (CHSRVD)
RMKNC2  LHL	R2,NCHN,KD		:MAX # OF CHANNELS (DYNAMIC FOR T-II)
RMKNC4  SIS	R2,1			:MINUS 1
	STH	R2,RMTSR4		:SAVE MAX CHANNEL THIS LINK

	ARAND	R0,R2			:ARRAYAND RETURNS HIGHEST NONZERO
					: BIT NUMBER IN R2
	JFS	RMKHIT			:ARRAYAND RESULT WAS NONZERO
	J	RMK3			:ARRAYAND RESULT WAS ZERO,
					: DONE WITH THIS LINK

:	FOUND CHANNEL WHICH NEEDS AND IS ALLOWED SERVICE

RMKHIT	RBT	R2,CHSRVD,R7,		:MARK CHANNEL AS SERVICED
	JE	RMKARC			:ARAND and RBT disagree
	TBT	R2,LNKFLG,R7,		:CONSISTENCY TEST ON ARRAYAND
	JE	RMKARC			:BOTH BITS !MUST! BE SET
	LR	CHN,R2			:SET UP LINK RELATIVE  CHANNEL NUMBER
	CLH	CHN,RMTSR4		:INSURE CHANNEL NUMBER IN RANGE
	JG	RMKCOR			:NO - CHANNEL OUT OF RANGE FOR LINK
	AR	CHN,CHN			:CHANNEL NUMBER*2

:	SEE IF PAGE CHANGE NEEDED

	EXBR	R1,R2			:GET PAGE NUMBER
	LBR	R1,R1
	CLB	R1,RMPAGE,KN,KN		:NEED PAGE CHANGE?
	JEFS	RMHIT3			:NO, CHANNEL IN RANGE OF CURRENT PAGE
	STB	R1,RMPAGE,KN,KN		:YES - SAVE NEW PAGE NUMBER
	AHI	R1,80			:INSERT PAGE CHANGE RECORD
	STB	R1,0,PRD		: INTO PACKET

	AIS	PRD,1			:INCREMENT PHYSICAL RECORD POINTER
	SIS	PRC,1			:DECREMENT PHYSICAL RECORD BYTE COUNT

:	SEE IF BACKPRESSURE COUNT SHOULD BE RESET

RMHIT3	IF	APLYBP			:Apply BackPressure logic (Tymstar)
	LB	R0,KTYP,KD
	CLHI	R0,STRTYP		:Is this a Starline ?
	JN	RMHI01			:No
	TBT	R2,BPSVCP,R7,		:Test, was 'Apply Backpressure' rcvd?
	JN	RMHT04			:No, refresh counts for next Xmission,
	LH	R3,BPSCNT,R6,CHN	:Yes - what is current count
	CLHI	R3,8			:If greater than 8, allow to run out
	JGE	RMHIT5			:
	LIS	R3,8			:Otherwise ...	
	STH	R3,BPSCNT,R6,CHN	:refresh to minimum (avoid snip)..
	J	RMHIT5			:and proceed
	EI	:STRHUB!STRRMT

RMHI01	RBT	R2,BPSVCP,R7,		:For this channel ..
	JEFS	RMHIT5			:if B.P. relief not previously received
					:then do not update counter

RMHT04	LIS	R3,3			:YES , GET CIRCUIT SPEED BITS
	NH	R3,NIOTAB,R6,CHN	: FROM PERMUTER TABLE ENTRY
	LHL	R3,CIRSPK,R3,R3		:GET APPROPRIATE COUNT
	STH	R3,BPSCNT,R6,CHN	:AND UPDATE COUNT FOR THIS CHANNEL

RMHIT5  LHL	R2,NIOTAB,R6,CHN	:NOW GET PERMUTER TABLE ENTRY
	NHI	R2,-4			:MASK OUT SPEED BITS
	JNFS	RMHIT8			:MUST BE NONZERO
	IF	DB.DEB
	DBOOPS				:ERROR - ZERO ENTRY IN PERMUTER TABLE
	ELSE	:NOT DB.DEB
	LHI	R0,LS.ZPT		:DON'T KNOW HOW, BUT WE GOT A NULL
	J	RMKSNP			: PERMUTER TABLE ENTRY - SNIP THE LINK
	EI	:DB.DEB

RMHIT8  XHI	R2,4			:FLIP TO OUTBOUND BUFFER #
	J	RMKTW			:TYMNET II

:	ARRAYAND INSTRUCTION TOOK 'HIT' RETURN AND BOTH BITS NOT ZERO
RMKARC	HS	0
	IF	DB.DEB
	DBOOPS				:PROBABLE HARDWARE FAULT
	ELSE	:NOT DB.DEB
	LHI	R0,LS.ARC		:INDICATE ARRAYAND ERROR
	J	RMKSNP			: AND SNIP THE LINK
	EI	:DB.DEB

:	ARRAYAND INSTRUCTION RETURNED CHANNEL NUMBER TOO HIGH
RMKCOR	HS	0
	IF	DB.DEB
	DBOOPS	
	ELSE	:NOT DB.DEB
	LHI	R0,LS.ACR		:INDICATE CHANNEL OUT OF RANGE
	J	RMKSNP			: AND SNIP THE LINK
	EI	:DB.DEB

	SUBTTL	YAKYAK (RMK - Tymnet-II link)

::	RMK3
::	ALL CHANNELS ON THIS LINK HAVE BEEN SCANNED. COPY THE CURRENT
::	BACKPRESSURE FLAGS INTO THE CHANNEL SERVICE ARRAY FOR THE NEXT
::	EXECUTION OF RMAKE ON THE LINK

RMK3	TS	RMKFLG			:MAKE SURE FLAGS ARE SCANNED
	JN	RMKXIT			: ONLY ONCE EACH TIME THRU RMK

	LHL	R0,LKBPND,KN,KN		:PTR TO LAST HW IN BACKPRESSURE ARRAY
					: (LNKBPV)
	LHL	R1,LKSVND,KN,KN		:MOVE BP ARRAY TO SERVICE ARRAY
					: (CHSRVD)
	LB	R2,KTYP,KD		:TYMNET-I LINK?
	JNFS	RMK310			:NO - T-1.5 OR T-II. NCHN REFLECTS

::	ALLOCATED PERMUTER TABLE SPACE AND ACTUAL NUMBER OF CHANNELS.
::	BPMV MAY HAVE ADJUSTED NCHN DOWN TO ACCOMMODATE T-I NEIGHBOR WITH
::	LOWER NUMBER OF GROUPS. NCHKN REFLECTS NUMBER OF CHANNELS ALLOCATED,
::	NCHN DETERMINES THE ACTUAL NUMBER OF CHANNELS.
	LHL	R2,NCHKN,KN,KN		:P.T. ALLOCATION BASED ON NCHKN
	JFS	RMK320
RMK310  LHL	R2,NCHN,KD		:NUMBER OF BITS
RMK320  SHI	R2,10			:(NUMBER OF 1/2 WDS -1)*10

	COPY	R0,R2			:MOVE THE ARRAY
					: (R0=SOURCE, R1=DEST., R2=LEN.)
	RBT	KN,LKRR			:NOTE ROUND ROBIN COMPLETED FOR LINK
	LIS	R1,1
	AHM	R1,KS.RRC,KD		:INCREMENT ROUND-ROBIN COUNT FOR LINK
	J	RMKNCH			:GO LOOK FOR NEXT CHANNEL

:	GENERAL EXIT POINT

RMKXIT	LHL	CD,NRMK,KD		:RESTORE CD (RECORD DESCRIPTOR ADDRESS)
	L	R9,RTMXSV		:	AND GET RETURN ADDRESS
	JR	R9			:RETURN TO CALLER

:	HERE WHEN BPSCNT=0 FOR CHANNEL WE'RE ABOUT TO BUILD
:	LOGICAL RECORD FOR. LEGITIMATE ONLY FOR CHANNELS 0 & 1.
RMKBRZ	HS	0
	CLHI	CHN,2
	JLE	RMKNCH			:O.K. FOR CHANNELS 0 AND 1
	IF	DB.DEB
	DBOOPS				:NOT O.K. - RMK12 SHOULD RESET
	ELSE	:NOT DB.DEB		:CHRSVD WHEN BPSCNT DECREMENTS TO .LE.6
	LHI	R0,LS.BPZ		:INDICATE BPSCNT = 0
	J	RMKSNP			: AND SNIP THE LINK
	EI	:DB.DEB

::	HERE TO PROCESS LOGICAL RECORDS TO TRANSMIT
::	ON A TYMNET II LINK
::
::	DETERMINE LRC, THE NUMBER OF BYTES TO BE PUT INTO THE RECORD.
::	THIS WILL BE THE MINIMUM OF:
::	1.	CBCCT(BUFFER)	# OF CHARACTERS IN BUFFER
::	2.	BPSCNT(CHAN)	# OF CHARS ALLOWED BY BACKPRESSURE. THIS
::				VALUE IS NEVER LESS THAN 8 - SEE RMK12
::	3.	PRC-2		SPACE LEFT IN PACKET - AT LEAST 10 (RMK17)

RMKTW	LHL	LRC,BPSCNT,R6,CHN
	IF	DB.DEB
	JE	RMKBRZ			:BUFFER RESTRICTION 0 - CHECK CHANNEL #
	ELSE	:
	JEBS	RMKBRZ			:BUFFER RESTRICTION 0 - CHECK CHANNEL #
	EI	:DB.DEB
	HC	3A12			:CBCT - Compute BCT (GET BUFFER COUNT)
	HC	BB/4
	HC	BBSIZE
	CR	R1,LRC			:WHICH IS SMALLER?
	JGEFS	RMK10			:BPSCNT,LRC LIMITED BY BACKPRESSURE
	LR	LRC,R1			:CHRCNT,LRC LIMITED BY CHARS AVAILABLE
RMK10	CLHI	LRC,-2,PRC		:WILL ALL BYTES FIT IN PHYSICAL PACKET?
	JLE	RMKP3			:YES
	LHI	LRC,-2,PRC		:NO,LRC LIMITED BY SPACE LEFT IN PACKET
	LR	R0,CHN			:SO RMAKE WILL BUILD A MAXIMUM PACKET
	SRLS	R0,1			:GET ACTUAL CHAN NO. INTO R0

::	LOGICAL RECORD SIZE IS RESTRICTED BY SPACE LEFT IN PACKET. IF
:: 	LRC LESS THAN THRESHOLD, GIVE THIS CHANNEL ANOTHER TURN.

	CLHI	LRC,T2SRVS
	JLE	RMKP1			:THIS CHAN GETS 1ST TRY AT NEXT PACKET

	TBT	R0,PRIRTY,R7,		:IS THIS A PRIORITY CIRCUIT
	JE	RMKP2			:NO, JUST COUNT IT
	LH	R1,PRICNT,KN,KN		:COUNT PRIORITY RECORD
	AIS	R1,1
	STH	R1,PRICNT,KN,KN
	THI	R1,3			:EQUAL TO 0 MOD 4?
	JNFS	RMKP1
	SRLS	R1,2			:4 TIMES NRMCNT?
	SH	R1,NRMCNT,KN,KN
	JGFS	RMKP3
RMKP1	HS	0
	SBT	R0,CHSRVD,R7,		:NEXT TURN WILL GO TO PRIORITY CHANNEL

::	IF BACKPRESSURE RESTRICTION COUNT (BPSCNT) DECREMENTS TO 8 OR LESS,
::	CHSRVD BIT WILL BE RESET IN RMK12.

	JFS	RMKP3
RMKP2	LIS	R0,1
	AHM	R0,NRMCNT,KN,KN
RMKP3	LR	CD,LRC			:CD (R13) USED AS A WORKING COPY OF LRC
	JNFS	RMK16A
	IF	DB.DEB
	DBOOPS				:NO ZERO LENGTH RECORDS
	ELSE	:NOT DB.DEB
	LHI	R0,LS.EBF		:INDICATE EMPTY BUFFER FOR ACTIVE CHAN
	J	RMKSNP			: AND GO SNIP THE LINK
	EI	:DB.DEB

RMK16A	AIS	PRD,2			:INDEX TO START OF DATA

	L	R3,BB,R2,		:GET CHARACTER OUT PTR
	JNFS	RMK5
	CRASH.(.RMEB0)

RMK5	SIS	PRD,1			:BACK UP TO LAST BYTE STORED
RMK5C	LHL	R0,0,PRD		:SET UP R1 AS SCRATCH
	EXHR	R0,R0			: REGISTER FOR THE
	LHL	R1,0,R3			: MICROCODE
	OR	R1,R0

::	MICROCODE RMAKE INSTRUCTION
::	CD = WORKING COPY OF LRC, # OF BYTES TO COPY
::	R12 = PRD  => POINTER TO OUTPUT RECORD
RMK5A	HC	0E1D			:RMAKE Copy 1 - SCRATCH REG, COUNT
RMK5B	HC	0F1D			:RMAKE Copy 2 - CONTINUATION ADDRESS
	HC	RMKNXT-RMK5B		:TO RELEASE EMPTY BUFFERLET
	HC	RMKC00-RMK5B		:TO HANDLE CHARACTER PAIR
	HC	RMKC01-RMK5B		:TO HANDLE PREFIX CHARACTER
	HC	RMKC02-RMK5B		:TO HANDLE GOBBLERS
	HC	RMKC03-RMK5B		:TO HANDLE GOBBLERS/ZAPPERS

	IF	DB.DEB	
	JFS	RMK5XT			:IN CASE UPSW TRACE ENABLED
	EI	:DB.DEB

:	DONE WITH RMAKE COPY FOR THIS CHANNEL
RMK5XT	HS	0
	AIS	PRD,1			:INCREMENT PRD TO NEXT LOGICAL RECORD
					: LOCATION (OR END OF PACKET)
	IF	DB.DEB
	LR	R2,R2			:VERIFY BUFFER INDEX STILL O.K.
	JNFS	RMK5OK			:NON-ZERO - MUST BE O.K....
	DBOOPS				:DEFINITELY NOT O.K.
	EI	:DB.DEB
RMK5OK  LHI	R0,-1,R3		:BACK UP BB POINTER
	CL	R0,BE,R2,		:BUFFER EMPTY?
	JN	RMKIG5			:NO, SKIP
	JAL	R8,GCLAST		:YES, RETURN LAST BUFFERLET
	GL	GCLAST
	J	RMK12			:RETURN TO MAINLINE

:	HERE TO RELEASE EMPTY BUFFERLET AND GET NEXT ONE

RMKNXT  LHI	R4,-1,R3		:MICROCODE INC'D POINTER
	CL	R4,BE,R2,		:BUFFER EMPTY?
	JNFS	RMKNX5			:NO, JUST BUFFERLET
	JAL	R8,GCLAST		:YES
	LIS	R3,0			:FLAG R3
	J	RMK5B

RMKNX5  JAL	R8,GCRET		:FREE ONE BUFFERLET
	GL	GCRET
	L	R3,BB,R2,
	J	RMK5B			:CONTINUE

:	COME HERE ON 00,01 AND 02 CHARACTER PAIRS

RMKC00  LIS	R0,0			:CREATE THE '00'
	JFS	RMKC0X

RMKC01  LIS	R0,1			:CREATE THE '01'
	JFS	RMKC0X

RMKC02	LIS	R0,2			:CREATE THE '02'

RMKC0X  CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RMKIG			: CHANNELS 0 AND 1

	SIS	CD,1			:ROOM IN LOGICAL RECORD FOR BOTH BYTES?
	JG	RMKC0Z			:YES, GO STORE THEM

:	NO ROOM FOR CHARACTER PAIR IN LOGICAL RECORD. DECREMENT
:	LRC, AND PUT CHARACTER BACK IN BUFFER.

	SIS	LRC,1			:LOGICAL RECORD SHORTER THAN EXPECTED
	JGFS	RMKC0Y
	CRASH.(.RMZLR)
RMKC0Y  LR	R1,R0			:GET THE CHAR TO R1
	ST	R3,BB,R2,		:SET UP BB FOR CALL TO WCD
	JAL	R8,WCD			:PUT CHAR BACK IN BUFFER
	J	RMK12			:DONE WITH LOGICAL RECORD

RMKC0Z	STB	R0,0,PRD		:STORE THE FIRST CHARACTER
	ST	R3,BB,R2,		:SET UP FOR CALL TO GCI
	JAL	R8,GCI			:GET THE SECOND CHARACTER
	GL	GCI
	L	R3,BB,R2,		:GET THE NEW POINTER
	AIS	PRD,1			:INCREMENT PACKET POINTER
	STB	R1,0,PRD		: AND STORE SECOND CHARACTER
	AIS	PRD,1
	SIS	CD,1			:ADJUST COUNT FOR SECOND CHARACTER
RMKCZZ	LR	CD,CD			:ENTRY POINT FROM RMK3TB, CHECK AGAIN
	JN	RMK5			:MORE DATA TO MAKE - GO DO IT
					: (R3 ALREADY SET UP)
	J	RMK12			:DONE WITH THIS LOGICAL RECORD

:	COME HERE TO IGNORE SPECIAL CHARACTERS -- ALSO EXIT AREA

RMKIG	SIS	CD,1			:DECREMENT COUNT SINCE MICROCODE DIDN'T
	JG	RMK5A			:MORE TO DO
	STB	R0,0,PRD		:IN CASE MICROCODE DIDN'T STORE IT
	J	RMK5XT			:GO FIX R12, (PRD), TEST FOR EMPTY BUFF

RMKIG3  AIS	PRD,1			:FIX UP R12 (PRD) FOR MAINLINE CODE
RMKIG5  ST	R3,BB,R2,
	J	RMK12

::	COME HERE ON '03' CHARACTER PAIRS -- TYMNET II
::	R3 = POINTER TO SECOND CHAR IN 03-XX PAIR
::	R12 (PRD)  = POINTER TO BYTE IN PHYSICAL RECORD JUST 'FILLED' WITH 03
::	CD HAS NOT BEEN DECREMENTED TO REFLECT THE 03 CHARACTER
::	03 CHAR HAS BEEN WRITTEN TO PHYSICAL RECORD ONLY IF R12 (PRD) IS EVEN

RMKC03  LIS	R0,3			:CREATE A '03' 
	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RMKIG			: CHANNELS 0 AND 1
	SIS	CD,1			:ROOM FOR 03-XX CHAR PAIR
					: IN LOGICAL RECORD?
	JGFS	RMKC3A			:YES - HANDLE 03-CHARACTER PAIR
	SIS	LRC,1			:NO, LOGICAL REC WILL BE SHORTER
					: THAN EXPECTED
	JG	RMKC0Y			:RETURN 03 TO BUFFER,
					: FINISH LOGICAL RECORD
	CRASH.(.RMZL3)
RMKC3A  LB	R1,0,R3			:LOOK AT 2ND CHARACTER
	CLHI	R1,20			:PERFORMANCE MONITORING OR HIGHER?
	JGEFS	RMKC3B			:YES, STUDY FURTHER
	CLHI	R1,NEEDP&0FF		:IS IT A NEEDLE?
	JEFS	RMKNEE			:YES, GO PROCESS NEEDLE
	IF	BFLTMR			:possibility of a bfr timer? ###jhl
	CLHI	R1,COMET&0FF
	JE	RMKBFD			:if so, jump to COMET-handler
	EI	:BFLTMR
	JL	RMK03N			:0300-030F, NETWORK CHARACTER PAIR
	J	RMKC0Z			:NONE OF ABOVE, JUST PASS CHAR ON

RMKC3B	CLHI	R1,3F			:PERFORMANCE MONITOR?
	JLE	RMKPFM			:YES
	J	RMKC0Z			:PASS ALL ELSE ALONG

::	RMKNEE
::	PROCESS NEEDLE

RMKNEE  ST	R3,BB,R2,		:SAVE BB
	JAL	R8,NCI			:SKIP A CHAR
	GL	NCI
	JAL	R8,NCI			:SKIP ANOTHER
	JAL	R8,PCI			:PEEK AT THIS ONE -- BYTE COUNT IN R1
	CLHI	R1,-2,PRC		:WILL IT FIT IN THIS RECORD?
	JG	RMKNE5			:NO, BACK UP

::	DECREMENT NUMBER OF NEEDLES OUTSTANDING BETWEEN CRQ AND RMAKE.
:: 	IF NEDOUT=0 AND NEDSUS<>0, THEN A LINK SHRINK HAS BEEN SUSPENDED
::	AND SHOULD BE RE-SCHEDULED.

	LH	R8,NEDOUT,KD		:NUMBER OF NEEDLES OUTSTANDING
	JGFS	RMKNE2			:SHOULD BE POSITIVE
	CRASH.(.RMNER)
RMKNE2	SIS	R8,1
	STH	R8,NEDOUT,KD		:NEW COUNT OF NEEDLES OUTSTANDING
	JNFS	RMKNE3			:OTHERS STILL TO PROCESS
	LB	R0,NEDSUS,KD		:IS THERE A SHRINK SUSPENDED?
	JEFS	RMKNE3			:NO

::	THERE WAS A SHRINK SUSPENDED AND NO NEEDLES ARE NOW OUTSTANDING.
::	RTD WILL RE-EXAMINE PACKET WITH SHRINK COMMAND/REQUEST.

	SBT	KN,LKTEAR		:SCHEDULE RTD TO PERFORM SHRINK

RMKNE3	LIS	R0,1
	AHM	R0,ANCHN,KD		:INCREMENT NUMBER OF ACTIVE CHANNELS
	LR	R0,CHN
	SRLS	R0,1			:RELATIVE CHANNEL NUMBER
	RBT	R0,NEEDLE,R7,		:INDICATE NEEDLE HANDLED
	JNFS	RMKNE4
	LR	R9,R0			:PRESERVE ABSOLUTE CHANNEL NUMBER 
	CRASH.(.RMKNE)
RMKNE4	LR	LRC,R1			:INSURE LOGICAL RECORD COUNT
					: INCLUDES ENTIRE NEEDLE
	LHI	CD,-1,LRC		:SUBTRACT 1 FOR '03' CHARACTER
	JAL	R8,NEDTIM,,		:COMPUTE NEEDLE TIME, SET CIRCUIT TIME
	GL	NEDTIM
	L	R3,BB,R2,		:RESTORE BB
	LIS	R0,3			:CREATE FIRST CHARACTER AGAIN
	J	RMKC0Z

RMKNE5  LIS	R1,3			:NEEDLE WON'T FIT -- BACK UP
	JAL	R8,WCD			:PUT '03' BACK IN BUFFER

::	ARTIFICIALLY EXTEND LENGTH OF PACKET BY STORING A COUPLE OF EXTRA
::	NULLS. IF LAST THING IN PACKET WAS PAGE CHANGE COMMAND TO HANDLE NEEDLE
::	CHANNEL, NEIGHBOR'S RTD WILL NOT NOTICE IT DUE TO TEST IN RTD1 ASSUMING
::	3 OR MORE CHARACTERS IN LOGICAL RECORD.

	LIS	R1,0
	STB	R1,-2,PRD,		:NGHBR INTERPRETS NULLS AS END-OF-PACKT
	STB	R1,-1,PRD,
	SIS	PRC,2			:MAKE PACKET COUNT CONSISTENT

	SRLS	CHN,1			:GET CHANNEL NUMBER
	SBT	CHN,CHSRVD,R7,		:NEEDLE WILL BE 1ST REC IN NEXT PACKET
	J	RMKXIT

	IF	BFLTMR			:if buffer timer pairs enabled?
:	This is the COMET (0314) handler.	
RMKBFD	HS	0
	ST	R3,BB,R2,
	JAL	R8,GCI			:read out the 14 (03 already out)
	JAL	R8,GCI			: followed by two consecutive
	LR	R4,R1			: bytes of FASTC
	EXBR	R4,R4			:they're unescaped, so we write our
	JAL	R8,GCI			: own retriever
	AR	R1,R4			:put the result in R1
	LHL	R0,FASTC+2,,		:what time is it now?
	SR	R0,R1			:difference into R0
	AHM	R0,BDLACC,KD		:add into halfword accumulator
	LHL	R0,BDLCNT,KD
	AIS	R0,1			:and bump the frequency counter
	STH	R0,BDLCNT,KD
:	adjust the buffer pointers and counters?
	L	R3,BB,R2,		:restore BB to R3
	SIS	CD,3			:adjust char out count for these 3 char
	SIS	LRC,4			:adjust LRC to ignore four timing chars
	LR	CD,CD			:TEST CODE
	JE	RMK12			:TEST CODE
	J	RMK5			:restart the RMKCOPY instructions
	EI	:BFLTMR

::	RMK12:
::	RECORD TRAFFIC STATISTICS AND UPDATE BACKPRESSURE FOR CHANNEL.
::	INSERT LOGICAL RECORD COUNT FIELD AND HEADER.
::	IF REBUILD IS ENABLED AND THE CIRCUIT IS A TERMINATION COPY
::	USER DATA INTO THE CIRCUIT'S HISTORY BUFFER.
::	EXPECTS PRD TO POINT BEYOND LAST DATA BYTE IN RECORD, LRC=BYTE COUNT

RMK12	LR	LRC,LRC			:NO ZERO LENGTH RECORDS
	JNFS	RMK122
	IF	DB.DEB
	DBOOPS
	ELSE	:NOT DB.DEB
	LHI	R0,LS.ZLR		:INDICATE ATTEMPT TO MAKE ZERO-LENGTH
	J	RMKSNP			: RECORD AND GO SNIP THE LINK
	EI	:DB.DEB

RMK122	AM	LRC,KS.LCO,KD		:COUNT LOGICAL CHARACTERS OUTPUT
	LIS	R3,1			:TO INCREMENT LOGICAL RECD FIELD###jhl
	AHM	R3,KS.LRM,KD		:ADD IT INTO LAST MINUTE'S COUNT###jhl

	SHI	PRC,2,LRC		:NOW UPDATE PRC
	LHL	R3,BPSCNT,6,CHN		:UPDATE CHAN BACKPRESSURE COUNT LIMIT
	SR	R3,LRC			:SUBTRACT OUT CURRENT LOGICAL REC SIZE
	STH	R3,BPSCNT,6,CHN		:STORE NEW BACKPRESSURE LIMIT VALUE
	SRLS	CHN,1			:GET ACTUAL CHANNEL NUMBER

	CLHI	R3,8			:NEW BACKPRESSURE LIMIT >8 BYTES?
	JGFS	RMK13			:OK. ELSE MARK BACKPRSR LIMIT EXHAUSTED
	RBT	CHN,LNKBPV,R7,		:BY CLEARING CHAN'S BACKPRESSURE FLAG
	RBT	CHN,CHSRVD,R7,		:ENSURE CHAN NOT SERVICED AGAIN UNTIL 
					:NGHBR REFRESHES BACKPRESSURE RESTRICTN
RMK13	LR	R9,PRD			:FORM THE LOGICAL RECORD HEADER
	SR	R9,LRC			:COMPUTE POINTR TO BEGIN OF LOGICAL REC
	STB	CHN,-1,9,		:INSERT CHANNEL NUMBER AND
	STB	LRC,-2,9,		: LOGICAL REC COUNT (DATA BYTES ONLY)

	XHI	R2,4			:FLIP TO OTHER BUFFER
	LH	R1,BF,R2,		:GET SOURCE ABSOLUTE CHANNEL NUMBER
	JLFS	RMK132			:BUFFER RETURNED
					: DUE TO ZAPPER BEING PROCESSED
	TBT	R1,TRCHAN,,		:TRACING DESIRED FOR THIS CHANNEL?
	JEFS	RMK132			:NO
	LCS	R0,1			:YES, INDICATE TRACING OUTBOUND DATA
	JAL	R8,CHRTRC		:MAKE ENTRY IN TRACE TABLE

	IF	REBILD
	LR	R9,PRD
	SR	R9,LRC			:RESTORE R9
	EI	:REBILD

RMK132	HS	0
	XHI	R2,4			:RESTORE BUFFER INDEX

::	CREATE HISTORY USING RTD MICROINSTRUCTION FOR TERMINATING 
::	CHANNELS WITH REBUILD ENABLED.
::
::	THE HISTORY BUFFER RULES ARE: ONLY DATA THAT THE USER WILL
::	RECEIVE GOES INTO THE BUFFER. SQACKS, SQFIXS AND NEEDLES
::	DON'T MAKE HISTORY. FAT GOBBLERS ARE CONVERTED TO NORMAL
::	GOBBLERS AND SAVED.
::
::	NOTE!!! THAT R4 PRESERVES THE BUFFER NUMBER FOR RMHFIN!!!

	IF	REBILD
	LR	R4,R2			:SAVE THE OUTBOUND BUFFER NUMBER IN R4
	SRLS	R2,3			:FORM REBUILD BIT ARRAY INDEX
	TBT	R2,CRQBSY		:IS REBUILD ENABLED HERE?
	JE	RMK17			:NO, SKIP ALL THIS STUFF
	AR	R2,R2			:YES, FORM THE HISTORY BUFFER NUMBER
	AI	R2,HBUFN,R2		:BY ADDING IN THE BASE HISTORY BUFFER #
	SR	PRD,LRC			:BACK UP PRD TO 1ST BYTE OF DATA IN REC
	LR	CD,LRC			:MICROCODE USES CD FOR WORKING BYTE CNT
	
::	RMHIST
::	INITIAL ENTRY POINT TO PERFORM RTD MICROCOPY, AND ALSO CONTINUATION
::	POINT AFTER PROCESSING SPECIAL CHARACTER PAIRS

RMHIST	L	R3,BE,R2,		:CURRENT HISTORY BUFFER 'IN' POINTER
	JNFS	RMHIS1			:BUFFERLET ALREADY ALLOCATED
	JAL	R8,WCFRST		:GET A BUFFERLET
	SIS	R3,1			:INITIALIZE R3 (BE) FOR MICROCODE

RMHIS1	LHL	R0,0,R3			:SET UP SCRATCH REGISTER
	EXHR	R0,R0
	LHL	R1,0,PRD
	OR	R1,R0
RMKHSA	HC	3B1D		:RTD Copy 1 - USING R1=SCRATCH, CD=COUNT
RMKHSB	HC	3C1D		:RTD Copy 2 - HERE AFTER GETTING NEW BUFFERLET
	HC	RMKHSN-RMKHSB		:TO GRAB ANOTHER BUFFERLET
	HC	RMKHS0-RMKHSB		:TO HANDLE ESCAPED CHARACTERS
	HC	RMKHS1-RMKHSB		:PREFIX CODES
	HC	RMKHS2-RMKHSB		:T-I GOBBLERS?
	HC	RMKHS3-RMKHSB		:T-II 03-XX CHAR PAIRS AND QUADS
	ST	R3,BE,R2,		:DONE - STORE BUFFERLET END POINTER
	J	RMHFIN			:GO HANDLE XSEQN UPDATES, SQFIXS, ETC.

:	HERE TO GET A NEW BUFFERLET

RMKHSN	JAL	R8,NXTBLT		:GET ANOTHER BUFFERLET
	JBS	RMKHSB			:RESUME PROCESSING

::	HERE TO HANDLE 00 AND 01 CHARACTER PAIRS. SET A BIT IN BSPLIT
::	IF THE CHARACTER PAIR WILL BE SPLIT ACROSS A BUFFERLET. PASS
::	THE CHARACTER PAIR ALONG.
::
::	THE 03-XX CHARACTER PAIR CODE TRANSFERS TO 'RMHSPA' IF IT DETERMINES
::	THAT THE CHARACTER PAIR IN QUESTION CAN BE HANDLED AS A PPREFIX CODE.

RMKHS0	LIS	R1,0			:PASS ON THE 00
	JFS	RMHSPA
RMKHS1	LIS	R1,1			:PASS ON THE 01
RMHSPA	ST	R3,BE,R2,		:STORE 'BE' - NEEDED FOR 'WCI' CALL
	STB	R1,0,R3			:STORE AWAY THE 00, 01, OR 03
	LB	R1,0,PRD		:NEXT BYTE (MICROCODE INCREMENTED PRD)
	JAL	R8,WCI			:WRITE IT INTO THE HISTORY BUFFER
	AIS	PRD,1			:ADVANCE PRD TO DATA BEYOND CHAR PAIR
	SIS	CD,2			:REDUCE REMAINING BYTE COUNT BY 2
	JG	RMHIST			:MORE DATA IN LOGICAL RECORD - CONTINUE
	JE	RMHFIN			:NO MORE DATA IN LOGICAL REC, FINISH UP
	CRASH.(.RMKHS)			:NEGATIVE LOGICAL RECORD COUNT

RMKHS2	HS	0			:###TZ
	CRASH.(.RMHS2)			:ILLEGAL 02 FOR HISTORY BUFFER	###TZ

::	RMKHS3:
::	HERE TO HANDLE 03-XX CHAR PAIRS BOUND FOR THE HISTORY BUFFER.
::	REBUILD CONTROL QUADS (SQFIX, SQACK) AND NEEDLES DO
::	NOT GO INTO THE HISTORY BUFFER AND DO NOT ADVANCE XSEQN.
::	FAT GOBBLERS ARE SHRUNK AND STORED AS NORMAL GOBBLERS. OTHER
::	03 PAIRS ARE TREATED AS DATA.

RMKHS3	HS	0
	LB	R0,0,PRD		:SEE WHAT THE NEXT CHARACTER MIGHT BE
	CLHI	R0,SQFIX&0FF		:IS IT A SQFIX?
	JE	RMHS3A			:YES
	CLHI	R0,SQACK&0FF		:OR A SQACK
	JE	RMHS3A			:YES
	CLHI	R0,20			:A PERFORMANCE MONITORING CHARACTER?
	JGE	RMHSPM			:YES, EXTRACT IT
	CLHI	R0,NEEDP&0FF		:OR A NEEDLE?
	JEFS	RMHSNE			:YES, A NEEDLE
	CLHI	R0,GOBBF&0FF		:A FAT GOBBLER?
	JEFS	RMHSFG			:YES, SHRINK IT
RMHS3B	LIS	R1,3			:NONE OF ABOVE - SOME HARMLESS 03-XX
	J	RMHSPA			: PAIR OR SHRUNKEN FAT GOBBLER.
					: PASS IT ON INTO BUFFER
RMHSNE	AHI	PRD,-1,LRC		:NEEDLE, RESTORE PRD TO POINT BEYOND
	JAL	R9,RSTRIP		:FREE UP POSSIBLY ALLOCATED BUFFERLET
	J	RMK17			:AND GO ON TO NEXT LOGICAL RECORD

RMHSFG	LIS	R1,3			:FAT GOBBLER - SHRINK IT. FORM THE '03'
	STB	R1,0,R3			:AND STUFF IT INTO BUFFERLET
	LIS	R1,8			:DO THE SAME FOR THE '08''
	ST	R3,BE,R2,		:SET UP 'BE' FOR WCI CALL
	JAL	R8,WCI			:WRITE THE 08 INTO HISTORY BUFFER
	AIS	PRD,5			:ADVANCE PRD BEYOND THE LAST 'FAT' BYTE
	SIS	LRC,4			:ADJUST LRC - ADVANCE XSEQN ONLY BY 2
	SIS	CD,6			:ALSO REDUCE THE WORKING BYTE COUNT
RMHSP1	JG	RMHIST			:MORE DATA
	JE	RMHFIN			:ALL DONE
	CRASH.(.RMHS4)
RMHSPM	AIS	PRD,1			:ADVANCE PRD BEYOND PERF. MONITOR
	SIS	LRC,2
	SIS	CD,2
	JBS	RMHSP1

RMHS3A	JAL	R9,RSTRIP		:SOME 03-XX QUAD THAT WON'T MAKE HSTORY
	SIS	LRC,6			:SO QUAD DOESN'T ADVANCE XSEQN
	AIS	PRD,5			:ADVANCE PRD BEYOND THE CHARACTER QUAD
	SIS	CD,6			:REDUCE REMAINING BYTE COUNT BY 4
	JG	RMHIST			:MORE DATA IN LOGICAL RECORD - CONTINUE
	JEFS	RMHFIN			:NO MORE DATA IN LOGICAL RECORD
					: - FINISH UP
	CRASH.(.RMHS3)

:	FINISH UP. R4=ORIGINAL OUTBOUND BUFFER, LRC=LOGICAL REC COUNT
:	ADJUSTED FOR 03-XX CHARACTER QUADS. PRD POINTS BEYOND THE LAST BYTE
:	IN THE LOGICAL RECORD JUST MADE. PRUNE BACK THE HISTORY
:	BUFFER IF NEEDED, AND ADD THE MODIFIED LRC INTO XSEQN.

RMHFIN	HS	0
	LHI	CD,CBSZ-2		:HIST BUFFER EXCEED ALLOCATED MAXIMUM?
	LH	R1,BCT,R2,		:CURRENT APPROXIMATE BUFFER SIZE
	LHL	R0,RHBSZ,R2,		:MAXIMUM ALLOWED SIZE (FROM LEP OR CRQ)
	SR	R1,R0			:FORM THE DIFFERENCE BETWEEN THEM
     IF  REBTST
        SR      R1,CD                   :could have 2 bflets for 2 chars
        JLEFS   RMKFI1                  :none to remove
        LR      R0,R1                   :count to remove
        JAL     R9,RTBFTA,,             :approximate since not split char pair
        GL      RTBFTA
        AM      R0,SEQN,R2,             :r0 gets actual number returned
     ELSE
RMKFI2	SR	R1,CD			:ALLOW FOR EXTRA BUFFERLET
	JLEFS	RMKFI1			:HISTORY BUFFER NOT TOO BIG, CONTINUE
	JAL	R8,RETBLT,,		:TOO BIG, RELEASE LEADING BUFFERLET
	AM	CD,SEQN,R2,		:UPDATE SEQN OF LEAD CHAR IN HIST BUFF
	JBS	RMKFI2			:AND REPEAT HISTORY BUFFER SIZE TEST
      EI  :REBTST

::	SEND A SQFIX TO THE OTHER END IF AT LEAST 'SQNUMB' CHARS HAVE
::	BEEN SENT SINCE LAST SQFIX

RMKFI1	L	R0,XSEQN,R4,		:GET THE LATEST SEQUENCE NUMBER
	AM	LRC,XSEQN,R4,		:AND UPDATE IT BY OUTGOING COUNT
	X	R0,XSEQN,R4,		:TEST IF TIME FOR A SQFIX	###GT
	THI	R0,SQNUMB		:IF WE'VE PASSED SQNUMB HEX BYTES
	JE	RMK17			:NO, NOT TIME YET

	LR	R2,R4			:SET R2=BUFFER NUMBER FOR WCD CALL
	SRLS	R4,3			:TIME. CHECK IF ANY SQACKS HAVE COME IN
	TBT	R4,CRQBSY,,
	JN	RMKFI3			:YES, AT LEAST ONE HAS. SEND A SQFIX
	J	RMK17			:DISABLE REBUILD, CARRY ON WITH RMAKE

RMKFI3	L	R1,XSEQN,R2,		:GET LATEST XMIT SEQUENCE NUMBER
	LHL	R0,REBDIS,,		:DISPLAY SQF ACTIVITY?
	JEFS	RMKFI5			:NO
	ST	R1,CRYSBF		:DISPLAY SEQN SENT
	LHL	R0,BF,R2,		:CHANNEL #
	JAL	R8,CRYPTO,,		:LOG THIS###OAS(MAKE RX3)
	HC	CRYE6F
RMKFI5	JAL	R8,WCD			:PREFIX IT IN A BYTE AT A TIME
	EXBR	R1,R1			:LOW ORDER HW FIRST		###GT
	JAL	R8,WCD
	EXHR	R1,R1			:THEN HIGH ORDER HW		###GT
	JAL	R8,WCD
	EXBR	R1,R1
	JAL	R8,WCD
	LHI	R1,SQFIX
	JAL	R8,WCD
	EXBR	R1,R1
	JAL	R8,WCD

	EI	:REBILD

RMK17	CLHI	PRC,0A			:AT LEAST 10 BYTES LEFT IN FRAME?
	JGE	RMKNCH			:YES, LOOK FOR MORE PACKETS TO MAKE
	J	RMKXIT			:NO, EXIT RMK

::	RMK03N:
::	PROCESS NETWORK 03-XX CHARACTER PAIR.
::	STORE THE '03'CHARACTER INTO THE LOGICAL RECORD. EXTRACT THE
::	SECOND BYTE OF THE PAIR WITH A GCI CALL AND STORE IT TOO.
::	ADVANCE 'PRD' TO POINT BEYOND THE PAIR. ADJUST 'CD'. FINALLY,
::	DISPATCH ON CHAR PAIR TYPE TO SEE IF YOU'VE DONE THE RIGHT THING.

RMK03N	STB	R0,0,PRD		:MAKE SURE THE '03' WAS STORED
	AIS	PRD,1			:ADVANCE PRD TO CHAR FOLLOWING THE '03'
	ST	R3,BB,R2,		:NOW REMOVE THE SECOND CHARACTER...
	JAL	R8,GCI			:...USING A GCI CALL
	SIS	CD,1			:DEC WORKING LRC TO ACCNT FOR CHAR PAIR
	STB	R1,0,PRD		:COPY SECOND CHAR INTO OUTPUT RECORD
	AIS	PRD,1			:ADVANCE PRD BEYOND CHAR PAIR
	LHL	R8,RMK3TB,R1,R1		:GET DISPATCH ADDR BASED ON SECOND BYTE
	J	SEG1,R8,		: OF 03-PAIR

::	RMKGOB:
::	GOBBLER. IF THIS END IS A TERMINATION AND THE NEIGHBOR CAN HANDLE IT
::	AND REBUILD IS ENABLED CHANGE THE GOBBLER TO A FAT GOBBLER BY FORCING
::	LRC TO 6, AND STUFF THE CURRENT XSEQN BEHIND THE FAT GOBBLER.
::	NOTE THAT THIS XSEQN GOES UP TO, BUT DOES NOT INCLUDE, THE
::	FAT GOBBLER ITSELF.
::	ALSO NOTE THAT FAT GOBBLERS LEAVE THEIR ORIGINATING NODE
::	IN THEIR OWN LOGICAL RECORD, WITH NO ACCOMPANYING DATA.
::	IF THE FAT WON'T DO, PASS THE SKINNY GOBBLER ON UNMOLESTED.

RMKGOB	HS	0
	IF	REBILD
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE REBUILD STUFF?
	JLE	RMKCZZ			:NO, PASS ON THE GOBBLER
	JAL	R9,RMKFCH		:MAKE SURE GOBBLER IS FIRST CHARACTER
	J	RMK12			:NO, WE'LL GET IT NEXT TIME
	LR	R0,R2
	SRLS	R0,3			:IS THIS A TERMINATING CHANNEL?
	TBT	R0,CRQEND
	JE	RMKCZZ			:NO, NOT A TERMINATION
	LIS	LRC,6			:YES - FORCE LRC TO 6
	L	R0,XSEQN,R2,		:GET THE LATEST XMIT SEQUENCE NUMBER
	STB	R0,3,PRD		:STORE AWAY THE LOWER BYTE
	EXBR	R0,R0
	STB	R0,2,PRD		:AND THEN THE UPPER BYTE
	EXHR	R0,R0			:NOW THE HIGH ORDER HW		###GT
	STB	R0,1,PRD		:				###GT
	EXBR	R0,R0
	STB	R0,0,PRD
	LIS	R0,9			:GOBBF&0FF BUT NAD WOULD CHOKE
	STB	R0,-1,PRD,		:CHANGE NORMAL GOBBLER TO FAT GOBBLER
	AIS	PRD,4			:ADVANCE PRD BEYOND THE 4 XSEQN BYTES
	J	RMK12			:TERMINATE LOGICAL RECORD BUILDING HERE
	ELSE	
	J	RMKCZZ			:NO REBUILD - PASS GOBBLER ON
	EI	:REBILD

:	RMKFGB:
:	FAT GOBBLER. STORE NEXT 4 BYTES (XSEQN) BEHIND FAT GOBBLER.

RMKFGB	JAL	R9,RMKFCH		:TEST FOR 1ST CHARACTER IN LOGICAL REC
	J	RMK12			:NO - GET IT NEXT TIME		###GT
	JAL	R9,G2CI			:GET COUNT FROM BUFFER
	GL	G2CI
	STH	R1,SQNSAV		:SAVE HO HALFWORD		###GT
	JAL	R9,G2CI
	LHL	R0,SQNSAV		:RESTORE HO OF SEQN
	EXHR	R0,R0
	OR	R1,R0			:AND SAVE IN R1				
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE FAT GOBBLERS?
	JGFS	RMKRBC			:YES				###wjl
RMKFG0	HS	0			:				###TZ
	SIS	LRC,4			:NO, OLD VERSION
					: - LRC IS 4 LESS WITHOUT FAT
	LHI	R0,GOBBL		:CHANGE FAT GOBBLER TO NORMAL
	STB	R0,-1,PRD,		: GOBBLER IN PACKET
	JFS	RMKRC2
:	COMMON ENTRY POINT FOR CHARACTER-QUADS
RMKRBC	STB	R1,3,PRD		:STORE BUFFER DATA INTO PACKET
	EXBR	R1,R1
	STB	R1,2,PRD
	EXHR	R1,R1			:UPPER HW			###GT
	STB	R1,1,PRD
	EXBR	R1,R1
	STB	R1,0,PRD
	AIS	PRD,4			:INCREMENT RECORD POINTER AND
RMKRC2	SIS	CD,4			: DECREMENT LOGICAL RECORD WORKING CNT
	JE	RMK12			:DONE WITH NETWORK QUAD
	L	R3,BB,R2,		:MORE DATA - LOAD UP BB
	J	RMK5			: AND GO FINISH LOGICAL RECORD

:	RMKSQF:
:	SQF QUAD. JUST PASS IT ON IF NEIGHBOR CAN HANDLE IT

RMKSQF	JAL	R9,RMKFCH		:TEST FOR 1ST CHARACTER IN LOGICAL REC
	J	RMK12			:NO, WE'LL GET IT NEXT TIME
	JAL	R9,G2CI			:GET SQF SEQUENCE NUMBER
	STH	R1,SQNSAV		:SAVE HO HALFWORD		###GT
	JAL	R9,G2CI			:LOWER HW OF SEQUENCE NUMBER
	LHL	R0,SQNSAV		:RESTORE
	EXHR	R0,R0			:PUT IN HIGH ORDER HW
	OR	R1,R0
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE SQF CHARACTERS?
	JG	RMKRBC			:YES - JUST PASS SQF QUAD ON...	###wjl

::	OLD VERSION NEIGHBOR - DON'T PASS ON THE SQF
::	SEND BACK A NAK USING SEQN=-1 SO WE DISABLE REBUILD
::	IMMEDIATELY INSTEAD OF WAITING FOR THE TIMEOUT

RMKOVR	LR	R4,R2			:SAVE R2			###GT
	SRHLS	R4,3
	TBT	R4,CRQEND		:IS THIS A TERMINATION?
	JN	RMKOV3			:DON'T SEND A NAK TO OURSELVES!
	XHI	R2,4			:FLIP TO OTHER BUFFER		###GT
	LHI	R1,SQFIX		:SEND BACK A SQFIX		###GT
	JAL	R9,W2CI
	LCS	R1,1			:SEND OUT A FULL-WORD OF -1
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	XHI	R2,4			:RESTORE BUFFER INDEX
RMKOV3	SIS	PRD,2			:DECREMENT PRD PAST 03-PAIR
	SIS	CD,4			:MORE DATA IN LOGICAL RECORD?	###GT
	JEFS	RMKOV2			:NO - CANCEL LOGICAL RECORD
	SIS	LRC,6			:ADJUST LRC SINCE IGNORING SQF QUAD
	JGFS	RMKOV1
	CRASH.(.RMZL0)
RMKOV1	L	R3,BB,R2,		:RESTORE BB AND
	J	RMK5			: GO FINISH LOGICAL RECORD
RMKOV2	SIS	PRD,2			:BACK UP TO LOGICAL RECORD BEGINNING
	J	RMKNCH			:GO FIND NEW CHANNEL WITH WORK

::*********************************************************************
::
::	SUBROUTINE:	RMKFCH:
::	FUNCTION:	TEST FOR 03-XX PAIR FIRST CHARS IN LOGICAL RECORD.
::	CALLING SEQ:	JAL	R9,RMKFCH
::	INPUT:		R1 = SECOND CHARACTER IN 03-XX PAIR.
::	CALLS:		JAL	R8,WCD
::	RETURNS:	SKIP RETURN IF TRUE, ELSE PUT 03-XX PAIR BACK
::			IN BUFFER AND DO NON-SKIP RETURN.
::
::*********************************************************************

RMKFCH	HS	0
	CLHI	LRC,2,CD		:IS THIS FIRST DATA IN LOGICAL RECORD?
	JE	4,R9			:YES - SKIP RETURN
	SHI	LRC,2,CD		:LRC NOW COUNT OF ALL CHARS BEFORE SQF
	JAL	R8,WCD			:REPLACE 2ND BYTE (IN R1) OF SQF PAIR
	LIS	R1,3
	JAL	R8,WCD			:REPLACE FIRST BYTE OF PAIR
	SIS	PRD,2			:UNDO INCREMENTS OF PRD
	JR	R9			: AND RETURN

::	RMKFZP
::	FAT ZAPPER. STORE NEXT FOUR BYTES (NODE PAIR) INTO PACKET 
::	PRIOR TO ZAPPING LAST HALF OF CIRCUIT.

RMKFZP	JAL	R9,RMKFCH		:TEST FOR FIRST CHAR IN LOGICAL REC
	J	RMK12			:NO - GET IT NEXT TIME		###GT
	JAL	R9,G2CI			:GET FIRST TWO BYTES
	STB	R1,1,PRD		: AND STORE IN PACKET
	EXBR	R1,R1
	STB	R1,0,PRD
	JAL	R9,G2CI			:AND SECOND PAIR...
	STB	R1,3,PRD
	EXBR	R1,R1
	STB	R1,2,PRD
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE FAT ZAPPERS?
	JGFS	RMKFZ2			:YES				###wjl
RMKFZ9	HS	0
	LHI	R0,ZAPPH		:NO, OLD VERSION - MAKE ZAPPER HARD
	STB	R0,-1,PRD,		: IN PACKET TO NEIGHBOR
	SIS	LRC,4			:NO NODE PAIR FOLLOWING ZAPPER...
	JFS	RMKFZ4
RMKFZ2	AIS	PRD,4			:INCREMENT RECORD POINTER
RMKFZ4	SIS	CD,4			: AND DECREMENT COUNT

::	RMKZAP
::	PROCESS ZAPPER ON TYMNET-II CHANNEL. ZAP 2ND HALF OF CIRCUIT,
::	DECREMENT NUMBER OF ACTIVE CHANNELS THIS LINK, AND TEST FOR ZAPPING
::	CIRCUIT IN THE PROCESS OF BEING BUILT.

RMKZAP	SR	LRC,CD
	JAL	R9,ZAPV,,		:NOW ZAP CIRC
	GL	ZAPV
	LCS	R0,1
	AHM	R0,ANCHN,KD		:DECREMENT NUMBER OF ACTIVE CHANNELS
	LHL	R0,SLOWC+2,,
	STH	R0,BPSCNT,R6,CHN	:SAVE TIME THAT CHANNEL ZAPPED
	LR	R0,CHN
	SRLS	R0,1			:RELATIVE CHANNEL NUMBER
	RBT	R0,NEEDLE,R7,		:DID WE ZAP A NEEDLE?
	JE	RMK12			:NO - CONTINUE
::	WE ZAPPED A BUFFER WHICH CONTAINED A NEEDLE NOT YET PROCESSED
::	BY RMAKE. DECREMENT 'NEDOUT' TO MAINTAIN CONSISTENCY.
	LH	R8,NEDOUT,KD
	JGFS	RMKZP2			:IT'D BETTER BE POSITIVE
	CRASH.(.RMNE0)
RMKZP2	LCS	R9,1
	AHM	R9,NEDOUT,KD		:DON'T HOLD UP SHRINK DUE TO NEEDLE...
	LIS	R9,1
	AHM	R9,LKNEDS,KN,KN		:INDICATE NEEDLE GOBBLED
	LR	R0,CHN			:CHAN#*2
	SRLS	R0,1
	LHL	R8,NDID,KD
	STH	R8,CRYSBF+2
	JAL	R8,CRYPTO,,		:SEND CRYPTOGRAM TO XRAY
	HC	CRYE0E			:(NEEDLE GOBBLED)
	J	RMK12

::	RMKPFM
::	PROCESS PERFORMANCE MONITORING CHARACTERS  ( 03 20 TO 03 3F )
::	THESE CHARS MUST BE THE FIRST CHARS IN THE OUTBOUND LOGICAL RECORD.
::	THE XLAX AND XLAX-ACK CHARS ARE PREFIXED INTO THE CHANNEL
::	BUFFER IN RTEAR, SO WILL ALWAYS BE AT THE TOP OF THE BUFFER,
::	BUT THE TIMER AND TIMER ACK CHARS MAY OCCUR ANYWHERE IN THE
::	BUFFER
::	ON ENTRY:
::	LRC	=	FINAL BYTE COUNT OF LOGICAL RECORD BEING MADE
::	CD	=	WORKING COPY OF LRC, DECREMENTED TO REFLECT '03' CHAR
::	R3	=	POINTS TO SECOND CHAR IN 03-XX CHAR PAIR
::	R1	=	SECOND CHAR IN 03-XX CHAR PAIR
::	R0	=	'03' CHAR IN CASE BRANCH TO RMKC0Z IS TAKEN

RMKPFM	CLHI	R1,PFMMAX		:VALID CHARACTER?
	JLEFS	RMKPF1			:YES
	CRASH.(.RMPER)
RMKPF1	LHI	R1,1,CD			:IS THIS FIRST BYTE IN LOGICAL RECORD?
	CR	LRC,R1			:IF CD+1 = LRC, THIS IS FIRST BYTE
	JE	RMKC0Z			:YES, PASS THE CONTROL CHAR ALONG
	SR	LRC,R1			:ELSE STOP BUILDING LOGICAL RECORD.
					: GET NEW LRC
	LIS	R1,3			:CREATE '03' FOR 03-XX PAIR
	ST	R3,BB,R2,		:SET UP BB FOR CALL TO WCD
	JAL	R8,WCD			:RESTORE 03 CHARACTER INTO BUFFER
	J	RMK12			:DONE WITH THIS LOGICAL RECORD

::*********************************************************************
::
::	TABLE:		RMK3TB:
::	FUNCTION:	DISPATCH TABLE FOR RMK 03-XX CHARACTER PAIRS
::
::*********************************************************************

RMK3TB	HS	0
	HC	RMKCZZ-SEG1	:0300 RESERVED				###GT
	HC	RMKZAP-SEG1	:0301 ZAPPH - HARD ZAPPER
	HC	RMKZAP-SEG1	:0302 ZAPPS - SOFT ZAPPER
	HC	RMKZAP-SEG1	:0303 ZAPPN - NON-GOBBLING ZAPPER
	HC	RMKFZP-SEG1	:0304 ZAPPF - FAT ZAPPER
	HC	RMKCZZ-SEG1	:0305 RESERVED				###GT
	HC	RMKCZZ-SEG1	:0306 RESERVED				###GT
	HC	RMKCZZ-SEG1	:0307 RESERVED				###GT
	HC	RMKGOB-SEG1	:0308 GOBBL - GOBBLER
	HC	RMKFGB-SEG1	:0309 GOBBF - FAT GOBBLER
	HC	RMKCZZ-SEG1	:030A UNUSED - PASS IT ON
	HC	RMKSQF-SEG1	:030B SQFIF - REBUILD SEQ NUMBER FIX
	HC	RMKSQF-SEG1	:030C SQACK - REBUILD SEQYENCE NUMBER ACK
	HC	RMKCZZ-SEG1	:030D RESERVED
	HC	RMKCZZ-SEG1	:030E RESERVED
	HC	RMKCZZ-SEG1	:030F RESERVED

	SUBTTL	YAKYAK (ILC - Inter-Link Control)

::*********************************************************************
::
::	SUBROUTINE:	ILC
::	FUNCTION:	Process Channel 0 messages received from neighbor.
::	CALLING SEQ:	J  ILC  (called directly from RTDXIT as part of
::				 RTD end processing.)
::	INPUT:		KD,R6
::	DESTROYED:	R1,R2,R3,R5,R8,R9,R10
::	CALLS:		JAL  R8,PCI
::			JAL  R8,CBCCT
::			JAL  R9,ZAPV
::			JAL  R10,TRACE
::	RETURNS:	JL   ILCRET  (returns from ILC process and goes
::					directly via  J  BPMV to process
::					backpressure received from neighbor.)
::
::*********************************************************************

ILC
	LHL	R2,NIOTAB,R6,		:ILC BUFFER
	NHI	R2,-4
	JNFS	ILC02			:GOT BUFFER NUMBER

	IF	DB.DEB
	DBOOPS				:PERMUTER TABLE ENTRY 0
	ELSE	:NOT DB.DEB
	LIS	R0,LS.ILC
	J	RTDSNP			:SNIP LINK, INDICATE CHN 0 PROBLEM
	EI	:DB.DEB
ILC02	LHL	R0,BCT,R2,
	JE	ILCRET			:BUFFER IS EMPTY
	L	R3,BB,R2,		:SEE IF THERE IS A FULL MESS
	JAL	R8,PCI			:BYTE COUNT
	LR	LRC,R1
	JAL	R8,CBCCT		:CHARS IN BUFF
	GL	CBCCT
	CR	R1,LRC
	JL	ILCRET
	SIS	R1,2			:MUST BE AT LEAST 2 BYTES IN BUFFER
	JL	ILCRET

	JAL	R8,GCI			:DISCARD BYTE COUNT
	JAL	R8,GCI			:GET MESS TYPE
	CLHI	R1,ILCDMX
	JGEFS	ILCSKP			:UNKNOWN TYPE, SKIP
	LHL	R1,ILCDIS,R1,R1		:DISPATCH
	J	SEG1,R1,

ILCSKP	LHI	R5,-2,LRC		:DISCARD MESSAGE
ILCSK1	LH	R0,BCT,R2,		:FOR GARBAGE MESSAGE,
					: DON'T TRUST BYTE COUNT
	JE	ILCRET			:AVOID GCI CRASH...
	JAL	R8,GCI
	SIS	R5,1
	JGBS	ILCSK1
	J	ILC

ILCZAK	JAL	R8,GCI			:ZAPPER ACKNOWLEDGE
	EXBR	CHN,R1			:FOLL HW IS PORT #
	JAL	R8,GCI
	AR	CHN,R1
	AR	CHN,CHN
	LHL	R2,NIOTAB,R6,CHN
	NHI	R2,-4
	JE	ILC			:NO CIRCUIT THERE
	XHI	R2,4
	JAL	R9,ZAPV,,
	J	ILC

ILCTRC	CLHI	LRC,40			:TRACE
	JGE	ILCSKP			:TRACE TOO BIG, IGNORE
	SIS	LRC,1
	LIS	R1,03
	LIS	PRD,0
	JFS	ILCTRL			:COPY TRACE TO LEPMES BUFFER
ILCTR1	JAL	R8,GCI
ILCTRL	STB	R1,LEPMES,PRD
	AIS	PRD,1
	SIS	LRC,1
	JGBS	ILCTR1
	SIS	PRD,2
	LHL	CHN,LKZFKN,KN,KN	:COMPUTE ABS CHANN #
	AH	CHN,LEPMES,PRD
	NHI	CHN,7FFF
	STM	KN,TRREGS		:SAVE IMPORTANT REGS
	JAL	R10,TRACE,,		:DO CIRCUIT TRACE
	GL	TRACE
	LM	KN,TRREGS
	J	ILC

:	GET 32-BIT KEY USED IN MULTI-LINE RESET
ILCKEY	HS	0
	SIS	LRC,6			:EXPECT LENGTH OF 6
	JN	ILCSKP			:INVALID LENGTH - NEIGHBOR FAULT?

	LCS	R9,4
ILCKY1	JAL	R8,GCI			:GET NEXT KEY BYTE AND
	STB	R1,RKEY+4,KD,R9		: AND STORE IN LINK DESCRIPTOR
	AIS	R9,1
	JLBS	ILCKY1			:GET ALL 4 BYTES
	J	ILC			:DONE

Q	EQ	SEG1
ILCDIS	HC	ILCSKP-Q,ILCKEY-Q,ILCZAK-Q,ILCTRC-Q
ILCDMX	EQ	(.-ILCDIS)/2


	SUBTTL	YAKYAK (BPMX - Send backpressure)

::*********************************************************************
::
::	SUBPROCESS:	BPMX:/BPMXPR:
::	LOGICALLY PART OF BPM, THIS ROUTINE IS ENTERED FROM THE
::	HALF-SECOND LOGIC AND UPDATES THE BACKPRESSURE BITS ON ALL EXISTING
::	LINKS.  HANDLES T-I LINKS.
::
::*********************************************************************

BPMX	HS	0
	ST	R10,BPMXSR		:SAVE RETURN (IN CASE WE YIELD)
	LIS	R2,0
BPMX2	L	R3,ALINKS,R2		:COPY ALINKS TO BPMTII AND BPMXSV
	ST	R3,BPMTII,R2
	ST	R3,BPMXSV,R2
	AIS	R2,4
	CI	R2,LKSIZE
	JL	BPMX2
:	standard set up for jump to biddy
	LI	R4,LKSIZE		:###shm
:	L	R1,ALINKS		:PROCESS ALL ACTIVE LINKS
:	ST	R1,BPMTII		:FOR TYMNET-II BACKPRESSURE PROCESSING
:	ST	R1,BPMXSV
	LA	R3,BPMXSV
	JAL	R9,YAKBID		:I.E., BIDDY
	J	BPMXPR

	IF	KERNEL
	LIS	R4,0			:UPDATE KERNEL BPS BITS
BPMXK1	LHL	R2,KIOTAB,R4,R4		:BUFF #
	LIS	R1,3			:LOAD BP INDEX
	NR	R1,R2
	NHI	R2,-4
	JE	BPMXK2			:NO CIRCUIT, OK TO RELIEVE BP
	LHL	R3,BCT,R2,		:SET BIT IF CNT<BP CONSTANT
	CLH	R3,CIRSPK,R1,R1
	JGFS	BPMXGT
BPMXK2	SBT	R4,KERBPX,,
BPMXGT	AIS	R4,1
	CLHI	R4,NKU
	JL	BPMXK1

	EI	:KERNEL

	L	R10,BPMXSR
	JR	R10			:ALL DONE, RETURN TO G500MS

BPMXPR	HS	0			:###OAS
	IF	DB.CPU
	LR	R3,R2			:SAVE R2			###OAS
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR BPMXPR	###OAS
	CPUTNM(BPMXPR)			:DEFINE BPMXPR CPUTIL ENTRY	###OAS
	LR	R2,R3			:RESTORE R2			###OAS
	EI	:DB.CPU

	LR	KN,R2			:LINK DESC
	SLL	KN,1
	L	KD,KDKN,KN,KN
	SRL	KN,1

	J	BIDDRT,,

	IF	APLYBP		:FOR APLY BACKPRESSURE LOGIC
::*******************************************************************
::
::	SUBPROCESS:	APMX:
::	CALLED FROM QUARTER-SECOND LOGIC AND ENABLES BACKPRESSURE 
::	CHECKING ON ALL EXISTING STARLINKS.  
::
::*********************************************************************

APMX	HS	0
	ST	R10,BPMXSR		:SAVE RETURN (IN CASE WE YIELD)
	LIS	R2,0
APMX2	L	R3,ALINKS,R2		:COPY ALINKS TO BPMTII AND APMXSV
	N	R3,STLNKS,R2		:BUT ONLY FOR STARLINKS
	ST	R3,BPMSTR,R2
	ST	R3,BPMXSV,R2
	AIS	R2,4
	CI	R2,LKSIZE
	JL	APMX2
:	standard set up for jump to biddy
	LI	R4,LKSIZE		:###shm
	LA	R3,BPMXSV
	JAL	R9,YAKBID		:I.E., BIDDY
	J	APMXPR


	L	R10,BPMXSR
	JR	R10			:ALL DONE, RETURN TO G500MS

APMXPR	HS	0			:###OAS
	LR	KN,R2			:LINK DESC
	SLL	KN,1
	L	KD,KDKN,KN,KN
	SRL	KN,1

	J	BIDDRT,,

	EI	:APLYBP
	IF	APLYBP		:Tymstar Relieve Backpressure	###ev
::*********************************************************************
::
::	SUBROUTINE:	STRBPR:
::	FUNCTION:	Relieves backpressure for channels on starlinks
::	CALLING SEQ:	JAL	R10,STRBPR
::	RETURNS:	JR	R10
::
::*********************************************************************
STRBPR	HS	0

	LHI	KN,NLINKS
STCK01	SIS	KN,1
	JLR	R10			:ROUTINE RETURNS TO CALLER

	TBT	KN,ALINKS		:ACTIVE?
	JEBS	STCK01
	SLL	KN,1
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR POINTER
	SRL	KN,1
	LB	R0,NLAT,KD		:IS LINK UP?
	JEBS	STCK01			:NO .. NEXT LINK
	LB	R0,KTYP,KD		:LINK TYPE?
	CLHI	R0,STRTYP		:APLYBP FOR STARLINKS ONLY
	JN	STCK01

	LHL	R7,FLDPKN,KN,KN		:START OF FLAGS FOR LINK (STARLINK)
	LIS	R3,0
	LHL	LRC,NCHN,KD		:MAX # OF CHANNELS ON LINK DIVIDED BY 8
	SRLS	LRC,3			: = # OF BYTES IN LINK ARRAYS 
	LI	R0,0C0000000		:ALWAYS LOOK AT CHANNELS 0 AND 1
	O	R0,LNKFLG,R7,		:FIRST TIME INCL CHAN 0 & 1
	JFS	STRB2	
STRB1	L	R0,LNKFLG,R3,R7		:EXAMINE SERVICE ARRAY 1 WORD AT A TIME
STRB2	JFFO	R0,STRB3		:ONE FOR CHANNEL IN SERVICE

	AIS	R3,4
	CLR	R3,LRC			:DONE WITH THIS LINK?
	JLBS	STRB1			:NO - CONTINUE

	J	STCK01			:RETURN FOR NEXT LINK

STRB3	ST	R0,RTMT1		:WORKING FULLWORD
	RBT	R1,RTMT1
	LR	CHN,R3
	SLLS	CHN,3			:FORM CHANNEL NUMBER
	OR	CHN,R1
	AR	CHN,CHN			:2 * CHANNEL NUMBER
	SRLS	CHN,1
	RBT	CHN,APBPVD,R7,		:Did we get 'Apply Backpressure'
	JN	STRB4			:If so .. do not enable throughput
	SBT	CHN,LNKBPV,R7,		:Else .. Starlink's 1/2 sec BP Relief
	SBT	CHN,BPSVCP,R7,		:and refresh throughput count
	JFS	STRB5
STRB4	RBT	CHN,LNKBPV,R7,		:Turn off channel service and	###ev
	RBT	CHN,BPSVCP,R7,		:do not refresh tput count	10687
STRB5	L	R0,RTMT1		:RESTORE WORKING COPY
	J	STRB2			:CONTINUE

	EI	:APLYBP			:END OF TEXT


	SUBTTL	YAKYAK (NEWLNK)

::*********************************************************************
::
::	SUBROUTINE:	NEWLNK
::	FUNCTION:	Determine if we are master or slave for new link.
::	If we are master, adjust LKAPND, LKCSND for channel scan to point to
::	link area in negative ACP, CHS arrays. That causes the FNDKNC routine
::	to find a new channel starting from the highest and working down.
::
::	CALLING SEQ:	JAL  R10,NEWLNK  (called from  ATTLN6 (LINKER))
::	INPUT:		KD
::	CALLS:		JAL  R8,BUBBLE,,
::			JAL  R8,HCLEAR,,
::			JAL  R9,CRQFCR,,
::			JAL  R8,CRYPTO,,
::			JAL  R10,SUP12,,
::	RETURNS:	JR   R10
::
::*********************************************************************

NEWLNK	HS	0
	ST	R10,NEWLNR		:SAVE RETURN
	LB	KN,LKNM,KD		:GET LINK NUMBER
	LIS	R0,1
	STB	R0,MASTKN,KN,		:ASSUME WE ARE THE MASTER
	LHL	R0,NDID,KD
	CLHI	R0,MACHNM		:HIGHER MACHINE # IS MASTER FOR T-II
	JL	NLMS10			:OURS IS HIGHER
	LIS	R0,0			:NEIGHBOR'S NUMBER IS HIGHER - SET
	STB	R0,MASTKN,KN,		:MASTKN TO 0, INDICATE WE ARE THE SLAVE
:	IF THIS LINK USED TO BE UP WITH US AS MASTER, THEN WE MUST REVERSE THE
:	POLARITY OF LKAPND, LKCSND.
	LHI	R0,ACP
	SH	R0,LKAPND,KN,KN		:SEE IF POINTER IN POSITIVE ACP
	JL	NLMS20			:YES - NO ADJUSTMENT NECESSARY
	SLLS	R0,1			:ADD (DISTANCE*2) TO CURRENT NEGATIVE
	SIS	R0,4			: POINTER, MINUS 4 TO GET PROPER
	AHM	R0,LKAPND,KN,KN		: POSITIVE ACP, CHS POINTERS
	AHM	R0,LKCSND,KN,KN
	J	NLMS20
NLMS10	LHL	R0,LKAPND,KN,KN
	SHI	R0,ACP			:DETERMINE DISTANCE FROM ACP
	JLFS	NLMS20			:POINTER ALREADY WEST OF ACP
	SLLS	R0,1			:DIFFERENCE TIMES 2
	LCS	R1,4			: MINUS 4
	SR	R1,R0			:REVERSE POLARITY AND
	AHM	R1,LKAPND,KN,KN		: ADJUST
	AHM	R1,LKCSND,KN,KN

NLMS20	JAL	R8,BUBBLE,,		:GET NEW HALF-PAGE OF PERMUTER TABLE
	J	NEWLN7			:COULDN'T ALLOCATE P.T., TAKE LINK DOWN
NEWLN0	LIS	R0,0			:CLEAR PAGE #
	STH	R0,RTPAGE,KN,KN
	STH	R0,RMPAGE,KN,KN
	STH	R0,LKSTCT,KN,KN		:CLEAR LINK SATURATED COUNTER
	STH	R0,LKOVLD,KN,KN		:CLEAR OVERLOAD COUNTER
	STH	R0,SNPTYP,KN,KN		:CLEAR LINK SNIP TYPE FIELD
					: (0 IF NO LINK SNIP)
	STH	R0,SHSTAT,KD		:CLEAR SHRINK STATE (SHSTAT, NEDSUS)
	STH	R0,NEDOUT,KD		:CLEAR NUMBER OF NEEDLES OUTSTANDING
	LHI	R2,KSSZ^-1		:HW SIZE OF LINK STATISTICS AREA###OAS
	LA	R1,KS.PCO,KD		:START ZEROING AT KS.PCO OF KD	###OAS
	JAL	R8,HCLEAR,,		:CLEAR LINK STATISTICS		###OAS
	LHI	R0,0C000		:SET BP FLAGS FOR CHN 0 & CHN 1
	LHL	R6,FLDPKN,KN,KN		:START OF ARRAYS FOR THIS LINK
	STH	R0,LNKBPV,R6,
	STH	R0,BPSVCP,R6,

NEWLN1	LR	R2,KN			:COMPUTE # OF CORRESPONDING ILC BUFF
	SLLS	R2,3			:IT'S ILCZBF+8*KN
	LHI	R2,ILCZBF,2
	LIS	R3,3			:BUILD CIRCUIT TO ILC - R3=SPEED
	LHI	CHN,ILCZFL,KN		:R4, CHN ARE ABSOLUTE PORT #'S
	LHL	R4,LKZFKN,KN,KN
	JAL	R9,CRQFCR,,		:BUILD CIRC
	GL	CRQFCR
	AIS	R4,1			:YES, INCREMENT TO CHAN 1 OF THIS LINK
	RBT	R4,ACP,,		:PREVENT CHANNEL FROM BEING USED DUE
:	TO SPECIAL LOGIC IN RMAKE, RTD FOR CHANNELS 0 & 1.
	LCS	R0,1
	SR	R0,R4			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		: FLAG THAT ALSO
NEWLN4	SBT	KN,ALINKS		:LINK NOW ACTIVE
	IF	BPFIX:APLYBP		:###ev  02/27
	LB	R0,KTYP,KD
	CLHI	R0,STRTYP		:For Starlink only
	JNFS	NEWST4
	SBT	KN,STLNKS		:Mark also as Starlink
NEWST4	EI	:APLYBP
	LHL	R0,NALINK		:UPDATE ACTIVE LINK COUNT
	AIS	R0,1
	CLH	R0,MXLINK		:A NEW HIGH FOR # OF ACTIVE LINKS?
	JLEFS	NEWMXL			:NO
	STH	R0,MXLINK		:YES, STORE NEW PEAK VALUE
NEWMXL	STH	R0,NALINK		:STORE NUMBER OF ACTIVE LINKS
	LIS	R0,2
	STH	R0,ANCHN,KD		:CHANNELS 0 & 1 IN USE, MARK AS ACTIVE

	LR	R0,KN
	EXHR	R0,R0			:LINK # TO UPPER HW
	OH	R0,NDID,KD		: NEIGHBOR NUMBER IN LOWER HALF
	ST	R0,CRYSBF
	LIS	R0,0
	JAL	R8,CRYPTO,,		:REPORT TO XRAY
	HC	CRYE01
	L	R10,NEWLNR		:ALL DONE
	JR	R10

NEWLN7	HS	0			:NO PERMUTER TABLES FOR NEW LINK
	LR	R0,KN
	EXHR	R0,R0			:LINK NUMBER IN UPPER HALF,
	OH	R0,NDID,KD		: NEIGHBOR NUMBER IN LOWER HALF
	ST	R0,CRYSBF
	LIS	R0,0
	JAL	R8,CRYPTO,,		:REPORT TO XRAY
	HC	CRYE03

:	REPORT 'NO PERMUTER TABLES' TO SUPERVISOR LOG
NEWLN8	LR	R0,LN			:##TZ
	SRLS	R0,1
	OHI	R0,8080
	STH	R0,SUPMBF+4		:REPORT INCLUDES 'ESCAPED' LINE NUMBER
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER IN HW2
	LIS	R0,NR.NPT
	STH	R0,SUPMBF		:INDICATE TYPE OF NODE REPORT
	JAL	R10,SUP12,,		:REPORT NO P.T. TO SUP LOG
:	FORCE LINK TO GO OUT SINCE NO CIRCUITS CAN BE BUILT
	SBT	KN,BORZAP		:TAKE LINK OUT
	L	R10,NEWLNR,,		:GET RETURN ADDRESS		##TZ
	JR	R10			:AND RETURN			##TZ

	SUBTTL	YAKYAK (TRLINK)

::*********************************************************************
::
::	SUBROUTINE:	TRLNK
::	FUNCTION:	Link tear down logic.  Link neighbor number and
::	machine number are placed in Fat Zapper message.  Buffers are 
::	cleared and replaced with a Fat Zapper for each circuit on the link.
::	The type of circuit is counted.  If a Link Snip has occurred, the 
::	reason is recorded and diagnostics are sent.  Link Permuter Table
::	space is returned to the Permuter Table Free Pool.
::
::	CALLING SEQ:	JAL  R10,TRLINK  (from DETLIN (LINKER))
::					&(from LEPRKD (LEP0F))
::	INPUT:		KD
::	CALLS:		JAL  R8,CBCLR
::			JAL  R10,TRCR02
::			JAL  R9,W2CI
::			JAL  R10,SUP12
::			JAL  R8,CRYPTO
::	RETURNS:	JR  R10
::
::*********************************************************************

:	LINK TEAR-DOWN LOGIC

TRLINK	ST	R10,NEWLNR		:SAVE RETURN
	LB	KN,LKNM,KD		:GET LINK NUMBER
	RBT	KN,BORZAP
	TBT	KN,ALINKS		:TEST FOR ACTIVE LINK 		###GT
	JEFS	TRLIN0			:IF LINK NOT ACTIVE, DON'T UPDATE COUNT
	LCS	R0,1			:UPDATE LINK COUNT
	AHM	R0,NALINK
TRLIN0	LIS	R0,0
	STH	R0,ZAPCNT		:INIT COUNT OF CIRCUITS ZAPPED DUE TO
	STH	R0,CMDZCT		: LINK OUT AND COMMAND CIRCUITS ZAPPED
	LHL	R6,TBDPKN,KN,KN
	LHL	R7,FLDPKN,KN,KN		:BEGINNING OF LINK'S BIT ARRAYS
	LHL	CHN,NCHN,KD		:NUMBER OF CHANNELS ALLOCATED TO LINK
	AR	CHN,CHN			: * 2...
	LHL	R0,NDID,KD
	EXHR	R0,R0
	OHI	R0,MACHNM		:NODE PAIR CAUSING CRQ'S TO BE ZAPPED
	ST	R0,RFAT			:(PASSED WITH FAT ZAPPERS)
TRLIN1	LHL	R2,NIOTAB-2,R6,CHN 	:GET CIRCUIT'S BUFFER INDEX
	NHI	R2,-4
	JE	TRLIN3			:NO CIRCUIT THIS CHANN
	CLHI	R2,CIRZBF		:IF AN INTERNODE CIRCUIT...
	JGEFS	TRLIN2			:JUST CLEAR IT
	JAL	R8,CBCLR,,
	XHI	R2,4
	JAL	R8,CBCLR,,
	LIS	R0,0
	STH	R0,NIOTAB-2,R6,CHN
	J	TRLIN3

TRLIN2	LHI	R1,ZAPPF
	JAL	R10,TRCR02,,		:INITIATE FAT ZAPPER
	GL	TRCR02			: UNLESS WE'RE TERMINATION
	LH	R0,TRCSV2		:FAT ZAPPER?
	JLFS	TRLINF			:NO
	LH	R0,BF,R2,		:BUFFER RETURNED?
	JLFS	TRLINF			:YES - CAN'T WRITE INTO IT...
	LHL	R1,RFAT
	JAL	R9,W2CI			:PASS OFFENDING NODE PAIR
					: BEHIND FAT ZAPPER
	LHL	R1,RFAT+2
	JAL	R9,W2CI

TRLINF	HS	0
	LIS	R0,1
	AHM	R0,ZAPCNT		:ANOTHER CIRCUIT ZAPPED
	LR	R1,CHN
	SIS	R1,2
	SRLS	R1,1			:RELATIVE CHANNEL THIS LINK
	TBT	R1,CMDCTS,R7,		:IS THIS A COMMAND CIRCUIT?
	JEFS	TRLIN3			:NO
	AHM	R0,CMDZCT		:YES - COUNT IT FOR REPORT
TRLIN3	SIS	CHN,2			:DECREMENT TO NEXT CHANNEL
	JG	TRLIN1

:	DONE ZAPPING LINK'S CIRCUITS...NOW DO LINK-OUT BOOKKEEPING
	LHL	R0,SNPTYP,KN,KN		:WAS THIS LINK BORI-ZAPPED?
	JE	TRLIN4			:NO
	STH	R0,SUPMBF+4		:YES - SAVE REASON FOR REPORT
	IF	T2GATE			:##AL
	PUSH(R15)			:IF DB.BTR SWITCHED IN WCI
	LHR	R3,R0			:SNPTYP IN THE MSG
	LR	R1,KN			:5/8/86 ##AL
:	STB	LN,DZ03LK		:THIS LINK NO.
	JAL	R10,GSUPLG,,		:GATEWAY TO INET SUP LOG
	POP(R15)
	EI	:T2GATE##AL
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER,
	OI	R0,(NR.SNP^10)+8000	: COMBINE WITH REPORT TYPE
	ST	R0,SUPMBF
	JAL	R10,SUP12,,		:SEND LINK SNIP NODE REPORT AND CRYPTO
	LIS	R0,1
	AHM	R0,LSNIPS		:COUNT LINK SNIPS

TRLIN4	LR	R0,KN
	EXHR	R0,R0			:GET LINK NUMBER IN HI-ORDER HW
	OH	R0,NDID,KD		: AND COMBINE WITH NEIGHBOR NUMBER
	ST	R0,CRYSBF
	JAL	R8,CRYPTO,,
	HC	CRYE02			:REPORT LINK OUT TO XRAY
	LHL	R10,ZAPCNT		:DID WE ZAP ANY USER CIRCUITS?
	JE	TRLINZ			:NO - DON'T MAKE TRIVIAL REPORT TO LOG
	OHI	R10,8000
	STH	R10,SUPMBF+4
	OHI	R0,8000
	STH	R0,SUPMBF+2		:REPORT NEIGHBOR # FOR ZAPPED CIRCUITS
	STH	KN,SUPMBF+6		:SAVE LINK NUMBER FOR CRYPTOGRAM
	LIS	R0,NR.PLI
	STH	R0,SUPMBF		:SIMILAR TO TYMNET-I NPLI PROBE REPORT
	JAL	R10,SUP12,,		:MAKE NODE REPORT TO SUP LOG
	LHL	R0,CMDZCT		:COUNT OF COMMAND CIRCUITS ZAPPED
	JEFS	TRLINZ			:NONE
	OHI	R0,8000
	STH	R0,SUPMBF+4
	LHI	R0,NR.CCZ		:COMMAND CIRCUIT ZAP COUNT NODE REPORT
	STH	R0,SUPMBF
	JAL	R10,SUP12,,
TRLINZ	if	STRHUB
	LB	R0,KTYP,KD		:IF STARLINK, NO COPY OF ONDID	###AL
	CLHI	R0,STRTYP
	JEFS	TRLNZ1
	EI	:STRHUB
	LH	R0,ONDID,KD		:ONDID IS ZERO IF THIS IS AN XLINK,
	STH	R0,NDID,KD		: US TO RELEASE XLINK LINK DESCRIPTOR
TRLNZ1
:	GIVE UP PERMUTER TABLE SPACE. PERMUTER TABLE SPACE IS ALLOCATED
:	IN HALF-PAGES. T-I AND T-1.5 LINKS MAY HAVE ADJUSTED NCHN DOWN DUE
:	TO RECEIPT OF BACKPRESSURE RECORD FROM NEIGHBOR (SEE BPMV).
:	DETERMINE THE NUMBER OF HALF-PAGES ALLOCATED FOR T-I OR T-1.5 LINK,
:	SO THAT THE SAME NUMBER MAY BE FREED UP.

	LHL	R10,NCHN,KD
	JEFS	TRLIN5			:# OF CHANNELS NOT YET DETERMINED
	THI	R10,7F			:NUMBER CHANNELS MULTIPLE OF 80?
	JEFS	TRLIN7			:YES
TRLIN5	TBT	KN,ALINKS		:IS LINK ACTIVE, IF NCHN = 0?     ###GT
	JEFS	TRLIN7			:IF NCHN=0 & LINK NOT ACTIVE, THERE ARE
					:NO HALF-PAGES TO FREE UP         ###GT
	LHL	R10,NCHKN,KN,KN		:NO - DETERMINE NUMBER OF HALF-PAGES
	CLHI	R10,80			:	ALLOCATED BY NEWLNK
	JGFS	TRLIN6			:2 HALF-PAGES ALLOCATED IF NCHKN > 80
	LHI	R10,80			:1 HALF-PAGE ALLOCATED - SET # CHANS=80
	JFS	TRLIN7
TRLIN6	LHI	R10,100			:SET # CHANS TO 100 SINCE 2 HALF-PAGES
					:ALLOCATED TO LINK WITH >8 GROUPS
TRLIN7	LIS	R0,0
	SR	R0,R10			:GET NEGATIVE NUMBER OF CHANNELS IN R0
	LR	R3,R0
	SRA	R3,3			:# OF CHANS/8 = BYTE DISPLACEMENT FOR
					:LINK BIT ARRAYS
	AR	R0,R0			:FOR HALFWORD POINTER FIELD
	AHM	R0,EBDPKN,KN,KN		:DECREMENT END OF PERMUTER TBLE POINTER
	AHM	R3,LKFGND,KN,KN		:DECREMENT 'LAST HALFWORD IN ARRAY'
	AHM	R3,LKSVND,KN,KN		: FIELDS 
	AHM	R3,LKBPND,KN,KN
	LB	R0,MASTKN,KN,		:ARE WE MASTER ON THIS LINK?
	JNFS	TRLIN8			:YES, END PTR STAYS THE SAME
					: FOR NEG. ACP, CHS
	AHM	R3,LKAPND,KN,KN		:DECREMENT ACP END AND
	AHM	R3,LKCSND,KN,KN		: CHS END
TRLIN8	LR	R0,R10			:NUMBER OF CHANNELS DIVIDED BY 128
	SRLS	R0,7			: YIELDS # OF HALF PAGES BEING RETURNED
	AHM	R0,NUMPAG,,		: TO PERMUTER TABLE FREE POOL
	LIS	R0,0
	IF	STRHUB
	STB	R0,NLAT,KD		:No line attatched to this link	###ev
	EI	:STRHUB
	STH	R0,NCHN,KD		:NO CHANNELS FOR OUT LINK
	RBT	KN,ALINKS		:NOW WE CAN DECLARE LINK OUT     ###GT
	L	R10,NEWLNR
	JR	R10

	SUBTTL	YAKYAK (CHRTRC - Character Trace)

::*********************************************************************
::
::	SUBROUTINE:	CHRTRC:
::	FUNCTION:	CHARACTER TRACE ROUTINE.
::	CALLED BY RTD OR RMAKE TO RECORD DATA
::	TRAVELING ON A CHANNEL WITH A SET BIT IN 'TRCHAN' BIT ARRAY. THE
:: 	CALLING ROUTINE PASSES THE I/O INDICATOR IN R0 (-2 IF
::	RTD, -1 IF RMAKE), THE ABSOLUTE CHANNEL NUMBER IN R1, THE POINTER
::	TO THE LOGICAL RECORD IN R9, AND THE LOGICAL RECORD COUNT IN LRC.
::
::	RTD AND RMAKE CALL CHRTRC FOR EACH LOGICAL RECORD DETECTED FOR CHANNELS
:: 	BEING TRACED. THE CHRTRC ENTRY CONSISTS OF A FIXED LENGTH HEADER AND
:: 	VARIABLE LENGTH DATA (BASED ON LRC). THE HEADER FORMAT IS AS FOLLOWS:
::		HW1 - I/O INDICATOR
::		HW2 - ABSOLUTE CHANNEL NUMBER
::		HW3 - FASTC
::		HW4 - LOGICAL RECORD LENGTH (LRC)
:: 	AND IS FOLLOWED BY THE DATA. EACH ENTRY BEGINS ON A DOUBLEWORD BOUNDARY
:: 	IN 'TRRING', WHICH IS A CIRCULAR RING INDEXED BY 'TRRIX'.
::
::	CALLING SEQ:	JAL  R10,CHRTRC
::	INPUT:		R0,R1,R9,LRC
::	PRESERVED:	R1,R9,LRC
::	DESTROYED:	R0
::	RETURNS:	JR  R8
::
::*********************************************************************

CHRTRC	HS	0
	SYAD(CHRTRC)
	NOPR	0,R8			:PATCH TO '0308' TO TURN OFF TRACE
	STM	PRD,TRREGS		:SAVE SOME REGS
	LHI	TC,TRRSIZ-1		:POWER OF 2 RING WRAP MASK
	LHL	PRD,TRRIX		:GET CURRENT RING INDEX
	STH	R0,TRRING,PRD,		:STORE I/O INDICATOR AND
	STH	R1,TRRING+2,PRD,	: ABSOLUTE CHANNEL NUMBER
	LH	R0,FASTC+2,,
	STH	R0,TRRING+4,PRD,	:STORE CURRENT TIME
	STH	LRC,TRRING+6,PRD,	:STORE LOGICAL RECORD LENGTH
	AIS	PRD,8
	NR	PRD,TC

:	NOW MOVE LOGICAL RECORD TO TRRING. MUST MOVE A BYTE AT A TIME
:	SINCE HALFWORD ALIGNMENT NOT GUARANTEED.

CHRT10	LB	R0,0,R9			:GET BYTE FROM LOGICAL RECORD AND
	STB	R0,TRRING,PRD,		: MOVE IT TO RING
	AIS	R9,1
	AIS	PRD,1			:INCREMENT POINTERS
	NR	PRD,TC
	SIS	LRC,1			:DECREMENT COUNT
	JGBS	CHRT10			:MORE TO DO...

	AIS	PRD,7			:ROUND INDEX UP TO NEXT DOUBLEWORD BND
	NHI	PRD,TRRSIZ-8
	STH	PRD,TRRIX		:SAVE TRRING INDEX
	LM	PRD,TRREGS		:RESTORE REGS AND
	JR	R8			: RETURN

RMKEND	HS	0			:DEFINE END OF RMAKE FOR MACERR OPTION

:	***END YAKYAK***

	ENDMO.(YAKYAK)
	EI	:1-KILLIT
	KILMSG(YAKYAK)

:	***NOTHING PAST THIS POINT***
   

	SUBTTL	XHOSTS

:		*   * *   *  ***   ***  *****  ***
:		 * *  *   * *   * *       *   *
:		  *   ***** *   *  ***    *    ***
:		 * *  *   * *   *     *   *       *
:		*   * *   *  ***  ****    *   ****

::#####################################################################
::
::	MODULE:	 XHOSTS
::
::	FUNCTION:  Interfaces to kernel and supervisor processes.
::
::	REGISTER CONVENTIONS:
::		CD  = R13	:pointer to reCord Descriptor
::		CHN = R5	:CHannel Number
::		KP  = R7	:Kernel Port buffer offset
::		LRC = R14	:Logical Record byte Count
::		PRC = R10	:Physical Record byte Count
::		PRD = R12	:Pointer to Record Data
::		TC  = R15	:for TrunCating ring pointers (power of 2 mask)
::		TYC = R11	:holds magic constant (03 or 07)
::
::	ROUTINES:
::		IZKNRG - Initialize rings used in SIO ring interface
::		IZSIRG - Initialize SIO ring
::		KERIPS - Moves data into kernel port buffers
::		KEROPS - Processes kernel data destined into network
::		KxROOM - Kernel utility routines
::		SIRxxx - SIORNG utility routines
::		SUPIN  - Moves characters to the sup input buffers
::		SUPOUT - Moves characters from the sup output buffer into net
::		SxROOM - Sup process utility routines
::
::	SWITCHES:
::		IKERNL - ISIS kernel (excludes RKERNL)
::		IKNRNG - ISIS kernel negative ring structure
::			 Requires version X+ of ISIS.
::		ISIS   - ISIS (implies IKERNL, KERNEL)
::		KERNEL - Any kind of kernel on node
::		KNRING - Kernel negative ring (non-ISIS)
::		RESHST - Restricted host (ISIS only)
::		RKERNL - Real kernel (excludes ISIS)
::		SIORNG - Split sup (SIO ring) configuration
::		SNRING - Sup negative ring
::		SUPER  - Supervisor node
::
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.
	IF	(1-T2GATE)	:Gateway does not use XHOSTS

::*********************************************************************
::
::	XHOSTS PARAMETERS:
::
::*********************************************************************

	IF	SIORNG
	REMARK	%SIO ring interface, device address
	NUMBER	SIORNG
	REMARK	x%
	EI	:SIORNG

:	>>SUPERVISOR TRACE AREA MOVED TO DATA MODULE<<	###wjl

::*********************************************************************
::
::	** COMMUNICATE WITH KERNEL, SUPERVISOR IN SEPARATE ENGINE **
::	**	USING SIO RING COPY MOTHER BOARD....		  **
::
::	DEFINE QUAD-WORD RING DESCRIPTORS. RING DESCRIPTOR IS OF THE FORMAT:
::	HC	ISIZE	:SIZE OF INPUT RING (TOWARDS NODE)
::	HC	OSIZE	:SIZE OF OUTPUT RING (FROM NODE)
::	WC	IRINGE	:REAL CORE ADDRESS OF INPUT RING
::	WC	ORINGE	:REAL CORE ADDRESS OF OUTPUT RING
::	WC	SIRDEN	:RING PAIR NUMBER
::	AND MUST RESIDE ON A QUAD-WORD BOUNDARY.
::
::*********************************************************************

	SEG	1

	IF	SIORNG

SIRDEN	EQ	0			:FIRST RING PAIR IS NUMBERED ZERO
	ORG	((.+0F)/10)*10		:ALIGN ON QUAD WORD BOUNDARY
SIRDES	HS	0
	SYAD(SIRDES)
	GL	SEG4,S4PH,SEG5,S5PH		:##AL
	QUADWD(KCNTLS,KCNTLS,KCNTLO,KCNTLI,4)
	QUADWD(KOFSIZ,NLOGSZ,KOF,NEWLOG,4)
KBNO	EQ	KBSZ+SIRGNF
	NOLIST
	RE	NKU
	QUADWD(KBSZ,KBSZ,KOB+KBNO,KIB+KBNO,4)
KBNO	EQ	KBNO+KBSZ+SIRGNF
	ER
	LIST
	QUADWD(SUPBSZ,SUPBSZ,NOSO+2,NOSI+2,5)
	QUADWD(SOBPSZ,SIBPSZ,NOSOBP+2,NOSIBP+2,5)
	QUADWD(SOCSZ,SICSZ,NOSOC+2,NOSIC+2,5)
SIRNRG	EQ	(.-SIRDES)/10
	SYAD(SIRNRG)			:NUMBER OF SIO RING DESCRIPTORS

	BND	10
SIRDRD	WS	0		:RING DESCRIPTOR FOR DOWN-LINE LOAD RING
	QUADWD(SIRDLS,SIRDLS,DWLKOB+4,DWLKIB+4,4)

KBNO	EQ	KBSZ+SIRGNF		:INIT TO SET UP TABLE FOR KIB & KOB
KBTBL	HS	0			:TABLE OF OFFSETS INTO KIB & KOB
	RE	NKU
	HC	KBNO
KBNO	EQ	KBNO+KBSZ+SIRGNF
	ER

	EI	:SIORNG

::*********************************************************************
::
::	NEGATIVE RING INDEXING REQUIRES ADDRESSING THE END OF THE RING
::	WITH A NEGATIVE INDEX REGISTER SPECIFIED. RE-DEFINE KIB, KOB TO
::	POINT TO END OF RING AREA.
::
::*********************************************************************

	IF	KNRING
KIB	EQ	KIB-SIRGNF		:END OF DATA AREA FOR RINGS
KOB	EQ	KOB-SIRGNF
	SYAD(KOB   )
	EI	:KNRING

	SUBTTL	XHOSTS (IZKNRG, IZSIRG - Initialization routines)

::*********************************************************************
::
::	SUBROUTINE:	IZKNRG:
::	FUNCTION:	Initializes rings used in SIO ring interface
::	CALLING SEQ:	JAL	R10,IZKNRG
::	DESTROYED:	R0, R1, R2, R3
::	CALLS:		JAL	R8,HCLEAR
::			JAL	R9,SIRCMD
::
::*********************************************************************

:	FIRST GIVE SIO CARD 'DIE' COMMAND (O.K. IF IT'S ALREADY DEAD).
:	INITIALIZE ALL RING POINTERS FOR EMPTY RINGS.

	IF	SIORNG

IZKNRG	HS	0
	LHI	R0,SIRDIE		:COMMAND SIO RING CARD TO DIE
	JAL	R9,SIRCMD		:ISSUE SVC, HANDLE TIME-OUT
	NOP				:TIME-OUT RETURN
	GL	S4SIZE,SEG4		:##AL
	LA	R1,SEG4,,
	LHI	R2,SS4SIZ/2             :size of supe's data in seg 4#sdw
	JAL	R8,HCLEAR,,		:CLEAR RING AREAS

:	INITIALIZE POINTERS FOR ALL KIB, KOB RINGS...
	LHI	R2,(NKU-1)*2
	LHI	R1,-KBSZ		:INITIAL VALUE FOR RING POINTERS
IZKN10	LHL	R3,KBTBL,R2,		:GET RING PAIR OFFSET
	STH	R1,NII,R3,
	STH	R1,NOI,R3,		:INIT RING POINTERS FOR EMPTY RINGS
	STH	R1,NIO,R3,
	STH	R1,NOO,R3,
	SIS	R2,2
	JGE	IZKN10			:DO ALL RINGS

	LHI	R1,-KCNTLS
	STH	R1,KCNTLI-4,,		:INITIALIZE CONTROL INPUT RING
	STH	R1,KCNTLI-2,,

	STH	R1,KCNTLO-4,,		:INITIALIZE CONTROL OUTPUT RING
	STH	R1,KCNTLO-2,,

	LHI	R1,-NLOGSZ
	STH	R1,NEWLOG-4,,		:INITIALIZE NEWLOG RING
	STH	R1,NEWLOG-2,,

	LHI	R1,-KOFSIZ
	STH	R1,KOF-4,,		:INITIALIZE DATA READY ARRAY RING
	STH	R1,KOF-2,,

	LIS	R0,0
	ST	R0,KERNWL,,		:NO NEW LOGONS OR
	ST	R0,NLOGOK		: NEWLOG HANDSHAKES IN PROGRESS
	ST	R0,NLOGCT
	STH	R0,KERSTT		:KERNEL STATUS
	JR	R10			:RETURN

	EI	:SIORNG

::*********************************************************************
::
::	SUBROUTINE:	IZSIRG:
::	FUNCTION:	Initialize SIO ring. Kill SIO card, activate
::			ring pairs, and bring SIO card to life.
::	CALLING SEQ:	JAL	R10,IZSIRG
::	DESTROYED:	R0, R1, R2, R3, R6, R8, and R9
::	CALLS:		JAL	R9,SIRCMD
::
::*********************************************************************


	IF	SIORNG

IZSIRG	HS	0
	LHI	R0,SIRDIE		:COMMAND SIO RING CARD TO DIE
	JAL	R9,SIRCMD		:ISSUE SVC, HANDLE TIME-OUT
	NOP				:TIME-OUT RETURN

	LIS	R0,0
	ST	R0,SIRI,,		:INITIALIZE SIRX RING POINTERS
	STH	R0,SIRFLG		:INDICATE SIO RING CARD DEAD

:	ACTIVATE RING PAIRS. CALL SIRCMD FOR EACH RING PAIR TO ACTIVATE.
: 	R0 HAS RING PAIR NUMBER IN BYTE 2, SIO RING CARD DEVICE ADDRESS IN
: 	BYTE 3. R1 HAS THE QUAD-WORD ADDRESS OF RING PAIRS' RING DESCRIPTORS.
	LHI	R6,SIRNRG		:NUMBER OF RING PAIRS TO INITIALIZE
	LA	R1,(SIRDES-SEG1+S1PH)/10 :QUAD-WORD ADDRESS OF RING DESCRIPTORS
	LHI	R0,SIORNG		:RING PAIR ZERO PLUS DEVICE ADDRESS
IZSR10	JAL	R9,SIRCMD		:ISSUE SVC, HANDLE TIME-OUT
	STH	R0,SIRFLG		:TIME-OUT
	AHI	R0,100			:INCREMENT RING PAIR NUMBER
	AIS	R1,1			:NEXT QUAD-WORD
	SIS	R6,1
	JGBS	IZSR10			:DO FOR ALL RING PAIRS

	LHI	R0,SIRALV		:BRING SIO RING CARD TO LIFE
	JAL	R9,SIRCMD		:ISSUE SVC, HANDLE TIME-OUT
	STH	R0,SIRFLG		:INDICATE TIMED-OUT

	JR	R10			:RETURN

	EI	:SIORNG

::*********************************************************************
::
::	KPRMAP:	 FW POINTERS TO PORTS' RING AREAS
::
::*********************************************************************

	IF	IKNRNG
KPRMAP	WS	0			:FW POINTERS TO PORTS' RING AREAS
Q	EQ	0
	RE	NKU			:ONE FOR EACH PORT
	WC	KRINGS+((KBSZ+4)*2*Q)
Q	EQ	Q+1
	ER	:NKU
	EI	:IKNRNG

	SUBTTL	XHOSTS (KERIPS - Move network data into kernel)

::*********************************************************************
::
::	SUBROUTINE:	KERIPS:
::	FUNCTION:	Moves data into kernel port buffers.
::	CALLING SEQ:	JAL	R10,KERIPS
::	CALLS:		JAL	R9,SIRCIN
::			JAL	R10,IZKNRG
::			JAL	R10,IZSUP
::			JAL	R10,IZSIRG
::			JAL	R9,JBIDDY
::			JAL	R9,KLROOM
::
::*********************************************************************

:******; IF	KERNEL

KERIPS	HS	0

:	******;	IF	SIORNG		:AND IF KERNEL
	LH	R0,SIRDLD		:SIO RING LOAD IN PROGRESS?
	JLR	R10			:YES - WAIT FOR LOAD TO COMPLETE
:	******;	EI	:SIORNG

	ST	R10,XHSVRT		:SAVE RETURN ADDRESS

:	******;	IF	KNRING		:AND IF KERNEL
	IF	DB.DEB
	NEGTST(LH,0,KCNTLI,-4,0,0)
	NEGTST(LH,0,KCNTLI,-2,0,0)
	NEGTST(LH,0,KCNTLI,-4,0,0)
	NEGTST(LH,0,NEWLOG,-2,0,0)
	NEGTST(LH,0,KOF,-4,0,0)
	NEGTST(LH,0,KOF,-2,0,0)
	NEGTST(LH,0,KCNTLO,-4,0,0)
	NEGTST(LH,0,KCNTLO,-2,0,0)
	EI	:DB.DEB
:	******;	EI	:KNRING

:	******;	IF	SIORNG		:AND IF KERNEL
	JAL	R9,SIRCIN		:GO CHECK FOR INTERRUPTS FROM SIO CARD
:	XRAY COMMAND MAY HAVE SPECIFIED FORCED INITIALIZATION OF SIO
: 	RING INTERFACE. IF SIRXIZ=0, NO FORCED INIT. IF SIRXIZ=1, INITIALIZE
: 	SIO RING, BUT DON'T MODIFY INTERFACE RING POINTERS. IF SIRXIZ=2,
: 	INITIALIZE INTERFACE RING POINTERS AND SIO RING.
	LH	R0,SIRXIZ,,		:FORCED INITIALIZATION?
	JEFS	KRSI20			:NO
	SIS	R0,1			:INITIALIZE INTERFACE RING POINTERS?
	JEFS	KRSI10			:NO - JUST SIO RING CARD
	JAL	R10,IZKNRG		:INITIALIZE INTERFACE RING POINTERS
	JAL	R10,IZSUP		:INITIALIZE SUP RINGS
KRSI10	JAL	R10,IZSIRG		:INITIALIZE SIO RING CARD
	LIS	R0,0
	STH	R0,SIRXIZ,,		:RESET INITIALIZATION FLAG
:	******;	EI	:SIORNG

KRSI20	HS	0
	LIS	R4,0			:KERFLG MAY BE MORE THAN 1 FW
KRSI22	L	R0,KERFLG,R4,		: CHECK ALL BUFFERS W/ CHARS FOR PORTS

	IF	NKU-20
	JNFS	KRSI21
	AIS	R4,4			:NONE HERE, CHECK NEXT FW
	CLHI	R4,(NKU+7)/8		:ONLY SO MANY FW'S IN KERFLG ARRAY
	JLBS	KRSI22			:ONE MORE
	SIS	R4,4
	EI	:NKU-20

KRSI21	STH	R4,KR4SAV
	ST	R0,KERSVD		:KERFLG SAVED AWAY
:	standard set up for jump to jbiddy
	LI	R4,4			:let's clean this up before release#wjl
	LA	R3,KERSVD		:FOR BIDDY
	JAL	R9,JBIDDY		:RETURNS KERNEL PORT IN R2
	GL	JBIDDY
	J	KERIN			:FOUND ONE

:	******;	IF	KNRING		:AND IF KERNEL
:	SINCE WE CAN REPORT ONLY ONE NEW LOGIN AT A TIME, WE
: 	MAY HAVE DEFERRED MULTIPLE NEWLOG REPORTS TO KERNEL.
KRSI23	L	R4,NLOGDF		:ANY DEFERRED LOGINS OUTSTANDING?
	JE	XHRET			:NO
	JAL	R9,KLROOM		:IS ROOM NOW AVAILABLE IN NEWLOG RING?
	SIS	LRC,2			:NEED AT LEAST 2 BYTES
	JLFS	XHRET			:WE'LL CATCH THIS GUY LATER
	JFFO	R4,KERI10		:FIND CHANNEL NUMBER
	CRASH.(.KERIC)
KERI10	RBT	CHN,NLOGDF		:CONSIDER IT DONE
	J	KINL00			:INFORM KERNEL OF NEW LOGIN
:	******;	EI	:KNRING

XHRET	L	R10,XHSVRT		:RETURN TO SPIDER
	JR	R10

::*********************************************************************
::
::	SUB-PROCESS:	KERIN
::	FUNCTION:	MOVES DATA INTO ISIS OR SUP KERNEL FROM NETWORK
::	CALLING SEQ:	LA	R3,KERSVD	Dispatched based on
::			JAL	R9,JBIDDY	buffered data requesting
::			J	KERIN		output to the kernel.
::	CALLS:		JAL	R9,KIROOM
::			JAL	R8,PCIS
::			JAL	R8,PCI
::			JAL	R8,GCI
::			JAL	R8,CBCCT
::			JAL	R8,NEDTIM
::			JAL	R9,ZAPX
::			JAL	R9,CRQHCR
::			JAL	R8,WCI
::			JAL	R9,KCROOM
::			JAL	R8,WCD
::			JAL	R10,SUP12
::			JAL	R9,ZAPV
::
::*********************************************************************

KERIN	HS	0			:R2 CONTAINS PORT NUMBER WITH DATA
					: RELATIVE TO FW OF KERFLG
	IF	DB.CPU
	LR	R4,R2			:SAVE R2
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR KERIN		###OAS
	CPUTNM(KERIN )			:DEFINE CPUTIL ENTRY FOR KERIN	###OAS
	LR	R2,R4			:RECOVER R2
	EI	:DB.CPU

	IF	NKU-20
	LHL	R4,KR4SAV		:RESTORE R4
	SLLS	R4,3			:FW OFFSET FOR R2
	AR	R2,R4			:R2 NOW CONTAINS PORT NUMBER.
	EI	:NKU-20

:	******;	IF	1-(KNRING!IKNRNG)	:AND IF KERNEL
	LHI	TC,KBSZ-1		:POWER OF 2 MASK FOR POSITIVE RINGS
:	******;	EI	:1-(KNRING!IKNRNG)

	LIS	TYC,3			:TO TEST FOR CONTROL CHAR
	LR	CHN,R2			:REL KERNEL PORT# SUPPLIED BY BIDDY

:	******;	IF	KNRING	:AND IF KERNEL
:	NLOGDF, NLOGCT, AND NLOGOK CONTROL HANDLING NEW LOGINS TO KERNEL.
:	A NEW CIRCUIT IS INDICATED BY A SET BIT IN KERNWL. WHEN A NEW CIRCUIT
:	IS DETECTED, WE SEND A CONTROL MESSAGE TO THE KERNEL AFTER MAKING OUR
:	KOB POINTERS EQUAL AND SETTING NLOGCT. THE KERNEL MAKES ITS KIB
:	POINTERS EQUAL AND SENDS US A NEWLOG CONTROL MESSAGE ACK. WE THEN
:	RESET NLOGCT AND SET NLOGOK, ALLOWING PROCESSING OF THE NEW CIRCUIT TO
:	THE KERNEL INTERFACE. WE STORE THE LOGIN STRING AND TRAILING DATA IN
:	KIB AND PASS THE NEW PORT NUMBER IN THE NEWLOG CONTROL RING. IF NO
:	ROOM IS AVAILABLE IN THE NEWLOG CONTROL RING, WE MUST SET NLOGDF AND
:	SEND THE PORT NUMBER THROUGH THE NEWLOG RING WHEN SPACE IS AVAILABLE.

	TBT	CHN,KERNWL,,		:SET IN CRQ FOR NEW KERNEL PORT
	JE	KERI12			:NOT A NEW CIRCUIT
	RBT	CHN,NLOGOK		:CAN WE HANDLE IT?
	JN	KERI12			:YES - WE MUST BE IN SYNC WITH KERNEL
	SBT	CHN,NLOGCT		:INDICATE PASSING NEWLOG MESSAGE
					: THROUGH CONTROL RING
:  	CHECK IF KERNEL IS STILL ALIVE.  IF KERNEL DOES NOT PROCESS A LOGIN
:	BETWEEN 16-24 SECONDS, WE WILL ASSUME IT HAS DIED AND WILL ZAP ALL
:	CIRCUITS TO KERNEL AND DECLARE THE HOST SHUT.
	JE	KERNLG		:INFORM KERNEL OF PENDING NEW LOGIN	###GT
	LIS	R0,3		:3 X 8 SECS IS THE TIME-OUT		###GT
	CLH	R0,KERSTT	:CHECK IF KERNEL HAS DIED		###GT
	JN	BIDDRT,,	:NO, OR NOT YET.. SO GO AWAY		###GT
	JAL	R10,KCQDET	:YES - ZAP ALL CIRCUITS AND SHUT HOST	###GT
	LIS	R0,2		:HOST SHUT STATUS			###GT
	STB	R0,HSTAT	:SAVE NEW STATUS			###GT

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)			###GT
	LR	R2,R0		:PRESERVE R0				###GT
	SLLS	R2,6		:SHIFT BITS 6,7 TO BITS 0,1		###GT
	LB	R1,HSTATN	:AND OR INTO HSTATN			###GT
	NHI	R1,003F		:STRIP OFF BITS 0 AND 1			###GT
	OR	R1,R2		:NOW ADD STATUS BITS			###GT
	STB	R1,HSTATN	:					###GT

	LHI	R8,HST0		:					###GT
	STH	R8,CRYSBF+2	:STORE HOST NUMBER FOR XRAY		###GT
	JAL	R8,CRYPTO,,	:HOST STATUS CRYPTOGRAM			###GT
	HC	CRYE15
	LIS	HN,0		:HOST ZERO IS KERNEL HOST		###GT
	STH	R13,SIRFLG	:INDICATE RING DEAD  HN = R13		###GT
	JAL	R10,SUP11,,	:SEND HOST STATUS REPORT TO SUP		###GT

	GL	SUP11
	J	BIDDRT,,	:RETURN FOR MORE WORK			###GT
:	******;	EI	:KNRING

KERI12	HS	0
	LR	KP,CHN			:SAVE CHANNEL NUMBER

:	******;	IF	RKERNL		:AND IF KERNEL
	AR	CHN,CHN			:NON-ISIS KERNEL USES HW INDEX IN CHN
	LHL	R2,KIOTAB,CHN,		:GET PERMUTER TABLE ENTRY
	ELSE	:NOT RKERNL
	LHL	R2,KIOTAB,CHN,CHN	:PERMUTER TABLE ENTRY, ISIS KERNEL
:	******;	EI	:RKERNL

	NHI	R2,-4			:MASK OUT GOUGING BITS
	JNFS	KERI20
	CRASH.(.KERI0)
KERI20	XHI	R2,4			:FLIP TO INBOUND BUFFER INDEX
	JAL	R9,KIROOM		:COMPUTE SPACE AVAILABLE IN RING FOR
					: THIS PORT
	SIS	LRC,2			:ALLOW FOR CHARACTER PAIRS
	JG	KERI22			:ROOM AVAILABLE, SET UP TRANSFER

:	******;	IF	KNRING!IKNRNG	:AND IF KERNEL
:	NO ROOM IN PORT'S RING, CHECK FOR ZAPPER OR GOBBLER
	JAL	R8,PCIS			:PEEK AT NEXT CHARACTER
	SIS	R1,3			:ZAPPER OR GOBBLER?
	JN	BIDDRT,,		:NO - WE'LL WAIT FOR ROOM IN RING

:		******;	IF	IKNRNG	:AND IF KNRING!IKNRNG
	JAL	R8,PCI			:PEEK AT SECOND CHAR OF 03-PAIR
	CLHI	R1,GOBBL&0FF		:GOBBLER?
	JE	BIDDRT,,		:YES, WAIT FOR ROOM IN RING
	J	KEIZAP			:NO, IT'S A ZAPPER, SO GO ZAP
:		******; ELSE	:KNRING
	JAL	R8,GCI			:YES - PULL IT OUT AND
	J	KEIT03			: PASS TO KERNEL IN CONTROL RING
:		******;	EI	:(KNRING)IKNRNG

:	******;	ELSE	:NOT KNRING!IKNRNG AND IF KERNEL
	J	BIDDRT,,		:NO ROOM IN RING
:	******;	EI	:(NOT) KNRING!IKNRNG

KERI22	JAL	R8,CBCCT		:COMPUTE MINIMUM (BUFF CNT, RING SPACE)
	CR	R1,LRC
	JGEFS	KERI24
	LR	LRC,R1
KERI24	LR	CD,LRC			:NUMBER OF CHARACTERS TO MOVE

:	******;	IF	1-(KNRING!IKNRNG)	:AND IF KERNEL
	NR	PRD,TC			:TRUNCATE INPUT PTR ???
:	******;	EI	:1-(KNRING!IKNRNG)

KERI30	JAL	R8,GCI			:GET CHAR
KERI40	STB	R1,KIB,KP,PRD		:PUT AWAY
	AIS	PRD,1			:ADVANCE RING POINTER

:	******;	IF	KNRING!IKNRNG	:AND IF KERNEL
	JLFS	KERI42			:NEGATIVE INDEX
	SHI	PRD,KBSZ		:WRAP RING...
:	******;	ELSE	:NOT KNRING!IKNRNG
	NR	PRD,TC			:POWER OF 2 MASK
:	******;	EI	:(NOT) KNRING!IKNRNG

KERI42	CR	R1,TYC			:TYMNET CONTROL CHARACTER?
	JGFS	KERI6			:NO - NORMAL HANDLING
	J	KEITYM
KERI6	SIS	CD,1
	JGBS	KERI30

	AM	LRC,KERICC		:CNT OF CHARS INTO KERNEL
        if      1-rkernl
        ar      chn,chn
        am      lrc,kerict,chn,chn      :count by port
        srls    chn,1
        else    :rkernl
        am      lrc,kerict,chn,chn
        ei      :
KERI5	HS	0
:	******;	IF	IKERNL		:AND IF KERNEL

:		******; IF	IKNRNG	:AND IF IKERNL
	STH	PRD,NII,KP,		:STORE AWAY POINTER

:		******;	ELSE	:NOT IKNRNG
	STB	PRD,NII,CHN,		:STORE AWAY POINTER
:		******;	EI	:(NOT) IKNRNG

:	******;	ELSE	:NOT IKERNL AND IF KERNEL
:		******;	IF	KNRING	:AND IF NOT IKERNL
	AH	LRC,NII,KP,		:INCREMENT NODE INDEX
	JLFS	KERI52
	SHI	LRC,KBSZ		:ADJUST FOR WRAP
KERI52	STH	LRC,NII,KP,		:PUT IT AWAY

:		******;	ELSE	:NOT KNRING
	AHM	LRC,NII,CHN,
:		******;	EI	:(NOT) KNRING

	SRHLS	CHN,1
:	******;	EI	:(NOT) IKERNL

	IF	INTACC		:###EV
	LHI	R3,KERZFL
	AR	R3,CHN			:Make port index into real chn #
	SHI	R3,MNACHN		:Make accounting port index
	LR	R0,LRC			:Set up character count
	JAL	R8,AARDIC,,		: and accumulate input characters
	GL	AARDIC
	EI	:INTACC		###EV
	RBT	CHN,KERNWL,,		:SET NEWLOG IF NEEDED
	JE	BIDDRT,,

:	GOT NEW LOGON INTO KERNEL
	JAL	R8,NEDTIM,,		:COMPUTE NEEDLE TIME, RECORD CIRC TIME
	LHL	R0,HNPORT		:BUMP NUMBER OF ACTIVE PORTS
	AIS	R0,1
	CLH	R0,MXPORT		:NEW PEAK?
	JLEFS	XHSMAX			:NO
	STH	R0,MXPORT		:YES, STORE THE NEW PEAK
XHSMAX	STH	R0,HNPORT

:	INFORM KERNEL OF NEW LOGIN
:	******;	IF	1-(KNRING!IKNRNG)	:AND IF KERNEL
	SBT	CHN,NEWLOG,,		:KERNEL EXAMINES THIS FOR NEW PORTS
	J	BIDDRT,,		:DONE WITH THIS PORT

:	******;	ELSE	IKNRNG		:AND IF 1-(KNRING!IKNRNG)
:	SET UP PARAMETERS FOR KERNEL LOGON SVC. 3 FW'S AT KPARMS, AS:
:	FW1 = ADDRESS OF PORT'S RING AREA
:	FW2 = PORT'S BIT INDEX (RELATIVE TO 0) INTO KOF ARRAY
:	FW3 = PORT'S BIT INDEX (RELATIVE TO 0) INTO KOFF ARRAY
	LA	R0,KOF,,		:GET ADDRESS OF DATA AVAILABLE ARRAY
	SLLS	R0,3			:8-BIT INDEX
	AR	R0,CHN			:PLUS KERNEL PORT NUMBER
	ST	R0,KPARMS+4,,		:SECOND PARAMTER FW
	LA	R0,KOFF,,		:GET ADDRESS OF RELIEVE B/P ARRAY
	SLLS	R0,3			:8-BIT INDEX
	AR	R0,CHN			:PLUS KERNEL PORT NUMBER
	ST	R0,KPARMS+8,,		:THIRD PARAMETER FW
	ST	KP,KPARMS,,		:RING AREA POINTER - FIRST PARAMETER FW
	LA	R0,KPARMS,,
	SVC	SYS,$A36		:DECLARE PORT TO KERNEL
	NOPR	0,0			:PADDING
	JFS	KLFAIL			:KERNEL REFUSED LOGON
					: DETACH PORT, SEND MSG
	J	BIDDRT,,		:DONE WITH THIS GUY
KLFAIL	HS	0
	L	R4,DETACP,,		:FIND A DETACH PROCESS PORT
	JFFO	R4,KLFAI1
	XHI	R2,4			:IF NOT AVAILABLE, JUST ZAP
	JAL	R9,ZAPX,,
	GL	ZAPX
	J	BIDDRT,,		:AND ALL DONE
KLFAI1	LIS	R4,3			:DETACH MESSAGE-OUT OF KERNEL PORTS
	STB	R4,DETMTY,CHN		:TELL DETACH PROCESS WHICH MESSAGE
	LHI	R1,0D0A			:FAKE ZAPPER - CRLF
	XHI	R2,4			:FLIP TO OUT BUFFER
	JAL	R9,ZAPX,,		:ZAP HALF CIRCUIT
	AHI	CHN,DETZFL		:DETACH PROCESS ABS CHANNEL #
	JAL	R9,CRQHCR,,		:CONNECT CRQ STUB TO DETACH PROCESS
	XHI	R2,4			:POINT TOWARD DETACH PROCESS
	LIS	R1,3			:WRITE NEEDLE POINT INTO BUFFER
	JAL	R8,WCI			:TO INFORM DETACH PROCESS
	LHI	R1,NEEDP
	JAL	R8,WCI
	J	BIDDRT,,		:ALL DONE WITH THIS PORT

:	******;	ELSE	KNRING		:AND IF 1-(KNRING!IKNRNG)
:	PASS CHANNEL NUMBER IN NEWLOG RING TO INFORM KERNEL OF NEW PORT.
: 	IF THE NEWLOG RING HAS NO ROOM, WE MUST DEFER REPORT UNTIL SPACE IS
: 	AVAILABLE IN NEWLOG.
	JAL	R9,KLROOM		:COMPUTE SPACE AVAILABLE IN NEWLOG RING
	SIS	LRC,2			:NEED AT LEAST 2 BYTES
	JLFS	KINL20			:NO ROOM - DEFER NEWLOG REPORT
KINL00	STH	CHN,NEWLOG-4,PRD,	:CHN IS ALL THAT'S REQUIRED
	AIS	PRD,2			:INCREMENT RING POINTER
	JLFS	KINL10
	LHI	PRD,-NLOGSZ		:ADJUST FOR RING WRAP
KINL10	STH	PRD,NEWLOG-4,,		:STORE NEW NODE RING INDEX
	J	BIDDRT,,		:DONE WITH THIS PORT

:	SET BIT IN NLOGDF TO INDICATE WE MUST REPORT NEW PORT TO KERNEL
: 	WHEN SPACE IS AVAILABLE IN NEWLOG RING.
KINL20	SBT	CHN,NLOGDF
	J	BIDDRT,,		:DONE FOR NOW...
:	******;	EI	:(NOT)1-(KNRING!IKNRNG)

KEITYM	JE	KEIT03			:03-TYPE PAIR?
	JAL	R8,GCI			:01,02 CHAR PAIR
KEITY1	OHI	R1,100			:SEND THE SECOND CHAR ON
	SIS	CD,1
	JN	KERI40			: ???
	AIS	LRC,1			:LRC IS AFFECTED
	J	KERI40

:	******;	IF	RKERNL	:AND IF KERNEL
:	NORMAL T-II KERNEL PROCESSING

:		******;	IF	KNRING	:AND IF RKERNL

:	ZAPPERS AND GOBBLERS GET PASSED TO THE KERNEL IN A CONTROL RING.
: 	EACH MESSAGE IN THE CONTROL RING CONSISTS OF A CHANNEL NUMBER FOLLOWED
: 	BY A BYTE INDICATING WHICH CONTROL CHARACTER WAS DETECTED.
KEIT03	HS	0
	JAL	R9,KCROOM		:ANY ROOM IN CONTROL RING?
	SIS	LRC,2			:NEED AT LEAST 2 BYTES IN RING
	JGEFS	KICT10			:GOT IT
:	NO ROOM IN CONTROL RING TO KERNEL. PUT '03' BACK IN BUFFER, WILL
: 	PASS CONTROL MESSAGE WHEN RING SPACE AVAILABLE.
	LIS	R1,3
	JAL	R8,WCD			:PUT 03 BACK IN BUFFER
	J	BIDDRT,,		:WILL TRY AGAIN LATER

KICT10	SRLS	CHN,1			:ACTUAL CHANNEL NUMBER
	JAL	R8,GCI			:GET NEXT CHARACTER
	CLHI	R1,GOBBL&0FF		:GOBBLER?
	JEFS	KICT20			:YES
	JLFS	KICT30			:NO, IT'S A ZAPPER
	CRASH.(.KICTC)
KICT20	SBT	CHN,KRGOBI		:INDICATE GOBBLER PASSED TO KERNEL - WE
	LIS	R0,KR.GOB		: EXPECT GOBBLER ACK BACK FROM KERNEL
	JFS	KICT40

:	IF A ZAPPER OR A GOBBLER IS DETECTED FOR THE KERNEL, WE MARK THE
: 	CONDITION AND PREVENT DATA FROM PASSING UNTIL AN ACK IS RECEIVED FROM
: 	KERNEL. FOR ZAPPERS, WE DO NOT FREE THE PORT (CALL ZAPV) UNTIL WE GET
: 	ZAP ACK FROM KERNEL.
KICT30	SBT	CHN,KRZAPI		:INDICATE ZAPPER PASSED TO KERNEL
	LIS	R0,KR.ZAP
KICT40	EXBR	CHN,CHN
	OR	CHN,R0			:MESSAGE IS 2 BYTES - CHANNEL FOLLOWED
	STH	CHN,KCNTLI-4,PRD,	: BY CONDITION BYTE
	AIS	PRD,2			:UPDATE RING POINTER
	JLFS	KICT50
	LHI	PRD,-KCNTLS		:NEGATIVE RING WRAP
KICT50	STH	PRD,KCNTLI-4,,		:UPDATE LEAD RING POINTER
	J	BIDDRT,,		:DONE FOR THIS PORT.
:	NOTE THAT A MESSAGE FRAGMENT MAY HAVE BEEN STARTED FOR THIS CHANNEL
: 	BEFORE THE ZAPPER/GOBBLER WAS ENCOUNTERED.  THE FACT THAT WE HAVEN'T
:	UPDATED THE PORTS'S KIB RING POINTER MEANS NO DATA WILL BE SENT
:	(SINCE WE WOULD HAVE GOBBLED IT ANYWAY).

:		******;	ELSE	:NOT KNRING AND IF RKERNL
KEIT03	JAL	R8,GCI			:03 TYPE PAIR
	CLHI	R1,GOBBL&0FF		:TEST FOR GOBBLER
	JE	KEITY1			:GOBBLER, JUST PASS IT ON
KEIZAP	LHI	R1,ZAPPH		:ZAPPER, INSURE IT'S A HARD ONE
	STB	R1,KIB,KP,PRD
	AIS	PRD,1
	NR	PRD,TC
	SHI	LRC,-2,CD		:TERMINATE MESSAGE HERE

:		******;	EI	:(NOT)KNRING

:	******;	ELSE	:NOT RKERNEL AND IF KERNEL
KEIT03	JAL	R8,GCI			:TEST FOR GOBBLER
	CLHI	R1,GOBBL&0FF
	JNFS	KEIZAP			:???
	SIS 	PRD,1
	IF	IKNRNG
	OHI	PRD,-KBSZ		:BACK UP POINTER
	ELSE	:NOT IKNRNG
	NR 	PRD,TC			:BACK UP POINTER
	EI	:(NOT)IKNRNG
	LIS	R1,2			:T-I GOBBLER
	LIS	LRC,1			:MESSAGE IS SHORTER
	J	KEITY1
KEIZAP	HS	0
:		******;	IF	IKNRNG	:AND IF NOT RKERNL
	LR	R0,KP			:PORT'S RING AREA POINTER IN R0 FOR SVC
	SVC	SYS,$A37		:ZAP KERNEL PORT
	NOPR	0			:PADDING
	JFS	KZFAIL			:KERNEL WOULDN'T ZAP PORT
	J	KPZAP			:GO ZAP IT
KZFAIL	HS	0			:SEND SUP AND CRYPTO MSGS
	JAL	R9,ZAPV,,		:ZAP IT
	LHI	R0,NR.KZF		:KERNEL ZAP FAILED NODE REPORT TO SUP
	STH	R0,SUPMBF
	LR	R0,CHN
	OHI	R0,8000			:MASK OUT HW2 AND SET HO BIT OF HW3
	ST	R0,SUPMBF+2		:KERNEL PORT #
	JAL	R10,SUP12,,
	J	KPZAP1
:		******;	EI	:IKNRNG

	SHI	LRC,-1,CD		:ZAPPER, END MESSAGE

:	******;	EI	:(NOT)RKERNL

:	******;	IF	1-KNRING	:AND IF KERNEL
KPZAP	JAL	R9,ZAPV,,
	IF	INTACC		:###EV
	LHI	R3,KERZFL
	AR	R3,CHN			:Make port index into real chan #
	SHI	R3,MNACHN		:Make accounting port index
	LI	R0,AALR03		:Normal disconnect from Network
	JAL	R8,AARLO,,		:Perform final accounting
	GL	AARLO
	EI	:INTACC		###EV
KPZAP1	HS	0
:		******; IF IKNRNG
	RBT	CHN,NEWLOG,,		:IF WE'RE ZAPPING A NEW LOGIN,
	JN	BIDDRT,,		:DON'T BOTHER WITH THE REST
:		******; EI	:IKNRNG
	LCS	R0,1			:ONE LESS LOGON
	AHM	R0,HNPORT
:		******; IF IKNRNG
	J	BIDDRT,,		:ALL DONE
:		******; ELSE	:NOT IKNRNG
	J	KERI5
:		******; EI	:(NOT)IKNRNG
:	******;	EI	:1-KNRING

:	******;	IF	KNRING
:	SEND NEWLOG MESSAGE TO KERNEL THROUGH CONTROL RING
KERNLG	HS	0
	JAL	R9,KCROOM		:ROOM IN CONTROL RING?
	LR	LRC,LRC
	JE	BIDDRT,,		:NO, HANDLE THIS LATER
	LR	R0,CHN
	EXBR	R0,R0			:CHANNEL NUMBER IN UPPER BYTE,
	OHI	R0,KR.NLG		: CONTROL MESSAGE TYPE IN LOWER BYTE
	STH	R0,KCNTLI-4,PRD,	:PUT IT AWAY
	AIS	PRD,2
	JLFS	KERNL2
	LHI	PRD,-KCNTLS		:NEGATIVE RING WRAP
KERNL2	STH	PRD,KCNTLI-4,,		:UPDATE RING POINTER
	LHL	KP,KBTBL,CHN,CHN
	LHL	R0,NIO,KP,		:MAKE KOB RING POINTERS EQUAL
	STH	R0,NOO,KP,
	RBT	CHN,KOFSAV		:DON'T EXAMINE KOB FOR THIS PORT
	LIS	R0,0			:SET TIME-OUT VALUE		###GT
	STH	R0,KERSTT		: FOR KERNEL ACTIVITY		###GT
	J	BIDDRT,,
:	******;	EI	:KNRING

	SUBTTL	XHOSTS (KEROPS - Move KERNEL data out into network)

::*********************************************************************
::
::	SUBROUTINE:	KEROPS:
::	FUNCTION:	Process KERNEL data destined into network.
::	CALLING SEQ:	JAL	R10,KEROPS
::	CALLS:		JAL	R9,KFROOM
::			JAL	R9,KXROOM
::			JAL	R9,JBIDDY
::			J	KEROUT
::			JAL	R9,KXREC
::			JAL	R9,GOBBLN
::			JAL	R9,KCROOM
::			JAL	R9,ZAPHRD
::			JAL	R9,ZAPV
::
::*********************************************************************

KEROPS	HS	0
:	******;	IF	SIORNG
	LH	R0,SIRDLD		:SIO RING LOAD IN PROGRESS?
	JLR	R10			:YES - WAIT FOR LOAD TO COMPLETE
:	******;	EI	:SIORNG

	ST	R10,XHSVRT		:SAVE RETURN ADDRESS

:	******;	IF	KNRING
	IF	DB.DEB
	NEGTST(LH,R0,KCNTLI,-4,0,0)
	NEGTST(LH,R0,KCNTLI,-2,0,0)
	NEGTST(LH,R0,NEWLOG,-4,0,0)
	NEGTST(LH,R0,NEWLOG,-2,0,0)
	NEGTST(LH,R0,KOF,-4,0,0)
	NEGTST(LH,R0,KOF,-2,0,0)
	NEGTST(LH,R0,KCNTLO,-4,0,0)
	NEGTST(LH,R0,KCNTLO,-2,0,0)
	EI	:DB.DEB
:	******;	EI	:KNRING

:	******;	IF	SIORNG
	JAL	R9,SIRCIN		:GO CHECK FOR INTERRUPTS FROM SIO CARD
:	******;	EI	:SIORNG

:	******;	IF	KNRING
:	KOF IS A BIT ARRAY FOR KERNEL PORTS WITH OUTPUT DATA WAITING.
: 	FOR THE NEGATIVE RING IMPLEMENTATION, KOF IS PASSED AS A SEPARATE
: 	RING...OTHERWISE, IT IS A BIT ARRAY IN SHARED MEMORY SPACE.

	JAL	R9,KFROOM		:SEE IF KOF RING DATA AVAILABLE
	LIS	R0,0			:ASSUME NO NEW PORTS WITH DATA
	LR	LRC,LRC
	JEFS	KERO12			:KOF NOT UPDATED OR NO NEW DATA
	L	R0,KOF-4,PRD,		:GET NEW KOF ARRAY
	AIS	PRD,4			:UPDATE RING POINTER
	JLFS	KERO10
	LHI	PRD,-KOFSIZ		:NEGATIVE RING WRAP
KERO10	STH	PRD,KOF-2,,		:NEW RING TRAILING POINTER
KERO12	O	R0,KOFSAV		:INCLUDE AGED PORTS NOT SERVICED
	ST	R0,KOFSAV
	N	R0,KERBPX		:MASK OUT BP'ED PORTS

:	******;	ELSE	:NOT KNRING
	LIS	R4,0			:INIT TO FIRST FW OF RELEVANT ARRAYS
KERO12	L	R0,KOF,R4,		:PORTS W/ CHARS FOR BUFFERS

	IF	NKU-20
	JNFS	KERO10
	AIS	R4,4			:NEXT FW
	CLHI	R4,(NKU+7)/8
	JLBS	KERO12
	SIS	R4,4
	EI	:NKU-20

KERO10	STH	R4,KR4SAV
	N	R0,KERBPX,R4		:MASK OUT BP'ED PORTS
:	******;	EI	:(NOT)KNRING

:	******;	IF	IKERNL
	O	R0,KOFF,R4,		:UNLESS BP OVERRIDE
	IF	1-IKNRNG
	NI	R0,@(1^($A31-NKU))	:MASK OUT TTY PORT WE DON'T HANDLE
	EI	:1-IKNRNG
:	******;	EI	:IKERNL

	ST	R0,KERSVD
:	standard set up for jump to biddy		
	LI	R4,4			:###wjl
	LA	R3,KERSVD
	JAL	R9,JBIDDY
	J	KEROUT

	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR KRORET	###OAS
	CPUTNM(KRORET)			:DEFINE CPUTIL ENTRY FOR KRORET	###OAS
	EI	:DB.CPU

:	******;	IF	KNRING
:	EXAMINE THE KERNEL OUTPUT CONTROL RING BEFORE QUITTING. ZAPPERS,
: 	GOBBLERS, AND ACK'S FOR SAME ARE PASSED BY KERNEL THROUGH CONTROL RING.

	JAL	R9,KXROOM		:SEE IF ANY CONTROL DATA FROM KERNEL
KRXCRT	LR	LRC,LRC			:ANY DATA IN CONTROL RING?
	JE	KEROXT			:NO
	JAL	R9,KXREC		:GET NEXT CONTROL RECORD FROM RING
	LR	CHN,R1
	SRLS	CHN,8			:CHANNEL NUMBER IN UPPER BYTE
	LHL	R2,KIOTAB,CHN,CHN
	NHI	R2,-4			:ISOLATE BUFFER NUMBER
	JNFS	KRCX00
	J	KRXCRT			:UNASSIGNED CHAN, GET NEXT CONTROL REC
KRCX00	LBR	R1,R1			:ISOLATE CONDITION BYTE
	THI	R1,KR.ACK		:IS THIS AN ACK?
	JN	KRXC20			:YES
	CLHI	R1,KRCXMX		:NO - VALID CONTROL REC?
	JLFS	KRXC10			:YES
	CRASH.(.KRCXC)
KRXC10	LHL	R3,KRCXTB,R1,R1
	J	SEG1,R3,		:DISPATCH BASED ON CONTROL RECORD TYPE

KRXC20	SHI	R1,KR.ACK
	CLHI	R1,KRAXMX		:VALID ACK?
	JLFS	KRXC30			:YES
	CRASH.(.KRXCA)
KRXC30	LHL	R3,KRAXTB,R1,R1
	J	SEG1,R3,		:DISPATCH BASED ON ACK TYPE

:	GOBBLER FROM KERNEL
KXCGOB	JAL	R9,GOBBLN,,		:GOBBLE DATA
	LHI	R6,KR.GAK		:SET UP TO RETURN GOBBLER ACK

KXCGZA	HS	0			:SEND GOBBLER, ZAPPER ACK TO KERNEL
:	MAKE RING POINTERS EQUAL IN CASE GOBBLER, ZAPPER GOT AHEAD OF KOB DATA
	RBT	CHN,KOFSAV		:NO DATA IN KOB...
	LHL	KP,KBTBL,CHN,CHN	:GET KOB OFFSET FOR THIS CHANNEL
	LHL	R0,NIO,KP,
	STH	R0,NOO,KP,		:RING DATA GOBBLED...

:	RETURN GOBBLER, ZAPPER ACK TO KERNEL
	JAL	R9,KCROOM		:SETUP ACCESS OF CONTROL RING TO KERNEL
	LR	R0,CHN
	EXBR	R0,R0			:CHANNEL NUMBER IN UPPER HALF,
	OR	R0,R6			: CONTROL MESSAGE TYPE IN LOWER HALF
	STH	R0,KCNTLI-4,PRD,	:SEND GOBBLER ACK TO KERNEL
	AIS	PRD,2			:UPDATE RING INDEX
	JLFS	KXCG10
	LHI	PRD,-KCNTLS		:NEGATIVE RING WRAP
KXCG10	STH	PRD,KCNTLI-4,,		:UPDATE LEAD RING POINTER

	JAL	R9,KXROOM		:RESTORE REGISTERS FOR KCNTLO OPERATION

KXAGOB	RBT	CHN,KRGOBI		:FREE UP INBOUND CHANNEL
	J	KRXCRT			:GO LOOK FOR MORE WORK

:	ZAPPER FROM KERNEL
KXCZAP	RBT	CHN,KRZAPI		:WAS ZAPPER SENT TO KERNEL
	JNFS	KXCZ10			:YES, ZAPPERS MUST HAVE PASSED IN RINGS
	JAL	R9,ZAPHRD,,		:THAT'S ALL FOR THIS GUY
	JFS	KXCZ20
KXCZ10	XHI	R2,4
	JAL	R9,ZAPV,,		:ZAP SECOND HALF OF CIRCUIT
KXCZ20	LCS	R0,1
	AHM	R0,HNPORT		:DECREMENT NUMBER OF ACTIVE PORTS
	LHI	R6,KR.ZAK		:SET UP TO RETURN ZAPPER ACK
	J	KXCGZA

:	ZAPPER ACK FROM KERNEL
KXAZAP	RBT	CHN,KRZAPI		:BIT SET IF WE SENT ZAPPER TO KERNEL
	JNFS	KXAZ10			:VALID KERNEL RESPONSE
	IF	DB.DEB
	DBOOPS				:ZAPPER ACK, NO ZAPPER SENT
	ELSE	:NOT DB.DEB
	J	KRXCRT			:IGNORE IT
	EI	:DB.DEB
KXAZ10	XHI	R2,4
	JAL	R9,ZAPV,,		:ZAP SECOND HALF OF CIRCUIT
	LCS	R0,1
	AHM	R0,HNPORT		:DECREMENT NUMBER OF ACTIVE PORTS

:	MAKE RING POINTERS EQUAL IN CASE GOBBLER, ZAPPER GOT AHEAD OF KOB DATA
	RBT	CHN,KOFSAV		:NO DATA IN KOB...
	LHL	KP,KBTBL,CHN,CHN	:GET KOB OFFSET FOR THIS CHANNEL
	LHL	R0,NIO,KP,
	STH	R0,NOO,KP,		:RING DATA GOBBLED...

	J	KRXCRT			:GO LOOK FOR MORE WORK

:	NEWLOG ACK FROM KERNEL
KXANLG	RBT	CHN,NLOGCT		:DID WE SEND NEWLOG CONTROL TO KERNEL?
	JNFS	KXAN10			:YES
	IF	DB.DEB
	DBOOPS				 :UNEXPECTED NEWLOG ACK FROM KERNEL
	ELSE	:NOT DB.DEB
	J	KRXCRT			:IGNORE
	EI	:DB.DEB
KXAN10	SBT	CHN,NLOGOK		:CAN NOW PROCESS NEW LOGIN ON THIS PORT
	RBT	CHN,KRGOBI		:NO GOBBLERS, ZAPPERS OUTSTANDING
	RBT	CHN,KRZAPI
	LHL	KP,KBTBL,CHN,CHN
	LHL	R0,NIO,KP,		:MAKE KOB RING POINTERS EQUAL
	STH	R0,NOO,KP,
	J	KRXCRT

:	DISPATCH TABLES FOR KERNEL RING CONTROL MESSAGES
KRCXTB	HS	0
	HC	KXCZAP-SEG1		:ZAPPER FROM KERNEL
	HC	KXCGOB-SEG1		:GOBBLER FROM KERNEL
KRCXMX	EQ	(.-KRCXTB)/2		:MAX MESSAGE TYPE

KRAXTB	HS	0
	HC	KXAZAP-SEG1		:ZAPPER ACK FROM KERNEL
	HC	KXAGOB-SEG1		:GOBBLER ACK FROM KERNEL
	HC	KXANLG-SEG1		:NEWLOG ACK FROM KERNEL
KRAXMX	EQ	(.-KRAXTB)/2

:	******;	EI	:KNRING

KEROXT	J	XHRET

::*********************************************************************
::
::	SUB-PROCESS:	KEROUT
::	FUNCTION:	HANDLE KOB OUTPUT DATA
::	CALLING SEQ:	LA	R3,KERSVD	Dispatched based on data
::			JAL	R9,JBIDDY	being received on kernel
::			J	KEROUT		ports.
::	INPUT:		R2 = CHANNEL NUMBER
::	CALLS:		JAL	R8,WCI
::			JAL	R9,GOBBLE
::
::*********************************************************************

KEROUT	HS	0
	IF	DB.CPU
	LR	R4,R2			:SAVE R2
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR KEROUT	###OAS
	CPUTNM(KEROUT)			:DEFINE CPUTIL ENTRY FOR KEROUT	###OAS
	LR	R2,R4			:RECOVER R2
	EI	:DB.CPU

:	******; IF 1-KNRING
	IF	NKU-20
	LHL	R4,KR4SAV
	SLLS	R4,3			:R4 CONTAINED BYTE OFFSET TO KOF FW,
:					:NOW CONTAINS BIT OFFSET
	AR	R2,R4			:R2 NOW CONTAINS KERNEL PORT NUMBER
	EI	:NKU-20
:	******; EI	:1-KNRING

	LIS	TYC,3

:	******;	IF	1-(KNRING!IKNRNG)
	LHI	TC,KBSZ-1		:POWER OF 2 MASK FOR POSITIVE RINGS
:	******;	EI	:1-(KNRING!IKNRNG)

:	******; IF 1-KNRING
	RBT	R2,KOF,,		:THIS PORT SERVICED
:	******; EI	:1-KNRING

:	******;	IF	IKERNL
	RBT	R2,KOFF,,
:	******;	EI	:(PREVENT LOOPS)

	LR	CHN,2			:2*PORT #

:	******; IF IKNRNG
	LR	KP,CHN
:	******; EI	:IKNRNG

:	******;	IF	RKERNL		:REAL KERNEL HAS HW PTRS
	AR	CHN,CHN
:	******;	EI	:RKERNL

	JAL	R9,KOROOM		:COMPUTE # OF CHARACTERS IN RING BUFFER
	LR	LRC,LRC
	JE	BIDDRT,,		:NO DATA - RETURN

:	******;	IF	KNRING
	RBT	R2,KOFSAV		:WE'VE GOT DATA, MARK PORT SERVICED
:	******;	EI	:KNRING

:	******;	IF	RKERNL
	LHL	R2,KIOTAB,CHN,		:GET CHAR BUFF #

:	******;	ELSE	:NOT RKERNL
	LHL	R2,KIOTAB,CHN,CHN
:	******;	EI	:(NOT) RKERNL

	NHI	R2,-4
	JNFS	KERO3

:	******;	IF	RKERNL

:		******;	IF	KNRING
:	MAKE RING POINTERS EQUAL SO WE DON'T THRASH ABOUT HERE
	LHL	R0,NIO,KP,
	STH	R0,NOO,KP,		:SET AS IF NO WORK TO DO...
:		******;	ELSE	:NOT KNRING
	LHL	R0,NIO,CHN,		:NO CIRCUIT, IGNORE EVERYTHING
	STH	R0,NOO,CHN,
:		******;	EI	:KNRING

:	******;	ELSE	:NOT RKERNL
:		******;	IF	IKNRNG	:AND IF NOT RKERNL
	LHL	R0,NIO,KP,
	STH	R0,NOO,KP,
	ELSE	:NOT IKNRNG
	LB	R0,NIO,CHN,
	STB	R0,NOO,CHN,
:		******;	EI	:(NOT)IKNRNG
:	******;	EI	:(NOT)RKERNL

	J	BIDDRT,,
KERO3	LR	CD,LRC			:# CHARS TO MOVE

:	******;	IF	1-(KNRING!IKNRNG)
	NR	PRD,TC			:TRUNCATE PTR
:	******;	EI	:1-(KNRING!IKNRNG)

KERO2	LB	R1,KOB,KP,PRD		:GET CHAR
KERO4	AIS	PRD,1

:	******;	IF	KNRING!IKNRNG
	JLFS	KERO42
	SHI	PRD,KBSZ		:NEGATIVE RING WRAP
:	******;	ELSE	:NOT KNRING!IKNRNG
	NR	PRD,TC			:INDEX PTR
:	******;	EI	:KNRING!IKNRNG

KERO42	JAL	R8,WCI			:PUT CHARACTER FROM KERNEL INTO BUFFER
	CR	R1,TYC
	JGFS	KERO6			:TYMNET CONTROL TEST
	J	KEOTYM
KERO6	SIS	CD,1
	JGBS	KERO2
	AM	LRC,KEROCC		:CNT OF CHARS OUT OF KERNEL
        if      rkernl
        am      lrc,keroct,chn,chn
        else    :not rkernl
        ar      chn,chn
        am      lrc,keroct,chn,chn      :char cnt per port      ###sdw
        srls    chn,1
        ei      :rkerrnl

KERO5	HS	0
:	******;	IF	IKERNL		:UPDATE THE POINTER

:		******;	IF	IKNRNG
	STH	PRD,NOO,KP,
:		******;	ELSE	:NOT IKNRNG
	STB	PRD,NOO,CHN,
:		******;	EI	:(NOT) IKNRNG

:	******;	ELSE	:NOT IKERNL

:		******;	IF	KNRING
	AH	LRC,NOO,KP,		:UPDATE RING TRAILING POINTER
	JLFS	KERO52
	SHI	LRC,KBSZ		:NEGATIVE RING WRAP
KERO52	STH	LRC,NOO,KP,		:STORE TRAIL POINTER AWAY
:		******;	ELSE	:NOT KNRING
	AHM	LRC,NOO,CHN,
:		******;	EI	:KNRING

	SRLS	CHN,1			:ACTUAL CHANNEL NUMBER

:	******;	EI	:(NOT)IKERNL

	IF	INTACC		:###EV
	LHI	R3,KERZFL
	AR	R3,CHN			:make port index into real chn #
	SHI	R3,MNACHN		:Make accounting port index
	LR	R0,LRC			:Set up count
	JAL	R8,AARDOC,,		: and accumulate output characters
	GL	AARDOC
	EI	:INTACC		###EV
	LHL	R3,BCT,R2,		:SET BACKPRESSURE IF BUFFER FULL
	LIS	R1,3
	NH	R1,KIOTAB,CHN,CHN
	CLH	R3,CIRSPK,R1,R1
	JL	BIDDRT,,
	RBT	CHN,KERBPX,,
	J	BIDDRT,,

:	******;	IF	RKERNL		:NORMAL STUFF

:		******;	IF	1-KNRING
KEOTYM	JE	KEOT03			:03-TYPE PAIR?
:		******;	ELSE	:NOT 1-KNRING
KEOTYM	HS	0
:	NO NEED TO TEST FOR ZAPPERS OR GOBBLERS SINCE THEY TRAVEL
:	IN CONTROL RING...
:		******;	EI	:(NOT)1-KNRING

:	******;	ELSE	:NOT RKERNL
KEOTYM	JE	KEOZAP			:03 IS ZAPPER
	CLHI	R1,2
	JE	KEOGO1			:02 IS GOBBLER
:	******;	EI	:(NOT)RKERNL
	LB	R1,KOB,KP,PRD		:00,01,02 CHAR PAIR
KEOTY1	SIS	CD,1			:JUST PASS IT ON
	OHI	R1,100
	J	KERO4

:	******;	IF	1-KNRING
KEOT03	LB	R1,KOB,KP,PRD		:03-TYPE PAIR
	AIS	PRD,1
:		******;	IF	IKNRNG	:AND IF NOT KNRING
	JLFS	KEOT3A
	AHI	PRD,-KBSZ
:		******;	ELSE	:NOT IKNRNG
	NR 	PRD,TC
:		******;	EI	:(NOT)IKNRNG

KEOT3A	CLHI	R1,GOBBL&0FF
	JE	KEOGOB
KEOZAP	JAL	R9,ZAPHRD,,		:ZAPPER
	IF	INTACC		:###EV
	LHI	R3,KERZFL
	AR	R3,CHN			:Make port index into real chan #
	SHI	R3,MNACHN		:Make accounting port index
	LI	R0,AALR02		:Normal disconnect from Kernel
	JAL	R8,AARLO,,		:Perform final accounting
	GL	AARLO
	EI	:INTACC		###EV
	SHI	LRC,-2,CD		:TERMINATE THE MESSAGE HERE
	LCS	R0,1			:ONE LESS LOGON
	AHM	R0,HNPORT

:		******;	IF	IKERNL

:			******;	IF	IKNRNG
	LHL	R0,NII,KP,
	STH	R0,NOI,KP,
:			******;	ELSE	:NOT IKNRNG
	LB	R0,NII,CHN,		:ISIS WANTS POINTERS EQUAL
	STB	R0,NOI,CHN,
	STB	R0,NMI,CHN,
:			******;	EI	:(NOT)IKNRNG

:		******;	EI	:IKERNL
	J	KERO5

KEOGOB	SIS	CD,1			:GOBBLER
KEOGO1	JAL	R9,GOBBLE,,		:GOBBLER  -- ***NOTE!! GOBBLE IS CALLED
	GL	GOBBLE			: INSTEAD OF GOBBLN HERE BECAUSE IT
					: SEEMS UNLIKELY THAT NEEDLES OR SQFIXS
					: WILL BE GOBBLED BY THE KERNEL HOST.
	J	KERO6
:	******;	EI	:1-KNRING

	SUBTTL	XHOSTS (Kernel utility routines)

:	THE FOLLOWING SUBROUTINES ARE FOR HANDLING THE NEGATIVE INDEXED
: 	FORMAT FOR THE KERNEL INTERFACE RINGS. THERE ARE 6 RINGS:
:
:	KIB - DATA RING, NODE-->KERNEL
:		NII LEAD POINTER, NODE INDEXED
:		NOI TRAIL POINTER, KERNEL INDEXED
:
:	KOB - DATA RING, KERNEL-->NODE
:		NIO LEAD POINTER, KERNEL INDEXED
:		NOO TRAIL POINTER, NODE INDEXED
:
:	NEWLOG - PASS PORT NUMBERS OF NEW LOGINS, NODE-->KERNEL
:		NEWLOG-4 LEAD POINTER, NODE INDEXED
:		NEWLOG-2 TRAIL POINTER, KERNEL INDEXED
:
:	KOF - BIT ARRAY INDICATING DATA AVAILABLE, KERNEL-->NODE
:		KOF-4 LEAD POINTER, KERNEL INDEXED
:		KOF-2 TRAIL POINTER, NODE INDEXED
:
:	KCNTLI - CONTROL RING FOR GOBBLERS AND ZAPPERS, NODE-->KERNEL
:		KCNTLI-4 LEAD POINTER, NODE INDEXED
:		KCNTLI-2 TRAIL POINTER, KERNEL INDEXED
:
:	KCNTLO - CONTROL RING FOR GOBBLERS AND ZAPPERS, KERNEL-->NODE
:		KCNTLO-4 LEAD POINTER, KERNEL INDEXED
:		KCNTLO-2 TRAIL POINTER, NODE INDEXED
:

:	THE 'ROOM' SUBROUTINES DETERMINE THE SPACE AVAIABLE FOR INPUT
: 	RINGS (NODE-->KERNEL), OR COMPUTE THE AMOUNT OF DATA WAITING FOR
: 	OUTPUT RINGS (KERNEL-->NODE). ALL SUBS LINK ON R9, RETURN PRD AS THE
: 	NODE'S RING INDEX, AND LRC AS THE LENGTH. THE DATA RING ROUTINES LOAD
: 	R7 WITH THE RELATIVE DISPLACEMENT OF THE RING FOR THE CHAN OF INTEREST.

::*********************************************************************
::
::	SUBROUTINE:	KIROOM:
::	FUNCTION:	COMPUTE SPACE AVAILABLE IN INPUT RING.
::	CALLING SEQ:	JAL	R9,KIROOM
::	INPUT:		KP  = R7 = CHANNEL NUMBER
::			CHN = R5 = CHANNEL NUMBER TIMES 2 FOR SOLO.
::
::*********************************************************************

KIROOM	HS	0
:	******;	IF	KNRING!IKNRNG

:		******;	IF	KNRING
:	ZAPPERS AND GOBBLERS ARE PASSED IN THE CONTROL RING, AND WILL BE
: 	ACK'D BY KERNEL. WHILE WAITING ON ACK, DON'T FILL RING.
	TBT	KP,KRGOBI		:GOBBLER IN TO KERNEL?
	JN	BIDDRT,,		:YES - WAITING FOR ACK
	LHL	KP,KBTBL,CHN,		:GET PORT RING DISPLACEMENT
:		******;	ELSE	:IKNRNG
	SLLS	KP,2			:FW INDEX
	L	KP,KPRMAP,KP		:PORT RING DISPLACEMENT
:		******; EI	:KNRING!IKNRNG

	LH	PRD,NII,KP,		:NODE INDEX
	NEGTST(NOP,,NII,0,)
	LH	LRC,NOI,KP,		:KERNEL INDEX
	NEGTST(NOP,,NOI,0)
	IF	DB.DEB&KNRING
	STH	PRD,KRNRPS		:SAVE USEFUL VALUES
	STH	LRC,KRNLRS
	EI	:DB.DEB&KNRING
	SHI	LRC,2,PRD		:COMPUTE SPACE LEFT IN RING
	JGER	R9
	AHI	LRC,KBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

:	******;	ELSE	:NOT KNRING!IKNRNG
	SLLS	KP,KBSZL		:COMPUTE OFFSET TO THIS PORT'S RING
	LB	PRD,NII+KQ,CHN,		:NODE INDEX
	LB	LRC,NOI+KQ,CHN,		:KERNEL INDEX

:		******;	IF	ISIS
	SR	LRC,PRD			:COMPUTE SPACE LEFT IN RING
	JGR	R9
	AHI	LRC,KBSZ		:ADJUST FOR RING WRAP
:		******;	ELSE	:NOT ISIS, POSITIVE RING INDEX (OLD STYLE)
	SHI	LRC,KBSZ,PRD		:COMPUTE SPACE LEFT IN RING AND
	NHI	LRC,KBST		: MASK
:		******;	EI	:(NOT)ISIS

	JR	R9			:RETURN
:	******;	EI	:(NOT)KNRING!IKNRNG

::*********************************************************************
::
::	SUBROUTINE:	KOROOM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA IN RING BOUND FOR NETWORK.
::	CALLING SEQ:	JAL	R9,KOROOM
::	INPUT:		R2  = CHANNEL NUMBER
::			CHN = R5 = CHANNEL NUMBER TIMES 2 FOR SOLO
::
::*********************************************************************

KOROOM	HS	0
:	******;	IF	KNRING!IKNRNG

:		******;	IF	KNRING
	LHL	KP,KBTBL,CHN,		:RING OFSET FOR THIS CHANNEL
:		******;	ELSE	:NOT KNRING
	SLLS	KP,2
	L	KP,KPRMAP,KP,
:		******;	EI	:(NOT)KNRING

	LH	PRD,NOO,KP,		:NODE INDEX
	NEGTST(NOP,,NOO,0)
	LH	LRC,NIO,KP,		:KERNEL INDEX
	NEGTST(NOP,,NIO,0)
	SR	LRC,PRD			:COMPUTE AMOUNT OF DATA IN RING
	JGER	R9
	AHI	LRC,KBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

:	******;	ELSE	:NOT KNRING!IKNRNG
	LR	KP,R2
	SLLS	KP,KBSZL		:RING OFFSET FOR THIS CHANNEL
	LB	PRD,NOO+KQ,CHN,		:NODE INDEX
	LB	LRC,NIO+KQ,CHN,		:KERNEL INDEX
	SR	LRC,PRD			:COMPUTE AMOUNT OF DATA IN RING
	NHI	LRC,KBST
	JR	R9			:RETURN
:	******;	EI	:(NOT)KNRING!IKNRNG

:	******;	IF	KNRING
:*FOLLOWING ROUTINES APPLY ONLY TO NEGATIVE INDEX KERNEL INTERFACE RING FORMAT*

::*********************************************************************
::
::	SUBROUTINE:	KCROOM:
::	FUNCTION:	COMPUTE SPACE AVAILABLE IN KCNTLI RING.
::	CALLING SEQ:	JAL	R9,KCROOM
::
::*********************************************************************

KCROOM	HS	0
	LH	PRD,KCNTLI-4,,		:NODE INDEX
	NEGTST(NOP,,KCNTLI,0)
	LH	LRC,KCNTLI-2,,		:KERNEL INDEX
	NEGTST(NOP,,KCNTLI,0)
	SHI	LRC,2,PRD		:COMPUTE SPACE AVAILABLE
	JGER	R9
	AHI	LRC,KCNTLS		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	KLROOM:
::	FUNCTION:	COMPUTE SPACE AVAILABLE IN NEWLOG RING
::	CALLING SEQ:	JAL	R9,KLROOM
::
::*********************************************************************

KLROOM	HS	0
	LH	PRD,NEWLOG-4,,		:NODE INDEX
	NEGTST(NOP,,NEWLOG,0)
	LH	LRC,NEWLOG-2,,		:KERNEL INDEX
	NEGTST(NOP,,NEWLOG,0)
	SHI	LRC,2,PRD		:COMPUTE SPACE AVAILABLE
	JGER	R9
	AHI	LRC,NLOGSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	KFROOM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA IN KOF RING.
::	CALLING SEQ:	JAL	R9,KFROOM
::
::*********************************************************************

KFROOM	HS	0
	LH	PRD,KOF-2,,		:NODE INDEX
	NEGTST(NOP,,KOF,0)
	LH	LRC,KOF-4,,		:KERNEL INDEX
	NEGTST(NOP,,KOF,0)
	SR	LRC,PRD			:COMPUTE AMOUNT OF DATA WAITING
	JGER	R9
	AHI	LRC,KOFSIZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	KXROOM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA IN KCNTLO RING
::	CALLING SEQ:	JAL	R9,KXROOM
::
::*********************************************************************

KXROOM	HS	0
	LH	PRD,KCNTLO-2,,		:NODE INDEX
	NEGTST(NOP,,KCNTLO,0)
	LH	LRC,KCNTLO-4,,		:KERNEL INDEX
	NEGTST(NOP,,KCNTLO,0)
	SR	LRC,PRD			:COMPUTE AMOUNT OF DATA WAITING
	JGER	R9
	AHI	LRC,KCNTLS		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	KXREC:
::	FUNCTION:	GET NEXT RECORD FROM KERNEL CONTROL RING
::	CALLING SEQ:	JAL	R9,KXREC
::
::*********************************************************************

KXREC	HS	0
	SIS	LRC,2			:DECREMENT NUMBER OF BYTES IN RING
	LHL	R1,KCNTLO-4,PRD,	:GET NEXT HALFWORD FROM RING
	AIS	PRD,2			:INCREMENT RING POINTER
	JLFS	KXRC10
	LHI	PRD,-KCNTLS		:NEGATIVE RING WRAP
KXRC10	STH	PRD,KCNTLO-2,,		:UPDATE TRAIL POINTER
	JR	R9			:RETURN

	SUBTTL	XHOSTS (SIRCMD, SIRCIN, SIRSCK - SIORNG utility routines)

:			******SIORING******
	IF	SIORNG

::*********************************************************************
::
::	SUBROUTINE:	SIRCMD:
::	FUNCTION:	SEND COMMAND TO SIO CARD
::	CALLING SEQ:	JAL	R9,SIRCMD
::	INPUT:		R0 = COMMAND
::			R1 = QUADWORD ADDRESS (FOR ACTIVATE RING PAIR COMMANDS)
::	DESTROYED:	R2, R3, AND R8
::	CALLS:		ISSUE SVC TO SIO CARD - NORMAL RETURN IF
::			COMMAND PROCESSED, ELSE SKIP RETURN DUE TO SIO
::			CARD BUSY. IF WE GET CONSECUTIVE SKIP-RETURNS
::			FOR 100 FASTC TICKS, SEND CRYPTOGRAM.
::	RETURNS:	NORMAL RETURN IF SIO CARD TIMES OUT
::			SKIP RETURN FOR SVC O.K.
::
::*********************************************************************

SIRCMD	HS	0
	L	R2,FASTC,,		:GET TIME ENTERED
SIRC10	SVC	0F,SV.SIR		:ISSUE SVC TO SIO RING CARD
	J	4,R9			:O.K. - SKIP RETURN
	L	R3,FASTC,,
	SR	R3,R2			:TIME SINCE FIRST SVC ISSUED
	CLHI	R3,100			:SIO BUSY FOR 100 FASTC TICKS?
	JLBS	SIRC10			:NO - TRY AGAIN
	JAL	R8,CRYPTO,,		:SEND CRYPTOGRAM FOR SIO BOARD BUSY,
	HC	CRYE3A			: R0 HAS COMMAND...
	JR	R9			:NORMAL RETURN

::*********************************************************************
::
::	SUBROUTINE:	SIRCIN:
::	FUNCTION:	CHECK FOR ANY INTERRUPTS FROM SIO RING CARD
::	CALLING SEQ:	JAL	R9,SIRCIN
::	DESTROYED:	R0, R1, R3, R4, AND R8.
::	CALLS:		JAL	R8,CRYPTO
::
::*********************************************************************

:	INTERRUPT STATUS HALFWORDS ARE STORED IN SIRX, SO MULTIPLE
:	INTERRUPTS BETWEEN CHECKS CAN BE DETECTED. SEND CRYPTOGRAM FOR
:	EACH INTERRUPT, AND TEST FOR SPECIAL UP/DOWN CONDITIONS TO SET SIRFLG.

SIRCIN	HS	0
	LH	R3,SIRI,,		:INTERRUPT INDEXED IN POINTER
	LH	R4,SIRO,,		:OUT POINTER
	SR	R3,R4
	NHI	R3,SIRXSZ-1		:AMOUNT OF DATA IN RING
	JER	R9			:RING EMPTY
SIRCI2	LHL	R0,SIRX,R4,		:GET INTERRUPT STATUS AND
	JAL	R8,CRYPTO,,		: SEND CRYPTOGRAM
	HC	CRYE3B			:(SIO RING CARD INTERRUPT)
:	IF STATUS IS 'UP' OR 'DOWN', SET SIRFLG APPROPRIATELY
	SRLS	R0,8			:ISOLATE STATUS
	LIS	R1,0
	CLHI	R0,SIRDWN		:SIO CARD DOWN?
	JEFS	SIRCI4			:YES
	LHI	R1,STSRM0
	CLHI	R0,SIRRM0		:RING PAIR MISMATCH FOR RING 0?
	JEFS	SIRCI4			:YES
	CLHI	R0,SIRUP		:SIO CARD UP?
	JNFS	SIRCI6			:NO - SOME OTHER INFORMATION
	LCS	R1,1
SIRCI4	STH	R1,SIRFLG		:INDICATE UP/DOWN - 0 = DOWN, -1 = UP
SIRCI6	AIS	R4,2
	NHI	R4,SIRXSZ-1		:ADVANCE BACKGROUND RING POINTER
	SIS	R3,2			:MORE DATA IN RING?
	JG	SIRCI2			:YES
	STH	R4,SIRO,,		:NO - STORE OUT POINTER AND
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SIRSCK:
::	FUNCTION:	STATUS CHECK OF SIO INTERFACE
::	CALLING SEQ:	JAL	R10,SIRSCK
::	CALLS:		JAL	R8,CRYPTO
::			JAL	R10,SUP11
::			JAL	R10,SCQZAP
::			JAL	R10,KCQDET
::			JAL	R10,IZKNRG
::			JAL	R10,IZSUP
::			JAL	R10,IZSIRG
::
::*********************************************************************

::	IF SIO RING INTERFACE NOT ALIVE, REPORT KERNEL HOST SHUT.
::	COMPARE TO LAST STATUS REPORTED TO PREVENT REDUNDANT HOST
::	STATUS REPORTS TO SUPERVISOR.

SIRSCK	HS	0
	LHL	R2,TVRBUF		:IS THERE A COMMAND CIRCUIT?
	JER	R10			:NO - RETURN
	LH	R1,SIRFLG		:GET SIO RING STATUS
	JNFS	SIRH10			:SIO RING UP OR AWAITING LOAD
	LIS	R0,2			:SIO RING DEAD, HOST SHUT STATUS IN R0
	JFS	SIRH20
SIRH10	LIS	R0,0			:HOST ANSWERED STATUS
SIRH20	CLB	R0,HSTAT		:SAME STATUS AS BEFORE?
	JER	R10			:YES - MAKE NO REPORT
	ST	R10,SIRCSV		:SAVE LINK
	STB	R0,HSTAT		:SAVE NEW STATUS

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)			###GT
	LR	R2,R0			:PRESERVE R0			###GT
	SLLS	R2,6			:SHIFT BITS 6,7 TO BITS 0,1	###GT
	LB	R1,HSTATN		:AND OR INTO HSTATN		###GT
	NHI	R1,003F			:STRIP OFF BITS 0 AND 1		###GT
	OR	R1,R2			:NOW ADD STATUS BITS		###GT
	STB	R1,HSTATN		:				###GT

	LHI	R8,HST0
	STH	R8,CRYSBF+2		:STORE HOST NUMBER FOR XRAY
	JAL	R8,CRYPTO,,		:HOST STATUS CRYPTOGRAM
	HC	CRYE15
	LIS	HN,0			:HOST ZERO IS KERNEL HOST
	JAL	R10,SUP11,,		:SEND HOST STATUS REPORT TO SUP
	LB	R0,HSTAT		:HOST STATUS CHANGED - ARE WE ANSWERED?
	JEFS	SIRH30			:YES
:	SIO RING JUST WENT DOWN. ZAP CIRCUITS TO SUP, KERNEL INTERFACE AND
: 	RE-INITIALIZE EVERYTHING.
	JAL	R10,SCQZAP		:ZAP SUP CIRCUITS
	JAL	R10,KCQDET		:DETACH KERNEL CIRCUITS
	JAL	R10,IZKNRG		:INITIALIZE KERNEL RINGS
	JAL	R10,IZSUP		:INITIALIZE SUP RINGS
	JAL	R10,IZSIRG		:ATTEMPT TO REVIVE SIO RING
SIRH30	L	R10,SIRCSV		:RESTORE LINK AND
	JR	R10			: RETURN

:		******END***
	EI	:SIORNG

:	******END***
	EI	:KNRING

:******; EI	:KERNEL

	SUBTTL	XHOSTS (SUPIN - Moves network data into supervisor)

:	1 - Data ring data format (SIB/SOB)
:
:	  A - Sup port data of the form
:
:	    2 bytes Channel Number, 2 bytes Data Byte Count, N bytes Data
:
:	  B - Special case channel number zero
:
:	    Input to Supervisor
:	    2 bytes 0, 2 bytes 0002, 2 bytes Channel Number to be Zapped
:	    2 bytes 0, 2 bytes 0002, 2 bytes Sup # + 8000 - Sleeping Pill
:
:	    Output by Supervisor
:	    2 bytes 0, 2 bytes 0002, 2 bytes Chan # + 8000 to be Zapped
:	    2 bytes 0, 2 bytes 0002, 2 bytes w/o 8000 bit set - Going to Sleep
:
:	  C - Special case channel number one, to Sup only, indicating
:	    control character(s) other than zapper found going to Sup
:
:	    2 bytes 1,
:	    2 bytes of Byte Count,
:	    2 bytes Message Type + 0880 where Message Type
:	        0 = Black Ball
:	        1 = Gobbler
:	        2 = Other Invalid Pair or Unpaired Control Character,
:	    2 bytes Offending Channel Number,
:	    2 bytes Invalid Pair (if present)
:
:	2 - Control ring data format (SIC/SOC)
:
:	    Output by Supervisor
:	    2 bytes Status Code
:	    	FFFF - Sup Sleeping
:	    	0001 - Sup Awake
:
:	    Input to Supervisor
:	    2 bytes Sup Port Zero Offset to Node Code Absolute Channel 0,
:	    2 bytes Node Number + 8000
:
:	3 - Backpressure control ring data format (SIBP/SOBP)
:
:	    2 bytes Channel Number - Relieve Backpressure
:	    2 bytes Channel Number + 8000 - Apply Backpressure

::*********************************************************************
::
::	SUBROUTINE:	SUPIN:
::	FUNCTION:	Moves characters into the sup input data ring (SIB)
::	CALLING SEQ:	JAL	R10,SUPIN
::	CALLS:		JAL	R9,SIROOM
::			JAL	R8,BID
::			JAL	R8,CBCCT
::			JAL	R8,GCLAST
::			JAL	R8,GCRET
::			JAL	R0,EXYLD
::			JAL	R8,GCI
::			JAL	R8,CBCLR
::			JAL	R9,ZAPV
::
::*********************************************************************

	IF	SUPER

SUPIN	HS	0
	ST	R10,XHSVRT		:SAVE RETURN

	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR SUPIN
	CPUTNM(SUPIN )			:DEFINE CPUTIL ENTRY FOR SUPIN
	EI	:DB.CPU

SUPGRP	HS	0			:###wjl
	LIS	R7,0			:DISPLACEMENT OF SUP ATTN FLAGS
	LIS	R4,0			:BASE PORT # FOR THIS GROUP
SUINXT	L	R1,SUPFLG,R7,		:GET NEXT FLAG GROUP
	N	R1,SUPBPV,R7,		:AND BACK PRESS FLAGS
	N	R1,SUPSVD,R7		:AND PORT SERVICED FLAGS
	JN	SUPI20
	AIS	R7,4			:NOTHING IN THIS GROUP
	AHI	R4,20
	CLHI	R4,NSP
	JL	SUINXT

	LIS	R2,0			:RESTORE SUPSVD AND GO ROUND AGAIN
	LIS	R7,0
	LCS	R0,1
SUPI10	ST	R0,SUPSVD,R7
	L	R1,SUPFLG,R7,
	N	R1,SUPBPV,R7,
	OR	R2,R1
	AIS	R7,4
	CLHI	R7,NSP/8
	JL	SUPI10
	LR	R2,R2			:IF 0, NOTHING TO DO
	JN	SUPGRP
SUPINX	J	XHRET			:return

:	service this port
SUPI20	HS	0
	JAL	R9,SIROOM		:ANY ROOM IN SIB RING?
	CLHI	PRC,8			:NEED AT LEAST 8 BYTES
	JLE	SUPINX			:DISMISS FROM SUPIN
	JAL	R8,BID,,		:GET THE PORT #
	LR	CHN,R2			:COMPUTE 2*PORT #
	AR	CHN,R4
	RBT	CHN,SUPSVD		:THIS PORT SERVICED
	LHL	R2,SIOTAB,CHN,CHN	:CORRESPONDING BUFFER #
	NHI	R2,-4			:STRIP SPEED BITS
	JNFS	SUPI30
	CRASH.(.SUPIC)
SUPI30	XHI	R2,4			:DATA IS IN COMP BUFFER
	JAL	R8,CBCCT		:# OF CHARS IN BUFFER
	LHI	LRC,-6,PRC		:# OF CHARS THAT MAY BE MOVED IN
	CR	R1,LRC			:COMPUTE LEAST OF ABOVE
	JGEFS	SUPI32
	LR	LRC,R1			:LRC HAS IT
SUPI32	LHI	R1,200			:MOVE ONLY THESE AT ONE TIME
	CR	R1,LRC
	JGEFS	SUPI34
	LR	LRC,R1
SUPI34	LR	CD,LRC			:# OF CHARS TO MOVE
	JNFS	SUPI36
	CRASH.(.SUPI0)
SUPI36	IF	SNRING
	LR	R11,PRD			:SAVE POINTER TO RECORD HEADER
	AIS	PRD,4			:INDEX PRD TO START OF DATA
	JLFS	SUPI38
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	AIS	PRD,4			:INDEX PRD TO START OF DATA
	NR	PRD,TC
	EI	:SNRING

:	why don't we use the GCI instruction???jhl
SUPI38	HS	0
	L	R3,BB,R2,		:SET UP BUFFER BEGIN ADDRESS
	JNFS	SUPI40
	CRASH.(.SUPI1)
SUPI40	LB	R1,0,R3			:MOVE CHARS
	CL	R3,BE,R2,
	JNFS	SUPI50
	JAL	R8,GCLAST
	LIS	R3,0
	JFS	SUPI60
SUPI50	AIS	R3,1
	THI	R3,CBSZ-1
	JNFS 	SUPI60
	JAL	R8,GCRET
	L	R3,BB,R2,
:	end of what would be GCI call.

SUPI60	CLHI	R1,3			:test for TYMNET control pairs
	JGFS	SUPI70			:greater than 3 is data
	J	SUITYM			:jump to control pair handler
SUPI70	STB	R1,SIB,PRD,		:here for data character handler
	AIS	PRD,1
	IF	SNRING
	JLFS	SUPI72
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC			:POWER OF 2 MASK
	EI	:SNRING
SUPI72	HS	0
	SIS	CD,1
	JG	SUPI40
	ST	R3,BB,R2,

SUPI80	IF	SNRING			:INSERT CHAN # AND ACTUAL BYTE COUNT
	LR	R1,R11			:RESTORE POINTER TO LOGICAL REC HEADER
	ELSE	:NOT SNRING
	LR	R1,PRD			:COMPUTE POINTER TO LOGICAL REC HEADER
	SHI	R1,4,LRC		:POINTS TO CHAN SLOT
	NR	R1,TC
	EI	:SNRING
	STH	CHN,SIB,R1,		:STORE CHANNEL NUMBER
	AIS	R1,2
	IF	SNRING
	JLFS	SUPI82
	SHI	R1,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	R1,TC
	EI	:SNRING
SUPI82	HS	0
	STH	LRC,SIB,R1,		:STORE LOGICAL RECORD COUNT
        ar      r5,r5                   :2*chn #
        am      lrc,supcpi,r5,r5         :save cps to supe per port
        srls    r5,1                    :restore chn
	AM	LRC,SUPICC		:COUNT OF CHARS INTO SUP

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	TBT	CHN,SRNTRE,,		:IS THIS CHANNEL ENABLED FOR TRACE ?
	JE	SRNA03			:NO

SRNA02	ST	R1,SRNSAV,,		:SAVE R1
	ST	R2,SRNSAV+4,,		:AND R2
	LR	R1,R11			:BEGINNING OF RECORD IN RING
	AIS	R1,6			:POINT TO MESSAGE TYPE BYTE
	JLFS	SRNA0B			:SUP NEG RING NOT WRAPPED
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNA0B	LB	R0,SIB,R1,		:GET MESSAGE TYPE
	TBT	R0,SRNICK,,		:CHECK IF THIS MESSAGE IS DESIRED
	JN	SRNA04			:MESSAGE NOT DESIRED
	LR	R1,R11			:POINT TO BEG OF RECORD DATA
	AIS	R1,4			:SKIP PAST CHAN AND COUNT
	JLFS	SRNA0C			:SUP NEG RING NOT WRAPPED
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNA0C	LHL	R2,SRNTRX,,		:NEXT ENTRY IN TRACE TABLE
SRNA05	LB	R0,SIB,R1,		:GET DATA FROM RING
	STB	R0,SRNTBL,R2,		:AND ENTER INTO TRACE TABLE
	AIS	R2,1			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNA06			:NO
	LIS	R2,0			:WRAP
SRNA06	AIS	R1,1			:BUMP RING INDEX
	JLFS	SRNA07			:NO NEGATIVE WRAP
	SHI	R1,SUPBSZ		:NEG RING WRAP
SRNA07	CR	R1,PRD			:END OF RECORD?
	JL	SRNA05			:NO
	THI	R2,0001			:ODD TRACE TABLE INDEX ?
	JEFS	SRNA08			:NO
	LIS	R0,0
	STB	R0,SRNTBL,R2,		:CLEAR PAD BYTE
	AIS	R2,1			:ENFORCE EVEN TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNA08			:NO
	LIS	R2,0			:WRAP
SRNA08	LR	R1,R11			:POINT TO BEGIN OF RECORD IN SUP RING
	AIS	R1,2			:POINT TO LRC
	JLFS	SRNA0D			:NO SUP NEG RING WRAP
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNA0D	LHL	R0,SIB,R1,		:GET LRC FROM RING
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNA09			:NO
	LIS	R2,0			:WRAP
SRNA09	LHL	R0,FASTC+2,,		:GET FASTC MARK
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNA0A			:NO
	LIS	R2,0			:WRAP
SRNA0A	LHL	R0,SIB,R11,		:GET CHAN # FROM RING
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNA10			:NO
	LIS	R2,0			:WRAP
SRNA10	STH	R2,SRNTRX,,		:UPDATE TRACE TABLE INDEX
SRNA04	L	R1,SRNSAV,,		:RECOVER R1
	L	R2,SRNSAV+4,,		:RECOVER R2

SRNA03	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	THI	LRC,1			:ADD ZERO PAD IF ODD LRC
	JEFS	SUPI90
	LIS	R1,0
	STB	R1,SIB,PRD,
	AIS	PRD,1
	IF	SNRING
	JLFS	SUPI84
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUPI84	HS	0
	AIS	LRC,1

SUPI90	AIS	LRC,4			:TOTAL # OF CHARS INSERTED
	IF	SNRING
	AH	LRC,NISI,,		:INCREMENT SIB LEAD POINTER
	JLFS	SUPI92
	SHI	LRC,SUPBSZ		:NEGATIVE RING WRAP
SUPI92	STH	LRC,NISI,,		:UPDATE POINTER, DONE WITH LOGICAL REC
	ELSE	:NOT SNRING
	AHM	LRC,NISI,,		:UPDATE THE LEAD POINTER FOR SIB
	EI	:SNRING

	JAL	R0,EXYLD,,		:ALL DONE, YIELD BETWEEN TRANSFERS
	J	SUPGRP

:	control pair handler
SUITYM	HS	0
	JE	SUICTL			:IF 03 DETECTED - TEST FOR ZAPPER
	LR	R1,R1			:NOT 03 - IS IT AN ESCAPE?
	JN	SUIINV			:NO - INVALID CHARACTER PAIR DETECTED

	LB	R1,0,R3			:ESCAPE, GET NEXT CHAR
	CL	R3,BE,R2,		:CHECK FOR LAST BUFFERLET
	JNFS	SUITY1			:NO--CONTINUE
	JAL	R8,GCLAST
	LIS	R3,0
	JFS	SUITY2
SUITY1	AIS	R3,R1
	THI	R3,CBSZ-1		:END OF BUFFERLET?
	JNFS	SUITY2			:NO--CONTINUE
	JAL	R8,GCRET		:YES--RETURN BUFFERLET
	L	R3,BB,R2,
SUITY2	SIS	CD,1
	JLE	SUPI70
	SIS	LRC,1			:escape affects message length
	J	SUPI70			:write char w/o escape into ring

:	DETECTED 03 CHARACTER ON COMMAND CIRCUIT. GET NEXT CHARACTER AND
:	TEST FOR A ZAPPER.
SUICTL	HS	0
	LR	R3,R3			:ANY MORE CHARACTERS IN BUFFER?
	JE	SUIINV			:NO, INVALID SINCE 03'S TRAVEL IN PAIRS
	ST	R3,BB,R2,
	JAL	R8,GCI			:GET NEXT BYTE
	LIS	R0,1			:SET R0 FOR GOBBLER DETECTED (SUICH1)
	CLHI	R1,GOBBL&0FF		:IS IT A GOBBLER?
	JL	SUIZAP			:NO, ITS A ZAPPER
	JE	SUICH1			:GOBBLER (R0 ALREADY SET UP)
	OHI	R1,300
	STH	R1,SUICHR		:INVALID 03 CHR PAIR - SAVE IT
	LIS	R0,2			:INDICATE INVALID CHARACTER PAIR AND
	J	SUICH1			: GO FORMAT CHANNEL 1 MESSAGE TO SUP

:	SOME KIND OF INVALID NETWORK CHARACTER DETECTED. DETERMINE WHAT
:	KIND, AND FORMAT CHANNEL 1 MESSAGE TO SUPERVISOR.
SUIINV	HS	0
	EXBR	R1,R1
	STH	R1,SUICHR		:SAVE FIRST CHARACTER OF PAIR
	LR	R3,R3			:ANY MORE CHARACTERS IN BUFFER?
	JE	SUIN10			:NO, SECOND CHAR OF PAIR NOT PRESENT
	ST	R3,BB,R2,
	JAL	R8,GCI
	STB	R1,SUICHR+1		:SAVE SECOND CHARACTER OF PAIR
	LHL	R1,SUICHR
	CLHI	R1,01FD			:WAS CHAR PAIR BLACK BALL (BUFFER ZAP)?
	JNFS	SUIN10			:NO
	LIS	R0,0			:YES - INDICATE BLACK BALL DETECTED
	STH	R0,SUICHR		: ON COMMAND CIRCUIT
	JFS	SUICH1			: AND GO FORMAT CHAN 1 MESSAGE TO SUP
SUIN10	LIS	R0,2			:SHOW UNKNOWN INVAL CHAR PAIR DETECTED

:	FORMAT CHANNEL 1 MESSAGE TO SUPERVISOR. ROUTINE ENTERED WITH MESSAGE
:	TYPE IN R0 - 0 FOR BLACK BALL, 1 FOR GOBBLER, 2 FOR OTHER INVALID
:	CHARACTER PAIR. FIRST HW IS 088x, WHERE x IS THE MESSAGE TYPE. SECOND
:	HW CONTAINS THE OFFENDING PORT NUMBER. THIRD HW (IF PRESENT) HAS THE
:	CHARACTER PAIR DETECTED. REGISTER PRD IS SET TO POINT BACK TO BEGINNING
:	OF CURRENT RECORD, WHICH IS WRITTEN OVER.
SUICH1	HS	0
	IF	SNRING
	LR	PRD,R11			:POINT BACK TO RECORD BEGINNING
	ELSE	:NOT SNRING
	SR	LRC,CD			:LRC HAS NUMBER OF BYTES ALREADY STORED
	SHI	PRD,4,LRC		:PRD NOW POINTS TO BEGIN OF CHAN 1 REC
	NR	PRD,TC
	EI	:SNRING
	LR	LRC,R0			:GET MESSAGE TYPE AND
	LB	LRC,SUIC1S,LRC		: COMPUTE LENGTH OF MESSAGE
	LIS	R1,1
	STH	R1,SIB,PRD,		:CHANNEL 1 MESSAGE
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIC10
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIC10	HS	0
	STH	LRC,SIB,PRD,		:LENGTH OF MESSAGE
	AM	LRC,SUPICC		:INCREMENT COUNT OF CHARACTERS TO SUP
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIC20
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIC20	HS	0
	OHI	R0,0880
	STH	R0,SIB,PRD,		:STORE MESSAGE TYPE
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIC30
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIC30	HS	0
	STH	CHN,SIB,PRD,		:STORE OFFENDING CHANNEL NUMBER
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIC40
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIC40	HS	0
	CLHI	LRC,4			:IS THERE MORE FOR THIS MESSAGE?
	JLEFS	SUIC90			:NO
	LHL	R1,SUICHR		:YES - GET NEXT 2 BYTES
	STH	R1,SIB,PRD,		: AND STORE
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIC90
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIC90	HS	0

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	LIS	R0,1
	TBT	R0,SRNTRE,,		:CHAN 1 TRACING ENABLED ?
	JE	SRNB03			:NO

	ST	R1,SRNSAV,,		:SAVE R1
	ST	R2,SRNSAV+4,,		:AND R2
	LHL	R2,SRNTRX,,		:NEXT ENTRY IN TRACE TABLE
	LR	R1,R11			:BEGINNING OF RECORD IN RING
	AIS	R1,4			:POINT TO RECORD DATA
	JLFS	SRNB05			:SUP NEG RING NOT WRAPPED
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNB05	LB	R0,SIB,R1,		:GET DATA FROM RING
	STB	R0,SRNTBL,R2,		:AND ENTER INTO TRACE TABLE
	AIS	R2,1			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNB06			:NO
	LIS	R2,0			:WRAP
SRNB06	AIS	R1,1			:BUMP RING INDEX
	JLFS	SRNB07			:NO NEGATIVE WRAP
	SHI	R1,SUPBSZ		:NEG RING WRAP
SRNB07	CR	R1,PRD			:END OF RECORD?
	JL	SRNB05			:NO
	THI	R2,0001			:ODD TRACE TABLE INDEX ?
	JEFS	SRNB08			:NO
	LIS	R0,0
	STB	R0,SRNTBL,R2,		:CLEAR DUMMY PAD BYTE
	AIS	R2,1			:ENFORCE EVEN TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNB08			:NO
	LIS	R2,0			:WRAP
SRNB08	LR	R1,R11			:POINT TO BEGIN OF RECORD IN SUP RING
	AIS	R1,2			:POINT TO LRC
	JLFS	SRNB0D			:SUP NEG RING NOT WRAPPED
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNB0D	LHL	R0,SIB,R1,		:GET LRC FROM RING
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNB09			:NO
	LIS	R2,0			:WRAP
SRNB09	LHL	R0,FASTC+2,,		:GET FASTC MARK
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNB0A			:NO
	LIS	R2,0			:WRAP
SRNB0A	LHL	R0,SIB,R11,		:GET CHAN # FROM RING
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNB10			:NO
	LIS	R2,0			:WRAP
SRNB10	STH	R2,SRNTRX,,		:UPDATE TRACE TABLE INDEX
	L	R1,SRNSAV,,		:RECOVER R1
	L	R2,SRNSAV+4,,		:RECOVER R2

SRNB03	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	STH	CHN,SUERCH		:SAVE OFFENDING CHANNEL NUMBER
	STH	R0,SUERTP		: AND ERROR TYPE
	JAL	R8,CBCLR		:CLEAR BUFFER (index in R2)
	J	SUPI90			:DONE

:	zapper
SUIZAP	HS	0
	JAL	R9,ZAPV,,		:ZAPPER
	IF	SNRING
	LR	PRD,R11
	AIS	PRD,4			:POINT TO BEGINNING OF DATA AREA
	JLFS	SUIZ10
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	SR	LRC,CD			:DISCARD ANY PRECEDING CHARS
	SR	PRD,LRC
	NR	PRD,TC
	EI	:SNRING
SUIZ10	HS	0
	RBT	CHN,SUPBPX,,		:NO MORE DATA FLOW ON THIS CHANNEL
	STH	CHN,SIB,PRD,		:SEND ZAPPER MESSAGE ON CHANNNEL 0
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIZ20
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIZ20	HS	0
	LIS	CHN,0
	LIS	LRC,2			:MESSAGE LENGTH
	J	SUPI80

::*********************************************************************
::
::	TABLE:	   SUIC1S:
::	FUNCTION:  LENGTHS FOR CHANNEL 1 MESSAGES, ORDERED BY MESSAGE TYPE
::
::*********************************************************************

SUIC1S	BC	6,4,6,0

	EI	:SUPER

	SUBTTL	XHOSTS (SUPOUT - Moves sup data out into network)

::*********************************************************************
::
::	SUBROUTINE:	SUPOUT:
::	FUNCTION:	Moves data from sup output data ring (SOB) into network
::	CALLING SEQ:	JAL	R10,SUPOUT
::	CALLS:		JAL	R9,SOROOM
::			JAL	R8,WCI
::			JAL	R9,SIBPRM
::			JAL	R0,EXYLD
::			JAL	R9,ZAPHRD
::			JAL	R10,SCQZAP
::			JAL	R8,CRYPTO
::
::*********************************************************************

	IF	SUPER

SUPOUT	HS	0
	ST	R10,XHSVRT

SUONXT	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR SUPOUT
	CPUTNM(SUPOUT)			:DEFINE CPUTIL ENTRY FOR SUPOUT
	EI	:DB.CPU

	JAL	R9,SOROOM		:COMPUTE AMOUNT OF DATA IN SOB RING
	LR	PRC,PRC
	JE	SUPOUX			:NO DATA, EXIT

	LHL	CHN,SOB,PRD,		:GET THE PORT #
	JE	SUZERO			:PORT 0 MESSAGE
	AIS	PRD,2
	IF	SNRING
	JLFS	SUON10
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUON10	HS	0
	LHL	LRC,SOB,PRD,		:# OF DATA BYTES TO MOVE
	AM	LRC,SUPOCC		:COUNT OF CHARS FROM SUP
        ar      r5,r5
        am      lrc,supcpo,r5,r5        :count chars by port
        srls    r5,1
        lr      r8,prd
        ais     r8,4                    :get to msg type
                IF      SNRING
        JLFS    SUON18
        SHI     r8,SUPBSZ              :NEGATIVE RING WRAP
suon18
        ELSE    :NOT SNRING
        NR      r8,TC
        EI      :SNRING
:       get msg type
        lb      r1,sob,r8,              :msg type
        sis     r1,0e                   :aux response
        jefs    suon17
        ais     r1,1                    :normal log response
        jnfs    suon19
suon17  lis     r1,1                    :count it
        ar      r5,r5
        am      r1,suprej,r5,r5
        srls    r5,1
        j       suon21
suon19  ais     r1,0d-9         :needle?
        jn      suon21
        lis     r1,1
        ar      r5,r5
        am      r1,supned,r5,r5 :count it
        lb      r0,sob+1,r8,            :get link count
        nhi     r0,7f                   :knock off high bit
        jnfs    suon29
        ahm     r1,supind,r5,           :internal circuits
        srls    r5,1
        j       suon21                  :dont do dest stuff since is orig
suon29
        am      r0,supilc,r5,r5         :link count for orig node
        srls    r5,1
        ais     r8,0c                   :get to needle list
        IF      SNRING
        JLFS    SUON30
        SHI     r8,SUPBSZ              :NEGATIVE RING WRAP
suon30
        ELSE    :NOT SNRING
        NR      r8,TC
        EI      :SNRING
        lis     r4,0                    :sort of error, don't count it
suon32  lh      r3,sob,r8,              :get next neighbor
        jlfs    suon35                  :got host so last was node
        lr      r4,r3                   :save last node number
        ais     r8,2                    :look fo rnext node number
        IF      SNRING
        JLFS    SUON37
        SHI     r8,SUPBSZ              :NEGATIVE RING WRAP
suon37
        ELSE    :NOT SNRING
        NR      r8,TC
        EI      :SNRING
        jbs     suon32                  :check next
suon35  clhi    r4,nsp+2+400            :valid node #?
        jgfs    suon21                  :no, ignore it (error of some sort)
        shi     r4,3fe                  :convert to internal port #
        ar      r4,r4
        am      r0,supdlc,r4,r4         :link count as destination
        am      r1,supdnd,r4,r4         :and a destination needle
suon21                          :and done
	AIS	PRD,2
	IF	SNRING
	JLFS	SUON20
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUON20	HS	0
:	FORCE SIZE TO HW BOUNDARY AND SAVE IN PRC. WILL UPDATE NOSO
: 	WHEN DONE EMPTYING THIS LOGICAL RECORD.
	LHI	PRC,5,LRC		:LRC + 4-BYTE HEADER,
	NHI	PRC,-2			: ROUNDED UP IF NECESSARY

	LHL	R2,SIOTAB,CHN,CHN	:GET BUFF #
	NHI	R2,-4
	JE	SUOER1			:UNASSIGNED CHANNEL - IGNORE
	LIS	R1,0			:WRITE THE LEADING ESCAPE FOR BYTE CNT
	JAL	R8,WCI
	JAL	R8,WCI			:SAVE SPACE FOR BYTE COUNT
	L	R11,BE,R2,		:POINTER TO BYTE COUNT

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	TBT	CHN,SRNTRE,,		:IS THIS CHANNEL TRACE ENABLED ?
	JE	SRNE01			:NO
	LR	R1,PRD			:GET POINTER TO START OF RECORD DATA
	AIS	R1,2			:POINT TO MESSAGE TYPE
	JLFS	SRNE02			:SUP NEG RING NOT WRAPPED
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNE02	LB	R0,SOB,R1,		:GET MESSAGE TYPE BYTE
	LIS	R1,1			:ASSUME MESSAGE IS NOT TO BE TRACED
	TBT	R0,SRNOCK,,		:IS THIS MESSAGE DESIRED ?
	JNFS	SRNE03			:NO
	LIS	R1,0			:MESSAGE TO BE TRACED
SRNE03	STH	R1,SRNSAV+8,,		:FLAG MESSAGE STATE
	ST	LRC,SRNSAV+4,,		:SAVE CURRENT LRC(ACTUAL RING DATA LRC)
					:FOR TRACE TABLE AFTER DATA.
SRNE01	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	LR	CD,LRC
	AIS	LRC,2			:MESSAGE IS AT LEAST THIS LONG
SUPO10	HS	0
	LB	R1,SOB,PRD,		:GET BYTE

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	TBT	CHN,SRNTRE,,		:IS THIS CHANNEL TRACE ENABLED ?
	JE	SRNF01			:NO
	LH	R0,SRNSAV+8,,		:CHECK IF THIS MESSAGE IS DESIRED
	JN	SRNF01			:NO, BYPASS

	LR	R0,R1			:SAVE DATA BYTE
	LHL	R1,SRNTRX,,		:GET INDEX INTO TRACE TABLE
	STB	R0,SRNTBL,R1,		:STORE CHAN DATA (OUTPUT FROM SUP)
	AIS	R1,1			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNF02			:NO
	LIS	R1,0			:WRAP

SRNF02	STH	R1,SRNTRX,,		:UPDATE TRACE TABLE INDEX
	LR	R1,R0			:RECOVER DATA BYTE IN R1

SRNF01	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	AIS	PRD,1
	IF	SNRING
	JLFS	SUPO12
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUPO12	HS	0
	CLHI	R1,4			:DOES IT NEED TO BE ESCAPED?
	JGEFS	SUPO20
	EXBR	R1,R1			:YES
	JAL	R8,WCI
	EXBR	R1,R1
	AIS	LRC,1			:BYTE COUNT IS AFFECTED
SUPO20	JAL	R8,WCI
	SIS	CD,1
	JG	SUPO10			:get another byte

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	TBT	CHN,SRNTRE,,		:IS THIS CHANNEL TRACE ENABLED ?
	JE	SRNF06			:NO
	LH	R0,SRNSAV+8,,		:IS THIS MESSAGE BEING TRACED
	JN	SRNF06			:NO

	LHL	R1,SRNTRX,,		:GET FINAL TRACE TABLE INDEX
	THI	R1,0001			:ODD TRACE TABLE INDEX ?
	JEFS	SRNF03			:NO
	LIS	R0,0
	STB	R0,SRNTBL,R1,		:CLEAR DUMMY PAD BYTE
	AIS	R1,1			:ENFORCE EVEN TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNF03			:NO
	LIS	R1,0			:WRAP
SRNF03	L	R0,SRNSAV+4,,		:GET RING LRC
	STH	R0,SRNTBL,R1,		:AND STORE IN TRACE TABLE
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNF04			:NO
	LIS	R1,0			:WRAP
SRNF04	LHL	R0,FASTC+2,,		:GET FASTC MARK
	STH	R0,SRNTBL,R1,		:AND STORE IN TRACE TABLE
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNF0A			:NO WRAP
	LIS	R1,0			:WRAP
SRNF0A	LR	R0,CHN			:GET CHANNEL #
	OHI	R0,8000			:SET HO BIT TO INDICATE OUT FROM SUP
	STH	R0,SRNTBL,R1,		:STORE IN TRACE TABLE
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNF05			:NO
	LIS	R1,0			:WRAP
SRNF05	STH	R1,SRNTRX,,		:UPDATE TRACE TABLE INDEX

SRNF06	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	STB	LRC,0,R11		:SET THE FINAL BYTE COUNT
SUPO30	LHL	R0,BCT,R2,		:BACKPRESSURE SUP IF BUFF TOO FULL
	CLHI	R0,CIRSP3		:ARBITRARILY CIRCUIT SPEED 3
	JL	SUPO50			:DON'T BACKPRESSURE

:	backpressure sup (SIBP)
SUPO40	IF	SNRING
	LR	R0,PRC			:SAVE RECORD LENGTH,
	JAL	R9,SIBPRM		: SET UP SIBP POINTERS,
	LR	PRC,PRC			: AND TEST FOR ROOM IN SIBP RING
	JLEFS	SUPO44			:NO ROOM, DON'T APPLY BACKPRESSURE
	LR	R9,CHN
	OHI	R9,8000			:CHN+8000 TO TURN BACKPRESSURE ON
	STH	R9,SIBP,PRD,		:APPLY BACKPRESSURE FOR THIS CHANNEL
	AIS	PRD,2
	JLFS	SUPO42
	SHI	PRD,SIBPSZ		:NEGATIVE RING WRAP
SUPO42	STH	PRD,NISIBP,,		:UPDATE LEAD POINTER
SUPO44	LR	PRC,R0			:RESTORE PRC
	EI	:SNRING
	RBT	CHN,SUPBPX,,		:BACKPRESSURE APPLIED THIS CHANNEL

:	DONE WITH THIS RECORD - UPDATE NOSO...
SUPO50	HS	0
	IF	SNRING
	AH	PRC,NOSO,,		:SOB TRAIL POINTER
	JLFS	SUPO52
	SHI	PRC,SUPBSZ		:NEGATIVE RING WRAP
SUPO52	STH	PRC,NOSO,,
	ELSE	:NOT SNRING
	AHM	PRC,NOSO,,		:UPDATE SOB TRAIL POINTER
	EI	:SNRING

	JAL	R0,EXYLD,,		:YIELD AFTER TRANSFER
	J	SUONXT			:ALL DONE W/ THIS PORT

:	port 0 message
SUZERO	HS	0
	AIS	PRD,4			:PORT 0 MESSAGE
	IF	SNRING
	JLFS	SUZER1
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC			:SKIP LRC
	EI	:SNRING
SUZER1	HS	0
	LHL	CHN,SOB,PRD,		:THIS IS THE ZAPPED CHANNEL

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	LIS	R0,0
	TBT	R0,SRNTRE,,		:IS CHAN 0 TRACE ENABLED
	JE	SRNC01			:NO

	ST	R1,SRNSAV,,		:SAVE R1
	LHL	R1,SRNTRX,,		:GET INDEX INTO TRACE TABLE
	STH	CHN,SRNTBL,R1,		:STORE CHAN ZERO DATA (OUTPUT FROM SUP)
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNC02			:NO
	LIS	R1,0			:WRAP
SRNC02	LIS	R0,2			:LOG REC COUNT (ALWAYS 0002)
	STH	R0,SRNTBL,R1,		:STORE LRC
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP?
	JLFS	SRNC04			:NO
	LIS	R1,0			:WRAP
SRNC04	LHL	R0,FASTC+2,,		:GET FASTC MARK
	STH	R0,SRNTBL,R1,		:AND STORE IN TRACE TABLE
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNC0A			:NO
	LIS	R1,0			:WRAP
SRNC0A	LHI	R0,8000			:CHAN ZERO + OUTPUT INDICATOR BIT
	STH	R0,SRNTBL,R1,		:STORE CHAN ZERO (OUTPUT FROM SUP)
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNC05			:NO
	LIS	R1,0			:WRAP
SRNC05	STH	R1,SRNTRX,,		:UPDATE TRACE TABLE INDEX
	L	R1,SRNSAV,,		:RECOVER R1

SRNC01	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	LIS	PRC,6			:RECORD SIZE 6, UPDATE NOSO IN 'SUPO52'
	THI	CHN,8000		:TEST FOR SPECIAL MESSAGE
	JN	SUOSLP			:SLEEP MESSAGE

:	sup zap
SUOZAP	LHL	R2,SIOTAB,CHN,CHN	:ZAPPER
	NHI	R2,-4
	JE	SUOER2			:UNASSIGNED CHANNEL, IGNORE
	JAL	R9,ZAPHRD,,
	J	SUPO40			:AND BACKPRESSURE CHANNEL

:	sup has gone to sleep
SUOSLP	HS	0			:SUP HAS GONE TO SLEEP
	STH	PRC,XHPRCS		:SAVE PRC
	JAL	R10,SCQZAP		:ZAP ALL COMMAND CIRCS FROM SUP INTERF
	LHL	PRC,XHPRCS
	LIS	R0,4			:SET SUP STATE
	STH	R0,TVRSTT
	J	SUPO50			:ALL CIRCUITS ZAPPED, UPDATE NOSO

SUPOUX	J	XHRET			:RETURN TO SPIDER

:	CRYPTO 24: SUP DATA ON UNASSIGNED CHN
SUOER1	HS	0			:SUP SENT DATA ON UNASSIGNED PORT
	LR	R0,CHN
	JAL	R8,CRYPTO,,		:REPORT TO XRAY WITH CHANNEL NUM IN R0
	HC	CRYE24
	J	SUPO50			:GO UPDATE NOSO AND DISMISS

:	CRYPTO 25: SUP ZAP ON UNASSIGNED CHN
SUOER2	HS	0			:SUP SENT ZAPPER ON UNASSIGNED PORT
	LR	R0,CHN
	JAL	R8,CRYPTO,,		:REPORT TO XRAY WITH CHANNEL NUM IN R0
	HC	CRYE25
	J	SUPO50

	EI	:SUPER

	SUBTTL	XHOSTS (Sup process utility routines)

:	THE FOLLOWING SUBROUTINES ARE FOR HANDLING THE NEGATIVE
: 	INDEXED FORMAT FOR THE SUPERVISOR INTERFACE RINGS (ENABLED BY ASSEMBLY
: 	OPTION 'SNRING'). THERE ARE 6 RINGS:
:
:	SIB - DATA RING, NODE-->SUP
:		NISI LEAD POINTER, NODE INDEXED
:		NOSI TRAIL POINTER, SUP INDEXED
:
:	SOB - DATA RING, SUP-->NODE
:		NISO LEAD POINTER, SUP INDEXED
:		NOSO TRAIL POINTER, NODE INDEXED
:
:	SIBP - BACKPRESSURE RING, NODE-->SUP
:		NISIBP LEAD POINTER, NODE INDEXED
:		NOSIBP TRAIL POINTER, SUP INDEXED
:
:	SOBP - BACKPRESSURE RING, SUP-->NODE
:		NISOBP LEAD POINTER, SUP INDEXED
:		NOSOBP TRAIL POINTER, NODE INDEXED
:
:	SIC - CONTROL RING, NODE--SUP
:		NISIC LEAD POINTER, NODE INDEXED
:		NOSIC TRAIL POINTER, SUP INDEXED
:
:	SOC - CONTROL RING, SUP-->NODE
:		NISOC LEAD POINTER, SUP INDEXED
:		NOSOC TRAIL POINTER, NODE INDEXED
:
:	THE 'ROOM' SUBROUTINES DETERMINE THE SPACE AVAILABLE FOR INPUT
: 	RINGS (NODE-->SUP), OR COMPUTE THE AMOUNT OF DATA WAITING FOR
: 	OUTPUT RINGS (SUP-->NODE). ALL SUBS LINK ON R9, RETURN PRD AS THE
: 	NODE'S RING INDEX, AND PRC AS THE LENGTH.

	IF	SUPER

::*********************************************************************
::
::	SUBROUTINE:	SIROOM:
::	FUNCTION:	COMPUTE AMOUNT OF SPACE AVAILABLE IN SIB
::	CALLING SEQ:	JAL	R9,SIROOM
::
::*********************************************************************

SIROOM	HS	0
	IF	SNRING
	LH	PRD,NISI,,		:NODE INDEX
	NEGTST(NOP,,NISI,0)		:IF DB.DEB, INSURE NEG RING POINTERS
	LH	PRC,NOSI,,		:SUP INDEX
	NEGTST(NOP,,NOSI,0)
	IF	DB.DEB
	STH	PRD,SRNRPS		:SAVE USEFUL VALUES
	STH	PRC,SRNPRS
	EI	:DB.DEB
	SHI	PRC,2,PRD		:COMPUTE SPACE LEFT IN RING
	JGER	R9
	AHI	PRC,SUPBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

	ELSE	:NOT SNRING

	LH	PRD,NISI,,		:NODE INDEX
	LH	PRC,NOSI,,		:SUP INDEX
	SHI	PRC,SUPBSZ,PRD
	NHI	PRC,2*SUPBSZ-1		:TRUNCATE SPACE LEFT IN RING
	LHI	TC,SUPBSZ-1		:SET UP POWER OF 2 MASK FOR RING WRAP
	NR	PRD,TC
	JR	R9			:RETURN
	EI	:SNRING

::*********************************************************************
::
::	SUBROUTINE:	SOROOM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA AVAILABLE IN SOB
::	CALLING SEQ:	JAL	R9,SOROOM
::
::*********************************************************************

SOROOM	HS	0
	IF	SNRING
	LH	PRD,NOSO,,		:NODE INDEX
	NEGTST(NOP,,NOSO,0)		:IF DB.DEB, INSURE NEG RING POINTERS
	LH	PRC,NISO,,		:SUP INDEX
	NEGTST(NOP,,NISO,0)
	SR	PRC,PRD			:COMPUTE AMOUNT OF DATA IN RING
	JGER	R9
	AHI	PRC,SUPBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

	ELSE	:NOT SNRING

	LH	PRD,NOSO,,		:NODE INDEX
	LH	PRC,NISO,,		:SUP INDEX
	SR	PRC,PRD
	NHI	PRC,2*SUPBSZ-1		:TRUNCATE SPACE LEFT IN RING
	LHI	TC,SUPBSZ-1		:SET UP POWER OF 2 MASK FOR RING WRAP
	NR	PRD,TC
	JR	R9			:RETURN
	EI	:SNRING

	IF	SNRING
:	THE FOLLOWING ROUTINES APPLY ONLY TO THE NEGATIVE INDEX SUPERVISOR
:	INTERFACE SINCE THE RINGS REFERENCED DO NOT EXIST OTHERWISE.

::*********************************************************************
::
::	SUBROUTINE:	SIBPRM:
::	FUNCTION:	COMPUTE SPACE AVAILABLE IN SIBP RING
::	CALLING SEQ:	JAL	R9,SIBPRM
::
::*********************************************************************

SIBPRM	HS	0
	LH	PRD,NISIBP,,		:NODE INDEX
	NEGTST(NOP,,NISIBP,0)
	LH	PRC,NOSIBP,,		:SUP INDEX
	NEGTST(NOP,,NOSIBP,0)
	SHI	PRC,2,PRD		:COMPUTE SPACE AVAILABLE
	JGER	R9
	AHI	PRC,SIBPSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SOBPRM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA IN SOBP RING
::	CALLING SEQ:	JAL	R9,SOBPRM
::
::*********************************************************************

SOBPRM	HS	0
	LH	PRD,NOSOBP,,		:NODE INDEX
	NEGTST(NOP,,NOSOBP,0)
	LH	PRC,NISOBP,,		:SUP INDEX
	NEGTST(NOP,,NISOBP,0)
	SR	PRC,PRD			:COMPUTE AMOUNT OF DATA WAITING
	JGER	R9
	AHI	PRC,SOBPSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SICROM:
::	FUNCTION:	COMPUTE AMOUNT OF SPACE AVAILABLE IN SIC RING
::	CALLING SEQ:	JAL	R9,SICROM
::
::*********************************************************************

SICROM	HS	0
	LH	PRD,NISIC,,		:NODE INDEX
	NEGTST(NOP,,NISIC,0)
	LH	PRC,NOSIC,,		:SUP INDEX
	NEGTST(NOP,,NOSIC,0)
	SHI	PRC,2,PRD		:COMPUTE SPACE AVAILABLE
	JGER	R9
	AHI	PRC,SICSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SOCROM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA WAITING IN SOC RING
::	CALLING SEQ:	JAL	R9,SOCROM
::
::*********************************************************************

SOCROM	HS	0
	LH	PRD,NOSOC,,		:NODE INDEX
	NEGTST(NOP,,NOSOC,0)
	LH	PRC,NISOC,,		:SUP INDEX
	NEGTST(NOP,,NISOC,0)
	SR	PRC,PRD			:COMPUTE AMOUNT OF DATA WAITING
	JGER	R9
	AHI	PRC,SOCSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

	EI	:SNRING

::*********************************************************************
::
::	SUBROUTINE:	IZSUP:
::	FUNCTION:	INITIALIZE FIELDS FOR SUP INTERFACE
::	CALLING SEQ:	JAL	R10,IZSUP
::
::*********************************************************************

:	IF SNRING, INITIALIZE NEGATIVE RING POINTERS. IF NOT SNRING, SET SBUFS.

IZSUP	HS	0
	IF	SNRING
	LHI	R0,-SUPBSZ
	STH	R0,NISI,,		:INIT SIB POINTERS
	STH	R0,NOSI,,

	STH	R0,NISO,,		:INIT SOB POINTERS
	STH	R0,NOSO,,

	LHI	R0,-SIBPSZ
	STH	R0,NISIBP,,		:INIT SIBP POINTERS
	STH	R0,NOSIBP,,

	STH	R0,NISOBP,,		:INIT SOBP POINTERS
	STH	R0,NOSOBP,,

	LHI	R0,-SICSZ
	STH	R0,NISIC,,		:INIT SIC POINTERS
	STH	R0,NOSIC,,

	STH	R0,NISOC,,		:INIT SOC POINTERS
	STH	R0,NOSOC,,

	ELSE	:NOT SNRING

	LHI	R0,SUPZFL
	STH	R0,SBUFS,,		:ABSOLUTE CHANNEL 0 OF SUP INTERFACE

	EI	:SNRING

	JR	R10			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SUPBPS:
::	FUNCTION:	RELIEVE BACKPRESSURE ON SUP PORTS THAT HAVE
::			SUFFICIENTLY LOW CHARACTER COUNTS
::	CALLING SEQ:	JAL	R10,SUPBPS
::	CALLS:		JAL	R8,BID
::			JAL	R9,SIBPRM
::			JAL	R9,SOBPRM
::
::*********************************************************************

SUPBPS	HS	0
	ST	R10,XHSVRT		:SAVE RETURN ADDRESS
	LIS	R4,0			:UPDATE SUPBPS BITS, SIBP IF SNRING
	LIS	R7,0

SUPB10	L	R0,SUPBPX,R7,		:PORTS/BITS ARE RESET IF BACKPRESSURED
	O	R0,SUPACP,R7,		:PORTS ACTIVE IF RESET
	LCS	R1,1
	XR	R1,R0			:SET IF ACTIVE .AND. BACKPRESSURED
	ST	R1,SBPTMP		:USED AS TEMP STORAGE
SUPB20	L	R1,SBPTMP
	JE	SUPB30			:NOBODY BP'ED
	JAL	R8,BID,,
	RBT	R2,SBPTMP
	AR	R2,R4			:SUP CHANNEL #
	LHL	R3,SIOTAB,R2,R2
	LR	R6,R3			:SAVE CIRCUIT SPEED
	NHI	R3,-4			:R3=BUFF #
	JE	SUPB20			:IDLE CHANNELS REMAIN BP'ED
	NHI	R6,3			:SPEED BITS
	LHL	R6,CIRSPK,R6,R6		:SPEED
	CLH	R6,BCT,R3,
	JL	SUPB20			:PORT MUST REMAIN BP'ED
	IF	SNRING
:	SEND CHANNEL NUMBER OVER SIBP RING TO RELEASE BACKPRESSURE
	JAL	R9,SIBPRM		:IS THERE ROOM IN SIBP?
	LR	PRC,PRC
	JLE	SUPB40			:NO ROOM, PROCEED NO FURTHER
	STH	R2,SIBP,PRD,		:RELEASE BACKPRESSURE FOR THIS CHANNEL
	AIS	PRD,2
	JLFS	SUPB22
	SHI	PRD,SIBPSZ		:NEGATIVE RING WRAP
SUPB22	STH	PRD,NISIBP,,		:UPDATE SIBP LEAD POINTER
	EI	:SNRING
	SBT	R2,SUPBPX,,		:INDICATE THIS CHANNEL'S BP RELEASED
	J	SUPB20
SUPB30	AIS	R7,4			:TRY NEXT PORT GROUP
	AHI	R4,20
	CLHI	R4,NSP
	JL	SUPB10

SUPB40	HS	0
	IF	SNRING
:	GET SUP BACKPRESSURE DATA FROM SOBP RING. CHANNEL NUMBER
: 	RELEASES BACKPRESSURE, CHANNEL NUMBER + 8000 APPLIES BACKPRESSURE.
	JAL	R9,SOBPRM		:ANY DATA IN SOBP RING?
	LR	PRC,PRC
	JLE	XHRET			:NO - RETURN
	LH	CHN,SOBP,PRD,		:GET NEXT ENTRY FROM SOBP RING
	JLFS	SUPB50			:APPLY BACKPRESSURE
	IF	DB.DEB
	CLHI	CHN,NSP			:INSURE VALID CHANNEL NUMBER
	JLFS	SUPB42			:O.K.
	DBOOPS				:SUP PASSED US INVALID CHANNEL NUMBER
	EI	:DB.DEB
SUPB42	SBT	CHN,SUPBPV,,		:RELEASE BACKPRESSURE FOR THIS CHANNEL
	JFS	SUPB60
SUPB50	NHI	CHN,7FFF		:STRIP HI-ORDER BIT
	IF	DB.DEB
	CLHI	CHN,NSP			:INSURE VALID CHANNEL NUMBER
	JLFS	SUPB52			:O.K.
	DBOOPS				:SUP PASSED US INVALID CHANNEL NUMBER
	EI	:DB.DEB
SUPB52	RBT	CHN,SUPBPV,,		:APPLY BACKPRESSURE FOR THIS CHANNEL
SUPB60	AIS	PRD,2
	JLFS	SUPB70
	SHI	PRD,SOBPSZ		:NEGATIVE RING WRAP
SUPB70	STH	PRD,NOSOBP,,		:UPDATE SOBP TRAIL POINTER
	J	SUPB40			:LOOK FOR MORE SOBP WORK
	ELSE	:NOT SNRING
	J	XHRET			:RETURN
	EI	:SNRING

::*********************************************************************
::
::	SUBROUTINE:	G08SUP:
::	FUNCTION:	EIGHT-SECOND TEST OF SUPER STATUS
::	CALLING SEQ:	JAL	R10,G08SUP
::	CALLS:		JAL	R9,SOCROM
::			JAL	R10,SCQZAP
::			JAL	R10,SICROM
::
::*********************************************************************

:	SUPERVISOR SENDS STATUS THRU SOC CONTROL RING. HALFWORD ENTRIES
: 	ARE -1 FOR SUP SLEEPING, 1 FOR SUP AWAKE. IF NO NEW ENTRIES IN RING
: 	EACH 8 SECONDS, CONSIDER SUP FROZEN (OR SICK).

	IF	SNRING

G08SUP	HS	0
	ST	R10,XHSVRT		:SAVE RETURN ADDRESS
	JAL	R9,SOCROM		:ANY DATA IN SOC CONTROL RING?
	LR	PRC,PRC
	JLE	SUPC40			:NO DATA, SUP NOT UPDATING SOC RING
SUPC02	LH	R0,SOC,PRD,		:GET ENTRY FROM RING
	JLFS	SUPC20			:SLEEPING SUP
	IF	DB.DEB
	SIS	R0,1
	JEFS	SUPC10			:ENTRY = 1, SUP AWAKE
	DBOOPS				:INVALID CONTROL RING ENTRY FROM SUP
	EI	:DB.DEB
SUPC10	LIS	R0,5			:STATUS FOR AWAKE SUP...
	JFS	SUPC30
SUPC20	IF	DB.DEB
	AIS	R0,1			:INSURE VALID CONTROL RING ENTRY
	JEFS	SUPC22			:O.K.
	DBOOPS				:INVALID CONTROL RING ENTRY FROM SUP
	EI	:DB.DEB
SUPC22	LIS	R0,4			:STATUS FOR SLEEPING SUP...
SUPC30	STH	R0,TVRSTT		:SAVE SUP STATUS
	AIS	PRD,2
	JLFS	SUPC32
	SHI	PRD,SOCSZ		:NEGATIVE RING WRAP
SUPC32	STH	PRD,NOSOC,,		:UPDATE SOC TRAIL POINTER
	JAL	R9,SOCROM		:ANY MORE ENTRIES IN SOC RING?
	LR	PRC,PRC
	JLE	SUPCIN			:NO - GO UPDATE SIC CONTROL RING
	J	SUPC02			:YES - EMPTY SIC RING
SUPC40	LIS	R0,3			:NO ENTRIES FROM SUP
	CLH	R0,TVRSTT		:WAS IT ALREADY FROZEN?
	JEFS	SUPC42			:YES
	STH	R0,TVRSTT		:NO - SAVE SUP STATUS AND
	JAL	R10,SCQZAP		: ZAP ALL COMMAND CIRCUITS
SUPC42	HS	0
	IF	SIORNG			:ONLY IF SPLIT/SUP		###GT
	LIS	R0,1			:UPDATE KERNEL STATUS
	AHM	R0,KERSTT		:SUP GONE, CHECK IF KERNEL STILL UP
					:DURING LOGIN TO KERNEL		###GT
	EI	:SIORNG

:	PUT NODE NUMBER, ABSOLUTE CHANNEL NUMBER OF INTERFACE IN SIC RING
SUPCIN	HS	0
	JAL	R9,SICROM		:ANY ROOM IN SIC?
	CLHI	PRC,4
	JLE	XHRET			:NO
	LHI	R0,SUPZFL		:SUP CHANNEL 0 ABSOLUTE CHANNEL NUMBER
	STH	R0,SIC,PRD,
	AIS	PRD,2
	JLFS	SUPC60
	SHI	PRD,SICSZ		:NEGATIVE RING WRAP
SUPC60	LHI	R0,MACHNM+8000		:NODE NUMBER + 8000
	STH	R0,SIC,PRD,
	AIS	PRD,2
	JLFS	SUPC70
	SHI	PRD,SICSZ		:NEGATIVE RING WRAP
SUPC70	STH	PRD,NISIC,,		:UPDATE SIC LEAD POINTER
	J	XHRET			:DONE

	ELSE	:NOT SNRING

G08SUP	LHL	R1,TVRSTT		:PREVIOUS STATUS
	LIS	R0,5			:SET SUP STATUS WORD
	STH	R0,TVRSTT
	TS	NODINF,,		:IS SUP AWAKE
	JER	R10			:YES
	JGFS	.+4			:SUP IS DOWN

	SIS	R0,1
	SIS	R0,1
	STH	R0,TVRSTT
	SIS	R1,4			:HAS SUP BEEN DOWN
	JLER	R10			:YES

	EI	:SNRING

::*********************************************************************
::
::	SUBROUTINE:	SCQZAP:
::	FUNCTION:	ZAP ALL COMMAND CIRCUITS
::	CALLING SEQ:	JAL	R10,SCQZAP
::	CALLS:		JAL	R9,ZAPX
::			JAL	R8,CRYPTO
::
::*********************************************************************

SCQZAP	HS	0
	L	R0,FASTC,,		:SAVE FASTC
	ST	R0,FASSAV
	LHI	R6,NSP-1		:ZAP ALL CIRCUITS...
	LHI	R1,ZAPPH
G08SU1	LHL	R2,SIOTAB,6,6
	NHI	R2,-4
	JEFS	G08SU3
	JAL	R9,ZAPX,,		:SEND A ZAPPER OUT
	GL	ZAPX
	RBT	R6,SUPBPX,,
G08SU3	SIS	R6,1
	JGEBS	G08SU1

	LIS	R0,0
	JAL	R8,CRYPTO,,		:SUP STOP
	HC	CRYE06
	JR	R10

	EI	:SUPER

::*********************************************************************
::
::	SUBROUTINE:	KCQDET:
::	FUNCTION:	DETACH KERNEL PORTS DUE TO SIO RING LINE DOWN	
::	CALLING SEQ:	JAL	R10,KCQDET
::	CALLS:		JAL	R9,ZAPHRD
::			JAL	R9,ZAPX
::			JAL	R9,CRQHCR
::			JAL	R8,WCI
::			JAL	R9,ZAPV
::
::*********************************************************************

:	RE-ROUTE ALL CIRCUITS TO KERNEL TO GO TO DETACH PROCESS.
:	'DETCIR' WILL SEND MEANINGFUL TEXT TO KERNEL USER BEFORE ZAPPING...

	IF	SIORNG

KCQDET	HS	0
	LCS	R0,1
	L	R1,KERACP,,		:ACTIVE PORTS ZEROS
	O	R1,KRZAPI		:MASK OUT PORTS AWAITING ZAPPER ACK
	XR	R0,R1			:MAKE ACTIVE PORTS ONES
	ST	R0,KERSVD
KCQD10	L	R0,KERSVD
	JFFO	R0,KCQD20		:FIND NEXT ACTIVE KERNEL PORT TO DETACH
	J	KCQD40			:DONE, SEE IF ANY HALF-ZAPPED
KCQD20	RBT	R1,KERSVD
	LHL	R2,KIOTAB,R1,R1		:GET PERMUTER TABLE ENTRY AND
	NHI	R2,-4			: ISOLATE BUFFER INDEX
	LH	R0,BF,R2,		:ONLY GOT HALF A CIRCUIT?
	JGFS	KCQD25			:NO, DETACH COMPLETE CIRCUIT
	SBT	R1,KRZAPI		:HALF-ZAPPED IF NOT THROUGH NEWLOG SEQ
	J	KCQD10

KCQD25	LCS	R4,1			:DECREMENT NUMBER OF HOST PORTS IN USE
	AHM	R4,HNPORT

:	FIND AVAILABLE PORT TO DETACH PROCESS
	L	R4,DETACP,,		:DETACH PROCESS PORTS
	JFFO	R4,KCQD30
	JAL	R9,ZAPHRD,,		:NO DETACH PORTS, JUST ZAP CIRCUIT
	J	KCQD10
KCQD30	LIS	R0,4
	STB	R0,DETMTY,CHN		:STORE DETACH REASON
:	CALL ZAPX WITH CR/LF INSTEAD OF ZAPPER. THIS REMOVES THE CIRCUIT
:	ENTRY FROM THE KERNEL INTERFACE WITHOUT ACTUALLY ZAPPING THE CIRCUIT.
	LHI	R1,0D0A			:CARRIAGE-RETURN, LINE-FEED
	JAL	R9,ZAPX,,		:REMOVE KIOTAB ENTRY, SET ACP
	AHI	CHN,DETZFL		:DETACH PROCESS ABSOLUTE CHANNEL NUMBER
	JAL	R9,CRQHCR		:CONNECT CIRCUIT STUB TO DETACH PROCESS
	XHI	R2,4			:POINT TOWARDS DETACH PROCESS AND
	LIS	R1,3			: WRITE NEEDLE POINT INTO BUFFER
	JAL	R8,WCI			: TO ALERT DETCIR OF NEW PORT
	LHI	R1,NEEDP
	JAL	R8,WCI
	J	KCQD10			:GO FIND ANOTHER PORT TO DETACH

:	NOW ZAP SECOND HALF OF HALF-ZAPPED CIRCUITS. COULD HAVE BEEN
: 	AWAITING ZAPPER ACK FROM KERNEL WHEN SIO RING INTERFACE WENT DOWN,
: 	OR MAYBE GOT ZAPPER BEFORE NEWLOG HANDSHAKE COMPLETED.
KCQD40	L	R4,KRZAPI		:BITS SET FOR HALF-ZAPPED CIRCUIT
	JFFO	R4,KCQD50
	JR	R10			:DONE KERNEL PORT DETACH/CLEANUP
KCQD50	RBT	CHN,KRZAPI
	LHL	R2,KIOTAB,CHN,CHN
	NHI	R2,-4
	JEBS	KCQD40			:NO CIRCUIT
	XHI	R2,4			:FLIP BUFFER INDEX AND
	JAL	R9,ZAPV,,		: ZAP SECOND HALF OF CIRCUIT
	J	KCQD40

	EI	:SIORNG
	EI	:(1-T2GATE)		:Gateway doesn't use XHOSTS
	ENDMO.(XHOSTS)
	EI	:1-KILLIT
	KILMSG(XHOSTS)
:	***NOTHING PAST THIS POINT***
 
	SUBTTL	DISPI

:		****  *****  **** ****  *****
:		*   *   *   *     *   *   *
:		*   *   *    ***  ****    *
:		*   *   *       * *       *
:		****  ***** ****  *     *****

::#####################################################################
::
::	MODULE:		DISPI
::
::	FUNCTION:	INTERFACE TO THE ISIS DISPATCHER.
::
::	REGISTER CONVENTIONS:
::		TYC	= R11	:HOLDS MAGIC CONSTANT (03 OR 07)
::		TC	= R15	:FOR TRUNCATING RING POINTERS
::		PRD	= R12	:POINTER TO RECORD DATA
::		PRC	= R10	:PHYSICAL DITTO
::		CHN	= R5	:CHANNEL NUMBER
::		LRC	= R14	:LOGICAL RECORD BYTE COUNT
::		CD	= R13	:WORKING COUNT
::
::	SUBTTLS:
::	  	DISPI (TABLES)
::		DISPI (DISIN - MOVE DATA INTO DISPATCHER FROM NETWORK)
::		DISPI (DISOUT - MOVE DATA OUT OF DISPATCHER INTO NETWK)
::		DISPI (DSZERO - INTRA-ISIS COMUNICATIONS, RPORT = 0)
::		DISPI (UTILITY ROUTINES)
::		DISPI (CONSAT - LOGCHR)
::
::#####################################################################		

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.

	IF	ISIS

	SEG	1

:	SUBTTL  DISPI (TABLES)
	GL	EXMG1

	IF	(1-T2GATE)	:Not used for Gateway configuration
::*********************************************************************
::
::	TABLE:		SLTLIC:
::	FUNCTION:	DEFINE SLOT LICENSE FOR EACH SLOT
::
::*********************************************************************

SLTLIC	WS	0
	SYAD(SLTLIC)		:SLOT LICENSE
Q	EQ	0
	RE	NUSLT+1		:ONCE FOR EACH SLOT
	IF	\S|Q|LIC	:IF LICENSE IS DEFINED
	WC	S|Q|LIC		:USE IT,
	ELSE
	WC	0		:USE THE DEFAULT
	EI	:\S|Q|LIC
Q	EQ	Q+1
	NOLIST
	ER
	LIST

::*********************************************************************
::
::	TABLE:		SCLTBL:
::	FUNCTION:	DEFINE LIMITS FOR NUMBER OF CIRCUITS/MINUTE 
::			AND NUMBER OF MESSAGES/MINUTE FOR EACH SLOT.
::
::*********************************************************************

:	CIRCUIT ACTIVITY LIMITS
SCLTBL	HS	0
	SYAD(SCLTBL)
Q	EQ	1
	RE	NUSLT
	HC	SCLT|$0Q|
Q	EQ	Q+1
	ER

::*********************************************************************
::
::	TABLE:		SMLTBL:
::	FUNCTION:	DEFINE SLOT REPORT LIMIT FOR EACH SLOT.
::
::*********************************************************************

SMLTBL	HS	0
	SYAD(SMLTBL)
Q	EQ	1
	RE	NUSLT
	HC	SMLT|$0Q|
Q	EQ	Q+1
	ER

::*********************************************************************
::
::	TABLES:		GHSTTB, GSHSTB, GCHSTB
::	FUNCTION:	IF RESTRICTED HOSTS HAVE BEEN DEFINED, SET UP
::			TABLES TO DEFINE HOST NUMBERS (GHSTTB),
::			HOST/SLOT RESTRICTIONS (GSHSTB),  AND
::			CIRCUITS PER MINUTE LIMITS (GCHSTB).
::
::*********************************************************************

	EI	:(1-T2GATE)	: end Gateway exclusion

	IF	RESHST

:	DEFINE ALL RESTRICTED HOSTS
GHSTTB	HS	0
	SYAD(GHSTTB)
Q	EQ	0
	RE	RESHST
	HC	GHST|$0Q|	:HOST NUMBER
Q	EQ	Q+1
	ER


:	DEFINE LEGAL SLOTS FOR EACH RESTRICTED HOST
GSHSTB	WS	0
	SYAD(GSHSTB)
Q	EQ	0
	RE	RESHST
	WC	GSHS|$0Q|	:BIT SET FOR LEGAL SLOT
Q	EQ	Q+1
	ER

:	DEFINE ACTIVITY LIMITS FOR EACH RESTRICTED HOST
GCHSTB	HS	0
	SYAD(GCHSTB)
Q	EQ	0
	RE	RESHST
	HC	GCHS|$0Q|	:CIRCUITS/MINUTE LIMIT FOR THIS HOST
Q	EQ	Q+1
	ER

	EI	:RESHST

:	bit assignments in psuedo needle request after local key
PSNIIX	EQ	8000		:pseudo needle request for IIX circuit
PSNELS	EQ	4000		:pseudo needle request for ext login status
PSNUUN	EQ	2000		:pseudo needle request for UUN

:	some local equates for immediate values
RDSPBP	EQ	0A100		:ring cmd to relieve backpressure
SDSPBP	EQ	0A000		:ring cmd to set backpressure
GRTLGN	EQ	0B600		:tell slot of successful logon
SUPRHNG	EQ	0B800		:super-(HDX) hang
XMTCAP	EQ	0B900		:ring cmd to set XMT capacity
UNUSNO	EQ	0C100		:universal user number (sup to slot)

	SUBTTL	DISPI (DISIN - Move data into dispatcher from network)

::*********************************************************************
::
::	SUBPROCESS:	DISIN:
::	FUNCTION:	MOVES DATA FROM THE NETWORK INTO THE DISPATCHER
::			RING.
::	CALLING SEQ:	JAL	R10,DISIN  Called from SPIDER.
::		Dispatched based on buffered data requesting output to
::		the Dispatcher.  Yields after processing each requesting
::		port, passes control to next subprocess when no more
::		data is present or there is no room in the Dispatcher
::		bound data ring, or if neither of the two previous
::		events occur within 61 MS.
::
::*********************************************************************

DISIN	HS	0
	ST	R10,DSSVRT		:SAVE RETURN
:	PREVENT HOGGING CPU IN DISPATCHER PROCESS. DIDTIM WILL CONTAIN
:	FASTC TIME TO DISMISS BACK TO SPIDER EVEN IF WORK TO DO.
	L	R0,FASTC,,
	AHI	R0,RATE/10		:DON'T RUN FOR MORE THAN 1/16TH SECOND
	ST	R0,DIDTIM

:	RETURN HERE AFTER SERVICING EACH CHANNEL, AND YIELD EITHER IF
:	HIGHER PRIORITY TASK HAS BEEN SCHEDULED, OR IF OUR TIME SLICE IS UP.

DSINXT	HS	0
	JAL	R0,EXYLD,,		:YIELD TO EXEC
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR DISIN		###OAS
	CPUTNM(DISIN )			:DEFINE DISIN CPUTIL ENTRY	###OAS
	EI	:DB.CPU
	L	R0,DIDTIM		:GET TIME TO DISMISS
	S	R0,FASTC,,		:LATER THAN CURRENT TIME?
	JGFS	DSINX1			:YES - CONTINUE FILLING DISPATCHER RING
	LIS	R0,1			:NO - COUNT NUMBER OF FORCED DISMISSES
	AHM	R0,DIDISM
	J	DSIORT			:..RETURN

DSINX1	LIS	TYC,7			:SET UP CONSTANTS
	LHI	TC,DRSZ-1
	LH	PRD,DRIF,,		:COMPUTE ROOM AVAILABLE
	LH	PRC,DRIE,,
	SR	PRC,PRD			:DRIE - DRIF
	JGFS	DISI05			:NO RING WRAP
	AHI	PRC,DRSZ		:RING WRAP
DISI05	CLHI	PRC,10			:MINIMUM ROOM CONSIDERED
	JGFS	DISI10			:PRC = ROOM AVAILABLE

:	HERE TO RETURN MAIN
DSIORT	L	R10,DSSVRT	
	JR	R10

:	LOCATE PORTS WITH INBOUND DATA
DISI10	LIS	R7,0	
	LIS	R4,0			:BASE PORT # FOR GROUP
DISI20	L	R1,DISFLG,R7,
	N	R1,DISBPV,R7		:MASK OUT BP'ED PORTS
	N	R1,DISSVD,R7		:AND SERVICED PORTS
	JN	DISI40			:GO TO SERVICE

	AIS	R7,4			:POINT TO  NEXT WORD OF BIT ARRAYS
	AHI	R4,20			:MOVE CHANNEL NUMBER AHEAD TO MATCH
	CLHI	R4,NDP			:HAVE WE REACHED END OF PAGE?
	JL	DISI20			:PROCESS THIS GROUP IF NOT

:	ALL PORTS SERVICED ONCE
	LCS	R2,1		
	LIS	R7,0
DISI30	ST	R2,DISSVD,R7		:RESTORE SERVICE FLAGS
	AIS	R7,4
	CLHI	R7,NDP/8
	JLBS	DISI30			:LOOP FOR NEXT GROUP

	J	DSIORT			:ALL DONE AND SPLIT

:	THIS IS THE MAIN WORK LOOP-- MOVE DATA FROM BUFFERLETS INTO RING
:	FOR THE PORTS MARKED IN R1'S BIT ARRAY.
DISI40	JFFO	R1,DISI42		:COMPUTE PORT NUMBER
DISI42	LR	CHN,R2			:CHANNEL OFFSET IN ONE GROUP
	AR	CHN,R4			:ADD CHAN OFFSET FOR WORD OF BIT ARRAY
					:CHN = RELATIVE DISPI CHN NUMBER
	RBT	CHN,DISSVD		:THIS PORT SERVICED
	LHL	R2,DIOTAB,CHN,CHN	:IOTAB ENTRY (OUTBOUND BUFF #)
	NHI	R2,-4			:STRIP GOUGING BITS FROM BUFFER NUMBER
	JNFS	DISI50
	CRASH.(.DISI0)			:DISPI FOUND NO DISPATCHER CIRCUIT
	J	DISI20			:GO TO SEE NEXT PORT

DISI50	XHI	R2,4			:SWITCH TO DISPI INBOUND BUFFER #
	JAL	R8,CBCCT		:GET CHAR COUNT, RETURN IN R1
					:PRC = DI RING SPACE AVAILABLE
					:LEAVE 7 SPACES
	LR	R1,R1			:Kludge fix to avoid spurrious
	JE	DISI20			:0264 crashes during Gateway logins
	LHI	LRC,-7,PRC		:CALCULATE # CHARS THAT CAN BE MOVED
	CLHI	LRC,DTDAT		:MAXIMUM DATA BYTE COUNT - 9D
	JLEFS	DISI52
	LHI	LRC,DTDAT
DISI52	CR	R1,LRC			:MINIMUM OF ABOVE
	JGEFS	DISI54
	LR	LRC,R1
DISI54	LHL	R1,DIXLIM,CHN,CHN	:TRANSMIT LIMIT
	CR	R1,LRC
	JGEFS	DISI56
	LR	LRC,R1			:MINIMUM AGAIN
DISI56	LR	CD,LRC			:WORKING COUNT
					:CD = NUMBER OF CHAR. CAN BE MOVED
					:PRD = DRIF = DI RING FILL POINTER
	STH	CHN,DIRNG,PRD,		:SET CHANNEL #  (RPORT)
	STH	PRD,RPSAV		:MUST SAVE THIS (POINTER TO RPORT)
	AIS	PRD,3			:PRD = POINTS TO START OF DATA
					:(LEAVE ONE SPACE FOR TYPE)

DISI60	JAL	R8,GCI			:MOVE CHARACTERS FROM BUFFER
	CR	R1,TYC			:TEST FOR TYMNET CTRL PAIRS
	JGFS	DISI70			:NO - DATA CHARACTER
	J	DSITYM			:YES - GO HANDLE TYMNET CONTROL CHAR

::*********************************************************************
::
::	SUBROUTINE:	DISI70:
::	FUNCTION:	HANDLE NORMAL DATA CHAR.
::
::*********************************************************************

DISI70	STB	R1,DIRNG,PRD,		:PUT AWAY BYTE INTO DI RING
	AIS	PRD,1			:INC PTR
	NR	PRD,TC			:WRAP AROUND IF NECESSARY
	SIS	CD,1			:DEC BYTE COUNT
	JGBS	DISI60			:GO TO READ NEXT BYTE OF CHAR.

DISI80	LHL	R1,RPSAV		:GET POINTER TO BYTE CNT (TYPE)
	STB	LRC,DIRNG+2,R1,		:THE COUNT IS THE TYPE IF A DATA MSG

DISI90	AHM	LRC,DISICC		:CHARS INTO DISPATCHER
	AIS	PRD,3			:ROUND OFF POINTER
	NHI	PRD,DRSZ-4
	STH	PRD,DRIF,,
	J	DSINXT			:AND LOOP

::*********************************************************************
::
::	SUBROUTINE:	DSITYM:
::	FUNCTION:	HANDLE NETWORK CONTROL CHAR PAIRS
::
::*********************************************************************

DSITYM	LR	R1,R1			:ESCAPE CHAR ?
	JNFS	DSITY1			:BRANCH IF NOT
:	GOT ESCAPE CHAR.
	JAL	R8,GCI			:GET ESCAPED CHAR
	SIS	CD,1
	JE	DISI70
	SIS	LRC,1			:0NE LESS CHAR IN RECORD
	J	DISI70			:PASS ON FOLLOWING CHAR

:	OTHER CONTROL CHAR.
DSITY1	SR	LRC,CD			:OTHER CONTROL -  END CURRENT RECORD
	JEFS	DSITY2			:NO RECORD HAS BEEN STARTED
	JAL	R8,WCD			:RETURN CHARACTER TO BUFF...
	J	DISI80			:..WE'LL CATCH IT NEXT

:	DISPATCH ON CONTROL  CHARACTER CODE
DSITY2	LHL	R1,DSITAB,R1,R1	
	J	SEG1,R1,

::*********************************************************************
::
::	SUBROUTINE:	DSITII:
::	FUNCTION:	HANDLE 03 CONTROL PAIRS
::
::*********************************************************************

DSITII	JAL	R8,GCI			:T-II CONTROL, GET NEXT CHR
	CLHI	R1,DSPMAX		:check range
	JGE	DSINXT			:ignore if too high
	LHL	R8,DSPTBL,R1,R1		:get dispatch value
	J	SEG1,R8,,		:and jump to handler

::*********************************************************************
::
::	DSPTBL:	DISPATCH TABLE FOR 03 PAIR	
::
::*********************************************************************

DSPTBL	HS	0
	HC	DSINXT-SEG1	:0300 unknown 03-pair
	HC	DSIZAP-SEG1	:0301 hard zapper
	HC	DSIZAP-SEG1	:0302 soft zapper
	HC	DSINGZ-SEG1	:0303 non-gobbling zapper 		###wjl
	HC	DSIZAP-SEG1	:0304 fat zapper
	HC	DSINXT-SEG1	:0305
	HC	DSINXT-SEG1	:0306
	HC	DSINXT-SEG1	:0307
	HC	DSIGOB-SEG1	:0308 GOBBLER
	HC	DSINXT-SEG1	:0309
	HC	DSINXT-SEG1	:030A
	HC	DSINXT-SEG1	:030B
	HC	DSINXT-SEG1	:030C
	HC	DSINXT-SEG1	:030D
	HC	DSINXT-SEG1	:030E
	HC	DSINXT-SEG1	:030F
	IF	T2GATE			:Gateway has several variations
	HC	DSINXT-SEG1	:Gateway Needle handler	###EV
	HC	DSINXT-SEG1	:Successful circuit request for Gateway
	HC	DSITIL-SEG1	:0312 used for Gateway only  for B8 translation
	HC	DSINXT-SEG1	:0313 Not used for Gateway
	ELSE	:NOT GATEWAY
	HC	DSINDP-SEG1	:0310 NEEDLE POINT
	HC	DSINDY-SEG1	:0311 NEEDLE EYE
	HC	DSITIL-SEG1	:0312 message for terminal in login mode
	HC	DSILRR-SEG1	:0313 error in circuit request
	EI	:T2GATE
DSPMAX	EQ	(.-DSPTBL)/2

::*********************************************************************
::
::	TABLE:		B4CODE:
::	FUNCTION:
::		TABLE TRANSLATES SUP CODES FOR TALKING TO TERMINAL
::		IN LOGIN MODE INTO ISIS CODES FOR B4 MESSAGE.  
::
::		SUP MSG 0D --> NODE CODE MSG 0312 --> ISIS MSG B4xx
::
::		SUP CODES START WITH 8. SUP CODES 11 AND 12 TRANSLATE
::		TO HANG (B8) AND SUPER-HANG (AF).  SUP CODES E, F, AND 10
::		ARE NOT USED (A 10 CODE IS CONVERTED TO 8 IN LEP).
::
::*********************************************************************
	IF	T2GATE
B4CODE	HC	0B400,0B401,0B402,0B403,0B404,0B405,0,0,0,09E00,0B800
	HC	0B408,0B409,0B40A,0B40B,0B40C,0B40D,0B40E,0B40F,0B410
	HC	0B411,0B412,0B413
	ELSE
B4CODE	HC	0B400,0B401,0B402,0B403,0B404,0B405,0,0,0,0AF00,0B800
	HC	0B408,0B409,0B40A,0B40B,0B40C,0B40D,0B40E,0B40F,0B410
	HC	0B411,0B412,0B413
	EI	:T2GATE

::*********************************************************************
::
::	SUBROUTINE:	DSITIL:
::	FUNCTION:	0312 - MESSAGE FOR TERMINAL IN LOGIN MODE.
::
::*********************************************************************

DSITIL	HS	0
	JAL	R8,GCI			:CODE BYTE
	LR	R7,R1			:SAVE IT
	NHI	R1,0E0			:ISOLATE SPECIAL BITS
	NHI	R7,1F			:ISOLATE CODE
	SIS	R7,8			:SUP CODES BEGIN WITH 8
	LHL	R7,B4CODE,R7,R7		:TRANSLATE FOR ISIS
	OR	R1,R7			:BLEND SPECIAL BITS BACK IN
	STH	R1,DIRNG-1,PRD,
	J	DISI90

	IF	1-T2GATE		:Gateway does not use the following
::*********************************************************************
::
::	SUBROUTINE:	DSINDP:
::	FUNCTION:	0310 - NEEDLE POINT
::
::*********************************************************************

DSINDP	HS	0
	LHL	R0,HNPORT		:INCREMENT NUMBER OF HOST PORTS IN USE
	AIS	R0,1
	CLH	R0,MXPORT		:IS THIS A NEW PEAK?
	JLEFS	DISNDX			:NO
	STH	R0,MXPORT		:YES, RECORD IT
DISNDX	STH	R0,HNPORT
	JAL	R8,NEDTIM,,		:COMPUTE NEEDLE TIME,
					: RECORD NEW CIRCUIT TIME
	LHI	R0,28
	JAL	R8,DIROOM		:SEE IF 28 BYTES AVAILABLE IN RING
	STH	CHN,DSICHN		:SAVE NEW NEEDLE CHN NUMBER
	LIS	R1,0			:SEND A TYPE '0'
	STB	R1,DIRNG-1,PRD,
	AIS	PRD,1			:SKIP ONE BYTE FOR LENGTH
	NR	PRD,TC			:WRAP RING POINTER IF NECESSARY
	JAL	R9,GCIE
	GL	GCIE
	JAL	R9,GCIE			:DISCARD BYTE AND LINK CNTS
	JAL	R9,GHWI
	GL	GHWI
	STH	R1,DIRNG,PRD,		:INVOICE # (ONE WORD LONG)
	JAL	R9,GHWI
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	JAL	R9,GHWI			:SAVE NEEDLE FLAGS
	STH	R1,DSINFL
	JAL	R9,GHWI			:SAVE CICUIT ORIGINATING NODE
	STH	R1,DSINOD
	JAL	R9,GHWI			:AND ORIGINATING PORT #
	STH	R1,DSIPRT
DSIND5	JAL	R9,GHWI			:SLEW OVER 'CREAMED' STUFF
	CI	R1,0FFFF
	JEBS	DSIND5			:.-0A
	NHI	R1,7FFF
	STH	R1,DIRNG,PRD,		:THIS IS DESTINATION HOST #
:	SAVE DESTINATION HOST FOR THIS CIRCUIT (CHN)
	STH	R1,DHSTIX,CHN,CHN	:SAVE FOR TRACE
	JAL	R8,GCI			:TID
	LR	R5,R1			:MUST HOLD IT

:	NEXT THREE BYTES MAY MEAN ONE OF TWO THINGS, DEPENDING ON VERSION OF
:	SUPERVISOR. 'OLD' SUP SENDS TWO BYTES C0C0!NODE-NUMBER (WHERE
:	NODE-NUMBER HAS 6 BITS IN LO-ORDER OF EACH BYTE) AND 1 BYTE
:	80!PORT-NUMBER. 'NEW' SUP SENDS ONE BYTE 80 FOLLOWED BY TWO
:	BYTES 8000!HOST-NUMBER. THE TEST FOR OLD OR NEW SUP IS IN THE
:	40 BIT OF THE FIRST BYTE - IF ZERO, ITS NEW SUP.

:	DELETE CODE TO HANDLE OLD SUP WHEN NEW SUP FULLY DEPLOYED!

	JAL	R9,GCIE			:GET FIRST BYTE AFTER TID AND
	LR	R6,R1			: SAVE IT
	JAL	R9,GHWI			:GET NEXT 2 BYTES
	THI	R6,40			:IF NEW SUP, R1 HAS CIRCUIT ORIG HOST #
	JE	DSINDO			:(DSINOD, DSIPRT ALREADY SET UP)

:	OLD SUP. GET CIRCUIT ORIGINATING NODE, PORT FROM 3 BYTES
:	FOLLOWING TID NSTEAD OF FIELDS IN NEEDLE. ORIGINATING HOST NOT
:	AVAILABLE, SET TO ZERO.
	LR	R0,R1
	EXBR	R6,R6
	SRLS	R6,2			:POSITION FIRST BYTE DATA AND
	NHI	R6,0FC0			: ISOLATE
	EXBR	R0,R0
	NHI	R0,3F
	OR	R6,R0			:COMBINE AND
	STH	R6,DSINOD		: SAVE
	NHI	R1,7F			:ISOLATE PORT NUMBER AND
	STH	R1,DSIPRT		: SAVE
	LIS	R1,0			:ORIGINATING HOST NOT KNOWN - SET TO 0
DSINDO	STH	R1,DSIHST		:SAVE ORIGINATING HOST NUMBER

	LHL	R1,DSINOD		:ORIGIN NODE
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	LHL	R0,DSIPRT		:ORIGIN PORT
	NHI	R0,7FFF			:STRIP HOB,JUST IN CASE,T-I FOR EXAMPLE
	CLHI	R1,MACHNM		:SET HI-ORD BIT IF INTERNAL CIRC
	JNFS	DSIND3
	CLHI	R0,DISZFL
	JLFS	DSIND3
	CLHI	R0,DISZFL+NDP
	JGEFS	DSIND3
	AHI	R0,8000-DISZFL		:IT IS INTERNAL CIRC, SET HI-ORD BIT
DSIND3	STH	R0,DIRNG+2,PRD, 	:ORIGINATING PORT NUMBER
	LHL	R0,DSIHST
	NHI	R0,7FFF			:STRIP HIGH-ORDER BIT		###GT
	STH	R0,DIRNG,PRD,		:CIRCUIT ORIGIN HOST NUMBER
	AIS	PRD,4
	NR	PRD,TC
	LIS	R0,0
	STH	R0,DIRNG,PRD,		:NEXT TWO BYTES UNUSED
	LHL	R1,DSINFL		:GET NEEDLE FLAGS AND
	NHI	R1,30			: ISOLATE GOUGING BITS
	SRLS	R1,4			:RIGHT-JUSTIFY GOUGING BITS AND
	OHI	R1,80			: OR WITH 80 TO INDICATE FIELD PRESENT
	STH	R1,DIRNG+2,PRD,		:STORE CIRCUIT GOUGING LEVEL
					: (THROUGHPUT CLASS)
	AIS	PRD,4
	NR	PRD,TC

:	TEST NEEDLE FLAGS TO SEE IF DESTINATION HOST IS 'SMART'. IF NF.SMC
:	BIT IN NEEDLE FLAGS IS SET, TURN ON HIGH-ORDER BIT OF DIALECT CODE FOR
:	SLOT.
	IF	MXPNM			:ISIS-MXP EXPECTS A NODE #IN THIS ###GT
	LHI	R0,MACHNM		:FIELD + 'I' BIT		###GT
	LHL	R1,DSINFL		:GET NEEDLE FLAGS		###GT
	THI	R1,NF.SMC		:SMART CIRCUIT?			###GT
	JEFS	DSND30			:NO, DUMB HOST OR NOT REQUESTED	###GT
	OHI	R0,8000			:INDICATE HIQ HOST		###GT
	ELSE				:NON-MXP			###GT
	LHL	R1,DSINFL		:GET NEEDLE FLAGS
	THI	R1,NF.SMC		:SMART CIRCUIT?
	JEFS	DSND30			:NO - DUMB HOST OR NOT REQUESTED...
	LHI	R0,8000			:INDICATE HIQ HOST
	EI	:MXPNM							###GT
DSND30	STH	R0,DIRNG,PRD,		:FORMERLY DIALECT CODE,
					: INDICATE HIQ HOST
	STB	R5,DIRNG+2,PRD,		:TID

	LR	R5,PRD			:SAVE THIS
	AIS	PRD,4
	NR	PRD,TC			:POINTS TO START OF USER NAME
	TS	DSITLG			:POSITIVE IF TRANSPARENT LOGIN
					: (ASSUME NOT)

	LIS	LRC,0			:COMPUTE LENGTH OF USER NAME
	JAL	R8,GCI			:GET 1ST CHAR (MIGHT BE "?" FOR
	CLHI	R1,0BF			: TRANSPARENT LOGIN)
	JN	DSIND4			:NOT A "?", SKIP IT
	STB	R1,DIRNG,PRD,		:SAVE THE "?"
	STH	R1,DSITLG		:FLAG AS TRANSPARENT LOGIN

	LHL	R1,DSINFL		:GET NEEDLE FLAGS AND
	SRLS	R1,4			: ISOLATE CIRCUIT SPEED BITS
	NHI	R1,3			: (ALSO KNOWN AS GOUGING BITS)
	AHI	R1,81			: CONVERT TO CTRL-A -> CTRL-D
	AIS	PRD,1			:BUMP RING POINTER
	NR	PRD,TC
	AIS	LRC,1			:INCLUDE GOUGING CHAR WE'RE INSERTING
	JFS	DSIND4
DSIND1	JAL	R8,GCI
DSIND4	AIS	LRC,1
	STB	R1,DIRNG,PRD,
	AIS	PRD,1
	NR	PRD,TC
	CLHI	R1,80!ASCSMC		:TERMINATOR? ASCII SEMI-COLON 0BB
	JEFS	DSIND2
	CLHI	R1,80!ASCCR		:TERMINATOR? ASCII CARRIAGE RETURN 8D
	JNBS	DSIND1
DSIND2	LR	R1,PRD
	SR	R1,R5			:LENGTH OF USER NAME
	SIS	R1,4
	NR 	R1,TC
	STB	R1,DIRNG+3,R5,		:SIZE OF USERNAME

:	IF THE SUPERVISOR SENDS AN ODD-LENGTH USER NAME, IT WILL PAD THE
:	USER NAME WITH AN ESCAPE CHARACTER FOR EVEN HALFWORD
:	ALIGNMENT. WE MUST STRIP THE ESCAPE CHARACTER FROM THE USER
:	NAME, IF PRESENT, BEFORE PASSING IT TO THE SLOT. IF THE LOGIN
:	IS TRANSPARENT, WE INSERTED A CHARACTER, AND MUST THEREFORE
:	TEST FOR AN EVEN LENGTH USER NAME INSTEAD OF ODD.
	TS	DSITLG			:IS THIS A TRANSPARENT LOGIN?
	JGFS	DIES10			:YES - EVEN LENGTH NEEDS ESCAPE REMOVED
	THI	R1,1			:NORMAL LOGIN - ODD LENGTH USER NAME?
	JE	DIESCX			:NO, EVEN LENGTH, NO ESCAPE REMOVAL
	JFS	DIES20			:YES - TOSS ESCAPE

DIES10	THI	R1,1			:TRANSPARENT LOGIN
					: - EVEN LENGTH USER NAME?
	JNFS	DIESCX			:NO - ESCAPE REMOVAL NOT REQUIRED

:	REMOVE ESCAPE FROM USER NAME
DIES20	LH	R0,BCT,R2,		:EXTRA CARE, NO
	JEFS	DIESCX			: GCI CRASH
	JAL	R8,GCI
	LR	R1,R1			:ESCAPED ESCAPE?
	JNFS	DIESCX			:NO
	JAL	R8,GCI

DIESCX	LHL	R5,RPSAV		:POINTS TO START OF MESSAGE
	LHI	LRC,-1,PRD
	NHI	LRC,DRSZ-4
	SR	LRC,R5
	NR	LRC,TC
	STB	LRC,DIRNG+3,R5,		:LENGTH
	AIS	PRD,3
	NHI	PRD,DRSZ-4
	LHL	CHN,DSICHN		:NEW NEEDLE CHN NUMBER
	JAL	R9,DIXCAP		:GIVE IT XMIT CAPACITY
	J	DISI90

::*********************************************************************
::
::	SUBROUTINE:	DSINDY:
::	FUNCTION:	0311  - NEEDLE EYE
::
::	NEEDLE EYE RECEIVED FROM LEP, INFORM REQUESTING SLOT THAT CIRCUIT
::	IS COMPLETE. SEND 0B6x0 MESSAGE IF NOT SMART CIRCUIT, ELSE 0B6x1. IF
::	THIS IS INTERNAL CIRCUIT, x IS 8 - OTHERWISE, x IS 0.
::
::*********************************************************************

DSINDY	HS	0
	JAL	R9,GHWI			:GET NEEDLE FLAGS
	LIS	R9,0
	LHR	R1,R1			:NEGATIVE IF NOT INTERNAL CIRCUIT
	JLFS	DSNY04
	AHI	R9,80			:INDICATE INTERNAL CIRC TO DISPATCHER
DSNY04	THI	R1,NF.SMC		:SMART CIRCUIT?
	JEFS	DSNY10			:NO
	AIS	R9,1			:YES - 0B6x1 BACK TO SLOT
DSNY10	LR	R6,R1			:SAVE NEEDLE FLAGS
	LHI	R1,0B600,R9
	STH	R1,DIRNG-1,PRD,		:'B6' + IIX, INTERNAL CIRC INDICATIONS
	IF	EXPNDL
	LI	R1,DIRNG-1,PRD		:save pointer in case IIX SNI in list
	ST	R1,SNFGSV,,
	EI	:EXPNDL
	AIS	PRD,1
	NR	PRD,TC			:FOLLOW W/ INVOICE #
	JAL	R9,GHWI
	STH	R1,DIRNG,PRD,
	JAL	R9,GHWI
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4			:advance ring ptr one word
	NR	PRD,TC
	LIS	R0,0
	ST	R0,DIRNG,PRD,		:ORIGIN HOST #
	AIS	PRD,4			:advance ring ptr another word
	NR	PRD,TC
	LR	R1,R6			:GET NEEDLE FLAGS BACK
	SRLS	R1,4			: AND ISOLATE SPEED BITS
	NHI	R1,3
	JAL	R9,DIXCAB		:GO TELL SLOT BACKPRESSURE LIMIT
					: (B9 msg)
	IF	EXPNDL
	THI	R6,NF.SNI		:does SNI list follow?
	JE	DSNY20
:	prepare to process SNI list
DSNY24	JAL	R8,GCI			:get SNI header
	LR	R8,R1			:get copy to destroy safely
	NHI	R8,0FF-SNITYP		:dispatch on high order six bits
	CLHI	R8,SNITRM		:end of list?
	JE	DSNY20			:yes--exit loop
	CLHI	R8,SNINOP
	JE	DSNY24			:NOP--get next list entry
	CLHI	R8,SNIMXS		:range check--too high?
	JGEFS	SNRSVD			:crash
:	list entry OK.  Go do it to it.
	L	R8,SNIDTB,R8		:dispatch entry
	JR	R8

SNRSVD	HS	0
	CRASH.(.SNICR)			:bad SNI received--crash

SNYUUN	HS	0			:send a 0C1 message to slot
	LR	R8,R1			:copy SNI header again
	NHI	R8,SNITYP		:R8 has message type (length indicator)
	CLHI	R8,SNTYP3		:UUN supports types 0,1,2 only
	JE	SNRSVD			:invalid type
	STH	CHN,DIRNG,PRD,		:insert port number in ring
	LHI	R1,UNUSNO		:message 0C100
	STH	R1,DIRNG+2,PRD,		:insert message indicator in ring
	AIS	PRD,4			:advance ring pointer one word
	NR	PRD,TC
:	this must be general enough to send slot a fullword
:	regardless of of length of UUN field from supervisor.
	LIS	R1,2			:number HW's of zeroes--2 HW's together
	SR	R1,R8			:for counting padding
	LR	R8,R1			:R8 now has (2 - type)
	JE	SYUU10			:type 2--read 2 HW's of UUN
	LIS	R1,0			:type 0 or 1 requires some 0-padding
	STH	R1,DIRNG,PRD,		:zero into slot
	SIS	R1,1			:was it type 0 or type 1?
	JEFS	SYUU20			:branch if type 1--have HW of UUN
	STH	R1,DIRNG+2,PRD,		:type 0--send UUN of zero
	AIS	PRD,4			:advance ring ptr one word
	NR	PRD,TC			:mask for wrap
	J	DSNY24			:and return for next SNI header
SYUU10	JAL	R9,GHWI			:type 2--get first HW of UUN
	STH	R1,DIRNG,PRD,		:and write to the slot
SYUU20	JAL	R9,GHWI			:get second HW of UUN
	STH	R1,DIRNG+2,PRD,		:and write to the slot
	AIS	PRD,4			:advance ptr one word
	NR	PRD,TC			:mask for wrap
	J	DSNY24			:return for next SNI header

SNYPRX	HS	0			:not supported yet
SNYLGC	HS	0			:to-sup only
SNYOHS	HS	0			:to-sup only
	J	SNRSVD			:crash

:	IIX indication could be sent either by means of this SNI
:	or in the old method of using the needle flags
SNYIIX	HS	0
	L	R1,SNFGSV,,		:points to B6-entry in ring
	LHL	R8,0,R1,
	OHI	R8,1			:set the IIX bit
	STH	R8,0,R1,
	J	DSNY24

::*********************************************************************
::
::	SNIDTB:	SNI Dispatch Table
::
::*********************************************************************

SNIDTB	WS	0		:###wjl
	WC	SNRSVD		:00--reserved
	WC	SNRSVD		:04--reserved
	WC	SNYUUN		:08--UUN
	WC	SNYPRX		:0C--proxy login token
	WC	SNYOHS		:10--origin host
	WC	SNYIIX		:14--IIX dialect
	WC	SNYLGC		:18--login characters
SNIMXS	EQ	.-SNIDTB	:maximum valid value

DSNY20	EI	:EXPNDL
	XHI	R2,4			:ENABLE NEEDLE TO TRAVEL
	JAL	R9,CRQALT,,		: BY ALERTING CRQ
	J	DISI90

::*********************************************************************
::
::	SUBROUTINE:	DSILRR
::	FUNCTION:	0313 - LOGIN ERROR
::			NODE CODE MSG 0313 ---> ISIS MSG   B5
::
::*********************************************************************

DSILRR	SIS	PRD,3			:LOGON FAILURE, SEND 'B5' MSG TO SLOT
	LHI	R1,0B500
	STH	R1,DIRNG+2,PRD,
	JAL	R8,GCI			:GET ERROR CODE
	NHI 	R1,ASC7BT		:STRIP OFF THE HOB (SET BY SUPERVISOR)
	STB	R1,DIRNG+3,PRD,		:AND MOVE INTO RING
	AIS	PRD,4
	NR	PRD,TC
	STH	CHN,DIRNG,PRD,		:FOLLOW WITH ZAPPER
	LHI	R1,09F00
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	SBT	CHN,DISZNK		:AWAITING ZAPPER ACK
	J	DISI90

	EI	:1-T2GATE		:End of Gateway non-use section

::*********************************************************************
::
::	SUBROUTINE:	DSINGZ:
::	FUNCTION:	0303 - NON-GOBBLING ZAPPER
::
::*********************************************************************

DSINGZ	HS	0
	IF	IDTACH			:ISIS Detach		###wjl
	SBT	CHN,DISZNK		:Indicates waiting for Zap Ack
	LHI	R1,ISDTCH		:Put Detach (9E) into ring
	J	DSIMES
	EI	:IDTACH			:else fall thru to Zap		###wjl

::*********************************************************************
::
::	SUBROUTINE:	DSIZAP
::	FUNCTION:	0301 - HARD ZAPPER
::			0302 - SOFT ZAPPER
::			0304 - FAT ZAPPER
::
::*********************************************************************

DSIZAP	SBT	CHN,DISZNK		:INDICATES WE'RE AWAITING ZAP ACK
	IF	T2GATE
	RBT	CHN,DISFLG		:Kludge fix for 3E63 crash (testing)
	EI	:T2GATE
	LHI	R1,ISZAPR		:PUT ZAPPER (09F) IN RING
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIGOB:
::	FUNCTION:	0308 - GOBBLER
::			NODE CODE MSG 0308 ---> ISIS MSG  0A2
::
::*********************************************************************

DSIGOB	LHI	R1,ISGBLR		:GOBBLER 0A2
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIRBL:
::	FUNCTION:	06 - RED BALL
::			NODE CODE MSG 06 ---> ISIS MSG 0AA
::
::*********************************************************************

DSIRBL	LHI	R1,ISRDBL		:RED BALL 0AB
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIGBL:
::	FUNCTION:	05 - GREEN BALL
::			NODE CODE MSG 05 ---> ISIS MSG 0AA
::
::*********************************************************************

DSIGBL	LHI	R1,ISGRBL		:GREEN BALL 0AA
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIEDM:
::	FUNCTION:	07 - ENTER DEM
::			NODE CODE MSG 07 --->  ISIS MSG 0A6
::
::*********************************************************************

DSIEDM	LHI	R1,ISEDEM		:EDEM 0A6
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSILDM:
::	FUNCTION:	04 - LEAVE DEM
::			NODE CODE MSG 04 --->  ISIS MSG 0A7
::
::*********************************************************************

DSILDM	LHI	R1,ISLDEM		:LDEM 0A7
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSITMC
::	FUNCTION:	HANDLE 01 CONTROL PAIRS
::
::*********************************************************************

DSITMC	JAL	R8,GCI			:01 PAIR, GET SECOND CHAR
	LR	R4,R1			:SAVE SECOND BYTE
	SRHLS	R1,4			:DISPATCH ON HI-ORDER 4 BITS
	LHL	R3,DSITMP,R1,R1
	SIS	PRD,3			:BACK UP POINTER
	J	SEG1,R3,

::*********************************************************************
::
::	TABLE:		DSITMP:
::	FUNCTION:	01 CONTROL PAIRS DISPATCH TABLE
::
::*********************************************************************

	NOLIST
DSITMP	HC	DSIT08-SEG1,DSIT08-SEG1,DSIT08-SEG1,DSIT08-SEG1
	HC	DSIT08-SEG1,DSIT08-SEG1,DSIT08-SEG1,DSIT08-SEG1
	HC	DSIT08-SEG1,DSIT09-SEG1,DSIT0A-SEG1,DSIT0A-SEG1
	HC	DSIT0C-SEG1,DSIT0C-SEG1,DSINXT-SEG1,DSIT0F-SEG1
	LIST

::*********************************************************************
::
::	SUBROUTINE:	DSIT08
::	FUNCTION:	HANDLE 010x, 011x, 012x, 013x, 014x, 015x, 016x,
::			017x, AND 018x CONTROL PAIRS
::
::*********************************************************************

DSIT08	LB	R3,DTM08,R1		:HERE FOR TYPES 0 - 8
DSIT8A	LB	R0,DTM80,R3		:R3 IS PTR TO SECOND TABLE
	THI	R0,80			:IF 80, WERE DONE
	JN	DISI90
	NR	R0,R4			:R0 IS TRUNCATED VALUE
	LB	R1,DTM80+1,R3		:R1 IS SHIFT COUNT FOR R4
	SRHL	R4,0,R1
	LB	R1,DTM80+2,R3		:R1 IS ISIS CODE # (N)
	EXBR	R0,R0
	AR	R0,R1
	JAL	R10,DSITSM		:SEND B1 MESSAGE
	AIS	R3,3
	J	DSIT8A			:AND REPEAT

:	IN THE FOLLOWING TABLE EACH ENTRY CONSISTS OF 3 1-BYTE ELEMENTS:
:	BYTE 1 - MASK FOR INCOMING DATA
:	BYTE 2 - NUMBER OF BITS TO SHIFT
:	BYTE 3 - THE ISIS-II MESSAGE NUMBER

:	EACH ARRAY IS COMPOSED OF AN INTEGRAL NUMBER OF 3-BYTE ENTRIES,
:	AND IS TERMINATED WITH AN '80'.
:	Each triple in the array describes how to process the
:	corresponding subfield, described by the "mask" entry, of the
:	"x" listed below.
:	See CIRCUIT PROTOCOL document, App. I, for description of these
:	messages.

DTM80	BC	1,1,3,1,1,2,1,1,1,1,1,0,80	:for 010x pairs
DTM81	BC	7,3,5,1,1,4,80			:for 011x pairs
DTM82	BC	1,1,7,7,3,6,80			:for 012x pairs
DTM83	BC	7,3,5,80			:for 013x pairs
DTM84	BC	1,1,0A,7,3,0A,80		:for 014x pairs
DTM85	BC	0F,4,0B,80			:for 015x pairs
DTM86	BC	0F,4,0A,80			:for 016x pairs
DTM87	BC	0F,4,9,80			:for 017x pairs
DTM88	BC	0F,4,6,80			:for 018x pairs
Q	EQ	DTM80
DTM08	BC	DTM80-Q,DTM81-Q,DTM82-Q,DTM83-Q
	BC	DTM84-Q,DTM85-Q,DTM86-Q,DTM87-Q,DTM88-Q

::*********************************************************************
::
::	SUBROUTINE:	DSIT09:
::	FUNCTION:	HANDLE 019x CONTROL PAIRS
::
::*********************************************************************

DSIT09	LIS	R1,0F			:TYPE 9 - RANDOM BULLSHIT
	NR	R1,4
	LB	R3,DTM09,R1		:POINTS TO LIST OF CODES
DSIT9A	LB	R0,DTM90,R3		:POINTS TO CODE BYTE
	THI	R0,80
	JN	DISI90
	JAL	R10,DSITQM		:SEND MESSAGE
	AIS	R3,1
	J	DSIT9A

DTM90	BC	3,2,1,0,80
DTM91	BC	4,5,80
DTM92	BC	6,7,80
DTM93	BC	9,8,80
DTM94	BC	0A,80
DTM95	BC	0B,80
DTM96	BC	0A,80
DTM97	BC	9,80
DTM98	BC	6,80

Q	EQ	DTM90
DTM09	BC	DTM90-Q,DTM91-Q,DTM92-Q,DTM93-Q
	BC	DTM94-Q,DTM95-Q,DTM96-Q,DTM97-Q,DTM98-Q

::*********************************************************************
::
::	SUBROUTINE:	DSIT0A:
::	FUNCTION:	HANDLE 01Ax, 01Bx CONTROL PAIRS.
::	
::*********************************************************************

DSIT0A	SRHLS	R4,1			:TYPE A - QUERY BITS
	NHI	R4,0F
	LB	R0,DTM0A,R4		:GET CODE
	JAL	R10,DSITQM
	J	DISI90

:	THIS TABLE IS ARRANGED IN 'NETWORK MESSAGE' ORDER TO CONVERT TO ISIS
DTM0A	BC	0,1,3,2,8,7,0C,4,0D,0E,10,11,12,13,0,0

::*********************************************************************
::
::	SUBROUTINE:	DSIT0C:
::	FUNCTION:	HANDLE 01Cx, 01Dx CONTROL PAIRS.
::
::*********************************************************************

DSIT0C	LIS	R1,R1			:TYPE C - SET/RESET BIT PARAMETER
	NR	R1,R4			:BIT VALUE (0/1) IN R1
	SRHLS	R4,1
	NHI	R4,0F
	LB	R0,DTM0A,R4		:CODE ('N') IN RIGHT BYTE
	EXBR	R1,R1
	AR	R0,R1
	JAL	R10,DSITSM		:send a B1 message
	J	DISI90

::*********************************************************************
::
::	SUBROUTINE:	DSIT0F:
::	FUNCTION:	HANDLE 01Fx CONTROL PAIRS
::
::*********************************************************************

DSIT0F	NHI	R4,0F			:TYPE F - BALLS
	LB	R1,DTM0F,R4
	AIS	PRD,3
	CLHI	R4,01			:IS IT HANG OR HDX HANG?
	JG	DSIMES			:NO
	SBT	CHN,DISHNG		:YES - REMEMBER WE SENT IT (INFO ONLY)
	J	DSIMES

::*********************************************************************
::
::	TABLE:		DTM0F:
::	FUNCTION:	TRANSLATE NODE CODE 01Fx PAIRS TO ISIS MSG
::
::*********************************************************************

DTM0F	BC	0AF	:F0 - HANG UP
	BC	0B8	:F1 - HDUX HANG
	BC	0A8	:F2 - ENTER TRANSPARENCY
	BC	0A9	:F3 - LEAVE DITTO
	BC	0BC	:F4 - ENTER ALTERNATE DEVICE MODE
	BC	0BD	:F5 - LEAVE ALTERNATE DEVICE MODE
	BC	0BF	:F6 - ENTER IIX EXCHANGE
	BC	0C0	:F7 - LEAVE IIX EXCHANGE
	BC	0,0,0	:F8 - FA - ZIP
	BC	0AE	:FB - BREAK
	BC	0A5	:FC - GREY BALL
	BC	0A4	:FD - BLACK "
	BC	0AD	:FE - ORANGE "
	BC	0AC	:FF - YELLOW

::*********************************************************************
::
::	SUBROUTINE:	DSIMES:
::	FUNCTION:	PUTS UP TO 3 CHARS IN RING.
::
::*********************************************************************

DSIMES	SIS	PRD,1			:PUTS UP TO 3 CHARS IN RING...
	NR	PRD,TC			:FIRST ONE IS TYPE
	LIS	LRC,0
	LR	R1,R1
DSIME1	JE	DISI90
	STB	R1,DIRNG,PRD,
	AIS	PRD,1
	NR	PRD,TC
	AIS	LRC,1
	SRHLS	R1,8
	JNBS	DSIME1
	J	DISI90

::*********************************************************************
::
::	SUBROUTINE:	DSITSM:
::	FUNCTION:	SEND SET PARAMETER MESSAGE
::
::*********************************************************************

:	sends:  chn, count, /B1/N/, /value/, where "/"'s enclose bytes
DSITSM	STH	CHN,DIRNG,PRD,		:SEND SET PARAM MESSAGE
	LHI	R1,ISSPRM		:SEND ISIS SET PARAMETER (0B1)
	STB	R1,DIRNG+2,PRD,		:PUT IT IN THE RING
	STB	R0,DIRNG+3,PRD,		:VALUE/'N' IN R0
	AIS	PRD,4			:advance the ring pointer a Wordsworth
	NR	PRD,TC			:check for ring wrap
	EXBR	R0,0			:get the second byte
	STB	R0,DIRNG,PRD,		:put it in the ring
	AIS	PRD,4			:advance another Wordsworth
	NR	PRD,TC			:check for another wrap
	JR	R10			:and blow this scene

::*********************************************************************
::
::	SUBROUTINE:	DSITQM:
::	FUNCTION:	SEND QUERY PARAMETER MESSAGE
::
::*********************************************************************

DSITQM	STH	CHN,DIRNG,PRD,		:SEND QUERY PARAM MESSAGE
	LHI	R1,ISQPRM		:ISIS QUERY PARAMETER (0B0)
	STB	R1,DIRNG+2,PRD,
	STB	R0,DIRNG+3,PRD,		:'N' IN R0
	AIS	PRD,4
	NR	PRD,TC
	JR	R10

::*********************************************************************
::
::	TABLE:		DSITAB:
::	FUNCTION:	NETWORK CONTROL CODES DISPATCH TABLE
::
::*********************************************************************

DSITAB	HC	DSINXT-SEG1,DSITMC-SEG1,DSINXT-SEG1,DSITII-SEG1
	HC	DSILDM-SEG1,DSIGBL-SEG1,DSIRBL-SEG1,DSIEDM-SEG1

	SUBTTL	DISPI (DISOUT - Move data out of dispatcher into network)

::*********************************************************************
::
::	SUBPROCESS:	DISOUT:
::	FUNCTION:	MOVES DATA FROM DISPATCHER INTO NETWORK
::	CALLING SEQ:	JAL	R10,DISOUT
::
::*********************************************************************

DISOUT	ST	R10,DSSVRT		:SAVE RETURN
:	DON'T SPEND FOREVER EMPTYING DISPATCHER RING. DIDTIM WILL CONTAIN
:	FASTC TIME TO RETURN BACK TO SPIDER EVEN IF WORK IS LEFT OVER.
	L	R0,FASTC,,
	AHI	R0,RATE/10		:1/16TH SECOND MAX
	ST	R0,DIDTIM

:	RETURN HERE AFTER SERVICING EACH CHANNEL, AND YIELD EITHER IF
:	HIGHER PRIORITY TASK HAS BEEN SCHEDULED, OR IF OUR TIME SLICE UP.
DSONXT	HS	0
	JAL	R0,EXYLD,,
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR DISOUT	###OAS
	CPUTNM(DISOUT)			:DEFINE CPUTIL ENTRY FOR DISOUT	###OAS
	EI	:DB.CPU
	L	R0,DIDTIM		:GET TIME TO DISMISS
	S	R0,FASTC,,		:LATER THAN CURRENT TIME?
	JGFS	DSONX1			:YES, CONTINUE EMPTYING DISPATCHER RING
	LIS	R0,1			:NO - COUNT NUMBER OF FORCED DISMISSES
	AHM	R0,DODISM
	J	DSIORT			:RETURN TO SPIDER

DSONX1	LIS	TYC,7			:SET CONSTANTS
	LHI	TC,DRSZ-1
	LHL	PRD,DROE,,		:COMPUTE # CHARS TO MOVE OUT OF DISPI
	LHL	PRC,DROF,,
	SR	PRC,PRD			:DROF - DROE
	NR	PRC,TC
	JE	DSIORT			:ALL DONE, DORNG  IS EMPTY

	LHL	CHN,DORNG,PRD,		:CHANNEL #  (RPORT)

:	INTRA-ISIS COMUNICATIONS, IF RPORT IS ZERO.
	JE	DSZERO			:SPECIAL CONTROL CHANNEL

:	FOR ALL RPORT IS NOT ZERO
	CLHI	CHN,NDP			:CHN = REL DISPI CHN #
	JLFS	DISO02			:VALID DISPATCHER PORTS ONLY
	CRASH.(.DISO0)
DISO02	LHL	R2,DIOTAB,CHN,CHN	:GET DISPI OUTBOUND BUFFER #
	NHI	R2,-4			:STRIP GOUGING BITS FROM BUFFER #
	JNFS	DISO04			:GO AHEAD, THE CIRCUIT IS THERE

	JAL	R8,DISKIP		:SKIP OVER DATA
					: ON UNASSIGNED DISPATCHER PORT
	J	DSONXT			:PROCESS NEXT CHANNEL

DISO04	LB	LRC,DORNG+2,PRD,	:CHARACTER COUNT (TYPE)
	AIS	PRD,3
	NR	PRD,TC			:POINTS TO LAST BYTE OF WORD
	LHI	R1,-9E,LRC		:IS IT DATA

:	IT IS CONTROL MESSAGE, IF TYPE >= 9E
	JGE	DSOCTL			:NO, CONTROL MESSAGE

:	IT IS DATA ONLY, IF TYPE <= 9D
	LR	CD,LRC			:MOVE THESE MANY

	IF	T2GATE
	IF	ACCT
::Accounting here so we get only data characters
	TBT	CHN,GORGPT		:Should we count these ? 
	JN	GLCH02			:This is an origin port - no count
	LR	R0,LRC			:Get count
	LR	R3,CHN			:Move Channel # to work reg
	AHI	R3,DISZFL		:Get absolute channel number
	SHI	R3,MNACHN		:Make an accounting index
	JAL	R8,AARDOC,,		:Now add to accumulator
	GL	AARDOC
	LIS	TYC,07			:This reg was getting clobbered	###ev
GLCH02
	EI	:ACCT
	EI	:T2GATE

:	LOOP TO MOVE DATA FROM DORING TO BUFFER
DISO1	LB	R1,DORNG,PRD,		:MOVE DATA FROM DORING
	AIS	PRD,1
	NR	PRD,TC			:INCREMENT RING POINTER
GDS01	CR	R1,TYC			:DO WE NEED TO ESCAPE?
	JGFS	DISO2			:NO - NORMAL DATA CHARACTER
	EXBR	R1,R1			:YES, PRECEDE WITH ESC CHAR (00)
	JAL 	R8,WCI
	EXBR	R1,R1
	AIS	LRC,1
DISO2	JAL	R8,WCI			:WRITE CHARACTER INTO BUFFER
	SIS	CD,1			:DONE?
	JGBS	DISO1			:NO - CONTINUE

	LHL	R1,DIOTAB,CHN,CHN	:SET BACKPRESSURE IF NEEDED
	NHI	R1,3			:READ GOUGING LEVEL BITS FROM IOTAB
	LHL	R0,BCT,R2,		:READ BCT FOR THE BUFFER
	CLH	R0,CIRSPK,R1,R1		:COMPARE BCT WITH GOUGING LEVEL MAX
	JLFS	DSOTBP			:IF BCT LESS THEN NO BP MSG TO ISIS

:	WE'VE MOVED MORE THAN BP MAX
	RBT	CHN,DISBPX		:ELSE WE'VE MOVED MORE THAN BP MAX
	LIS	R0,4			:WAIT FOR ROOM IN ISIS INPUT RING
	JAL	R8,DIROOM
	LHI	R1,SDSPBP		:SEND ONE WORD MSG TO ISIS--SET BP
	JAL	R8,DIRMES

DSOTBP	AHM	LRC,DISOCC		:INC CHAR COUNT
DSOIRP	AIS	PRD,3			:TRUNCATE POINTER
	NHI	PRD,DRSZ-4
	STH	PRD,DROE,,
	J	DSONXT			:REPEAT

::*********************************************************************
::
::	SUBROUTINE:	DSOCTL:
::	FUNCTION:	HANDLE ISIS CONTROL MESSAGES  ( >= 9E )
::
::*********************************************************************

DSOCTL	LIS	LRC,0
	CLHI	R1,DSODMX		:IF TYPE > MAX...
	JLFS	DSOCT2
DSOCRH	HS	0
	CRASH.(.DSOC0)
DSOCT2	TBT	R1,DSOMBA		:1=EASY, 0=HARD TO CONVERT
	JE	DSOCT1			:HARD, FANOUT BY TYPE##AL

:	EASY TO CONVERT
	LHL	R1,DSOMTB,R1,R1		:TRANSLATE THE REST

	IF	T2GATE
	TBT	CHN,LOGING		:For Gateway, login  handler
	JE	DSOMS1			:Not log-in - just proceed
	CLHI	R1,05			:Is a green ball
	JE	GDCM01			:Yes
	CLHI	R1,06			:Is a red ball
	JE	GDCM01			:Yes
	CI	R1,0FF01		:Or a yellow ball	###jk
	JE	GDCM02
DSOMS1	LR	R1,R1
	EI	:(T2GATE)

DSOMES	JE	DSOTBP			:ALL DONE
	JAL	R8,WCI
	SRHLS	R1,8
	JBS	DSOMES

	IF	T2GATE
GDCM01	XHI	R2,4			:Flip to terminal bound buffer
	JAL	R8,WCI			:And bounce it
	XHI	R2,4			:Return to net bound buffer
	J	DSOTBP
GDCM02	XHI	R2,4			:Flip again
	LHI	R1,01
	JAL	R8,WCI
	LHI	R1,0FE
	JAL	R8,WCI			:bounce orange ball
	XHI	R2,4			:Flip back
	J	DSOTBP
	EI	:(T2GATE)

:	DISPATCH ON TYPE
DSOCT1	LHL	R1,DSOMTB,R1,R1	
	J	SEG1,R1,

::*********************************************************************
::
::	SUBROUTINE:	DSODET:
::	FUNCTION:	9E  -  DETACH
::
::*********************************************************************

DSODET	HS	0
	IF	IDTACH			:ISIS Detach			###wjl
	IF	T2GATE
	JAL	R8,GBYHOM
	EI	:T2GATE
	LHL	R0,BF,R2,		:ZAPPER
	JE	DSOIRP			:IGNORE IF WAITING FOR ZAK
	RBT	CHN,DISHNG		:IF WE SENT HANG, ZAPPER CLEARS
	LHI	R1,ZAPPN		:Non-Gobbling Zapper (0303)
	JAL	R9,ZAPXN,,		:ZAP circuit, do not CBCLR
	GL	ZAPXN
	J	DSOZ10			:GO CLEAR HOST ENTRY,
					: DECREMENT PORT COUNT
	ELSE	:not IDTACH
	J	DSOIRP
	EI	:IDTACH	###wjl

::*********************************************************************
::
::	SUBROUTINE:	DSOZAP:
::	FUNCTION:	9F - ZAPPER
::
::*********************************************************************

DSOZAP	LHL	R0,BF,R2,		:ZAPPER
	JE	DSOIRP			:IGNORE IF WAITING FOR ZAK
	RBT	CHN,DISHNG		:IF WE SENT HANG, ZAPPER CLEARS

	IF	T2GATE
	TBT	CHN,LOGING
	JN	GSOZA5
	TBT	CHN,GDSTPT
	JE	GSOZA4
	LHI	R1,AALR02		:Log out by host
	STH	R1,AAREAS,,		:Store reason for accounting	
	JAL	R8,GBYHOM		:Send "inter-link cleared" if appr.

	LR	R4,CHN
	JAL	R10,GSOZW7
	J	GSOZA6			:PORT DETATCHED
GSOZA4	LIS	R1,0
	STH	R1,AAREAS,,		:Zap not counted if origin port
GSOZA5	JAL	R9,ZAPHRD,,		:NOT DETATCHED MUST HARD ZAP
GSOZA6	HS	0
	ELSE	:NOT T2GATE
	JAL	R9,ZAPHRD,,		:ZAP
	EI	:T2GATE
	J	DSOZ10			:GO CLEAR HOST ENTRY,
					: DECREMENT PORT COUNT

::*********************************************************************
::
::	SUBROUTINE:	DSOZAK:
::	FUNCTION:	BB - ZAP ACK
::
::*********************************************************************

DSOZAK	HS	0
	IF	T2GATE
	TBT	CHN,DISZNK		:Should be zero if log-in mode
	JN	DSOZ05
	JAL	R9,GLZPV,,
	GL	GLZPV
	JFS	DSOZ10
	EI	:T2GATE


DSOZ05	XHI	R2,4			:FLIP TO INBOUND BUFFER INDEX AND
	JAL	R9,ZAPV,,		: ZAP SECOND HALF OF CIRCUIT
	RBT	CHN,DISZNK		:NO LONGER AWAITING ZAPPER ACK

DSOZ10	HS	0
	IF	T2GATE
	RBT	CHN,LOGING		:Disable possible login service
	RBT	CHN,DISFLG		:Kludge fix for 3E63 crash
	EI	:T2GATE			:###ev
	LCS	R0,1
	AHM	R0,HNPORT		:DECREMENT HOST PORT COUNT
	STH	R0,DHSTIX,CHN,CHN	:CLEAR HOST ENTRY (-1 INDICATES ITS
					:BEEN USED BEFORE, 0 FOR NEVER USED)
	J	DSOIRP			:DONE

::*********************************************************************
::
::	SUBROUTINE:	DSOGOB:
::	FUNCTION:	A2 - GOBBLER
::
::*********************************************************************

DSOGOB	JAL	R9,GOBBLN,,		:GOBBLER, DON'T GOBBLE NEEDLE
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOSXL:
::	FUNCTION:	B9 - SET XMT LIMIT
::
::*********************************************************************

DSOSXL	LB	R1,DORNG,PRD,		:SET XMIT LIMIT
	STH	R1,DIXLIM,CHN,CHN
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOQPR:
::	FUNCTION:	B0 - QUERY FIELD PARAMETER
::
::*********************************************************************

DSOQPR	LB	R1,DORNG,PRD,		:QUERY FIELD PARAMETER
	NHI	R1,1F
	LB	R1,TQPR,R1		:GET SECOND BYTE OF CORRESPONDING...
	JE	DSOTBP			:DON'T SEND OUT 01-00 PAIRS	###GT
DSOQP1	EXBR	R1,R1			:...01 PAIR
	AIS	R1,1
	J	DSOMES			:SEND PAIR

::*********************************************************************
::
::	SUBROUTINE:	DSOSPR:
::	FUNCTION:	B1 - SET FIELD PARAMETER
::
::*********************************************************************

DSOSPR	LB	R1,DORNG,PRD,		:SET FIELD PARAMETER
	AIS	PRD,1
	NR	PRD,TC
	LB	R0,DORNG,PRD,		:FIELD VALUE
	AIS	PRD,4
	NR	PRD,TC
	NHI	R1,1F			:RESTRICT INDEX (0-31d)
	CLHI	R1,5			:TEST FOR B1/05 MSG
					: (SET INPUT BAUD RATE) AND BYPASS DUE
	JE	DSOTBP			: TO AMBIGUOUS TREATMENT BY TYMSATS
	LB	R4,TSPRM,R1		:GET THE VALUE MASK
	NR	R0,R4			:PREVENTS FIELD OVERFLOW
	LB	R1,TSPR,R1		:SECOND BYTE OF 01 PAIR
	JE	DSOTBP			:DON'T SEND OUT 01-00 PAIRS	###GT
	OR	R1,R0			:INSERT VALUE
	J	DSOQP1			:SEND PAIR

::*********************************************************************
::
::	SUBROUTINE:	DSORBP:
::	FUNCTION:	A1 - RELEASE BACKPRESSURE
::
::*********************************************************************

DSORBP	SBT	CHN,DISBPV		:RELEASE BACKPRESSURE
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOSBP:
::	FUNCTION:	A0 - SET BACKPRESSURE
::
::*********************************************************************

DSOSBP	RBT	CHN,DISBPV		:SET BACKPRESSURE
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOHNG:
::	FUNCTION:	B8 - SUPER HANG CHAR PAIR
::
::*********************************************************************
DSOHNG	LI	R1,0F101		:SUPERHANG CHAR PAIR
	IF	T2GATE
	JAL	R9,GDOMES		:Forward it
	LHI	R1,09F00
	JAL	R8,DIRMES		:but Zap circuit backwards
	RBT	CHN,DISZNK
	RBT	CHN,LOGING
	RBT	CHN,DISFLG
	LA	R4,EXMG1,,
	JAL	R9,BUFCAN,,		:Send "pls see yr rep"
	TBT	CHN,GTTRNS
	JN	GDSOH4
	LA	R4,GNGONE,,		:if not Xparent, "inter link cleared"
	JAL	R9,BUFCAN,,
	ROUTE(HOMEN,ISISN)
	LA	R4,CRLF
	JAL	R9,BUFCAN
GDSOH4	LHI	R1,ZAPPN		:then Non Gobbling Zapper forward
	JAL	R9,ZAPX,,
	J	DSOTBP			:next port
	ELSE	:NOT T2GATE
	J	DSOMES			:otherwise send it and continue
	EI	:T2GATE
::**********************************************************************
::
::		Miscellaneous Gateway Utility routines
::		GDOMES:	GBYHOM:
	IF	T2GATE
GDOMES	HS	0
	LR	R1,R1
GDOM1	JE	GDOM8
	JAL	R8,WCI
	SRHLS	R1,8
	JBS	GDOM1
GDOM8	JR	R9
::********************
GBYHOM	HS	0
	ST	R8,GDSAVE		:Save return 
	TBT	CHN,GORGPT		:Should be destination
	JE	GBYSKP			:from terminal and
	TBT	CHN,LOGING		:not in log-in mode and
	JN	GBYSKP			:not a transparent circuit
	TBT	CHN,GTTRNS		:if we're going to send the
	JN	GBYSKP			:"inter-link cleared" message
	LA	R4,GNGONE,,		:back to the terminal
	JAL	R9,BUFCAN,,
	ROUTE(HOMEN,ISISN)
	LA	R4,CRLF	
	JAL	R9,BUFCAN,,
	L	R8,GDSAVE
GBYSKP	JR	R8
::********************
:	DETACH CIRCUIT. REMOVE DISPATCHER PERMUTER TABLE ENTRY FROM DIOTAB,
:	FIND AVAILABLE CHANNEL TO DISPATCH PROCESS IN CIOTAB (STARTING WITH
:	DETZFL). CONNECT NETWORK HALF-CIRCUIT TO DETACH PROCESS FOR SENDING
:	APPROPRIATE TEXT TO USER, BOUNCING YELLOW BALL, AND TIMING OUT CIRCUIT
:	IF NO ORANGE BALL RETURNED.
GSOZW7	HS	0			:DONE WITH ACCT. DETACH PORT
	LHL	R2,DIOTAB,R4,R4		:GET EXISTING PERMUTER TABLE ENTRY TO
	NHI	R2,-4			: MOVE TO CIOTAB.
:	FIND NEXT AVAILABLE CHANNEL TO DETACH PROCESS...
	L	R4,DETACP,,		:DETACH PORT AVAILABLE ?
	JFFO	R4,GSOZW8		:FOUND ONE
	J	4,R10			:NO DETACH PORTS, ZAP CIRC TO NETWORK

GSOZW8	HS	0
:	CAUSE ZAPX TO PUT CR/LF INTO BUFFER INSTEAD OF ZAPPER. THIS WILL
:	CAUSE DISPATCHER PORT TO BE FREED UP WITHOUT ZAPPING EXISTING CIRCUIT.
	LHI	R1,0D0A			:MAKE ZAPX PUT 'CRLF' INTO BUFFER
	JAL	R9,ZAPX,,		:'ZAP' THE DISPI SIDE OF CIR.
	GL	ZAPX
	LIS	R0,8			:Load "inter-link cleared" message
	STB	R0,DETMTY,CHN		:and store for Detatch process
	AHI	CHN,DETZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER AND
	JAL	R9,CRQHCR,,		:BUILD 2ND HALF OF CKT TO DETACH PROCES
:	SEND NEEDLE POINT TO DETACH PROCESS TO ALERT IT TO NEW PORT.
	XHI	R2,4			:INDEX FOR BUFF TOWARDS DETACH PROCESS
	LIS	R1,3
	JAL	R8,WCI
	LHI	R1,NEEDP
	JAL	R8,WCI			:WRITE NEEDLE POINT IN BUFFER
        SHI     CHN,DETZFL              :restore channel number ##sdw
	JR	R10				:CONTINUE

	EI	:T2GATE

	IF	1-T2GATE		:Gateway does not get B3 chars
::*********************************************************************
::
::	SUBROUTINE:	DSOLGC:
::	FUNCTION:	B3 - LOGON CHAR
::
::*********************************************************************

DSOLGC	HS	0			:PROCESS LOGON CHARACTER
	LB	R1,DORNG,PRD,		:GET LOGON CHARACTER FOR LOGCHR
	JAL	R11,LOGCHR		:JUMP TO LOGIN CHAR PROCESSING ROUTINE
	J	DSOLG1			:RETURNS HERE IF PORT NOT IN LOGIN MODE
	J	DSOLG3			:RETURNS HERE IF LOGIN BUFFER FULL
	J	DSOTBP			:RETURNS HERE IF ALL IS WELL

:	GOT LOGIN CHARACTER FROM DISPATCHER PORT NOT IN LOGIN MODE.
:	COUNT OCCURRENCE, AND UPDATE RING POINTER PAST ILLEGAL MESSAGE.
DSOLG1	LIS	R0,1
	AHM	R0,DOILLG		:NUMBER OF ILLEGAL LOGIN CHARACTERS
	J	DSOIRP			:BYPASS THIS MESSAGE

:	LOGIN BUFFER FULL. SEND USER 'TOO MANY CHARS' MSG AND 'PLS  SEE REP'
:	MESSAGE AND HANG PORT
DSOLG3	HS	0
	LIS	R0,4			:SEND 'SUPER HANG' (FOR HDX TERMS)
	JAL	R8,DIROOM
	LHL	R10,DRIF,,
	STH	CHN,DIRNG,R10,
	LHI	R0,0B800		:PORT # + SUPER HANG
	STH	R0,DIRNG+2,R10,
	AIS	R10,4
	NR	R10,TC
	STH	R10,DRIF,,
	LA	R1,FULMSG		:BUFFER FILLED MESSAGE
	JAL	R8,DIMMES		:TELL USER
	LA	R1,EXMG1		:SEND PLS SEE REPRES... MSG
	JAL	R8,DIMMES		: TO USER
	LIS	R0,4			:SEND HANG
	JAL	R8,DIROOM
	LHL	R10,DRIF,,
	STH	CHN,DIRNG,R10,
	LHI	R0,0AF00		:PORT # + HANG
	STH	R0,DIRNG+2,R10,
	AIS	R10,4
	NR	R10,TC
	STH	R10,DRIF,,
	J	DSOTBP			:CONTINUE
	EI	:1-T2GATE

::*********************************************************************
::
::	SUBROUTINE:	DSOZWR:
::	FUNCTION:	BE - ZAP WITH REASON
::
::	REASON 0 = HOST OUT OF PORTS
::	INPUT MESSAGE FORMAT:
::		|PORT...! BE :REASON|{0000! 05 : -- |7MG,VALUE..|}
::
::	FOR THE NEW ISIS, CHECK THAT REASON IS REALLY 0, AND DO
:: 	NOT ASSUME THAT ACCOUNTING MESSAGE FOLLOWS IMMEDIATELY,
::	CHECK HOST RELATED ERRORS, SEND MESSAGE TO ERROR LOGGER
::	BUT DO NOT SEND ACCOUNTING MESSAGES.
::
::*********************************************************************

DSOZWR	HS	0			:ZAP WITH REASON
	LR	R4,CHN			:SAVE 'OLD' CHAN #
	LB	R0,DORNG,PRD,		:GET THE REASON FOR THIS ZAP
	JE	DSOZW2			:ZERO IS OK

:	DISPLAY ERROR IN CRYPTO LOG

	JAL	R8,CRYPTO,,		:LOG THIS REASON AS AN ERROR
	HC	CRYE73
	J	DSOIRP			:AND IGNORE THE MESSAGE

DSOZW2	HS	0	:FIND HOST NUMBER TO CHECK FOR REALLY OUT OF PORTS
	LHL	R1,DHSTIX,R4,R4		:GET HOST NUMBER
	JAL	R9,FNDHST,,		:FIND HOST INDEX (HN)
	GL	FNDHST
	J	DSOZW7			:NO HOST, ASSUME PORTS REPORTED 'FULL'
	LHL	R0,HSTPTA,HN,HN		:PORTS REPORTED AS FULL?
	JE	DSOZW7			:YES
:	NO--SEND NODE REPORT
	STH	R0,SUPMBF+2		:# OF PORTS REPORTED AVAIL LAST
	LIS	R0,0			:SET PORT ARRAY TO 0
	STH	R0,HSTPTA,HN,HN		: (THAT'S WHAT WE'RE TELLING SUP)

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R0,EHHOPT		:set host out of ports bit
	STB	R0,HSTATN,HN		:TO INDICATE OUT OF PORTS	###OAS

	LHI	R0,NR.NRJ		:NEEDLE REJECT (HOST OUT OF PORTS)
	STH	R0,SUPMBF
	LHL	R0,HOSTN,HN,HN		:HOST #
	OHI	R0,8000
	STH	R0,SUPMBF+4
	JAL	R10,SUP12,,		:REPORT TO SUP LOG

	LHL	R0,HOSTN,HN,HN		:GET HOST #
	OHI	R0,8000
	STH	R0,SUPMBF
	LHI	R5,8F			:OUT OF PORTS
	LIS	R6,1			:1 HALFWORD TO BE SENT
	LIS	R2,1
	JAL	R10,SUP14,,		:SEND OUT OF PORTS MSG TO SUP

:	DETACH CIRCUIT. REMOVE DISPATCHER PERMUTER TABLE ENTRY FROM DIOTAB,
:	FIND AVAILABLE CHANNEL TO DISPATCH PROCESS IN CIOTAB (STARTING WITH
:	DETZFL). CONNECT NETWORK HALF-CIRCUIT TO DETACH PROCESS FOR SENDING
:	APPROPRIATE TEXT TO USER, BOUNCING YELLOW BALL, AND TIMING OUT CIRCUIT
:	IF NO ORANGE BALL RETURNED. TEXT TO USER IS DETERMINED BY VALUE STORED
:	IN DETMTY BYTE ARRAY.

DSOZW7	HS	0			:DONE WITH ACCT. DETACH PORT
	LHL	R2,DIOTAB,R4,R4		:GET EXISTING PERMUTER TABLE ENTRY TO
	NHI	R2,-4			: MOVE TO CIOTAB.
:	FIND NEXT AVAILABLE CHANNEL TO DETACH PROCESS...
	L	R4,DETACP,,		:DETACH PORT AVAILABLE ?
	JFFO	R4,DSOZW8		:FOUND ONE
	J	DSOZAP			:NO DETACH PORTS, ZAP CIRC TO NETWORK

DSOZW8	HS	0
:	CAUSE ZAPX TO PUT CR/LF INTO BUFFER INSTEAD OF ZAPPER. THIS WILL
:	CAUSE DISPATCHER PORT TO BE FREED UP WITHOUT ZAPPING EXISTING CIRCUIT.
	LHI	R1,0D0A			:MAKE ZAPX PUT 'CRLF' INTO BUFFER
	JAL	R9,ZAPX,,		:'ZAP' THE DISPI SIDE OF CIR.
	GL	ZAPX
:	STORE 'DETACH REASON' INTO DETMTY BYTE ARRAY
	LIS	R0,2			:INDICATE HOST OUT OF PORTS, DETECTED
	STB	R0,DETMTY,CHN		: BY SLOT WHICH SENT 'BE' MESSAGE

	AHI	CHN,DETZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER AND
	JAL	R9,CRQHCR,,		:BUILD 2ND HALF OF CKT TO DETACH PROCES
:	SEND NEEDLE POINT TO DETACH PROCESS TO ALERT IT TO NEW PORT.
	XHI	R2,4			:INDEX FOR BUFF TOWARDS DETACH PROCESS
	LIS	R1,3
	JAL	R8,WCI
	LHI	R1,NEEDP
	JAL	R8,WCI			:WRITE NEEDLE POINT IN BUFFER
	J	DSOIRP			:CONTINUE



TOMANY	HS	0
FULMSG	SC	/"8D"8Atoo many login characters/
LSMX08	SC	/"8D"8Aplease see your repesentative/
	SC	/"8D"8Aif you are having trouble logging in/



::*********************************************************************
::
::	TABLE:	DSOMTB:
::	FUNCTION:	DISPATCH TABLE FOR PORT SIGNALS FROM ISIS
::
::*********************************************************************

DSOMTB	HC	DSODET-SEG1	:9E - DETACH				###wjl
				:ISIS makes 9E into YB, wait for OB, ZAP.
	HC	DSOZAP-SEG1	:9F - ZAPPER
	HC	DSOSBP-SEG1	:A0 - SET BACKPRESSURE
	HC	DSORBP-SEG1	:A1 - RELEASE BP
	HC	DSOGOB-SEG1	:A2 - GOBBLER
	HC	DSOIRP-SEG1	:A3 - REVERSE GOBBLER (UNUSED)
	HC	0FD01		:A4 - BLACK BALL
	HC	0FC01		:A5 - GREY BALL
	HC	07		:A6 - EDEM
	HC	04		:A7 - LDEM
	HC	0F201		:A8 - ENTER TRM
	HC	0F301		:A9 - LEAVE TRM
	HC	05		:AA - GREEN BALL
	HC	06		:AB - RED BALL
	HC	0FF01		:AC - YELLOW BALL
	HC	0FE01		:AD - ORANGE BALL
	HC	0FB01		:AE - BREAK DETECTED
	HC	0F001		:AF - HANG UP
	HC	DSOQPR-SEG1	:B0 - QUERY PARAMETER
	HC	DSOSPR-SEG1	:B1 - SET PARAMETER
	IF	T2GATE
	HC	GDB2-SEG1	:B2 - PSEUDO NEEDLE 
	HC	DSOCRH-SEG1	:B3 - LOGON CHAR
	HC	GDB4-SEG1	:B4 - LOGON STATUS 
	HC	GDB5-SEG1	:B5 - LOGON FAILURE 
	HC	GDB6-SEG1	:B6 - SUCCESSFUL LOGON 
	HC	DSOCRH-SEG1	:B7 - ADDENDUM TO ACCOUNTING
	ELSE
	HC	DSOCRH-SEG1	:B2 - PSEUDO NEEDLE (ILLEGAL)
	HC	DSOLGC-SEG1	:B3 - LOGON CHAR
	HC	DSOCRH-SEG1	:B4 - LOGON STATUS (ILLEGAL)
	HC	DSOCRH-SEG1	:B5 - LOGON FAILURE (ILLEGAL)
	HC	DSOCRH-SEG1	:B6 - SUCCESSFUL LOGON (ILLEGAL)
	HC	DSZACC-SEG1	:B7 - ADDENDUM TO ACCOUNTING
	EI	:T2GATE
	HC	DSOHNG-SEG1	:B8 - SUPERHANG
	HC	DSOSXL-SEG1	:B9 - SET XMIT LIMIT
	HC	DSOIRP-SEG1	:BA - END OF BREAK
	HC	DSOZAK-SEG1	:BB - ZAP ACK
	HC	0F401		:BC - ENTER ALTERNATE DEVICE MODE
	HC	0F501		:BD - LEAVE ALTERNATE DEVICE MODE
	HC	DSOZWR-SEG1	:BE - ZAP WITH REASON
	HC	0F601		:BF - ENTER IIX EXCHANGE
	HC	0F701		:C0 - LEAVE IIX EXCHANGE
DSODMX	EQ	(.-DSOMTB)/2

::*********************************************************************
::
::	TABLE:	DSOMBA:
::	FUNCTION:	
::
::	THE FOLLOWING BIT ARRAY INDICATES WHICH DSOMTB ENTRIES CONTAIN
::	THE ACTUAL MAPPING CHARACTERS, AND WHICH HAVE ROUTINE ADDRESSES TO
::	HANDLE THE MAPPING FUNCTION. THE ARRAY IS RELATIVE TO MESSAGE TYPE
::	9E, AND THE ONE BITS REPRESENT ENTRIES WHICH CONTAIN THE CHARACTER.
::
::*********************************************************************

DSOMBA	BC	003,0FF,0C0,003,060	:BIT ARRAY FOR 'TRIVIAL CONVERSION'

::*********************************************************************
::
::	TABLES:		TQPR,  TSPR,  TSPRM.
::	FUNCTION:
::
::	THE FOLLOWING 3 TABLES ARE ARRANGED IN ISIS MESSAGE ORDER
::	AND ARE USED TO TRANSLATE 'SET TERMINAL' TYPE MESSAGES
::
::*********************************************************************

:	QUERY TERMINAL PARAMETERS
TQPR	BC	0A0,0A2,0A6,0A4	:DSOQPR TABLE
	BC	0AE,093,098,0AA
	BC	0A8,097,096,095
	BC	0AC,0B0,0B2,094
	BC	0B4,0B6,0B8,0BA
	BC	0,0,0,0		:ADDITIONAL 0'S FOR FILLER ONLY
	BC	0,0,0,0
	BC	0,0,0,0

:	SET TERMINAL PARAMETERS
TSPR	BC	0C0,0C2,0C6,0C4	:DSOSPR TABLE
	BC	0CE,030,080,0CA
	BC	0C8,070,060,050
	BC	0CC,0D0,0D2,040
	BC	0D4,0D6,0D8,0DA
	BC	0,0,0,0		:ADDITIONAL 0'S FOR FILLER ONLY
	BC	0,0,0,0
	BC	0,0,0,0

TSPRM	BC	01,01,01,01	:DSOSPR MASKS
	BC	01,0F,0F,01
	BC	01,0F,0F,0F
	BC	01,01,01,0F
	BC	01,01,01,01
	BC	01,01,01,01	:ADDITIONAL 01'S FOR FILLER ONLY
	BC	01,01,01,01
	BC	01,01,01,01

	SUBTTL  DISPI (T2GATE - Gateway login handling logic)

	IF	T2GATE
	GL	ZAPXN,LSMS27,PSRMSG,AARDIC,SPAC,GLBCLR,LSMSZ,NLSOK,LSMSTZ
::*********************************************************************
::
::	POINT OF DEPARTURE:	GDB2:	Gateway Dispatcher B2 Message	
::	FUNCTION:		Gateway gets a B2 (pseudo needle) on
::			CHN in response to a request for a Log-in.  It
::			sets up the buffer and arrays with given CHN, and
::			if transparent log-on will send username in B3
::			messages  to dispatcher
::	CALLING SEQ:	Jump to from DISKIP.  for Gateway only.
::	INPUT:		CHN	=  relative dispatcher port number
::			PRD	=  pointer to message in ISIS ring 
::			R2	=  buffer number gotten from the Local Key
::				   field in B2.  Must be in Log-on state. 
::	CALLS:		JAL	R8,GCI
::			JAL	R9,GHWI
::			JAL	R9,AAMKPT,,
::			JAL	R8,WLOCDR
::			JAL	R9,BUFCAN
::			JAL	R9,ZAPV1
::	RETURNS:	Jumps directly to DSOIRP to continue Dispatcher  pro.
::
::*********************************************************************

GDB2	HS	0		:Gateway handler for Pseudo Needle (type B2)
	AIS	PRD,4
	NR	PRD,TC		:Advance pointer to Local Key
	LHL	R2,DORNG,PRD,	:Get Local Key
	LHL	R0,BF,R2,	:Now get Flag pointer for this buffer
	AIS	PRD,2
	NR	PRD,TC		:Fix up pointer
	CLHI	R0,LOGMAX	:Should be marked as a Log-in buffer
	JG	DSOCRH
	CLHI	R0,LOGMIN
	JL	DSOCRH
::We are in Log-in mode.  Is there really a circuit?
	XHI	R2,4
	LHL	R0,BF,R2,	:Get Hnet channel number
	JLE	GDB2FL		:If dead, just flush this
	XHI	R2,4		:Return to F.T. buffer
	LHI	R0,LGSNT.	:Mark as TID accepted by Sup
	STH	R0,BF,R2,	:for future processing / timeout
	SBT	CHN,LOGING
	SBT	CHN,GDSTPT	:This is a circuit destination.
	RBT	CHN,GORGPT
	SBT	CHN,DISBPV	:Relieve backpressure
	SBT	CHN,DISBPX	:and we haven't BPed mr dispatcher
	SBT	CHN,LOGDAT	:allow log-on processing to begin
	SBT	CHN,GLGDAT	:first delimiter not yet sent
::Initialize the rest of the arrays
	RBT	CHN,GTAUX
	RBT	CHN,GTHDX
	SBT	CHN,GTASCI
	SBT	CHN,GTECHO
	SBT	CHN,GTLGEC
	RBT	CHN,GTTRNS
	RBT	CHN,GIIXCT
	LIS	R0,0
	STB	R0,GLGCNT,CHN,	:Init logon character counter
::Now get items of information from our still intact Needle.
	JAL	R8,GCI		:Skip Needle point
	JAL	R8,GCI
	JAL	R8,GCI		:Get length of Needle
	JAL	R8,GCI
	STB	R1,GDNLEN	:and store for possible flush
	JAL	R8,GCI		:Skip escape
	JAL	R8,GCI		:Read link count and toss
	JAL	R9,GHWI		:Get 2 bytes of Invoice number
	STH	R1,GDNINV
	JAL	R9,GHWI		:Get remaining two
	STH	R1,GDNINV+2,,	:Store the Invoice Number

::Install a scratch table entry for future reference
	STH	R2,GDLGTB,CHN,CHN	:and store it in our scratch table

::Connect dispatcher port IOTAB to outbound (to terminal) buffer
::We mark the IOTAB so that our CHN will not be selected for another
::circuit.  We must keep track of login and complete circuit.
	AHI	CHN,DISZFL	:Make absolute channel number
	XHI	R2,4		:flip to outbound buffer #
	STH	R2,IOTAB,CHN,CHN	:chan marked as in use
	RBT	CHN,ACP,,	:Reset ACP bits
	LCS	R0,1
	SR	R0,CHN
	RBT	R0,ACP,,
	XHI	R2,4		:Now get from terminal buffer 
::Time to initialize the accounting block for this circuit termination
	LIS	R1,1
	AHM	R1,NC.CRC	:Count circuit completion for CRQ
	JAL	R8,AASTRT,,
	GL	AASTRT
	NOP			:Possible error stuff added later
GDB205	SHI	CHN,DISZFL	:Restore relative dispatcher port number
	LHI	R0,INXLIM
	STH	R0,DIXLIM,CHN,CHN	:7/29/86	###EV
::Now get Needle Flags field and store for possible future use
	JAL	R9,GHWI
	STH	R1,GDFLGS
	THI	R1,NF.SMC	:If IIX circuit - mark as such
	JE	GDB215
	SBT	CHN,GIIXCT
GDB215	NHI	R1,030		:Get speed bits
	SRHLS	R1,4		:Put in low order nibble
	STB	R1,GDSPED	:and store for later
	JAL	R9,GHWI		:Skip origin node
	JAL	R9,GHWI		:Skip origin port
::Now toss the node list
GDB206	JAL	R9,GHWI
	CI	R1,0FFFF
	JEBS	GDB206
	TI	R1,8000
	JN	GDB207		:At end of node list - proceed
	J	GDZAP		:Some error - Zap both sides of circuit
::Get User Flags field and examine username
GDB207	HS	0
	JAL	R9,GHWI		:User flags
	STH	R1,GDUSRF	:Store temporarily
	SRLS	R1,8		:Get rid of extra bits
	NHI	R1,1F		:Get the CCT itself
	LBR	R1,R1
	JE	GDBAUX		:Aux circuit if CCT is 0
	THI	R1,20		:Test Half Duplex bit
	JEFS	GDB208		:No
	SBT	CHN,GTHDX	:Else set as Half duplex
	RBT	CHN,GTECHO	:No echo for Half duplex terminals
::Test for 2741 terminal type
GDB208	SIS	R1,8
	JL	GDB209
	SIS	R1,9-8
	JGEFS	GDB209
	SBT	CHN,GTHDX	:Yes this is a 2741 type
	RBT	CHN,GTECHO	:No echo for this terminal
	RBT	CHN,GTASCI	:Special distinction as HDX Ascii
	JFS	GDB209
GDBAUX	SBT	CHN,GTAUX	:Marker as an Auxilliary circuit
	RBT	CHN,GTECHO	:No echo for Aux circuits	###per Kopfj
                                :the ###per KOPFj refers that it was commented
                                :out to allow echoing of username for aux cirs.
                                :that prevent loadii from working.  maybe later
                                :##### sdw
GDB209	JAL	R9,GHWI		:Pass requesting host
::Now check for Transparent Log-on
	JAL	R8,GCI		:First username character
	CLHI	R1,GXPRNT	:Is it a "?" ..? (transparent indicator)
	JN	GDB216		:No - flush username and proceed
::Transparent user - set up appropriately
	SBT	CHN,GTTRNS	:Set Transparent circuit flag
	TBT	CHN,GTHDX	:Is this a HDX circuit?
	JE	GDB210		:NO
	LHI	R1,0B3		:Set up for Log-on character
	EXBR	R1,R1		:Move to HO byte of LO HW
	AHI	R1,08		:Make it control-H
	JAL	R8,DIRMES	:and send to dispatcher
GDB210	LB	R1,GDSPED	:Get throughput class
	LB	R1,TPTBL,R1	:Get control character from table
	LHI	R0,0B3
	EXBR	R0,R0
	AR	R1,R0		:Make B3 message
	JAL	R8,DIRMES	:and send it
::Now we've prepared the username with the right controls, so enter name
	LHI	R7,LGCHMX
	GL	LGCHMX		:Maximum log-on characters allowed
GDB212	SIS	R7,1
	JL	GD2MNY		:Zap buffer and tell user "too many.."
	JAL	R8,GCI		:Get a username character
	LHI	R0,0B300
	AR	R1,R0
	JAL	R8,DIRMES	: .. and write it to dispatcher
	NHI	R1,0FF
	CHI	R1,8D		:Is it a <cr>?
	JEFS	GDB214
	CHI	R1,0BB		:Is it a semi-colon?
	JN	GDB212		:If not either, then get more characters
:Finished sending Log-on string to Sup
GDB214	RBT	CHN,LOGDAT	:log-in in wait state
	J	GDB220		:Continue
::Here if non-transparent and need to flush username
GDB216	LHL	R7,GDNLEN	:Flush username
GDB217	SIS	R7,1
	JL	GDB218		:We must have flushed it by now
	JAL	R8,GCI:::::may not be a good idea to continue here
	CHI	R1,8D
	JEFS	GDB218
	CHI	R1,0BB
	JN	GDB217
GDB218	HS	0		:
GDB220	XHI	R2,4		:Flip to outbound (to terminal) buffer
	TBT	CHN,GIIXCT	:An IIX circuit?
	JEFS	GDB222		:NO
	LA	R4,GIIXGW	:Send "reached IIX Gateway"
	JAL	R9,BUFCAN
GDB222	TBT	CHN,GTTRNS	:Transparent log-on?
	JN	GDB226		:Yes - don't send banner

GDB224	LA	R4,GNETOK	:Load 'inter-link connected'
	JAL	R9,BUFCAN	:Send it
	ROUTE(HOMEN,ISISN)
	LA	R4,CRLF
	JAL	R9,BUFCAN
	LA	R4,GATPLI	:Load 'Please log in'
	TBT	CHN,GIIXCT	:IIX circuit?
	JEFS	GDB225		:NO
	LA	R4,GIXPLI	:Load IIX PLI message	
GDB225	JAL	R9,BUFCAN
::Turn on output to the Network
GDB226	LHL	R3,BF,R2,		:Get the channel number
	SBT	R3,BPSVCP-LNKZFL/8,,	:Enable RMAKE service of this channel
	SBT	R3,LNKBPV-LNKZFL/8,,
	RBT	R3,PRIRTY-LNKZFL/8,,
	RBT	R3,CMDCTS-LNKZFL/8,,
	LHL	R7,GDFLGS		:Get needle flags
	THI	R7,NF.PRI		:Is this a priority circuit?
	JEFS	GDB228			:No
	SBT	R3,PRIRTY-LNKZFL/8,,	:Set priority circuit flag
GDB228	THI	R7,NF.CMD		:Command circuit? (ILLEGAL)
	JEFS	GDB229			:No
	CRASH.(.DISI0)			:Illegal for Gateway 
GDB229	LB	R1,GDSPED		:Get speed bits from temp storage
	LHL	R0,IOTAB,R3,R3
	OR	R0,R1			:Merge into perm table entry
	STH	R0,IOTAB,R3,R3		:And restore outbound table entry
:Load port counters and etc.
	LHL	R1,HNPORT
	AIS	R1,1
	CLH	R1,MXPORT
	JLEFS	GDB230
	STH	R1,MXPORT
GDB230	STH	R1,HNPORT
	STH	R1,DHSTIX,CHN,CHN
::Now send Needle  ack
	LHL	R2,TVRBUF	:Load up 'To Sup' buffer
	JE	GDB240		:No Sup? .. oh well ..
	JAL	R10,SUPMHD,,
	GL	SUPMHD
	LBR	R1,CHN		:Get relative Dispatcher port #
	OHI	R1,1500		:Type 15 message
	JAL	R9,WHWI
	LH	R1,GDNINV
	JAL	R9,WHWI
	LH	R1,GDNINV+2
	JAL	R9,WHWI		:Followed by invoice number
GDB2FL	HS	0		:Also exit for no circuit
GDB240	J	DSOIRP		:Return to Dispatcher mainline


::**********************************************************************
::
::	GD2MNY:	Sends message "too man log-on characters" to terminl user,
::		then Zaps the circuit.
GD2MNY	HS	0
	XHI	R2,4		:Flip to outbound buffer(to terminal)
	LA	R4,TOMANY	:Get message
	JAL	R9,BUFCAN	:and put it out
	LA	R4,LSMX08	:"please see your rep ... "
	JAL	R9,BUFCAN
:NOW FALL THROUGH AND ZAP THE CIRCUIT IN BOTH DIRECTIONS

::**************************************************
::
::	GDZAP:	Zaps a Log-in circuit not fully built
::		from HNET  to INET.
::	EXPECTS:	CHN	=  Rel. Dispatcher chn
::			R2	=  From Terminal buffer
::
GDZAP	HS	0		:Zap Gateway Log-in circuit
	LHI	R1,09F00	:Load a hard Zapper
	JAL	R8,DIRMES	:Send to Dispatcher on CHN
	LIS	R0,0		:Zero out scratch permuter table
	STH	R0,GDLGTB,CHN,CHN
	STH	R0,BF,R2,	:Zero our previously marked as Log-in BF
	XHI	R2,4		:Flip to To Termnal buffer, set up via CRQ
	LHI	R1,ZAPPN
	JAL	R9,W2CI		:Zap network side of circuit
	RBT	CHN,LOGING		:reset..
	RBT	CHN,DISFLG		:no more input to dispatcher
	RBT	CHN,DISZNK		:prepare for GLZPV
	J	DSOIRP			:and return to mainline


::*********************************************************************
::
::	SUBROUTINE:	GDB3IN:  Gateway Dispatcher B3 INput handler.
::	FUNCTION:	Invoked for ports in Log-in mode.  Formulates
::			characters from HNET terminal into B3 for ISI.
::	CALLING SEQ:	JAL	R10,GDB3IN
::	CALLS:
::	RETURNS:
::
::*********************************************************************
GDB3IN	HS	0
	ST	R10,DSSVRT		:SAVE RETURN
:	PREVENT HOGGING CPU IN DISPATCHER PROCESS. DIDTIM WILL CONTAIN
:	FASTC TIME TO DISMISS BACK TO EXEC 500MS EVEN IF WORK TO DO.
	L	R0,FASTC,,
	AHI	R0,RATE/10		:DON'T RUN FOR MORE THAN 1/16TH SECOND
	ST	R0,DIDTIM

::Should we dismiss after servicing each Log-in port?
GDINXT	HS	0
	L	R0,DIDTIM		:GET TIME TO DISMISS
	S	R0,FASTC,,		:LATER THAN CURRENT TIME?
	JGFS	GDLNX1			:YES - CONTINUE FILLING DISPATCHER RING
	LIS	R0,1			:NO - COUNT NUMBER OF FORCED DISMISSES
	AHM	R0,DIDISM
	J	GDLORT			:..RETURN

GDLNX1	LIS	TYC,7			:SET UP CONSTANTS
	LHI	TC,DRSZ-1
	LH	PRD,DRIF,,		:COMPUTE ROOM AVAILABLE
	LH	PRC,DRIE,,
	SR	PRC,PRD			:DRIE - DRIF
	JGFS	GDB305			:NO RING WRAP
	AHI	PRC,DRSZ		:RING WRAP
GDB305	CLHI	PRC,10			:MINIMUM ROOM CONSIDERED
	JGFS	GDB310			:PRC = ROOM AVAILABLE

:	HERE TO RETURN MAIN
GDLORT	L	R10,DSSVRT	
	JR	R10

:	LOCATE PORTS WITH INBOUND DATA
GDB310	LIS	R7,0	
	LIS	R4,0			:BASE PORT # FOR GROUP
GDB320	L	R1,LOGING,R7,
	N	R1,LOGDAT,R7,		:Only ports in log-in WITH data
	N	R1,GDSTPT,R7,		:Service only destination ports
	N	R1,DISBPV,R7		:MASK OUT BP'ED PORTS
	N	R1,DISSVD,R7		:AND SERVICED PORTS
	JN	GDB340			:GO TO SERVICE

	AIS	R7,4			:POINT TO  NEXT WORD OF BIT ARRAYS
	AHI	R4,20			:MOVE CHANNEL NUMBER AHEAD TO MATCH
	CLHI	R4,NDP			:HAVE WE REACHED END OF PAGE?
	JL	GDB320			:PROCESS THIS GROUP IF NOT

:	ALL PORTS SERVICED ONCE
	LCS	R2,1		
	LIS	R7,0
GDB330	ST	R2,DISSVD,R7		:RESTORE SERVICE FLAGS
	AIS	R7,4
	CLHI	R7,NDP/8
	JLBS	GDB330			:LOOP FOR NEXT GROUP

	J	GDLORT			:ALL DONE AND SPLIT

:	THIS IS THE MAIN WORK LOOP-- MOVE DATA FROM BUFFERLETS INTO RING
:	FOR THE PORTS MARKED IN R1'S BIT ARRAY.
GDB340	JFFO	R1,GDB342		:COMPUTE PORT NUMBER
GDB342	LR	CHN,R2			:CHANNEL OFFSET IN ONE GROUP
	AR	CHN,R4			:ADD CHAN OFFSET FOR WORD OF BIT ARRAY
					:CHN = RELATIVE DISPI CHN NUMBER
	RBT	CHN,DISSVD		:THIS PORT SERVICED
	LHL	R2,DIOTAB,CHN,CHN	:IOTAB ENTRY (OUTBOUND BUFF #)
	NHI	R2,-4			:STRIP GOUGING BITS FROM BUFFER NUMBER
	JNFS	GDB350
	CRASH.(.DISI0)			:DISPI FOUND NO DISPATCHER CIRCUIT
	J	GDB320			:GO TO SEE NEXT PORT
::Proceed
GDB350	XHI	R2,4			:Switch to inbound(from term) buffer
::Check to ensure that we're in Log-in mode!
	LHL	R1,BF,R2,		:The BF should indicate Log-in
	CLHI	R1,LOGMAX
	JG	GB3CRH
	CLHI	R1,LOGMIN
	JL	GB3CRH

::	JAL	R8,CBCCT		:GET COUNT, RETURN IN R1
	
	HC	3A12
	HC	BB/4
	HC	BBSIZE
	LR	R1,R1
	JE	GDB320			:If NO  data, go service next port

GDB356	LR	LRC,R1			:MINIMUM AGAIN
	LR	CD,LRC			:WORKING COUNT

::Now read Log-in characters, acting on zappers and passing on the rest
GDB360	JAL	R8,GCI			:MOVE CHARACTERS FROM BUFFER
	CR	R1,TYC			:Is it a Tymnet Control Character?
	JG	GDB3PR
        LR      R1,R1                   :escaped char?
        JNFS    GDB361
        SIS     CD,1                    :reduce count by the escape
        JAL     R8,GCI                  :get the escaped char
        J       GDB3PR                  :and process it  ###sdw
GDB361	CLHI	R1,03			:Is it a Zapper
	JN	GDB403			:No, continue processing
	JAL	R8,PCIS
	CLHI	R1,01
	JE	GDB362
	CLHI	R1,02
	JE	GDB362
	CLHI	R1,03
	JN	GDB403

::Clean up logon aspects of circuit - Zapper ack will clean up Hnet side
GDB362	HS	0
	RBT	CHN,LOGING		:No longer login mode
	RBT	CHN,DISZNK		:Expect zap ack - prepare for GLZPV
	LIS	R0,0
	STH	R0,GDLGTB,CHN,CHN	:Zero out scratch table
	JAL	R8,RFCBUF,,		:And in this case must return buffer
	GL	RFCBUF			:because is not done by Zapx or Glzpv
::ZAPX will have cleared out the H-Net side of the circuit and done accounting
::Send Zapper to ISIS side of circuit
	STH	CHN,DIRNG,PRD,		:Put channel number into ring
	LHI	R1,ISZAPR		:Load ISIS  ZAPPER
	STB	R1,DIRNG+2,PRD,		:Store to dispatcher ring
	AIS	PRD,4
	NR	PRD,TC

::End point for each iteration of this routine
GDB390	HS	0
	IF	ACCT
::Perform character counts for this destination
	TBT	CHN,GDSTPT		:Destination port?
	JE	GDB396			:Not destination, no count
	LR	R0,LRC			:Get count
	LR	R3,CHN			:Move Channel # to work reg
	AHI	R3,DISZFL		:Get absolute channel number
	SHI	R3,MNACHN		:Make an accounting index
	JAL	R8,AARDIC,,		:Now add to accumulator
	EI	:ACCT
GDB396	AIS	PRD,3		:Round off pointer
	NHI	PRD,DRSZ-4
	STH	PRD,DRIF,,	:and restore
	J	GDINXT		:Process next port

::Or process other control characters
GDB403	HS	0
	LIS	LRC,0			:For accounting, don't count controls
	CLHI	R1,05			:Is a green ball
	JE	GB3C01			:Yes
	CLHI	R1,06			:Is a red ball
	JE	GB3C01			:Yes
	CLHI	R1,0FF			:Or a yellow ball
	JE	GB3C02
	J	GDB390			:Continue processing

::Bounce green and red balls, reflect orange for yellow
GB3C01	XHI	R2,4			:Flip to terminal bound buffer
	JAL	R8,WCI			:And bounce it
	XHI	R2,4			:Return to net bound buffer
	J	GDB390
GB3C02	XHI	R2,4			:Flip again
	LHI	R1,0FE
	JAL	R8,WCI			:bounce orange ball
	XHI	R2,4			:Flip back
	J	GDB390

::Else, process Log-on characters - sending each one in a B3 message to ISIS
::Enter here for next character
GDB3PR	LB	R9,GLGCNT,CHN,		:Current acumulated count
::Test for Half Duplex
GDB3P1	OHI	R1,80			:Set high order bit
	LR	R6,R1			:Save copy of character
	CLHI	R1,88			:Is character control-H
	JNFS	GL3C1			:NO
	RBT	CHN,GTECHO		:Turn off echo for this guy
	SBT	CHN,GTHDX		:Make sure were thinking HDX
GL3C1	CLHI	R1,09F			:Is character printable
	JLE	GL3CH1			:NO
	TBT	CHN,GTLGEC		:Should this be echoed
	JE	GL3CH1			:NO
	TBT	CHN,GTECHO		:Echo for this terminal type?
	JE	GL3CH1			:NO
	XHI	R2,4			:Flip to terminal bound buffer
	JAL	R8,WCI			:Echo back to terminal
	XHI	R2,4			:Flip buffer back
::Now write character to ISIS using B3 format.
GL3CH1	HS	0
	LR	R1,R6			:Get a copy of the char
	LBR	R1,R1			:Ensure one byte
	STH	CHN,DIRNG,PRD,
	LHI	R0,0B300		:Make B3 message
	AR	R0,R1
	STH	R0,DIRNG+2,PRD,		:Put into ring
	AIS	PRD,4
	NR	PRD,TC
::Now check for terminators
	CHI	R1,8D			:= 'CR' ?
	JEFS	GB3CH0			:YES, SET NODE CODE TO OK
	CHI	R1,0BB			:= "SEMI :" ?
	JN	GDB3PP			:Do next character
	RBT	CHN,GTLGEC		:No echo allowed after semi-colon
GB3CH0	RBT	CHN,LOGDAT		:Put log-in in wait state
	LIS	R1,0
	STB	R1,GLGCNT,CHN,		:Reinit counter
	RBT	CHN,GLGDAT	
	J	GDB390			:Return for next port
::Not delimiter .. get next character
GDB3PP	AIS	R9,1		:too many characters yet?
	TBT	CHN,GLGDAT
	JEFS	GDPP2
	CHI	R9,LGCHMX-3
	JFS	GDPP3
GDPP2	CHI	R9,LGCHMX
GDPP3	JLE	GDPP4		:Not too many .. continue
	XHI	R2,4
	LA	R4,TOMANY		:Sent "to many login characters"
	JAL	R9,BUFCAN		:back to the terminal user
	XHI	R2,4
	J	GDB390			:and go to next port
GDPP4	SIS	CD,1
	JGFS	GDB3P9		:more characters
	STB	R9,GLGCNT,CHN,	:Else .. store count so far
	J	GDB390		:and go to next port
GDB3P9	JAL	R8,GCI
        LR      R1,R1           :escaped char?
        JN      GDB3P1
        SIS     CD,1            :another char gone
        JAL     R8,GCI          :get the char
	J	GDB3P1		:Get next character

GB3CRH	HS	0		:Come here when circuit is inconsistent
	CI	R1,DEAD		:Could be special case of circular login
	GL	DEAD
	JE	GB3CR1
	CRASH.(.DISI0)
GB3CR1	XHI	R2,4		:If so, other should be too
	LHL	R1,BF,R2,
	CI	R1,DEAD
	JE	GB3CR2		:If so, clear table entries
	CRASH.(.DISI0)
GB3CR2	RBT	CHN,LOGING
	AHI	CHN,DISZFL
	LHL	R1,IOTAB,CHN,CHN
	CR	R1,R2		:Consistency check
	JE	GB3CR3
	CRASH.(.DISI0)	
GB3CR3  HS      0
        IF      CBZDBG                  :debug this too (like ZAPV)
        ST      R4,REGST,,
        JAL     R4,GPZDB3,,
        GL      GPZDB3
        L       R4,REGST,,
        EI   :CBZDBG

	LIS	R0,0		:End of same circuit, so clear tables
	STH	R0,IOTAB,CHN,CHN
	SBT	CHN,ACP,,
	RBT	CHN,CHS,,
	SBT	CHN,CHS1,,
	LCS	R0,1
	SR	R0,CHN
	SBT	R0,ACP,,
	RBT	R0,CHS,,
	SBT	R0,CHS1,,
	J	GDB320

::*********************************************************************
::
::	ENTRY POINT:	GDB4:	Gateway Dispatcher B4 Message Handler
::	FUNCTION:	Handles the B4 Log-on response.
::	INPUT:		CHN	=  Relative Dispatcher port number
::			R2	=  Buffer number of outbound (to terminal)
::	CALLS:		JAL	R8,GCI
::			JAL	R8,DIMMES
::			JAL	R8,DIRMES
::	RETURNS:	Jumps directly back to DISOUT processing.
::
::*********************************************************************

GDB4	HS	0		:Handle B4 Messages for Gateway
::First, check to ensure that this is the correct circuit
	LB	R1,DORNG,PRD	:PRD updated by DISOUT routine
	STB	R1,GLGSTA	:Store away status byte
	TBT	CHN,LOGING	:This channel should be in Log-in mode
	JE	DSKP3		:Jump out to DISKIP's error handling
::Now double check to ensure that the right buffer is used
	XHI	R2,4		:Flip to incoming (from terminal)buffer
	LHL	R1,GDLGTB,CHN,CHN	:Get previously stored buffer #
	CR	R1,R2		:These should match
	JE	GDB402		:They do - proceed
	J	DSOCRH
::As a triple check, the BF should indiciate Log-in state
GDB402	LHL	R1,BF,R2,	:Get flags field
	CLHI	R1,LOGMAX
	JG	DSOCRH
	CLHI	R1,LOGMIN
	JL	DSOCRH
::Proceed with login message interpretation
	SBT	CHN,LOGDAT		:Remove log-in wait state
	LB	R10,GLGSTA		:GET STATUS
	THI	R10,40			:CHECK FOR ECHO-ON
	JNFS	GDB41			:SET IF ON
	RBT	CHN,GTLGEC		:ELSE RESET ECHOING
	JFS	GDB41A
GDB41	SBT	CHN,GTLGEC
GDB41A	THI	R10,20			:CHECK IF WE SHOULD FLUSH OUTPUT BUFFER
	JEFS	GDB42			:SKIP IF NOT
	XHI	R2,4			:FLIP TO (to terminal) buffer
	JAL	R8,CBCLR		:ELSE DO IT
	XHI	R2,4			:YES, flip to from terminal buffer
GDB42	THI	R10,80			:SHOULD WE EMPTY INPUT BUFFER?
	JE	GDB42B			:NO
	LHL	R0,BCT,R2,		:ANYTHING IN THE BUFFER?
	JLEFS	GDB42B			:NO, ALREADY EMPTY
	JAL	R8,GCI			:YES, GET 1ST CHAR
	SIS	R1,3			:IS 1ST CHAR A ZAPPER?
	JNFS	GDB42A			:NO, SKIP
	J	GDZAP			:If so Zap both sides of circuit	
GDB42A	JAL	R8,GLBCLR		:Clear buffer (special log-on clear)
GDB42B	XHI	R2,4			:Back to inputed R2
	LHI	R11,1F			:SET MASK FOR STATUS BITS
	NR	R11,R10			:EXTRACT MSG #
	TBT	CHN,GIIXCT		:IIX REQUESTED FOR THIS CKT?
	JN	GDB46			:YES
	LR	R11,R11			:CONTINUE?
	JE	DSOIRP			:RETURN IF 'CONTINUE'
::	LIS	R0,3		:###EV
::	STB	R0,GLGCNT,CHN,		:Reset character counter
:	CHN  = TYMNET PORT
:	R2  = TO TERMINAL BUFFER
:	R10 = STATUS
:	R11 = MESSAGE INDEX
	LA	R4,CRLF			:OUTPUT C/R L/F
	JAL	R9,BUFCAN

	IF	NETNAME
	TBT	CHN,GTTRNS		:TRANSPARENT USER?
	JE	GDB42C			:NO, SKIP
	LA	R4,ISISN		:OUTPUT NET NAME
	JAL	R9,BUFCAN
	LA	R4,SPAC			:...FOLLOWED BY A SPACE
	JAL	R9,BUFCAN
GDB42C	EI	:(NETNAME)

	LIS	R8,0			:INIT MSG TABLE INDEX
	TBT	CHN,GTTRNS		:TRANSPARENT USER?
	JEFS	GDB43A			:NO, SKIP
	AHI	R8,LSMSTZ		:MOVE INDEX TO TRANSPARENT MSGS
GDB43A	TBT	CHN,GTASCI		:IS IT REALLY ASCII TERMINAL?
	JEFS	GDB44			:SKIP IF NOT
	AHI	R8,LSMSZ		:MOVE INDEX TO ASCII MSGS
	TBT	CHN,GTHDX		:HALF-DUPLEX TERMINAL?
	JNFS	GDB43			:SKIP IF SO
	TBT	CHN,GTAUX		:AUX CIRCUIT?
	JEFS	GDB44			:SKIP IF NOT
GDB43	AHI	R8,LSMSZ		:MOVE INDEX TO HDX MSGS
GDB44	
	CHI	R11,5			:MSG#>5, USE SAME LSMS27 TABLE+3
	JLEFS	GDB44A			:<=5, NO+3
	AHI	R11,3
GDB44A	SLLS	R11,2			:FW BOUNDARY OF 4 BYTES
	L	R4,LSMS27,R11,R8	:GET ADDR OF MSG
	JAL	R9,BUFCAN		:OUTPUT MSG TO PORT

GDB45	TBT	CHN,GTTRNS		:TRANSPARENT USER?
	JE	GDB45A			:NO, SKIP
	SRLS	R11,2
	TBT	R11,NLSOK		:SHOULD MSG BE FOLLOWED BY DETACH?
	JN	DSOIRP			:NO RETURN TO MAINLINE
	LHI	R1,ZAPPN		:Let Zapv clear buf and network side
	JAL	R9,W2CI			:Write Non-gobbling Zapper to buffer
::Now clean up Dispatcher side of log-in - no further need of it.
	LHI	R1,09F00	:Load a hard Zapper
	JAL	R8,DIRMES	:Send to Dispatcher on CHN
	LIS	R0,0		:Zero out scratch permuter table
	STH	R0,GDLGTB,CHN,CHN
	XHI	R2,4		:Flip to To Termnal buffer, set up via CRQ
	STH	R0,BF,R2,	:Zero our previously marked as Log-in BF
	RBT	CHN,LOGING		:reset..
	JAL	R9,GLZPV,,		:Clear dispatcher side immediately
GDB45A	J	DSOIRP			:RETURN

:	IIX CKT - SEND LOGIN STATUS BACK TO ORIGIN OF CKT
GDB46	NHI	R10,0BF			:DONT SEND ECHO ON

:	IIX LOGIN STATUS - RETURNS NETNAME (IF NON-TRANSPARENT) AND IIX
:	LOGIN STATUS MSG
:	REQUIRES	R2 = BUFF INDEX
:			CHN = Relative Dispatcher port #
:			R10 = LOGIN STATUS BYTE
	IF	NETNAM
	TBT	CHN,GTTRNS		:Transparent user?
	JE	GB4DX1			:NO, SKIP
	LR	R11,R11			:CHECK MSG TYPE
	JE	GB4DX1			:IF 'CONTINUE', SKIP
	LA	R4,CRLF			:OUTPUT CR, LF
	JAL	R9,BUFCAN			:/
	LA	R4,ISISN		:OUTPUT NETNAME
	JAL	R9,BUFCAN			:/
	LA	R4,SPAC			:...AND A SPACE
	JAL	R9,BUFCAN			:/
GB4DX1	HS	0
	EI	:(NETNAM)
	LA	R4,IIXLMS		:BEGINNING OF IIX LOGIN STATUS MSG
	JAL	R9,BUFCAN			:OUTPUT IT
GB4DX4	CLHI	R11,7			:DOES STATUS BYTE NEED TO BE ESCAPED?
	JGFS	GB4DX2			:NO
	LIS	R1,0			:YES, OUTPUT AN ESCAPE
	JAL	R8,WCI			:/
GB4DX2	LR	R1,R10			:GET STATUS BYTE
	JAL	R8,WCI			:SEND IT
	J	GDB45


::*********************************************************************
::
::	ENTRY POINT:	GDB5:	Gateway Dispatcher B5 Message Handler
::	FUNCTION:	Handles the B5 Log-on response.
::	INPUT:		CHN	=  Relative Dispatcher port number
::			R2	=  Buffer number of outbound (to terminal)
::	CALLS:		JAL	R8,GCI
::			JAL	R8,DIMMES
::			JAL	R8,DIRMES
::	RETURNS:	Jumps directly back to DISOUT processing.
::
::*********************************************************************

GDB5	HS	0		:Handle B5 Messages for Gateway
::First, check to ensure that this is the correct circuit
	TBT	CHN,LOGING	:This channel should be in Log-in mode
	JE	GDB5SK		:Small Error, just skip it.
::Now double check to ensure that the right buffer is used
	XHI	R2,4		:Flip to incoming (from terminal)buffer
	LHL	R1,GDLGTB,CHN,CHN	:Get previously stored buffer
	CR	R1,R2		:These should match
	JE	GDB5SK		:They do - proceed
	J	DSOCRH		:No match  .. big problem
::As a triple check, the BF should indiciate Log-in state
GDB5SK	LHL	R1,BF,R2,	:Get flags field
	CLHI	R1,LOGMAX
	JG	DSOCRH
	CLHI	R1,LOGMIN
	JL	DSOCRH
::A zapper will follow this but we will implant a nongobl zap 
::and clean up dispatcher side right now
	LIS	R0,0
	STH	R0,BF,R2,		:Set BF to 0 for Zapv
	STH	R0,GDLGTB,CHN,CHN	:Clear scratch table
	JAL	R9,GLZPV,,		:and clear Disp IO and chn bit arrays
	LHI	R1,09F00
	JAL	R8,DIRMES
	RBT	CHN,DISFLG		:Disable dispatcher service
	RBT	CHN,LOGING		:and reset loging array
::Disp will skip Zap coming from INet sup
::Now send disconnect test to terminal user
	XHI	R2,4		:Flip to to-terminal buffer
	LB	R1,DORNG,PRD		:Get error code
	AIS	PRD,1
	NR	PRD,TC
	TBT	CHN,GIIXCT
	JN	GDB5FN
	::send error test message
	TBT	CHN,GTTRNS		:No text if transparent
	JN	GDB5FN
	LA	R4,GNGONE,,		:Send "inter-link cleared"
	JAL	R9,BUFCAN,,
	ROUTE(HOMEN,ISISN)
	LA	R4,CRLF,,
	JAL	R9,BUFCAN,,
GDB5FN	LHI	R1,ZAPPN			:Load non-gobbling zapper
	JAL	R9,W2CI,,
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	GDB6:	Gateway B6 message handler
::	FUNCTION:	Completes the Gateway LOg-in from HNET to INET.
::	CALLS:
::	RETURNS:	Jumps directly to DSOIRP.
::
::*********************************************************************
GDB6	HS	0		:Gateway B6 message handler
::First, check to ensure that this is the correct circuit
	TBT	CHN,LOGING	:This channel should be in Log-in mode
	JE	DSKP3		:Jump out to DISKIP's error handling
::Now double check to ensure that the right buffer is used
	XHI	R2,4		:Flip to incoming (from terminal)buffer
	LHL	R1,GDLGTB,CHN,CHN	:Get previously stored buffer
	CR	R1,R2		:These should match
	JE	GDB602		:They do - proceed
	J	DSOCRH		:Crash
::As a triple check, the BF should indicate Log-in state
GDB602	LHL	R1,BF,R2,	:Get flags field
	CLHI	R1,LOGMAX
	JG	DSOCRH		:Crash
	CLHI	R1,LOGMIN
	JL	DSOCRH
::	SUCESSFUL LOGON
	LB	R1,DORNG,PRD		:GET IIX FIELD (PRD advanced prior)
	LBR	R13,R1			:SAVE IIX BIT
	AIS	PRD,1
	NR	PRD,TC			:Move ring pointer to invoice number
	L	R1,DORNG,PRD
	ST	R1,ININV,,		:SAVE ISIS-NET NET INVOICE #
	AIS	PRD,4
	NR	PRD,TC			:Advance pointer again
::Now each Network must send the other its Invoice number
	IF	ACCT
	STM	R1,AARGSV
	AHI	CHN,DISZFL		:Make absolute - AASWAP will rtrn rel
	LR	R3,CHN			:Load  chan number in wrk reg
	CLHI	R3,MNACHN		:Do accounting range check
	JL	GDBSKP
	CLHI	R3,MXACHN
	JG	GDBSKP
	SHI	R3,MNACHN		:Make an accounting chan index
	JAL	R9,AAMKPT,,		:Get the block pointer (R11)
	GL	AAMKPT
	JAL	R10,AASWAP,,		:EXCHANGE INVOICE #'S
	GL	AASWAP
GDBSKP	HS	0
	LM	R1,AARGSV
	EI	:(ACCT)
::Toss originating host number, we don't need it
	AIS	PRD,2
	NR	PRD,TC
	RBT	CHN,LOGING		:NO LONGER IN LOGIN MODE
	TBT	CHN,GIIXCT		:WAS IIX REQUESTED?
	JEFS	GDB62			:NO
	LA	R4,IIXGRS		:YES, ASSUME GW REACHED SMART HOST
	SRLS	R13,1			:IIX BIT SET?
	JCFS	GDB61			:YES
	LA	R4,IIXGRD		:NO, GW REACHED DUMB HOST
GDB61	XHI	R2,4			:FLIP TO TO-TERM BUFFER
	JAL	R9,BUFCAN		:RETURN MSG TO ORIGIN
	XHI	R2,4			:FLIP BACK TO F. T. BUFFER	###EV
::Now connect the circuit and let data flow.
GDB62	LR	R1,R2			:Use work register
	SRLS	R1,1			:Make fullword index
	L	R0,FASTC,,
	ST	R0,BUFTIM,R1,		:Store Needle origination time
	LIS	R0,0
	STH	R0,GDLGTB,CHN,CHN	:Zero out scratch table
::Turn on Dispatcher port
	SBT	CHN,DISBPV		:Relieve backpressure,
	RBT	CHN,LOGING		:remove from Log-in status
	LHI	R0,INXLIM		:and set up intital
	STH	R0,DIXLIM,CHN,CHN	:transmit capacity
	AHI	CHN,DISZFL		:Make absolute channel number

::Continue circuit building 
	XHI	R2,4			:and get outbound (to term) buf#
	JAL	R9,CRQHCR,,		:Complete actual circuit
::Report IRC to Inet sup
	IF	IRC
	LHL	R3,BF,R2,		:ABSOLUTE CHAN#
	JAL	R9,FCHLNK,,		:FIND LINK# IN R0
	GL	FCHLNK
	J	GDB63			:Error return
	LR	R1,R0			:For indexing purposes
	LB	R7,IRCTBL,R1		:IS THERE IRC VALUE THIS LINK?
	JE	GDB63			:NO REPORT IF NO IRC VALUE
	STB	R7,GB7REA		:STORE INTO CANNED GB7 MSG.
	LHI	R1,-DISZFL,CHN		:GET RPORT
	STH	R1,GB7PRT
	LHI	R1,0E00E		:MSG.# 14 FOR IRC LOCATN DEFINED
	STH	R1,GB7INV		:Renew message type
	LIS	R1,0
	STB	R1,GB7INV+2		:(may have been previously used)
	LA	R1,GDB7M		:IRC ACCT.MSG. REPORT
	LHI	R3,GDB7L		:LENGTH BYTE
	JAL	R8,DIZSMS		:TO DISPATCHER PORT 0
GDB63
	EI	(IRC)
::Merge speed bits from origin side of circuit
	LHL	R1,BF,R2,		:Get other channel number
	LHL	R1,IOTAB,R1,R1		:Get permuter table entry
	NHI	R1,3			:Get speed bits
	LHL	R0,IOTAB,CHN,CHN	:Get table entry for circuit completion
	OR	R0,R1			:Install speed bits
	STH	R0,IOTAB,CHN,CHN	:Replace table entry
::Report to crypto log 
GDBC64	LHL	R0,BF,R2,		:Log first port
	EXHR	R0,R0
	XHI	R2,4
	LHL	R8,BF,R2,		:Then the other one
	AR	R0,R8
	JAL	R8,CRYPTO,,
	HC	CRYE0B
	LHL	R1,BCT,R2,		:Anything in F.T. buffer?
	JE	GDB573
	LHL	R1,BF,R2,
	SBT	R1,NFLAGS,,		:Set attention flag

GDB573	J	DSOIRP			:and continue

IIXGRS	XC	0401F68082		:SIIX + GW Reached smart host
IIXGRD	XC	0401F68083		:SIIX + GW Reached dumb host


	EI	:T2GATE

	SUBTTL	DISPI (DSZERO - Intra-ISIS Comunications, RPORT = 0)

::*********************************************************************
::
::	SUBROUTINE:	DSZERO:
::	FUNCTION:	PROCESS COMMANDS ON CHANNEL 0.
::			INTRA-ISIS COMUNICATIONS.
::
::*********************************************************************

DSZERO	LB	R1,DORNG+2,PRD,		:CHANNEL ZERO MESSAGE, GET TYPE
	CLHI	R1,DSZETL		:TEST NOT NECESSARY IF ISIS WORKING OK
	JLFS	DSZER1
	CRASH.(.DSZE0)
DSZER1	LHL	R1,DSZETB,R1,R1		:DISPATCH
	J	SEG1,R1,,

::*********************************************************************
::
::	SUBROUTINE:	DSZTLG:
::	FUNCTION:	07 - PSEUDO NEEDLE REQUEST
::			NORMAL CIRCUIT-BUILDING REQUEST
::
::*********************************************************************
	IF	(1-T2GATE)		:Not used for Gateway
DSZTLG	JAL	R10,DSZATS		:NORMAL CIRCUIT REQUEST - SET UP
	J	DSZ07B			:SOME FAILURE (SEE DSZATS)
	LHL	R1,DORHST		:GET HOST NUMBER (SET UP IN DSZATS)
	OHI	R1,8000			:PREPARE FOR SUP MESSAGE
	JAL	R9,WHWI			:WRITE INTO LOGIN BUFFER
	GL	WHWI
	LB	R1,DORNG,PRD,		:GET THE TID
	JAL	R8,WCI			:SEND IT TO THE LOG ON BUFFER
	LR	R0,R1			:GET TID FOR LOGIN ROUTINE
	JAL	R8,LOGIN
	GL	LOGIN
	J	DSZ07B			:NO SUP, ZAP IT
	LH	R0,DORSIQ		:SEE IF SIQ SET FOR THIS CIRCUIT
	JGEFS	DZ0710			:NO
:	CIRCUIT HAS SIQ SET, IS 'SMART'. SET GOUGING BIT IN IOTAB FOR
:	THIS CIRCUIT SO LOGGER CAN INFORM SUP OF SMART CIRCUIT.
	XHI	R2,4
	LHL	R4,BF,R2,		:GET ORIGINATION CHANNEL
	LHL	R1,IOTAB,R4,R4
	AIS	R1,1			:'GOUGING' BIT FOR PORT IN LOGIN MODE
	STH	R1,IOTAB,R4,R4		: MEANS SMART CIRCUIT

DZ0710	HS	0
	SHI	CHN,DISZFL		:RELATIVE PORT #
					:RELATIVE DISPI CHANNEL #
	RBT	CHN,DISELS		:EXTENDED LOG-IN STATUS
	THI	R0,PSNELS		:TEST ELS BIT
	JEFS	DZ0711			:NO
	SBT	CHN,DISELS		:else set bit in ELS bit array
DZ0711	IF	EXPNDL
	THI	R0,PSNUUN		:did slot request UUN from sup?
	JEFS	DZ0713			:branch if not
	SBT	CHN,DISUUN		:else set bit in UUN bit array
DZ0713	EI	:EXPNDL
	RBT	CHN,DISAUX		:INDICATE NORMAL LOGON

:	PSEUDO NEEDLE REQUEST O.K. AND CHANNEL ASSIGNED. RETURN
:	PSEUDO NEEDLE TO REQUESTING SLOT.
DSZ07C	HS	0
	LHL	R1,HNPORT		:INCREMENT NUMBER OF HOST PORTS IN USE
	AIS	R1,1
	CLH	R1,MXPORT		:IS THIS A NEW PEAK?
	JLEFS	DSZMPX			:NO
	STH	R1,MXPORT		:YES, RECORD IT
DSZMPX	STH	R1,HNPORT
	LH	R1,DORHST		:GET ORIG. HOST #
	STH	R1,DHSTIX,CHN,CHN	:SAVE IT FOR PROBE TRACE REPORTING
	LHI	R1,0B2			:'B2' MESSAGE - PSEUDO NEEDLE

DSZ07A	LHL	R6,RPSAV		:POINTS TO START OF MESSAGE
	STB	R1,DIRNG+2,R6,		:MESSAGE TYPE (0B2 OR OTHER)
	STH	CHN,DIRNG,R6,		:RELATIVE DISPI CHANNEL #
	AIS	R6,8
	NR	R6,TC			:UPDATE POINTER
	STH	R6,DRIF,,
	LHL	R8,DORSLT		:CIRCUIT ORIGINATING SLOT (SLOT# * 2)
	LIS	R1,1
	AHM	R1,SCLCNT-2,R8		:INCREMENT NUMBER OF CIRCUITS THIS SLOT
	IF	RESHST
	LR	HN,HN			:IS THIS HOST KNOWN TO US?
	JL	DSOIRP			:NO - EXIT
	AHM	R1,HCTSCT,HN,HN		:INCREMENT NUMBER OF CIRCUITS THIS HOST
	EI	:RESHST
	J	DSOIRP			:ALL DONE

:	REJECT LOGON
DSZ07B	LIS	R1,9			:REJECT LOGON (RETURN TYPE '9')
	LIS	CHN,0			:CHANNEL 0 MESS
	J	DSZ07A

::*********************************************************************
::
::	SUBROUTINE:	DSZALG:
::	FUNCTION:	08 - AUX CIRCUIT REQUEST
::
::*********************************************************************

DSZALG	JAL	R10,DSZATS		:AUX CIRCUIT REQUEST - SET UP
	J	DSZ08C			:FAILURE, REJECT
	IF	1-MXPNM			:MXP DISPATCHER CHECKS AUX CIRC LICENSE
	THI	R7,8000			:TEST SLOT LICENSE FOR AUX STATUS
	JE	DSZNAL			:NO AUX LICENSE, ABORT LOGIN
	EI	:1-MXPNM
	LB	LRC,DORNG,PRD,		:# CHARS IN STRING
	AIS	PRD,1			:START OF STRING
DSZ08A	LB	R1,DORNG,PRD,		:MOVE STRING
	AIS	PRD,1
	NR	PRD,TC
	OHI	R1,80			:ESCAPE ALL
	JAL	R8,WCI
	SIS	LRC,1
	JGBS	DSZ08A
:	IF LAST BYTE NOT CR OR SEMI-COLON, APPEND CR TO USER NAME
	CLHI	R1,8D			:= <CR> ?
	JEFS	DSZ08B			:YES, GO AHEAD
	CLHI	R1,0BB			:= "SEMI-:" ?
	JEFS	DSZ08B			:YES, GO AHEAD
	LHI	R1,8D			:APPEND A <CR> TO
	JAL	R8,WCI			: THE LOG IN STRING
DSZ08B	HS	0
	LIS	R0,0			:INITIATE LOGIN - AUX MODE
	JAL	R8,LOGIN
	J	DSZ07B			:NO SUP, REJECT LOGON
	SHI	CHN,DISZFL		:RELATIVE PORT #
	SBT	CHN,DISAUX		:INDICATE AUX LOGON
	J	DSZ07C

DSZNAL	JAL	R9,ZAPHRD,,		:ZAP HALF-CIRCUIT ALREADY BUILT FOR
:	SLOT WHICH ATTEMPTED AUX CIRCUIT WITHOUT PROPER LICENSE

DSZ08C	LB	LRC,DORNG,PRD,		:REJECT, SKIP TO END OF MESS
	AHI	PRD,1,LRC
	J	DSZ07B			:AND REJECT LOGON

::*********************************************************************
::
::	SUBROUTINE:	DSZATS:
::	FUNCTION:	SETUP ROUTINE FOR CIRCUIT REQUEST
::	CALLING SEQ:	JAL	R10,DSZATS
::
::*********************************************************************

DSZATS	HS	0
	LIS	R0,8			:SET UP TO RETURN NEEDLE OR REJECT
	JAL	R8,DIROOM
	LHL	R6,DRIF,,		:INPUT RING POINTER
	STH	R6,RPSAV		:SAVE IT FOR FILLING IN LATER
	LB	R8,DORNG+3,PRD,		:KEY (SLOT NUMBER * 4)
	STB	R8,DIRNG+3,R6,
	IF	MXPNM			:ISIS-MXP EXPECTS A DIFF KEY 	###GT
					: ( = SLOT #, MACHINE #)	###GT
	SLLS	R8,4			:SHIFT LO 4 BITS TO UPPER 4 BITS###GT
	EXBR	R7,R8			:MOVE UPPER 4 BITS TO LO 4 BITS	###GT
	OR	R8,R7			:FORM A SLOT # (MACH #, SLOT #)	###GT
	NHI	R8,0FF			:SAVE LOWER BYTE		###GT
	SLLS	R8,1			:FORM HALFWORD INDEX		###GT
	ELSE				:OLD-FASHIONED ISIS HAS KEY=SLOT # * 4
	LHL	R7,SLTLIC,R8		:GET SLOT LICENSE
	SRLS	R8,1
	EI	:MXPNM			:MXP DIFFERENCE ENDS HERE
	STH	R8,DORSLT		:SAVE SLOT NUMBER * 2
	AIS	R6,4
	NR	R6,TC
	AIS	PRD,4
	NR	PRD,TC			:NOW POINTS TO LOCAL KEY
	LHL	R1,DORNG,PRD,		:KEY
	STH	R1,DIRNG,6,
	LHL	R1,DORNG+2,PRD,		:HI-ORDER BIT OF 'DIALECT' FIELD
	STH	R1,DORSIQ		: IS SIQ
	LIS	R1,0
	STH	R1,DIRNG+2,6,
	AIS	R6,4
	NR	R6,TC			:PUT AWAY POINTER
	AIS	PRD,4			:POINT PRD TO ORIGINATING HOST #
	NR	PRD,TC
	LHL	R1,DORNG,PRD,		:GET ORIGINATING HOST,
	STH	R1,DORHST		: AND SAVE FOR 'LOGIN'
	AIS	PRD,2			:PRD NOW POINTS TO TID OR BYTE COUNT
	IF	RESHST
	LCS	HN,1			:IF NEGATIVE, HOST NOT FOUND,SEE DSZ07C
	LR	R1,R1
	JE	DSZT10			:HOST 0 NOT DEFINED
	JAL	R9,FNDHST,,		:DO WE KNOW ABOUT THIS HOST?
	J	DSZT10			:NO - SKIP ORIGIN HOST EDIT
	LH	R0,HCTSM,HN,HN		:GET CIRCS/MINUTE LIMIT FOR THIS HOST
	JLFS	DSZT10			:NO EDITING DESIRED
	CLH	R0,HCTSCT,HN,HN		:LIMIT EXCEEDED?
	JE	DSZT30			:JUST REACHED LIMIT - MAKE NODE REPORT
	JLR	R10			:YES - REJECT THIS CIRCUIT
	JFS	DSZT20			:NO, O.K. TO ATTEMPT CIRCUIT BUILDING
	EI	:RESHST
DSZT10	LH	R0,SCLTBL-2,R8		:GET LIMIT FOR CIRCS/MINUTE THIS SLOT
	JLFS	DSZT20			:NO EDITING DESIRED
	CLH	R0,SCLCNT-2,R8		:LIMIT EXCEEDED?
	JE	DSZT30			:JUST REACHED LIMIT - MAKE NODE REPORT
	JLR	R10			:YES - REJECT CIRCUIT
DSZT20	LHI	R1,NDP-1		:FIND A FREE CHANNEL
	LHI	CHN,DISZFL+1
	JAL	R9,FNDCHN,,
	GL	FNDCHN
	J	0,R10			:(immediate return) REJECT
	JAL	R8,GFCBUF,,		:(+4 return) GET BUFFER  
	J	0,R10			:(immediate return) REJECT
	JAL	R9,CRQHCR,,		:(+4 return) BUILD HALF CIRCUIT
	LHI	R1,-DISZFL,CHN		:R1 = REL. DISPI CHN #
	SBT	R1,DISBPV		:RELEASE BP
	LHI	R0,INXLIM
	STH	R0,DIXLIM,R1,R1		:TRANSMIT LIMIT PER PORT.
	J	4,R10			:ALL OK
DSZT30	LR	R6,R10			:SAVE RETURN ADDRESS
	OHI	R1,8000
	STH	R1,SUPMBF+4		:HOST NUMBER + 8000
	SRLS	R8,1
	OHI	R8,8000			:SLOT NUMBER + 8000
	STH	R8,SUPMBF+2
	LHI	R8,NR.CLE
	STH	R8,SUPMBF		:INDICATE HOST/SLOT CIRC LIMIT EXCEEDED
	JAL	R10,SUP12,,		:MAKE REPORT TO SUP LOG
	JR	R6			: AND MAKE NON-SKIP RETURN

	EI	:(1-T2GATE)		: All of above not used for Gateway

::*********************************************************************
::
::	SUBROUTINE:	DSZHSH:
::	FUNCTION:	10 - EXTENDED REPORT HOST STATUS
::	FORMAT:
::		--------.-------.-------.--------
::		|	0       |  10   |  key  |
::		|-------.-------.-------.-------|
::		|  Host number  | number/ports  |
::		|-------.-------.-------.-------|
::		|    RH No.     |status | H key |
::		|-------.-------.-------.--------
::		|xstatus|  PID |
::		-----------------
::	Status currently specifies these parameters:
::		The low 2 bits specify one of 4 host states:
::			0	host answered
::			1	host down
::			2	host shut (but up)
::			3	host gone
::		The next bit (mask x04) specifes if H key is meaningful.
::	Xstatus, the eXtended status byte currently specifies:
::		I O D P C C 0 0
::		I	Host I/Q (HIQ)
::		O	Originate only
::		D	Destination only
::		P	Proxy host
::		C C	Collect-call capability:
::			0	never accept collect calls
::			1	only accept collect calls
::			2	leave the decision to the destination host
::			3	unused
::		0 0	Unused
::	MESSAGE FROM HOST WHICH INCLUDES HOST STATUS, HIQ, AND HID.
::	HOST STATUS PROCESSING IS THE SAME AS FOR THE TYPE 04 ISIS
::	MESSAGE FOR REPORTING HOST STATUS ONLY.  THE CELL 'DSOHYP' IS
::	SET TO -1 FOR TYPE 10 MESSAGE, 0 FOR TYPE 04 MESSAGE SO COMMON
::	LOGIC CAN BE USED.
::
::	THE NODE-TO-SUPERVISOR MESSAGE, TYPE 11, MAY INCLUDE HOST STATUS,
::	HIQ, AND HID.  THE FORMAT OF THE FIRST HALFWORD OF THE MESSAGE
::	INDICATES THE MESSAGE CONTENTS TO THE SUPERVISOR. THE FIRST HALFWORD IS
::			[11,X0+STATUS],
::	WHERE X IS DEFINED BY THE FOLLOWING EQUATES:
::
::*********************************************************************

HS.HID	EQ	80	:HID PRESENT IF 0.  6-BYTE MSG WITH HID, ELSE 4 BYTES.
HS.SET	EQ	40	:SET IF HS.HID NOT SET (TO PREVENT ESCAPING)
HS.STS	EQ	20	:IGNORE HOST STATUS BITS IF 1 (NO CHANGE IN STATUS)
HS.HIQ	EQ	10	:HIQ FLAG.  SMART HOST IF 1, ELSE DUMB.

	IF	(1-T2GATE)		:Gateway will not receive following

DSZHSH	HS	0			:INDICATE PROCESSING TYPE 10 MESSAGE
	TS	DSOHYP			:this message from slot has extra hw
	JFS	DZHS02			: containing HIQ & HID data for host

::*********************************************************************
::
::	SUBROUTINE:	DSZHST:
::	FUNCTION:	04 - REPORT HOST STATUS
::
::*********************************************************************

DSZHST	HS	0
	LIS	R2,0			:INDICATE PROCESSING TYPE 04 MESSAGE
	STH	R2,DSOHYP

:	COMMON LOGIC FOR TYPE 10 AND 04 MESSAGES

DZHS02	LB	R2,DORNG+3,PRD,		:SAVE KEY IN R2
	AIS	PRD,4
	NR	PRD,TC			:REPORT HOST STATUS
	LHL	R1,DORNG,PRD,		:HOST #
	JAL	R9,FNDHST,,		:LOCATE HOST ENTRY

	J	DZHS50			:NO ENTRY IN HOSTN TABLE.  MAKE ONE.

:	Found the host in HOSTN.  VERIFY THAT THE HOST KEY (4*SLOT #) MATCHES.

	CLB	R2,HSTKEY,HN
	JE	DZHS04			:BRANCH IF KEY MATCHES

	LB	R0,HSTAT,HN		:KEY DOESN'T MATCH. INCUMBENT HOST DWN?
	SIS	R0,1			:status 1 is "down"
	JE	DZHS03			:yes, host down			###wjl
	TBT	HN,HSTFLG		:reporting for the first time?	###wjl
	JN	DZHS70			:NO, REJECT THE PRETENDER

:	Old host coming up in new slot, but OK because old host is down or
:	host is reporting for the first time.  Do not report as "imposter" host
	LIS	R0,0			:				###wjl
DZHS03	STH	R0,HOSTN,HN,HN		:clear HOSTN table entry for old host
	STB	R0,HSTAT,HN		:clear host status		###LH

:	CLEAR EXPANDED HOST STAUTS FIELDS
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	STB	R0,HSTATN,HN		:clear expanded host status entry###LH
	SLLS	HN,1			:FORM FW INDEX INTO		###OAS
	ST	R0,HSTTIM,HN,HN		:HOST TIME ARRAY AND clear it.	 ###LH
	SRLS	HN,1			:RESTORE HN			###OAS

	J	DZHS50			:Install the new guy.  When that is
					:done, return here (to DZHS04)

:	Host status msg in proper slot (key matches),
:	or after an entry has been made for new host.  Process it.

DZHS04	SBT	HN,HSTFLG		:SET FLAG INDICATING GOT HOST STATUS
					:REPORT FROM ISIS.		###LH
	LHL	R1,DORNG+2,PRD,		:GET # OF PORTS
	NHI	R1,0FFF

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)
	JEFS	DZHS07			:OUT OF PORTS			###OAS
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R0,0FF-EHHOPT		:reset host out of ports bit	###JHL
	STB	R0,HSTATN,HN		:TO INDICATE PORTS AVAILABLE	###OAS
	JFS	DZHS08
DZHS07	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R0,EHHOPT		:set host out of ports bit	###jhl
	STB	R0,HSTATN,HN		:TO INDICATE OUT OF PORTS	###OAS

DZHS08	HS	0
	AIS	PRD,4
	NR	PRD,TC
	STH	R1,HMAXP,HN,HN		:SAVE MAXIMUM PORTS
	STH	R1,HSTPTA,HN,HN		:SAVE PORTS AVAILABLE
	LB	R0,DORNG+2,PRD,		:NEW STATUS, IS IT ANSWERING?
	NHI	R0,3			:CLEAR 'H KEY' BIT

	JN	DZHS06			:branch if not answering now
					:(gone,down, or shut)

	LB	R1,HSTAT,HN		:Host answering, then check what it was
	THI	R1,1

	JE	DZHS06			:don't report shut if it was already
					: shut or answered.

:	Report Host shut first if it was gone or down.
:	Host answering, and he hasn't been through the SHUT stage yet.
:	UPDATE HSTATN AND TIME OF UPDATE (USED FOR EXPANDED HOSTS STATUS)
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R1,0FF-EHSTTS		:AND STRIP OFF OLD STATUS BITS	###OAS
	OHI	R1,EHSHUT		:set status "shut"
	STB	R1,HSTATN,HN		:AND RESTORE			###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW,,		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO HOST TIME	###OAS
	ST	R0,HSTTIM,HN,HN		: ARRAY, STORE CURRENT TIME	###OAS
	SRLS	HN,1			:RESTORE HN			###OAS

	LIS	R0,2			:REPORT HIM SHUT FIRST
	STB	R0,HSTAT,HN
	JAL	R10,SUP1A,,		:SEND NODE-TO-SUP MSG 1AN###GT ###LH
	GL	SUP1A
	LIS	R0,0			:pretend status "answered" to gen
					:another host status message "answered"

:	SET UP FOR REPORT:  SEND NODE-TO-SUP MESSAGE, TYPE 11, HOST STATUS.
:	THE FIRST HALFWORD OF THE HOST STATUS REPORT IS OF THE FORMAT
:	[11,X0+STATUS]. THE LO-ORDER BYTE OF THIS HALFWORD IS ASSEMBLED
:	IN R14 FOR THE CALL TO SUPHS, WHICH ACTUALLY MAKES THE REPORT.
:	Each of the following states come here:
:	(1) Host is not answering now (gone,down, or shut).
:	(2) Host is answering and it was answered, too.
:	(3) Host is answering and has been through the SHUT stage already.

DZHS06	HS	0
	LHI	R14,1100+HS.HID		:INITIAL VALUE
					: - STATUS PRESENT, HOST ID (HID)
					:NOT PRESENT, HOST IQ (HIQ) DUMB...
	CLB	R0,HSTAT,HN		:HAS THE HOST STATUS CHANGED?
	JNFS	DZHS10			:YES - NEED TO REPORT HOST STATUS
	LH	R1,DSOHYP		:IS HYPE FIELD PRESENT? (type 10 msg)
	JE	DZHS40			:NO HYPE, NO STATUS CHANGE - NO REPORT!

	JN	DZHS11			:NO STATUS CHANGE,
					: BUT NEED PRESENT HYPE		###LH

:	HERE FOR HOST STATUS CHANGE

DZHS10	LB	R1,HSTAT,HN		:SEND A '1A' REPORT TO SUP FIRST###GT
					:IF PREVIOUS STATUS WAS 'GONE'	###GT
	STB	R0,HSTAT,HN		:SAVE NEW HOST STATUS
	SIS	R1,3			:CHECK FOR 'GONE'		###GT
	JNFS	DZHS12			:PREVIOUS STATUS WAS NOT 'GONE' - JUST
					:CONTINUE			###LH
	JAL	R10,SUP1A,,		:SEND MESSAGE '1A' TO SUP	###GT
DZHS11	OHI	R14,HS.STS		:SUP WILL IGNORE HOST STATUS	###LH

DZHS12	HS	0
	LB	R0,HSTAT,HN		:RESTORE HOST STATUS		###LH
	OR	R14,R0			:COMBINE HOST STATUS WITH WORKING
					: HEADER			###LH

:	UPDATE HSTATN AND TIME OF UPDATE (USED FOR EXPANDED HOST STATUS)
	SLLS	R0,6			:MOVE HSTAT (BITS 6,7)
					: TO HSTATN (BITS 0,1)
	LB	R1,HSTATN,HN		:GET HSTATN			###OAS
	NHI	R1,0FF-EHSTTS		:strip off old status bits
	OR	R1,R0			:COMBINE			###OAS
	STB	R1,HSTATN,HN		:AND RESTORE			###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW,,		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO HOST TIME	###OAS
	ST	R0,HSTTIM,HN,HN		: ARRAY AND STORE CURRENT TIME	###OAS
	SRLS	HN,1			:RESTORE HN			###OAS

	LH	R4,DSOHYP		:HYPE FIELD PRESENT?
					:NO, IT IS ISIS MESSAGE TYPE 04
	JE	DZHS30			:REPORT HOST STATUS ONLY

:	PROCESS HIQ AND HID FOR ISIS MESSAGE TYPE 10
	LR	R4,PRD			:TEMP RING POINTER, PRESERVES PRD...
	AIS	R4,4
	NR	R4,TC			:ADVANCE RING POINTER
	LH	R4,DORNG,R4,		:GET HYPE FIELD
:	THE COMBINATION OF HIQ AND HID IS CALLED HYPE. THE HI-ORDER BIT OF
:	HYPE IS HIQ, THE LO-ORDER BYTE IS HID.
	JE	DZHS30			:NO HIQ OR HID - GO REPORT STATUS
	JG	DZHS20			:NO HIQ - DUMB HOST
	OHI	R14,HS.HIQ		:INDICATE SMART HOST

:	SET IIX BIT IN HSTATN (USED FOR EXPANDED HOST STATUS)
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R0,EHIIX		:set IIX bit in HSTATN
	STB	R0,HSTATN,HN		:TO INDICATE HOST IIX		###OAS

:	PROCESS ORG/DEST BITS (USED FOR EXPANDED HOST STATUS)
DZHS20	HS	0
	LR	R0,R4
	NHI	R0,6000			:ISOLATE ORG/DEST ONLY BITS (1/2)###OAS
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS
	NHI	R1,0FF-EHORGN-EHDSTN	:strip off org/dest bits
	SRLS	R0,0B			:GET 1,2 OF HO BYTE INTO 4,5 OF LO BYTE
	OR	R1,R0			:AND COMBINE WITH		###OAS
	STB	R1,HSTATN,HN		:PREVIOUS EXPANDED HOST STATUS	###OAS
	LR	R0,R0
	JEFS	DZHS21			:NOT ORG ONLY			###OAS
	CLHI	R0,EHORGN+EHDSTN	:dest only and org only?
	JNFS	DZHS21			:if both, pretend not org only

:	ORIGIN ONLY HOST, SEND OUT OF PORTS MESSAGE TO SUPERVISOR
	LHL	R1,HOSTN,HN,HN		:GET HOST NUMBER FOR SUP REPORT	###OAS
	STH	R1,SUPMBF
	LHI	R5,8F			:SEND HOST OUT OF PORTS		###OAS
	JAL	R10,SUP14,,		:TO SUPERVISOR			###OAS

:	PROCESS PROXY HOST AND COLLECT-CALLS BITS (3,4,5)		###wjl
DZHS21	HS	0
	LR	R0,R4			:get Hype field back		###wjl
	NHI	R0,1C00			:isolate Proxy & CC bits (3,4,5)###wjl
	SRLS	R0,8			:3,4,5 of HO byte to 3,4,5, of LO byte
	STB	R0,HSTAT3,HN		:store for SUP 1A and SUP 19 msg###wjl

	NHI	R4,7FFF			:ISOLATE HID
	JEFS	DZHS30			:DON'T HAVE HID IF ZERO

:	PROCESS HOST ID (USED FOR EXPANDED HOSTS STATUS)
	STB	R4,HSTYPE,HN		:STORE HOST TYPE		###OAS

	XHI	R14,HS.HID+HS.SET 	:INDICATE HOST ID PRESENT, SET
				  	:HS.SET BIT TO PREVENT ESCAPING

:	SEND HOST STATUS REPORT (SUP 11) TO SUP

DZHS30	JAL	R10,SUPHS,,		:MAKE REPORT TO SUP. HEADER BYTE IN R14
	GL	SUPHS			:HID IN R4
	LHL	R0,HOSTN,HN,HN
	STH	R0,CRYSBF+2,,
	LB	R0,HSTAT,HN
	JAL	R8,CRYPTO,,
	HC	CRYE15			:CHANGE IN HOST STATUS

:	REPORT MULTI-BASE HOST KEY IF PRESENT AND HOST ANSWERED OR SHUT
DZHS40	HS	0
	LB	R0,HSTAT,HN		:HOST ANSWERED ?
	JEFS	DZHS42			:YES
	CLHI	R0,2			:MULTI-BASE HOST KEY VALID IF HOST SHUT
	JN	DZHS44			:NOT ANSWERED OR SHUT

:	HERE IF HOST IS ANSWERED OR SHUT

DZHS42	LIS	R0,5			:TEST 5TH BIT IN STATUS FOR 'SEND KEY'
	TBT	R0,DORNG+2,PRD,		: (BIT SET FOR SENDING IT)
	JE	DZHS46			: (RESET FOR NOT SENDING)
	LB	R0,DORNG+3,PRD,		:HOST KEY = 0 ?
	STH	R0,SUPMBF+2		:SAVE KEY

:	PROCESS MULTI-BASED HOST KEY (USED FOR EXPANDED HOST STATUS)
	STB	R0,HSTMBK,HN		:STORE MULTI BASED HOST KEY	###OAS

	LHI	R5,8C			:TELL SUP IT'S HOST # & KEY
	LIS	R1,0			:SENT BY NODE CODE
	LIS	R6,2			:2 HALFWORDS OF DATA IN SUPMBF
	LHL	R0,HOSTN,HN,HN		:GET HOST NUMBER
	STH	R0,SUPMBF		:SEND TO SUP
	JAL	R10,SUP14,,		:SEND MESSAGE
	J	DZHS46

:	HERE IF HOST NOT ANSWERED OR SHUT, STATUS IN R0

DZHS44	SIS	R0,3			:IS HOST GONE?
	JN	DZHS46			:NO

:	HERE IF HOST IS GONE, CLEAR ENTRY FOR THIS HOST

	STH	R0,HOSTN,HN,HN		:YES, CLEAR ENTRY
	STB	R0,HSTAT,HN		:CLEAR STATUS			###LH

:	CLEAR FIELDS USED FOR EXPANDED HOST STATUS
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	STB	R0,HSTATN,HN		:CLEAR EXTENDED HOST STATUS	###LH
	SLLS	HN,1			:FORM FW INDEX INTO		###OAS
	ST	R0,HSTTIM,HN,HN		:HOST TIME ARRAY AND CLEAR IT	###LH
	SRLS	HN,1			:RESTORE HN			###OAS

:	COMES HERE IF HOST IS DOWN, OR EVERTHING IS DONE.

DZHS46	AIS	PRD,4
	LH	R0,DSOHYP		:HOW LONG WAS MESSAGE FROM SLOT?
	JE	DSOIRP			:NOT LONG - 04 MESSAGE
	AIS	PRD,2			:LONG, TYPE 10 MESSAGE HAS EXTRA HW
	J	DSOIRP			:DONE, RETURN TO MAIN LOOP

:	HERE IF HOST STATUS REPORT FOR AN UNKNOWN HOST. MAKE AN ENTRY
:	FOR HOST AND MARK STATUS AS GONE.

DZHS50	JAL	R9,FNDHSL,,		:LOCATE A FREE ENTRY
	GL	FNDHSL
	J	DZHS52			:THERE ISN'T ONE, REJECT THIS HOST
	LHL	R1,DORNG,PRD,		:RESTORE HOST #

	IF	RESHST
	JAL	R9,VRHOST		:VERIFY THIS HOST
	J	DZHS54			:NOT A VALID HOST FOR THIS NODE OR SLOT
	EI	:RESHST

	STH	R1,HOSTN,HN,HN		:ENTER HOST #
	STB	R2,HSTKEY,HN		:SAVE SLOT# * 4, NON-MXP CONFIGURATIONS
					:SLOT #, MACHINE #, MXP CONFIGURATIONS

:	CLEAR FIELDS USED FOR EXPANDED HOST STATUS
	LIS	R0,0
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	LHI	R0,EHGONE		:set status bits to "gone"
	STB	R0,HSTATN,HN		:TO INDICATE GONE STATUS	###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW,,		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO HOST TIME	###OAS
	ST	R0,HSTTIM,HN,HN		: ARRAY AND STORE CURRENT TIME	###OAS
	SRLS	HN,1			:RESTORE HN			###OAS

	LIS	R0,3			:CALL HIM GONE
	STB	R0,HSTAT,HN		:AFTER MADE AN ENTRY FOR THE NEW HOST
	J	DZHS04			:AND PROCEED IT

:	REJECT HOST DUE TO MAX NUMBER ALREADY UP ON THIS NODE.

DZHS52	LIS	R9,0			:ERROR TYPE 0
	IF	RESHST
	J	DZHS60

:	REJECT HOST DUE TO NOT LEGAL RESTRICTED HOST

DZHS54	SBT	HN,RESHMS		:NODE REPORT BEEN SENT YET?
	JN	DZHS56			:YES - NO NEED TO SEND ANOTHER...
	LR	R6,R1
	LR	R7,R2			:SAVE SOME REGS
	OHI	R1,8000
	STH	R1,SUPMBF+4		:HOST NUMBER + 8000
	IF	1-MXPNM			:NON-MXP			###GT
	SRLS	R2,2
	EI	:1-MXPNM						###GT
	OHI	R2,8000
	STH	R2,SUPMBF+2		:SLOT NUMBER + 8000
	LHI	R1,NR.INH
	STH	R1,SUPMBF		:INDICATE INVALID RESTRICTED HOST
	JAL	R10,SUP12,,		:MAKE REPORT TO SUP LOG
	LR	R1,R6
	LR	R2,R7			:RESTORE REGS
DZHS56	LIS	R9,3			:ERROR TYPE '3'
	EI	:RESHST

DZHS60	EXBR	R9,R9			:REJECT HOST, R9 = ERROR * 100x
	LIS	R0,8			:MESSAGE SIZE
	JAL	R8,DIROOM		:GET ROOM FOR ISIS MSG
	LR	R0,R9			:SAVE ERROR NUMBER
	LHL	R9,DRIF,,		:GET FILL POINTER
:	OHI	R2,0B00			:CREATE '0B' MESSAGE, KEY ALREADY IN R2
	OHI	R2,INHTRJ^8		:CREATE '0B' MESSAGE, KEY ALREADY IN R2
	ST	R2,DIRNG,R9,		:SAVE 1ST 4 BYTES OF MSG
	AIS	R9,4			: /
	NR	R9,TC			:/

	EXHR	R1,R1			:'HOST #', '0000'
	AR	R1,R0			:'HOST #', 'ERR', '00'
	ST	R1,DIRNG,R9,		:SAVE 2ND 4 BYTES
	AIS	R9,4			: /
	NR	R9,TC			:/
	STH	R9,DRIF,,		:SAVE BACK THE INDEX
	AIS	PRD,4			:UPDATE OUTPUT EMPTY POINTER
	NR	PRD,TC
	J	DZHS46			:DONE WITH THIS MESSAGE

:	IMPOSTER HOST...HOST COMING UP ON A SLOT, ALREADY EXISTS IN
:	ANOTHER SLOT. SEND NODE REPORT AND REJECT THIS HOST.
DZHS70	HS	0
	STH	R2,DORSLT		:SAVE KEY FROM ISIS		###GT
	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R2,2			:ACTUAL SLOT NUMBER
	ELSE				:MXP -  HAVE TO SWAP NIBBLES	###GT
	SLLS	R2,4			:SHIFT LOWER 4 NIBBLES UP	###GT
	EXBR	R4,R2			:MOVE UPPER 4 BITS TO LO NIBBLE ###GT
	OR	R2,R4			:MAKE A NEW SLOT #		###GT
	NHI	R2,0FF			:MASK OFF UNWANTED BITS		###GT
	EI	:1-MXPNM						###GT
	STB	R2,SUPMBF+3		:SAVE NEW SLOT KEY (BAD GUY)
	LB	R9,HSTKEY,HN		:SAVE OLD SLOT KEY (GOOD GUY)
	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R9,2
	ELSE				:MXP - HAVE TO SWAP NIBBLES	###GT
	SLLS	R9,4			:SHIFT LOWER 4 NIBBLES UP	###GT
	EXBR	R4,R9			:MOVE UPPER 4 BITS TO LO NIBBLE ###GT
	OR	R9,R4			:MAKE A NEW SLOT #		###GT
	NHI	R9,0FF			:MASK OFF UNWANTED BITS		###GT
	EI	:1-MXPNM						###GT
	STB	R9,SUPMBF+2		:HW2 CONTAINS OLD SLOT, OFFENDING SLOT
	LH	R9,HOSTN,HN,HN		:STORE HOST NUMBER + 8000 IN HW3
	OHI	R9,8000
	STH	R9,SUPMBF+4
	LIS	R9,NR.HIM		:INDICATE IMPOSTER HOST,
	STH	R9,SUPMBF		: DETECTED BY NODE
	JAL	R10,SUP12,,		:SEND NODE REPORT
	LHL	R2,DORSLT		:RESTORE R2 - THE ISIS KEY	###GT
	LIS	R9,2			:GET ERROR NUMBER FOR SLOT MSG
	LH	R1,HOSTN,HN,HN		:GET HOST NUMBER
	J	DZHS60			:GO REJECT HOST

	IF	RESHST

::*********************************************************************
::
::	SUBROUTINE:	VRHOST:
::	FUNCTION:	VERIFY RESTRICTED HOST
::	CALLING SEQ:	JAL	R9,VRHOST
::	INPUT:		R1 = HOST NUMBER
::			R2 = REQUESTING SLOT NUMBER*4 IN R2.
::	RETURNS:	TEST FOR HOST NUMBER ENTRY IN GHSTTB TABLE.
::			IF NOT FOUND, OR IF FOUND BUT NOT LEGAL FOR REQUESTING
::			SLOT, DO NON-SKIP RETURN.
::
::*********************************************************************

VRHOST	HS	0
	LHI	R3,(RESHST-1)*2		:HW TABLE, 1 ENTRY EACH RESTRICTED HOST
VRHS10	CLH	R1,GHSTTB,R3		:ENTRY FOUND?
	JEFS	VRHS20			:YES
	SIS	R3,2
	JGEBS	VRHS10
	JR	R9			:ENTRY NOT FOUND - NON-SKIP RETURN

VRHS20	HS	0
	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R2,2			:CONVERT TO ACTUAL SLOT NUMBER
	EI	:1-MXPNM						###GT
	SLLS	R3,1			:MAKE FULLWORD INDEX
	LA	R4,GSHSTB,R3		:POINT TO GSHSnn ENTRY
	TBT	R2,0,R4			:IS HOST LEGAL FOR THIS SLOT?
	JEFS	VRHS30			:NO
	SRLS	R3,1
	LHL	R0,GCHSTB,R3		:GET CIRCUITS/MINUTE LIMIT
	STH	R0,HCTSM,HN,HN		: AND SAVE
	AIS	R9,4			:SKIP RETURN...
VRHS30	HS	0
	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SLLS	R2,2			:RESTORE R2
	EI	:1-MXPNM						###GT
	JR	R9			:RETURN
	EI	:RESHST

::*********************************************************************
::
::	SUBROUTINE:	DSZLGR:
::	FUNCTION:	03 - REPORT TO SUPERVISOR'S LOG
::	FORMATS:
::		--------.-------.-------.--------
::		|	0	|   03  |  key  |
::		|-------.-------.-------+-------|
::		|     DATA2	| R TYP | DATA1 |	R TYP:	Report Type
::		|-------.-------+-------+--------
::		|PROD ID|				PROD ID:  Product ID
::		---------
::
::			12 - ERROR LOG REPORT
::		[1280][ HW1][ HW2][ HW3]
::	This is the generic format for node reports.  HW1 can either be
::	[ss,xx] where ss = Slot number and xx = Product ID or [00,xx]
::	xx = node report type.  HW2 and HW3 are data.
::
::*********************************************************************

DSZLGR	HS	0
	LB	R1,DORNG+3,PRD,		:REPORT TO SUP'S LOG
	AIS	PRD,4
	NR	PRD,TC
	CLHI	R1,0FF			:KERNEL REPORT IF KEY = FF	###LH
	JE	DSZKER			:JUMP TO REPORT, DO NOT NEED TO CHECK
					:IF REPORT LIMIT EXCEEDED OR NOT###LH

	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R1,2			:GET ACTUAL SLOT NUMBER
	ELSE				:MXP				###GT
	SLLS	R1,4			:THE KEY = SLOT#, MACHINE #	###GT
	EXBR	R0,R1			:NEED TO SWAP NIBBLES		###GT
	OR	R1,R0			:AND OR INTO PLACE		###GT
	NHI	R1,0FF			:EXTRACT UPPER NIBBLE		###GT
	EI	:1-MXPNM		: TO FORM MACHINE #, SLOT #	###GT

	STB	R1,SUPMBF		:ACTUAL SLOT #
	SLLS	R1,1			:SLOT HALFWORD INDEX
	LH	R0,SMLTBL-2,R1		:GET SLOT'S SLOT REPORT LIMIT
	JLFS	DSZLG2			:NO LIMIT
	AIS	R0,1
	LIS	R10,1
	AHM	R10,SMLCNT-2,R1		:INCREMENT COUNT OF SLOT RPTS FOR SLOT
	CLH	R0,SMLCNT-2,R1		:IS LIMIT EXCEEDED?

	JLE	DSZLG4			:YES - SEND SLOT REPORT LIMIT EXCEEDED
					: - 1E MESSAGE TO SUP

	J	DSZLG2			:NO - SEND SLOT REPORT TO SUP	###LH

:	KEY - FF (KERNEL)

DSZKER	STB	R1,SUPMBF		:KEY - FF (KERNEL)		###LH

:	SEND SLOT OR KERNEL REPORT TO SUP

DSZLG2	L	R0,DORNG,PRD,
	EXHR	R0,R0			:GET THE HALFWORDS IN ORDER
	AIS	PRD,4
	NR	PRD,TC
	ST	R0,SUPMBF+2
	LB	R0,DORNG,PRD,
	AIS	PRD,4
	NR	PRD,TC
	STB	R0,SUPMBF+1
	JAL	R10,SUP12,,
	J	DSOIRP

DSZLG4	JL	DSZLG6			:PAST THRESHOLD - JUST CLEAN UP

:	SEND LIMIT EXCEEDED REPORT TO SUP
	SIS	R0,1
	STH	R0,SUPMBF+4		:EQUAL THRESHOLD - MAKE NODE REPORT
	SRLS	R1,1			:GET ACTUAL SLOT NUMBER,
	OHI	R1,8000			:REDUCE NETWORK ESCAPES,
	STH	R1,SUPMBF+2		:AND STORE
	LHI	R0,NR.SML
	STH	R0,SUPMBF		:INDICATE SLOT REPORT LIMIT EXCEEDED
	JAL	R10,SUP12,,		:AND SEND NODE REPORT TO SUPERVISOR

DSZLG6	AIS	PRD,8			:NO REPORT SENT - ADVANCE
	NR	PRD,TC			:RING POINTER PAST MESSAGE
	J	DSOIRP

DSZHAV	AIS	PRD,4
	NR	PRD,TC			:HOST AVAILABILITY
	L	R7,DORNG,PRD,		:HOST #, PORTS
	AIS	PRD,8
	NR	PRD,TC
	LHL	R2,TVRBUF
	JE	DSOIRP			:NO SUP
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	LHI	R1,140F
	THI	R7,0FFF
	JEFS	DSZL10
	AIS	R1,1
DSZL10	JAL	R9,WHWI			:HEADER
	EXHR	R1,R7
	JAL	R9,WHWI			:HOST #
	J	DSOIRP
::*********************************************************************
::
::	SUBROUTINE:	DSZHPA:
::	FUNCTION:	REPORT HOST PORT AVAILABILITY
::
::*********************************************************************

DSZHPA	LIS	R6,1			:HOST PORT AVAILABILITY
	AIS	PRD,4
	NR	PRD,TC
	LHL	R1,DORNG,PRD,		:HOST #
	JAL	R9,FNDHST,,		:FIND HOST (HN IS INDEX)
	J	DSZHP1			:NOT FOUND, SKIP IT

	STH	R1,SUPMBF
	LHI	R5,8F			:HOST OUT OF PORTS (MSG SUBTYPE)
	LHL	R0,DORNG+2,PRD,		:GET # AVAILABLE
	STH	R0,HSTPTA,HN,HN		:SAVE IN PORT AVAILABLE

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)
	JEFS	DSZH10
	LHI	R5,90			:HOST HAS PORTS (MSG SUBTYPE)	###OAS
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R1,0FF-EHHOPT		:reset host out ports bit,we have ports
	STB	R1,HSTATN,HN		:TO INDICATE PORTS AVAILABLE	###OAS
	JFS	DSZH11

DSZH10	HS	0			:OUT OF PORTS			###OAS
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R1,EHHOPT		:set host out of ports bit
	STB	R1,HSTATN,HN		:TO INDICATE OUT OF PORTS	###OAS

DSZH11	HS	0
	AIS	PRD,8
	NR	PRD,TC
	JAL	R10,SUP14,,
	J	DSOIRP

DSZHP1	AIS	PRD,8			:UPDATE RING POINTER
	NR	PRD,TC
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSZHCS:
::	FUNCTION:	0C - REPORT HOST COST
::
::*********************************************************************

DSZHCS	LHI	R5,88			:HOST COST
	LIS	R6,2			:SUP14 PARAMETER
	AIS	PRD,4
	NR	PRD,TC
	L	R0,DORNG,PRD,
	ST	R0,SUPMBF
	AIS	PRD,8
	NR	PRD,TC

:	UPDATE HSTCST (USED FOR EXPANDED HOST STATUS)
	LR	R1,R0
	EXHR	R1,R1			:ISOLATE			###OAS
	NHI	R1,7FFF			:HOST NUMBER IN R1		###OAS
	JAL	R9,FNDHST,,		:AND FIND HOST TABLE INDEX	###OAS
	J	DSOIRP			:NOT FOUND, IGNORE MESSAGE	###OAS
	LR	R1,R0
	NHI	R1,00FF			:ISOLATE HOST COST AND		###OAS
	STB	R1,HSTCST,HN		:STORE IN HOST COST TABLE	###OAS

	JAL	R10,SUP14,,
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSZACC:
::	FUNCTION:	PROCESS ISIS MESSAGE B7 - ADDENDUM TO ACCOUNTING
::			& INTRA-ISIS MESSAGE 05 - REPORT ACCOUNTING
::
::*********************************************************************

DSZACC	LHI	R5,89
	LIS	R6,2
	AIS	PRD,4
	NR	PRD,TC			:ACCOUNTING MESSAGE
	L	R0,DORNG,PRD,
	AIS	PRD,4
	NR	PRD,TC
	ST	R0,SUPMBF
	LIS	R1,4			:SET FLAG TO INDICATE DISPI SENDING
	JAL	R10,SUP14,,		: ACCT REC.
	J	DSOIRP			
	EI	:(1-T2GATE)		:End of Gateway non-use section

	IF	T2GATE
::*********************************************************************
::
::	ENTRY POINT	GLZ9:
::	FUNCTION:	Handles a Pseudo Needle Reject (Type 09) for Gateway.
::	CALLS:		JAL	R9,BUFCAN
::			JAL	R9,ZAPX,,
::	RETURNS:	J	DSOIRP
::
::*********************************************************************
GLZ9	HS	0			:Pseudo Needle reject
::Advance ring pointer 
	AIS	PRD,4
	NR	PRD,TC		:Move pointer to local key
::First, check to ensure that this is the correct circuit
	LHL	R2,DORNG,PRD,	:Local key should be buffer number
::The BF should indicate Log-in state
	LHL	R1,BF,R2,	:Get flags field
	CLHI	R1,LOGMAX
	JG	DSOCRH
	CLHI	R1,LOGMIN
	JL	DSOCRH
::BF shows in Log-in state .. proceede
: Since host shuts when we don't have INET supe this can only happen to
: needles built before HNET got our shut msg.  thus the ease of this
: justifies not sending a msg and all of the setup that would require (see
: the B2 logic)    ####sdw
	AIS	PRD,3
	NR	PRD,TC
	XHI	R2,4			:Point to outbound (to terminal) buf
        LHI     R1,ZAPPH                :
        JAL     R9,ZAPX,,
	LIS	R1,1
	AHM	R1,NC.CRZ		:Count uncompleted circuit for CRQ
	J	DSOIRP			:AND QUIT FOR NOW

::*********************************************************************
::
::	ENTRY POINT	G02NUP:	##AL
::	FUNCTION:	Handles INET node taken up. (Type 02) for Gateway.
::	CALLS:		JAL	R10,SUP11
::	RETURNS:	J	DSOIRP
::
::*********************************************************************
G02NUP	HS	0
        LB      R1,DORNG+3,PRD,         :new supe number
        JNFS    G02NU1                  :ISIS 5.08 put a zero in supe # field
        LHI     R1,7F                   :as compared to a real supe #   ###sdw
G02NU1  STB     R1,G0DFG                :save supe
	AIS	PRD,4			:ADVANCE MSG LENGTH IN PTR
	NR	PRD,TC			:WRAP TO A HW
        LIS     R10,0                   :init answerred
        LHL     R1,TVRBUF               :have Hnet supe?
        JNFS    G02NU2                  :yes
        LIS     R10,2                   :shut if not
G02NU2  LB      R1,HSTAT                :what was old host stat
        STB     R10,HSTAT               :save host status
        CR      R1,R10                  :find if any changes
        JE      DSOIRP                  :no changes to report
	JAL	R10,SUP11		:HST RPT FROM GW TO HNET SUP
	GL	SUP11
        LB      R3,HSTAT                :it wants our status.
        JAL     R10,GHSTST              :tell inet about us
	J	DSOIRP

::*********************************************************************
::
::	ENTRY POINT	G0DNSP:	##AL
::	FUNCTION:	Handles INET no sup. (Type 0d) for Gateway.
::	CALLS:		JAL	R10,SUP11
::	RETURNS:	J	DSOIRP
::
::*********************************************************************
G0DNSP	HS	0
	AIS	PRD,4			:ADVANCE MSG LENGTH IN PTR
	NR	PRD,TC			:WRAP TO A HW
	LIS	R1,2			:set host shut
	STB	R1,HSTAT
	LIS	R1,0                    :no supe on INET side
	STB	R1,G0DFG		:SET A FLAG FOR NODE TAKEN AGAIN
	JAL	R10,SUP11		:HST RPT FROM GW TO HNET SUP
	J	DSOIRP

LOFAIL	WC	LOF0-SEG1,LOF1-SEG1,LOF2-SEG1,LOF3-SEG1,LOF4-SEG1
	WC	LOF5-SEG1,LOF6-SEG1,LOF7-SEG1,LOF8-SEG1,LOF9-SEG1,LOFA-SEG1
NOLIST
LOF0	SC	'"8D"8AISIS unable to complete request'
LOF1	SC	'"8D"8Aformat error'
LOF2	SC	'"8D"8Abad user name'
LOF3	SC	'"8D"8Abad mud'
LOF4	SC	'"8D"8Asystem unavailable'
LOF5	SC	'"8D"8Adialout failure'
LOF6	SC	'"8D"8Atimeout'
LOF7	SC	'"8D"8Aaccess not permitted'
LOF8	SC	'"8D"8Aout of origination ports'
LOF9	SC	'"8D"8Asup reject...try later'
LOFA	SC	'"8D"8Aunable to complete request'
LIST
IIXGW	XC	0801F68080808201F7	:IIX REACHED GATEWAY MSG (SELECT GW DIALECT)
IIXMS1	XC	0601F680840001		:IIX 'PLEASE LOG IN' MSG
IIXLMS	XC	0401F68084		:START OF IIX LOGIN STATUS MSG
	EI	:T2GATE

::*********************************************************************
::
::	SUBROUTINES:	DSZK04,DSZK08,DSZK0C
::	FUNCTION:	TO SKIP OVER UNDECODED MESSAGES
::
::*********************************************************************

DSZK04	LIS	R0,4			:TO SKIP OVER UNDECODED MESSAGES
	JFS	DSZKIL
DSZK08	LIS	R0,8
	JFS	DSZKIL
DSZK0C	LIS	R0,0C
DSZKIL	AH	R0,DROE,,
	NHI	R0,DRSZ-4
	STH	0,DROE,,
	J	DSONXT

::*********************************************************************
::
::	SUBROUTINE:	DSIOER:
::	FUNCTION:	COME HERE FOR MESSAGES RECEIVED FROM THE
::			DISPATCHER WHICH ARE ONLY VALID GOING TOWARDS
::			THE DISPATCHER.
::
::*********************************************************************

DSIOER	HS	0
	CRASH.(.DSIO0)

::*********************************************************************
::
::	TABLE:		DSZETB:
::	FUNCTION:	DISPATCH TABLE FOR CHANNEL ZERO MESSAGES 
::			FROM ISIS.
::
::*********************************************************************

	IF	(1-T2GATE)	:Gateway uses own dispatch table
				:SUBTYPE

DSZETB	HC	DSZK04-SEG1	:00 - DISCONNECT (UNUSED)
	HC	DSZK04-SEG1	:01 - RESTART INTERFACE (UNUSED)
	HC	DSZK04-SEG1	:02 - TAKEOVER MESSAGE (N/A)
	HC	DSZLGR-SEG1	:03 - LOG REPORT
	HC	DSZHST-SEG1	:04 - HOST STATUS
	HC	DSZACC-SEG1	:05 - ACCOUNTING
	HC	DSZK08-SEG1	:06 - TIME (N/A)
	HC	DSZTLG-SEG1	:07 - TERMINAL LOGIN
	HC	DSZALG-SEG1	:08 - AUX LOGIN
	HC	DSZK08-SEG1	:09 - REJECT LOGON (N/A)
	HC	DSZHPA-SEG1	:0A - REPORT HOST PORT AVAILABILTY
	HC	DSZK08-SEG1	:0B - HOST UNACCEPT (N/A)
	HC	DSZHCS-SEG1	:0C - HOST COST
	HC	DSIOER-SEG1	:0D - NO SUP (ILLEGAL)
	HC	DSIOER-SEG1	:0E - 1-DOWN (PLITEXT) (ILLEGAL)
	HC	DSIOER-SEG1	:0F - REPORT ALL HOSTS (ILLEGAL)
	HC	DSZHSH-SEG1	:10 - HOST STATUS AND HYPE
DSZETL  EQ	(.-DSZETB)/2
	EI	:(1-T2GATE)	:End - not used for Gateway

	IF	T2GATE		:Gateway dispatch table for 
				: dispatcher port 0 messages

DSZETB	HC	DSZK04-SEG1	:00 - DISCONNECT (IGNORED)
	HC	DSZK04-SEG1	:01 - RESTART INTERFACE (IGNORED)
	HC	G02NUP-SEG1	:02 - TAKEOVER MESSAGE ##AL
	HC	DSIOER-SEG1	:03 - LOG REPORT
	HC	DSIOER-SEG1	:04 - HOST STATUS
	HC	DSIOER-SEG1	:05 - ACCOUNTING
	HC	DSZK08-SEG1	:06 - TIME 
	HC	DSIOER-SEG1	:07 - TERMINAL LOGIN
	HC	DSZK0C-SEG1	:08 - AUX LOGIN
	HC	GLZ9-SEG1	:09 - REJECT LOGON 
	HC	DSIOER-SEG1	:0A - REPORT HOST PORT AVAILABILTY
	HC	DSIOER-SEG1	:0B - HOST UNACCEPT
	HC	DSIOER-SEG1	:0C - HOST COST
	HC	G0DNSP-SEG1	:0D - NO SUP ##AL
	HC	DSIOER-SEG1	:0E - 1-DOWN 	:Illegal at this time
	HC	DSIOER-SEG1	:0F - REPORT ALL HOSTS 
	HC	DSIOER-SEG1	:10 - HOST STATUS AND TYPE(ILLEGAL)
DSZETL	EQ	(.-DSZETB)/2



	EI	:T2GATE


::*********************************************************************
::
::	SUBROUTINE:	DISKIP:
::	FUNCTION:	SKIP OVER DISPATCHER MESSAGE.
::			EXPECT PRD POINTING TO PORT #, UPDATES DROE.
::	CALLING SEQ:	JAL	R8,DISKIP
::
::*********************************************************************

DISKIP	NHI	PRD,DRSZ-4		:MAKE SURE PRD IS OK
	LB	R1,DORNG+2,PRD,		:GET TYPE
::Point of departure for Gateway Needle
	IF	T2GATE
	JE	GNEDIN		:Needle front end process for Gateway
	CLHI	R1,0B2		:Only other legal from this caller is B2
	JE	GDB2		:Go to the Gateway B2 handler
	ELSE
	JEFS	DSKP2			:NEEDLE (GROSSLY ILLEGAL)
	EI	:T2GATE
	CLHI	R1,DTDAT
	JG	DSKP3			:SOME CONTROL MESS
	LHI	R0,6,R1
	NHI	R0,DRSZ-4
DSKP1	AR	PRD,0
	NR	PRD,TC			:INDEX PRD
	STH	PRD,DROE,,		:UPDATE DROE
	JR	R8
DSKP2	LB	R0,DORNG+3,PRD,		:NEEDLE, GET ADDIT LENGTH
	AIS	R0,4			:OVERALL LENGTH
	JBS	DSKP1
DSKP3	CLHI	R1,DTCON		:TYPE TOO LARGE
	JLEFS	DSKP4
	CRASH.(.DSKP0)
DSKP4	LIS	R0,4
	SHI	R1,0B1
	JL	DSKP1
	LB	R0,DSKPLN,R1		:OVERALL LENGTH
	J	DSKP1

DSKPLN	BC	8,8,4,4,4,0C,8,4,4,4,4,4,4,4,4,4	:TYPES B1 - DTCON
	HS	0			:INSURE HW ALIGNMENT
	IF	T2GATE
::*********************************************************************
::	DIRECT ENTRY-
::	SUBROUTINE:	GNEDIN:	Gateway NEDle IN
::	FUNCTION:	Gateway Needle front end handler.  Called from
::			DISKIP+0A when a Needle is received on an un-
::			assigned Dispatcher port.  (This is only legal
::			for the Gateway.)  This routine serves to initiate
::			Gateway Log-on processing from the INET side.
::	CALLING SEQ:	JE	GNEDIN	:(based on getting Type 00 on port)
::	INPUT:		CHN	=  Dispatcher Port Number
::			PRD	=  Pointer to data in ring (empty cursor)
::	CALLS:		
::	RETURNS:	Returns to previously stored R8 return address
::			to jump to DSONXT.
::
::*********************************************************************

GNEDIN	HS	0		:Gateway gets Needle from Dispatcher on port #
	ST	R8,GDSAVE	:Save return address 
	STH	PRD,GDPRD	:Save PRD for restoration of ring pointer
	LB	R8,DORNG+3,PRD,	:Gets length of total Needle
	STB	R8,GDNLEN
	AIS	PRD,4
	NR	PRD,TC		:Now we're pointing to Invoice number
	L	R1,DORNG,PRD,	:Get INvoice #
	ST	R1,GDNINV	:Save this temporarily
	AIS	PRD,4
	NR	PRD,TC		:Now we're pointing at Dest. Host #
	LHL	R1,DORNG,PRD,	:Get Desination Host number (should
	CHI	R1,IHOST	: be IHOST for Gateway)
	JN	GDNERR		: Error, zap circuit
:Check to see if Sup exists -- either proceeed or abort
	LHL	R3,TVRBUF
	JE	GNOSUP		:Output "NO Net" message to INET user

::Initialize all log-on related bit arrays
	RBT	CHN,GTAUX	:Aux circuit thru Gateway
	RBT	CHN,GTHDX	:For Half-Duplex terminals
	SBT	CHN,GTASCI	:Not a 2741 TID
	SBT	CHN,GTECHO	:Echo permitted for this terminal
	SBT	CHN,GTLGEC	:Start log-in in Echo mode
	RBT	CHN,GTTRNS	:Assume non-transparent user
	RBT	CHN,GIIXCT	:Assume non-IIX circuit
	RBT	CHN,DISELS	:Not Extended log-on status (for node code)
	RBT	CHN,DISAUX	:Not Aux circuit (for node code)
	LIS	R0,0		:Initialize logon character counter
	STH	R0,GDLGTB,CHN,CHN
::Now set up Log-on buffer
	AHI	CHN,DISZFL	:Make Dispatcher port into absolute CHN
	JAL	R8,GFCBUF,,	:Get a free buffer (returned in R2)
	J	GDNERR		:Error, zap circuit
	JAL	R9,CRQHCR,,	:Build half circuit to buffer
	LHL	R1,IOTAB,CHN,CHN
	OHI	R1,02		:Allow characters .. but not IIX (yet)
	STH	R1,IOTAB,CHN,CHN	:###EV
	LHI	R1,-DISZFL,CHN	:Make relative chn #
	SBT	R1,DISBPV	:Release back pressure
	SBT	R1,LOGING	:Mark as in Log-on state
	SBT	R1,GMSG0F	:..and having data for the Log-in
	LIS	R0,3
	STB	R0,GLGCNT,R1,	:Initialize buffer count at 3 bytes
	IF	ACCT
::Store invoice number for internet exchange
	LR	R3,CHN		:Get chn # in work reg
	CLHI	R3,MNACHN	:Range check
	JL	GNED01 
	CLHI	R3,MXACHN
	JG	GNED01
	SHI	R3,MNACHN	:De-bias to make accounting port
	JAL	R9,AAMKPT,,	:Get pointer to accounting block
	L	R0,GDNINV	:Get previously stored invoice number
	OI	R0,80000000	:Set HO bit to indicate primary inv #
	ST	R0,AAINV,R11	:Store in Acct. blk
	EI	:(ACCT)
GNED01	LHI	R0,INXLIM
	STH	R0,DIXLIM,R1,R1	:Set up transmit limit

::Now begin to fill log-on buffer, starting with Host number
	LHI	R1,HHOST	:This log-on is from INET toward HNET
	OHI	R1,8000		:Prepare host # for Sup message
	JAL	R9,WHWI		:Write into login buffer
	GL	WHWI
	
	AIS	PRD,08
	NR	PRD,TC		:Now pointing to word with TPC at end
	LB	R1,DORNG+3,PRD,	:Get TPC
	STB	R1,GDTPC	: and store for later use
	AIS 	PRD,4
	NR	PRD,TC		:Now pointing to Dialect and TID
	SHI	CHN,DISZFL	:Make port index again
	LHL	R1,DORNG,PRD,	:Get dialect field
	STH	R1,GDDIAL	:Store for later

::Determine intelligence of circuit
	EXHR	R1,R1		:Less than 0 = HO bit set
	JGEFS	GNED02		:Not IIX, proceed
	SBT	CHN,GIIXCT	:Indicate as IIX circuit
	
GNED02	LHL	R1,DORNG+2,PRD,	:Get CCT and usrname size
	STH	R1,GDCCT	:and store for later
	EXBR	R1,R1		:Get CCT byte
	STB	R1,CCTTBL,CHN	:and table it for possible future reference???
	AIS	PRD,4
	NR	PRD,TC		:Now points to beginning of username

::Write whatever TID we have into buffer with Cntrl chars if needed
	LBR	R6,R1		:Save TID
	NHI	R1,1F		:Mask to get TID
	JE	GNEAUX		:If Aux-circuit TID (00)
	THI	R6,20		:If Half-Duplex TID
	JEFS	GNE010		:Not Hdx, more tests ...
	SBT	CHN,GTHDX	:Mark this one as Half dux
	J	GNE002
GNE010	LHI	R0,-8,R1	:If not Hdx then what about oddball 2741 etc.
	JL	GNE002		:Test for 2741 or 3767 terminal types
	SIS	R0,9-8
	JGFS	GNE002
	SBT	CHN,GTHDX	:This oddball is HDX
	RBT	CHN,GTECHO	:No echo allowed
	RBT	CHN,GTASCI	:A special distinction as HDX ascii 2741
	JFS	GNE002		:Now write it to buffer
GNEAUX	SBT	CHN,GTAUX	:Mark this one as Aux circuit
	RBT	CHN,GTECHO	:Suppress echo for Aux circuit
	LHI	R1,GAXTID	:Exchange for Gateway Aux TID '0E'
	JFS	GNE021
GNE002	LBR	R1,R6		:Get TID again
	OHI	R1,0C0		:Restore mask

GNE021	JAL	R8,WCI		:Write TID into buffer

::Continue processing with Username treatment
	TBT	CHN,GTHDX
	JEFS	GNE121
	LHI	R1,88		:For Half Duplex terminal
	JAL	R8,WCI		:Put CNTRL-H into buffer
GNE121	LB	R4,GDUNSZ	:Load username counter
	LB	R0,DORNG,PRD,	:First username character
	CLHI	R0,GXPRNT	:Is it "?" (0BF) ? (Transparent gateway user)
	JN	GNE025		:If not, flush name and continue

::For Transparent user, just copy Username
	AIS	PRD,1
	NR	PRD,TC		:Discard ?(BF) preceeding username
	SBT	CHN,GTTRNS	:Set as Transparent user
	RBT	CHN,GTLGEC	:Turn echo off
	LB	R1,GDTPC	:Get Througput class
	NHI	R1,3		:ONLY 2 bits on
	LB	R1,TPTBL,R1	:Get ascii from table
	JAL	R8,WCI		:Write cntrl-char for tput class to buffer

GNE020	SIS	R4,1		:Decrement counter (from usrnm+1)
	JEFS	GNE003		:Finished? then continue logon

	LB	R1,DORNG,PRD,	:Get Username character
	JAL	R8,WCI		:Put into log-on buffer
	AIS	PRD,1
	NR	PRD,TC
	J	GNE020		: until all characters transferred

GNE025	LB	R0,GDUNSZ
	AR	PRD,R0
	NR	PRD,TC		:Flush Username
GNE003	XHI	R2,4		:Flip to terminal bound buffer
	TBT	CHN,GIIXCT	:If IIX circuit
	JEFS	GNE032		:No
	LA	R4,GIIXGW	:If IIX, send 'reached IIX Gateway"
	JAL	R9,BUFCAN	:Send it
GNE032	TBT	CHN,GTTRNS
	JN	GNE035		:Yes, don't send banner

GNE033	LA	R4,GNETOK	:If not Xprnt nor IIX send 'interlink' banner
	JAL	R9,BUFCAN
	GL	FROM,TO,ISISN,BUFCAN,HOMEN
	ROUTE(ISISN,HOMEN)
	LA	R4,CRLF
	JAL	R9,BUFCAN
	LA	R4,GATPLI
	TBT	CHN,GIIXCT
	JEFS	GNE034
	LA	R4,GIXPLI	:If IIX load IIX PLI message
GNE034	JAL	R9,BUFCAN


GNE035	TBT	CHN,GIIXCT	:See if 'smart' bit is set
	JEFS	GNE710		:No bit set, proceeed
	LHL	R4,BF,R2,
	LHL	R1,IOTAB,R4,R4
	AIS	R1,1		:'Gouging --  bit in LOg-in mode
	STH	R1,IOTAB,R4,R4	:means 'smart' 
GNE710	XHI	R2,4		:Flip back to log-on (to Sup) buffer
	SBT	CHN,GORGPT	:Mark channel as an originating port
	RBT	CHN,GDSTPT
	LR	R1,R2
	LIS	R2,LOGBUF	:Put buffer on LOGGER's list
	JAL	R9,WHWI0
	GL	WHWI0
	LHI	R0,LGST.N	:Init N.C. & TID ready flag
	STH	R0,BF,R1,	:Set BF to log-on state
	LR	R2,R1
	SRLS	R2,1		:Set buffer timer index
	L	R9,SLOWC,,
	AHI	R9,GLGTMR	:Set 2 minute timer
	ST	R9,BUFTIM,R2,
	SLLS	R2,1		:restore buffer index

	LHL	R1,HNPORT	:Increment  port counter
	AIS	R1,1
	CLH	R1,MXPORT
	JLEFS	GNEMXP		:Not a new peak
	STH	R1,MXPORT	:otherwise store it
GNEMXP	STH	R1,HNPORT
	LH	R1,HHOST	:Housekeeping - store host number for 
	STH	R1,DHSTIX,CHN,CHN	:possible circuit trace

	J	GNEXIT

::*********************************************************************
::
::	ENTRY POINT:	GDNERR:	Gateway Dispatcher NEedle ERRor
::	FUNCTION:	Sends Zap back on Dispatcher port which had 
::			sent a Needle on an unassigned port - due to
::			some circuit building error.
::	CALLING SEQ:	JUMP directly to GDNERR
::	INPUT:		CHN 	= Channel (relative dispatcher port)
::	RETURNS:	Jumps directly to GNEDIN exit point.
::
::*********************************************************************
GDNERR	HS	0
	LHI	R1,9F00
	JAL	R8,DIRMES		:Send zapper on Dispatcher port
	J	GNEXIT			:And finish turn off


::*********************************************************************
::
::	GNOSUP:		Sends "unable to complete inter-link" to terminal 
::			user -  due to no Supervisor on the HNET side
::	CALLING SEQ:	JUMP directly to GNOSUP
::	INPUT:		CHN 	= Channel (relative dispatcher port)
::	RETURNS:	Jumps directly to GNEDIN exit point.
::
::*********************************************************************
GNOSUP	HS	0		:put nonet towards dispatcher
	LA	R1,GNONET
	JAL	R8,DIMMES
	LHI	R1,9E00		:Must Zap incoming circuit
	JAL	R8,DIRMES

::Now all Needle front end for Log-on buffer is complete - restore
::ring pointer and return exit to DSONXT

GNEXIT	HS	0
	LB	R0,GDNLEN	:Get additional length of needle
	AIS	R0,4		:Make it total length
	LHL	PRD,GDPRD	:Restore pre-needle ring pointer
	AR	PRD,R0		:..and do virtual flush of needle
	NR	PRD,TC
	STH	PRD,DROE,,	:Update ring pointer
	L	R8,GDSAVE	:Restore return address
	JR	R8		:Return to Dispatcher processing






::Throughput class table indexed by TPCLASS field in ISIS Needle
TPTBL	BC	81,82,83,84	:CNTRL-A, B, C, D.

::Various messages for Log-on processing from INET to HNET

GNONET	SC	'"8D"8Aunable to complete inter-link...try again in a few minutes'
GNETOK	SC	'"8D"8Ainter-link established'
GNGONE	SC	'"8D"8Ainter-link cleared'
GIIXGW	XC	0801F68080808201F7	:IIX reached Gateway(select GW dialect)
GIXPLI	XC	0601F680840001		:IIX 'Please Log In'
GATPLI	SC	/please log in: /
CRLF	SC	/"8D"8A/
	EI	:T2GATE

	SUBTTL	DISPI (Utility routines)

::*********************************************************************
::
::	SUBROUTINE:	DIRMES:
::	FUNCTION:	SEND A 1-WORD MESSAGE
::	CALLING SEQ:	JAL	R8,DIRMES
::	INPUT:		R1 = 2 BYTES DATA
::			CHN = CHANNEL #
::	DESTROYED:	R3
::
::*********************************************************************

DIRMES	HS	0
	LHL	R3,DRIF,,		:INPUT PTR
	STH	CHN,DIRNG,R3,
	STH	R1,DIRNG+2,R3,
	AIS	R3,4
	NHI	R3,DRSZ-4
	STH	R3,DRIF,,
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	DIROOM:
::	FUNCTION:	DISMISSES UNTIL SPACE MADE IN THE INPUT RING.
::	CALLING SEQ:	JAL	R8,DIROOM
::	INPUT:		R0 = SPACE REQUESTED
::	DESTROYED:	R3
::
::*********************************************************************

DIROOM	LH	R3,DRIE,,		:COMPUTE EXISTING SPACE
	SH	R3,DRIF,,
	JGFS	DIRO10
	AHI	R3,DRSZ			:ALLOW FOR RING WRAP
DIRO10	SIS	R3,4			:FILL MAY ONLY GET WITHIN 4 OF EMPTY
	CR	R0,R3			: POINTER
	JLER	R8			:ENOUGH SPACE--RETURN TO CALLER
	SVC	DISMIS,0		:NOT ENOUGH, DISMISS
	J	DIROOM

::*********************************************************************
::
::	SUBROUTINE:	DIMMES:
::	FUNCTION:	MGVES CANNED MESSAGES TO DISPATCHER INPUT
::			RING. (TOWARD APPLICATION SLOTS)
::			DATA STRING IN THE FORMAT (n/B1/B2/..  ../Bn)
::
::	CALLING SEQ:	JAL	R8,DIMMES
::	INPUT:
::			R1 = ADDRESS OF MESSAGE
::			CHN = CHANNEL NUMBER
::	REGISTER USAGE:	
::			R0 = CHARACTER BEING MOVED
::			R3 = LENGTH OF STRING
::			R14 = WORK REGISTER
::			R15 = DRIF ( DISPI INPUT RING FILL POINTER)
::
::*********************************************************************

DIMMES	HS	0
	STM	R14,DIMMSV		:SAVE WORKING REGISTERS
	LR	R14,R8			:SAVE RETURN REGISTER
	LB	R0,0,R1			:GET LENGTH
	AIS	R0,6			:ALLOW FOR MAXIMUM MESSAGE SIZE
	JAL	R8,DIROOM		:WAIT FOR ROOM
	LHL	R15,DRIF,,		:GET FILL POINTER
	STH	CHN,DIRNG,R15,		:SAVE PORT NUMBER INTO MESSAGE
	LB	R3,0,R1			:GET MESSAGE LENGTH
	STB	R3,DIRNG+2,R15,		:SAVE LENGTH
	AIS	R15,3			:ADD LENGTH FOR PORT AND LEN.
DIMME1	HS	0
	LB	R0,1,R1			:GET CHARACTER
	STB	R0,DIRNG,R15,		:PUT IT IN RING
	AIS	R1,1			:UPDATE MESSAGE POINTER
	AIS	R15,1			:MOVE FILL POINTER
	NHI	R15,DRSZ-1
	SIS	R3,1			:DONE?
	JN	DIMME1			:NO, CONTINUE
	AIS	R15,3
	NHI	R15,DRSZ-4
	STH	R15,DRIF,,		:DONE
	LR	R8,R14			:RESTORE LINK REG
	LM	R14,DIMMSV		:RESTORE WORKING REGS
	JR	R8			:RETURN

	IF	T2GATE
::*********************************************************************
::
::	SUBROUTINE:	DIZSMS:
::	FUNCTION:	Moves canned control messages to dispatcher input
::			ring on Dispatcher Port, toward Slot 0. (for Gateway)
::			Port is supplied to message template or defaulted to 0.
::	CALLING SEQ:	JAL	R8,DIZSMS
::	INPUT:		R3 = length of string
::			R1 = address of message 
::	REGISTER USAGE:	
::			R0 = character being moved
::			R14 = work register
::			R15 = drif ( DISPI input ring fill pointer)
::
::*********************************************************************

DIZSMS	HS	0
	STM	R14,DIMMSV		:SAVE WORKING REGISTERS
	LR	R14,R8			:SAVE RETURN REGISTER
	LR	R0,R3			:GET LENGTH
	ST	R3,DZLEN		:Store length for a while
	AIS	R0,6			:ALLOW FOR MAXIMUM MESSAGE SIZE
	JAL	R8,DIROOM		:WAIT FOR ROOM
	LHL	R15,DRIF,,		:GET FILL POINTER
	L	R3,DZLEN		:Get length to initialize
DIZS01	HS	0
	LB	R0,0,R1			:GET CHARACTER
	STB	R0,DIRNG,R15,		:PUT IT IN RING
	AIS	R1,1			:UPDATE MESSAGE POINTER
	AIS	R15,1			:MOVE FILL POINTER
	NHI	R15,DRSZ-1
	SIS	R3,1			:DONE?
	JN	DIZS01			:NO, CONTINUE
	AIS	R15,3
	NHI	R15,DRSZ-4
	STH	R15,DRIF,,		:DONE
	LR	R8,R14			:RESTORE LINK REG
	LM	R14,DIMMSV		:RESTORE WORKING REGS
	JR	R8			:RETURN
	EI	:T2GATE

::*********************************************************************
::
::	SUBROUTINE:	DIXCAP:
::	FUNCTION:	TO GIVE NEW CIRCUITS SOME XMIT CAPACITY.
::	CALLING SEQ:	JAL	R9,DIXCAP
::
::*********************************************************************

DIXCAP	HS	0
	LIS	R1,3			:GET CIRCUIT SPEED
	NH	R1,DIOTAB,CHN,CHN
DIXCAB	LHL	R1,CIRSPK,R1,R1
	CLHI	R1,09E			:0FF IS MAX ALLOWED BY MESS FORMAT
	JLFS	DIXC10
	LHI	R1,09D
DIXC10	AHI	R1,XMTCAP
	STH	CHN,DIRNG,PRD,
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	DISBPS:
::	FUNCTION:	RELIEVE BACKPRESSURE ON DIS PORTS THAT HAVE
::			SUFFICIENTLY LOW CHARACTER COUNTS.
::	CALLING SEQ:	JAL	R10,DISBPS
::
::*********************************************************************

DISBPS	HS	0
	LIS	R4,0			:UPDATE DISBPS BITS
	LIS	R7,0

DISBP1	L	R0,DISBPX,R7,		:PORTS (BITS) ARE RESET IF BACKPRESSURD
	O	R0,DISACP,R7,		:PORTS ACTIVE IF RESET
	LCS	R1,1
	XR	R1,R0			:BITS SET IF BP'D .AND. ACTIVE
	ST	R1,SBPTMP		:USED AS TEMP STORAGE
DISBP2	L	R1,SBPTMP
	JE	DISBP3			:NOBODY BP'ED
	JAL	R8,BID,,
	RBT	R2,SBPTMP
	AR	R2,R4			:DIS CHANNEL #
	LHL	R3,DIOTAB,R2,R2
	LR	R6,R3			:SAVE CIRCUIT SPEED
	NHI	R3,-4			:R3=BUFF #
	JE	DISBP2			:IDLE CHANNELS REMAIN BP'ED
	NHI	R6,3			:SPEED BITS
	LHL	R6,CIRSPK,R6,R6		:SPEED
	CLH	R6,BCT,R3,
	JL	DISBP2			:PORT MUST REMAIN BP'ED
	SBT	R2,DISBPX
	LIS	R0,4			:SEND MESSAGE
	JAL	R8,DIROOM
	LR	CHN,R2
	LHI	R1,RDSPBP		:RELEASE BP THROUGH ISIS FOR CHN
	JAL	R8,DIRMES
	J	DISBP2
DISBP3	AIS	R7,4			:TRY NEXT PORT GROUP
	AHI	R4,20
	CLHI	R4,NDP
	JL	DISBP1
	JR	R10			:RETURN TO SPIDER


	IF	T2GATE			:###EV
::*********************************************************************
::
::	SUBROUTINE:	GSUPLG
::	FUNCTION:	Informs Slot 0 if Gateway report to INET sup.log
::	CALLING SEQ:	JAL	R10,GSUPLG
::	INPUT:		R3 = NR.XXX (Node Report parameter)
::			R1 = Line#/linK#
::	OUTPUT:		Message on Port 0 to Dispacher  (Type 03)
::	RETURNS:	JR	R10
::
::*********************************************************************

GSUPLG	HS	0		:
	STH	R3,DZ03NR,,	:Insert node rpt para. in message
	STB	R1,DZ03LK,,	:Insert line/link# in message
	LA	R1,GDZ03M,,	:Get address of message
	LHI	R3,GDZ03L	:and get length of message
	JAL	R8,DIZSMS	:Output to Dispatcher on port Zero
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	GCKPST:
::	FUNCTION:	Informs Slot 0 if Gateway has port sts changed,
::			Also informs Hnet sup when out of ports.
::	CALLING SEQ:	JAL	R10,GCKPST	
::	INPUT:		R3	=  current port value
::	OUTPUT:		Message on Port 0 to Dispacher  (Type 0A)
::	RETURNS:	JR	R10
::
::*********************************************************************

GCKPST	HS	0		:
	LR	R3,R3		:GAVPTS=0?
	JN	GCKP01
	LR	R4,R3		:SAVE R3
	LHL	R2,TVRBUF	:SUP PRESENT?
	JE	GCKP02		:SKIP IF NO SUP BUF
	LHI	R1,8000+MACHNM	:SENT 148F OUT OF PORTS TO HNET SUP
	JAL	R9,WHWI		: 6 BYTES MSG
	LHI	R1,148F		:GW TO SUP MSG
	JAL	R9,WHWI
	LHL	R1,HOSTN	:GW SLOT HOST NO.
	JAL	R9,WHWI
	LHI	R1,1
	STB	R1,MG148F	:SET SENT FLAG
	LR	R3,R4		:RESTORE R3
	J	GCKP02
GCKP01	LB	R1,MG148F	:CHECK 148F SENT FLAG
	JE	GCKP02		:SKIP IF IT'S NOT SENT
	LHL	R2,TVRBUF	:SUP PRESENT?
	JE	GCKP02		:SKIP IF NO SUP BUF
	LR	R4,R3		:SAVE R3
	LHI	R1,8000+MACHNM	:SENT 1490 HST HAS PORTS TO HNET SUP
	JAL	R9,WHWI		: 6 BYTES MSG
	LHI	R1,1490		:GW TO SUP MSG
	JAL	R9,WHWI
	LHL	R1,HOSTN	:GW SLOT HOST NO.
	JAL	R9,WHWI
	LHI	R1,0
	STB	R1,MG148F	:RESET SENT FLAG
	LR	R3,R4		:RESTORE R3
GCKP02	CLH	R3,DZ0APT,,	:Compare with the last port value
	JER	R10		:Return if same port,no change
	STH	R3,DZ0APT,,	:Insert new port value in message
	LA	R1,GDZ0AM,,	:Get address of message
	LHI	R3,GDZ0AL	:and get length of message
	JAL	R8,DIZSMS	:Output to Dispatcher on port Zero
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	GHSTCT:
::	FUNCTION:	Informs Slot 0 that Gateway Inet host has cost
::	CALLING SEQ:	JAL	R10,GHSTCT
::	INPUT:		None
::	OUTPUT:		Message to Port 0 of Dispacher  (Type 0C)
::	RETURNS:	JR	R10
::
::*********************************************************************

GHSTCT	HS	0
	LA	R1,GDZ0CM,,	:Get address of message
	LHI	R3,GDZ0CL	:and get length of message
	JAL	R8,DIZSMS	:Output to Dispatcher on port Zero
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	GHSTST:
::	FUNCTION:	Informs Slot 0 that Gateway has host and status
::	CALLING SEQ:	JAL	R10,GHSTST	
::	INPUT:		R3	=  Status of host
::	OUTPUT:		Message on Port 0 to Dispacher  (Type 10)
::	RETURNS:	JR	R10
::
::*********************************************************************

GHSTST	HS	0		:Send Host Status Message to Dispatcher
	STB	R3,DZ10ST,,	:Insert status bits in message
	LHL	R3,GAVPTS,,	:The latest no. of ports
	STH	R3,DZ10PT,,	:stored
	LA	R1,GDZ10M,,	:Get address of message
	LHI	R3,GDZ10L	:and get length of message
	JAL	R8,DIZSMS	:Output to Dispatcher on port Zero
	JR	R10

	EI	:T2GATE		:###ev



	EI	:ISIS

	SUBTTL	DISPI (CONSAT - LOGCHR)

	IF	ISIS!SOLOCS

	SEG	1

:	BIT ARRAY TO INDICATE LOGON ESCAPE CHARACTERS (1B-1F,7B-7E)

DLMESC	HC	0000,001F,0000,0000,0000,0000,0000,001E

::*********************************************************************
::
::	SUBROUTINE:	LOGCHR:
::	FUNCTION:	PROCESS CHARACTERS COMING FROM PORTS IN LOGIN
::			MODE.
::			THIS ROUTINE IS USED BOTH BY DISPI AND THE
::			CONSAT (ASYNC) MODULE.
::	CALLING SEQ:	JAL	R11,LOGCHR
::	INPUT:		R1 = CHAR FROM PORT IN LOGIN MODE
::			R2 = OUTBOUND BUFFER #
::	RETURNS:	IMMEDIATE IF PORT NOT IN LOGIN MODE
::			+4 IF LOGIN BUFFER FULL
::			+8 IF EVERYTHING OK
::
::*********************************************************************

:	VERIFY PORT IN LOGIN MODE, AND TOSS CHARACTER IF NOT
LOGCHR	HS	0
	LHL	R0,BF,R2,
	CLHI	R0,LOGMAX		:RANGE CHECK BUFFER FLAG
	JGR	R11			:NOT IN LOGIN MODE
	CLHI	R0,LOGMIN
	JLR	R11			:NOT IN LOGIN MODE

	OHI	R1,80			:SET HOB OF CHARACTER
	TBT	R1,DLMESC-10		:IS CHARACTER AN ESCAPE ?
	JN	LOGBAD			:YES, HANDLE ESCAPE
	LR	R6,R1			:SAVE LOGON CHARECTER
	JAL	R8,WCI			:R1=CHAR, R2=BUFFER #*4
	IF	ISIS			:###TZ
	LIS	LRC,1
	EI	:ISIS			:###TZ

	JAL	R8,CBCCT		: *REMOVE WHEN SUP GOES TO 56 CHARS*
	CHI	R1,$A48			: > 48 CHARS ?
	JG	LOGCHA			:ZAP BUFFER, SEND MESSAGE TO USER

	CHI	R6,8D			:= 'CR' ?
	JEFS	LOGCH0			:YES, SET NODE CODE TO OK
	CHI	R6,0BB			:= "SEMI-:" ?
	JN	8,R11			:NO, DO +8 RETURN
:	SET BF TO 'NODE CODE = YES' IF CHARACTER IS CR OR SEMI-:
LOGCH0	HS	0
	LHL	R8,BF,R2,		:GET BF
	OHI	R8,LOGNDC		:SET 'NODE CODE = OK' BIT
	STH	R8,BF,R2,
	J	8,R11			:CONTINUE WITH +8 RETURN

:	BUFFER OVERFLOW, ZAP BUFFER, TELL USER

LOGCHA	HS	0
	LIS	R1,0			:SET TO 0 FOR NO ESC CHAR

LOGBAD	LIS	R0,0			:COMMON ENTRY POINT FOR ESCAPE
					: & BUFFER FULL
	ST	R0,DSOLGH,,		:CLEAR TEMPORARY SAVE AREA
	GL	DSOLGH
	STB	R1,DSOLGH+3,,		:STORE R1 (EITHER ESCAPE CHAR OR 0)
	LIS	R0,0F
	TBT	R0,BF,R2,		:IS TID IN THE BUFFER?
	JEFS	LOGBA1			:NO
	JAL	R9,GHWI			:YES, GET HOST NUMBER
	GL	GHWI			:###wjl
	STH	R1,DSOLGH,,		:AND SAVE IT
	JAL	R8,GCI			:ALSO GET TID
	STB	R1,DSOLGH+2,,		:SAVE IT ALSO
LOGBA1  LB	R1,DSOLGH+3,,		:ESCAPE OR BUFFER FULL?
	JE	LGFULL			:BUFFER FULL, GO CLEAR IT

LOGES2  LHL	R0,BCT,R2,		:ESCAPE TYPED...ANYTHING IN BUFFER?
	JEFS	LOGES1			:NO, BUFFER EMPTY
	JAL	R9,GCIE			:YES, GET A CHARACTER, ESCAPE STRIPPED
	GL	GCIE
	NHI	R1,7F			:STRIP OFF MSB
	CLHI	R1,01F			:CONTROL CHARACTER?
	JGBS	LOGES2			:NO, GET ANOTHER CHARACTER
	SBT	R1,DSOSPC,,		:CONTROL CHARACTER, NOTE IT
	GL	DSOSPC
	JBS	LOGES2			:AND KEEP EMPTYING BUFFER
LOGES1  LHL	R1,DSOLGH,,		:GET HOST NUMBER
	JEFS	LOGES6			:NO HOST NUMBER IN BUFFER
	JAL	R9,WHWI			:DEPOSIT HOST NUMBER
	GL	WHWI
	LB	R1,DSOLGH+2,,
	JAL	R8,WCI			:AND TID
LOGES6	LHI	R4,01F			:SEND SUP ALL CONTROL CHARACTERS
LOGES4  RBT	R4,DSOSPC,,		:WAS THIS ONE IN BUFFER?
	JEFS	LOGES5			:NO
	LHI	R1,80,R4		:YES, APPEND 80-BIT...
	JAL	R9,WCIE			:AND, WRITE IT IN
	GL	WCIE
LOGES5  SIS	R4,1
	JGEBS	LOGES4			:LOOP OVER ALL CINTROL CHARACTERS
LOGES3  LB	R1,DSOLGH+3,,		:GET THE ESCAPE CHAR
	JAL	R8,WCI			:AND WRITE IT IN
	LIS	R0,0E
	SBT	R0,BF,R2,		:SET NODE CODE TO GO AHEAD
	J	8,R11			:DO A +8 RETURN

LGFULL	JAL	R8,CBCLR		:CLEAR BUFFER
	LHL	R1,DSOLGH,,		:IS HOST NUMBER IN BUFFER
	JE	4,R11			:NO, DO A +4 RETURN
	JAL	R9,WHWI			:YES, REDEPOSIT IT
	LB	R1,DSOLGH+2,,		:AND ALSO THE TID
	JAL	R8,WCI
	J	4,R11

	EI	:ISIS!SOLOCS


::Log-in  Error messages for Gateway (terminal in Log-in mode)
LFER08	SC	/out of origination ports/

	ENDMO.(DISPI)
	EI	:1-KILLIT
	KILMSG(DISPI)

:	***NOTHING PAST THIS POINT***


	SUBTTL	SWTCH2

:		 **** *   * *****  ***  *   *  ***
:		*     *   *   *   *   * *   * *   *
:		 ***  * * *   *   *     *****   *
:		    * ** **   *   *   * *   *  *
:		****  *   *   *    ***  *   * *****

::#####################################################################
::
::	MODULE:		SWTCH2
::
::	FUNCTION:	Circuit building and command channel
::			communications processes.
::
::	REGISTER CONVENTIONS:
::
::	SUBTTLS:	IZSWIT:  Switch initialization
::			SWITCH:  Switch exec
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA	0
	SEG	1

::*********************************************************************
::
::	TABLE:		DETMTB:
::	FUNCTION:	CANNED DETACH MESSAGES
::
::*********************************************************************

	NOLIST
DETM00	SC	/"8A"8Ddestination node out of ports/
DETM01	SC	/"8A"8Dhost out of ports./	:NC DETECTED
DETM02	SC	/"8A"8Dhost out of ports!/	:SLOT DETECTED
DETM03	SC	/"8A"8Ddestination node out of kernel ports/
DETM04	SC	/"8A"8DKernel SIO ring interface down/
DETM05	SC	/"8A"8Dout of xray slots/
DETM06	SC	/"8A"8Dxray slot overridden/
DETM07	SC	/"8A"8DBAD XRAY USERNAME/
	IF	T2GATE
DTM08X	HC	DTM08L
DETM08	EQ	DTM08X+1
	AC	/inter-link cleared from /
	IF	NETNAM
	HNAME()
	ELSE
	AC	/HOME NETWORK/
	EI	:NETNAM
	AC	/ to /
	IF	NETNAM
	INAME()
	ELSE
	AC	/ISIS NETWORK/
	EI	:NETNAM
	AC	/"8D"8A/
DTM08L	EQ	.-DETM08-1
	EI	:T2GATE
	LIST

DETMTB  HC	DETM00-SEG1,DETM01-SEG1,DETM02-SEG1,DETM03-SEG1,DETM04-SEG1
	HC	DETM05-SEG1,DETM06-SEG1,DETM07-SEG1
	IF	T2GATE
	HC	DETM08-SEG1
	EI	:T2GATE


::*********************************************************************
::
::	TABLE:		KDKN:
::	FUNCTION:	LINK DESCRIPTORS INDEXED BY LINK NUMBER
::
::*********************************************************************
	IF	STRHUB
Q	EQ	KDSC
R	EQ	0
KDKN	WS	0			:LINK POINTERS BY DIFFERENTIAL SIZE
	RE	NLINKS
	WC	Q
	IF	\K.S|$A R|			:IF THIS LINK IS STARLINK
Q	EQ	Q+SKDSZ			:STRLNK DESCRIPTOR SIZE
	ELSE
Q	EQ	Q+KDSZ
	EI
R	EQ	R+1
	ER
	ELSE	:NOT STRHUB		:FOR NON STAR HUB
Q	EQ	KDSC			:LINK PTRS BY LINK NUMBER
KDKN	WS	0
	RE	NLINKS
	WC	Q
Q	EQ	Q+KDSZ
	NOLIST
	ER
	LIST
	EI	:STRHUB
	SYAD(KDKN  )

::*********************************************************************
::
::	TABLE:		HMSK:
::	FUNCTION:	HALFWORD MASK ARRAY
::			YIELDS HC 8000,4000,2000,ETC...
::
::*********************************************************************

HMSK	HS	0
Q	EQ	8000
	RE	10
	HC	Q
Q	EQ	Q^-1
	ER

::*********************************************************************
::
::	TABLE:		WMSK:
::	FUNCTION:	WORD MASK BIT ARRAY
::
::*********************************************************************

WMSK	WS	0			:WORD MASK BIT ARRAY
	NOLIST
	RE	20
	WC	1^(1F-(.-WMSK)/4)
	ER				:80000000,40000000,20000000, ETC.
	LIST

::*********************************************************************
::
::	ROUTINE:	JBIDDY:
::	FUNCTION:	JUMPS TO BIDDY. ALLOWS RX2 JAL'S.
::	CALLING SEQ:	???
::	INPUT:		SAME AS BIDDY
::	OUTPUT:		SAME AS BIDDY
::	DESTROYED:	SAME AS BIDDY
::	CALLS:		NONE
::
::*********************************************************************

JBIDDY	J	BIDDY,,			:ALLOW RX1'S TO BIDDY

	SUBTTL	SWTCH2 (IZSWIT - Switch initialization)

::*********************************************************************
::
::	SUBROUTINE:	IZSWIT:
::	FUNCTION:	Initializes SWITCH
::	CALLING SEQ:	JAL	R10,IZSWIT
::
::*********************************************************************

DEAD	EQ	0DEAD			:for BF entry, etc.	###jhl

IZSWIT	HS	0
:	Init CHNMAP.  CHNMAP is a FW array used by the TRACE logic to
:	figure out where circuits are headed.  The HO HW is the absolute
:	channel of relative channel 0 for the channel range.  The LO HW
:	is an index into CHNMPD (if positive, otherwise it is a flag for
:	terminating circuits).

:	Init CHNMAP for internal control (ILC, BPM) channels (CHNMPD index=-6)
	LI	R0,LNKLFL^10+0FFFA
	ST	R0,CHNMAP,,		:ILC, BPM CIRCUITS (INT CONTROL CIRCS)

:	Init CHNMAP for link channels (CHNMPD index=2*link#)
	LI	R0,LNKLFL^10+2*(NLINKS-1)
	LIS	R1,4
IZSWA	ST	R0,CHNMAP,R1,		:LEFT HALF CHANNEL 0 #,
					: RIGHT HALF CHNMPD INDEX
	SIS	R0,2
	AIS	R1,4
	CLHI	R1,4*NLINKS		:DONE ALL LINKS?
	JLEBS	IZSWA			:NO - CONTINUE

:	Init CHNMAP for dispatcher ports (CHNMPD index=-3)
	IF	ISIS
	LI	R0,DISZFL^10+0FFFD	:DISPATCHER PORTS (-3)
	ST	R0,CHNMAP,R1,
	AIS	R1,4
	EI	:ISIS

:	Init CHNMAP for sup ports (CHNMPD index=-2)
	IF	SUPER
	LI	R0,SUPZFL^10+0FFFE	:SUP PORTS (-2)
	ST	R0,CHNMAP,R1,
	AIS	R1,4
	EI	:SUPER

:	Init CHNMAP for kernel ports (CHNMPD index=HST0)
	IF	KERNEL
	LI	R0,KERZFL^10+8000+HST0
	ST	R0,CHNMAP,R1,
	AIS	R1,4
	EI	:KERNEL

:	Init CHNMAP for CONSAT ports (CHNMPD index=-8)
	IF	SOLOCS
	LI	R0,ASYZFL^10+0FFF8	:TYMSAT PORTS (-8)
	ST	R0,CHNMAP,R1,
	AIS	R1,4
	EI	:SOLOCS

:	Init CHNMAP for internal host ports (CHNMPD index=-4),
:	LEP ports  (CHNMPD index=-5), transient	state ports (CHNMPD index=-7)
	LI	R13,INTZFL^10+0FFFC	:INT PORTS (-4)
	LI	R14,LEPZFL^10+0FFFB	:COMMAND CIRCUIT (-5)
	LI	R15,0FFF9		:TRANSIENT STATE (-7)
	STM	R13,CHNMAP,R1,

:	Init downline load cells (DWTEST, DWLDSP)
	LIS	R0,1
	STH	R0,DWTEST,,		:INITIALIZE DWLIN SEMAPHORE
	LIS	R0,0
	ST	R0,DWLDSP,,		:CLEAR DWL DISPATCH ARRAY
	ST	R0,DWLDSP+4,,

:	Init various bit arrays and pointers, link by link
	LHI	R0,LNKZFL		:FIRST CHANNEL NUMBER FOR NETWORK LINKS
	LIS	R1,0
	LHI	R4,LNKFLG-2,		:LAST HW BEFORE 'ATTN' ARRAY
	LHI	R5,CHSRVD-2,		:LAST HW BEFORE 'SERVICE' ARRAY
	LHI	R6,LNKBPV-2,		:LAST HW BEFORE BACKPRESSURE ARRAY
	LHI	R7,LNKACP-2,		:LAST HW BEFORE ACP ARRAY
	LHI	R8,LNKCHS-2,		:LAST HW BEFORE CHS ARRAY
	LHI	R3,-2*NLINKS		:LINK FIELD INDEX
IZSWB	HS	0
	STH	R0,LKZFKN+2*NLINKS,R3,	:ABSOLUTE CHANNEL FOR RELATIVE CHAN 0
	STH	R1,TBDPKN+2*NLINKS,R3,	:START OF TABLES..
	STH	R1,EBDPKN+2*NLINKS,R3,	:..END OF TABLES
	STH	R1,FLDPKN+2*NLINKS,R3,	:START OF FLAGS FOR THIS LINK
	STH	R4,LKFGND+2*NLINKS,R3,	:LAST HW IN 'ATTN' ARRAY
	STH	R5,LKSVND+2*NLINKS,R3,	:LAST HW IN 'SERVICE' (CHSRVD) ARRAY
	STH	R6,LKBPND+2*NLINKS,R3,	:LAST HW IN BACKPRESSURE ARRAY
	STH	R7,LKAPND+2*NLINKS,R3,	:LAST HW IN ACP ARRAY
	STH	R8,LKCSND+2*NLINKS,R3,	:LAST HW IN CHS ARRAY
	AIS	R3,2			:DO FOR ALL LINKS
	JL	IZSWB

	LHI	R3,-ACPSZP*4		:1/2 ARRAY SIZE, FULLWORD INDEX
	LCS	R1,1

:	Init ACP and CHS (to 1's to indicate channels available).
:	Note ACP and CHS must be contiguously allocated.
IZSWC	HS	0
	ST	R1,ACPBSE+ACPSZP*4,R3,	:SET ACP, CHS TO -1
	AIS	R3,4
	JLBS	IZSWC

:	Init table space
	LHI	R0,TCHANS*2		:END OF TABLE SPACE
	STH	R0,TBDPKN+2*NLINKS,,
	LHI	R0,TCHANS/80
	STH	R0,NUMPAG,,		:NUMBER OF FREE PAGES

	LHI	R1,DEAD			:LINK AVAILABLE BUFFER PAIRS
	LHI	R2,CIRZBF
	STH	R2,FREELB		:HEAD OF FREE PAIR LIST

:	Init buffer linkages (using BB), BF's to "DEAD",
:	free buffer pair list (FREELB).
IZSW1	HS	0
	AIS	R2,8
	STH	R2,BB-8,R2,		:BB USED FOR CHAINING
	STH	R1,BF-8,R2,		:ATTENTION FLAGS SET TO 'DEAD'
	STH	R1,BF-4,R2,
	LR	R3,R2
	SRHLS	R3,1
	IF	REBILD
	STH	R1,BF+HBUFN-4,R3,
	EI	:REBILD
	CLI	R2,8*NCIRCS
	JN	IZSW1

	LIS	R0,0			:LAST PAIR GETS A ZERO
	STH	R0,BB-8,R2,
	STH	R1,BF-8,R2,

	LIS	R0,1			:NOW LINK THE BUFFERLET CHAIN
	LA	R1,CHRBUF,,		:ADDRESS OF ZEROETH BUFFERLET
	LI	R2,NBFLET-1		:USE FW FOR A BIG POOL##AL
	GL	NBFLET
	STH	R0,FREELT		:HEAD OF THE FREE LIST

:	Init bufferlet chain and free bufferlet list (FREELT).
:	Bufferlets are 16d bytes long (CBSZ)--the first HW links to the next
:	bufferlet, the next 14 are for data.  Linking is done via bufferlet
:	number, from 0 to NBFLET-1.  The actual address of a bufferlet is
:	computed by multiplying its number by 10x and adding the base bufferlet
:	address (CHRBUF).  Since FW arithmetic is used,	bufferlet storage can
:	span segment boundaries.
IZSW2	HS	0
	STH	R0,CBSZ-2,R1		:STORE # OF FOLLOWING BFLET
	AHI	R1,CBSZ
	AIS	R0,1
	SIS	R2,1
	JGBS	IZSW2

	LIS	R0,0			:LAST BUFFERLET LINK GETS A 0
	STH	R0,CBSZ-2,R1

:	Schedule CKZB to fill reserve tank first thing
	LHI	R0,1F-PCKZB
	SBT	R0,SQUEUE		:FILL RESERVE TANK

:	Init CRQ buffer flag (BB=0)
	LHI	R0,CRQZFL		:INIT CRQ BUFFER FLAG
	STH	R0,BB,,

:	Build sup circuit to LEP
	IF	SUPER
	JAL	R9,SUPCRQ,,		:BUILD CIRCUIT FROM SUP TO LEP
	GL	SUPCRQ		:##AL
	EI	:SUPER

:	Init downlin load channels (DWLNUM)
	LCS	R0,1			:INIT DOWN-LINE LOAD 
	LIS	R1,TINTCH-1
IZSDWL	HS	0
	STH	R0,DWLNUM,R1,R1
	SIS	R1,1
	JGEBS	IZSDWL

:	Init SIO lines downline load command blocks and	output buffers
	IF	SILINS
	LHI	R1,SILINS*10		:INIT SIO LINES DWL COMMAND BLOCKS
	LHI	LN,NLINES
IZSSIO	HS	0
	SIS	LN,1
	SHI	R1,10			:AND OUTPUT BUFFERS
	JL	IZSSI2
	LR	R2,R1
	SLLS	R2,3			:FOR INDEXING CONVENIENCE
	LA	R0,SIDWBF,R2,		:QUAD ADDRESS OF EACH SIO LINE'S OUTPUT
	GL	SIDWBF
	SRLS	R0,4
	STH	R0,SIDWCM+2,R1,		:BUFFER MUST BE STORED IN ITS CCW AREA
	GL	SIDWCM
	LIS	R0,0
	STH	R0,SIDWCM+4,R1,		:AS MUST A STOP COMMAND 
	IF	STRHUB
	LB	R0,LTYP,LN,LN		:CHECK LTYP IF STAR LINE ##AL
	JEFS	IZSSIA
	LHI	R0,46			:PLUS 4 BYTES OF STARLINK KEY
	JFS	IZSSIB
IZSSIA	EI	:STRHUB
	LHI	R0,42
IZSSIB	STH	R0,SIDWBF,R2,		:FINALLY STORE BYTE COUNT IN IST HW
	J	IZSSIO
IZSSI2	LCS	R0,1
	EI	:SILINS

:	Init PLI message count (-1=nada)
	STH	R0,PLICNT		:INIT PLI MESSAGE

:	Init (-1) the sup NOP flag to idle
	STH	R0,LEPNPF		:INIT SUP NOP FLAG TO IDLE STATE

:	Init (-1) SUPIBF to indicate no diagnostic node	reports formatted
	IF	ISIS
	STH	R0,SUPIBF		:NO DIAGNOSTIC NODE REPORTS FORMATTED
	EI	:ISIS

:	EXPANDED HOST TABLES FOR PROPER HOST INFORMATION MAINTENANCE
	LHI	R0,HST0			:STORE KERNEL HOST NO.		###OAS
	STH	R0,HOSTN		:INTO FIRST ENTRY IN HOST # TABLE##OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW,,		:FOR TIME OF LAST STATUS UPDATE	###OAS
	ST	R0,HSTTIM		:STORE IN FIRST ENTRY OF HOST TIME#OAS
	LHI	R0,NKU			:ANY KERNEL PORTS?		###OAS
	JNFS	IZSSI3			:YES, INDICATE HOW MANY PORTS	###OAS
	LIS	R0,2			:NO, INDICATE 2 PORTS		###OAS
IZSSI3	STH	R0,HSTPTA		:IN PORTS AVAILABLE ARRAY	###OAS

	IF	XRYTMC			:###wjl
	LHI	R0,EHIIXX		:set bit to indicate IIX
	STB	R0,HSTATN		:for TMCS/XRAY
	EI	:XRYTMC

	LHI	R0,TIITYP		:ASSUME TII PID			###OAS
	IF	ISIS
	LHI	R0,I2ISTP		:ISIS PID			###OAS
	EI	:ISIS
	IF	SUPER
	LHI	R0,SUPTYP		:SUPERVISOR PID			###OAS
	EI	:SUPER
	IF	SIORNG	
	LHI	R0,SKERTY		:SPLIT SUPERVISOR PID	###OAS	###wjl
	EI	:SIORNG
	STB	R0,HSTYPE		:STORE KERNEL HOST TYPE

:	Clear accounting flags (ACT7, ACTLST)
	LCS	R0,1			:CLEAR ACCOUNTING FLAGS
	ST	R0,ACT7+0
	ST	R0,ACT7+4
	ST	R0,ACT7+8
	LIS	R0,8			:SET INDEX TO INVALID
	STB	R0,ACTLST

:	Set threshhold for reporting circuit errors.
	LHI	R0,RPTHCE
	STH	R0,NC.THS		:SET REPORT THRESHOLD FOR CIRC ERRORS

:	Return when done
	JR	R10			:RETURN

	SUBTTL	SWTCH2 (SWITCH - Switch exec)

::*********************************************************************
::
::	PROCESS:	SWITCH:
::	FUNCTION:	Switch exec loop dispatches to various sub-processes
::		based on their attention flags:
::		LEP    - process data on a command channel
::		CRQ    - complete second half of circuit building process
::		LOGGER - process ports currently in login mode
::		INTHST - process data for internal hosts
::		ASYLOU - IF SOLOCS, move login data from sup to ports
::			 in login mode
::		LGGO   - IF SOLOCS, move login data from ports toward sup
::		DETCIR - detached circuit processing
::
::*********************************************************************

:	DUMMY DEBUG PROCESS NUMBERS FOR SWITCH SUBPROCESSES		###wjl
:	FORM PROCESS NUMBER * 4 FOR FW INDEX INTO PROTIM, PACTIM,	###wjl
:	PROHWM, PSVTIM ARRAYS ALLOWING USE OF CPRHWM AND MPRTIM ROUTINES###wjl
	IF	SWITIM			:SWITCH MAX PROCESS TIME debug	###wjl
PLAST	EQ	(1F-PGMSRK)^2		:last Process number * 4	###wjl
PLEP	EQ	PLAST+4			:dummy debug Process # for LEP	###wjl
PCRQ	EQ	PLEP+4			:CRQ				###wjl
PLOGGR	EQ	PCRQ+4			:LOGGER				###wjl
PINTHS	EQ	PLOGGR+4		:INTHST				###wjl
PASYLO	EQ	PINTHS+4		:ASYLOU				###wjl
PLGGO	EQ	PASYLO+4		:LGGO				###wjl
PDETCR	EQ	PLGGO+4			:DETCIR				###wjl
	EI	:SWITIM			:				###wjl

SWITCH	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(SWITCH)			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU

:	See if foreground formatted a diagnostic node report (SUPIBF>=0).
:	If so call NETDGN to send node report and cryptogram.
:	Else skip to SWINOP.
	IF	ISIS&(1-T2GATE)		:###EV
	TS	SUPIBF			:ANY WORK TO DO?
	JLFS	SWINOP			:NO
	L	R8,SUPIBF+2		:GET MESSAGE AND MOVE TO
	ST	R8,SUPMBF+2		:PROPER BUFFER
	SRL	R8,18			:SET UP DIAGNOSTIC SUB-TYPE
	JAL	R9,NETDGN,,		:SEND CRYPTOGRAM, NODE REPORT
	GL	NETDGN			:##AL
	EI	:ISIS&(1-T2GATE)	:###EV

:	If supe NOP command is throttle (LEPNPF>=0), then go see if output has
:	been drained enough to continue	artificial load to supe (LEPNP4).
:	Else continue.
SWINOP	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PLEP			:load LEP dummy debug process id (*4)
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	TS	LEPNPF			:IS SUP NOP COMMAND THROTTLED?
	JGE	LEPNP4			:YES - SEE IF OUTPUT DRAINED ENOUGH TO
	GL	LEPNP4			:CONTINUE ARTIFICIAL LOAD TO SUP

:	If any supe command data for LEP, go there (via	BIDDY) and process it.
:	Else continue at SWICRQ.
SWILEP	HS	0
	LB	R1,LEPFLG,,		:PROCESS SUP COMMANDS
	JEFS	SWICRQ			:NO DATA FROM SUPERVISOR
	STB	R1,SWIVSV		:SAVE ATTENTION FLAGS

:	ENTRY POINT - EXEC LOOP RETURNS HERE DUE TO QEXEC ADDR STORED BY BIDDRT
:	standard set up for jump to biddy				###shm
	LI	R4,4			:BIDDRT CAUSES EXEC LOOP TO RETURN HERE
	LA	R3,SWIVSV		:BY STORING ADDRESS IN QEXEC BUT
	JAL	R9,JBIDDY		:ALLOWS HIGHER-PRIORIY PROCESS TO RUN
	J	LEP			:HERE IF SWIVSV NOT 0
	GL	LEP

:	If any needles have come in through LEP or RTD into CRQBUF,
:	go to CRQ to handle them.  Else continue at SWILOG.
SWICRQ	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PLEP			:load LEP dummy debug process id (*4)
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	LHL	R0,BCT,,		:HERE IF SWIVSV = 0. PROCESS NEEDLES
	JE	SWILOG			:NO CIRCUITS TO BUILD		###wjl

	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR CRQ		###OAS
	CPUTNM(CRQ   )			:DEFINE CRQ CPUTIL ENTRY	###OAS
	EI	:DB.CPU

	IF	SWITIM			:				###wjl
	LHI	R2,PCRQ			:load CRQ dummy debug process id (*4)
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	CRQ			:HANDLE NEEDLES FOR HALF-BUILT CIRCUITS
	GL	CRQ

:	Yield after CRQ is done
CRQRET	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PCRQ			:load CRQ dummy debug process id (*4)
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	JAL	R0,EXYLD,,		:ALLOW HIGHER-PRIORITY PROCESS TO RUN

:	If any login input data waiting to be processed	(LOGBUF), go to LOGGER.
:	Else continue at SWIINT.
SWILOG	HS	0
	LHL	R0,BCT+4,,		:PROCESS PORTS IN LOGIN MODE
	JE	SWIINT			:NO PORTS CURRENTLY IN LOGIN MODE##wjl

	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR LOGGER	###OAS
	CPUTNM(LOGGER)			:DEFINE LOGGER CPUTIL ENTRY	###OAS
	EI	:DB.CPU

	IF	SWITIM			:				###wjl
	LHI	R2,PLOGGR		:load LOGGER dummy debug process id *4
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	LOGGER			:LOOK FOR LOGIN STRING FROM LOCAL PORT
	GL	LOGGER

:	Yield after LOGGER runs
LOGRET	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PLOGGR		:load LOGGER dummy debug process id *4
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	JAL	R0,EXYLD,,		:ALLOW HIGHER-PRIORITY PROCESS TO RUN

:	If any data for internal hosts, go to INTHST to process it.
:	Else continue at SWIALO.
SWIINT	HS	0
	LHL	R2,INTFLG,,		:PROCESS DATA FOR INTERNAL HOST
	JE	SWIALO			:NO INTERNAL HOST ACTIVITY	###wjl

	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR INTHST	###OAS
	CPUTNM(INTHST)			:DEFINE CRQ CPUTIL ENTRY	###OAS
	EI	:DB.CPU

	IF	SWITIM			:				###wjl
	LHI	R2,PINTHS		:load INTHST dummy debug process id *4
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	INTHST,,		:LOOK FOR DATA FOR AN INTERNAL HOST
	GL	INTHST

:	Yield after INTHST runs
INTRET	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PINTHS		:load INTHST dummy debug process id *4
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	JAL	R0,EXYLD,,		:ALLOW HIGHER-PRIORITY PROCESS TO RUN

:	Call ASYLOU to move login data from sup to ports in login mode
SWIALO	HS	0
	IF	SOLOCS
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR ASYLOU
	CPUTNM(ASYLOU)			:DEFINE ASYLOU CPUTIL ENTRY
	EI	:DB.CPU

	IF	SWITIM			:				###wjl
	LHI	R2,PASYLO		:load ASYLOU dummy debug process id *4
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	ASYLOU,,		:MOVE LOGIN DATA NETWORK->TYMSAT 
	GL	ASYLOU
	GL	ALORET

:	Yield after ASYLOU runs
ALORET	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PASYLO		:load ASYLOU dummy debug process id *4
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	JAL	R0,EXYLD,,		:ALLOW HIGHER-PRIORITY PROCESS TO RUN

:	Call LGGO (CONSAT) to move login data from ports toward sup
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR LGGO
	CPUTNM(LGGO  )			:DEFINE LGGO CPUTIL ENTRY
	EI	:DB.CPU

	IF	MPCCHK				:###LSH
	L	R0,FASTC,,
	ST	R0,LGGOB
	LIS	R0,0
	STH	R0,LGGOF
	EI	:MPCCHK

	IF	SWITIM			:				###wjl
	LHI	R2,PLGGO		:load LGGO dummy debug process id (*4)
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

:	EVERY TIME ONLY SCAN 16 PORTS AND THEN YIELD TO EXEC		###LSH
	LHI	RPOL,(NGRP-1)*2		:HALFWORD INDEX FOR BIT ARRAYS
	GL	NGRP			:				###LSH

	J	LGGO,,
	GL	LGGO
	GL	ALIRET

:	Yield after LGGO runs
ALIRET	HS	0

	IF	MPCCHK				:###LSH
	L	R0,FASTC,,
	S	R0,LGGOB
	LH	R1,LGGOF
	JEFS	MPCK6
	ST	R0,LGGSND
	JFS	MPCK7
MPCK6	ST	R0,LGGNO
MPCK7	HS	0
	EI	:MPCCHK

	IF	SWITIM			:				###wjl
	LHI	R2,PLGGO		:load LGGO dummy debug process id (*4)
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl	

	ST	RPOL,RPOLSV,,		:STORE RPOL			###LSH
	JAL	R0,EXYLD,,		:ALLOW HIGHER-PRIORITY PROCESS TO RUN

	IF	SWITIM			:				###wjl
	LHI	R2,PLGGO		:load LGGO dummy debug process id (*4)
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	L	RPOL,RPOLSV,,		:RESTORE RPOL			###LSH
	SIS	RPOL,2			:UPDATE INDEX			###LSH
	JGE	LGGO,,			:GO TO PROCESS NEXT GROUP 	###LSH

	EI	:SOLOCS

:	If any data for detached ports, go to DETCIR to	handle.
:	Else return to EXEC via SWIRET.
	L	R2,DETFLG,,		:DATA FROM A DETACHING PORT?
	IF	DB.CPU
	JE	SWRET1			:NO DATA, RETURN TO EXEC	###OAS
					:INDICATE DISPATCH IF NECCESARY ###OAS
	ELSE	:not DB.CPU
	JE	SWIRET,,		:NO - RETURN TO EXEC
	EI	:DB.CPU

	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR DETCIR	###OAS
	CPUTNM(DETCIR)			:DEFINE DETCIR CPUTIL ENTRY	###OAS
	EI	:DB.CPU

	IF	SWITIM			:				###wjl
	LHI	R2,PDETCR		:load DETCIR dummy debug process id *4
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	DETCIR,,		:YES - EXAMINE AND PROCESS
	GL	DETCIR

:	Yield after DETCIR runs.  Then return to EXEC via SWIRET.
DETRET	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PDETCR		:load DETCIR dummy debug process id *4
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	JAL	R0,EXYLD,,		:ALLOW HIGHER-PRIORITY PROCESS TO RUN

	IF	DB.CPU
SWRET1	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR SWIRET	###OAS
	CPUTNM(SWIRET)			:DEFINE SWIRET CPUTIL ENTRY	###OAS
	EI	:DB.CPU

	J	SWIRET,,

::*********************************************************************
::
::	JBIDRT:	Allows RX2 jumps to BIDDRT.  Can't have RX3 after a JAL
::	from which we may get a skip+4 return.
::
::*********************************************************************

JBIDRT	HS	0
	J	BIDDRT,,		:DON'T WANT RX3 JUMP TO BIDDRT IF
			:JUMP FOLLOWS SUBROUTINE WHICH DOES SKIP RETURN.

	ENDMO.(SWTCH2)

	EI	:1-KILLIT

	KILMSG(SWTCH2)

 :	***NOTHING PAST THIS POINT***

	SUBTTL BUFF

:			****   *   * ***** *****
:			*   *  *   * *     *
:			****   *   * ***   ***
:			*   *  *   * *     *
:			****    ***  *     *

::#####################################################################
::
::	MODULE:		BUFF
::
::	FUNCTION:	CHARACTER BUFFER ROUTINES
::
::	REGISTER CONVENTIONS:
::		R0=SCRATCH
::		R1=CHARACTER TO OR FROM BUFFER. ALSO SCRATCH.
::		R2=BUFFER # (MULTIPLE OF 4)
::		R3=SCRATCH
::		R8=LINK
::	SUBTTLS:
::		WCI - Write character into a buffer
::		GCI - Get character from a buffer
::		CBCLR - Clear a buffer
::		CKZB - Refill bufferlet reserve tank
::		Utilities
::		GFCBUF/RFCBUF - Get/Return free character buffer pair)
::		Copy message into a buffer
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA  0
	SEG  1

::*********************************************************************
::
::	SUBROUTINE:	WCI:
::	FUNCTION:	Write character into buffer
::	CALLING SEQ:	JAL	R8,WCI
::	INPUT:		R1 = CHARACTER
::			R2 = BUFFER INDEX
::
::*********************************************************************

WCI	HS	0			:Entry point

	CLHI	R2,4			:TEST FOR BUFFER NUMBER 0 OR 1
	JGFS	WCI0			:OK
	CRASH.(.WCIC0)			:Crash if buffer index 0 or 4.

	IF	ESYNC

WCI0	HS	0
:	Check buffer's BF, crash if negative. Else to WCI1.
	IF	DB.DEB
	LH	R0,BF,R2,		:EDIT BUFFER'S BF
	JGEFS	WCI1
	DBOOPS				:SPECIAL OOPS CALL
	EI	DB.DEB

WCI1	HS	0			:Here to do a WCI.
:	WCI instruction.  Takes us to WCIERR if bad buffer index, to WCNXT
:	to fetch another bufferlet, to WCFRST to get the first bufferlet.
:	Falls through when done, and we return to caller (R8).
WCI2	HS	0			:WCI INSTRUCTION
	HC	3912			:R1=CHAR, R2=BUFFER INDEX

	HC	BE-BB			:SIZE OF BB STORAGE
	HC	WCIERR-WCI2		:HERE ON INVALID BUFFER NUMBER
	HC	BE/4			:ADDRESS OF BE STORAGE/4
	HC	WCNXT-WCI2		:HERE TO CHAIN IN ANOTHER BUFFERLET
	HC	WCFRST-WCI2		:HERE TO GET FIRST BUFFERLET

	JR	R8			:DONE

:	Crash due to bad buffer index detected by WCI.
WCIERR	HS	0
	CRASH.(.WCIC1)

	ELSE	:NOT ESYNC

WCI0	L	R3,BE,R2,		:LOAD IN PTR
	JEFS	WCFRST			:IF 0, BUFF EMPTY, SO GET BUFFERLET
	AIS	R3,1			:INC TO NEXTSLOT
	THI	R3,CBSZ-1
	JEFS	WCI1			:NEED ANOTHER BUFFERLET
	STB	R1,0,R3
	ST	R3,BE,R2,		:RESTORE IN PTR
	JR	R8

WCI1	J	WCNXT

	EI	:ESYNC

::*********************************************************************
::
::	WCFRST:	Chain the first bufferlet into a buffer.
::	Set BCT to 1, bump the count of bufferlets in use (by 14d),
::	set the buffers attention flag (NFLAGS).
::
::*********************************************************************

WCFRST	HS	0
	LIS	R3,1			:FIRST BFLET, SET CHRCNT=1
	STH	R3,BCT,2,
	LIS	R3,CBSZ-2
	AM	R3,BFLTSV		:INCREMENT COUNT OF BUFFERLETS IN USE
	JGEFS	WCFRS9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCFRS9	HS	0
	IF	REBILD
	CLI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	WCFRS1			:NO				###OAS
	AM	R3,HBFTSV		:YES, INCREMENT COUNT		###OAS
	JGEFS	WCFRS1			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCFRS1	HS	0
	EI	:REBILD

	LH	R3,BF,2,		:SET ATTN FLAG
	SBT	R3,NFLAGS,,

:	Get a bufferlet from the free list (FREELT). If one is there,
:	continue at WCFRS0.  If not, call WRE to get the reserve tank,
:	then jump back here and try again.
WCFRS0	HS	0
	LHL	R3,FREELT		:GET BFLET FROM FREE LIST
	JNFS	WCFRS2
	JAL	R0,WRE
	JBS	WCFRS0

:	Got a free bufferlet to chain.  Point BB to it, put its link pointer
:	in FREELT, put the character into it, set up BE, and return to the WCI
:	caller.
WCFRS2	HS	0
	SLLS	R3,CBSZL		:COMPUTE ADDR OF FIRST SLOT
	AI	R3,CHRBUF
	ST	R3,BB,R2,		:IT'S ALSO THE NEW OUT PTR
	LHL	R0,CBSZ-2,R3		:UPDATE FREE LIST
	STH	R0,FREELT
	STB	R1,0,R3			:PUT AWAY BYTE
	ST	R3,BE,R2,		:RESTORE PTR
	JR	R8

::*********************************************************************
::
::	WCNXT:	Chain another bufferlet to a buffer.
::	Bump the count of bufferlets in use (BFLTSV), bump BCT by 14d.
::	If BCT<32K, continue at WCNXT0.  Else if BCT<0FFF0, continue at WCNXT0.
::	Else call BUFZAP to zap the buffer because we're in danger of
::	overflowing BCT.  If the buffer we zapped was a history buffer (there
::	is nothing--i.e., no black ball--in it) continue at WCFRST.
::	Else continue at WCNXT2.
::
::*********************************************************************

WCNXT	HS	0
	LIS	R0,CBSZ-2		:CHAIN ANOTHER BFLET - INC CNT
	AM	R0,BFLTSV		:INCREMENT NUMBER OF BUFFERLETS IN USE
	JGEFS	WCNXT9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS

WCNXT9	HS	0
	IF	REBILD
	CLI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	WCNX33			:NO				###OAS
	AM	R0,HBFTSV		:YES,INCREMENT COUNT		###OAS
	JGEFS	WCNX33			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCNX33	HS	0
	EI	:REBILD

	AHM	R0,BCT,R2,		:AND BCT FOR THIS BUFFER
	JG	WCNXT0			:BCT < 32K
	LHL	R0,BCT,R2,
	CI	R0,0FFF0		:ARE WE IN DANGER OF BCT OVERFLOW?
	JL	WCNXT0			:NO
	ST	R4,REGST,,		:STORE R4 			###LSH
	JAL	R4,BFZDB2,,		:STORE SOME DATA FOR DEBUGGING	###LSH
	GL	BFZDB2			:BEFORE WE ZAP THE BUFFER 	###LSH
	L	R4,REGST,,		:RESTORE R4 			###LSH
	JAL	R0,BUFZAP		:YES - ZAP BUFFER
	L	R3,BE,R2,		:SET UP BE
	JN	WCNXT2			:AND GO STORE CHARACTER
	J	WCFRST			:MUST BE HIST BUFF,NO BLACK BALL IN IT

:	Here if BCT not too big.  Get the next bufferlet from the free list.
:	If one is there, continue at WCNXT1.  Else call WRE to get the reserve
:	pool and come back here to try again.
WCNXT0	HS	0
	LHL	R0,FREELT		:LINK TO NEXT BUFFERLET IN CHAIN
	JNFS	WCNXT1			:LINK ADDRESS<>0,BUFFERLET CHAIN INTACT
	JAL	R0,WRE			:FREE POOL EMPTY, GET LINK ADDRESS FROM
	JBS	WCNXT0			:RESERVE POOL AND SCHEDULE 'CKZB' TO
					:REFILL RESERVE POOL, ZAPPING A BUFFER
					:IF NECESSARY.

:	Here after successfully chaining in another bufferlet.
:	Set up link, update FREELT.
WCNXT1	HS	0
	STH	R0,0,R3			:R3 PTS TO LINK SLOT
	LR	R3,R0			:COMPUTE NEW IN PTR
	SLLS	R3,CBSZL
	AI	R3,CHRBUF
	LHL	R0,CBSZ-2,R3
	STH	R0,FREELT

:	Got a bufferlet, bookkeeping done. Now store away the character
:	and update BE.  Then return to WCI caller.
WCNXT2	HS	0
	STB	R1,0,R3			:STORE THE CHAR
	ST	R3,BE,R2,
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	WRE:
::	FUNCTION:	Link the reserve tank into the free list.
::			Called when free list found empty.
::	CALLING SEQ:	JAL	R0,WRE
::	DESTROYED:	NO REGISTERS
::
::*********************************************************************

WRE	HS	0			:Get the reserve tank pointer.

	IF	BFSDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,WREDB1,,
	GL	WREDB1
	L	R4,REGST,,
	EI	:BFSDBG

	ST	R0,WRERET		:IN ORDER TO SAVE ON REGISTERS
	LHL	R0,FREELT		:MAKE SURE WE SHOULD BE HERE
	JEFS	WRE0
	CRASH.(.WREFL)
WRE0	HS	0
	LH	R0,REBL
	JNFS	WRE2
	CRASH.(.WRECR)			:Crash if reserve tank empty
				:unreasonable drain on bufferlet storage

:	Link reserve tank into bufferlet free list.  Schedule CKZB (highest
:	priority) to refill the reserve tank, zapping buffers if necessary.
:	Then return.
WRE2	HS	0
	STH	R0,FREELT
	LIS	R0,0
	STH	R0,REBL
	LHI	R0,1F-PCKZB		:SCHEDULE REFILL OF RESERVE TANK
	SBT	R0,SQUEUE		:A HIGH PRIORITY PROCESS
	L	R0,WRERET

	IF	BFSDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,WREDB2,,
	GL	WREDB2
	L	R4,REGST,,
	EI	:BFSDBG

	JR	R0

::*********************************************************************
::
::	SUBROUTINE:	WCD:
::	FUNCTION:	Prefix a character to a buffer
::	CALLING SEQ:	JAL	R8,WCD
::
::*********************************************************************

:	If buffer empty, go handle same as WCI (WCFRST).
WCD	HS	0
	L	R3,BB,R2,		:USE THE IN PTR
	JE	WCFRST			:EMPTY BUFF, SAME AS A WCI

:	If no room in first bufferlet, go get another one (WDNXT).
	SIS	R3,1			:BACK UP PTR
	THI	R3,CBSZ-2		:OFF THE BUFFER?
	JEFS	WDNXT			:YES, GET ANOTHER BUFFERLET

:	Otherwise, store the character and update BB, then return to caller.
	STB	R1,0,R3			:NO, JUST STORE BYTE
	ST	R3,BB,R2,		:AND UPDATE 'BB'
	JR	R8

:	Prefix a bufferlet in order to prefix a char.
:	Increment BCT and bufferlets-in-use count.
WDNXT	HS	0
	LIS	R0,CBSZ-2		:PREFIX A BUFFERLET, INC BCT FIELD
	AHM	R0,BCT,R2,
	AM	R0,BFLTSV		:UPDATE COUNT OF BUFFERLETS IN USE
	JGEFS	WCD09			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCD09	HS	0
	IF	REBILD
	CLI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	WCD01			:NO				###OAS
	AM	R0,HBFTSV		:YES, ADJUST COUNT		###OAS
	JGEFS	WCD01			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCD01	HS	0
	EI	:REBILD

	LI	R0,-CHRBUF+1,R3		:COMPUTE # OF THIS BUFFERLET
	SRLS	R0,CBSZL
	STH	R0,WCDSAV		:SAVE BUFFERLET #		###GT

:	Get free list pointer. If something there, continue at WDNXT1.
WDNXT0	HS	0
	LHL	R3,FREELT		:LINK TO NEXT BUFFERLET IN CHAIN
	JNFS	WDNXT1			:LINK ADDRESS<>0,BUFFERLET CHAIN INTACT

:	Else call WRE to get reserve pool, then back to WDNXT0.
	JAL	R0,WRE			:FREE POOL EMPTY, GET LINK ADDRESS FROM
	JBS	WDNXT0			:RESERVE POOL AND SCHEDULE 'CKBZ' TO
					:REFILL RESERVE POOL, ZAPPING A BUFFER
					:IF NECESSARY.

:	Got a free bufferlet. Store the character at the end of the bufferlet,
:	update FREELT, and chain old first bufferlet to this one. Update BB and
:	return to caller.
WDNXT1	HS	0
	SLLS	R3,CBSZL		:MAKE PTR TO LAST BYTE
	AI	R3,CHRBUF+CBSZ-3
	STB	R1,0,R3			:PUT AWAY BYTE
	LHL	R0,1,R3			:GET THE LINK
	STH	R0,FREELT		:NEW HEAD OF LIST
	LHL	R0,WCDSAV		:RESTORE THE BUFFERLET # FOR LINK###GT
	STH	R0,1,R3			:CHAIN TO OLD BUFFLET
	ST	R3,BB,R2,		:SAVE NEW PTR
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	WHWI:
::	FUNCTION:	Write a HW from R1 into a buffer (index in R2),
::			escaping bytes 00-03.
::	CALLING SEQ:	JAL	R9,WHWI
::	INPUT:		R1 = HW
::			R2 = BUFFER INDEX
::	DESTROYED:	R1, R8
::	CALLS:		JAL	R8,WCI	Crashes (in WCI) if R2=0 or 4
::
::*********************************************************************

WHWI	HS	0
	EXBR	R1,R1
	THI	R1,0FC			:ESCAPE CHARACTERS 0 - 3
	JNFS	WHW1
	SLLS	R1,8
	JAL	R8,WCI
	SRLS	R1,8
WHW1	JAL	R8,WCI
	EXBR	R1,R1
	THI	R1,0FC
	JNFS	WHW2
	SLLS	R1,8
	JAL	R8,WCI
	SRLS	R1,8
WHW2	JAL	R8,WCI
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	WHWI0:
::	FUNCTION:	Same as WHWI but allows buffer index (R2) of 0 or 4.
::			Used by CRQ and LOGGER.
::	CALLING SEQ:	JAL	R9,WHWI0
::	INPUT:		R1 = HW
::			R2 = BUFFER INDEX
::	DESTROYED:	R1, R8
::	CALLS:		JAL	R8,WCI0
::
::*********************************************************************

WHWI0	HS	0
	EXBR	R1,R1			:DO LEFT BYTE FIRST
	THI	R1,0FC
	JNFS	WHWI01			:ESCAPE BYTES 00 - 03 ONLY
	SLLS	R1,8
	JAL	R8,WCI0			:WRITE 0 INTO BUF
	SRLS	R1,8
WHWI01	JAL	R8,WCI0
	EXBR	R1,R1			:GET 2ND BYTE INTO LOW-ORDER POSITION
	THI	R1,0FC
	JNFS	WHWI02			:ESCAPE 2ND BYTE ALSO
	SLLS	R1,8
	JAL	R8,WCI0
	SRLS	R1,8
WHWI02	JAL	R8,WCI0
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	WCIE:
::	FUNCTION:	Write a character (from R1), escaped if necessary, into
::		a buffer (index in R2).
::	CALLING SEQ:	JAL	R9,WCIE
::	INPUT:		R1 = CHARACTER
::			R2 = BUFFER INDEX
::	CALLS:		JAL	R8,WCI	Crashes (in WCI) if R2=0 or 4. 
::
::*********************************************************************

WCIE	HS	0
	THI	R1,0F8			:is it in the 0-7 range?
	JNFS	WCIE1
	EXHR	R1,R1			:if yes, shift zero to low byte
	JAL	R8,WCI			:and write in an escape
	EXHR	R1,R1			:get the data back back to low byte
WCIE1	JAL	R8,WCI			:write data byte to buffer
	JR	R9			:and return

::*********************************************************************
::
::	SUBROUTINE:	WCDE:
::	FUNCTION:	Prefix a character (from R1), escaped if necessary,
::			into a buffer (index in R2).
::	CALLING SEQ:	JAL	R9,WCDE
::	INPUT:		R1 = CHARACTER
::			R2 = BUFFER INDEX
::	DESTROYED:	R8
::	CALLS:		JAL	R8,WCD
::
::*********************************************************************

WCDE	JAL	R8,WCD
	THI	R1,0F8
	JNR	R9
	EXHR	R1,R1
	JAL	R8,WCD
	EXHR	R1,R1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	W2CI:
::	FUNCTION:	Write 2 characters (from R1), without escaping, into a
::		buffer (index in R2).
::	CALLING SEQ:	JAL	R9,W2CI
::	INPUT:		R1 = 2 CHARACTERS
::			R2 = BUFFER INDEX
::	DESTROYED:	R8
::	CALLS:		JAL	R8,WCI	Crashes (in WCI) if R2=0 or 4.
::
::*********************************************************************

W2CI	HS	0
	EXBR	R1,R1			:HIGH-ORDER BYTE GOES FIRST
	JAL	R8,WCI
	EXBR	R1,R1
	JAL	R8,WCI			:WRITE SECOND BYTE
	JR	R9			:AND RETURN

	SUBTTL	BUFF (GCI - Get character from a buffer)

::*********************************************************************
::
::	SUBROUTINE:	GCI:
::	FUNCTION:	Get a byte of data from a buffer.
::	CALLING SEQ:	JAL	R8,GCI
::	INPUT:		R2 = BUFFER NUMBER X 4
::	OUTPUT:		R1 = CONTAINS THE CHARACTER
::	DESTROYED:	R0, R3
::	PRESERVED:	ALL OTHERS
::
::*********************************************************************

:	Normal entry point.  Make sure not using buffer	index 0 or 4.
:	(CRQ and LOGGER enter at GCI0).
GCI	HS	0
	CLHI	R2,4			:TEST FOR BUFFER NUMBER 0 OR 1
	JGFS	GCI0			:OK
	CRASH.(.GCICR)			:Illegal use of buffer 0 or 4 at GCI

	IF	ESYNC

:	Entry point for CRQ, LOGGER using buffer index 0, 4.
:	Fall thru here for valid regular GCI buffer index.
GCI0	HS	0
:	Edit buffer's BF. Crash if negative.  Else continue at GCI1.
	IF	DB.DEB
	LH	R1,BF,R2,		:EDIT BUFFER'S BF
	JGEFS	GCI1
	DBOOPS
	EI	:DB.DEB
GCI1	HS	0
:	GCI instruction takes us to GCIERR on empty buffer or invalid buffer
:	index, to GCRET to return empty bufferlet, to GCLAST when buffer is
:	empty.  Otherwise, fall thru, check for buffer tracing, and return.
GCI2	HS	0
	HC	3812			:GCI  R1,R2

	HC	BE-BB			:SIZE OF BB STORAGE
	HC	GCIERR-GCI2		:HERE ON EMPTY OR INVALID BUF #
	HC	BB/4			:ADDRESS OF BB STORAGE /4
	HC	GCRET-GCI2		:HERE TO RETURN EMPTY BUFFERLET
	HC	GCLAST-GCI2		:HERE TO CLEAR EMPTY BUFFER

	JR	R8			:DONE

:	Here from GCI instruction for bad buffer index or empty buffer.
GCIERR	HS	0
	CRASH.(.GCIC0)

	ELSE	:NOT ESYNC

GCI0	L	R3,BB,R2,		:GET THE OUT PTR
	JNFS	GCI1
	JAL	R0,OOPS			:EMPTY BUFFER
	JR	R8
GCI1	LB	R1,0,R3			:GET THE CHAR
	CL	R3,BE,R2,		:IS IT THE LAST?
	JEFS	GCLAST
	AIS	R3,1			:NO, MOVE TO NEXT SLOT
	THI	R3,CBSZ-1
	JE	GCRET			:TIME TO RETURN BFLT
	ST	R3,BB,R2,
	JR	R8
	EI	:ESYNC

::*********************************************************************
::
::	GCLAST:	Here when GCI empties a buffer.
::
::*********************************************************************

:	Clear BB, BE, BCT and reset attention flag.
:	Decrement count of bufferlets in use.
:	Link to and update FREELT.
GCLAST	HS	0
	LIS	R0,0			:LAST CHAR - CLEAR THE BUFFER
	ST	R0,BB,R2,		:SET BOTH PTRS TO 0
	ST	R0,BE,R2,
	STH	R0,BCT,R2,
	LH	R0,BF,R2,		:CLEAR ATTN FLAG
	RBT	R0,NFLAGS,,
	AHI	R3,CBSZ-1		:INDEX PTR TO LINK
	NHI	R3,@(CBSZ-1)
	LCS	R0,CBSZ-2		:negative number of data bytes in bflt
	AM	R0,BFLTSV		:DECREMENT NUMBER OF BUFFERLETS IN USE
	JGEFS	GCLAS9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS

GCLAS9	HS	0
	IF	REBILD
	CLI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	GCLAS1			:NO				###OAS
	AM	R0,HBFTSV		:YES, INCREMENT COUNT		###OAS
	JGEFS	GCLAS1			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
GCLAS1	HS	0
	EI	:REBILD

	LHL	R0,FREELT
	STH	R0,0,R3
	SI	R3,CHRBUF+CBSZ-2	:COMPUTE BFLET #
	SRLS	R3,CBSZL
	STH	R3,FREELT
	JR	R8			:RETURN TO CALLER

::*********************************************************************
::
::	GCRET:	GCI emptied a bufferlet. Return it to the free list.
::
::*********************************************************************

:	Decrement BCT and bufferlet-in-use count.
:	Return bufferlet and link to FREELT.
GCRET	HS	0
	LCS	R0,CBSZ-2		:RETURN A BFLET - DEC CNT
	AHM	R0,BCT,R2,
	AM	R0,BFLTSV		:DECREMENT COUNT OF BUFFERLETS IN USE
	JGEFS	GCRET9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
GCRET9	HS	0

	IF	REBILD
	CLI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	GCRET1			:NO				###OAS
	AM	R0,HBFTSV		:YES, ADJUST COUNT		###OAS
	JGEFS	GCRET1			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
GCRET1	HS	0
	EI	:REBILD

	LHL	R0,0,R3			:GET LINK
	SLLS	R0,CBSZL			:COMPUTE PTR
	AI	R0,CHRBUF
	ST	R0,BB,R2,
	LHL	R0,FREELT		:PREFFIX BUFF TO LIST
	STH	R0,0,R3
	SI	R3,CHRBUF+CBSZ-2	:COMPUTE BFLET #
	SRLS	R3,CBSZL
	STH	R3,FREELT
	JR	R8			:RETURN TO CALLER

::*********************************************************************
::
::	SUBROUTINE:	GHWI:
::	FUNCTION:	Assemble a HW (no escapes) in R1 from a buffer.
::		Buffer must contain a HW of data or we'll crash in GCI.
::	CALLING SEQ:	JAL	R9,GHWI
::	DESTROYED:	R0, R3, R4
::
::*********************************************************************

GHWI	HS	0
	JAL	R8,GCI			:GET CHAR
	LR	R1,R1
	JNFS	GHWI10
	JAL	R8,GCI			:ESCAPED CHAR
GHWI10	LR	R4,R1
	EXBR	R4,R4
	JAL	R8,GCI			:SECOND CHAR
	LR	R1,R1
	JNFS	GHWI20			:###jhl
	JAL	R8,GCI
GHWI20	AR	R1,R4			:###jhl
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	GZHWI:
::	FUNCTION:	Assemble a HW (no escapes) in R1 from a buffer.
::	CALLING SEQ:	JAL	R9,GZHWI
::	INPUT:		R2 = VALID BUFFER INDEX
::	OUTPUT:		R1 = HALFWORD
::	DESTROYED:	R0, R3, R4, R8
::	CALLS:		JAL	R8,GCI
::	RETURNS:	Straight return if buffer empties prior to completion.
::			Else skip+4 return.
::
::*********************************************************************

GZHWI	HS	0
	LHL	R0,BCT,R2,		:BUFFER EMPTY?
	JER	R9			:YES - DO NORMAL RETURN
	JAL	R8,GCI
	LR	R1,R1			:ESCAPE CHARACTER?
	JNFS	GZHW10			:NO
	LHL	R0,BCT,R2,
	JER	R9			:EMPTY BUFFER RETURN
	JAL	R8,GCI			:GET ESCAPED CHAR
GZHW10	LR	R4,R1
	EXBR	R4,R4
	LHL	R0,BCT,R2,
	JER	R9			:EMPTY BUFFER RETURN
	JAL	R8,GCI
	LR	R1,R1			:SECOND CHAR ESCAPED?
	JNFS	GZHW20			:NO
	LHL	R0,BCT,R2,		:YES - GET IT
	JER	R9			:ONLY IF BUFFER
	JAL	R8,GCI			:NOT EMPTY
GZHW20	AR	R1,R4			:COMBINE BOTH CHARACTERS AND
	J	4,R9			:DO SKIP RETURN

::*********************************************************************
::
::	SUBROUTINE:	GHWI0:
::	FUNCTION:	Same as GHWI but accepts buffer index 0 or 4.
::	CALLING SEQ:	JAL	R9,GHWI0
::	INPUT:		R2 = VALID BUFFER INDEX
::	OUTPUT:		R1 = HALFWORD
::	DESTROYED:	R0, R3, R4, R8
::	CALLS:		JAL	R8,GCI0
::
::*********************************************************************

GHWI0	HS	0
	JAL	R8,GCI0			:GET CHARACTER
	LR	R1,R1
	JNFS	GHWI01			:NOT ESCAPE
	JAL	R8,GCI0
GHWI01	LR	R4,R1
	EXBR	R4,R4			:MOVE FIRST BYTE TO HI-ORDER POS. OF HW
	JAL	R8,GCI0
	LR	R1,R1			:REQUIRE ESCAPE?
	JNFS	GHWI02			:NO
	JAL	R8,GCI0			:YES - GET ESCAPED CHARACTER
GHWI02	AR	R1,R4			:COMBINE FIRST AND SECOND CHARACTERS
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	GCIE:
::	FUNCTION:	Get a character (returned in R1) from a buffer
::			(index in R2),	stripping escapes.
::	CALLING SEQ:	JAL	R9,GCIE
::	INPUT:		R2 = VALID BUFFER INDEX  Crashes if R2=0 or 4.
::	OUTPUT:		R1 = CHARACTER
::	DESTROYED:	R1, R8
::	CALLS:		JAL	R8,GCI
::
::*********************************************************************

GCIE	HS	0
	JAL	R8,GCI			:GET CHAR (UNESCAPED)
	LR	R1,R1
	JNR	R9
	JAL	R8,GCI
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	G2CI:
::	FUNCTION:	Get 2 characters (into R1) from a buffer (index in R2),
::			without stripping escapes.
::	CALLING SEQ:	JAL	R9,G2CI
::	INPUT:		R2 = VALID BUFFER INDEX  Crashes (in GCI) if R2=0 or 4.
::	OUTPUT:		R1 = 2 CHARACTERS
::	DESTROYED:	R1, R4, R8
::	CALLS:		JAL	R8,GCI
::
::*********************************************************************

G2CI	HS	0
	JAL	R8,GCI
	LR	R4,R1
	EXBR	R4,R4			:FIRST CHARACTER IN HIGH-ORDER BYTE
	JAL	R8,GCI
	OR	R1,R4			:COMBINE BOTH CHARACTERS
	JR	R9			:AND RETURN

	SUBTTL	BUFF (PCI - Peek at first character in a buffer)

::*********************************************************************
::
::	SUBROUTINE:	PCIS:/PCI:/NCI:
::	FUNCTION:	ENTRY POINTS:
::		PCIS -	Peek at the first character in a buffer.
::		PCI  -	Peek at (the next) character in a buffer.
::			R3 must contain a legal pointer into the buffer,
::			else garbage is returned.  Before calling PCI,
::			set up R3 to point to desired position in buffer,
::			or use PCIS for first character, PCI for subsequent
::			characters in sequence.  R3 must stay in tact from
::			PCIS to last PCI.  
::		NCI  -	Same as PCI, but does not peek at character,
::			just increments pointer into buffer.
::
::*********************************************************************

:	Init R3 to point to first character in buffer (BB).
PCIS	HS	0
	L	R3,BB,R2,		:INIT PCI

:	Enter here if R3 already set up.
:	(Either by caller or by previous call to PCIS)
PCI	HS	0
	LB	R1,0,R3			:GET THE CHARACTER

:	Enter here to increment pointer into buffer (R3) by one position,
:	without peeking at characters.
NCI	HS	0
	AIS	R3,1			:INC PTR
	THI	R3,CBSZ-1
	JNR	R8
	LHL	R3,0,R3			:MOVE TO NEXT BUFFERLET
	SLLS	R3,CBSZL
	AI	R3,CHRBUF
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	PCIE:
::	FUNCTION:	Peek at next (escaped) character in buffer.
::			Same as PCI, but strips escapes.
::	CALLING SEQ:	JAL	R9,PCIE
::	CALLS:		JAL	R8,PCI
::
::*********************************************************************

:	PCI a char.  If 00, PCI another and return. Else just return.
PCIE	HS	0
	JAL	R8,PCI			:PEEK AT NEXT CHARACTER
	LR	R1,R1			:ESCAPE?
	JNR	R9			:NO - RETURN 
	JAL	R8,PCI			:YES - GET ESCAPED CHARACTER AND
	JR	R9			:RETURN


::*********************************************************************
::
::	SUBROUTINE:	PHWI:
::	FUNCTION:	Peek at next HW (returned in R1) in a buffer, stripping
::		escapes.  R3 must contain a valid pointer into the buffer
::		(see PCI).  There must be a HW of data in the buffer, or
::		garbage is returned.
::	CALLING SEQ:	JAL	R9,PHWI
::	INPUT:		R3 = VALID BUFFER POINTER
::	OUTPUT:		R1 = HW
::	DESTROYED:	R1, R4, R8
::	CALLS:		JAL	R8,PCI
::
::*********************************************************************

PHWI	HS	0
	JAL	R8,PCI			:GET A CHAR
	LR	R1,R1			:TEST FOR ESCAPE CHAR '00'
	JNFS	PHWI1			:SKIP ANOTHER READ IF NOT ESC-PAIR
	JAL	R8,PCI			:READ SECOND OF PAIR IF ESCAPED CHAR
PHWI1	LR	R4,R1			:SAVE CHAR IN REG 4
	EXBR	R4,R4			:PUT IN 2ND BYTE FROM RIGHT FOR LATER
	JAL	R8,PCI			:GET NEXT CHARACTER
	LR	R1,R1			:TEST FOR ESCAPE CHARACTER
	JNFS	PHWI2			:SKIP ANOTHER READ IF NOT ESCAPE-PAIR
	JAL	R8,PCI			:READ SECOND OF PAIR IF ESCAPED
PHWI2	AR	R1,R4			:COMBINE SECOND BYTE WITH FIRST IN R1
	JR	R9			:RETURN TO CALLING ROUTINE

::*********************************************************************
::
::	SUBROUTINE:	CHWI:
::	FUNCTION:	RETURNS A HALF-WORD IN R1 AND REPLACES IT WITH 'FFFF'.
::	CALLING SEQ:	JAL	R9,CHWI
::	DESTROYED:	R0
::	CALLS:		JAL	R8,NCI
::
::*********************************************************************

CHWI	HS	0
	LCS	R0,1
	LB	R4,0,R3			:GET A CHARACTER
	JNFS	CHWI1			:IT IS NOT BEING ESCAPED, SKIP
	JAL	R8,NCI,,		:ESCAPED, INC PTR, GET NEXT CHAR###CY
	LB	R4,0,R3
CHWI1	STB	R0,0,R3			:REPLACE IT W/ 'FF'
	EXBR	R4,R4
	JAL	R8,NCI,,		:INC PTR  			###CY
	LB	R1,0,R3			:AND REPEAT
	JNFS	CHWI2
	JAL	R8,NCI,,		:###CY
	LB	R1,0,R3
CHWI2	STB	R0,0,R3
	JAL	R8,NCI,,		:###CY
	AR	R1,R4
	JR	R9

	SUBTTL	BUFF (CBCLR - Clear a buffer)

::*********************************************************************
::
::	SUBROUTINE:	CBCLR: / GLBCLR:
::	FUNTION:	Clear a buffer (index in R2), reset its attention flag.
::			Crashes if R2 not a valid buffer index, or if buffer's
::			BF is negative.
::	CALLING SEQ:	JAL	R8,CBCLR
::	INPUT:		R2 = VALID BUFFER INDEX
::	DESTROYED:	R0, R3
::
::*********************************************************************
::GLBCLR avoids possible complications by not resetting the BF, which is 
::actually marked as Log-in state - therefore not a real BF, therfore avoiding
::a wild reset of some bit somewhere between 10 and 17.

	IF	T2GATE
GLBCLR	HS	0		:Special section for Gateway 1/2 circuits
	THI	R2,3			:LEGAL BUFF?
	JE	GBCLR1
	CRASH.(.CBCLC)
GBCLR1	LH	R3,BF,R2,		:GET ABSOLUTE CHANNEL NUMBER 
	JGE	GBCLR2
	CRASH.(.CBCL0)
GBCLR2	L	R3,BE,R2,		:GET BUFFER FILL POINTER
	JER	R8			:ZERO, BUFFER EMPTY. RETURN
	J	GLBC01		:continue with clearing process
	EI	:T2GATE


CBCLR	HS	0
	ST	R2,TSTSAV,,		:TESTING ###EV
	IF	BFSDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,CBCDB1,,
	GL	CBCDB1
	L	R4,REGST,,
	EI	:BFSDBG

	THI	R2,3			:LEGAL BUFF?
	JE	CBCLR1
	CRASH.(.CBCLC)
CBCLR1	LH	R3,BF,R2,		:GET ABSOLUTE CHANNEL NUMBER 
	JGE	CBCLR2
	CRASH.(.CBCL0)
CBCLR2	RBT	R3,NFLAGS,,		:CLEAR ATTN FLAG
	L	R3,BE,R2,		:GET BUFFER FILL POINTER
	JER	R8			:ZERO, BUFFER EMPTY. RETURN

:	If the buffer is empty, just RETURN.  Otherwise, chain the first
:	bufferlet to the free list, clear BB, BE, and BCT, decrement
:	bufferlets-in-use count, then RETURN.
GLBC01	AHI	R3,CBSZ-1		:MAKE PTR TO BFRLT LINK
	NHI	R3,@(CBSZ-1)
	LHL	R0,FREELT		:INSERT HEAD OF LIST
	STH	R0,0,R3
	L	R3,BB,R2,		:COMPUTE # OF FIRST BUFFERLET
	SI	R3,CHRBUF
	SRLS	R3,CBSZL
	STH	R3,FREELT

	IF	BFSDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,CBCDB2,,
	GL	CBCDB2
	L	R4,REGST,,
	EI	:BFSDBG

	LIS	R0,0			:CLEAR BOTH PTRS
	ST	R0,BE,R2,
	ST	R0,BB,R2,
	LHL	R3,BCT,R2,		:BCT=14*N-13,N=NUMBER OF B'LETS CHAINED
	AIS	R3,CBSZ-3		:R3 NOW = 14*(NUMBER OF B'LETS CHAINED)
	STH	R0,BCT,R2,		:ZERO OUT THE BCT COUNT
	SR	R0,R3			:FORM 2'S COMPLEMENT OF R0 R3???

	IF	REBILD
	CLI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	CBCLR3			:NO				###OAS
	AM	R0,HBFTSV		:YES, ADJUST COUNT		###OAS
	JGEFS	CBCLR3			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
CBCLR3	HS	0
	EI	:REBILD

	AM	R0,BFLTSV		:DECREMENT THE NUMBER OF B'LETS IN USE
	JGER	R8			:				###TZ
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS


	SUBTTL	BUFF (CKZB - Refill bufferlet reserve tank)

::*******************************************************************
::
::	PROCESS:	CKZB:
::	FUNCTION:	Refill bufferlet reserve tank.
::		Highest priority process in the node code.  Gets scheduled
::		whenever the reserve tank is linked into the free list.  We
::		must recover 80x bufferlets to refill the reserve tank. If
::		they are not available, we will zap buffers until they are.
::
::*********************************************************************

:	Init R1 to 80 (number of free bufferlets required to refill reserve
:	tank).  Get the free list pointer in R3, continue at REB3.
CKZB	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(CKZB  )			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU
	LHI	R1,80			:80 bufferlets to refill reserve tank
CKZB0	LHL	R3,FREELT		:Free list pointer to R3
	JFS	REB3			:Skip on first pass

:	Get the current bufferlet's link pointer to R3.
REB2	HS	0
	LR	R2,R3
	SLLS	R2,CBSZL
	LHL	R3,CHRBUF+CBSZ-2,R2,

:	If R3 is 0 (last bufferlet), go to REBZ to zap another buffer.
:	Else decrement R1 by 1 and back to REB2 until R1 is 0
:	(80 bufferlets found).
REB3	HS	0
	JE	REBZ
	SIS	R1,1
	JGBS	REB2

:	Got 80 bufferlets. Link them into the reserve tank (REBL),
:	update FREELT, and DISMISS to EXEC.
	STH	R1,CHRBUF+CBSZ-2,R2,
	LHL	R1,FREELT		:80 BUFFERLETS FOUND,
	STH	R1,REBL			:LINK THEM INTO RESERVE TANK
	STH	R3,FREELT
	
	IF	BFSDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,CKZDB1,,
	GL	CKZDB1
	L	R4,REGST,,
	EI	:BFSDBG

	J	EXDISM,,

:	ZAP A BUFFER, AND RETURN TO CKBZ TO TRY AGAIN TO REFILL RESERVE TANK.

:	Find the biggest buffer (based on BCT) and call BUFZAP to zap it and
:	report to sup.  Then back to CKZB to finish refilling reserve tank.
REBZ	HS	0
	LHI	R1,BBSIZE-4		:ZAP BIGGEST BUFFER, MAKE MORE STORAGE
	LIS	R7,0
REBZ1	LHL	R0,BCT,R1,
	CLR	R7,R0
	JGEFS	REBZ2
	LR	R7,R0			:LARGEST COUNT SO FAR
	LR	R2,R1			:AND BUFFER INDEX
REBZ2	SIS	R1,4
	JGEBS	REBZ1
:	R2 CONTAINS INDEX FOR BUFFER WITH LARGEST COUNT. ZAP IT.
	JAL	R0,BUFZAP		:ZAP BUFFER, REPORT TO SUP

	IF	BFSDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,RBZDB1,,
	GL	RBZDB1
	L	R4,REGST,,
	EI	:BFSDBG

	J	CKZB			:###TZ

::*********************************************************************
::
::	SUBROUTINE:	BUFZAP:
::	FUNCTION:	Zap the buffer specified by R2.
::	ZAP BUFFER SPECIFIED BY BUFFER INDEX IN R2. CLEAR BUFFER, AND PLACE
::	BLACK BALL INTO BUFFER TO NOTIFY DESTINATION THAT
::	DATA HAVE BEEN LOST. MAKE REPORT TO SUPERVISOR.
::	CALLING SEQ:	JAL	R0,BUFZAP
::	INPUT:		R2 = BUFFER INDEX
::	PRESERVED:	ALL OTHER REGISTERS
::	CALLS:		JAL	R8,CBCCT
::			JAL	R8,CBCLR
::			JAL	R9,W2CI
::			JAL	R10,SUP12
::
::*********************************************************************

:	Get and save (R4) the exact buffer byte count, then clear the buffer.
BUFZAP	HS	0
	STM	R0,BFZPRS,,		:PRESERVE CONTEXT
	JAL	R8,CBCCT
	LR	R4,R1			:SAVE EXACT BUFFER COUNT
	JAL	R8,CBCLR		:CLEAR BUFFER

	IF	BFSDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	ST 	R8,RGST,,
	LR	R8,R4			:BUFFER COUNT
	JAL	R4,BFZDB1,,
	GL	BFZDB1
	L	R4,REGST,,
	L	R8,RGST,,
	EI	:BFSDBG

:	If we're zapping a history buffer, update HSEQN by the count of
:	characters clear (R4)--total pruning.
:	Go to BUFZP4 to bypass putting a black ball in.
	IF	REBILD
	CLI	R2,HBUFN		:HISTORY BUFFER?
	JLFS	BUFZP2			:NO - GARDEN VARIETY
	AM	R4,HSEQN,R2,		:YES - TOTAL PRUNING! ADVANCE HIST SEQ#
	JFS	BUFZP4			:BYPASS BLACK BALL
	EI	:REBILD

:	Not a history buffer, so put a black ball in buffer to inform
:	destination of data loss.
BUFZP2	HS	0
	LHI	R1,01FD			:BLACK BALL
	JAL	R9,W2CI

:	Inform supe and CRYPTO of buffer zap, bump count of buffer zaps,
:	return to caller.
BUFZP4	HS	0
	LIS	R0,NR.BFZ		:BUFFER ZAP NODE REPORT
	STH	R0,SUPMBF
	STH	R2,SUPMBF+2		:BUFFER INDEX
	STH	R4,SUPMBF+4		:BUFFER COUNT
	XHI	R2,4			:FLIP BUFFER
	LHL	R0,BF,R2,		:GET GUILTY CHANNEL
	STH	R0,SUPMBF+6		:AND STORE FOR XRAY DISPLAY
	XHI	R2,4			:RECOVER BUFFER
	JAL	R10,SUP12,,		:NODE REPORT AND CRYPTOGRAM
	LIS	R0,1
	AHM	R0,BZAPCT,,		:COUNT BUFFER ZAPS
	LM	R0,BFZPRS,,
	JR	R0			:RETURN

	SUBTTL	BUFF (Utilities)

::*********************************************************************
::
::	SUBROUTINE:	RETBLT:
::	FUNCTION:	Return the first bufferlet from a buffer (index in R2)
::		to the free list.  Used by REBILD to prune a history
::		buffer. Decrements BCT and bufferlets-in-use count.
::		Crashes if the latter goes negative.
::	CALLING SEQ:	JAL	R8,RETBLT
::	INPUT:		R2 = BUFFER INDEX
::	DESTROYED:	R0, R3
::
::*********************************************************************

      IF 1-REBTST  :no longer needed
RETBLT	HS	0
	L	R3,BB,R2,		:POINTER TO BFLET LINK
	AHI	R3,CBSZ-1
	NHI	R3,@(CBSZ-1)
	LHL	R0,0,R3			:NEXT BLET IN CHAIN
	SLLS	R0,CBSZL
	AI	R0,CHRBUF
	ST	R0,BB,R2,
	LHL	R0,FREELT
	STH	R0,0,R3
	SI	R3,CHRBUF+CBSZ-2
	SRLS	R3,CBSZL
	STH	R3,FREELT
	LCS	R0,CBSZ-2

	IF	REBILD
	CLI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	RETBL1			:NO				###OAS
	AM	R0,HBFTSV		:YES, ADJUST COUNT		###OAS
	JGEFS	RETBL1			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
RETBL1	HS	0
	EI	:REBILD

	AM	R0,BFLTSV		:DECREMENT # OF BUFFERLETS-IN-USE FIELD
	JGEFS	RETBL9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
RETBL9	HS	0			:				###TZ
	LHL	R0,BCT,R2,		:ALLOW FOR FULL 16-BIT BCT	###TZ
	SIS	R0,CBSZ-2		:				###TZ
	STH	R0,BCT,R2,		:				###TZ
	JGER	R8
	CRASH.(.RTBLC)
      EI  :REBTST


        IF      REBTST

::*********************************************************************
::
::	SUBROUTINE:	RTBFTS:
::	FUNCTION:       ReTurn BufFerleTS  removes the number of chars
::		specified in R0 from buffer in R2.  Returns actual
::		number chars removed in R0.  Destroys R0 and R3.  Much
::		more efficient than either using a GCI per char or
::		repeatedly calling a similar routine that only returns
::		a bflet at a time (which removed between 1 and 14 chars
::		per bflet).                             ###sdw
::
::*********************************************************************

RTBFTS  ST      R4,R4RBFT       :save a reg
        STH     R0,R0RBFT       :save count to remove
        ST      R1,R1RBFT       :save R1
        HC      3A42            :CBCCT r4,r2 :BCT to R4 of buff in R2
        HC      BB/4
        HC      BE-BB
        CR      R4,R0           :have enough (r4) to return asked amount? (r0)
        JG      RTBFT1          :jump if enough
        ST      R8,R0RBFT       :just empty it
        JAL     R8,CBCLR
        L       R8,R0RBFT       :save regs as use normal empty
        LR      R0,R4           :restore count removed
        L       R1,R1RBFT
        L       R4,R4RBFT
        JR      R8              :handle the complete empty case

RTBFT1  L       R3,BB,R2,       :get start
        LR      R1,R3           :get copy to calc how many in 1st buflet
        AIS     R1,CBSZ-1       :bump up to pointer plus a byte
        NHI     R1,-CBSZ        :knock of a bit and get pointer
        SR      R3,R1           :R3 gets negative count of chars in 1st buflet
        AR      R0,R3           :that many already read
        JL      RTBFT7          :all chars to remove were in first bufferlet
        LIS     R4,0            :count how many bflets removed for BCT
RTBFT2  LR      R3,R1           :repeat for next buflet
        LHL     R1,0,R3         :get next pointer to next buflet
        SLLS    R1,CBSZL        :make pointer into address
        AI      R1,CHRBUF+CBSZ-2
        SIS     R4,CBSZ-2       :another bflet returned
        SIS     R0,CBSZ-2       :reduce count of how many to remove
        JGEBS   RTBFT2          :new BB will be in next buflet
        AHM     R4,BCT,R2,      :r0 is BCT by buflet
        AM      R4,BFLTSV
        JGEFS   RTBFT4
        JAL     R7,NEGBCR,,     :crash if in use goes negative
RTBFT4  HS      0
      IF REBILD         :rebuild's in use
        CLI    R2,HBUFN        :history buff?
        JLFS    RTBFT5          :nope
        AM      R4,HBFTSV       :fewer history in use
        JGEFS   RTBFT5
        JAL     R7,NEGHCR,,     :crash if neg
RTBFT5  HS      0
      EI  :rebild
        LHL     R4,FREELT       :chain 1st free to end of chain we're returning
        STH     R4,0,R3
        L       R4,BB,R2,       :1st free will is buflet number of what was BB
        AIS     R4,CBSZ-1       :make the address into pointer
        NHI     R4,-CBSZ
        SI      R4,CHRBUF
        SRLS    R4,CBSZL        :now a pointer
        STH     R4,FREELT       :newest free
RTBFT7  AR      R1,R0           :R1 is end of bflet, R4 is chars from end
        ST      R1,BB,R2,       :save new bb
        LHL     R0,R0RBFT       :get how many removed
        L       R1,R1RBFT       :restore a couple of regs
        L       R4,R4RBFT
        JR      R8              :nicely done  ###sdw

        EI  :SDDW.2

::*********************************************************************
::
::      SUBROUTINE:     RTBFTA:
::	FUNCTION:
::      returns number of chars in R0 plus however many to ensure that
::      first char in buff could not be a second char of a char pair
::      Can't allow potential split char be intepreted as a first char
::      of a pair since this probably would make an invalid char pair.
::
::*********************************************************************

        IF      REBTST
RTBFTA  JAL     R8,RTBFTS       :remove specified number of char
        LHL     R1,BCT,R2,
        JER     R9
        JAL     R8,PCIS
        SIS     R1,3
        JGR     R9              :no problem
        LIS     R4,1            :count how many extra read
        JFS     RTBFA2
RTBFA1  JAL     R8,PCIS
        SIS     R1,3
        JGFS    RTBFA3
        AIS     R4,1
RTBFA2  JAL     R8,GCI          :take out the offending char
        LHL     R2,BCT,R2,
        JGBS    RTBFA1          :make sure buffer not empty
RTBFA3  LHL     R0,R0RBFT       :get back R0 from RTBFTS
        AR      R0,R4           :and extra chars
        L       R4,R4RBFT
        JR      R9
        EI :REBTST

::*********************************************************************
::
::	SUBROUTINE:	CBCCT:
::	FUNCTION:	Compute the (exact) count (returned in R1) of bytes in
::			a buffer (index in R2).
::	CALLING SEQ:	JAL	R8,CBCCT
::	INPUT:		R2 = BUFFER NUMBER * 4
::	OUTPUT:		R1 = CHARACTER COUNT
::
::*********************************************************************

	IF	ESYNC
CBCCT	HS	0
	HC	3A12			:CBCT - COMPUTE BCT (CHAR COUNT)
	HC	BB/4			:START OF BUFFERLET AREA
	HC	BE-BB			:SIZE OF BB ARRAY
	JR	R8

	ELSE
:	CBCCT:
:	RETURNS COUNT OF CHARACTER IN BUFFER. (IN R1)
:	***NOTE THAT THE MAXIMUM # CHARACTERS ALLOWED IN A BUFFER
:	IS 2^15-1 (I.E., HI ORDER BIT OF COUNT MUST BE 0). OTHERWISE AN
:	OVERFLOW WILL RESULT.****

CBCCT	LHL	R0,BB+2,R2,
	NHI	R0,CBSZ-1
	LHL	R1,BE+2,R2,
	NHI	R1,CBSZ-1
	SR	R1,R0
	AH	R1,BCT,R2,
	JR	R8
	EI	:ESYNC

::*********************************************************************
::
::	SUBROUTINE:	SNDFX0:
::	FUNCTION:	Write a SQFIX with a count of 0 into a buffer
::		(index in R2).
::		This special sextet is sent immediately behind a needle to
::		determine whether a new circuit is rebuildable.  If it is,
::		the destination node will respond with a SQACK with a count 
::		of 0 before sending any data.  If we don't get a SQACK0 
::		before any data, we know the circuit is not rebuildable..
::	CALLING SEQ:	JAL	R9,SNDFX0
::	INPUT:		R2 = BUFFER INDEX
::	DESTROYED:	R1, R4, R8
::	CALLS:		JAL	R8,WCI
::
::*********************************************************************

	IF	REBILD

SNDFX0	LR	R4,R3			:SAVE R3			###GT
	LIS	R1,3			:SEND BACK A SQFIX 0		###GT
	JAL	R8,WCI
	LIS	R1,SQFIX&0FF
	JAL	R8,WCI			:TO DETERMINE REBUILDABILITY	###GT
	LIS	R1,0			:SEQUENCE NUMBER = 0
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	LR	R3,R4			:RESTORE R3
	JR	R9			:RETURN

	EI	:REBILD

	SUBTTL	BUFF (GFCBUF/RFCBUF - Get/Return free character buffer pair)

::*********************************************************************
::
::	SUBROUTINE:	GFCBUF:
::	FUNCTION:	Grab-Free-Character-BUFfer
::	CALLING SEQ:	JAL	R8,GFCBUF
::	OUTPUT:		R2 = BUFFER #
::	DESTROYED:	R0
::
::*********************************************************************

:	Get buffer index from FREELB, crash if 0, or if <CIRZBF, or if >HBUFN-8
GFCBUF	HS	0

	IF	BFSDBG			:DEBUGGER			###LSH
	ST	R4,REGST,,
	JAL	R4,GFCDB1,,
	GL	GFCDB1
	L	R4,REGST,,
	EI	:BFSDBG		

	LHL	R2,FREELB		:GET THE BUFF #
	JE	OP8063			:NONE, COMPLAIN
	CLI	R2,CIRZBF		:RANGE CHECK BUFFER NUMBER
	JL	OP8263			:TOO LOW
	CLI	R2,HBUFN-8
	JG	OP8263			:TOO HIGH

:	Get linked buffer (via BB), crash if <CIRZBF, or if >HBUFN-8,
:	or if not multiple of 4.
	LHL	R0,BB,R2,		:UPDATE FREE LIST
	JER	R8			:immediate return - out of buffers!#wjl
	CLI	R0,CIRZBF		:RANGE CHECK LINKED BUFFER NUMBER
	JL	OP8463			:(NEW HEAD OF FREE LIST)
	CLI	R0,HBUFN-8
	JG	OP8463
	THI	R0,3			:BETTER BE A BUFF #
	JN	OP8663			:NOT

:	BUFFER EDITS COMPLETE - STORE NEW HEAD OF FREE LIST
:	Got good free buffer and linked buffer index.
:	Update the free list, clear the new buffers' BFs and BB
:	(also history buffer's BF if REBILD).
:	Skip +4 RETURN.
	STH	R0,FREELB
	LIS	R0,0			:CLEAR THE ATTN FLAG
	STH	R0,BF,R2,
	STH	R0,BF+4,R2,

	IF	REBILD
	SRHLS	R2,1
	STH	R0,BF+HBUFN,R2,
	SLHLS	R2,1
	EI	:REBILD

	STH	R0,BB,R2,

	IF	\TZ.TST
	DBCRY.(TZ.TST,R2,R8)
	EI	:TZ.TST

	J	4,R8			:SKIP RETURN

OP8063	CRASH.(.GFCR0)
OP8263	CRASH.(.GFCR1)
OP8463	CRASH.(.GFCR2)
OP8663	CRASH.(.GFCR3)

::**********************************************************************
::
::	SUBROUTINE:	RFCBUF:
::	FUNCTION:	RETURNS A BUFFER PAIR TO THE FREE LIST.
::			USES 'BB' AS LINK IN FREE BUFFER CHAIN.
::			SETS 'BF' TO 'DEAD' TO INDICATE BUFF NOT IN USE.
::	CALLING SEQ:	JAL	R8,RFCBUF
::	INPUT:		R2 = BUFFER #
::
::*********************************************************************

RFCBUF	STH	R2,RFCSAV		:SAVE BUFFER #
	NHI	R2,-8			:USE LOW ORDER HALF of pair (even bfr)

	IF	BFSDBG			:DEBUGGER			###LSH
	ST	R4,REGST,,
	JAL	R4,RFCDB1,,
	GL	RFCDB1
	L	R4,REGST,,
	EI	:BFSDBG		

	CLI	R2,CIRZBF		:RANGE CHECK BUFFER # BEING RETURNED
	JL	OP8863			:ERROR - TOO LOW
	CLI	R2,HBUFN-8
	JG	OP8863			:TOO HIGH
	LR	R1,R8			:SAVE LINK
	JAL	R8,CBCLR,,		:DON'T TAKE ANY BUFFERLETS WITH IT
	LHL	R0,FREELB
	STH	R0,BB,R2,
	STH	R2,FREELB

	IF	\TZ.TST
	DBCRY.(TZ.TST,R2,R1)
	EI	:

	IF	REBILD
	LIS	R0,0			:CLEAR OTHER VARIABLES
	ST	R0,SEQN,R2,
	ST	R0,SEQN+4,R2,
	EI	:REBILD

	XHI	R2,4			:CLEAR OTHER HALF

	JAL	R8,CBCLR,,

	LHI	R3,DEAD			:SET BF'S TO 'DEAD'
	STH	R3,BF-4,R2,
	STH	R3,BF,R2,

	SRHLS	R2,1			:CLEAR HISTORY BUFF VARIABLES
	LR	R0,R2
	SRHLS	R0,2			:REBUILD TIMEOUTS
	RBT	R0,CRQBSY,,		:CIRCUIT NO LONGER IN USE

	IF	REBILD
	RBT	R0,SQFIXV,,		:CLEAR REBUILD-QUADS-RECEIVED ARRAY 
	EI	:REBILD

	RBT	R0,CRQEND,,		:CIRCUIT NO LONGER AN ENDPOINT
	RBT	R0,REBTMO,,
	RBT	R0,REBTMI,,

	IF	REBILD
	RBT	R0,SQFTMO,,		:NO REBUILD			###GT
	RBT	R0,SQFTMI,,
	NHI	R2,-4
	AI	R2,HBUFN
	JAL	R8,CBCLR,,
	LIS	R0,0
	ST	R0,HSEQN,R2,
	ST	R0,RINVC,R2,
	STH	R0,RNFLAG,R2,
	STH	R0,RHOSTN,R2,
	STH	R0,RBASE,R2,
	STH	R0,RHBSZ,R2,
	EI	:REBILD

	LHL	R2,RFCSAV
	LR	R8,R1
	JR	R8

OP8863	CRASH.(.RFCR0)

	SUBTTL	BUFF (Copy message into a buffer)

::*********************************************************************
::
::	SUBROUTINE:	BUFCAN:
::	FUNCTION:	Copy a canned message (address in R4) into a buffer
::		(index in R2).  First byte of message must be byte count.
::	CALLING SEQ:	JAL	R9,BUFCAN
::	INPUT:		R2 = BUFFER INDEX
::			R4 = ADDRESS
::	DESTROYED:	R1, R4, R5, R8
::	CALLS:		JAL	R8,WCI
::
::*********************************************************************

BUFCAN	HS	0
	ST	R5,BURSAV		:Save reg 5 (CHN)
	LB	R1,0,R4			:GET LENGTH
	JER	R9			:ZERO COUNT, RETURN
	LIS	R5,1			:COMPUTE NEG. INDEX
	SR	R5,R1
	AR	R4,R1			:COMPUTE END OF STRING

BUFCA1	HS	0			:LOOP
	LB	R1,0,R4,R5		:GET DATA BYTE
	JAL	R8,WCI			:WRITE IT INTO BUFFER
	AIS	R5,1			:NEXT BYTE
	JLEBS	BUFCA1			:CONTINUE
	L	R5,BURSAV		:Restore reg 5 (CHN)
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	MERGE:/PREFIX:/MOVE:
::	ENTRY POINTS:
::		MERGE:	USED DURING REBUILD PROCESS.
::		ANY USER BYTES THAT MAY HAVE ACCUMMULATED IN THE OUTBOUND
::		BUFFER (NOW CONNECTED TO A 'STUB') ARE COPIED OVER BYTE
::		BY BYTE INTO THE CORRESPONDING HISTORY BUFFER, BEHIND THE
::		HISTORY DATA ITSELF. THEN THE H-BUFFER DESCRIPTOR (BB,
::		BE, BF, BCT, SEQN) IS COPIED INTO THE S-BUFFER DESCRIPTOR,
::		AND IS ITSELF CLEARED.	THE RESULT IS AN EMPTY HISTORY
::		BUFFER AND AN OUTPUT BUFFER CONTAINING HISTORY DATA FOLOWED
::		BY SUBSEQUENT USER DATA.
::		IN THE EVENT THAT THE OUTPUT BUFFER CONTAINS A GOBBLER,
::		THE HISTORY BUFFER IS SIMPLY CLEARED.
::		R6 = OUTBOUND BUFF #
::		R7 = HISTORY BUFF (COMPUTED FROM R6)
::		PREFIX:
::		CONTENTS OF BUFFER IN R7 TO THE CONTENTS OF BUFFER IN R6.
::		SOURCE BUFFER IS CLEARED.
::		R6 = DESTINATION
::		R7 = SOURCE (CLEARED)
::		MOVE:
::		MOVES ALL DATA IN BUFFER GIVEN IN R7 TO BUFFER GIVEN IN R6.
::		R6 = DESTINATION
::		R7 = SOURCE
::
::*********************************************************************

	IF	REBILD

MERGE	LR	R7,R6			:COMPUTE HB #
	SRHLS	R7,1
	NHI	R7,-4
	AI	R7,HBUFN
	LHL	R1,BCT,R7,
	JER	R9			:HISTORY BUFFER IS EMPTY
	LR	R2,R6			:IF GOBBLER IN OB, CLEAR HB
	L	R3,BB,R2,
	JN	MERGE1			:TEST FOR GOBBLER IN OB
     IF  REBTST
MERGE2	LHI     R0,SPLCSZ               :if both large BCT then use SPLICE
        CLH     R0,BCT,R6,
        JGFS    MERGE4
        CLH     R0,BCT,R7,              :APPEND is ok if one of buff is smalle
        JGFS    MERGE4
        ST      R9,TRCSV1
        JAL     R9,SPLICE
        L       R9,TRCSV1
        JFS     MERGE3                  :SPLICEd to save our CPU from working
      ELSE      :remember to define merge2
MERGE2  HS      0                       :The same as MERGE4
      EI  :REBTST
MERGE4	ST	R9,TRCSV1		:SAVE LINK
	JAL	R9,APPEND		:EMPTY DATA IN OB AND WRITE IT INTO HB
	L	R9,TRCSV1
MERGE3	LR	R2,R6			:NOW CLEAR OB
	JAL	R8,CBCLR,,
	LIS	R0,0
	L	R1,BB,R7,		:MOVE EVERYTHING FROM HB TO OB
	ST	R1,BB,R6,
	ST	R0,BB,R7,
	L	R1,BE,R7,
	ST	R1,BE,R6,
	ST	R0,BE,R7,
	LHL	R1,BF,R7,
	STH	R1,BF,R6,
	STH	R0,BF,R7,
	LHL	R1,BCT,R7,
	STH	R1,BCT,R6,
	STH	R0,BCT,R7,
        IF      REBTST           :correct bug of history in use number
        AIS     R1,CBSZ-3       :BCT to a mult of 14d (HW pointer, 1st char)
        CLI     R6,HBUFN        :dest history buffer?
        JLFS    MERG8           :nope
        AM      R1,HBFTSV       :bump up its in use
        JGEFS   MERG8           :in use still ok
        JAL     R7,NEGHCR,,     :went negative
MERG8   CLI     R7,HBUFN        :one losing the chars a hist buff?
        JLFS    MERG9           :nope
        SR      R0,R1           :get a count to reduce the number
        AM      R0,HBFTSV       :little bit smaller
        JGEFS   MERG9
        JAL     R7,NEGHCR,,     :history went negative
MERG9   LIS     R0,0            :restore reg.
        EI      :REBTST
	L	R1,SEQN,R7,
	ST	R1,SEQN,R6,
	JR	R9

MERGE1	JAL	R8,PCI,,		:IF A GOBBLER IN OB, CLEAR HB...###OAS
	CLHI	R1,3
	JN	MERGE2
	JAL	R8,PCI,,		:###OAS
	CLHI	R1,GOBBL&0FF
	JN	MERGE2
	LR	R2,R7			:CLEAR HB (CONTENTS IRRELEVANT)
	JAL	R8,CBCLR,,
	L	R1,SEQN,R6,		:MAINTAIN INTEGRITY OF SEQUENCE
	ST	R1,SEQN,R7,
	JR	R9

PREFIX	EQ	MERGE4
MOVE	EQ	MERGE3

	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	TRUNC:
::	FUNCTION:	REMOVES CHARS FROM BUFFER UNTIL 'BE'=CONTENTS OF R3.
::	CALLING SEQ:	JAL	R9,TRUNC
::	INPUT:		R2 = BUFF #
::			R3 = FULL WORD PTR TO CHARACTER
::
::*********************************************************************

TRUNC	HS	0
	LR	R6,R3
TRUNC1	LHL	R0,BCT,R2,		:BUFF EMPTY
	JER	R9
	JAL	R8,GCI,,		:REMOVE A CHAR
	CL	R6,BB,R2,
	JNBS	TRUNC1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	APPEND:
::	FUNCTION:	DOES A BYTE-BY-BYTE COPY OF SOURCE (R6) BUFFER
::		INTO DESTINATION (R7) BUFFER, LEAVING THE SOURCE BUFFER EMPTY
::	CALLING SEQ:	JAL	R9,APPEND
::	INPUT:		R6 = SOURCE
::			R7 = DESTINATION
::
::*********************************************************************

        IF 1-REBTST

APPEND	HS	0
	LHL	R0,BCT,R6,		:SOURCE EMPTY?
	JER	R9			:YES, EXIT

	LR	R2,R6
	JAL	R8,GCI
	LR	R2,R7
	JAL	R8,WCI
	JBS	APPEND

     ELSE  :otherwise use smart efficient append code

APPEND	HS	0
	LHL	R0,BCT,R6,		:SOURCE EMPTY?
	JER	R9			:YES, EXIT
        LHL     R1,BCT,R7,              :any in destination?
        JE      APPEN6                  :no, just move buffers as a group
        SRLS    R1,2                    :divide dest BCT by 4
        CR      R0,R1                   :if dest much smaller than source?
        JLFS    APPEN3                  :if yes then empty from the smaller

APPEN2	LR	R2,R6                   :here's the old and normal append logic
	JAL	R8,GCI
	LR	R2,R7
	JAL	R8,WCI
        LHL     R0,BCT,R6,              :source empty?
        JGBS    APPEN2                  :nope do it again
        JR      R9                      :done and exit

APPEN3  LR      R2,R7                   :dest
        JAL     R8,GCD                  :get from other end of buff
        LR      R2,R6                   :source
        JAL     R8,WCD                  :write to other end of buff
        LHL     R0,BCT,R7,              :buff empty?
        JGBS    APPEN3                  :nope, loop
                                        :nice little fallthrough
APPEN6  L       R0,BB,R6,               :move buflets from source to dest
        ST      R0,BB,R7,               :and we know dest was empty
        L       R0,BE,R6,
        ST      R0,BE,R7,               :BB, BE, and will do BCT
        LH      R0,BF,R6,               :and mark buffer as empty
        RBT     R0,NFLAGS,,
        LH      R0,BF,R7,
        SBT     R0,NFLAGS,,             :and other now has data
                                        :and get BCT to fix history in use
        LHL     R0,BCT,R6,
        STH     R0,BCT,R7,              :all dest pointers ok
        AIS     R0,CBSZ-3               :2 for pointer and 1 for first char

SPLIC9  HS      0                       :standard HBUF in use and clear source
                                        :section of code
     IF REBILD
        CLI     R7,HBUFN                :dest a hist buff?
        JLFS    APPEN7                  :nope, normal buff
        AM      R0,HBFTSV               :yes, more history bytes in use
APPEN7  CLHI    R6,HBFTSV               :source a hist buff?
        JLFS    APPEN8                  :nope
        LIS     R1,0                    :we need to subtract
        SR      R1,R0                   :get a negative BCT
        AM      R1,HBFTSV               :reduce count in use
        JGEFS   APPEN8                  :make sure didn't go negative
        JAL     R7,NEGHCR,,             :crash if went neg
     EI  :REBILD
APPEN8  LIS     R0,0                    :clear out source
        STH     R0,BCT,R6,
        ST      R0,BB,R6,
        ST      R0,BE,R6,
        JR      R9                      :DONE
      EI        :new buffer stuff

::*********************************************************************
::
::	SUBROUTINE:  SPLICE:
::	FUNCTION:  A special rebuild routine that is used when there are a ton
::         a chars that need to be appended to another buffer.  Instead of
::         GCI and WCI every char SPLICE escapes data chars until the buffers
::         line up on even bufflet boundaries and then chains the bufflets.
::         NOTE: escaping of data does add a bit of a load to other nodes but
::               that is better than spending >.1 sec of CPU time on this node.
::
::*********************************************************************

        IF      REBTST
SPLICE  LR      R2,R6           :buff pointer in R6 gets added to buff of R7
        L       R4,BE,R7,       :fill up to last bufflet for dest
SPLIC1  LHL     R0,BCT,R2,      :should'nt happen (was supposed to be big buff)
        JEFS    SPLIC8          :could have big buff full of char pairs though
        AIS     R4,1            :fill upto end
        THI     R4,CBSZ-1       :at end of bflet
        JEFS    SPLIC0          :evened up dest buflet
        JAL     R8,GCI          :get char from source
        STB     R1,0,R4         :and put the char
        JBS     SPLIC1          :loop until filled up BFLET

SPLIC8  ST      R4,BE,R7,
        JR      R9              :no more to move so then done

SPLIC0  CLHI    R1,3            :don't want to split char pairs
        JGFS    SPLIC2          :no worries
        SIS     R4,1            :damn pair, make R4 to last char
        ST      R4,BE,R7,       :BE is set up for WCi
        LR      R2,R7           :trick idea is to simply write char and start
        JAL     R8,WCI          :SPLICEing all over again on next BUFlet
        J       SPLICE          :easiest way to handle rare case
SPLIC2  ST      R4,BE,R7,       :note BE points to pointer and not a char
        L       R4,BB,R6,       :now start escaping the data
        LR      R3,R4           :make copy
        NHI     R4,-CBSZ        :make R4 to start of BFlet
        AIS     R4,2            :where to start putting the data
        ST      R4,BB,R6,       :save what is going to be new BB
SPLIC3  CR      R4,R3           :done if equal
        JE      SPLIC5
        C       R3,BE,R6,       :make sure not at end
        JE      SPLIC5
        JAL     R8,PCI          :get a char to esc and +1 to R3
        CLHI    R1,7            :don't escape signals
        JLEFS   SPLIC4          :otherwise signals become data
        EXBR    R1,R1           :get a zero (escape the data)
        JAL     R8,PWCI         :write char and +1 to R4
        EXBR    R1,R1           :get back the char
        JAL     R8,PWCI         :+1 to R4
        J       SPLIC3          :note this loop added 2 to R4 and 1 to R3
SPLIC4  JAL     R8,PWCI         :put the char at new position
        CLHI    R1,4
        JGE     SPLIC3          :not a char pair signal
        JAL     R8,PCI
        JAL     R8,PWCI         :do second char of pair
        J       SPLIC3

SPLIC5  L       R3,BB,R6,               :chain the buflets now
        SI      R3,CHRBUF               :make start of source to BF pointer
        SRLS    R3,4                    :now pointer
        L       R4,BE,R7,               :get address to put pointer
        STH     R3,0,R4                 :have chain
        L       R4,BE,R6,
        ST      R4,BE,R7,               :and end of source is now end of data
        LHL     R0,BCT,R6,              :and fix up char count
        AIS     R0,CBSZ-3               :2 bytes for pointer 1 byte for 1st char
        AHM     R0,BCT,R7,              :add in chars of chained
        J       SPLIC9                  :and do buff in use logic

::******************************************************
:  PWCI is sort of like PCI except it writes char in R1 at R4, moves
:       R4 to next spot but does not touch BB, BE or BCT.  It assumes
:       that caller knows where writing to (by R4) and caller will not
:       try writing after BE (not checked because don't ask for R2).
::********************************************************

PWCI    STB     R1,0,R4                 :store it
        AIS     R4,1
        THI     R4,CBSZ-1               :at pointer now?
        JNR     R8                      :nope so den done
        LHL     R4,0,R4                 :get next buffer number
        SLLS    R4,4                    :relative address
        AI      R4,CHRBUF               :real address
        JR      R8                      :R4 setup for next char
        ei  :REBTST


::*****************************************************
: GCD   gets char from other end of buffer.  the end which WCI writes to.
:       links on R8
:       input:  R2 is buffer number
:       trashes: R0 and R3 (normal buffer trashed regs).

GCD     L       R3,BE,R2,               :end of buffer
        JNFS    GCD1                    :not empty
        JAL     R0,OOPS,,
        JR      R8
GCD1    LB      R1,0,R3                 :get the char
        CL      R3,BB,R2,               :last char?
        JE      GCLAST                  :BE=BB so empty and use existing
        SIS     R3,1                    :back up BE
        ST      R3,BE,R2,               :save it
        THI     R3,CBSZ-2               :if BFlet empty then nibble =1 so
        JNR     R8                      :bflet still has data

:cute little fall through.  must return bufferlet but all we have is
:last entry of linked buffer list.  so must go to start and look for
:the link that points to our current position.

GCDRET  AIS     R3,0F                   :move it up to the pointer
        LHL     R0,FREELT               :insert our buffer to start of free
        STH     R0,0,R3                 :link all free to our buflet
        SI      R3,CHRBUF               :make r3 a buf number
        SRLS    R3,CBSZL                :now it is buf number
        STH     R3,FREELT               :put it on free list
        LR      R0,R3                   :use R0 so R3 can be used for index
        L       R3,BB,R2,               :get start of list
        AIS     R3,CBSZ-2               :get pointer location
        NHI     R3,-CBSZ                :got it (it sits on quad word bound)
GCD2    CLH     R0,0,R3                 :R0 is buffer just emptied
        JEFS    GCD3                    :found link
        LHL     R3,0,R3                 :get next pointer
        SLLS    R3,CBSZL                :make into address
        AI      R3,CHRBUF+CBSZ-2        :now is address of the next pointer
        JBS     GCD2                    :loop until find link

GCD3    SIS     R3,1                    :adjust to end of bflet
        ST      R3,BE,R2,               :save new end
        LCS     R0,CBSZ-2
        AHM     R0,BCT,R2,              :knock down BCT
        AM      R0,BFLTSV               :knock bytes in use
     IF REBILD
        JGEFS   GCD4                    :count still ok
     ELSE
        JGER    R8                      :not rebuild have nothing else to do
     EI
        JAL     R7,NEGBCR,,             :crash if not negative
      IF REBILD
GCD4    CLI     R2,HBUFN                :history buffer?
        JLR     R8                      :done
        AM      R0,HBFTSV
        JGER    R8                      :done
        JAL     R7,NEGHCR,,             :crash r7 being location
      EI



::*********************************************************************
::
::	SUBROUTINE:	PURGE:
::	FUNCTION:	REMOVES CHARACTERS FROM SOURCE BUFFER UNTIL CHAR
::		BEARING A GIVEN SEQ # IS AT FRONT OF BUFFER.
::	CALLING SEQ:	JAL	R9,PURGE
::	INPUT:		R2 = BUFF #
::			R4 = SEQN OF FIRST CHAR IN BUFFER
::			R5 = SEQN OF FIRST CHAR AFTER PURGE
::	RETURNS:	TAKES IMMED RETURN IF DATA HAS BEEN LOST.
::			ELSE +4 RETURN
::
::*********************************************************************

	IF	REBILD

PURGE	HS	0
	SR	R4,R5			:FORM -(NUMBER OF EXCESS CHARACTERS)
	JE	4,R9			:NO EXCESS CHARACTERS, DO SKIP RETURN
	JGR	R9			:DESIRED DATA NOT IN H-BUFFER
					: - DATA LOST!
PURG1	LHL	R0,BCT,R2,		:DATA IN BUFFER?
	JER	R9			:NO - LOST DATA, DO NON-SKIP RETURN
      IF  REBTST        :more efficient method of returning chars
        LIS     R0,0                    :r0 is going to be how many to purge
        SR      R0,R4                   :how many to purge
        LR      R4,R0                   :save a copy for ourselves
        JAL     R8,RTBFTS               :return chars
        CR      R0,R4                   :r0 is how many actually purged
        JNR     R9                      :not able to return requested #
        ST      R5,SEQN,R2,             :bump number purged
        J       4,R9                    :routine by ###sdw
      ELSE  :old code
	JAL	R8,GCI			:TOSS DATA
	AIS	R4,1
	JLBS	PURG1
	ST	R5,SEQN,R2,		:AOK				###GT
	J	4,R9
      EI  :REBTST

	EI	:REBILD

	ENDMO.(BUFF)
	EI	:1-KILLIT
	KILMSG(BUFF)

:	***NOTHING PAST THIS POINT***

	SUBTTL	LOGSUP

:			*      ***   ***   ***  *   * ****
:			*     *   * *     *     *   * *   *
:			*     *   * *  **  ***  *   * ****
:			*     *   * *   *     * *   * *
:			*****  ***   ***  ****   ***  *

::#####################################################################
::
::	MODULE:		LOGSUP
::
::	SUBTTLS:	LOGGER - Process data to sup in login mode
::			SUP message generators
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA  0
	SEG  1

::*********************************************************************
::
::	SUBPROCESS:	LOGGER:
::	FUNCTION:	Process ports in login mode.
::	SCHEDULED:	Runs off SWITCH exec loop, based on presence of
::			data in LOGBUF.
::		LOGGER processes data from ports in login mode (ISIS or 
::		Solo CONSAT) toward the supervisor.  It does not use the 
::		usual attention-flag scheme to detect which login buffers
::		have data ready to go.  This is because login data is not
::		necessarily "ready to go" simply because it is available
::		in a buffer.  Instead, the process which fills the login
::		buffer monitors the input for 1) a login-string terminator
::		(semi-:or CR), 2) an escape, or 3) overflow (a login-string
::		may not be longer than 55d bytes).  When one of these is
::		detected, the filling process marks the buffer ready for
::		LOGGER service by writing the login-buffer's index into
::		LOGBUF (as an escaped HW).  LOGGER's attention gets flagged
::		by the presence of something in LOGBUF.  For related reasons,
::		a login-buffer's BF is never a channel number in the regular
::		sense.  Instead, it is a value between 10 (LOGMIN) and 17
::		(LOGMAX).  This value defines the current state of the login-
::		buffer, as follows:
::			10-bit :port is in login mode.
::			01-bit :(LG.TID) TID is in the login buffer (i.e.,
::				 hasn't been sent to the supe yet.
::			02-bit :(LOGNDC) node code is ready to transmit 
::				 login data.
::			04-bit :(LOGSUP) supe is ready to accept login data.
::
::*********************************************************************

IIXLOG	EQ	1	:bit of IOTAB entry set for IIX circuit request	###jhl
LGCHMX	EQ	$A 48	:Maximum characters allowed for login
:	Start out by appending a marker (0 HW) to the contents of LOGBUF.
:	We will cycle thru LOGBUF looking for login-buffer numbers.
:	We will service each buffer once, and when we get to the marker 
:	we'll know that we're through.
LOGGER	HS	0

	IF	MPCCHK				:###LSH
	L	R1,FASTC,,
	ST	R1,LGERB
	LIS	R1,0
	STH	R1,LGERF
	EI	:MPCCHK

	LIS	R2,0			:PUT A MARKER IN THE LOGGER LIST

:	Write marker to LOGBUF (first pass) or return buffer just serviced
:	to LOGBUF (if it still needs LOGGER service).  Jumping to here from
:	below has the effect of returning the current buffer to the LOGGER
:	list before going on to the next login-buffer.
LOG1	HS	0
	LR	R1,R2			:RETURN CURRENT PORT TO LOGGER LIST
	LIS	2,LOGBUF
	JAL	R9,WHWI0
	GL	WHWI0
	IF 	NEWALI
	JFS	LOG0
	EI	:NEWALI
LOG2	HS	0			:COME HERE TO RETURN BUFFER PAIR
	IF	NEWALI
	LIS	R0,0
	STH	R0,BF,R2,
	JAL	R8,RFCBUF		:RETURN BUFFER TO FREE LIST
	EI	:NEWALI

:	Get the next buffer index from LOGBUF. If its our 0-marker,
:	RETURN via LOGXIT. Otherwise, check its BF to make sure its a valid
:	login-buffer (LOGMIN<=BF<=logmax).  If it is, skip to LOG7.
:	Jumping here from below has the effect of removing the current buffer
:	from the LOGGER list.
LOG0	HS	0
	LIS	R2,LOGBUF		:PROCESS NEXT PORT
	JAL	R9,GHWI0
	GL	GHWI0
	LR	R2,R1			:THIS IS THE BUFFER W/ CHARS FOR SUP
	JE	LOGXIT			:MARKER, WE'RE DONE

	LHL	R1,BF,R2,		:INSURE WE'RE REALLY IN LOGIN
	CLHI	R1,LOGMIN		:TEST FOR VALID LOG IN MODE
	JLFS	LOG8
	CLHI	R1,LOGMAX
	JLE	LOG7			:YES WE ARE IN LOGIN MODE
:	INVALID LOGGER BF. REPORT TO XRAY AND REMOVE OFFENDING BUFFER
:	NUMBER FROM THE LOGGER LIST.
:	Found an invalid BF (not in login mode) for a buffer in LOGBUF.
:	Report to crypto (CRYE23) and go on to the next entry (LOG0) without
:	putting this buffer back into LOGBUF.
LOG8	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	ST	R1,RGST,,
	LIS	R1,0			:CASE # 0
	JAL	R4,LGGDB2,,
	GL	LGGDB2
	L	R4,REGST,,
	L	R1,RGST,,
	EI	:LPGDBG

	EXHR	R0,R2			:###TZ
	OR	R0,R1			:###TZ
	JAL	R8,CRYPTO,,		:REPORT WITH BAD BUFFER INDEX, BF IN R0
	HC	CRYE23
	J	LOG0			:JUMPING TO LOG0 HAS THE EFFECT OF
					:REMOVING BUFFER # FROM LOGGER LIST.
:	Found a login-buffer with a valid BF.  Check to see if we have a sup
:	circuit and if we have not had a recent takeover.  If both are ture,
:	continue.  Else, go zap the login circuit (LOGZAP).  We can't
:	process logins if there is no sup, and we can't continue to process
:	logins if there a possibility that a new supe is taking us over.
LOG7	HS	0
	LHL	R0,TVRBUF		:IS THERE A SUP?
	JE	LOGZAP			:NO, ZAP CIRCUIT
	LHL	R0,LOGZPF		:HAS THERE BEEN A TAKEOVER?
	JN	LOGZAP			:YES, ZAP CIRCUIT

:	If the INFinite-LoGin-Timer flag is not set, we have to see if the
:	login-circuit has timed out.  If the TID has already been sent to the
:	sup, we let the sup handle the timeout (skip to LOG9).  Otherwise,
:	we check for timeout by seeing if we've passed the SLOWC time that was
:	saved in BUFTIM when the login was initiated (timeout is 120d seconds).
	IF	1-INFLGT
	LHL	R1,BF,R2,		:GET BUFFER FLAG
	THI	R1,LG.TID		:TID IN BUFFER ?
	JE	LOG9			:NO, SUP WILL TIME THIS ONE OUT

	SRLS	R2,1			:COMPUTE BUFTIM INDEX
	NHI	R2,-4
	L	R0,BUFTIM,R2,		:HAS THIS CIRCUIT TIMED OUT?
	SLLS	R2,1			:RESTORE BUFFER #
	S	R0,SLOWC,,		:(BUFTIM HAD START TIME + 120d)
	JG	LOG9			:NOT YET

:	HAVE DISPI (IN) SEND:
:		SUPER HANG (ISIS B8) (FOR HDX TERMINALS)
:		TEXT "PLEASE SEE YOUR REPRE..."
:		HANG (ISIS AF)  (NORMAL HANG)
:	Login-circuit timed out.  Send "please see your Rep"
:	(with HANG and HDX-HANG) to port.  Then go service the next
:	login-buffer (LOG0) without putting this one back in the LOGGER list
:	(LOGBUF).

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	ST	R1,RGST,,
	LIS	R1,2			:CASE # 2
	JAL	R4,LGGDB2,,
	L	R4,REGST,,
	L	R1,RGST,,
	EI	:LPGDBG

	XHI	R2,4			:OTHER BUFFER

	IF	T2GATE
	LHL	R5,BF,R2,
	SHI	R5,DISZFL		:Get dispatcher port
	LA	R1,PSRMSG
	JAL	R8,DIMMES		:Output "pls see your rep.."
	TBT	R5,GTTRNS
	JN	GLOG7
	LA	R1,GNGONE,,
	JAL	R8,DIMMES
	DROUTE(ISISN,HOMEN)		:If non-transparent send
	LA	R1,CRLF			:"inter-link cleared .."
	JAL	R8,DIMMES
GLOG7	LHI	R1,09E00		:In either case zap circuit
	JAL	R8,DIRMES
	LIS	R1,0			:and let dispatcher Zapper ack
	XHI	R2,4			:return logon circuitry
	STH	R1,BF,R2,		:Set bf to Zero for RFCBUF
	SBT	CHN,DISZNK		:And set up for Zapv to clean up

	ELSE	:NOT T2GATE

:	changes begin here			###LSH
:	change MPVC sub-port timeout logic to fix ASYNC ring wrapped
:	problem. send 0301 instead of "0312,12 please see your
:	representative, if you are having trouble loging in. 0312,11"
:	when timeout an MPVC sub-port.		###LSH
	IF	SOLOCS			:SOLO CONSAT ONLY
	IF	NMPVC			:MPVC CONFIGURATION ONLY
	LHL	R1,BF,R2,		:GET ABS. ANI CHN (R2=.ALBUF+4)
	SHI	R1,ANIZFL		:GET REL. ANI CHN
	JL	LOGERR			:MAKE SURE IT IS ANI CHN
	CLHI	R1,NANIPT
	JGE	LOGERR
	GL	SUBSTB
	TBT	R1,SUBSTB,,		:MPVC SUB-PORT AWAIT TIMEOUT ??
	JE	LOGERR			:NO,  TIMEOUT A REGULAR PORT
:	timeout an MPVC sub-port
	LHI	R1,ZAPPH		:YES, TIMEOUT AN MPVC SUB-PORT
	EXBR	R1,R1
	JAL	R8,WCI,,		:WRITE 0301 INTO .ALBUF+4
	EXBR	R1,R1
	JAL	R8,WCI,,
	IF	MPCCHK			:MPVC SUB-PORT TIME CHECKING###LSH
	TS	LGERF
	EI	:MPCCHK
	J	LOG0			:REMOVE THIS BUFFER FROM LIST
LOGERR	HS	0
	EI	:NMPVC
	EI	:SOLOCS
:	changes end here 			###LSH

:	timeout a regular port (non-MPVC port)
	LA	R4,PSRMSG		:ADDRESS OF Please See your...(W/HANGS)
	GL	PSRMSG
	JAL	R9,BUFCAN		:OUTPUT MESSAGE TO BUFFER
	GL	BUFCAN
	EI	:T2GATE

	J	LOG0			:REMOVE THIS BUFFER FROM LIST
	EI	:1-INFLGT

:	Here for login-buffer that has not timed out.
:	If the supe and node code bits are both set in the buffer's BF,
:	we continue.  Otherwise, we go on to the next buffer (LOG1) and
:	return this buffer to the LOGGER list.
LOG9	HS	0
	LHL	R1,BF,R2,		:ARE WE IN XMIT MODE (SUP & NC)
	NHI	R1,@LG.TID		:(TID DOESN'T COUNT)
	IF	T2GATE
	CLHI	R1,LOGMIN+LOGSUP	:CMP WITH 14H
	ELSE
	CLHI	R1,LOGXMT
	EI	:T2GATE
	JN	LOG1			:NO, BACK TO THE LIST

:	Here for buffer with BF set ready to transmit.
:	If there is data in the buffer, continue.  Otherwise,
:	go on to next buffer (LOG1).
	LHL	R1,BCT,R2,
	JGFS	LOG10			:MORE IN BUFER, GO GET

	IF	NEWALI
	XHI	R2,4			:LOGIN OUTPUT BUFFER
	LHL	R1,BF,R2,		:IT'S FLAG
	LHL	R1,IOTAB,R1,R1		:P-TABLE ENTRY
	JE	LOG2			:NO LONGER CONNECTED, RETURN BUFFER
	XHI	R2,4			:FLIP BACK
	EI	:NEWALI
	J	LOG1			:RETURN TO LOGGER LIST

LOG10	HS	0			:Found a login-buffer with data in it.
	IF	T2GATE
	L	R3,BB,R2,		:INIT PCI
	XHI	R2,4			:BUF TO TERM, TO GET CHN
	LHL	CHN,BF,R2,		:Get to-terminal channel
	SHI	CHN,DISZFL		:Make to relative dispatcher port
	XHI	R2,4			:FROM TERM FOR PCI
	TBT	CHN,GMSG0F		:0F MSG ALREADY SENT?
	JE	LOG60		  	:YES
	JAL	R8,PCI			:
	STB	R1,GDSAVE
	JAL	R8,PCI
	STB	R1,GDSAVE+1		:FIRST TWO BYTE ARE ORG. HST#
	LHL	R1,GDSAVE		:SAFTY CHECK FOR CORRECT HST#
	CLI	R1,HHOST+8000
	JN	LOGZAP
	SIS	R3,2
LOG60	LB	R0,GLGCNT,CHN,		:Get previous count (should init. at 3)
	JAL	R8,CBCCT		:CHECK CHAR CT. in buffer now
	STB	R1,GLGCNT,CHN,		:STORE NEW CT
        LR      R9,R0                   :how many chars (total) scanned
	LR	R4,R1			:New count into work reg
	SR	R4,R0			:DIFF. IN R4
	JLE	LOG1			:NO NEW CHAR
	LR	R0,R0
	JE	LG10LP			:If buffer had been empty, go from BB
LOG105	JAL	R8,NCI			:INC R3 PTR ONLY,NO PEEK
	SIS	R0,1			:DEC OLD CT 	
	JGBS	LOG105
LG10LP	JAL	R8,PCI			:PEAK EACH CHAR. & ANALIZE
        CLHI    R1,07                   :escaped char? ##sdw
        JG      LG11LP                  :yes
        LR      R1,R1                   :escaped char?
        JEFS    LG11LQ
        SIS     R1,03                   :IS a ZAPPER in The buffer
	JN	LOG41                   :not a zapper sig
        AIS     R9,1                    :one closer to the end
        SIS     R4,1                    :another one peeked
	JAL	R8,PCI
	CLHI	R1,03
	JLE	LOG42			:..IF SO , SEND DIRECTLY TO SUP
        J       LOG41                   :let the nonzapper just sit
LG11LQ  JAL     R8,PCI                  :read escaped byte
        AIS     R9,1                    :one closer to too many
        SIS     R4,1                    :reduce unread count by one
LG11LP	OHI	R1,80			:HO-BIT SET FOR CHAR
	XHI	R2,4			:TO TERM. BUF#
	CLHI	R1,88			:Is char. ctl-H?
	JNFS	LOG61			:No
	RBT	CHN,GTECHO		:Turn off echo for this guy
	SBT	CHN,GTHDX		:Make sure were thinging HDX
LOG61	CLHI	R1,09F			:Is char. printable?
	JLEFS	LOG62			:No
	TBT	CHN,GTLGEC		:Should this be echoed?
	JEFS	LOG62			:No
	TBT	CHN,GTECHO		:Echo for this term. type?
	JEFS	LOG62			:No
	LR	R10,R3
	JAL	R8,WCI			:Echo back to term.
	LR	R3,R10
LOG62	XHI	R2,4			:FROM TERM. BUF#
	CLHI	R1,9B			:ESC KEY?
	JE	LGBAD			:YES, HANDLE ESCAPE
	CHI	R1,8D			:= 'CR' ?
	JE	LOG42			:YES, SET NODE CODE TO OK
	CHI	R1,0BB			: IF IT IS SEMI-:
	JNFS	LOG41
	RBT	CHN,GTLGEC		: NO ECHO AFTER SEMI-:
	J	LOG42
LOG41   AIS     R9,1                    :one closer to too many
        CLHI    R9,LGCHMX               :made it to too many?
        JG      LGCHA                   :jump more than 48 log chars
	SIS	R4,1			:EMPTY BUFFER YET ?
	JG	LG10LP			:No .. get more characters
	J	LOG1			:and go to next port
:	SET BF TO 'NODE CODE = YES' IF CHARACTER IS CR OR SEMI-:
LOG42	HS	0
	LHL	R8,BF,R2,		:GET BF
	OHI	R8,LOGNDC		:SET 'NODE CODE = OK' BIT
	STH	R8,BF,R2,
	J	LOG101			:GO TO COPY TO SUP BUF

:	MORE THEN 48 CHAR.S ENTRY
LGCHA 	HS	0
	LIS	R1,0			:SET TO 0 FOR NO ESC CHAR
:	ESCAPE KEY HANDLER
LGBAD	LIS	R0,0			:COMMON ENTRY POINT FOR ESCAPE
					: & BUFFER FULL
	ST	R0,DSOLGH,,		:CLEAR TEMPORARY SAVE AREA
	GL	DSOLGH
	STB	R1,DSOLGH+3,,		:STORE R1 (EITHER ESCAPE CHAR OR 0)
	LIS	R0,0F
	TBT	R0,BF,R2,		:IS TID IN THE BUFFER?
	JEFS	LGBA1			:NO
	JAL	R9,GHWI			:YES, GET HOST NUMBER
	STH	R1,DSOLGH,,		:AND SAVE IT
	JAL	R8,GCI			:ALSO GET TID
	OHI	R1,80			:HO-BIT SET FOR CHAR
	STB	R1,DSOLGH+2,,		:SAVE IT ALSO
LGBA1   LB	R1,DSOLGH+3,,		:ESCAPE OR BUFFER FULL?
	JE	LGFLL			:BUFFER FULL, GO CLEAR IT

LGES2   LHL	R0,BCT,R2,		:ESCAPE TYPED...ANYTHING IN BUFFER?
	JEFS	LGES1			:NO, BUFFER EMPTY
	JAL	R9,GCIE			:YES, GET A CHARACTER, ESCAPE STRIPPED
	GL	GCIE
	NHI	R1,7F			:STRIP OFF MSB
	CLHI	R1,01F			:CONTROL CHARACTER?
	JGBS	LGES2			:NO, GET ANOTHER CHARACTER
	SBT	R1,DSOSPC,,		:CONTROL CHARACTER, NOTE IT
	GL	DSOSPC
	JBS	LGES2			:AND KEEP EMPTYING BUFFER
LGES1   LHL	R1,DSOLGH,,		:GET HOST NUMBER
	JEFS	LGES6			:NO HOST NUMBER IN BUFFER
	JAL	R9,WHWI			:DEPOSIT HOST NUMBER
	GL	WHWI
	LB	R1,DSOLGH+2,,
	JAL	R8,WCI			:AND TID
LGES6	LHI	R4,01F			:SEND SUP ALL CONTROL CHARACTERS
LGES4   RBT	R4,DSOSPC,,		:WAS THIS ONE IN BUFFER?
	JEFS	LGES5			:NO
	LHI	R1,80,R4		:YES, APPEND 80-BIT...
	JAL	R9,WCIE			:AND, WRITE IT IN
	GL	WCIE
LGES5   SIS	R4,1
	JGEBS	LGES4			:LOOP OVER ALL CONTROL CHARACTERS
LGES3   LB	R1,DSOLGH+3,,		:GET THE ESCAPE CHAR
	JAL	R8,WCI			:AND WRITE IT IN
	LIS	R0,0E
	SBT	R0,BF,R2,		:SET NODE CODE TO GO AHEAD
	J	LOG101			:GO TO COPY TO SUP. BUF
::Too many login characters .... abort login
LGFLL	JAL	R8,CBCLR		:CLEAR BUFFER
	LIS	R0,0E
	SBT	R0,BF,R2,		:SET NODE CODE TO GO AHEAD
	XHI	R2,4
	LHL	CHN,BF,R2,
	SHI	CHN,DISZFL
	XHI	R2,4
	LHL	R1,DSOLGH,,		:IS HOST NUMBER IN BUFFER
	JE	LGF11			:GO TO COPY TO SUP. BUF
	JAL	R9,WHWI			:YES, REDEPOSIT IT
	LB	R1,DSOLGH+2,,		:AND ALSO THE TID
	JAL	R8,WCI
LGF11	LA	R1,TOMANY
	JAL	R8,DIMMES
	LA	R1,PSRMSG
	JAL	R8,DIMMES		:Output "pls see your rep.."
	TBT	R5,GTTRNS
	JN	GTMN7
	LA	R1,GNGONE,,
	JAL	R8,DIMMES
	DROUTE(ISISN,HOMEN)		:If non-transparent send
	LA	R1,CRLF			:"inter-link cleared .."
	JAL	R8,DIMMES
GTMN7	TBT	CHN,GMSG0F		:Has  TID etc. been sent to sup ?
	JE	GTMN8			:Yes .. continue processing login

	LHI	R1,09E00		:In this case, just Zap circuit
	JAL	R8,DIRMES
	LIS	R1,0			:and let dispatcher Zapper ack
	STH	R1,BF,R2,		:Set bf to Zero for RFCBUF
	SBT	CHN,DISZNK		:And set up for Zapv to clean up
	J	LOG0			:also ensure LOGCLR

GTMN8	LHI	R1,ZAPPH		:Abort login in progress 
	JAL	R9,W2CI			:WRITE ZAPPER TO BUFFER
					:and continue ... send Zapper to sup
	EI	:T2GATE

LOG101	LR	R6,R2			:MOVE CHARS TO THE LEP BUFFER
	LHL	R10,BF,R2,		:GET LOGIN STATUS (16 OR 17 HEX)

:	Get the login status from BF and convert to proper sup message type
:	(0E=login string continuation, 0F=TID+login string).  
:	Create a login string message in the sup buffer (TVRBUF)
:	get logon status from BF and convert to NEW or not depending on TID
:	in buffer or not.  Send a type 0C message in either case.
LOG11	HS	0
	IF	EXPNDL
	LHL	R2,TVRBUF		:init R2 to hold to-SUP buffer number
	LR	R7,R2			:R7 holds sup buffer while we work
	LHI	R1,MACHNM+8000		:MAKE SUP RECORD
	JAL	R9,WHWI			:node number to identify us
	LIS	R1,0C			:send a type 0C message
	JAL	R8,WCI

	IF	LPGDBG 			:DEBUGFGER		###LSH 
	L	R1,BE,R7,
	ST	R1,LPGSSV,,		:save ptr to use in cpying data
	EI	:LPGDBG

	THI	R10,LG.TID		:Is TID still in the buffer?
	JNFS	LGEN10			:branch if it is 
	LIS	R1,8			:sup ignores if not NEW
	JFS	LGEN15			:--won't escape this

:	the TID is sent from DSZTLG in the login buffer
LGEN10	LR	R2,R6			:get the login buffer into R2
	JAL	R9,GHWI			:first read out the requesting host #
	LR	R11,R1			:and save it in R11
	JAL	R8,GCI			:read in the TID
	OHI	R1,80			:set the NEW bit (hob set already?)
	LR	R2,R7			:get sup buffer into R2
LGEN15	JAL	R8,WCI			:write second byte of 0C msg into buff
	LR	R1,R6			:get the login buffer
	XHI	R1,4			:flip to slot-bound buffer
	LHL	R1,BF,R1,		:BF of +4 is port number to tell sup
	OHI	R1,8000			:set high order bit for sup
	JAL	R9,WHWI			:write in the port number
	LIS	R1,0			:prepare field for msg length
	JAL	R8,WCI			:lay an escaped byte of zero
	JAL	R8,WCI			:escape, then the place for count
	L	R1,BE,R2,		:save pointer to second byte
	ST	R1,SNCSV1,,		:fill it in when we know the length
:	Now for the SNI list--R10 has BF of login buffer
	LIS	LRC,0			:init SNI-length count
	THI	R10,LG.TID		:if NEW then send orig host SNI
	JEFS	LGEN18			:otherwise don't
	LHI	R1,SNIHST+SNTYP1	:send SNI: org hst/hw of host
	JAL	R8,WCI
	LR	R1,R11			:get requesting host from R11
	JAL	R9,WHWI			:fill in host field for org hst SNI
:	00-03 are escaped
	AIS	LRC,3			:update SNI-length count
:	test for UUN request and send SNI if appropriate
LGEN18	LR	R1,R6			:get the login buffer again
	XHI	R1,4			:turn in slot bound direction
	LHL	R1,BF,R1,		:BF of +4 is channel number
	IF	ISIS
	SHI	R1,DISZFL		:get rel offset into dispatcher array
	EI	:ISIS
	IF	SOLOCS			:this will get ridiculous	###jhl
	SHI	R1,ANIZFL
	EI	:SOLOCS
	RBT	R1,DISUUN		:test for send UUN request
	JEFS	LGEN20			:branch around if not set by DSZTLG
	LIS	R1,SNIUUN+SNTYP0
	JAL	R8,WCI			:write SNI asking for UUN
	AIS	LRC,1			:update the SNI-length count
:	test for IIX circuit and send SNI if appropriate
LGEN20	LR	R9,R6			:get login buffer
	XHI	R9,4			:flip to outbound buffer
	LHL	R9,BF,R9,		:BF of outbound is originating channel 
	LHL	R0,IOTAB,R9,R9		:permuter table entry for circuit orig
	THI	R0,IIXLOG		:SIQ circuit?
	JEFS	LGEN23			:no
	THI	R10,LG.TID		:check BF for TID still in buffer
	JEFS	LGEN23			:send only for NEW request
	LHI	R1,SNIIIX+SNTYP0	:write in the IIX SNI
	JAL	R8,WCI
	AIS	LRC,1			:update SNI-length
LGEN23	HS	0
:	Next put in the SNI for logon characters
	LHI	R1,SNILGC+SNTYP3
	JAL	R8,WCI			:write in the SNI header
	LIS	R1,0			:write in the count field
	JAL	R8,WCI			:escape it just to be safe
	JAL	R8,WCI			:hold the place with  zero
	L	R10,BE,R2,		:get pointer to count-cell for later
	AIS	LRC,2			:add in LOG CHR header
	STH	LRC,SNCTSV,,		:save for retrieval later
	LIS	LRC,0			:initialize counter of login string

:	now proceed from LOG3 to append login string
	ELSE	:not EXPNDL
	SHI	R10,08			:CONVERT TO MESSAGE TYPE (0E OR 0F HEX)
	LHL	R2,TVRBUF		:init R2 to hold to-SUP buffer number
	LR	R7,R2			:R7 holds sup buffer while we work
	LHI	R1,MACHNM+8000		:MAKE SUP RECORD
	JAL	R9,WHWI
	LR	R1,R10			:MESSAGE TYPE '0E' OR '0F'
	JAL	R8,WCI

	IF	LPGDBG 			:DEBUGFGER		###LSH 
	L	R1,BE,R7,
	ST	R1,LPGSSV,,		:save ptr to use in cpying data
	EI	:LPGDBG

	LIS	R1,0
	JAL	R8,WCI			:ASSUME CHAR COUNT NEEDS ESCAPING
	JAL	R8,WCI			:ESCAPED CHAR CNT WILL GO HERE IN BUFF
	L	R10,BE,R2,		:SAVE POINTER TO IT
	LR	R1,R6
	XHI	R1,4			:GET THE PORT #
	LHL	R1,BF,R1,
	OHI	R1,8000			:SET FOR SUP
	JAL	R9,WHWI
	GL	WHWI
	LHI	LRC,80			:NUMB OF CHARACTERS TO BE SENT.
:	80-bit means not SIQ circuit. May be reset below.
		
:	If the TID is still in the buffer, include the host number.
:	Else skip to LOG3.
	LIS	R2,0F			:LAST (TID) BIT IN HW
	TBT	R2,BF,R6,		:TID WAITING TO BE SENT ?
	JE	LOG3			:NO, SKIP HOST NUMBER
:	If we're sending the intial login string (msg type 0F),
:	we have to check for a smart (SIQ) circuit and inform the sup if so.
:	We know a circuit is SIQ if the LO bit of the orginating channel's
:	permuter table entry is set (i.e., the LO gouging bit).  We tell
:	the supe a circuit is SIQ by resetting the HO bit of the count field
:	(1 byte) in the type-0F message.
	IF	T2GATE
	RBT	CHN,GMSG0F		:SET FLAG TO 0 WHEN SENDING 0F
	EI	:T2GATE
	XHI	R6,4
	LHL	R9,BF,R6,		:GET ORIGINATING CHANNEL
	XHI	R6,4
	LHL	R0,IOTAB,R9,R9		:PERMUTER TABLE ENTRY FOR CIRCUIT ORIG
	THI	R0,IIXLOG		:SIQ CIRCUIT?
	JEFS	LOG9SQ			:NO
	LIS	LRC,0			:ABSENCE OF 80 BIT INDICATES SIQ TO SUP
LOG9SQ	HS	0			:Type 0F msg. Include host number+8000.
	LR	R2,R6			:GET PORT BUFFER
	IF	T2GATE			:##AL
	LHL	R0,BCT,R2,		:check for more data
	JE	LOG05			:IT'S EMPTY NOW
	EI	:T2GATE
	JAL	R9,GHWI			:GET 8000+HOST NUMBER
	LR	R2,R7			:GET SUP BUFFER
	JAL	R9,WHWI			:WRITE HOST NUMBER
	EI	:not EXPNDL

:	Supe message header complete.  Now append login string from login
:	buffer to it (escaping as necessary) until login buffer is depleted or
:	a terminator or escape char is detected.  (See LOGDLM for escape
:	characters-- there are several.)  Bump the count in LRC as we go.
:	Skip to LOG05 if the buffer empties.
LOG3	HS	0
	IF	T2GATE
	LR	R2,R6			:port buffer
	LHL	R0,BCT,R2,		:check for more data
	JE	LOG05			:IT'S EMPTY NOW
	JAL	R8,PCIS
	CLHI	R1,03
	JN	LOG309	
	JAL	R8,PCI
	CLHI	R1,01
	JE	LG11ZP
	JFS	LOG309
	EI	:T2GATE
LOG33	LR	R2,R6			:port buffer
	LHL	R0,BCT,R2,		:check for more data
	JE	LOG05			:IT'S EMPTY NOW
LOG309	JAL	R8,GCI			:read out a byte
	LR	R2,R7			:sup buffer
	CLHI	R1,8			:ESCAPE IF NEEDED (00-07)
	JGE	LOG6
	EXBR	R1,R1			:move high order byte of 0 down
	JAL	R8,WCI			:write in the escape
	EXBR	R1,R1			:move data byte back
LOG6	HS	0
	IF	T2GATE
	OHI	R1,80			:Must set high order bit for sup
	EI	:T2GATE
	JAL	R8,WCI			:and write in data byte
	AIS	LRC,1			:INC STRING COUNT (don't count escapes)
	AIS	R4,1			:STOP WHEN CR, SEMI-:, OR ESC IS FOUND
	TBT	R1,LOGDLM-10		:DELIMITER = 'CR', "SEMI-:", 'ESC' ?
	JE	LOG33			:no, continue at top of loop
	J	LOG4

	IF	T2GATE
::	Detected Zapper in buffer.  Just send a Zapper to sup.
LG11ZP	HS	0
	LR	R2,R7
	LHI	R1,ZAPPH
	JAL	R9,WHWI			:Write Zapper directly to sup buffer
	AIS	LRC,2
	AIS	R4,2
	XHI	R6,4
	LHL	R1,BF,R6,		:Get return channel (to terminal port)
	SHI	R1,DISZFL		:Make relative dispatcher port
	RBT	R1,DISFLG		:and disable  servic of null buffer
	XHI	R6,4			:Return to previous state
	J	LOG05
::Now continue and send to sup
	EI	:T2GATE	
:	Detected terminator (semi-:, CR) or escape in login string.
:	Complete supe message, mark BF for TID sent and waiting for response
:	from sup (ie, node code and sup not ready).  Go on to next buffer(LOG1)

LOG4	HS	0
	STB	LRC,0,R10		:CR OR SEM--PUT AWAY COUNT
	IF	EXPNDL
	AH	LRC,SNCTSV,,		:add on cumulative SNI-length
	LHI	R1,SNITRM+SNTYP0	:terminate the SNI list
	JAL	R8,WCI			:write it to the sup buffer
	AIS	LRC,1			:up the SNI-length
	L	R10,SNCSV1,,		:points to the msg length entry
	STB	LRC,0,R10		:enter (escaped) msg length
	EI	:EXPNDL
	LR	R2,R6			:get .ALBUF (if SOLOCS) into R2 
	LHI	R1,LG.SNT		:SET NO TID, SUP NO LONGER READY,
	STH	R1,BF,R2,		:	NODE CODE NO LONGER READY

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	ST	R2,RGST,,
	LIS	R1,4			:CASE # 4
	JAL	R4,LGGDB2,,
	LR	R2,R7			:R2 = TVRBUF
	JAL	R4,LGGDB3,,
	GL	LGGDB3
	L	R4,REGST,,
	L	R2,RGST,,
	EI	:LPGDBG
	
	IF	T2GATE
	LIS	R0,0
	STB	R0,GLGCNT,CHN,		:Reinit. log-on buffer count
	EI	:T2GATE

	J	LOG1

:	Login buffer emptied while we were transfering it to the sup buffer.
:	Close out the supe message, mark the login buffer's BF to show TID has
:	been sent, then go on to next buffer (LOG1).
LOG05	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	ST	R2,RGST,,
	LIS	R1,3			:CASE # 3
	JAL	R4,LGGDB2,,
	LR	R2,R7			:R2 = TVRBUF
	JAL	R4,LGGDB3,,
	L	R4,REGST,,
	L	R2,RGST,,
	EI	:LPGDBG

	IF	T2GATE
	LIS	R0,0
	STB	R0,GLGCNT,CHN,		:Reinit. log-on buffer count
	EI	:T2GATE
	STB	LRC,0,R10		:EMPTY BUFF - PUT AWAY COUNT
	IF	EXPNDL
	AH	LRC,SNCTSV,,		:add on cumulative SNI-length
	LHI	R1,SNITRM+SNTYP0	:terminate the SNI list
	LR	R2,R7			:get to-sup buffer into R2
	JAL	R8,WCI			:write it to the sup buffer
	AIS	LRC,1			:up the SNI-length
	L	R10,SNCSV1,,		:points to the msg length entry
	STB	LRC,0,R10		:enter (escaped) msg length
	EI	:EXPNDL	
	LR	R2,R6
	LHI	R1,LGSN.T		:SET SUP & NC = Y, TID = N
	STH	R1,BF,R2,
	J	LOG1			:PUT HIM BACK ON QUEUE

:	(CR) (ESC,FS,GS,RS,US) (SEMI:) ({,|,},TILDA)
:	Bit array (80x bits) marks ASCII codes that are to be considered
:	"escapes" in a login string.
LOGDLM	HS	0
	HC	0004,001F,0000,0010,0000,0000,0000,001E

::	Here to zap a login circuit because LOGGER found no sup or recent
::	takeover (in either case we can't process any more login data now,
::	and because we can't be sure of the status of any login data 
::	already sent to the (a) sup, we have to ask every one to start over
::	again).  We zap a port in login mode by sending it a
::	login-error-character-pair (0313).  If ISIS, DISPI will send the
::	dispatcher a B5 message and a zapper, and will call ZAPV when it gets
::	the corresponding zapper ack.  In a CONSAT, the port will be hung and
::	a zapper sent back to the node code by ASYNC.
::	For Gateway, we must send a zapper (to invoke an ISIS detatch)
::	and let the zap ack invoke Zapv to clear circuit - because we are not
::	talking to a terminal in Log-in mode, but to an active circuit in
::	another network.
LOGZAP	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	LIS	R1,1			:CASE # 1
	JAL	R4,LGGDB2,,
	L	R4,REGST,,
	EI	:LPGDBG

	XHI	R2,4			:ZAP CIRCUIT
	IF	T2GATE
LGZA1	LIS	R1,3
	JAL	R8,WCI
	LHI	R1,ZAPPH&0FF		:having placed char pr 0303
	JAL	R8,WCI
	ELSE	:NOT GATEWAY
	LIS	R1,3
	JAL	R8,WCI			:LOGRR (0313) ACTS AS ZAPPER
	LHI	R1,LOGRR&0FF		:(SENT TOWARDS CIRCUIT ORIGINATOR)
	JAL	R8,WCI
	LIS	R1,0			:ISIS unable to complete request###wjl
	JAL	R8,WCI			:ERROR CODE
	EI	:T2GATE
LGZPCN	XHI	R2,4			:Continuation point in either case

:	Set this guy's BF back to 0 (nothing doing) and go on to the next
:	buffer (LOG0).
	LIS	R1,0			:ZERO BUFFER FLAG
	STH	R1,BF,2,
	
	J	LOG0			:DONT PUT HIM BACK

:	LOGGER exit point.  Mark the 'has-ther-been-a-recent-takeover" flag
:	to "no" before returning to SWITCH exec loop (LOGRET).
LOGXIT	HS	0
	LIS	R0,0			:FORCE THIS TO NORMAL STATE
	STH	R0,LOGZPF

	IF	MPCCHK			:###LSH
	L	R1,FASTC,,
	S	R1,LGERB
	LH	R8,LGERF
	JEFS	MPCK14
	ST	R1,LGERYS
	J	MPCK15
MPCK14	ST	R1,LGERNO
MPCK15	HS	0
	EI	:MPCCHK
	
	J	LOGRET

::*********************************************************************
::
::	SUBROUTINE:	LOGCLR:
::	FUNCTION:	Remove a login-buffer (index in R6) from the
::		LOGGER list (LOGBUF).
::		Starts by appending a marker (HW 0) into LOGBUF,
::		then searching thru LOGBUF for the specified buffer index.
::		It is removed, the marker is removed, and we RETURN to the
::		caller.
::	CALLING SEQ:	JAL	R9,LOGCLR
::	DESTROYED:	R1
::	CALLS:		JAL	R9,WHWI0
::			JAL	R9,GHWI0
::
::*********************************************************************

LOGCLR	HS	0
	ST	R9,LGCSAV		:SAVE LINKER REGISTER		###LSH
	ST	R2,LOGTBF
	LIS	R2,LOGBUF
	LIS	R1,0
LOGCL1	JAL	R9,WHWI0		:WRITE MARKER
LOGCL2	JAL	R9,GHWI0		:GET NEXT ENTRY
	LR	R1,R1			:MARKERZ?
	JEFS	LOGCL3			:YES, WE'RE DONE
	CR	R1,6
	JEBS	LOGCL2			:THIS IS IT, DONT PUT IT BACK
	JBS	LOGCL1
LOGCL3	L	R9,LGCSAV		:RESTORE LINKER REGISTER	###LSH
	L	R2,LOGTBF
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	LOGIN:
::	FUNCTION:	Initiates login process for a dispatcher or CONSAT port
::	CALLING SEQ:	JAL	R8,LOGIN
::	INPUT:		R0 = TID (0 if aux circuit)
::			R2 = login input buffer (.ALBUF in the case of
::				the SOLOCS) index
::			R5 = CHN = absolute channel number of the login port
::				(not the async port number, but the ANITAB
::				index in the case of the SOLOCS)
::	RETURNS:	Does skip+4 return if successful,
::			straight return if no sup. 
::
::*********************************************************************

:	If there is no sup, call ZAPHRD to zap the login circuit,
:	then do straight return.  Otherwise, continue at LOGI1.
LOGIN	HS	0

	IF	LNFDBG		:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,LINDB1,,
	GL	LINDB1
	L	R4,REGST,,
	EI	:LNFDBG

	ST	R8,LOGSAV		:SAVE RETURN
	STB	R0,LOGTID		:SAVE TID
	STH	R2,LOGTBF		:AND A REG
	LHL	R3,TVRBUF		:IS THERE A SUP?
	JGFS	LOGI1			:YES
LOGI2	JAL	R9,ZAPHRD		:NO SUP, ZAP (FROM REQUESTING PORT)
	L	R8,LOGSAV		:AND TAKE IMMEDIATE RETURN
	JR	R8

:	We have a sup.  Put the login buffer index into LOGBUF so LOGGER will
:	process the data.  If the TID is 0, got to LOGAUX to set up for
:	aux circuit login.  Otherwise, mark the login status (BF) to indicate
:	sup OK, TID in buffer, node code not OK.  Go to LOGIEX to finish up.
LOGI1	HS	0
	LR	R1,R2			:PUT HIM ON LOGGER LIST
	LIS	R2,LOGBUF
	JAL	R9,WHWI0
	LB	R0,LOGTID		:TID=0 (AUX CIR ?)
	JEFS	LOGAUX			:YES,

	LHI	R0,LGST.N		:SUP=Y, TID=Y, NODE CODE=N
	STH	R0,BF,R1,		:SET BF TO LOGIN
	J	LOGIEX			:EXIT, RESTORING REGS.

:	Here because TID is 0 -- aux circuit login.
:	Set login status bits (BF) to indicate supe not OK,
:	TID not in buffer, node code OK.
LOGAUX	HS	0
	LHI	R0,LGN.ST		:AUX LOGIN -SUP=WAIT, NC=OK, TID =NONE
	STH	R0,BF,R1,
:	Build the aux circuit request in the supe buffer, as follows:
:		8000+node#
:		1081 (or 1001 if ISIS SIQ circuit)
:		8000+channel#
:		8000+requesting host#
	LHL	R2,TVRBUF
	LHI	R1,MACHNM+8000		:REQUEST AUX CIRCUIT
	JAL	R9,WHWI
	LHI	R1,1081			:TYPE,ETC
	IF	ISIS
:	IF SIQ CIRCUIT, INDICATE TO SUP BY ABSENCE OF 80 BIT
	LH	R0,DORSIQ		:SIQ CIRCUIT?
	JGEFS	LOGAX1			:NO
	LHI	R1,1001			:YES - INDICATE SMART SOURCE TO SUP
	EI	:ISIS
LOGAX1	JAL	R9,WHWI
	LR	R1,CHN			:PORT #
	IF	NEWALI
	OH	R1,CKTKEY-(2*ANIZFL),CHN,CHN :BLEND IN KEY BITS
	EI	:NEWALI
	OHI	R1,8000
	JAL	R9,WHWI
	IF	ISIS
	LHL	R1,DORHST		:ADD HOST NUMBER TO 
	OHI	R1,8000			:AUX CIRCUIT REQUEST
	ELSE	:ISIS
	LHI	R1,8000!HST0
	EI	:ISIS
	JAL	R9,WHWI

:	Common exit point for regular and aux logins.
:	Set up buffer timeout (BUFTIM, 2 min.), and skip+4 return for all OK.
LOGIEX	HS	0
	L	R8,LOGSAV		:RESTORE LINK
	LH	R2,LOGTBF		:AND BUFFER #

	SRLS	R2,1			:SET UP BUFTIM INDEX
	L	R9,SLOWC,,		:SET UP 2-MINUTE WARNING IN CASE WE
	AHI	R9,$A120		:WANT TO TIME THIS LOGIN OUT
	ST	R9,BUFTIM,R2,
	SLLS	R2,1

	J	4,R8			:SKIP RETURN, ALL OK

	SUBTTL	LOGSUP (Sup message generators)

::*********************************************************************
::
::	SUBROUTINE:	SUP08:
::	FUNCTION:	REPORT TYMNET-I ZAPPER SENT OR RECEIVED.
::	CALLING SEQ:	JAL	R10,SUP08
::
::*********************************************************************

SUP08	HS	0
	LHL	R2,TVRBUF		:IS THERE A SUP?
	JER	R10			:NIX
	ST	R4,YAKT1
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	LR	R1,CHN
	SRHLS	R1,1
	AHI	R1,800			:08+CHANNEL #
	JAL	R9,WHWI
	LHL	R1,NDID,KD		:NEIGHBOR #
	AHI	R1,8000
	JAL	R9,WHWI
	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUP0B:
::	FUNCTION:	Resources Report to Sup
::	CALLING SEQ:	JAL	R10,SUP0B    Called from 2-MINUTE LOGIC
::			and from CRQ when node goes out of passthroughs
::
::*********************************************************************

SUP0B	HS	0
	LHL	R2,TVRBUF		:REPORT AVAILABLE PASSTHRUS
	JER	R10			:no sup--can't report
	LHI	R1,8000+MACHNM		:else write our node #
	JAL	R9,WHWI
	LHI	R1,0B80			:write our messge type
	JAL	R9,WHWI
	LHI	R1,NPASTH		:number of total possible passthroughs
	SH	R1,PASTHR		:minus number of used passthroughs
	JGEFS	SUP0B2			:a neg check is expecting the worst
	LIS	R1,0			:report none left--an understatement
SUP0B2	STH	R1,PTHRPD		:store # Passthrus reported available
	JAL	R9,WHWI			:tell the sup our conclusion
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUP11:
::	FUNCTION:	REPORT HOST STATUS
::	CALLING SEQ:	JAL	R10,SUP11
::	INPUT:		R13 = HN = HOST # (NOT FOR GATEWAY)
::
::*********************************************************************

SUP11	HS	0
	LHL	R2,TVRBUF		:THE USUAL
	JER	R10
	ST	R4,YAKT1
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	IF	T2GATE			:GATEWAY SUP11 REPORT TO HNET
	LB	R1,HSTAT
	AHI	R1,1190			:Report as IIX Gateway
	ELSE
	LB	R1,HSTAT,HN		:STATUS BITS, MESS #
	AHI	R1,1180
	EI	:T2GATE ##AL
	JAL	R9,WHWI
	IF	T2GATE			:GATEWAY RPT TO HNET
	LHL	R1,HOSTN		:ONLY ONE GW SLOT HOST
	ELSE
	LHL	R1,HOSTN,HN,HN		:HOST #
	EI	:T2GATE ##AL
	OHI	R1,8000			:PLUS 8000X
	JAL	R9,WHWI
	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUP1A:
::	FUNCTION:	REPORT HOST STATUS IN NEW FORMAT FOR MXP SYSTEMS
::			INCLUDING MACHINE # AND SLOT #
::	CALLING SEQ:	JAL	R10,SUP1A
::	INPUT:		R13 = HN = HOST #
::	FORMAT:
::	[1A,STATUS] where STATUS is 8 bits long, STATUS = 100P CCXY
::		P = Proxy host
::		CC= collect-calls
::			00 = never accept collect-calls
::			01 = only accept collect calls
::			10 = leave the decision to the destination host
::			11 = unused
::		XY= Status
::			00 = answered
::			10 = shut
::			01 = down
::			11 = gone
::	[reserved]
::	[8000 + Host #]
::	[80 + MXP machine #, 80 + Host slot]
::*********************************************************************

SUP1A	HS	0
	LHL	R2,TVRBUF		:IS THERE A SUPERVISOR?
	JER	R10			:DON'T BOTHER IF NOT
	ST	R4,YAKT1
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	LB	R1,HSTAT,HN		:STATUS BITS
	LB	R0,HSTAT3,HN		:Proxy, CC bits (3,4,5)		###wjl
	OR	R1,R0			:combine			###wjl
	AHI	R1,1A80			:+ MESSAGE NUMBER (NEW)
	JAL	R9,WHWI
	LHI	R1,8080			:FOR FUTURE USE
	JAL	R9,WHWI
	LHL	R1,HOSTN,HN,HN		:HOST NUMBER
	OHI	R1,8000			:SET 8000 BIT
        JAL     R9,WHWI			:###LH
	LB	R1,HSTKEY,HN		:GET SLOT# * 4 IF NON-MXP (00SS)
					:    SLOT#,MACHINE# IF MXP (00SM)
        IF      MXPNM			:IF MXP, CONVERT (00SM) TO (0M0S)
	EXBR	R0,R1			:R0 = (SM00)
        NHI     R0,0F00         	:R0 = (0M00)
        SRHLS   R1,4            	:R1 = (000S)
	OR	R1,R0			:R1 = (0M0S)
        ELSE	:not MXPNM		:IF NON-MXP, COMPUTE SLOT#
        SRHLS   R1,2	           	:(TRUE SLOT#, NOT SLOT# * 4)
        EI      :MXPNM
	OHI	R1,8080			:SEND SLOT# (00SS) + 8080 IF NON-MXP
	                               	:SEND MACHINE#,SLOT# (0M0S) + 8080 IF
        	                       	:MXP MACHINE			###LH
	JAL	R9,WHWI
	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUPHS:
::	FUNCTION:	SEND HOST STATUS REPORT TO SUP WHICH MAY
::			CONTAIN HIQ, HID DATA.
::	CALLING SEQ:	JAL	R10,SUPHS
::	INPUT:		R4  = HID
::			R13 = HOST #
::			R14 = MESSAGE HEADER
::
::*********************************************************************

SUPHS	HS	0
	LHL	R2,TVRBUF		:IS THERE A COMMAND CIRCUIT?
	JER	R10			:NO
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI			:IDENTIFY OURSELVES
	LR	R1,R14
	JAL	R9,WHWI			:SEND MESSAGE HEADER
	LHL	R1,HOSTN,HN,HN
	OHI	R1,8000			:HOST NUMBER + 8000
	JAL	R9,WHWI
	LR	R1,R4
	JER	R10			:NO HID, DONE WITH MESSAGE
	OHI	R1,8000
	JAL	R9,WHWI			:HID + 8000
	JR	R10			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SUP12:
::	FUNCTION:	REPORTS TO SUP'S LOG.
::	CALLING SEQ:	JAL	R10,SUP12
::	DESTROYED:	R0, R1, R2, R3, R8, R9
::
::*********************************************************************

:	COMMAND CIRCUIT EXISTS IF TVRBUF<>0 (TVRBUF CONTAINS COMMAND CIRCUIT
:	BUFFER INDEX) AND AN ENTRY IN LIOTAB MATCHES IT (TVRBUF MAY BE
:	NON-ZERO IF UPSTREAM LINK JUST WENT OUT AND LEP HAS NOT YET
:	PROCESSED THE ZAPPER FROM TRLINK). IF THERE IS NO COMMAND CIRCUIT,
:	TEST FOR LINE DIAGNOSTIC MESSAGE, CHARACTERISED BY THE 8000 BIT
:	SET IN SUPMBF. IF NOT A LINE DIAGNOSTIC, STORE REPORT TO LOG IN
:	'NCCBUF' BUFFER TO BE SENT TO SUP FOLLOWING NODE'S TAKEOVER.

SUP12	HS	0
	LHL	R2,TVRBUF		:GOT A COMMAND CIRCUIT?
	JEFS	SUP12B			:NO
	LHI	R1,NLQ-1		:MAYBE - SEE IF ANY LEP P.T. ENTRIES
:	ARE EQUAL TO THE CONTENTS OF TVRBUF, AND THEREFORE POINT TO ACTIVE SUP
SUP12A	LHL	R0,LIOTAB,R1,R1
	NHI	R0,-4
	CR	R0,R2			:UPSTREAM POINTER?
	JEFS	SUP12C			:YES - GOT A COMMAND CIRCUIT
	SIS	R1,1
	JGEBS	SUP12A			:KEEP CHECKING

:	NO COMMAND CIRCUIT PRESENT...
SUP12B	LH	R2,SUPMBF		:IS THIS A LINE DIAGNOSTIC?
	JLR	R10			:YES, RETURN
	LIS	R2,NCCBUF		:NO - STORE TYPE 12 MSG IN TEMP BUFFER
SUP12C	ST	R4,YAKT1
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	LHI	R1,1280
	JAL	R9,WHWI
	LHL	R1,SUPMBF
	JAL	R9,WHWI			:48 BITS OF MESSAGE
	LHL	R1,SUPMBF+2
	JAL	R9,WHWI
	LHL	R1,SUPMBF+4
	JAL	R9,WHWI

:	FORMAT CRYPTOGRAM FOR XRAY LOG
SUP12D	HS	0
	LHL	R4,SUPMBF		:GET NODE REPORT TYPE
	CLHI	R4,NRMPNE		:DO WE WANT TO SEND CRYPTOGRAM?
	JG	NRCREX			:NO - EXIT
	SLLS	R4,2
	LH	R1,NRMPTB-4,R4		:GET MAPPING ENTRY
	JL	NRCREX			:NO FORMATTING DESIRED
	LB	R1,NRFMTB-1,R1		:GET MAPPING ARRAY ADDRESS
NRCR10	LB	R8,NRMPBS,R1		:GET SOURCE DISPLACEMENT
	JEFS	NRCR20			:DONE WITH THIS CRYPTOGRAM
	LB	R9,NRMPBS+2,R1		:GET MASK
	LB	R3,SUPMBF,R8		:GET SOURCE BYTE AND
	NR	R3,R9			:MASK OUT UNWANTED BITS
	LB	R9,NRMPBS+1,R1
	STB	R3,CRYSBF,R9		:STORE FOR CRYPTOGRAM
	AIS	R1,3
	JBS	NRCR10
NRCR20	LHL	R1,NRMPTB-2,R4		:GET CRYPTO NUMBER AND MESSAGE FLAGS
	L	R0,CRYSBF+4
	JAL	R8,CRYPT1,,		:SEND CRYPTOGRAM
NRCREX	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	TABLE:		NRMPTB
::	FUNCTION:	DEFINE MAPPING BETWEEN NODE REPORTS AND CRYPTOGRAMS
::
::*********************************************************************

:	EACH ENTRY IS 2 HALFWORDS LONG, WITH A FORMAT VALUE AND A CRYPTO VALUE.
:	BOTH ENTRY FIELDS ARE -1 IF NO CRYPTOGRAM IS TO BE GENERATED.
:	THE FORMAT VALUE PROVIDES AN INDEX INTO THE 'NRFMTB' TABLE WHICH
:	DIRECTS THE FORMATTING OF CRYPTOGRAMS BASED ON THE DATA IN THE NODE
:	REPORT. THE NRMPTB ENTRIES ARE ORDERED BY NODE REPORT NUMBER.
:
:	Six DIFFERENT MAPPINGS OF SUP DATA TO CRYPTO DATA ARE OFFERED.
:	FOR REFERENCE, THE SUP12 ROUTINE EXPECTS up to 4 HW OF DATA IN SUPMBF.
:	THESE ARE REFERRED TO AS SUP HW0 TO SUP HW3. CRYPT1 EXPECTS UP
:	TO 4 HW STARTING AT CRYSBF. THESE ARE REFERRED TO AS CRY HW0 TO
:	CRY HW3.
:
:	SUPMBF HW0 contains NR.### and is preceeded by 1280.
:	SUPMBF HW1 and HW2 contain data for the Sup as explained below.
:	SUPMBF HW3 may contain additional data for CRYPTO message.
:	CRYSBF contains data in the following order: HW2 HW3 HW0 HW1 !!
:
:	CRYPTO Equate Codes indicate which HW's contain data.  For example,
:	a code of 5 (0101) indicates HW1 and HW3 contain data.
:
:	MAPS 1 AND 5 ARE BOTH USED FOR A CRYEXX CODE OF 5. THE REASON IS 
:	THAT CRY HW3 IS RESERVED FOR EITHER NEIGHBOR NUMBERS OR HOST NUMBERS
:	TO PROVIDE FOR FUTURE SCAN FUNCTIONS FOR A SPECIFIED NEIGHBOR OR
:	HOST. THE NODE REPORT CONVENTION HAS BEEN TO PUT THE NEIGHBOR
:	NUMBER IN SUP HW1 AND THE HOST NUMBER IN SUP HW2 FOR THE VARIOUS
:	DIFFERENT NODE REPORTS. THEREFORE, MAPS 1 AND 5 REVERSE THE FORMATTING
:	OF THOSE TWO FIELDS.
:
:	MAP 1:	SUP HW1 -> CRY HW3	CRYEXX CODE 5XXX
:		SUP HW2 -> CRY HW1
:
:	MAP 2:	SUP HW1 -> CRY HW0	CRYEXX CODE CXXX
:		SUP HW2 -> CRY HW1
:
:	MAP 3:	SUP HW1 -> CRY HW3	CRYEXX CODE 3XXX
:		SUP HW2 -> CRY HW2
:
:	MAP 4:	SUP HW1 -> CRY HW3	CRYEXX CODE 7XXX
:		SUP HW2 -> CRY HW1	:###wjl
:		SUP HW3 -> CRY HW2	:###wjl
:
:	MAP 5:	SUP HW1 -> CRY HW1	CRYEXX CODE 5XXX
:		SUP HW2 -> CRY HW3
:
:	MAP 6:	SUP HW1 -> CRY HW0	CRYEXX CODE CXXX
:		SUP HW2 -> CRY HW1	(SAME AS MAP 2 EXCEPT NO MASKING OF
:					 HI-ORDER BIT)

NRMPTB	HS	0
	HC	1,CRYE5F	:1 - CHANNEL IN USE
	HC	-1,-1		:2 - DATA ON UNASSIGNED CHANNEL
	HC	4,CRYE60	:3 - BUFFER ZAP
	HC	-1,-1		:4 - REMOVE NEIGHBOR RESPONSE
	HC	-1,-1		:5 - ADD NEIGHBOR RESPONSE
	HC	1,CRYE22	:6 - LINK BUBBLE
	HC	1,CRYE21	:7 - LINK SHRINK
	HC	3,CRYE68	:8 - OUT OF PERMUTER TABLE SPACE
	HC	3,CRYE69	:9 - OUT OF LINK DESCRIPTOR SPACE
	HC	4,CRYE4D	:0A- LINK OUT PLI COUNT
	HC	5,CRYE1C	:0B- OUT OF DISPATCHER PORTS
	HC	5,CRYE61	:0C- NEEDLE REJECTED BY SLOT OUT OF PORTS
	HC	5,CRYE62	:0D- IMPOSTER HOST
	HC	-1,-1		:0E- CIRCUIT LIFETIME
	HC	1,CRYE39	:0F- LINK SNIP
	HC	-1,-1		:10- DIAGNOSTIC REPORT
	HC	1,CRYE0A	:11- NO NEIGHBOR
	HC	1,CRYE26	:12- INVALID MACHNM ON COMMAND CIRCUIT
	HC	2,CRYE27	:13- INVALID COMMAND ON COMMAND CIRCUIT
	HC	2,CRYE34	:14- CIRCUIT ERRORS
	HC	2,CRYE35	:15- CIRCUIT INCONSISTENCIES
	HC	1,CRYE51	:16- LINK FROZEN
	HC	1,CRYE52	:17- LINK THAWED
	HC	4,CRYE4E	:18- COMMAND CIRCUIT PLI'S
	HC	-1,-1		:19- NODE CRASH REPORT
	HC	-1,-1		:1A- REPORT SIO, SYNC, XLINKS, NLINKS
	HC	-1,-1		:1B- REPORT PORTS, PASSTHROUGHS
	HC	-1,-1		:1C- REPORT UNUSED LINES
	HC	-1,-1		:1D- LINE/LINK REPORT
	HC	2,CRYE58	:1E- SLOT REPORT LIMIT EXCEEDED
	HC	5,CRYE5B	:1F- INVALID HOST FOR RESTRICTED NODE
	HC	5,CRYE5A	:20- SLOT/HOST CIRCUIT LIMIT EXCEEDED
	HC	-1,-1		:21- CNT OF CIRCUITS ZAPPED DUE TO DLOAD OR BT
	HC	2,CRYE5E	:22- INVALID 03-CHAR PAIR ON COMMAND CIRCUIT
	HC	2,CRYE56	:23- MAC ERROR, SOFT FAILURE
	HC	2,CRYE55	:24- 56KB DIAGNOSTIC - CCW CHAINING TIMEOUT
	HC	2,CRYE58	:25- DATA ON IDLE TYMSAT PORT
	HC	1,CRYE5C	:26- INVALID 03-CHAR PAIR ON T-I CMND CIRCUIT
	HC	1,CRYE5D	:27- T-I SUP RECORD WITH INVALID LENGTH
	HC	2,CRYE57	:28- DMA HARDWARE TIMEOUT CAUSED MAC INTERRUPT
	HC	5,CRYE64	:29- KERNEL PORT ZAP FAILED
	HC	-1,-1		:2A- FIRST ADDENDUM TO CRASH REPORT
	HC	-1,-1		:2B- 2ND ADDENDUM TO CRASH REPORT
	HC	-1,-1		:2C- REPORT KERNEL HOST NUMBER
	HC	-1,-1		:2D- SQFIX ERROR
	HC	-1,-1		:2E- TEMPERATURE OUT OF RANGE
	HC	2,CRYE75	:2F- NETID MISMATCH			###wjl
	HC	2,CRYE76	:30- WSIZ MATCH DOWN			###wjl
	HC	2,CRYE77	:31- XRAY NETID MOD			###wjl
	HC	3,CRYE79	:32- STARLINK RESET RETRY FAILURE	###EV
	HC	2,CRYE4F	:33- ASYNC RING WRAP			###wjl
NRMPNE	EQ	(.-NRMPTB)/4	:NUMBER OF NRMPTB ENTRIES

::*********************************************************************
::
::	TABLE:		NRMPBS
::	FUNCTION:	SET OF MAPPING ARRAYS TO CONSTRUCT CRYTPOGRAMS
::			FROM NODE REPORTS.
::
::*********************************************************************

:	EACH MAP CONSISTS OF 3-BYTE ELEMENTS, FOR BYTE-BY-BYTE FORMATTING.
:	THE FIRST BYTE IS THE SOURCE ADDRESS, RELATIVE TO SUPMBF.
:	THE SECOND BYTE IS THE DESTINATION ADDRESS, RELATIVE TO CRYSBF.
:	THE THIRD BYTE IS A MASK, SINCE MANY NODE REPORT FIELDS ARE OR'D WITH
:	8000 TO PREVENT NETWORK ESCAPES.

NRMPBS	HS	0		:BASE ADDRESS FOR MAP ENTRIES.

NRMP01	EQ	.
	BC	2,2,7F
	BC	3,3,0FF
	BC	4,6,7F
	BC	5,7,0FF
	BC	0		:END OF MAP 01

NRMP02	EQ	.
	BC	2,4,7F
	BC	3,5,0FF
	BC	4,6,7F
	BC	5,7,0FF
	BC	0		:END OF MAP 02

NRMP03	EQ	.
	BC	2,2,7F
	BC	3,3,0FF
	BC	4,0,7F
	BC	5,1,7F
	BC	0		:END OF MAP 03

NRMP04	EQ	.
	BC	2,2,7F
	BC	3,3,0FF
	BC	6,0,0FF		:###TZ
	BC	7,1,0FF		:###TZ
	BC	4,6,7F
	BC	5,7,0FF
	BC	0		:END OF MAP 04

NRMP05	EQ	.
	BC	2,6,7F
	BC	3,7,7F
	BC	4,2,7F
	BC	5,3,0FF
	BC	0		:END OF MAP 05


NRMP06	EQ	.
	BC	2,4,0FF
	BC	3,5,0FF
	BC	4,6,0FF
	BC	5,7,0FF
	BC	0		:END OF MAP 06

::*********************************************************************
::
::	TABLE:		NRFMTB:
::	FUNCTION:	POINTS TO FORMAT ACTION ARRAY
::			INDEXED BY FORMATTING TYPE
::
::*********************************************************************

NRFMTB	HS	0
	BC	NRMP01-NRMPBS
	BC	NRMP02-NRMPBS
	BC	NRMP03-NRMPBS
	BC	NRMP04-NRMPBS
	BC	NRMP05-NRMPBS
	BC	NRMP06-NRMPBS
	HS	0

::*********************************************************************
::
::	SUBROUTINE:	SUP12L:
::	FUNCTION:	FORMAT LINK BUBBLE/SHRINK NODE REPORT
::
::*********************************************************************

SUP12L	HS	0
	STH	R0,SUPMBF		:ENTERED WITH REPORT TYPE IN R0
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER IN HW2
	LHL	R0,NCHN,KD
	OHI	R0,8000
	STH	R0,SUPMBF+4		:CURRENT # OF CHANNELS IN HW3
	ST	R10,RTMT1
	JAL	R10,SUP12,,		:SHIP REPORT TO SUPERVISOR
	L	R10,RTMT1		:RESTORE LINK REG..
	JR	R10			:..AND RETURN

::*********************************************************************
::
::	SUBROUTINE:	NETDGN:
::	FUNCTION:	FORMAT DIAGNOSTIC CRYPTOGRAMS AND NODE REPORTS.
::	CALLING SEQ:	JAL	R9,NETDGN
::	INPUT:		R8 = DIAGNOSTIC SUB-TYPE
::
::*********************************************************************

NETDGN	HS	0
:	THROTTLE REPORTING IN CASE PATHOLOGICAL CONDITION...
	LHI	R0,NR.DGN
	AM	R0,NETDCT,,		:SHOULD WE THROTTLE DIAGNOSTIC REPORT?
	JGR	R9			:YES - ENOUGH THIS MINUTE

	STH	R0,SUPMBF		:STORE NODE REPORT TYPE
	L	R0,SUPMBF+2		:SET UP R0 FOR CRYPTO (LAST 3 BYTES OF
					:NODE REPORT ALSO USED AS CRYPTO DATA)
	STB	R8,SUPMBF+2		:STORE DIAGNOSTIC SUB-TYPE
	NHI	R8,NTDRTS/2-1		:INSURE VALID VALUE
	LHL	R10,NTDRTN,R8,R8	:GET SUB-TYPE ROUTINE ADDRESS
	J	SEG1,R10,,		:DISPATCH

NTDSYM	JAL	R8,CRYPTO,,
	HC	CRYE30			:SYNC SCAN ERROR
	J	NTDSNR

NTDSIO	NI	R0,0FFFFFF		:strip out diagnostic sub-type	###wjl
	JAL	R8,CRYPTO,,
	HC	CRYE32			:SIO BUFFER COUNT ERROR
	JFS	NTDSNR

NTDSBZ	NI	R0,0FF0000		:STRIP OUT NEIGHBOR NUMBER
	AR	R0,R8			:PUT IN REASON FOR TIMEOUT
	JAL	R8,CRYPTO,,		:M-BOARD TIMEOUT
	HC	CRYE33
	JFS	NTDSNR

NTDOPS	JAL	R8,CRYPTO,,
	HC	CRYE31			:OOPS - INVALID CALLING ARGUMENT IN R8
	JR	R9

NTDSNR	HS	0			:SEND NODE REPORT
	ST	R9,NTDRET,,
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP
	L	R9,NTDRET,,		:RESTORE LINK REG AND
	JR	R9			:RETURN

::*********************************************************************
::
::	TABLE:		NTDRTN
::	FUNCTION:	HANDLER ROUTINES, BASED ON SUB-TYPE
::
::*********************************************************************

NTDRTN	HC	NTDSYM-SEG1,NTDSIO-SEG1,NTDSBZ-SEG1,NTDSBZ-SEG1,NTDSBZ-SEG1
	HC	NTDSBZ-SEG1,NTDOPS-SEG1,NTDOPS-SEG1
NTDRTS	EQ	.-NTDRTN	:TABLE SIZE

::*********************************************************************
::
::	SUBROUTINE:	SUP13:
::	FUNCTION:	INDICATES CHANGES IN LINK CONDITIONS
::	CALLING SEQ:	JAL	R10,SUP13
::	INPUT:		R4  =  MESSAGE TYPE
::			R14 = LN
::			R15 = KD
::
::*********************************************************************

SUP13	HS	0
	LHL	R2,TVRBUF		:IS THERE A SUP?
	JER	R10
	ST	R4,YAKT1
	LHI	R1,8000+MACHNM
	JAL	R9,WHWI
	LR	R1,R4
	JAL	R9,WHWI
	EXBR	R1,LN
	SRHLS	R1,1
	OHI	R1,8000
	LB	R0,KSPD,KD
	AR	R1,R0
	JAL	R9,WHWI
	LHL	R1,NDID,KD
	OHI	R1,8000
	JAL	R9,WHWI
	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUP14:/SUP14A:
::	FUNCTION:	GENERAL AND SUNDRY MISCELLANEA
::	REGISTER USAGE:
::		R1 - SOURCE OF ACCOUNTING (IF SUBTYPE = 89x)
::			0 FOR NODE CODE, 4 FOR DISPATCHER OR TYMSAT.
::			ALSO USED FOR WCI DATA
::		R2 - SUP BUFFER # (IF SUP IS PRESENT) SUPPLIED BY THIS RTN
::		R3 - SCRATCH, USED BY WCI
::		R4 - PRESERVED.  USED FOR CURRENT 7--- ACCT. RECORD
::		R5 - SUB-TYPE, PROVIDED BY CALLING ROUTINE
::		R6 - LENGTH OF DATA IN HW'S (2 MAXIMUM)
::		R8 - LINK FROM WHWI TO WCI
::		R9 - LINK TO WHWI
::		R10- LINK TO THIS ROUTINE
::
::*********************************************************************

:	SUP14A:
:	ENTRY POINT FOR NODE CODE GENERATED ACCOUTING MESSAGE TO SUP.
:	ENTERED WITH FIRST 2 HALFWORDS ACCOUNTING DATA IN R1.

SPTP14	EQ	1400			:sup msg type 14, subtype field empty
NCACCT	EQ	89			:node code generated accounting msg

SUP14A	HS	0
	ST	R1,SUPMBF		:HW1, HW2 OF ACCOUNTING MSG
	LHI	R5,NCACCT		:INDICATE ACCOUNTING MESSAGE,
	LIS	R1,0			:GENERATED BY NODE CODE,
	LIS	R6,2			:2 HALFWORDS LONG

SUP14	HS	0
	ST	R4,YAKT1		:PRESERVE R4
	IF	ISIS+SOLOCS
	CLHI	R5,NCACCT		:ACCOUNTING MESSAGE?
	JN	SUP14B			:NO, CONTINUE "NORMALLY"
	LB	R8,SUPMBF		:GET ACCOUNTING DATA TYPE
	NHI	R8,00F0			:GET HIGH ORDER NIBBLE
	CLHI	R8,0070			:TYPE 07?  (CHANGE INVOICE #)
	JE	SUP14C			:YES

:	ACCOUNTING DATA RECEIVED
	THI	R1,0FFFB		:TYPE OF CALL = 0 OR 4 ?
	JEFS	SUP14E			:YES, OK
	CRASH.(.SUPCR)
SUP14E	L	R4,ACT7,R1		:COMPARE LAST 7--- OF THIS TYPE
	LB	R8,ACTLST		:WITH LAST 7--- ISSUED
	C	R4,ACT7,R8
	STB	R1,ACTLST		:(SAVE CURRENT SOURCE AS OLD SOURCE)
	JE	SUP14B			:EQUAL, SEND NO 7--- RECORD

:	7---'S NOT EQUAL, SEND LAST 7--- OF THIS TYPE, AND DATA REC.
	LHL	R2,TVRBUF		:SUP?
	JE	SUP14F			:NO, EXIT
	LHI	R1,8000+MACHNM		:SEND NODE #
	JAL	R9,WHWI
	LHI	R1,SPTP14+NCACCT	:ACCOUNTING MESSAGE SUB-TYPE
	JAL	R9,WHWI
	EXHR	R1,R4			:GET FIRST HALF OF 7--- RECORD
	JAL	R9,WHWI
	LHR	R1,R4			:SECOND HALF
	JAL	R9,WHWI
	J	SUP14D			:WRITE NON-7--- DATA

SUP14C	L	R8,SUPMBF		:GET NEW ACCT MESSAGE
	C	R8,ACT7,R1		:= LAST ONE OF THIS TYPE?
	JE	SUP14F			:YES, REDUNDANT MSG, SKIP IT
	ST	R8,ACT7,R1		:SAVE 7---
	CLB	R1,ACTLST		:IF THIS 7--- IS FROM THE SAME SOURCE
	JN	SUP14F			:AS THE LAST ONE, WE MUST SET IT TO
	LIS	R8,8			:SOMTHING DIFFERENT OR IT MAY NOT
	STB	R8,ACTLST		:BE SENT
	J	SUP14F			:RESTORE R4 AND EXIT

SUP14B	HS	0
	EI	:ISIS+SOLOCS
GSP14H	LHL	R2,TVRBUF		:SUP PRESENT? (entry for Gateway
	JER	R10			:host cost report to H-net)
SUP14D	LHI	R1,8000+MACHNM
	JAL	R9,WHWI
	LHI	R1,SPTP14		:sup msg type 14, empty subtype field
	AR	R1,R5			:R5 CONTAINS SUBTYPE
	JAL	R9,WHWI
	LHL	R1,SUPMBF  
	JAL	R9,WHWI
	SIS	R6,1
	JLEFS	SUP14F
	LHL	R1,SUPMBF+2
	JAL	R9,WHWI
SUP14F	L	R4,YAKT1
	JR	R10

	ENDMO.(LOGSUP)

	EI	:1-KILLIT

	KILMSG(LOGSUP)

:	***NOTHING PAST THIS POINT***
 
	SUBTTL	LEP

:			*     ***** ****
:			*     *     *   *
:			*     ****  ****
:			*     *     *
:			***** ***** *

::#####################################################################
::
::	MODULE:		LEP
::
::	FUNCTION:	SUPERVISOR TO NODE COMMANDS
::
::	SUBTTLS:
::		LEP08 - Takeover command
::		LEP09 - Circuit building command
::		LEP0B - Circuit trace request
::		LEP0C - Sleeping pills
::		LEP0D - Message for ports in login mode
::		LEP0E - Aux circuit message
::		LEP0F - General supervisor commands
::		LEP10 - Port status request
::		LEP11 - Assign channel to TYMNET-I
::		LEPZAP - Handle command circuit zapper
::		LEP utilities and tables
::
::#####################################################################

	IF 	1-KILLIT	
	BEGMO.
	SEG	1

::*********************************************************************
::
::	SUBPROCESS:	LEP:
::	FUNCTION:	Process data on a command channel.
::	SCHEDULED:	Runs off SWITCH exec loop, based on data being
::			received on a command channel.
::
::*********************************************************************

:	TYMNET-II LEPRECHAUN
LEP	HS	0			:###OAS

	IF	DB.CPU
	LR	R3,R2			:SAVE R2			###OAS
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR LEP		###OAS
	CPUTNM(LEP   )			:DEFINE LEP CPUTIL ENTRY	###OAS
	LR	R2,R3			:RESTORE R2			###OAS
	EI	:DB.CPU

	LR	CHN,R2			:SAVE THE CHANNEL #
	LHL	R2,LIOTAB,R2,R2		:GET BUFF #
	NHI	R2,-4
	XHI	R2,4
	STH	R2,LEPINB		:SAVE IT

:	ENTRY POINT - RETURN FROM PROCESSING COMMAND
LEP1	HS	0
	LHL	R2,LEPINB		:RETREIVE BUFFER #
	L	R3,BB,R2,		:PEEK AT BYTE COUNT
	JE	BIDDRT,,		:BUFFER EMPTY
	JAL	R8,PCI			:SKIP LEADING 0

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,LEPDB1,,
	GL	LEPDB1
	L	R4,REGST,,
	EI	:LPGDBG

	CLHI	R1,3			:TEST FOR 03-PAIR (ONLY ZAPPERS)
	JE	LEPZAP			:ZAP SUP CIRCUIT IF IT IS
	JAL	R8,PCI			:ACTUAL BYTE CNT
	LR	LRC,R1			:SAVE IT
	JAL	R8,CBCCT		:CNT OF CHARS IN BUFF
	CLHI	R1,6			:NEED AT LEAST 6 CHARS IN BUFF
	JL	BIDDRT,,
	CR	R1,LRC
	JL	BIDDRT,,		:EXIT IF ENTIRE MESS NOT IN BUFF

	JAL	R8,GCI			:DISCARD BYTE CNT
	JAL	R8,GCI

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	ST	R5,RGST,,
	LR	R5,LRC			:GET BYTE COUNT INTO R5
	JAL	R4,LEPDB2,,
	GL	LEPDB2
	L	R4,REGST,,
	L	R5,RGST,,
	EI	:LPGDBG

	L	R3,BB,R2,		:PCI needs this
	JAL	R9,PHWI			:GET THE NODE #
	NHI	R1,7FFF
	CLHI	R1,MACHNM
	JN	LEPXMN			:ABORT IF INCORRECT NODE #
	JAL	R8,PCI			:GET THE MESSAGE TYPE
	SIS	R1,8			:DISPATCH
	JL	LEPXCM			:MSG TYPE OUT OF RANGE
	CLHI	R1,LEPDMX
	JGE	LEPXCM			:MSG TYPE OUT OF RANGE
	LHL	R1,LEPDIS,R1,R1		:GET PTR FROM DISPATCH TYPE 
	J	SEG1,R1,		:AND GO EXECUTE

:	ILLEGAL MACHINE NUMBER
LEPXMN	HS	0		
	OHI	R1,8000
	STH	R1,SUPMBF+2		:SAVE ILLEGAL NODE # FOR NODE REPORT
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP COMMAND CIRCUIT...
	LHI	R0,NR.XMN		:SET UP FOR NODE REPORT
	JFS	LEPXC2

:	INVALID COMMAND TYPE
LEPXCM	HS	0		
	OHI	R1,8000
	AIS	R1,8			:REPLACE BIAS
	STH	R1,SUPMBF+2		:SAVE INVALID COMMAND FOR NODE REPORT
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP COMMAND CIRCUIT...
	LHI	R0,NR.XCM
:	SEND NODE REPORT TO SUP
LEPXC2	STH	R0,SUPMBF		:NODE REPORT TYPE
	LH	R0,LEPXER
	AIS	R0,1			:INCREMENT COUNT OF LEP ERRORS
	STH	R0,LEPXER
	OHI	R0,8000
	STH	R0,SUPMBF+4		:INCLUDE COUNT IN NODE REPORT
	JAL	R10,SUP12		:SEND NODE REPORT
	J	LEPZA4			:OUTPUT CRYPTOGRAM AND EXIT

:	HANDLER ROUTINE FOR UNKNOWN MESSAGE TYPE FROM SUPERVISOR
LEPXT	LHI	R6,-2,LRC		:REMOVE THE COMMAND
LEPXT1	LHL	R0,BCT,R2,		:EXTRA CARE TAKEN FOR UNKNOWN COMMAND
	JE	BIDDRT,,		:TO AVOID GCI CRASHES
	JAL	R8,GCI
	SIS	R6,1			:MARK CHAR OF MSG OUT OF BUFFER
	JGBS	LEPXT1			:LOOP FOR NEXT ONE IF THERE IS ONE
	J	LEP1

	SUBTTL	LEP (LEP08 - Type 8:  Takeover command)

::*********************************************************************
::
::	COMMAND:	LEP08:
::	FUNCTION:	PROCESS TAKEOVER COMMANDS (TYPE 8)
::
::*********************************************************************

LEP08   HS     0
:       BEFORE PROCESSING TAKEOVER COMMANDS ON AN ISIS MACHINE, WE FIRST
:	NEED TO VERIFY THAT THE STATUS OF EACH HOST IS CORRECT.
        IF     ISIS&(1-T2GATE)
        ST     R2,HSTSAV	       :SAVE R2
        JAL    R7,CHKHST	       :VERIFY THE STATUS OF ALL HOSTS
        L      R2,HSTSAV	       :RESTORE R2
        EI     :ISIS&(1-T2GATE)

:       START TO PROCESS TAKEOVER COMMANDS
	IF	T2GATE			:RPT TO INET SUP IF NESSARY
        LB      R1,G0DFG                :have INET supe?
        JEFS    LP081                   :shut until have both supes ###sdw
	LIS	R3,0			:remember is answerred
	STB	R3,HSTAT		:TAKEOVER RESP. MAY RPT HSTAT
	JAL	R10,GHSTST
	EI	:T2GATE			:##AL
LP081	JAL	R9,GHWI			:TAKEOVER - GET NODE #

:	OLD SUP REQUIRES TYPE 09 TAKEOVER RESPONSE, NEWSUP TAKES TYPE 19
:	WHICH INCLUDES EXPANDED HOST INFORMATION
	LIS	R8,0			:ASSUME OLD TYPE SUP		###OAS
	THI	R1,8000			:CHECK FOR BIT 0 OF NODE NO. SET###OAS
	JNFS	LEP08S			:SET, OLD TYPE SUPERVISOR	###OAS
	LIS	R8,1			:NOT SET, FLAG AS NEW TYPE SUP	###OAS
LEP08S	HS	0	
	STH	R8,NEWSUP		:STORE NEW SUP FLAG		###OAS

	JAL	R8,GCI			:DISCARD TYPE
	JAL	R8,GCI			:GET THE SUP #
	NHI	R1,0F			:four bits max for sup number
	LR	PRC,R1
	LHL	R2,TVRBUF		:GET BUFF TOWARDS OLD SUP
	JEFS	LEP08A			:NONE
	LHI	R1,MACHNM+8000		:SEND TAKEOVER NOTICE TO OLD SUP
	JAL	R9,WHWI
	LR	R1,PRC			:NEW SUP #
	AHI	R1,0A80
	JAL	R9,WHWI
LEP08A	LHL	R2,LIOTAB,CHN,CHN	:GET BUFF # (TOWARDS SUP)
	NHI	R2,-4
	STH	PRC,TVRSUP		:SAVE # OF CURRENT SUP
        clhi    prc,machnm&7            :our supe?
        if      super
        jnfs    lep08y
        gl      swclear                 :clear Supe Watch stats
        jal     r9,swclear,,
lep08y
        ei      :super
	STH	R2,TVRBUF		:AND UPSTREAM BUFF #

:	CHECK FOR OLD OR NEW SUP (NEW SUP ACCEPTS EXPANDED HOST INFO)
	LHL	R1,NEWSUP		:CHECK FOR OLD OR NEW SUP	###OAS
	JN	LEP08T			:NEW SUP, FORM NEW TAKEOVER RESP###OAS

:	SEND TYPE 09 TAKEOVER RESPONSE TO OLD SUP
	LHI	R1,MACHNM+8000		:NOW SEND TAKEOVER RESPONSE
	JAL	R9,WHWI
	LR	R1,PRC			:SUP #
	AHI	R1,980
	JAL	R9,WHWI
	LH	R1,VERSSV+2,,		:VERSION
	JAL	R9,WHWI
	LH	R1,CRSHAD+2		:CRASH MARK
	JAL	R9,WHWI
	LB	R1,CRHCNT+1		:CRASH COUNT
	EXBR	R1,R1
	OHI	R1,8080			:(BOTH ARE "ESCAPED")
	AH	R1,NALINK		:...& # OF LINKS
	JAL	R9,WHWI
	IF	1:albert
	L	R1,BE,R2,		:				###AL
	ST	R1,NALNKA		:STORE NALINK FLD. PTR ADDR.	###AL
	EI	:al
	LHI	R1,80			:LEAVE ROOM FOR # OF HOSTS
	JAL	R8,WCI
	L	R0,BE,R2,		:SAVE PTR TO IT
	ST	R0,YAKT1
	JAL	R8,WCI			:FOLLOWING BYTE ALWAYS 80
	LHI	R1,NPASTH		:# OF PASSTHRUS
	SH	R1,PASTHR
	JGEFS	LEP810			:MAY BE <0 DUE TO SUP CIRCS
	LIS	R1,4
LEP810	JAL	R9,WHWI

	LIS	KN,0			:NEIGHBOR #'S
	IF 	1:albert
	LHI	R0,0			:				###AL
	STH	R0,TEMPHS		:ZERO THE #NBRS CNT.		###AL
	EI	:al
LEP08B	SLL	KN,1
	L	KD,KDKN,KN,KN
	SRL	KN,1
	LB	R0,NLAT,KD		:DON'T REPORT LINK IF INACTIVE
	JEFS	LEP08D
	LH	R1,NDID,KD
	OHI	R1,8000
	JAL	R9,WHWI
	IF	1:ALBERT
	LHI	R0,1			:				###AL
	AHM	R0,TEMPHS		:INC. TEMPHS			###AL
	EI	:AL
LEP08D	AIS	KN,1
	CLHI	KN,NLINKS
	JL	LEP08B
	IF	1:ALBERT
	LHL	R0,TEMPHS		:CHECK IF #NBRS MATCH NALINK	###AL
	CLH	R0,NALINK		:				###AL
	JE	LEP8CC			:IF OK DO NOTHING		###AL
	EXHR	R0,R0			:REPORT CRYPTO. HW0=#NBRS,HW1=NALINK
	AH	R0,NALINK
	JAL	R8,CRYPTO,,
	HC	CRYE74
	LH	R0,TEMPHS		:FORCE TO MATCH #NBRS=NALINK	###AL
	OHI	R0,80			:HO BIT SET IN FORMAT		###AL
	L	R1,NALNKA		:PREVIOUS FLD. ADDR SAVED	###AL
	STB	R0,,R1,			:				###AL
LEP8CC
	EI	:AL

	LIS	KN,0			:LINK SPEEDS
LEP08C	SLL	KN,1
	L	KD,KDKN,KN,KN
	SRL	KN,1
	LB	R0,NLAT,KD		:SKIP INACTIVE LINKS
	JEFS	LEP08E
	LB	R1,KSPD,KD
	OHI	R1,80
	JAL	R8,WCI
LEP08E	AIS	KN,1
	CLHI	KN,NLINKS
	JL	LEP08C

	LIS	HN,0			:HOST DATA
	LHI	R5,80			:TO COUNT HOW MANY HOSTS
LEP08G	LHL	R1,HOSTN,HN,HN		:HOST #
	JEFS	LEP08F			:NONE THERE
	AIS	R5,1
	AHI	R1,8000
	JAL	R9,WHWI
LEP08F	AIS	HN,1
	CLHI	HN,NHOSTS
	JL	LEP08G
	L	R1,YAKT1		:PUT AWAY HOST COUNT
	STB	R5,0,R1
	LIS	HN,0			:SEND STATUS BITS
	LIS	R1,1			:2 BITS/HOST IS DUMB!
LEP08J	LHL	R5,HOSTN,HN,HN		:read host entry
	JEFS	LEP08K			:nothing doing if no host there
	SLHLS	R1,2			:shift R1--make room for next status
	LB	R5,HSTAT,HN		:STATUS IS HI 2 BITS
	AR	R1,R5			:add status bits into the byte
	THI	R1,100			:test for overflow from byte
	JEFS	LEP08K			:branch until it is full
	JAL	R9,WCIE			:BYTE FULL -- write it into buffer
	GL	WCIE
	LIS	R1,1			:reset register for next bunch of stati
LEP08K	AIS	HN,1			:increment pointer to next entry
	CLHI	HN,NHOSTS		:check for end of table
	JL	LEP08J			:there may be more hosts--keep looping
	CLHI	R1,1			:now check for remnants in R1
	JE	LEP08M			:if it's 1, no new info there
LEP820	SLHLS	R1,2			:left adjust any partials	###jhl
	THI	R1,100			:overflow means we're adjusted
	JEBS	LEP820			:keep shifting until overflow	###jhl
	JAL	R9,WCIE			:then write in the final byte of stati

	J	LEP08M

:	SEND TYPE 19 TAKEOVER RESPONSE TO NEW SUP (WITH EXPANDED HOST INFO)
LEP08T	HS	0			:FORM NEW TAKEOVER RESPONSE	###OAS
	LHI	R1,MACHNM+8000		:SET UP HEADER			###OAS
	JAL	R9,WHWI
	LR	R1,PRC			:GET SUPERVISOR NUMBER		###OAS
	AHI	R1,1980			:FORM NEW TAKEOVER RESP (19)	###OAS
	JAL	R9,WHWI

	LB	R1,CRHCNT+1		:GET CRASH COUNT		###OAS
	EXBR	R1,R1			:INTO HO BYTE OF LO HW		###OAS
	OHI	R1,8080			:ESCAPE BOTH BYTES		###OAS
	AH	R1,NALINK		:AND COMBINE # OF LINKS		###OAS
	JAL	R9,WHWI
	IF	1:albert
	L	R1,BE,R2,		:				###AL
	ST	R1,NALNKA		:STORE NALINK FLD. PTR ADDR.	###AL
	EI	:al
	LIS	HN,0			:COUNT NUMBER OF HOSTS		###OAS
	LHI	R1,8000			:TO COUNT HOW MANY HOSTS	###OAS
LEPN8J	HS	0
	LHL	R5,HOSTN,HN,HN		:CHECK HOST TABLE FOR ENTRY	###OAS
	JEFS	LEPN8K			:NONE THERE, DON'T COUNT	###OAS
	AIS	R1,1			:HOST THERE, BUMP COUNT		###OAS
LEPN8K	HS	0
	AIS	HN,1			:BUMP HOST INDEX		###OAS
	CLHI	HN,NHOSTS		:EXCEEDED NUMBER OF ENTRIES	###OAS
	JL	LEPN8J			:NO, CHECK FOR MORE HOSTS	###OAS
	JAL	R9,WHWI			:ALL DONE, WRITE # HOSTS	###OAS

	LH	R1,VERSSV+2,,		:GET VERSION NUMBER		###OAS
	JAL	R9,WHWI	

	LH	R1,CSMTBL+CS.CID	:GET CRASH SUBTYPE,TYPE		###OAS
	JAL	R9,WHWI

	LHI	R1,8080			:RESERVE SPACE FOR FUTURE USE	###OAS
	JAL	R9,WHWI

	LHI	R1,NETID		:GET NODE'S NETWORK ID		###OAS
	JAL	R9,WHWI
	LHI	R1,NETMOD		:GET NODE'S NETWORK MODIFIER	###OAS
	JAL	R9,WHWI
	LHI	R1,SUBNET		:GET NODE'S SUBNET NUMBER	###OAS
	JAL	R9,WHWI

	LHI	R1,NPASTH		:GET NUMBER OF POSSIBLE PASSTHRUS##OAS
	JAL	R9,WHWI
	LHI	R1,NPASTH		:COMPUTE AVAILABLE FROM TOTAL	###OAS
	SH	R1,PASTHR		:MINUS CURRENT PASSTHRUS	###OAS
	JAL	R9,WHWI

	LIS	KN,0			:BEGIN LINK CLUSTERS		###OAS
	IF	1:ALBERT
	LHI	R0,0			:INIT TEMPHS CNT FOR #NBRS	###AL
	STH	R0,TEMPHS		:				###AL	
	EI	:AL
LEPN8B	HS	0
	SLL	KN,1
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR		###OAS
	SRL	KN,1
	LB	R0,NLAT,KD		:CHECK IF LINK ACTIVE		###OAS
	JE	LEPN8D			:NOT ACTIVE, DON'T REPORT	###OAS

	LH	R1,NDID,KD		:GET NEIGHBOR NO.		###OAS
	OHI	R1,8000
	JAL	R9,WHWI

	LHI	R1,0080
	JAL	R8,WCI			:SAVE FOR FUTURE USE AS LINK FLAGS#OAS
	LB	R1,KSPD,KD		:GET LINK SPEED/FLAGS		###OAS
	OHI	R1,0080
	JAL	R8,WCI
	IF	1:ALBERT
	LHI	R0,1			:INC. TEMPHS CNT		###AL
	AHM	R0,TEMPHS		:				###AL
	EI	:AL
LEPN8D	HS	0
	AIS	KN,1			:BUMP LINK INDEX		###OAS
	CLHI	KN,NLINKS		:# LINKS EXCEEDED?		###OAS
	JL	LEPN8B			:NO, LOOK THROUGH MORE LINKS	###OAS
	IF	1:ALBERT
	LHL	R0,TEMPHS		:CHECK IF #NBRS MATCH NALINK	###AL
	CLH	R0,NALINK		:				###AL
	JE	LEP8GG			:IF OK DO NOTHING		###AL
	EXHR	R0,R0			:REPORT CRYPTO. HW0=#NBRS,HW1=NALINK
	AH	R0,NALINK
	JAL	R8,CRYPTO,,
	HC	CRYE74
	LH	R0,TEMPHS		:FORCE TO MATCH #NBRS=NALINK	###AL
	OHI	R0,80			:SET HO BIT IN FORMAT		###AL
	L	R1,NALNKA		:PREVIOUS FLD. ADDR SAVED	###AL
	STB	R0,,R1,			:				###AL
LEP8GG	HS	0
	EI	:AL

	LIS	HN,0			:BEGIN HOST CLUSTERS		###OAS
LEPN8G	HS	0
	LHL	R1,HOSTN,HN,HN		:CHECK HOST TABLE FOR HOST ENTRIES#OAS
	JE	LEPN8F			:NO HOST AT THIS ENTRY		###OAS

	LB	R1,HSTAT3,HN		:Proxy, and CC (bits 3,4,5)	###wjl
	SLLS	R1,0B			: to HO byte (bits 0,1,2) of HW	###wjl
	JAL	R9,WHWI
	LHL	R1,HOSTN,HN,HN		:RECOVER HOST NUMBER		###OAS
	JAL	R9,WHWI

:	PREPARE TO SEND SLOT NUMBER TO SUP			        ###LH
	LB	R1,HSTKEY,HN		:GET SLOT# * 4  IF NON-MXP  (00SS)
					:    SLOT#,MACHINE# IF MXP  (00SM)
        IF      MXPNM			:IF MXP, CONVERT (00SM) TO (0M0S)
	EXBR	R0,R1			:R0 = (SM00)
        NHI     R0,0F00         	:R0 = (0M00)
        SRHLS   R1,4            	:R1 = (000S)
	OR	R1,R0		 	:R1 = (0M0S)
        ELSE	:NON-MXP, COMPUTE SLOT#
        SRHLS   R1,2			:(TRUE SLOT#. NOT SLOT# * 4)
        EI      :MXPNM
        OHI     R1,8080         	:SEND SLOT# (00SS) + 8080 IF NON-MXP
					:SEND MACHINE#,SLOT# (0M0S) + 8080 IF
					:MXP MACHINE			###LH
	JAL	R9,WHWI
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	IF	T2GATE
	OHI	R1,10			:For Gateway, always IIX	###ev
      :fixed above to OR in 10 (iix bit) from 80 (origination only bit)###sdw
	EI	:T2GATE
	EXBR	R1,R1			:INTO HO BYTE OF LO HW		###OAS
	LB	R0,HSTCST,HN		:GET MULTI-TARGET HOST COST	###OAS
	OR	R1,R0			:COMBINE AND WRITE		###OAS
	JAL	R9,WHWI
	LB	R1,HSTMBK,HN		:GET MUTI-BASED HOST KEY	###OAS
	EXBR	R1,R1			:INTO HO BYTE OF LO HW		###OAS
	IF	T2GATE
	LHI	R0,08B			:Gateway is prodid 8B		###ev
	ELSE
	LB	R0,HSTYPE,HN		:GET HOST TYPE (PID)		###OAS
	EI	:T2GATE
	OR	R1,R0			:COMBINE AND WRITE		###OAS
	JAL	R9,WHWI

LEPN8F	HS	0
	AIS	HN,1			:BUMP HOST INDEX		###OAS
	CLHI	HN,NHOSTS		:MORE HOST ENTRIES?		###OAS
	JL	LEPN8G			:YES, GO CHECK THEM		###OAS

:	FINISHED WITH TAKEOVER RESPONSE, NOW MAKE CRYPTO LOG ENTRY
LEP08M	LR	R0,PRC			:TELL XRAY
	JAL	R8,CRYPTO,,
	HC	CRYE05			:TAKEOVER

	TS	TAKOVR			:FOR DEFERRED TAKEOVER NODE REPORTS

	IF	ISIS&(1-T2GATE)		:INFORM DISPATCHER (but not if Gateway)
	LHI	HN,NHOSTS		:TELL SUP OF ALL HOSTS OUT 
LEP08N	HS	0			:OF PORTS.
	SIS	HN,1			:NEXT HOST
	JL	LEP08O			:DONE
	LHL	R0,HOSTN,HN,HN		:GET HOST #
	JEBS	LEP08N			:IF ZERO HE IS GONE
	LHL	R1,HSTPTA,HN,HN		:GET PORTS AVAILABLE
	JNBS	LEP08N			:NOT 0 PORTS, DON'T REPORT
	LIS	R6,1			:TELL SUP 1 HW
	STH	R0,SUPMBF		:SAVE HOST #
	LHI	R5,8F			:HOST OUT OF PORTS MSG
	JAL	R10,SUP14
	J	LEP08N			:CONTINUE

LEP08O	HS	0			:DONE WITH OUT OF PORTS REPORTING
	LIS	R0,4
	JAL	R8,DIROOM		:WAIT FOR ROOM
	LHL	PRD,DRIF,,
	LHI	R0,INTKVR^8		:PORT 0 TAKEOVER MESS		###jhl
	AH	R0,TVRSUP		:INCLUDE SUP # IN 'UNUSED' MSG BYTE
	ST	R0,DIRNG,PRD,
	AIS	PRD,4
	NHI	PRD,DRSZ-4
	STH	PRD,DRIF,,
	EI	:ISIS&(1-T2GATE)	:###EV
	LHL	R0,BCT+4,,		:ANY PORTS IN LOGIN MODE (IN BUFFER 4)?
	JEFS	LEP08P			:NO
	STH	R0,LOGZPF		:YES, TELL LOGGER TO ZAP THEM ALL

LEP08P	LIS	R6,NCCBUF
	LR	R7,R2
LEP08Q	LHL	R0,BCT,R6,		:ANY DATA IN TEMP STORAGE BUF?
	JEFS	LEP08R			:NO,MAKE KHOST REPORT,PERHAPS CRASH RPT
	LR	R2,R6
	JAL	R8,GCI			:COPY DATA FROM TEMPORARY BUFFER
	LR	R2,R7
	JAL	R8,WCI			:TO NEW COMMAND CIRCUIT BUFFER
	JBS	LEP08Q
LEP08R	LHI	R3,HST0			:GET KERNEL HOST NUMBER
	JAL	R9,HEXDEC,,		:GO DECIMAL
	GL	HEXDEC
	STH	R3,SUPMBF+2		:AND STORE AWAY
	LHI	R3,VERSIO		:GET VERSION NUMBER
	JAL	R9,HEXOCT,,		:GO OCTAL
	GL	HEXOCT
	STH	R3,SUPMBF+4		:AND STORE AWAY
	LHI	R3,NR.HVR		:REPORT KERNEL AND VERSION NUMBER
	STH	R3,SUPMBF
	JAL	R10,SUP12
	IF	T2GATE
	IF	\HNCOST
	LHI	R0,HNCOST		:Get specified cost
	LHI	R1,HHOST		:and H-net host #
	EXHR	R1,R1
	AR	R1,R0			:Make sup message content
	ST	R1,SUPMBF		:and store in sup mesage buffer
	LHI	R5,NCHCST		:Get message subtype 88
	JAL	R10,GSP14H		:and send it to sup
	EI	:\HNCOST
        LB      R1,HSTAT                :have to explicity say shut
        JEFS    LEP9TG                  :(shut if no INET supe)
        JAL     R10,SUP11
LEP9TG  HS      0
	EI	:T2GATE
	TS	CREPRT			:CRASH REPORT ALREADY MADE?
	JL	LEP1			:YES - DONE WITH TAKEOVER RESPONSE

:	REPORT CRASH WITH:
:	NODE REPORT node# TYPE 19 aabbbbbb
:	where:
:		19 - Node crash report
:		aa = crash reason code
:	    bbbbbb = crash address
:
:	FOLLOWED BY CRASH ADDENDUM REPORT1:
:	NODE REPORT node# TYPE 2A aabbccdd
:	where:
:		2A - First addendum to the node crash report
:		aa = Crash code extension
:		bb = Current crash count
:		cc = Node code version number + 80
:			<0=SWITCHER, 1=ISIS, 2=TYMSAT, 3=GATEWAY>
:		dd = 0	<80 + NO. OF ADDITIONAL CRASH ADDENDUM REPORTS
:			 (TYPE 2B) TO FOLLOW.>
:
:	FOLLOWED BY 0-2 CRASH ADDENDUM REPORTS (CONTENTS OF CRITICAL REGISTERS)
:		(not implemented)

	LIS	R7,0			:INDEX INTO ADDITIONAL CRASH DATA AREA
	LHL	R6,NXTCRP		:GET OFFSET INTO CRASH SUMMARY TABLE
					:FOR NEXT CRASH TO REPORT TO SUP.
	JEFS	LPCR00			:THIS IS THE LATEST CRASH
	LIS	R7,0A			:'OLD' CRASH ADDITIONAL DATA AREA
LPCR00	L	R0,CSMTBL+CS.PSD+4,R6	:CRASH ADDRESS
	LR	R6,R6			:LATEST CRASH?
	JEFS	LPCR10			:YES
	OI	R0,800000		:SET HO BIT OF CRASH ADDRESS TO
					:INDICATE THIS IS AN 'OLD' CRASH
LPCR10	ST	R0,SUPMBF+2		:CRASH ADDRESS TO SUP BUFFER
	LB	R0,CSMTBL+CS.CID+1	:COMMON CRASH CODE		###wjl
	STB	R0,SUPMBF+2		:TO SUP BUFFER
	LHI	R0,NR.CRP		:REPORT TYPE 19
	STH	R0,SUPMBF		:TO SUP BUFFER
	JAL	R10,SUP12

:	Make first addendum to the node crash report  
LPCR20	LB	R0,CSMTBL+CS.CID	:CRASH SUBTYPE CODE
	SLLS	R0,8			:SHIFT IT UP 1 BYTE		###wjl
	LB	R1,CRHCNT+1		:GET CURRENT CRASH COUNT	###wjl
	OR	R0,R1			:COMBINE AND
	EXHR	R0,R0			:SHIFT UP
	LI	R1,8080+((VERSIO&0F000)^-4) :COMBINE WITH HO NIBBLE OF VERSION
	OR	R0,R1			:COMBINE
:	R0 = CRASH SUBTYE<1BYTE>,CRASH COUNT<1BYTE>,VERSION TYPE+80,
:	NUMBER ADDENDA TO FOLLOW+80.
	ST	R0,SUPMBF+2
	LHI	R0,NR.CR1		:REPORT TYPE 2A
	STH	R0,SUPMBF		:to sup buffer			###wjl
	JAL	R10,SUP12		:MAKE REPORT TO SUP
LPCR30	LR	R6,R6			:WAS THIS FOR THE MOST RECENT CRASH?
	JEFS	LPCR40			:YES
	LIS	R7,0			:POINT TO LATEST CRASH
	LIS	R6,0
	STH	R6,NXTCRP		:INDICATE NEXT CRASH TO SEND IS LATEST
	J	LPCR00
LPCR40	J	LEP1			:ALL DONE

::*********************************************************************
::
::	SUBROUTINE:	CHKHST:
::	FUNCTION:	VERIFY THAT THE STATUS OF EACH HOST IS CORRECT
::	CALLING SEQ:	JAL	R7,CHKHST       CALLED FROM "LEP08"
::
::*********************************************************************

:       BEFORE PROCESSING TAKEOVER COMMANDS ON AN ISIS MACHINE, WE FIRST
:	NEED TO VERIFY THAT THE STATUS OF EACH HOST IS CORRECT.
:
:	CONSIDER THE FOLLOWING SITUATION:
:       IF HOST "A" GOES DOWN DURING A NODE CODE CRASH, ISIS TRIES
:       TO NOTIFY THE NODE CODE OF THE CHANGE IN STATUS, BUT THE NODE CODE
:	IS NOT THERE.
:       
:       THE NODE CODE DOESN'T CLEAR ALL THE HOST TABLES DURING RESTART, 
:       SO AFTER A NODE CODE RESTART, THE NODE CODE STILL HAS ALL
:       THE OLD HOST INFORMATION, AND DOESN'T KNOW THAT HOST "A" IS GONE.
:       HOW CAN THE NODE CODE CHECK IF ANY HOSTS WENT DOWN DURING A NODE
:	CODE CRASH?
:
:       DURING RESTART, NODE CODE SENDS AN "0F" COMMAND TO ISIS
:       REQUESTING HOST STATUS REPORTS FOR ALL HOSTS.  THIS WILL CAUSE
:       A SERIES OF "04" MESSAGES TO BE RETURNED TO THE NODE CODE.
:       THE NODE CODE WILL SET A FLAG, "HSTFLG", TO INDICATE
:       WHICH HOSTS IT HAS RECEIVED HOST STATUS REPORTS FOR FROM ISIS SINCE
:       THE LAST RESTART.  THEREFORE, FOR THOSE HOSTS IN THE HOST TABLE FOR
:	WHICH WE HAVE NOT RECEIVED HOST STATUS REPORTS FROM ISIS AFTER
:	RESTART, WE CAN BE SURE THOSE HOSTS ARE GONE, AND WE NEED TO NOTIFY
:	THE SUP OF THEIR "GONE" STATUS, AND CLEAR THE HOST ENTRY FOR THOSE
:	HOSTS.

        IF      ISIS&(1-T2GATE)		:###EV

CHKHST  HS     0
        LIS    HN,1			:THE SECOND ENTRY TO HOST TABLE
					:SKIP THE FIRST ENTRY 0, SINCE IT IS
					:KERNEL HOST.
CHKENT  HS     0
        LHL    R1,HOSTN,HN,HN		:CHECK HOST TABLE FOR HOST ENTRIES
        JE     CHKNXT			:NO HOST AT THIS ENTRY, GO CHECK NEXT

:       YES, THERE IS A HOST AT THIS ENTRY.
:       CHECK IF WE RECEIVED A HOST STATUS REPORT FOR THIS HOST SINCE LAST
:       RESTART.
        TBT    HN,HSTFLG		:IS FLAG SET ?
        JN     CHKNXT			:YES,RECEIVED STATUS REPORT SINCE LAST 
					:RESTART, GO CHECK NEXT

:       NO STATUS REPORT RECEIVED SINCE LAST RESTART.
:       THIS HOST GONE, NOTIFY SUP OF STATUS, AND CLEAR ENTRY.
HSTGON  HS     0
        LIS    R0,3			:STATUS IS "GONE"
        LHI    R14,1180			:HOST STATUS REPORT WITHOUT TYPE FIELD
        OR     R14,R0			:COMBINE WITH STATUS
        LIS    R4,0			:INDICATING NO PID
        STB    R0,HSTAT,HN		:SAVE HOST STATUS

:	UPDATE HSTATN AND TIME OF UPDATE (USED FOR EXPANDED HOST STATUS)
        SLLS   R0,6			:MOVE HSTAT (BITS 6,7) TO HSTATN 
					:(BITS 0,1)
        LB     R1,HSTATN,HN		:GET HSTATN
        NHI    R1,0FF-EHSTTS		:STRIP OFF OLD STATUS BITS
        OR     R1,R0			:COMBINE WITH STATUS
        STB    R1,HSTATN,HN		:RESTORE
        JAL    R9,GMTCAL,,		:GET CURRENT GMT
        L      R0,GMTNOW,,		:FOR TIME OF LAST STATUS UPDATE
        SLLS   HN,1			:FORM FW INDEX INTO HOST TIME ARRAY
        ST     R0,HSTTIM,HN,HN		:STORE CURRENT TIME
        SRLS   HN,1			:RESTORE HN

:       SEND  STATUS REPORT TO SUP
        JAL    R10,SUPHS,,		:SEND [11,80+STATUS] TO SUP
        GL     SUPHS
        LHL    R0,HOSTN,HN,HN
        STH    R0,CRYSBF+2,,
        LB     R0,HSTAT,HN
        JAL    R8,CRYPTO,,
        HC     CRYE15			:CHANGE IN HOST STATUS 
     
:       DELETE THIS HOST FROM HOST TABLE
        LIS    R0,0        
        STH    R0,HOSTN,HN,HN		:CLEAR ENTRY
        STB    R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST
        STB    R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY
        STB    R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)
        STB    R0,HSTAT			:CLEAR HOST STATUS
        STB    R0,HSTATN		:CLEAR EXTENDED HOST STATUS
        SLLS   HN,1			:FORM FW INDEX INTO HOST TIME ARRAY
        ST     R0,HSTTIM,HN,HN		:CLEAR TIME ARRAY
        SRLS   HN,1			:RESTORE HN

:       CHECK NEXT HOST ENTRY
CHKNXT  HS     0
        AIS    HN,1			:BUMP HOST INDEX
        CLHI   HN,NHOSTS-1		:MORE HOST ENTRIES?  (EXCEPT KERNEL
					:HOST)
        JLE    CHKENT			:CHECK NEXT ENTRY		:###cwc
        JR     R7			:DONE, RETURN

        EI      :ISIS&(1-T2GATE)

	SUBTTL	LEP (LEP09 - Type 9:  Circuit building command)

::*********************************************************************
::
::	COMMAND:	LEP09:
::	FUNCTION:	PROCESS CIRCUIT-BUILDING REQUESTS (TYPE 9)
::
::*********************************************************************

LEP09	HS	0
	LR	R5,R2			:NEEDLE, SAVE SUP BUFF # AND GET
	JAL	R8,GFCBUF		:A BUFFER PAIR FOR NETWORK-BOUND DATA
	J	OP8463			:immed. return - out of buffers!###wjl
	LR	R7,R2			:+4 return, ok - SAVE IT IN R7

	SRLS	R2,1			:SET UP BUFTIM INDEX
	NHI	R2,-4
	L	R0,FASTC,,		:STORE FASTC TIME THAT
	ST	R0,BUFTIM,R2,		:NEEDLE ORIGINATES IN NODE

	LHI	R6,-2,LRC		:COPY OVER THE REST OF NEEDLE
	IF	EXPNDL
	LIS	R9,3			:counter to link count byte
	JAL	R10,LEP90A
	SIS	R6,1			:do this for the last byte
	NHI	R1,7F			:strip high order bit from link count
	STH	R1,CQNLK
	LIS	R9,4			:counter to first byte of FLAGS hw
	JAL	R10,LEP90A
:	Check for SNI list attached to needle.
:	If one is there we must write it to the SNIBUF buffer, instead
:	of to the network bound buffer.
SNICHK	HS	0
	SIS	R6,1			:we missed doing this above
	THI	R1,NF.SNI^-8		:test for presence of SNI list
	JE	LEP09A			:if no list, just copy the needle 
:	Note--We can assume that we have neither a TYMNET-I origination
:	nor termination if there is an SNI list present.

:	Needle has SNI list appended.  Copy needle up to the list into
:	the network-bound buffer, and then get a new buffer and copy
:	the SNI list into it for later processing.
:	We have now copied the buffer as far as the first byte of the
:	FLAGS halfword into the network-bound buffer.
	JAL	R8,GFCBUF,,		:get a free buffer for SNI list
	J	OP8463			:immed. return - out of buffers!###wjl
	ST	R2,SNIBUF,,		:+4, keep buffer number for later use
	LIS	R9,0B			:number HW's left, exclusive of node
					:list, up to start of user data field 
	AH	R9,CQNLK		:add 2 bytes per node in link list
	AH	R9,CQNLK
SNICH3	LR	R2,R5			:R5 has buffer # from sup
	JAL	R8,GCI
	LR	R2,R7			:put data into new net-bound buffer
	JAL	R8,WCI
	SIS	R6,1			:decrement needle length counter
	LR	R1,R1			:is it a data escape?
	JEFS	SNICH4
	SIS	R9,1			:dec to-username counter
	JGBS	SNICH3
	JFS	SNICH5

SNICH4	LR	R2,R5			:R5 has buffer # from sup
	JAL	R8,GCI,,		:read out the escaped character
	LR	R2,R7			:put data into new net-bound buffer
	JAL	R8,WCI,,
	SIS	R6,1			:decrement needle length counter
	SIS	R9,1			:dec count only by data--not by escapes
	JG	SNICH3
:	We have arrived at the user data field.
SNICH5	LR	R2,R5			:get from-sup buffer
	JAL	R8,GCI,,
	LR	R2,R7			:get net-bound buffer
	JAL	R8,WCI,,
	SIS	R6,1			:decrement needle length counter
	CLHI	R1,ASCCR+80
	JEFS	SNIC52
	CLHI	R1,ASCSMC+80
	JNBS	SNICH5
SNIC52	L	R9,SNIBUF,,		:prime for SNI list write
	LR	R2,R5
	JAL	R8,GCI,,
	CLHI	R1,80			:it's a pad char or first SNI header
	JN	SNIC62
	LR	R2,R7
	JAL	R8,WCI,,		:write pad char to net-bound buffer
	SIS	R6,1			:decrement needle length counter

:	We are now pointing to the SNI list.  
:	Write the SNI list into SNIBUF for later processing.
	JEFS	SNIC64			:if end of needle, go process(ERROR)
SNICH6	LR	R2,R5			:get byte from the needle buffer
	JAL	R8,GCI,,
SNIC62	LR	R2,R9			:write into the SNI buffer
	JAL	R8,WCI,,
	SIS	R6,1			:decrement needle length counter
	JGBS	SNICH6

SNIC64	LR	R2,R7			:need net-bound buffer in R2
	JFS	LEP90C
	EI	:EXPNDL

LEP09A	LR	R2,R5			:R5 HAS BUFFER # FROM SUP
	JAL	R8,GCI
	LR	R2,R7			:PUT DATA INTO NEW NET-BOUND BUFFER
	JAL	R8,WCI
	SIS	R6,1			:DECREMENT COUNT
	JGBS	LEP09A			:LOOP FOR ALL THE DATA
:	Next set up the net-bound buffer in the proper format
LEP90C	JAL	R9,GHWI			:REMOVE NODE #
	JAL	R8,GCI			:AND MESSAGE TYPE
	LIS	R1,0			:PRECEDE LINK CNT BY AN ESCAPE
	JAL	R8,WCD
	JAL	R8,WCD			:LEAVE A SLOT FOR BYTE CNT
	L	PRD,BB,R2,		:SAVE PTR TO SAME
	JAL	R8,WCD			:PRECEDE BYTE CNT BY AN ESCAPE
	LHI	R1,NEEDP		:INSERT NEEDLE POINT
	JAL	R8,WCD
	EXBR	R1,R1
	JAL	R8,WCD
	JAL	R8,CBCCT		:GET THE RESULTING BYTE COUNT
	STB	R1,0,PRD		:AND PUT IT AWAY
	STH	R2,CQNBUF		:SAVE THE NET-BOUND BUFF # IN CASE

:	NEEDLE HAS BEEN ASSEMBLED IN BUFFER, NOW PROCESS THE ORIGIN:

	L	R3,BB,R2,		:SET UP FOR PEEK ROUTINES
	JAL	R9,PHWI			:SKIP NEEDLE POINT
	JAL	R9,PHWI			:GET BYTE AND LINK COUNTS
	NHI	R1,7F			:SAVE LINK COUNT
	STH	R1,CQNLK
	JAL	R9,PHWI			:SAVE INVOICE #
	STH	R1,CQINV
	JAL	R9,PHWI
	STH	R1,CQINV+2,,
	JAL	R9,PHWI			:GET THE FLAGS
	LR	R7,R1			:SAVE NEEDLE FLAGS IN R7
	STH	R7,NEDFLG		:	AND IN MEMORY
	JAL	R9,PHWI			:SAVE REQUESTING NODE
	STH	R1,CQNODE
	JAL	R9,PHWI			:GET REQUESTING PORT#
	IF	NEWALI
	THI	CHN,6000		:FOR CONSAT PORT IN LOGIN? IF SO,
					:AT LEAST ONE OF THESE BITS WILL BE SET
	JE	LEP09B			:NO, CONTINUE
	LR	R8,R1			:SAVE FOR CKTKEY CHECK
	NHI	R1,1FFF			:ISOLATE CHANNEL#
	NHI	R8,6000			:ISOLATE KEY
	CLH	R8,CKTKEY-(2*ANIZFL),R1,R1	:DOES KEY MATCH?
	JN	LEP09Z			:NO, NOT FOR US, ABORT
	LIS	R0,0			:RE-INIT CKTKEY
	STH	R0,CKTKEY-(2*ANIZFL),R1,R1	:BACK TO 0
	SIS	R3,2			:BACK UP BUFFERLET POINTER
	STH	R1,0,R3			:WRITE ABSOLUTE CHANNEL # INTO BUFFER
	AIS	R3,2			:RESTORE BUFFERLET POINTER
	EI	:NEWALI
LEP09B	STH	R1,CQPORT		:SAVE REQUESTING PORT
	LR	CHN,R1			:IT'S OUR ABSOLUTE CHAN #
	THI	R7,NF.REB		:IS THIS A REBUILD NEEDLE?
	JN	LEP09R			:YES, A REBUILD IS IN PROGRESS
	LHL	R0,CQNLK		:NO...ORIGINAL CIRCUIT. IS IT INTERNAL?
	JNFS	LEP09G			:NOT INTERNAL, SET UP REBILD PARAMETERS
	IF	ISIS
:	INTERNAL CIRCUIT - SAVE DESTINATION HOST NUMBER TO TEST
:	FOR KERNEL HOST OR XRAY.
	LR	R6,R3			:SAVE BB	
	JAL	R9,PHWI			:NEXT HW IS DESTINATION HOST+8000
	NHI	R1,7FFF
	STH	R1,CQDHST		:INTERNAL CIRCUIT DESTINATION HOST #
	LR	R3,R6			:RESTORE BB (STILL POINTS TO DEST HST)
	EI	:ISIS
	IF	REBILD
	J	LEP09N			:NO HISTORY REQUIRED FOR INTERNAL CIRC
	EI	:REBILD

:	INITIALIZE THE VARIABLES ASSOCIATED WITH THE ORIGIN OF A
:	REBUILDABLE CIRCUIT.

LEP09G	HS	0
	IF	REBILD
	ST	R3,TRCSV1		:TEMP STORE,POINTS TO 1ST OF NODE LIST
	JFS	LEP9G2
LEP9G1	STH	R1,CQHOST,,		:SAVE IN CASE THIS IS THE BASE
LEP9G2	JAL	R9,PHWI			:READ NEXT NODE #
	THI	R1,8000			:IF NEG IT'S HOST #
	JEBS	LEP9G1			:POSSIBLY BASE
	LR	R3,R2			:HOST # IN R1, COMPUTE HIST BUFF #
	SRHLS	R3,1
	AI	R3,HBUFN
	STH	R7,RNFLAG,R3,		:SAVE NEEDL FLAGS, HOST, INVOICE
	STH	R1,RHOSTN,R3,
	LHL	R0,CQHOST,,
	STH	R0,RBASE,R3,
	L	R0,CQINV
	ST	R0,RINVC,R3,
	LR	R1,R7			:COMPUTE 2*BP CONSTANT* # LINKS-BP
	HSIZE(R1)			:COMPUTE SIZE BASED ON SPEED BITS###CY
	STH	R0,RHBSZ,R3,
	L	R3,TRCSV1		:RESTORE PEEK PTR
	EI	:REBILD

:	TEST FOR CIRCUIT BUILDING REQUEST COMING FROM A T-1 NEIGHBOR

LEP09N	HS	0
:	IF	(1-KILLT1)
	THI	R7,NF.T1O		:IS T-1 ORIG BIT IN NEEDLE FLAG SET?
	JN	LEP09T			:YES, REQUESTING 'PORT' IS A T-1 NODE
:	EI	:(1-KILLT1)
	LHL	R6,IOTAB,CHN,CHN	:NO, PORT IS SOME INTERNAL INTERFACE
	NHI	R6,-4			:CHECK THE PORT'S OUTBOUND BUFFER
	JE	LEP09F			:NO PERMTR TABLE ENTRY MADE YET,PROCEED
	LHL	R1,BF,6,		:THERE'S ALREADY A PERMUTER TABLE ENTRY
	CLHI	R1,LOGMIN		:..THE PORT HAD BETTER BE IN LOGIN MODE
	JL	LEP09U			:NOT IN LOGIN MODE,GENERATE DIAGNOSTICS
	CLHI	R1,LOGMAX
	JG	LEP09U			:NOT IN LOGIN MODE...CHANNEL IN USE ERR

LEP9N1	JAL	R9,LOGCLR		:CLEAR BUFF # FROM LOGGER LIST
	LCS	KD,1			:INDICATE T-II TERM, KD POSITIVE IF T-I
:	IF	1-KILLT1		:##AL
	J	LEP09V

:	HANDLE TYMNET-I ORIGIN
LEP09T	JAL	R9,CHWI			:TYM-I ORIGIN - 'CREAM' NODE #
	GL	CHWI
	JAL	R9,FNDLNK,,		:GET ITS LINK #
	J	LEP09H			:NOT THERE
	TBT	KN,ALINKS
	JE	LEP09H			:LINK IS DOWN
	JAL	R9,CHWI			:GET THE CHANNEL #
	LHL	CHN,LKZFKN,KN,KN	:COMPUTE THE ABSOLUTE CHANNEL #
	AR	CHN,R1
	LHL	R6,IOTAB,CHN,CHN	:IS ASSIGNED CHANNEL ENTRY NULL?
	JE	LEP9TI			:YES
	LHL	R1,BF,R6,		:WAS 'ASSIGN CHANNEL' COMMAND RECEIVED
	CLHI	R1,EARLFL		:FROM SUP FOR THIS CHANNEL?
	JN	LEP09U			:NO, SOMETHING IS WRONG

:	GOT A T-1 ORIGIN WITH THE PERMUTER TABLE ENTRY ASSIGNED. CHECK
:	FOR 'EARLY DATA' SENT BY T-1 NEIGHBOR WHILE WE WERE WAITING
:	FOR THE NEEDLE TO ARRIVE FROM THE SUP.
:	EI	:(1-KILLT1)

:	Or came here after deciding that needle has a TII origination.

LEP09V	LR	R7,R2			:CHECK FOR 'EARLY ZAP' IN FROM-TERM BFR

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,LP9DB1,,
	GL	LP9DB1
	L	R4,REGST,,
	EI	:LPGDBG

	L	R3,BB,R6,		:SET UP FOR A PEEK
	JAL	R8,PCI
	SIS	R1,3			:BY TESTING FOR AN 03...
	JN	LEP9V2			:NO ZAPPER, APPEND WHATEVER DATA
	JAL	R8,PCI			:SOMETHING IS UP, LOOK AT NEXT BYTE
	CLHI	R1,ZAPPH&0FF		:IS IT A HARD ZAPPER?
	JEFS	LEP9V1			:YES, ZAP CIRCUIT
	CLHI	R1,ZAPPN&0FF		:OR A NON-GOBBLING ZAPPER?
	JN	LEP9V2			:NO, JUST PASS ON WHATEVER IT MAY BE

:	GOT AN 'EARLY ZAPPER' FROM AN ORIGINATING T-1 PORT -
:	MUST CLEAR THE CIRCUIT TO PREVENT DEAD ENDS, SO
:	SEND A NON-GOBBLING ZAPPER AFTER NEEDLE SO THAT THE
:	T-II DESTINATION WILL SEND A NEEDLE ACK TO SUP.

LEP9V1	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	ST	R3,RGST,,
	LIS	R3,1			:CASE # 1
	JAL	R4,LP9DB2,,
	GL	LP9DB2
	L	R4,REGST,,
	L	R3,RGST,,
	EI	:LPGDBG

	LHI	R1,ZAPPN		:SEND A NON-GOBBLING ZAPPER
	JAL	R9,W2CI
	IF	(1-T2GATE)
	LIS	R0,0			:CLEAR PERMUTER ENTRY
	STH	R0,IOTAB,CHN,CHN
	EI	:(1-T2GATE)		:Gateway uses Zap Ack to clean up

	IF	T2GATE
	LHI	R1,-DISZFL,CHN		:F.T. buf must be dispatcher channel
	RBT	R1,DISFLG,,		:Possible 3E63 crash averted
	SBT	R1,DISZNK		:Prepare for ZAPV
	LR	R0,CHN			:Save absolute channel number
	LR	CHN,R1			:Use rel dispatcher port
	LHI	R1,09F00		:to clear for reuse
	JAL	R8,DIRMES
	LIS	R1,0
	STH	R1,BF,R6,		:Prepare for Zapv to return buffer
	LR	CHN,R0			:Restore absolute channel for crypto
	EI	:T2GATE

:	FOR SOLO CONSAT, WE NEED TO RESET LOGSTB.
:	WE NO LONGER NEED SPECIAL TREATMENT BY ASYLOU	###LSH
	IF	SOLOCS
	LHI	R2,-ANIZFL,CHN		:MAKE SURE IT'S AN ANI PORT
	JL	LP9V1A			:NO, JUMP
	CLHI	R2,NANIPT	
	JGE	LP9V1A			:NO, JUMP
	RBT	R2,LOGSTB,,
LP9V1A	HS	0
	EI	:SOLOCS	###LSH
	IF	(1-T2GATE)		:Gateway must hold until Zap Ack clears
	SBT	CHN,ACP,,		:FREE THE CHANNEL'S ACP BIT
	LCS	R2,1			:SET NEGATIVE ACP ARRAY ALSO
	SR	R2,CHN
	SBT	R2,ACP,,
	LR	R2,R6			:RETURN ORIGINAL BUFFER
	JAL	R8,RFCBUF
	GL	RFCBUF
	EI	:(1-T2GATE)
	LR	R2,R7			:ALERT CRQ OF NEEDLE BY WRITING NEEDLE
	JAL	R9,CRQALT		:BUFFER NUMBER INTO BUFFER 0
	JAL	R8,CHNLNK,,		:GO FIND NEIGHBOR
	GL	CHNLNK
	NOP	R0,0
	NOP	R0,0
	EXHR	R0,CHN			:MOVE CHAN TO UPPER HW OF R0
	OR	R0,R3			:COMBINE WITH T-1 NEIGHBOR NUMBER
	JAL	R8,CRYPTO,,		:REPORT ZAPPER
	HC	CRYE18			:MESSAGE - EARLY ZAPPER
	J	BIDDRT,,		:EXIT - CAN DO NO MORE FOR THIS CIRCUIT

:	NO ZAPPER--APPEND DTA IN FROM-TERM BUFFER TO OUR NEW
:	NETWORK-BOUND BUFFER
LEP9V2	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	ST	R3,RGST,,
	LIS	R3,2			:CASE # 2
	JAL	R4,LP9DB2,,
	GL	LP9DB2
	L	R4,REGST,,
	L	R3,RGST,,
	EI	:LPGDBG

	JAL	R9,APPEND		:NO ZAPPER, APPEND DATA
	GL	APPEND

:	FOR THE SOLO CONSAT, WE NEED TO UPDATE THE PORT TABLES (.ALBUF)
:	WITH THE NEW BUFFER ASSIGNED AS .ALBUF.	###GT
	IF	SOLOCS			:BECAUSE TABLES FOR SOLOCS ARE SO MESSY
	LHI	R2,-ANIZFL,CHN		:MAKE SURE IT IS AN ASYNC PORT
	JL	LP9V2A			:NO - JUST GO AWAY
	CLHI	R2,NANIPT		:###LSH
	JGE	LP9V2A
	TBT	R2,LOGSTB,,		:IS THIS A HUNG PORT?		###LSH
	JN	LP9V2A			:YES, IGNORE THE FOLLOWING	###LSH
	LHI	R2,ALMZFL-ANIZFL,CHN	:GET THE INDEX INTO ALMTAB
	LHL	R2,IOTAB,R2,R2		:GET .TTBUF
	NHI	R2,-4
	LHL	R2,BF,R2,		:GET ASYNC PORT NUMBER
	JLE	LP9V2A			:PORT IN THE PROCESS OF ZAP	###LSH
	SHI	R2,ASYZFL		:THIS IS THE ABSOLUTE PORT NUMBER
	AR	R2,R2			:FORM HALFWORD INDEX
	LHL	R2,.PTP.,R2,		:PORT TABLE POINTER
	AI	R2,PTBASE		:FORM PORT TABLE ADDRESS
	ST	R7,.ALBUF,R2		:ENTER THE NEW BUFFER PAIR AS .ALBUF
LP9V2A	HS	0
	EI	:SOLOCS	###GT
	LR	R2,R6			:RETURN DATA (FROM-TERM) BUFFER
	JAL	R8,RFCBUF
	LR	R2,R7			:NET-BOUND IS NOW THE RELEVANT BUFFER
:	IF	1-KILLT1
	LR	KD,KD			:T-I ORIGIN FOLLOWING 'ASSIGN CHANNEL'?
	JLFS	LEP09F			:NO (SEE LEP9N1)
LEP9TI	LIS	R0,1			:RECORD ADDITIONAL ACTIVE CHANNEL
	AHM	R0,ANCHN,KD		:TO TYMNET-I NEIGHBOR
:	EI	:1-KILLT1
LEP09F	JAL	R9,CRQHCR		:BUILD HALF CIRC TO OUR REQUESTING PORT
	IF	ISIS
	LHI	R1,-DISZFL,CHN		:IS REQUESTING PORT A DISPATCHER PORT?
	JL	LEP9F1			:NO, TOO LOW
	CLHI	R1,NDP			:TEST UPPER BOUND
	JGE	LEP9F1			:TOO LARGE, NOT A DISPATCHER PORT
	SBT	R1,DISBPV		:FOR A DISPATCHER PORT,FIRST RELIEVE BP
	LHI	R0,INXLIM		:AND GIVE IT XMIT CAPACITY
	STH	R0,DIXLIM,R1,R1

	IF	T2GATE
	RBT	R1,LOGING		:No longer in Log-in mode
::If IIX circuit - must send IIX reached ##/## host reply
	TBT	R1,GIIXCT
	JE	GASTRT
	LHL	R0,NEDFLG		:Get needle flags
	THI	R0,NF.SMC
	JEFS	GLPNSM			:Not smart
	LA	R4,IIXGRS,,		:Smart
	JFS	GLPSND
GLPNSM	LA	R4,IIXGRD,,
GLPSND	XHI	R2,4			:Flip to terminal bound buffer
	JAL	R9,BUFCAN		:send it
	XHI	R2,4			:Back to sup bound bffer

::Circuit initiation  complete -  initiate accounting 
	IF	ACCT
	GL	AASTRT,GASTR1,AASWAP
GASTRT	HS	0
	ST	R2,GASTOR,,
	LR	R3,CHN
	CLHI	R3,MNACHN
	JL	GASKIP
	CLHI	R3,MXACHN
	JG	GASKIP		:Range check on the absolute chan
	SHI	R3,MNACHN
	JAL	R9,AAMKPT,,	:Make pointer to the accounting block
	L	R0,AAINV,R11	:Get previously stored  Invoice number
	ST	R0,ININV,,	:Store temporarily
	XI	R0,80000000	:Check high order bit (should be set)
	JL	GASKIP
	JAL	R8,GASTR1,,	:Initiate accounting
	NOP			:Need this 4 bytes for the normal return
	JAL	R10,AASWAP,,	:and swap invoice numbers
	L	R0,AAINV,R11	:R11 still hold accounting pointer, get inv#
	OI	R0,0C0000000	:Mark as origin circuit - do not report
	ST	R0,AAINV,R11
GASKIP	HS	0
	L	R2,GASTOR,,
	EI	:ACCT

	ELSE	:(1-T2GATE)		:Gate does not send back "needle eye"
	XHI	R2,4			:FLIP TO ISIS-BOUND BUFFER
	LHI	R1,NEEDE		:SEND NEEDLE EYE TO DISPATCHER
	JAL	R9,W2CI
:	SEND NEEDLE FLAGS TO CIRCUIT ORIGINATION WITH NEEDLE EYE. FLAGS
:	INDICATE IIX SMART CIRCUITS, ALSO INTERNAL CIRCUITS.
	LHL	R1,NEDFLG		:NEEDLE FLAGS, FROM CIRCUIT NEEDLE
	THI	R1,NF.T1D		:TYMNET-I DESTINATION?
	JNFS	LEP9F0			:YES - NOT AN INTERNAL CIRCUIT
	OHI	R1,NF.INT		:MAY BE UNNECESSARY, BUT SAFE
	LHL	R0,CQNLK		:IF ZERO LINKS, THIS IS INTERNAL CIRC
	JNFS	LEP9F0			:NOT INTERNAL - NF.INT LEFT SET
:	DON'T INDICATE INTERNAL CIRCUIT TO ISIS IF DESTINATION HOST
:	IS NOT A DISPATCHER HOST (I.E. KERNEL HOST OR XRAY)...
	LHL	R0,CQDHST
	CLHI	R0,HST0			:KERNEL HOST AS DESTINATION?
	JEFS	LEP9F0			:YES, DON'T INDICATE ISIS INTERNAL CIRC
	XHI	R1,NF.INT		:INTERNAL CIRCUIT - RESET NF.INT
LEP9F0	JAL	R9,WHWI			:NEEDLE FLAGS TOWARD DISPATCHER INTERFC
	LHL	R1,CQINV
	JAL	R9,WHWI			:APPEND INVOICE #
	LHL	R1,CQINV+2,,
	JAL	R9,WHWI
	EI	:(T2GATE)	
	IF	EXPNDL
	L	R9,SNIBUF,,		:set up peek pointer into SNIBUF
	JE	LP9F15			:no buffer--no SNI list
	L	R3,BB,R9,
:	parse SNI list for valid syntax.  Zap if bad form. (implement)
LP9F24	JAL	R8,PCI			:get the SNI header
LP9F25	LR	R6,R3			:save running BB pointer,clobbrd in WCI
	JAL	R8,WCI			:write SNI header to the slot
	LR	R3,R6			:restore peek pointer
	LR	R0,R1			:lift out the type bits
	NHI	R1,0FF-SNITYP		:get which WHAT it is
	CLHI	R1,SNITRM		:is this the list terminator?
	JE	LP9F12			:if so, get out of here

	CLHI	R1,SNIUUN		:min valid value
	JL	LPSNIR			:crypto and exit
	CLHI	R1,SNILGC		:max valid value
	JG	LPSNIR			:crypto and exit

	NHI	R0,SNITYP		:R0 has type now--use for length
	JE	LP9F24			:type 0 is already processed
	SIS	R0,1			:is it type 1?
	JE	LPTYP1			:process type 1
	SIS	R0,1			:is it type 2?
	JE	LPTYP2			:process type 2
:	fall through to type 3
	JAL	R9,PCI			:get char count
	LR	R7,R1			:save it in R7
	LR	R6,R3			:save peek pointer 
	JAL	R8,WCI			:write to the slot
	LR	R3,R6			:restore peek pointer
LP3GET	JAL	R9,PCI			:get character
	LR	R6,R3			:save peek pointer
	JAL	R8,WCI			:write char to slot
	LR	R3,R6			:restore peek pointer
	SIS	R7,1			:decrement the count
	JGBS	LP3GET			:loop for next character
	J	LP9F24			:next list entry

LPTYP2	JAL	R9,PHWI			:peek at next halfword (strips escapes)
	LR	R6,R3			:preserve peek pointer
	JAL	R9,WHWI			:write escaped data to DISPI
	LR	R3,R6			:restore peek pointer
LPTYP1	JAL	R9,PHWI			:peek at next halfword
	LR	R6,R3			:preserve peek pointer
	JAL	R9,WHWI			:write escaped data to DISPI
	LR	R3,R6			:restore peek pointer
	J	LP9F24			:get next list entry

LPSNIR	LR	R0,R1			:HW0 and HW1 (ADDRESS) holds bad SNI
	ST	R7,CRYSBF,,		:put needle flags in HW2 and HW3
	JAL	R8,CRYPTO,,		:send wild card message to crypto log
	HC	CRYE71			:and ignore the rest of the mess

LP9F12	LR	R6,R2			:save R2 for a moment
	L	R2,SNIBUF,,		:get the SNI list holder
	JAL	R8,RFCBUF,,		:return to the free list
	LIS	R2,0
	ST	R2,SNIBUF,,		:zero the buffer cell for next pass
	LR	R2,R6			:restore R2
LP9F15	EI	:EXPNDL

	IF	T2GATE
	JFS	LEP9F1			:CRQALT done here to outbound circuit
	ELSE
	XHI	R2,4			:RESTORE BUFFER POINTER NET-BOUND###GT
	JFS	LEP9F2			:SKIP CRQALT (WILL BE DONE IN DISPI)
	EI	:T2GATE
	EI	:ISIS

	IF	SOLOCS
	LHI	R1,-ANIZFL,CHN		:IS REQUESTING PORT A CONSAT PORT?
	JL	LEP9F1			:NO, TOO LOW
	CLHI	R1,NAPRT2		:UPPER LIMIT OF ASYNC INTERFACE PORTS
	JGE	LEP9F1			:TOO LARGE, NOT FOR A CONSAT PORT
	TBT	R1,LOGSTB,,		:IS THIS A HUNG PORT?		###GT
	GL	LOGSTB
	JN	LEP9F1			:YES - IGNORE THE FOLLOWING	###GT
	XHI	R2,4			:CONSAT PORT, FLIP TO CONSAT INPUT BUFF
	LIS	R1,3
	JAL	R8,WCI			:AND DEPOSIT NEEDLE EYE
	LHI	R1,NEEDE&0FF
	JAL	R8,WCI

:	SEND TWO TYPE 14 STYPE 9 MESSAGES TO SUP. FIRST MESSAGE IS ACCOUNTING
:	TYPE 7 (INVOICE NUMBER) AND THE SECOND IS ACCOUNTING TYPE 14
:	STYPE 9 (REPORT PHYSICAL PORT NUMBER). THESE REPORTS GIVE THE
:	SUP THE PHYSICAL ASYNC PORT NUMBER OF THE ORIGINATING PORT.

	LHI	R11,ALMZFL-ANIZFL,CHN	:GET ABSOLUTE CHAN NUMBER IN ALMTAB
	LHL	R11,IOTAB,R11,R11	:AND ITS BUFFER NUMBER
	NHI	R11,-4
	LHL	R11,BF,R11,		:GET ABSOLUTE CHANNEL NUMBER IN ASYTAB
	SHI	R11,ASYZFL		:GET ABSOLUTE PORT NUMBER	###GT
	LHL	R0,CQNLK		:GET THE LINK COUNT
	STB	R0,ASYLNK,R11,		:AND SAVE IT FOR XRAY DISPLAY
	GL	ASYLNK
	LR	R12,R2			:SAVE THE BUFFER NUMBER
	LHI	R5,89			:MESSAGE SUBTYPE - ACCOUNTING
	LI	R0,70000000		:ACCOUNTING MESSAGE - INVOICE NUMBER
	O	R0,CQINV
	ST	R0,SUPMBF		:DEPOSIT IT
	LIS	R1,4			:FLAG TO INDICATE CONSAT MESSAGE
	LIS	R6,2			:MESSAGE LENGTH IN HW
	JAL	R10,SUP14		:GO MAKE SUP MESSAGE
	IF	NMPVC
	CLHI	R11,.MPORT		:IS IT A MPVC PSEUDO-PORT? 	###GT
	JL	LP9F1A			:NO -PROCEED AS USUAL		###GT
	LHI	R11,-.MPORT,R11		:YES - GET PSEUDO PORT NUMBER	###GT
	AR	R11,R11	
	L	R0,CQINV		:GET INVOICE # FOR THIS SESSION ###GT
	ST	R0,MPINVC,R11,R11	:SAVE FOR FUTURE MPVC ACCOUNTING###GT
	GL	MPINVC
	LHL	R11,ASNPUT,R11,		:GET PHYSICAL PORT # FOR THIS MPVC
	GL	ASNPUT
LP9F1A	HS	0			:PSEUDO PORT			###GT
	EI	:NMPVC
	LI	R0,0E0090000,R11	:ACCOUNTING MESSAGE - PHYSICAL PORT #
	ST	R0,SUPMBF
	LIS	R1,4			:FLAG TO INDICATE CONSAT MESSAGE
	LIS	R6,2			:MESSAGE LENGTH IN HW
	JAL	R10,SUP14		:MAKE SUP MESSAGE

	LR	R2,R12			:RECOVER BUFFER NUMBER
	XHI	R2,4			:FLIP TO BUFFER WITH NEEDLE
	EI	:SOLOCS:*:

LEP9F1	JAL	R9,CRQALT		:ALERT CRQ TO NEEDLE
LEP9F2	SRHLS	R2,3			:MAKE CRQ INDEX			###CY
	SBT	R2,CRQEND		:CIRCUIT ENDPOINT CREATED
	RBT	R2,REBTMO,,		:CLEAR CRQ TIMEOUT (SEE LEP11)  ###CY
	RBT	R2,REBTMI,,
	IF	REBILD
	LHL	R0,CQNLK		:INT CRQ NOT REBUILDABLE	###CY
	JE	BIDDRT,,		:				###CY
	SBT	R2,CRQBSY		:REBUILDABLE CIRCUIT IN USE
	RBT	R2,SQFTMO		:CLEAR REBUILD TIMEOUT
	SBT	R2,SQFTMI		:SET REBUILD TIMER
	SLHLS	R2,3			:RESTORE BUFFER INDEX		###GT
	JAL	R9,SNDFX0		:SEND SEQ FIX 0			###CY
	GL	SNDFX0
	EI	:REBILD

	
	J	BIDDRT,,		:ALL DONE

:	PROCESS ARRIVAL AT ORIGIN OF A REBUILD NEEDLE:

	IF	REBILD

LEP09R	JAL	R9,FNDCRQ,,		:REBUILD NEEDLE, LOCATE CIRCUIT
	GL	FNDCRQ
	J	LEP09Z			:CANNOT MATCH THE INVOICE NUMBER, ABORT
	LHL	R5,CQNFLG,,		:RECOMPUTE HIST BUFF SIZE
	HSIZE(R5)			:BASED ON SPEED BITS		###CY
	STH	R0,RHBSZ,R7,		:R6, R7 WERE SET UP IN FNDCRQ
	JAL	R9,MERGE		:MERGE OUTBOUND AND HISTORY BUFFERS
	GL	MERGE
	LR	R2,R6			:CHECK MERGED OUTBOUND BUFF'S 1ST CHAR
        IF      REBTST                   :SHOULD WORK FOR ALL  ###SDWW
        LHL     R1,BCT,R2,              :NO PEEK EMPTY BUFFER
        JE      LEP09S
        EI
	JAL	R8,PCIS			:IT MIGHT BE AN '02' OR '03' RESULTING

    IF 1-REBTST
					:FIX REBUILD SPLIT CHAR PROBLEMS###LSH
	SIS	R1,7		:FROM HIST-BUFF PRUNING,SPLIT CHAR PAIR ###LSH
	JGFS	LEP09S			:NOPE, IT'S > 7
    ELSE                        :scott's new rebuild does not split char pairs
        SIS     R1,3            :sequence numbers do not split char pairs and
        JGFS    LEP09S          :since new logic returns exactly as many as
        AIS     R1,1            :seq num thus split pairs stay together.
        JLFS    LEP09S          :old logic returned convient number of bytes
   EI  :REBTST                   :which could split the pairs
	XHI	R2,4			:FIRST CHAR IS <= 7, NO REBUILD
	JAL	R9,ZAPHRD		:ZAP BACK TOWARDS THE ORIGINATING PORT
	J	LEP1			:AND GO TO NEXT SUP MESSAGE

LEP09S	LHL	R2,CQNBUF		:BUFFER WHERE NEEDLE ASSEMBLED
	XHI	R6,4			:R6=INBOUND BUFFER
	LHL	R1,VSEQN,R6,		:GET COUNT OF CHARS RECEIVED ON CIRC
	JAL	R9,WHWI			:...TELLS FAR END WHAT TO SEND NEXT
	LHL	R1,VSEQN+2,R6,		:LOWER HW OF 32-BIT NUMBER	###GT
	JAL	R9,WHWI
	XHI	R6,4			:FLIP TO OUTBOUND BUFFER...TELLS
	LHL	R1,XSEQN,R6,		: FAR END WHICH CHAR WE'LL SEND NEXT
	JAL	R9,WHWI			:WRITE IT INTO NEEDLE BUFFER
	LHL	R1,XSEQN+2,R6,		:LOWER HW			###GT
	JAL	R9,WHWI
	JAL	R8,CBCCT		:COMPUTE NEW NEEDLE BYTE COUNT
	STB	R1,0,PRD		:AND STORE IN APPROPRIATE NEEDLE FIELD

	JAL	R9,SNDFX0		:SEND A FIX0 BEHIND THE NEEDLE	###GT

	LR	R7,R2			:R7 SOURCE, R6 DEST
	L	R0,SEQN,R6,		:KEEP SEQN S,TRAIGHT
	ST	R0,SEQN,R7,
	JAL	R9,PREFIX		:PREFIX NEEDLE TO OB
	GL	PREFIX
	LHL	R2,CQNBUF		:RETURN NEEDLE BUFFER
	JAL	R8,RFCBUF
	LR	R2,R6
	JAL	R9,CRQALT		:ALERT CRQ OF NEEDLE
	SRHLS	R2,3			:CLEAR TIMEOUTS
	SBT	R2,CRQBSY		:RE-ACTIVATE REBUILD PROCESSING
	SBT	R2,CRQEND		:AND NOTE CREATION OF AN ENDPOINT
	RBT	R2,REBTMO
	RBT	R2,REBTMI
	RBT	R2,SQFTMO		:CLEAR REBUILD TIMEOUT BIT	###GT
	SBT	R2,SQFTMI		:SET REBUILD TIMEOUT COUNTER	###GT
	J	BIDDRT,,		:ALL DONE

	ELSE	:NOT REBILD

LEP09R	J	LEP09Z			:CANNOT REBUILD, NOT ENABLED. ABORT

	EI	:REBILD

LEP09U	HS	0
	ST	R2,LEPSV1		:TYPE 1 MESS TO SUP'S LOG
	JAL	R10,SWRCHU		:FORMAT CHANNEL IN USE NODE REPORT,
	GL	SWRCHU			: CIRCUIT LIFETIME NODE REPORT,
					: AND CRYPTOGRAM.
	L	R2,LEPSV1
	J	LEP09Z			:ABORT

LEP09H	HS	0			:NO SUCH NEIGHBOR
	ST	R2,LEPSV1		:SAVE BUFFER INDEX
:	SEND NODE REPORT FOR 'NO NEIGHBOR'
	LHI	R0,NR.NNE
	STH	R0,SUPMBF		:REPORT TYPE
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER NOT FOUND
	LHL	R0,NEDFLG
	STH	R0,SUPMBF+4		:NEEDLE FLAGS
	JAL	R10,SUP12		:SEND NODE REPORT TO SUPERVISOR LOG
	L	R2,LEPSV1		:RESTORE BUFFER INDEX TO RETURN IT...

LEP09Z	JAL	R8,RFCBUF		:ABORT - RETURN BUFFER
	LIS	R0,1
	AHM	R0,NC.LPE		:COUNT CIRCUIT BUILDING ERRORS IN LEP
	J	LEP1			:AND PROCESS NEXT COMMAND

::*********************************************************************
::
::	SUBROUTINE:	LEP90A:
::	FUNCTION:	Routine to copy # of chars (in R9) from buffer (in R5)
::			to buffer (in R7), and to return the R9th byte (in R1).
::			Resumes execution at LEP90C if data in R5 runs out.
::	CALLING SEQ:	JAL	R10,LEP90A
::	DESTROYED:	R1, R2, R6
::
::*********************************************************************

	IF	EXPNDL

LEP90A	LR	R2,R5			:R5 HAS BUFFER # FROM SUP
	JAL	R8,GCI
	LR	R2,R7			:PUT DATA INTO NEW NET-BOUND BUFFER
	JAL	R8,WCI
	LR	R1,R1			:check for escapes
	JEFS	LEP90B
	SIS	R9,1			:dec counter to FLAGS
	JLR	R10
	SIS	R6,1			:dec the needle length counter
	JG	LEP90A			:and go get another char
	J	LEP90C			:we should never get here

LEP90B	LR	R2,R5			:R5 has buffer # from sup
	JAL	R8,GCI			:get the escaped byte
	LR	R2,R7			:get net-bound buffer
	JAL	R8,WCI			:write in the escaped byte
	SIS	R6,1
	SIS	R9,1			:dec counter to FLAGS
	JLR	R10			:don't count escapes for this count
	SIS	R6,1			:decrement LRC count
	JG	LEP90A			:loop for all the data
	J	LEP90C			:needle transferred to net-buffer
					:we should never get here
	EI	:EXPNDL

	SUBTTL	LEP (LEP0B - Type B:  Circuit trace request)

::*********************************************************************
::
::	COMMAND:	LEP0B:
::	FUNCTION:	PROCESS TRACE REQUEST (TYPE 0B)
::
::*********************************************************************

LEP0B	HS	0
	JAL	R9,GHWI			:DISCARD NODE NUMBER,
	JAL	R9,GHWI			:AND TYPE
	LI	R1,03008001		:INIT TRACE HEADER
	ST	R1,LEPMES
	JAL	R9,GHWI			:HOST #
	STH	R1,LEPMES+4
	JAL	R9,GHWI			:PORT #
	STH	R1,LEPMES+6
	LHI	R1,MACHNM
	STH	R1,LEPMES+8
	LIS	PRD,0A			:TRACE NEEDS THIS INITIALIZED

	LHL	R1,LEPMES+4		:RECOVER HOST #
	IF	SUPER
	LHI	CHN,SUPZFL
	CI	R1,0FFFE
	JE	LEP0B1
	EI	:SUPER
	THI	R1,4000			:IF THE 4000 BIT IS NOT SET...
	JE	LEP0B3			:...R1 CONTAINS A HOST NUMBER, ELSE
	NHI	R1,3FFF			:R1 IS A T-1 NEIGHBOR. STRIP 4000 BIT
	LIS	CHN,0
	JAL	R9,FNDLNK,,		:GO FIND THE T-1 NEIGHBOR
	J	LEP0B2			:NGHBR NOT FOUND, REJECT TRACE REQUEST
	LHL	CHN,LKZFKN,KN,KN
LEP0B1	AH	CHN,LEPMES+6		:CHN=ABSOLUTE PORT #
LEP0B2	NHI	R1,7FFF
	JAL	R10,TRACE		:TRACE WIL REJECT REQUEST IF CHN=0
	J	LEP1			:DONE

LEP0B3	NHI	R1,3FFF			:HERE TO TRACE FROM A HOST ON THE NODE
	IF	ISIS!SOLOCS		:ON ISIS AND SOLO CONSAT NODES	##TZ
	JEFS	LEP0B7			:HOST = 0 SERVES AS A WILD-CARD HOST #
	EI	:ISIS			:FOR ANY ISIS HOST
	LIS	CHN,0			:CLEAR CHN IN CASE WE REJECT TRACE REQ
	JAL	R9,FNDHST		:MAKE SURE THE HOST EXISTS
	GL	FNDHST
	J	LEP0B2			:CAN'T FIND HOST, REJECT TRACE REQUEST
	IF	SOLOCS
	LHI	CHN,ASYZFL		:IF CONSAT, BASE = FIRST CONSAT PORT
	ELSE	:NOT SOLOCS
	LHI	CHN,KERZFL		:ELSE, ASSUME BASE = FIRST KERNEL PORT
	EI	:SOLOCS
	LR	HN,HN			:IF FNDHST RETURNS WITH INDEX = 0...
	JE	LEP0B1			:IT IS THE KERNEL (HOST0)
LEP0B7	HS	0			:				##TZ
	IF	ISIS			:				##TZ
	LHI	CHN,DISZFL		:IT'S EITHER A DISPATCHER PORT	##TZ
	ELSE	:NOT ISIS						##TZ
	LHI	CHN,ASYZFL		:OR AN ASYNC PORT		##TZ
	EI	:ISIS							##TZ
	J	LEP0B1

	SUBTTL	LEP (LEP0C - Type C:  Sleeping pills)

::*********************************************************************
::
::	COMMAND:	LEP0C:
::	FUNCTION:	PROCESS PILLS  (TYPE 0C)
::
::*********************************************************************

LEP0C	HS	0
	JAL	R9,GHWI			:DISCARD NODE # AND TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:GET FIRST BYTE (SUP # + 80)
	IF	SUPER
	IF	SNRING
	LR	R8,R1			:NEW INTERFACE, REPORT OF SENDING SUP #
	NHI	R8,7F
	ELSE	:NOT SNRING
	LIS	R8,1			:OLD INTERFACE RECOGNIZES SUP 1 ONLY
	EI	:SNRING
	LIS	R0,0
	LHL	R1,TVRSTT		:IS SUP FROZEN?
	SIS	R1,3
	JE	BIDDRT,,		:SUP FROZEN IGNORE
	IF	SNRING
	JAL	R9,SIROOM,,		:ROOM IN SUP INPUT RING?
	CLHI	PRC,8
	JLE	BIDDRT,,		:THIS SUP A HEAVY SLEEPER...
	ELSE	:NOT SNRING
	LHL	PRD,NISI,,		:SEND PILL
	NHI	PRD,SUPBSZ-1
	EI	:SNRING
	STH	R0,SIB,PRD,		:CHANNEL 0
	AIS	PRD,2
	IF	SNRING
	JLFS	LEP0C1
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NHI	PRD,SUPBSZ-1
	EI	:SNRING
LEP0C1	LIS	R0,2			:LRC = 2
	STH	R0,SIB,PRD,
	AIS	PRD,2
	IF	SNRING
	JLFS	LEP0C2
	SHI	PRD,SUPBSZ
	ELSE	:NOT SNRING
	NHI	PRD,SUPBSZ-1
	EI	:SNRING
LEP0C2	LHI	R0,8000,R8		:PILL WITH SENDING SUP NUMBER
	STH	R0,SIB,PRD,
	IF	SNRING
	LIS	PRD,6			:6-BYTE RECORD
	AH	PRD,NISI,,		:INCREMENT SIB LEAD POINTER
	JLFS	LEP0C3
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
LEP0C3	STH	PRD,NISI,,		:STORE NEW SIB RING INDEX
	ELSE	:NOT SNRING
	LIS	R0,6			:INDEX IN POINTER
	AHM	R0,NISI,,
	EI	:SNRING
	EI	:SUPER
	J	BIDDRT,,		:IF NOT A SUP'S BASE, JUST EXIT

	SUBTTL	LEP (LEP0D - Type D:  Message for ports in login mode)

::*********************************************************************
::
::	COMMAND:	LEP0D:
::	FUNCTION:	PROCESS LOGIN MESSAGES
::
::*********************************************************************

:	Format of messages is :
:	[node#],[0D,n+flags],[port#],<# chars>,<char>,...,<char>

LEP0D	HS	0
	JAL	R9,GHWI			:DISCARD NODE # AND TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:SAVE FIRST BYTE
	LR	R7,R1
	JAL	R9,GHWI			:ABSOLUTE PORT#(ANITAB index,if SOLOCS)
	IF	NEWALI
	LR	R8,R1			:SAVE CHANNEL KEY
	NHI	R1,1FFF			:PORT NUMBER
	NHI	R8,6000			:ISOLATE KEY
	CLH	R8,CKTKEY-(2*ANIZFL),R1,R1 :SEE IF IT MATCHES THE CURRENT KEY
	JN	LEP0D4			:NO, NOT FOR US
	ELSE	:NOT NEWALI
	NHI	R1,7FFF			:strip HOB of port # (ANITAB index)
	EI	:NEWALI
	LR	CHN,R1			:port # becomes CHN
	LR	R6,R2			:SAVE SUP BUFF #
	LHL	R2,IOTAB,CHN,CHN	:MAKE SURE THAT THE PORT IS THERE
	NHI	R2,-4

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,LPDDB1,,
	GL	LPDDB1
	L	R4,REGST,,
	LR	R2,R2
	EI	:LPGDBG

::Departure for Gateway logins
	IF	T2GATE
	JN	GLP0DD
	ELSE
	JN	LEP0DD			:YES, PROCEED
	EI	:T2GATE
LEP0D4	LR	R2,R6			:NO CIRCUIT OR CKTKEY DOESN'T MATCH
	CLHI	R7,10			:IS THERE ADDIT STUFF? (R7 is n+flags)
	JN	LEP1			:NO, GO BYE
	JAL	R8,GCI			:CHAR COUNT
	LR	R1,R1			:is it escaped?
	JNFS	LEPD10			:non-zero means not escaped
	JAL	R8,GCI			:if escaped, second byte is the count
LEPD10	LR	LRC,R1			:count becomes log record count
LEPD20	JAL	R8,GCI			:read out a data byte
	SIS	LRC,1			:	and decrement counter
	JGBS	LEPD20			:go while we have it
	J	LEP1			:return when we don't no more
LEP0DD	XHI	R2,4			:flip to port bound buffer(.ALBUF+4)
	LHI	R1,TILIM		:SEND 03-12  PAIR TO PORT IN LOGIN
	JAL	R9,W2CI
	LR	R1,R7			:GET CODE BYTE, e.g n + flags
	NHI	R7,1F			:mask down to five bits in work reg 7
	TBT	R7,EXLGMG		:EXPAND LOGIN MESSAGE ?
	JE	LEP0DE			:NO
	IF	ISIS
	SHI	CHN,DISZFL		:RELATIVE CHANNEL NO.
	TBT	CHN,DISELS		:CHECK ELS BIT - IF SET, NO TEXT
	JN	LEP0DF			:NO TEXT
	EI	:ISIS
	J	LEP0D3			:SEND TEXT
LEP0DE	CLHI	R7,10			:NO
	JEFS	LEP0DG			:IF 10, THERE'S ADDITIONAL STUFF
LEP0DF	JAL	R8,WCI			:WRITE CODE STATUS BYTE IN TO PORT
	J	LEP0DA
LEP0DG	XHI	R1,18			:MAKE IT INTO A $2 XXX01000
	JAL	R8,WCI
::A reentry point for Gateway log-ins
GLPEI4	LR	R7,R2			:PORT INPUT BUFF SAVE(.ALBUF+4, solocs)
	LR	R2,R6			:BYTE COUNT OF STRING FROM R6(LEP buff)
	JAL	R8,GCI			:GET (ESCAPED) LENGTH
	LR	R1,R1			:is it escaped?
	JNFS	LEPD30
	JAL	R8,GCI			:else second byte is count
LEPD30	LR	LRC,R1			:write count to buffer (R6)
LEP0DB	LR	R2,R6			:R6 is LEP buffer
	JAL	R8,GCI			:move string from LEP buffer to port
	LR	R2,R7			:R7 is port input buffer
	JAL	R8,WCI
	SIS	LRC,1
	JGBS	LEP0DB
	LR	R2,R6			:KLUDGE TO CIRCUMVENT SUP BUG
	LH	R1,BCT,R2,		:INSURE BUFFER NOT EMPTY
	JEFS	LEP0D1
	JAL	R8,GCI
	CLHI	R1,80			:REMOVE FOLLOWING NULL, IF ANY
	JEFS	LEP0D1
	JAL	R8,WCD
LEP0D1	LR	R2,R7
::Gateway log-on response processing reenters here
LEP0DA	HS	0			:INDICATE THAT SUP HAS SAID 'GO AHEAD'
	XHI	R2,0004			:GET OPPOSITE BUFFER
	LH	R1,BF,R2,		:GET CURRENT BUFFER FLAG
	CLHI	R1,LOGMIN		:VERIFY IN LOGIN MODE
	JL	LEP1
	CLHI	R1,LOGMAX
	JG	LEP1			:OUT OF RANGE
	OHI	R1,LOGSUP		:SET SUP 'OK' BIT
	STH	R1,BF,R2,
	J	LEP1			:ALL DONE

LEP0D3	HS	0			:EXPAND CANNED MESSAGE
	SHI	R7,13			:FIRST MESSAGE IS 13X
	LHL	R7,EXLGTB,R7,R7		:GET TABLE ENTRY		###CY
	LA	R7,SEG1,R7,
	LB	LRC,0,R7
	NHI	R1,0E0			:MSG TYPE="SEND NO MESSAGE"(CONTINUE)
	OHI	R1,8			:EMPTIERS EXPECT BIAS OF 8
	JAL	R8,WCI
	LHI	R1,8D			:KLUDGE TO SIMULATE SUP MESSAGE WITH
	JAL	R8,WCI			:EXTRA CARRIAGE-RETURN
LEP0D2	LB	R1,1,R7			:GET CHARACTER
	JAL	R8,WCI
	AIS	R7,1			:NEXT CHAR.
	SIS	LRC,1
	JGBS	LEP0D2			:LOOP
	LHI	R1,8D8A			:INSERT TRAILING CARRIAGE-RETURN,
	JAL	R9,WHWI			:LINE-FEED...
	J	LEP0DA			:MESSAGE COPIED



	IF	T2GATE
::*********************************************************************
::
::	ENTRY POINT:	GLP0DD:	Gateway LeP type 0D handler
::	FUNCTION:	Handles the Gateway variations of the Node
::			response to the Log-on response type 0D from Sup
::	INPUT:		R2	=  Buffer from terminal
::			CHN	=  Channel number (absolute)
::	OUTPUT:		Outputs a text and possible control characters.
::			Gateway must interpret and send any text due to its
::			capacity during log-in as a virtual terminal interface.
::			It must do this based on several possible general
::			terminal profile characteristics.  ie. Transparent
::			Log-on, IIX, HDX or just plain Ascii.
::	CALLS:		JAL	R8,GCI
::			JAL	R8,WCI  
::			JAL	R9,BUFCAN
::	RETURNS:	Jumps back to end of LEP0D routine to finish up
::			and return to further Lep processing.
::
::*********************************************************************

: rewritten GLP0dd to prevent any ports from going in cleanup.
: ###sdw

GLP0DD  LR      R10,R7          :make copy of status byte
        NHI     R7,1F           :r7 has message type
        SHI     CHN,DISZFL      :use relative (dispatcher) channel

        SBT     CHN,GTLGEC      :echo on
        THI     R10,40          :unless told to turn it off
        JNFS    GLP41
        RBT     CHN,GTLGEC      :told to turn off

GLP41   THI     R10,20          :flush port bound buffer?
        JEFS    GLP42           :nope
        XHI     R2,4            :port bound buffer
        JAL     R8,CBCLR        :flush
        XHI     R2,4            :return back to supe bound buffer

GLP42   CLHI    R7,11           :is the hang that ends the supe session?
        JE      GLP30Z          :yes handle it (nothing else matters)
        THI     R10,80          :clear supe bound buffer?
        JE      GLP42D          :nope
        JAL     R8,CBCCT        :count to clear
        LR      R1,R1           :any to clear?
        JLE     GLP42D          :nope
        JAL     R8,GCI          :make sure we don't clear a supe bound zap
        SIS     R1,3            :first byte of a zapper?
        JNFS    GLP42C          :nope, so ok to empty buffer
        LIS     R1,3            :put back that zapper byte
        JAL     R8,WCD          :put it back on the about to be read side
        LHI     R4,LOGMIN+LOGSUP :set status so LOGGER will sind it to supe
        STH     R4,BF,R2,       :loging status is stored in BF field
        J       LEP1            :done with this message

GLP42C  JAL     R8,GLBCLR       :empty login buffer (special empty routine)

GLP42D  XHI     R2,4            :flip back to terminal buffer
        TBT     R7,LGCHZZ       :should we reinit our to supe char count?
        JEFS    GLP42E          :nope
        LIS     R0,0
        STH     R0,GDLGTB,CHN,CHN :reinit count

GLP42E  SHI     R7,8            :bias down to 0
        TBT     CHN,GIIXCT      :iix circuit
        JN      GL30J           :yes special messages

        TBT     R7,GXLGMG       :a message for us to expand?
        JNFS    GLP0D2
        CLHI    R7,8            :message with supe text? (unbiased 10)
        JN      LEP0DA          :nothing for us to do (msg 12x 8x)
        J       GLPEI4          :expand routine

GLP0D2  LA      R4,CRLF         :new line
        JAL     R9,BUFCAN
    IF NETNAM
        TBT     CHN,GTTRNS      :transparent?
        JEFS    GL30F           :nope
        LA      R4,HOMEN        :name of home net
        JAL     R9,BUFCAN
        LA      R4,SPAC         :a space
        JAL     R9,BUFCAN
GL30F
     EI :NETNAM

        LIS     R8,0            :starting table index
        TBT     CHN,GTTRNS      :transparent table?
        JEFS    GL30G           :nope
        LHI     R8,LSMSTZ       :moves up a table index
GL30G   TBT     CHN,GTASCI      :asci?
        JEFS    GL30H           :nope
        AHI     R8,LSMSZ        :bump up a table index
        TBT     CHN,GTHDX       :half duplex?
        JNFS    GL30D           :yes
        TBT     CHN,GTAUX       :aux get same table as halfduplex ???
        JEFS    GL30H           :not aux circuit
GL30D   AHI     R8,LSMSZ        :bump up another table index
GL30H   SLHLS   R7,2            :word index
        L       R4,LSMS27,R7,R8 :get the message
        SRHLS   R7,2            :restore r7
        JAL     R9,BUFCAN       :output the message

GL30N   LR      R7,R7           :reentry for gl30j
        JLFS    GL30H1          :good messages are 0-5 (before bias 8-D)
        CLHI    R7,5
        JGFS    GL30H1          :not a good one
        LR      R8,R2           :poke into supe buffer flag
        XHI     R8,4            :supe buffer
        LHI     R4,LOGMIN+LOGSUP :set status
        STH     R4,BF,R8,

GL30H1  TBT     CHN,GTTRNS      :transparent?
        JE      LEP0DA          :nothing else to do
        TBT     R7,NLSOK        :hang this transparent user?
        JN      LEP0DA          :nope
        LIS     R1,1            :the hang char
        JAL     R8,WCI
        LHI     R1,0F0
        JAL     R8,WCI
        J       LEP0DA          :continue at normal lep finish

:       IIX Subroutine for GLP0DD
:       returns GL30N or LEPIE4 (if supe text)

GL30J   HS      0
    IF NETNAM
: why can a transparent IIX receive CRLF while normal IIX cannot?????
        TBT     CHN,GTTRNS      :transparent user?
        JEFS    GLPIX2          :nope
        LR      R7,R7           :continue msg?
        JLEFS   GLPIX2          :yes
        LA      R4,CRLF
        JAL     R9,BUFCAN       :new line
        LA      R4,HOMEN        :home net name (to an IIX? guess so)
        JAL     R9,BUFCAN
        LA      R4,SPAC
        JAL     R9,BUFCAN
GLPIX2
    EI :netnam

        LA      R4,IIXLMS       :the IIX login status message
        JAL     R9,BUFCAN       :has everything except the status
        CLHI    R7,8            :unbiased 10 (supe has sent text)
        JNFS    GLPIX3          :nope
        LIS     R1,0            :the null message (means continue)
        JAL     R8,WCI          :(can't forget we have started an IIX status)
        JAL     R8,WCI          :must be escaped too
        J       GLPEI4          :and now the lep processing does the text

GLPIX3  LB      R1,IXB4TB,R7    :send the proper code (isis style)
        JAL     R9,WCIE         :write and maybe escape
        J       GL30N           :done with IIX stuff

GLP30Z                          :r2 starts pointing to supe buffer
        LIS     R0,0            :not talking to supe any more
        STH     R0,BF,R2,       :not flags
        LR      R6,R2           :remove this from logger list
        JAL     R9,LOGCLR
: but do not reset LOGING because if DISPI were to read a zapper immediately
: after this routine we would send out accounting and ISIS would crash us.
: The zapper in the outbound buffer is how this port is going to be cleared.
: ###sdw

        XHI     R2,4            :back to port bound buffer
        LHI     R1,ZAPPN        :non gobbling zapper
        JAL     R9,W2CI
        J       LEP1            :really done



IXB4TB	BC	00,01,02,03,04,05,00,00,00,00,00,08,09,0A,0B,0C,0D,0E,0F
	BC	10,11,12,13		:Translate Node codes to Isis codes

LGCHZZ	HC	0000,0FFE: (> Msg 13x)	:RE-INIT CHARACTER COUNTER?
GXLGMG  HC      7E1F,0FE00 :(09-1E)     :expand for gateway log-in response

	EI	:T2GATE


EXLGMG	HC	0000,1FFE (13-1E)	:EXPAND LOGIN MESSAGE

	NOLIST

EXMG1	SC	/"8D"8Aplease see your representative"8D"8Aif you are having trouble logging in/
EXMG2	SC	/"8D"8Abad mud/
EXMG3	SC	/"8D"8Acircuits busy/
EXMG4	SC	/"8D"8Ahost not available thru net/
EXMG5	SC	/"8D"8Ahost out of ports/
EXMG6	SC	/"8D"8Ahost down/
EXMG7	SC	/"8D"8Ahost shut/
EXMG8	SC	/"8D"8Atry again in 2 minutes/
EXMG9	SC	/"8D"8Aaccess not permitted/
EXMG10	SC	/"8D"8Ano host specified/
EXMG11	SC	/"8D"8Abad host number/
EXMG12	SC	/"8D"8Amud error/
	IF	T2GATE
EXMGDL  HC      XMGDL
EXMG13	EQ	EXMGDL+1
	AC	/"8D"8Aplease see your representative/
	AC	/"8D"8Aif you are having trouble logging in/
	AC	/"8D"8Ainter-link cleared from /
	IF	NETNAM
	INAME()
	ELSE
	AC	/ISIS NETWORK/
	EI	:NETNAM
	AC	/ to /
	IF	NETNAM
	HNAME()
	ELSE
	AC	/HOME NETWORK/
	EI	:NETNAM
	AC	/"8D"8A/
XMGDL	EQ	.-EXMG13-1
	EI	:T2GATE
	LIST

EXLGTB	HS	0		:LOOK UP TABLE
Q	EQ	1		:START AT 1
	RE	$A 12
	HC	EXMG|$AQ|-SEG1
Q	EQ	Q+1
	NOLIST
	ER
	LIST

	IF	1-INFLGT
	NOLIST
:	THE FOLLOWING MESSAGE INCLUDES A SUPER HANG, AND A HANG
PSRMSG	SC	/"03"12"12"8D"8Aplease see your representative"8D"8Aif you are having trouble logging in"03"12"11/
	LIST
	EI	:1-INFLGT

	IF	T2GATE
::Address tables for Log-on response messages to callers for Gateway

LSMS27	WC	LSMS0	:08 - Continue
	WC	LSMS12	:09 - P.L.I.
	WC	LSMS22	:0A - error, type username
	WC	LSMS32	:0B - error, type password
	WC	LSMS42	:0C - user name
	WC	LSMS52	:0D - password
	WC	LSMS0	:0E - 
	WC	LSMS0	:0F - 
	WC	LSMS0	:10 - send Sup specified string
	WC	LSMS0	:11 - 
	WC	LSMS0	:12 - 
	WC	EXMG13	:13 - please se your rep.
	WC	EXMG2	:14 - bad mud
	WC	EXMG3	:15 - circuits busy
	WC	EXMG4	:16 - host not avail thru net
	WC	EXMG5	:17 - host out of ports
	WC	EXMG6	:18 - host down
	WC	EXMG7	:19 - host shut
	WC	EXMG8	:1A - try again
	WC	EXMG9	:1B - access not permitted
	WC	EXMG10	:1C - no host specified
	WC	EXMG11	:1D - bad host number
	WC	EXMG12	:1E - mud error
LSMSZ	EQ	.-LSMS27
::The Ascii table is below
LSMS	WC	LSMS0,LSMS1,LSMS2,LSMS3,LSMS4,LSMS5,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG13,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::The Half Duplex table is below
LSMSH	WC	LSMS0,LSMS1,LSMS2,LSMSC,LSMS4,LSMSE,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG13,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
LSMSTZ	EQ	.-LSMS27
::Same tables as above except for transparent Log-ons
LSM27T	WC	LSMS0,LSMS1T,LSMS2T,LSMS32,LSMS4T,LSMS52,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG1,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::Ascii
LSMST	WC	LSMS0,LSMS1T,LSMS2T,LSMS3,LSMS4T,LSMS5,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG1,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::Half Duplex
LSMSHT	WC	LSMS0,LSMS1T,LSMS2T,LSMSC,LSMS4T,LSMSE,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG1,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::End of address tables for log-on responses from Supervisor
NLSOK	HC	$2 1001010111111111,-1
	NOLIST
LSMS0	BC	0;
	HS	0
LSMS1	SC	/please log in: /;
LSMS12	SC	/please log in: "05/;
	HS	0
LSMS2	SC	/error, type user name: /;
LSMS22	SC	/error, type user name: "05/;

LSMS1T	SC	/circuit cleared/
LSMS2T	SC	/bad user name/

LSMS3	SC	/error, type password: /;
	HC	ZMS32
LSMS32	EQ	.-1
	AC	/error, type password: /
	AC	/###############"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/+++++++++++++++"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/OOOOOOOOOOOOOOO"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88"05/
ZMS32	EQ	.-LSMS32-1;
	HC	ZMSC
LSMSC	EQ	.-1
	AC	/error, type password:/
	AC	/"8D"8A"FF###############/
	AC	/"8D"FF"FF+++++++++++++++/
	AC	/"8D"FF"FFOOOOOOOOOOOOOOO"8D/
ZMSC	EQ	.-LSMSC-1;
LSMS4	SC	/user name: /;
LSMS42	SC	/user name: "05/;

LSMS4T	SC	/user name missing/
LSMS5	SC	/password: /;
	HC	ZMS52
LSMS52	EQ	.-1
	AC	/password: /
	AC	/###############"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/+++++++++++++++"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/OOOOOOOOOOOOOOO"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88"05/
ZMS52	EQ	.-LSMS52-1;
	HC	ZMSE
LSMSE	EQ	.-1
	AC	/password:/
	AC	/"8D"8A"FF###############/
	AC	/"8D"FF"FF+++++++++++++++/
	AC	/"8D"FF"FFOOOOOOOOOOOOOOO"8D/
ZMSE	EQ	.-LSMSE-1;
LABORT	SC	/"8D"8Alogon aborted...disconnecting/
	IF	NETNAM
	HS	0
I.NAME(ISISN)			:PRIMARY ISIS NET NAME;
	HS	0
H.NAME(HOMEN)			:SECONDARY HOME NET NAME;
	ELSE	:NETNAM NOT DEFINED, DEFAULT NAMES
	HS	0
ISISN	SC	/ISIS NETWORK/	:PRIMARY ISIS NET NAME;
	HS	0
HOMEN	SC	/HOME NETWORK/	:SECONDARY HOME NET NAME;
	EI	:NETNAM
	HS	0
FROM	SC	' from ';
TO	SC	' to ';
CRLF	SC	/"8D"8A/;
SPAC	SC	/ /;
IIXLMS	XC	0401F68084		:Start of IIX logon status message

	EI	:T2GATE
	LIST
	SUBTTL	LEP (LEP0E - Type E:  Aux circuit message)
::*********************************************************************
::
::	COMMAND:	LEP0E:
::	FUNCTION:	PROCESS AUX CIRCUIT MESSAGE (TYPE E)
::
::*********************************************************************

LEP0E	HS	0
	JAL	R9,GHWI			:DISCARD NODE & TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:GET SUBTYPE
	LR	R7,R1
	JAL	R9,GHWI			:PORT #
	IF	NEWALI
	LR	R8,R1			:SAVE FOR KEY CHECK
	NHI	R1,1FFF			:ISOLATE PORT#
	NHI	R8,6000			:AND CKTKEY
	CLH	R8,CKTKEY-(2*ANIZFL),R1,R1 :DOES KEY MATCH?
	JN	LEP1			:NO, FORGET IT
	LR	CHN,R1			:YES, CONTINUE
	ELSE	:NOT NEWALI
	LR	CHN,R1
	NHI	CHN,7FFF		:RESET HI-ORD BIT
	EI	:NEWALI
	LHL	R2,IOTAB,CHN,CHN
	NHI	R2,-4
	JE	LEP1			:NO SUCH CIRCUIT
	LHL	R1,BF,R2,		:MAKE SURE ITS IN LOGIN
	CLHI	R1,LOGMIN
	JL	LEP1
	CLHI	R1,LOGMAX
	JG	LEP1
	CLHI	R7,80			:DO WE SEND REST OF LOGIN
	JN	LEP0EZ			:ERROR
	LH	R0,BF,R2,		:GET OLD FLAG,
	OHI	R0,LOGSUP		:SET SUP 'OK' BIT
	STH	R0,BF,R2,
	J	LEP1

LEP0EZ	XHI	R2,4			:SOME ERROR
	LIS 	R1,3
	JAL	R8,WCI			:RETURN LOGRR MESSAGE
	LHI 	R1,LOGRR&0FF
	JAL	R8,WCI
	LR 	R1,R7
	JAL	R8,WCI			:FOLLOWED BY ERROR CODE
	LIS	R0,0
	XHI	R2,4
	STH	R0,BF,R2,		:CLEAR BUFFER FLAG
	LR	R6,R2
	JAL	R9,LOGCLR		:REMOVE ENTRY FROM LOGGER LIST
	J	LEP1			:ALL DONE
	SUBTTL	LEP (LEP0F - Type F:  General supervisor commands)

::*********************************************************************
::
::	COMMAND:	LEP0F:
::	FUNCTION:	PROCESS GENERAL SUP COMMANDS (TYPE F)
::
::*********************************************************************

LEP0F	HS	0
	JAL	R9,LEPGMS		:COPY MESSAGE TO BUFFER
	LB	R1,LEPMES+1
	SHI	R1,88			:RANGE CHECK 0F SUBTYPE
	JL	LEP1			:ERROR - TOO LOW
	CLHI	R1,LEPN0F
	JG	LEP1			:ERROR - TOO HIGH
	LHL	R1,LEP0FT,R1,R1
	J	SEG1,1,

::*********************************************************************
::
::	SUBTYPE:	LEPHTM:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 08:  SEND HOST GMT
::
::*********************************************************************

LEPHTM	HS	0			:GET SUP TIME FOR NODECODE AND/OR ISIS.
	TS	GETGMT,,		:GET GMT FOR NODE CODE ONLY IF WE ARE
					:BEING TAKEN OVER AFTER CRASH, GMTGET=0
	JL	LEPHT1			:DON'T BOTHER, GO DO ISIS.
	L	R1,SLOWC,,		:SLOWC BASE TIME.
	ST	R1,GMTSLC,,		:STORE IT.
	ST	R1,SUPSLC,,		:FOR CRASH TABLES
	L	R1,LEPMES+4		:GET GMT IN HEX SEC'S
	ST	R1,SUPTIM,,		:FOR CRASH TABLES
:	NOW WE REDUCE R1 (HEX GMT) TO THE NO. OF SEC'S SINCE THE
:	BEGINNING OF THE CURRENT YEAR, PLUS A DAY'S WORTH.  THIS SO THAT
:	DAY 0 MEANS WE HAVEN'T YET GOTTEN GMT FROM THE SUP.
	SI	R1,$A(7*365*24*3600)+(2*24*3600) :R1= NO. SEC'S SINCE START
					:OF 1980 (A LEAPYEAR BOUNDARY)
:	FOR EFFICIENCY, PRECEDING LINE SHOULD BE MODIFIED AFTER EVERY LEAPYEAR.
:	NOTE: THIS WILL GO WRONG IN THE YEAR 2000. BEWARE!
LEPHT7	CI	R1,$A(4*365*24*3600)+(24*3600)	:HAS A LEAPYEAR PASSED SINCE?
	JLEFS	LEPHT2			:NO, SO SKIP
	SI	R1,$A(4*365*24*3600)+(24*3600)	:ADJUST FOR QUADYEAR PASSED
	JBS	LEPHT7			:AND CHECK AGAIN
LEPHT2	LIS	R0,1			:IF R0 GOES TO 4 (WRAPS TO 0) = LEAP YR
	LI	R6,$A(365*24*3600)	:SEC'S IN NORMAL YEAR
LEPHT5	CR	R1,R6			:HAS A YEAR PASSED?
	JLEFS	LEPHT6			:NO, SO SKIP
	LBR	R0,R0			:LEAPYEAR?
	JEFS	LEPHTC			:YES, MUST BE LAST DAY OF LEAPYEAR,SKIP
	AIS	R0,1			:A YEAR CLOSER TO A LEAPYEAR
	NHI	R0,3			:MOD 4
	SR	R1,R6			:ADJUST FOR NORMAL YEAR PASSED
	JBS	LEPHT5			:CHECK AGAIN
LEPHT6	LBR	R0,R0			:LEAPYEAR?
	JNFS	LEPHT4			:NO, SKIP
LEPHTC	AI	R6,$A24*3600		:ADD A DAY'S WORTH FOR CURRENT LEAPYEAR
LEPHT4	AI	R6,$A24*3600		:SEE NEXT COMMENT
	AI	R1,$A24*3600		:ADD DAY'S WORTH OF SEC'S, WHEN CONVERT
					:TO HUMAN FORM WE NEVER GET A DAY 0
					:UNLESS HAVEN'T BEEN HERE TOP GET GMT
	ST	R1,GMTHEX,,		:BASE GMT HEX SEC'S:GMTSLC
	SLLS	R1,7			:FORMAT FOR GMTCNV
	ST	R1,XLCRSH,,		:TIME OF LAST CRASH FOR ND DISPLAY
	ST	R6,CYRMAX,,		:MAX SEC'S IN CURRENT YEAR
	STH	R0,CYRCOD,,		:CURRENT YEAR TYPE (0-3) 0=LEAPYEAR
	L	R0,XFIRST		:IS THIS THE FIRST TAKEOVER SINCE LOAD?
	JNFS	LEPHTD			:XFIRST ALREADY HAS 1ST TAKEOVER TIME
	ST	R1,XFIRST		:YES, STORE FIRST TAKEOVER TIME
	L	R1,SUPTIM,,		:GET UNADULTERATED TAKE TIME
	ST	R1,TAKETI		:FOR CRASH TABLE

LEPHTD	HS	0
:	SOME LINES CAME UP BEFORE TAKEOVER, SO THEY HAVE ATT TIMES THAT
:	ARE NOT GMT. WE NOW ADJUST THEM TO GMT.
	LHI	R6,(NLINES-1)*4		:CHECK EACH LINE - FW INDEX
LEPHT8	L	R0,LINTIM,R6,		:GET TIME FOR LINE
	JEFS	LEPHT9			:IF 0 IGNORE
	SRLS	R0,7			:ADJUST FROM GMTCNV FORMAT
	L	R1,GMTHEX,,		:GET BASE GMT
	SR	R1,R0			:FIND GMT FOR LINE
	CI	R1,$A24*3600		:IF < 1 DAY, TIME IS IN PREVIOUS YEAR
	JLFS	LEPHTA			:GO FIGURE
LEPHTB	SLLS	R1,7			:GMTCNV FORMAT
	ST	R1,LINTIM,R6,		:STORE LINE GMT
LEPHT9	SIS	R6,4			:NEXT LINE
	JGE	LEPHT8			:IF ANY MORE

	JFS	LPHTM1			:CONTINUE

LEPHTA	AI	R1,$A365*24*3600	:ASSUME PREV YEAR NORMAL
	LHL	R0,CYRCOD,,		:CURRENT YEAR CODE
	SIS	R0,1			:PREV YEAR LEAPYEAR IF/ONLYIF CYRCOD=1
	JNBS	LEPHTB			:GMT OK
	AI	R1,$A24*3600		:ADD FOR LEAPYEAR
	J	LEPHTB

:	SOME HOSTS REPORTED STATUS BEFORE TAKEOVER, SO THEY HAVE HOST
:	STATUS TIMES THAT ARE NOT GMT. WE NOW ADJUST THEM TO GMT.
:	(USED FOR EXPANDED HOST STATUS)
LPHTM1	LHI	R6,0			:HW INDEX INTO HOST TABLES
LPHTM8	LHL	R0,HOSTN,R6		:CHECK FOR HOST ENTRY
	JE	LPHTM9			:NO ENTRY, SKIP
	L	R0,HSTTIM,R6,R6		:GET HOST STATUS TIME FOR ADJUSTMENT
	SRLS	R0,7			:ADJUST FROM GMTCNV FORMAT
	L	R1,GMTHEX,,		:GET BASE GMT
	SR	R1,R0			:FIND GMT FOR HOST
	CI	R1,$A24*3600		:IF < 1 DAY, TIME IS IN PREVIOUS YEAR
	JLFS	LPHTMA			:GO FIGURE
LPHTMB	SLLS	R1,7			:GMTCNV FORMAT
	ST	R1,HSTTIM,R6,R6		:STORE HOST GMT
LPHTM9	AIS	R6,2			:NEXT HOST TABLE HW INDEX
	CLHI	R6,NHOSTS^1		:AT END OF HOSTS TABLES
	JL	LPHTM8			:IF ANY MORE HOSTS
	JFS	LEPHT1			:CONTINUE
LPHTMA	AI	R1,$A365*24*3600	:ASSUME PREV YEAR NORMAL
	LHL	R0,CYRCOD,,		:CURRENT YEAR CODE
	SIS	R0,1			:PREV YEAR LEAPYEAR IF/ONLYIF CYRCOD=1
	JN	LPHTMB			:GMT OK
	AI	R1,$A24*3600		:ADD FOR LEAPYEAR
	J	LPHTMB

LEPHT1	IF	ISIS&(1-T2GATE)		:ONLY APPLIES TO DISPATCHER HOSTS
	LIS	R0,8			:WAIT FOR ROOM
	JAL	R8,DIROOM
	LHL	R6,DRIF,,		:get the fill pointer
	LHI	R1,INSTTM^8		:TIME MESSAGE			###jhl
	ST	R1,DIRNG,R6,		:put it in the ring
	AIS	R6,4
	NHI	R6,DRSZ-4
	L	R1,LEPMES+4		:GMT
	ST	R1,DIRNG,R6,
	AIS	R6,4
	NHI	R6,DRSZ-4
	STH	R6,DRIF,,
	EI	:ISIS&(1-T2GATE)	:###EV
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPBRZ:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 09: STOP TALKING TO NODE
::
::*********************************************************************

LEPBRZ	HS	0
	LHL	R1,LEPMES+2		:LOAD NEIGHBOR NUMBER
	JAL	R9,FNDLNK,,		:ZAP LINK IF UP
	J	LEPB10
	SBT	KN,BORZAP
LEPB10  HS      0               	:###wjl
        NHI     R1,7FFF         	:RESET HIGH-ORDER BIT		###wjl
      	LHI	R5,(BGLSIZ-1)*2
LEPB30	LH	R0,BGLIST,R5
	JEFS	LEPB20          	:IF NO ENTRY, GO MAKE ENTRY
        CR      R1,R0           	:SEE IF THIS A DUPLICATE	###wjl
        JEFS    LEPB40          	:DUPLICATE, SO RETURN		###wjl
	SIS	R5,2            	:PREPARE TO CHECK NEXT ENTRY OR
	JGBS	LEPB30			:IF LIST FULL, REUSE FIRST ENTRY
LEPB20	STH	R1,BGLIST,R5    	:MAKE ENTRY IN BAD GUY LIST
LEPB40	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPBRU:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0A: START TALKING TO NODE
::
::*********************************************************************

LEPBRU	HS	0
	LHL	R1,LEPMES+2		:LOAD NEIGHBOR NUMBER
	JAL	R9,FNDLNK,,		:FIND LINK
	J	LEPBR2			:TRLINK HAS PROBABLY RESET BORZAP
	RBT	KN,BORZAP		:PROBABLY REDUNDANT, BUT SAFE
LEPBR2  HS      0               	:###wjl
        NHI     R1,7FFF         	:RESET HIGH-ORDER BIT		###wjl
	LIS	R0,0
	LHI	R5,(BGLSIZ-1)*2
LEPBR6	CLH	R1,BGLIST,R5
	JNFS	LEPBR4
	STH	R0,BGLIST,R5		:REMOVE ENTRY FROM BAD GUY LIST
LEPBR4	SIS	R5,2
	JGEBS	LEPBR6
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPRBJ:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0B:  REBUILD ABORTED
::
::*********************************************************************

	IF	REBILD

LEPRBJ	HS	0
	L	R1,LEPMES+2		:REB REJECT - GET INVOICE #
	ST	R1,CQINV
	JAL	R9,FNDCRQ		:LOCATE CIRCUIT
	J	JBIDRT			:CIRCUIT NOT FOUND
	LR	R2,R6			:RETURNS OUTBOUND BUFF IN R6
	XHI	R2,4			:INBOUND BUFF
	JAL	R9,ZAPHRD		:BYEBYE CIRCUIT
	J	BIDDRT,,

	ELSE	:NOT REBILD

:	DESTINATION NODE WITH NO REBUILD CAPABILITY RECEIVED A REBUILD
:	REJECT COMMAND FROM SUPERVISOR AND DOES NOT KNOW HOW TO HANDLE
:	THE COMMAND...			:###wjl
LEPRBJ	HS	0
	J	BIDDRT,,		:###wjl
	EI	:REBILD

::*********************************************************************
::
::	SUBTYPE:	LEPDLL:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0C:  DLOAD COMMAND (GO TO BOOT)
::
::*********************************************************************

LEPDLL	HS	0
	LHL	R0,HNPORT		:# OF ACTIVE PORTS (TYMSAT+KERNEL+ISIS)
	OHI	R0,8000
	STH	R0,SUPMBF+2		:FORMAT FOR REPORT TO SUPERVISOR LOG
	LHL	R0,PASTHR
	OHI	R0,8000			:NUMBER OF PASSTHROUGHS + 8000
	STH	R0,SUPMBF+4
	LHI	R0,NR.DLD		:NODE REPORT TYPE
	STH	R0,SUPMBF
	JAL	R10,SUP12		:SEND THE REPORT
	TS	DLDFLG			:SET DLOAD FLAG FOR THE 4-SECOND LOGIC
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPZLI:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0D:  LOGIN ZAPPER CONFIRMATION
::
::*********************************************************************

LEPZLI	HS	0
	LHL	CHN,LEPMES+2		:ZAPPER CONFIRMATION ON LOGIN
	NHI	CHN,7FFF		:PORT #

	IF	NEWALI
	LR	R8,CHN			:SAVE KEY+PORT
	NHI	CHN,1FFF		:CHANNEL#
	NHI	R8,6000			:CKTKEY
	CLH	R8,CKTKEY-(2*ANIZFL),CHN,CHN	:DOES IT MATCH?
	JN	LEP1			:NO, FORGET IT
	LIS	R0,0			:THIS IS THE ONE WE WERE WAITING FOR
	STH	R0,CKTKEY-(2*ANIZFL),CHN,CHN	:RE-INIT KEY
	J	LEP1

	ELSE	:NOT NEWALI
	LHL	R2,IOTAB,CHN,CHN	:GET CHN'S OUTBOUND BUFFER
	NHI	R2,-4

	IF	LPGDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,LPZDB1,,
	GL	LPZDB1
	L	R4,REGST,,
	LR	R2,R2
	EI	:LPGDBG

	JE	LEP1			:NOTHING THERE
	LHL	R1,BF,R2,
	CLHI	R1,LOGMIN       	:HAS NEEDLE BEEN SENT DOWN YET  ??
	JL	LEPZL0		
	CLHI	R1,LOGMAX
	JLE	LEPZL1

:	NEEDLE HAS BEEN SENT DOWN ALREADY	###LSH
LEPZL0  HS      0
	GL	ZAPX
	IF	SOLOCS
:	NO LONGER NEEDS SPECIAL TREATMENT BY ASYLOU
	SHI	CHN,ANIZFL		:GET RELATIVE ANI CHN NUMBER
	RBT	CHN,LOGSTB,,		:RESET LOGSTB FLAG
	AHI	CHN,ANIZFL		:GET BACK TO ABS. CHN NUMBER
:       CLEAR FIRST HALF CIRCUIT (TO TERMINAL DIRECTION),
:       AND SEND ZAP TO HOST.
	LHI	R1,ZAPPN		:NON-GOBBLING TYPE ZAPPER
	JAL	R9,ZAPX
	
	ELSE	:NOT SOLOCS
:	ZAP IN BOTH DIRECTIONS
	LHI	R1,ZAPPN		:NON-GOBBLING TYPE ZAPPER
	JAL	R9,ZAPX			:CLEAR HALF CIRCUIT (TO DISPATCHER)
					: AND SEND ZAP DOWN TO HOST
	JAL	R8,GFCBUF		:GET ANOTHER BUFFER PAIR
	J	OP8463			:immed. return - out of buffers!###wjl
	JAL	R9,CRQHCR		:+4, BUILD HALF CIRCUIT (TO DISPATCHER)
	XHI	R2,4			:SWITCH TO CHN'S INCOMING BUFFER
	JAL	R9,ZAPHRD		:SEND ZAP TO DISPATCHER
	EI	:SOLOCS

	J	LEP1

:	NEEDLE HAS NOT BEEN SENT YET.  WE CAN RETURN BUFFER, AND
:	STOP CIRCUIT RIGHT HERE.

LEPZL1	LIS	R0,0
	STH	R0,IOTAB,CHN,CHN	:CLEAR PERMUTER TABLE
	LR	R6,R2
	JAL	R9,LOGCLR		:REMOVE FROM LIST
	IF	SOLOCS
 	SHI	CHN,ANIZFL		:get relative ANI channel offset
	RBT	CHN,LOGSTB,,		:no longer needs special treatment
 	AHI	CHN,ANIZFL		:must get back to absloute offset
	EI	:SOLOCS
	SBT	CHN,ACP,,		:MARK PORT AS AVAILABLE
	LCS	R0,1
	SR	R0,CHN
	SBT	R0,ACP,,		:NEGATIVE ACP MARKED AS AVAILABLE
	JAL	R8,RFCBUF		:RETURN BUFFER PAIR
	IF	T2GATE
	SHI	CHN,DISZFL		:make dispatcher port (relative chn)
	LHI	R1,9F00
	JAL	R8,DIRMES		:and free up port for dispatcher use
	EI	:T2GATE
	J	LEP1

	EI	:NEWALI	###LSH

::*********************************************************************
::
::	SUBTYPE:	LEPSPR:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0E:  SYNC PORT REQUEST
::
::*********************************************************************

LEPSPR	HS	0
	JAL	R10,SUPMHD		:SYNC LINE REPORT
	LHI	R1,148D			:RETURN TYPE '14'
	JAL	R9,WHWI
	LHI	R1,NLINES+8080
	JAL	R9,WHWI
	LIS	R5,0
LEPSP1	LHL	R1,NGSVLN,R5,R5
	NHI	R1,0BFFF		:ERRONEOUS NGHBR NOT REPORTED AS SIO
	IF	SILINS
	CLHI	R5,NLINES-SILINS
	JLFS	LEPS20
	OHI	R1,4000
LEPS20	HS	0
	EI	:SILINS
	JAL	R9,WHWI
	AIS	R5,1
	CLHI	R5,NLINES
	JLBS	LEPSP1
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPLSP:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0F:  LINK SPEED REQUEST
::
::*********************************************************************

LEPLSP	HS	0
	JAL	R10,SUPMHD		:LINK SPEED REQUEST 0F/0F
	LHI	R1,148E
	JAL	R9,WHWI
	LHL	R1,LEPMES+2		:GET NEIGHBOR IN QUESTION
	NHI	R1,7FFF
	JAL	R9,WHWI			:RETURN #
	JAL	R9,FNDLNK
	J	LEPLS1			:NO SUCH NEIGHBOR
	LB	R1,KSPD,KD
	NHI	R1,7F
	JNFS	LEPL10
LEPLS1	LCS	R1,1			:LINK IS DOWN
LEPL10	JAL	R9,WHWI
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPHRJ:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 10:  HOST REJECT COMMAND
::
::*********************************************************************

LEPHRJ	HS	0			:HOST REJECT MESSAGE,SENT TO DISPATCHER
	IF	ISIS			:(14/10)
	LIS	R0,8			:CHECK FOR ENOUGH ROOM
	JAL	R8,DIROOM
	LHL	R6,DRIF,,		:GET FILL INDEX FOR RING
	LHL	R1,LEPMES+2		:GET HOST NUMBER
	NHI	R1,7FFF
	CLHI	R1,HST0			:KERNEL HOST NUMBER?
	JE	LEP1			:YES, IGNORE

	IF	SOLOCS
	CLHI	R1,.AHOST		:SOLO CONSAT HOST NUMBER?	###OAS
	JE	LEP1			:YES,IGNORE			###OAS
	EI	:SOLOCS

	JAL	R9,FNDHST		:RETURNS HN AS HOST # INDEX
	J	LEP1			:REJECT A HOST WE DON'T HAVE
	LB	R0,HSTKEY,HN		:"KEY" (4*SLOT #)
	AHI	R0,0B00			:TYPE B MSG - REJECT
	ST	R0,DIRNG,R6,		:INTRA-ISIS MSG ON RPORT 0 (UPPER HW)
	AIS	R6,4			:UPDATE POINTER
	NHI	R6,DRSZ-4
:	RETURN HOST NUMBER, ERROR REASON=1 FOR HOST REJECT BY SUPERVISOR
	EXHR	R1,R1			:HOST NUMBER IN UPPER HALFWORD,
	AHI	R1,0100			:REASON=01 IN FOLLOWING BYTE
	ST	R1,DIRNG,R6,		:PUT IT AWAY TOWARDS OFFENDING SLOT
	AIS	R6,4
	NHI	R6,DRSZ-4		:UPDATE POINTER
	STH	R6,DRIF,,
	LIS	R0,0
	STH	R0,HOSTN,HN,HN		:CLEAR HOST ENTRY

:	CLEAR EXPANDED HOST STATUS INFORMATION
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R0,00C0			:CLEAR BITS 2,3,4,5 OF LO BYTE	###OAS
	STB	R0,HSTATN,HN		:AND RESTORE			###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW,,		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO		###OAS
	ST	R0,HSTTIM,HN,HN		:HOST TIME ARRAY,STORE CURRENT TIME#OAS
	SRLS	HN,1			:RESTORE HN#			###OAS

	EI	:ISIS

	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPBGL:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 11:  REPORT BAD-GUY LIST
::
::*********************************************************************

LEPBGL	HS	0
	JAL	R10,SUPMHD		:REPORT THE BAD GUYS LIST  (14/12)
	LHI	R1,1492			:TYPE 14, SUBTYPE 12
	JAL	R9,WHWI
	LHI	R1,8080
	LHI	R5,(BGLSIZ-1)*2
LEPBG1  LH	R0,BGLIST,R5		:COUNT HOW MANY ON LIST
	JEFS	LEPBG4
	AIS	R1,1
LEPBG4	SIS	R5,2
	JGEBS	LEPBG1
	JAL	R9,WHWI
	LHI	R5,(BGLSIZ-1)*2
LEPBG2  LH	R1,BGLIST,R5		:NOW SEND THEM IN
	JEFS	LEPBG6
	OHI	R1,8000
	JAL	R9,WHWI
LEPBG6	SIS	R5,2
	JGEBS	LEPBG2
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPRKD:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 12:  REMOVE NEIGHBOR
::
::*********************************************************************

:	NEIGHBOR NUMBER TO REMOVE IS IN LEPMES+2. RESPONSE IS A REPORT TO
:	LOG (TYPE 12), WITH 3 HALFWORDS, AS FOLLOWS:
:	*HW1* 4 (SUBTYPE 4)
:	*HW2* NEIGH # + 8000
:	*HW3* STATUS + 8080
:		=1 FOR NEIGHBOR NUMBER REMOVED
:		=2 FOR NEIGHBOR NUMBER NOT FOUND

LEPRKD	HS	0
	LHL	R1,LEPMES+2
	STH	R1,SUPMBF+2		:SAVE NEIGHBOR NUMBER FOR RESPONSE
	NHI	R1,7FFF
	JAL	R9,FNDLNK		:GET LINK DESCRIPTOR FOR THIS NEIGHBOR
	J	LEPRK4			:NOT FOUND
	LB	R7,NLAT,KD		:ANY LINES ATTACHED TO THIS LINK?
	JEFS	LEPRK2			:NO - LINK DOWN

:	LINK TO BE REMOVED IS UP - TEAR IT DOWN
	JAL	R10,TRLINK,,		:ZAP CIRCUITS, MARK LINK INACTIVE
	LHI	R4,13A4			:REPORT LINK OUT BY COMMAND
:	(NOTE R7=0 FROM TRLINK, WHICH DETERMINES LINK STATUS IN SUP13)
	JAL	R10,SUP13		:REPORT LINK DOWN TO SUP

LEPRK2	LIS	R0,1			:INDICATE NEIGHBOR NUMBER REMOVED
	JFS	LEPRK6
LEPRK4	LIS	R0,2			:INDICATE NEIGHBOR NUMBER NOT FOUND
LEPRK6	STH	R0,SUPMBF+4		:(HW3)
	LIS	R0,NR.RLK
	STH	R0,SUPMBF		:REPORT TO LOG, SUBTYPE 4
	JAL	R10,SUP12
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPAKD:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 13:  ADD NEIGHBOR
::
::*********************************************************************

:	NEIGHBOR NUMBER TO ADD IS IN LEPMES+2. DESIRED WINDOW SIZE + 8000 IS
:	IN LEPMES+4. IF SPECIFIED WINDOW SIZE IS 0, THEN ANY AVAILABLE LINK
:	WILL DO. RESPONSE IS A REPORT TO LOG (TYPE 12), WITH 3 HALFWORDS,
:	AS FOLLOWS:
:	*HW1* 5 (SUBTYPE 5)
:	*HW2* NEIGH # + 8000
:	*HW3* STATUS
:		=8000 + WSIZ IF NEIGHBOR ADDED
:		=FF00 + WSIZ IF LINK SPACE AVAILABLE BUT NO WSIZ MATCH
:		=FFFF IF NO LINK SPACE AVAILABLE

LEPAKD	HS	0
	LIS	R0,NR.ALK		:SET UP RESPONSE MESSAGE
	STH	R0,SUPMBF		: (REPORT TO LOG, SUBTYPE 5)
	LHL	R2,LEPMES+4
	STH	R2,SUPMBF+4		:SAVE WINDOW SIZE + 8000
	NHI	R2,7FFF
	LIS	R3,0			:R3 IS FLAG FOR ANY LINK FOUND
	LHL	R1,LEPMES+2
	STH	R1,SUPMBF+2		:NEIGHBOR # + 8000
	NHI	R1,7FFF
	STH	R1,LEPMES+2		:STORE BACK FOR LEPBRU (8000 BIT OFF)
:	SCAN ALL LINKS FOR AVAILABLE LINK DESCRIPTOR
	LHI	KN,NLINKS-1
LEPAK2	SLL	KN,1
	L	KD,KDKN,KN,KN
	SRL	KN,1
	LH	R0,NDID,KD		:IS LINK SPACE FREE?
	JNFS	LEPAK4			:NO
	LR	R2,R2			:YES - WSIZ SPECIFIED?
	JE	LEPAK6			:NO - ANY SIZE WILL DO
	CLH	R2,WSIZ,KD		:TEST FOR MATCH ON WINDOW SIZE
	JEFS	LEPAK6			:YES - ADD NEIGHBOR TO THIS LINK
	LCS	R3,1			:FLAG FOR LINK FOUND BUT WSIZ MISMATCH
LEPAK4	SIS	KN,1
	JGE	LEPAK2			:SCAN ALL LINKS
:	ALL LINK DESCRIPTORS EXAMINED - NO MATCH FOUND
	STB	KN,LEPMES+4		:INDICATE NEIGHBOR NOT ADDED
	LR	R3,R3			:DID WE REJECT DUE TO WSIZ MISMATCH?
	JLFS	LEPAK5			:YES - RETURN REQUESTED WINDOW SIZE
	STB	KN,LEPMES+5		:NO, ABSOLUTELY NO LINK SPACE AVAILABLE
LEPAK5	JAL	R10,SUP12		:REPORT TO LOG
	J	LEPBRU			:INSURE NEIGHBOR NOT ON BAD GUY LIST

LEPAK6	STH	R1,NDID,KD		:RESERVE LINK DESCRIPTOR FOR THIS NGHBR
	STH	R1,ONDID,KD
	JBS	LEPAK5			:REPORT AND CLEAN BAD GUY LIST

::*********************************************************************
::
::	SUBTYPE:	LEPNOP:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 14:  SUP NOP COMMAND -
::			TIMING DIAGNOSTIC REQUEST
::	FORMAT:	[0F,n+80]    where n=14
::		[time
::		 time]       Sup data to return intact
::		[8000+count] Return count messages
::*********************************************************************

:	THE SUP NOP COMMAND IS USED TO TIME ROUND TRIP OF SUP MESSAGES TO
:	INDIVIDUAL NODES BY PASSING AND HAVING RETURNED ITS OWN 'FASTC'. IN
:	ADDITION, AN ARTIFICIAL LOAD CAN BE CREATED SINCE THE THIRD HALFWORD
:	CONTAINS A LOOP COUNTER. THE LOOP COUNTER INDICATES THE NUMBER OF
:	RESPONSES TO RETURN FOR THIS COMMAND. RESPONSE IS A TYPE 14,
:	SUBTYPE 15, WITH 5 HALFWORDS, AS FOLLOWS:
:	*HW1* SUP FASTC
:	*HW2* SUP FASTC+2
:	*HW3* DECREMENTING LOOP COUNTER
:	*HW4* NODE FASTC
:	*HW5* NODE FASTC+2

LEPNOP	HS	0
	LHL	R15,LEPMES+6		:GET LOOP COUNTER AND
	NHI	R15,7FFF		:ISOLATE
	JE	LEP1			:SUP GENERATING ONE-WAY LOAD DOWNSTREAM

	L	R0,LEPMES+2		:MOVE SUP FASTC TO SAVE AREA IN
	ST	R0,LEPNSF		:CASE WE INTERRUPT TO OBSERVE BP LIMIT

:	NUMBER OF RESPONSE MESSAGES IS BASED ON LOOP COUNTER IN R15
LEPNP2	JAL	R10,SUPMHD		:SET UP MESSAGE HEADER
	LHI	R1,1415
	JAL	R9,WHWI			:TYPE 14, SUBTYPE 15
	LHL	R1,LEPNSF
	JAL	R9,WHWI			:RETURN SUP FASTC
	LHL	R1,LEPNSF+2
	JAL	R9,WHWI			:AND FASTC+2
	LR	R1,R15
	OHI	R1,8000			:INCLUDE LOOP COUNTER
	JAL	R9,WHWI
	LHL	R1,FASTC,,
	JAL	R9,WHWI			:RETURN NODE FASTC
	LHL	R1,FASTC+2,,
	JAL	R9,WHWI			:AND FASTC+2
	SIS	R15,1			:DECREMENT LOOP COUNTER
	JLE	SWICRQ			:DONE
	LHL	R0,BCT,R2,
	CLHI	R0,CIRSP3		:HAVE WE REACHED BACKPRESSURE LIMIT?
	JLE	LEPNP2			:NO - CONTINUE
	ST	R15,LEPNPF		:YES - COME BACK FROM 'SWITCH'
:	TO CHECK FOR OUTPUT DRAINED. HIGH-ORDER HW FLAGS BRANCH TO LEPNP4.
	J	SWICRQ

LEPNP4	HS	0			:CONTINUATION POINT FOR SUP NOP PROCESS
	LHL	R15,LEPNPF+2		:RESTORE LOOP COUNTER
	J	LEPNP2

	SUBTTL	LEP (LEP10 - Type 10:  Port status request)

::*********************************************************************
::
::	COMMAND:	LEP TYPE 10:
::	FUNCTION:	PORT STATUS REQUEST
::
::*********************************************************************

LEP10	HS	0
	JAL	R9,GHWI			:DISCARD NODE & TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:PORT GROUP #
	LR	R15,R1			:TO REG 15
	JAL	R9,GHWI			:HOST #
	LR	R14,R1			:TO REG 14
	JAL	R10,SUPMHD		:CREATE HEADER
	LHI	R1,148B
	JAL	R9,WHWI
	LR	R1,R14			:HOST #
	JAL	R9,WHWI

:	TEST FOR LINK PORT STATUS REQUEST
:	IF 40 BIT OF PORT GROUP BYTE SET R14 = NODE#
	THI	R15,40
	JN	L10LNK			:YES, LINK PORT STATUS REQUEST

	LR	R1,R14			:GET HOST #
	NHI	R1,7FFF			:CLEAR HI-ORD BIT
	JNFS	LEP10A			:IF HOST <> 0 SKIP

:	HOST = 0, REPORT ALL DISPATCHER OR TYMSAT PORTS IN USE
	IF	SOLOCS
	LHI	R6,NAPORT/8		:NUMBER OF BYTES OF ACP TO CHECK
	LA	R7,ASYACP,,		:START ADDRESS OF TYMSAT ACP ARRAY
	ELSE
	LHI	R6,(NDP+7)/8		:NUMBER OF BYTES OF ACP TO CHECK
	LA	R7,DISACP,,		:GET START ADDR OF DISPATCHER ACP ARRAY
	EI	:SOLOCS
	J	LEP10C			:PROCESS

LEP10A	CLHI	R1,7FFE			:IS IT THE SUP?
	JE	LEP10E

	JAL	R9,FNDHST		:HOST, FIND IT
	J	LEP10G			:WE DONT KNOW HIM

	CLHI	R1,HST0			:HOST = KERNEL ?
	JN	LEP10D			:NO,REPORT DISPATCHER HOST PORTS IN USE
	LHI	R6,(NKU+07)/8		:YES, SET UP # OF PORTS
	LHI	R7,KERACP,		:SET UP START OF KER PRTS

:	REPORT ACTIVE PORTS BY SENDING SUP COMPLEMENTED 'ACP' ARRAY
:	SO THAT AN ACTIVE PORT IS INDICATED BY A BIT SET

LEP10C	LIS	R5,8
	NHI	R15,3F
	LR	R1,R15			:RESPOND WITH
	OHI	R1,8080			:PORT GROUP + 8080
	SLLS	R15,4			:GET NUMBER OF BYTES OFFSET FOR GROUP
					:16d BYTES PER GROUP
	AR	R7,R15			:ADD TO EXISTING OFFSET
	IF	SOLOCS
	CI	R7,ASYACP+NAPORT/8	:VERIFY USER-ENTERED PORT GROUP
	ELSE	:NOT SOLOCS
	CI	R7,DISACP+(NDP+7)/8
	EI	:SOLOCS
	JGE	LEP10X			:INVALID, COMPUTED ADDRESS OUT OF RANGE

	JAL	R9,WHWI			:ADDR OK, SEND PORT GROUP +8080 TO SUP
	SR	R6,R15			:GET MAX # OF NON-ZERO BYTES TO SEND
	LCS	R10,1			:COMPLEMENT ACP SO 1'S FOR ACTIVE PORTS
LEP10F	LHL	R1,0,R7			:GET A PORT GROUP
	XR	R1,R10			:MAKE ACTIVE PORTS ONES
	LR	R6,R6			:ZERO PAD IF NEEDED
	JGFS	LEP10H
	LIS	R1,0
LEP10H	JAL	R9,WHWI
	AIS	R7,2			:GO TO NEXT GROUP
	SIS	R6,2
	SIS	R5,1
	JGBS	LEP10F
	J	LEP1			:ALL DONE

:	RETURN PORTS IN USE BY SPECIFIED HOST
LEP10D	HS	0
	LR	R14,R1			:SAVE HOST NUMBER
	LR	R1,R15			:REQUESTED PORT GROUP 
	OHI	R1,8080			:+ 8080
	JAL	R9,WHWI			:RETURN PORT GROUP NUMBER
	NHI	R15,3F			:ISOLATE RELEVANT BITS AND
	EXBR	R15,R15			:COMPUTE HW OFFSET FOR PORTS TO EXAMINE

L10D10	CLHI	R15,NDP*2		:OUT OF RANGE FOR DISPATCHER PORTS?
	JGE	L10D40			:YES - MARK REMAINING PORTS UNUSED...
	IF	ISIS
	LIS	R1,0			:R1 CARRIES 1 BIT FOR EACH PORT IN USE
	LIS	CHN,0			:INIT CHN FOR THIS GROUP OF 10
L10D20	LHL	R0,DHSTIX,R15,CHN	:GET HOST # FOR CIRCUIT ON THIS PORT
	CR	R0,R14			:IS THIS THE HOST SPECIFIED?
	JNFS	L10D30			:NO
	OH	R1,HMSK,CHN,		:YES - TURN ON BIT FOR THIS PORT
L10D30	AIS	CHN,2
	THI	CHN,1E			:DONE WITH THIS GROUP OF 10?
	JNBS	L10D20			:NO
	JAL	R9,WHWI			:YES - PASS IT ON

	AHI	R15,20			:INCREMENT TO NEXT GROUP OF 10 PORTS
	THI	R15,0FE			:DONE WITH PSTAT?
	JN	L10D10			:NO
	J	LEP1			:YES - RETURN TO LEP COMMAND PROCESSOR
	EI	:ISIS

:	PAD REMAINING PORT ENTRIES WITH ZEROS
L10D40	LIS	R1,0
	JAL	R9,WHWI			:UNUSED PORTS...
	AHI	R15,20
	THI	R15,0FE			:DONE?
	JNBS	L10D40			:NO
	J	LEP1			:YES - RETURN

LEP10E	LA	R7,SUPACP,,		:SUPERVISOR ACP ADDRESS
	LHI	R6,(NSP+07)/8		:# OF GROUPS
	J	LEP10C

:	PORT STATUS REQUEST IS FOR LINK. FIND LINK DESCRIPTOR, 
:	ACP OFFSET, AND NUMBER OF CHANNELS TO SCAN.
L10LNK	HS	0
	LR	R10,R15			:GET PORT GROUP BYTE AND
	NHI	R10,3F			:ISOLATE PORT GROUP NUMBER
	LR	R1,R14			:GET NODE NUMBER AND
	NHI	R1,7FFF			:MASK OUT HIGH-ORDER BIT
	JAL	R9,FNDLNK		:FIND LINK DESCRIPTOR FOR THIS NEIGHBOR
	J	LEP10G			:NEIGHBOR DOES NOT EXIST
	TBT	KN,ALINKS		:IS LINK ACTIVE?
	JE	LEP10G			:NO, SEND REPORT TO SUP

	LHL	R7,FLDPKN,KN,KN
	LA	R7,LNKACP,R7,		:ADDRESS OF ACP ARRAY FOR THIS LINK
	LHL	R6,NCHN,KD		:NUMBER OF CHANNELS ASSIGNED TO LINK
	SRLS	R6,3			:NCHN/8 = # BYTES OF ACP FOR THIS LINK

	LR	R15,R10			:RESTORE R15 FOR PSTAT RESPONSE, LEP10C
	SLLS	R10,4			:PORT GROUP*10=BYTE DISPLACMNT INTO ACP
	LR	R9,R6			:NUMBER OF BYTES OF ACP ARRAY TO SCAN
	SR	R9,R10			:MINUS PORT GROUP OFFSET IS POSTIVE?
	JG	LEP10C			:GO FORMAT PSTAT RESPONSE

LEP10X	OHI	R1,200			:ARRAY OUT OF RANGE,
	JFS	LEP10V			: SEND 8080+200+ARRAY#
LEP10G	LHI	R1,8180			:NODE/HOST UNKNOWN,
					: SEND 8080+100+PORT ARRAY#
	NHI	R15,3F			:EXTRACT PORT ARRAY NUMBER
	OR	R1,R15			:INCLUDE PORT ARRAY NUMBER INTO R1
LEP10V	JAL	R9,WHWI			:SEND ERROR RESPONSE TO SUP
	LIS	R5,8			:SEND 8 HW OF 1'S
	LCS	R1,1
LEP10B	JAL	R9,WHWI			:RETURN -1 FOR PORT GROUP #
	SIS	R5,1
	JGBS	LEP10B
	J	LEP1

	SUBTTL	LEP (LEP11 - Type 11:  Assign channel to TYMNET-I)

::*********************************************************************
::
::	COMMAND:	LEP11:
::	FUNCTION:	PROCESS 'ASSIGN CHANNEL TO TYMNET-I' COMMAND.
::
::*********************************************************************

:	THE COMMAND FORMAT IS DESCRIBED WITH 1 HALFWORD PER LINE, AS FOLLOWS:
:		TYPE (11), CHANNEL NUMBER
:		NEIGHBOR NUMBER
:		FIRST 2 BYTES INVOICE NUMBER
:		LAST 2 BYTES INVOICE NUMBER

:	IF THE TYMNET-I CHANNEL IS SUCCESSFULLY ASSIGNED, A 'CHANNEL ACK'
:	IS RETURNED TO THE SUPERVISOR. THE FORMAT OF THE CHANNEL ACK IS:
:		TYPE (16), CHANNEL NUMBER
:		FIRST 2 BYTES INVOICE NUMBER
:		LAST 2 BYTES INVOICE NUMBER

LEP11	HS	0
	JAL	R9,GHWI			:DISCARD NODE# (OURS, ALREADY VERIFIED)
	JAL	R9,GHWI			:GET TYPE (11), AND CHANNEL NUMBER
	LBR	R1,R1			:ISOLATE CHANNEL NUMBER,
	STB	R1,LEPSV1		:AND SAVE
	LR	R10,R1
	JAL	R9,GHWI			:GET TYMNET-I NEIGHBOR NUMBER
	JAL	R9,FNDLNK		:FIND LINK DESCRIPTOR TO T-I NEIGHBOR
	J	LEP11C			:LINK DOESN'T EXIST, TELL XRAY NO NGHBR
	TBT	KN,ALINKS		:IS LINK ACTIVE?
	JE	LEP11C			:NO - REPORT TO XRAY
	JAL	R9,GHWI			:GET FIRST 2 BYTES OF INVOICE NUMBER
	STH	R1,CQINV		:AND SAVE
	JAL	R9,GHWI			:SAME FOR LAST 2 BYTES
	STH	R1,CQINV+2,,
	JAL	R8,GFCBUF		:GET BUFFER FROM FREE POOL
	J	OP8463			:immed. ret - out of buffers!###wjl
	LHL	CHN,LKZFKN,KN,KN	:GET ABSOLUTE CHANNEL NUMBER OF FIRST
					: CHANNEL ON THIS LINK AND
	AR	CHN,R10			:ADD TO RELATIVE CHANNEL THIS LINK.
	LHL	R0,IOTAB,CHN,CHN
	JN	LEP09U			:PERMUTER TABLE ENTRY NON-ZERO,
					:CHANNEL IN USE
:	NEIGHBOR LINK UP AND CHANNEL AVAILABLE. BUILD HALF-CIRCUIT AND
:	RESERVE CHANNEL TO TYMNET-I NEIGHBOR.
	JAL	R9,CRQHCR		:BUILD HALF CIRCUIT
	LHI	R0,EARLFL		:SET UP BF,ALLOW EARLY DATA ON CIRC AND
	STH	R0,BF,R2,		:HOLD HALF CIRC UNTIL NEEDLE ARRIVES
	SRHLS	R2,3
	SBT	R2,REBTMI,,		:THIS BUFFER WILL TIME OUT
					: IF NO NEEDLE ARRIVES
:	FORMAT CHANNEL ACK RESPONSE TO SUPERVISOR
	JAL	R10,SUPMHD		:SET UP MESSAGE HEADER
	LB	R1,LEPSV1		:GET CHANNEL NUMBER BACK AND
	OHI	R1,1600			:COMBINE WITH RESPONSE MESSAGE TYPE
	JAL	R9,WHWI
:	NOW ECHO BACK INVOICE NUMBER
	LHL	R1,CQINV
	JAL	R9,WHWI			:FIRST 2 BYTES OF INVOICE NUMBER
	LHL	R1,CQINV+2,,
	JAL	R9,WHWI			:LAST 2 BYTES OF INVOICE NUMBER
	J	LEP1			:GET NEXT COMMAND

LEP11C	HS	0			:NO NEIGHBOR OR LINK DOWN
	ST	R2,LEPSV1		:SAVE BUFFER INDEX
:	SEND NODE REPORT FOR 'NO NEIGHBOR'
	LHI	R0,NR.NNE
	STH	R0,SUPMBF		:REPORT TYPE
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER NOT FOUND
	LHL	R0,NEDFLG
	STH	R0,SUPMBF+4		:NEEDLE FLAGS
	JAL	R10,SUP12		:SEND NODE REPORT TO SUPERVISOR LOG
	L	R2,LEPSV1		:RESTORE BUFFER INDEX TO RETURN IT...
	JAL	R9,GHWI
	JAL	R9,GHWI			:DISCARD REMAINDER OF MESSAGE
	J	LEP1			:GET NEXT COMMAND

	SUBTTL	LEP (LEPZAP:  Handle command circuit zapper)

::*********************************************************************
::
::	LEPZAP:
::	FUNCTION:	PROCESS ZAPPERS ARRIVED ON COMMAND CIRCUITS
::
::*********************************************************************

LEPZAP	HS	0			:ZAPPER ON COMMAND CIRCUIT
	LHI	R0,LEPZFL,CHN		:GET ABSOLUTE CHANNEL NUMBER AND
	RBT	R0,TRCHAN,,		:TURN OFF TRACING FOR THIS CHANNEL
	JAL	R8,PCI
	CLHI	R1,GOBBL&0FF		:TEST FOR ZAPPER
	JL	LEPZA2			:YES - COMPLETE CIRCUIT TEARDOWN
:	AN 03-CHARACTER PAIR WHICH IS NOT A ZAPPER IS RATHER ANOMALOUS...
:	ZAP COMMAND CIRCUIT, AND ISSUE NODE REPORT
	OI	R1,0FFFF0300
	ST	R1,SUPMBF+2		:SHOW WHAT WE GOT
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP COMMAND CIRCUIT...
	LHI	R1,NR.I3C
	STH	R1,SUPMBF		:INDICATE INVALID 03-CHARACTER PAIR
	JAL	R10,SUP12		:SUP12 WILL BUFFER NODE REPORT
	JFS	LEPZA3			: UNTIL RE-TAKEN
LEPZA2
	JAL	R9,ZAPV			:GOT A ZAPPER - TEAR DOWN CIRCUIT
LEPZA3	IF	SUPER			:IF FROM OUR SUP, REBUILD CIRC
	LHL	R0,LIOTAB,,
	JNFS	LEPZA4
	JAL	R9,SUPCRQ
	EI	:SUPER
LEPZA4	LHL	R4,TVRBUF		:IS IT FROM REIGNING SUP?
	XHI	R4,4
	CLH	R4,LEPINB
	JN	BIDDRT,,		:NO, EXIT
	IF	T2GATE			:RPT TO INET SUP HST SHUT ##AL
	LIS	R3,HSHUT
        STB     R3,HSTAT                :we are shut
	JAL	R10,GHSTST		:HST STATUS TO INET SUP
	EI	:T2GATE
	LHL	R0,TVRSUP		:GET CURRENT SDUPERVISOR NUMBER
	JAL	R8,CRYPTO,,		:TELL XRAY
	HC	CRYE07			:MESSAGE = SUP CRQ LOST
	LIS	R0,0			:YES, NO MORE SUPER
	STH	R0,TVRBUF
	STH	R0,TVRSUP
	IF	ISIS&(1-T2GATE)
	LIS	R0,8			:ROOM FOR NO SUP MSG
	JAL	R8,DIROOM
	LHI	R0,INNOSP^8		:NO SUP MESSAGE			###jhl
	LHL	R8,DRIF,,		:GET FILL POINTER
	ST	R0,DIRNG,R8,		:SAVE IT
	AIS	R8,4			:BUMP INDEX
	NHI	R8,DRSZ-1		:FIX WRAP
	STH	R8,DRIF,,
	EI	:ISIS&(1-T2GATE)	:###EV

	J	BIDDRT,,

	SUBTTL	LEP (Utilities and tables)

::*********************************************************************
::
::	SUBROUTINE:	LEPGMS:
::	FUNCTION:	COPIES LEP MESSAGES TO INTERMEDIATE BUFFER
::	CALLING SEQ:	JAL	R9,LEPGMS
::
::*********************************************************************

LEPGMS	HS	0
	LA	R4,LEPNOD
	LHI	R6,-2,LRC
LEPGM1	JAL	R8,GCI
	LR	R1,R1
	JNFS	LEPG10
	JAL	R8,GCI
	SIS	R6,1
LEPG10	STB	R1,0,R4
	AIS	R4,1
	SIS	R6,1
	JGBS	LEPGM1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	SUPMHD:
::	FUNCTION:	CREATE A SUP MESSAGE HEADER
::	CALLING SEQ:	JAL	R10,SUPMHD
::
::*********************************************************************

SUPMHD	HS	0
	LHL	R2,TVRBUF
	JE	LEP1			:NO SUP, ABORT
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	JR	R10

::*********************************************************************
::
::	TABLE:		LEPDIS:
::	FUNCTION:	LEP DISPATCH TABLE
::
::*********************************************************************

LEPXX	EQ	LEPXT-SEG1

LEPDIS	HC	LEP08-SEG1,LEP09-SEG1,LEPXX,LEP0B-SEG1
	HC	LEP0C-SEG1,LEP0D-SEG1,LEP0E-SEG1,LEP0F-SEG1
	HC	LEP10-SEG1,LEP11-SEG1
LEPDMX	EQ	(.-LEPDIS)/2	:NUMBER OF VALID LEP COMMANDS

::*********************************************************************
::
::	TABLE:		LEP0FT:
::	FUNCTION:	LEP0F SUBTYPE DISPATCH TABLE
::
::*********************************************************************

LEP0FT  HC	LEPHTM-SEG1,LEPBRZ-SEG1,LEPBRU-SEG1,LEPRBJ-SEG1
	HC	LEPDLL-SEG1,LEPZLI-SEG1,LEPSPR-SEG1,LEPLSP-SEG1
	HC	LEPHRJ-SEG1,LEPBGL-SEG1,LEPRKD-SEG1,LEPAKD-SEG1
	HC	LEPNOP-SEG1
LEPN0F	EQ	(.-LEP0FT)/2	:NUMBER OF LEP 0F TYPE COMMANDS

:	***END LEP***

	ENDMO.(LEP)
	EI	:1-KILLIT
	KILMSG(LEP)

:	***NOTHING PAST THIS POINT***

	SUBTTL	CRQ

:			 ***  ****   ***
:			*   * *   * *   *
:			*     ****  *   *
:			*   * *  *  *  **
:			 ***  *   *  ****

::#####################################################################
::
::	MODULE:		CRQ
::
::	FUNCTION:	Circuit building, teardown, timeout, detach,
::		and trace routines.
::
::	SUBTTLS:
::		CRQ - Second half circuit building
::		Circuit building routines
::		Utilities
::		DETCIR - Handle data for 'Detached Ports'
::		TRACE - Circuit tracing logic
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA  0
	SEG  1

::*********************************************************************
::
::	SUBPROCESS:	CRQ:
::	FUNCTION:	Completes the "second half" of the circuit-building
::			process.
::	SCHEDULED:	Like LOGGER, gets called when there is something in its
::		buffer (CRQBUF) by SWITCH.  Returns to SWITCH (CRQRET) when
::		done.
::		When LEP or RTD writes a needle into a buffer, it writes
::		the buffer's index into CRQBUF via CRQALT.  CRQ makes one
::		pass through this list of buffers, servicing as appropriate.
::
::*********************************************************************

:	Write a 00 marker into CRQBUF.  When we come to it,
:	we'll know we're thru.
CRQ	HS	0
	LIS	R2,0			:PUT A 0 MARKER IN THE CRQ BUFFER

:	Come back here to put a buffer back in CRQBUF for further processing
:	next time around.
CRQ10	HS	0
	LR	R1,R2			:WRITE THE BUFFER # IN R2 INTO CRQBUF
	LIS	R2,CRQBUF		:R1=0 ON FIRST PASS, BUFFER # OTHERWISE
	JAL	R9,WHWI0		:WHWI0 ALLOWS USE OF BUFFER # 0

:	Come here to get the next buffer that needs service.
:	If it's our 0-marker, we're done, go to CRQRET.
CRQ20	HS	0
	LIS	R2,CRQBUF		:PROCESS NEXT BUFFER IN THE LIST
	JAL	R9,GHWI0		:BUFF IN WHICH NEEDLE IS ASSEMBLED
	LR	R2,R1
	JE	CRQRET			:IF THE 0 MARKER, WE'RE DONE

:	DO RANGE CHECK TO INSURE VALID BUFFER NUMBER
:	Buffer index must be in range (>=CIRZBF, <=HBUFN-8).
:	If not, crash. Else, continue at CRQ40.
	CLHI	R2,CIRZBF
	JLFS	CRQ30			:ERROR - TOO LOW
	CLI	R2,HBUFN-8
	JLEFS	CRQ40			:BUFFER NUMBER O.K.
CRQ30	HS	0
	CRASH.(.CRQCR)			:Bad buffer index in CRQBUF
CRQ40	HS	0			:Buffer index OK
	STH	R2,CQNBUF		:SAVE THE NEEDLE BUFF #
	IF	NDREAD
	SEG	0
NDRDSV	WS	1			:buffer number needle copy is in
	SYAD(NDRDSV)			:control cell for needle read
NDRFLG	HS	1	
	SEG	1
	LH	R9,NDRFLG,,		:did XRAY enable this?
	JE	NDRD90			:jump if disabled (zero)
	LR	R9,R2			:save needle buffer in R9
	L	R3,BB,R9,		:get start of needle buffer
	L	R2,NDRDSV,,		:get dest buffer if we have one already
	JNFS	NDRD10	
	JAL	R8,GFCBUF,,		:get a working buffer from free pool
	J	OP8463			:immed. return - crash, no buffers left
	ST	R2,NDRDSV,,		:+4 return, ok - save buffer number
NDRD10	JAL	R8,PCI,,		:peek at chars from needle buffer
	LR	R5,R3			:WCI kills R3
	JAL	R8,WCI,,		:write them into dest buffer
	LR	R3,R5			:restore pointer into needle buffer
	C	R3,BE,R9,		:test for end of needle buffer
	JNBS	NDRD10			:loop for all data
	JAL	R8,PCI,,		:get the last character
	JAL	R8,WCI,,
	LHL	R2,CQNBUF		:restore needle buffer number to R2
NDRD90	EI	:NDREAD
:	If the buffer's BF is marked for "intercept" (=INCPFL),
:	go handle at CRQINT.
	IF	REBILD
	LHL	R0,BF,R2,		:IF BF=INCPFL, IT'S AN 'INTERCEPT'
	CLHI	R0,INCPFL
	JE	CRQINT
	EI	:REBILD
:	If 1st byte in buffer not a possible needle point (03xx),
:	go to garbage-handler (CRQER1).
	JAL	R8,PCIS			:TEST FOR NEEDLE POINT
	CLHI	R1,NEEDP/100		:DO WE START WITH "03
	JN	CRQER1			:GARBAGE
	JAL	R8,PCI			:GOT AN 03 - LOOK AT NEXT BYTE
:	If 1st HW in buffer not a needle point (0310), go to CRQZOG.
	CLHI	R1,NEEDP&0FF		:IS IT "10
	JN	CRQZOG			:NOT NEEDLE POINT,SOME OTHER 03-XX PAIR
:	Got a needle point (via peeks only so far).
:	It should look like this in the buffer:
:		[0310]
:		[00cc] - byte count
:		[00ll] - link count
:		[iiii]
:		[iiii] - invoice number
:		[ffff] - 8080+flags
:		[nnnn] - origin node#
:		[pppp] - requesting port#
:		[mmmm] - node list (several of these HW's)
:	Get and save off these quantities via peeks
:	(i.e., leave the buffer as is).
	JAL	R8,PCI			:GOT NEEDLE - SKIP OVER LENGTH ESCAPE
	JAL	R8,PCI			:BYTE COUNT
	STH	R1,CQNSZ		:SAVE IT
	JAL	R8,PCI			:GET ESCAPE FOR LINK COUNT
	JAL	R8,PCI			:READ LINK COUNT
	NHI	R1,7F			:MASK HIGH ORDER BIT
	STH	R1,CQNLK		:AND SAVE LINK COUNT
	JAL	R9,PHWI			:READ 4 BYTES OF INVOICE #,HW AT A TIME
	STH	R1,CQINV		: AND STORE FOR LATER
	JAL	R9,PHWI			:READ SECOND HALFWORD
	STH	R1,CQINV+2,,		: AND STORE FOR LATER
	JAL	R9,PHWI			:GET FLAGS
	LR	R7,R1			:SET R7=FLAGS (+8080)
	STH	R1,CQNFLG,,		:SAVE THEM TOO
	JAL	R9,PHWI			:READ AND SAVE REQUESTING NODE
	STH	R1,CQNODE
	JAL	R9,PHWI			:READ AND SAVE REQUESTING PORT
	STH	R1,CQPORT

:	Now go through the node list, ignoring FFFF's (nodes already processed
:	by other nodes) until we find one that is not FFFF.  If the 8000 bit
:	is set, it should be us, go to CRQTRM.  If not, see if it's for an
:	active neighbor. If not (either active or a neighbor), go zap
:	the needle (CRQNNE).
CRQ50	HS	0
	LR	R5,R3			:SLEW OVER 'CREAMED' NODE #'S
	JAL	R9,PHWI			:READ NEXT NODE NUMBER
	CI	R1,0FFFF		:ALREADY PROCESSED AT ANOTHER NODE?
	JEBS	CRQ50			:IF -1, IT WAS CROSSED OFF
	TI	R1,8000			:ARE WE THE TERMINATION NODE?
	JN	CRQTRM			:YES--HIGH BIT SET 

CRQNOD	JAL	R9,FNDLNK		:FOR T-II NEIGHBOR - LOCATE LINK
	J	CRQNNE			:NOT THERE, ZAP NEEDLE

CRQ60	TBT	KN,ALINKS		:FOUND THE T-II LINK, IS LINK ACTIVE?
	JE	CRQNNE			:NOPE, ZAP NEEDLE

:	Got a needle for an active neighbor.
:	Check for shrink activity on link (SHSTAT) and if true (RMAKE frozen),
:	return this buffer to CRQBUF for later handling (go to CRQ10).
	LH	R0,SHSTAT,KD		:ANY SHRINK ACTIVITY?
	JN	CRQ10			:YES - RETURN BUFFER BACK TO CRQ LIST

:	So far, so good. Change our node number in the needle in the buffer
:	(JAL CHWI) to FFFF.
CRQ62	HS	0
:	EDITS COMPLETE ON DESTINATION LINK. CREAM NEIGHBOR NUMBER IN NEEDLE...
	LR	R3,R5			:POINTER TO NEIGHBOR # ENTRY IN NEEDLE
	JAL	R9,CHWI			:STORE 'FFFF', CREAMS NEEDLE ENTRY
	GL	CHWI

:	Find an available channel (JAL FNDKNC). If none, go to CRQER2.
CRQ64	HS	0
	LHL	R1,NCHN,KD		:NUMBER OF CHANNELS ON LINK
	JAL	R9,FNDKNC		:FIND AVAILABLE CHANNEL
	GL	FNDKNC			: (RETURNS CHAN# IN CHN)
	J	CRQER2			:OUT OF CHANNELS

:	New channel better be available (IOTAB=0). If not,
:	go zap needle at CRQCHU.
CRQ70	HS	0
	LHL	0,IOTAB,CHN,CHN		:IS THERE A CIRCUIT THERE?
	JN	CRQCHU			:YES, ZAP NEEDLE

:	Got a good channel.  Bump count of circuits completed (NC.CRC) and
:	build the last half of the circuit.
CRQ72	HS	0
	LIS	R3,1
	AHM	R3,NC.CRC		:COUNT CIRCUITS COMPLETED

:	BUILD LAST HALF OF CIRCUIT...
:	Set up our BF and get the speed bits from the needle into R1.
:	If the source channel is not a link neighbor, go on to CRQ90.
	STH	CHN,BF,R2,		:STORE ONGOING CHANNEL NUMBER INTO BF

	IF	CBZDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,CRQDB1,,
	GL	CRQDB1
	L	R4,REGST,,
	EI	:CBZDBG

	XHI	R2,4			:FLIP TO ONGOING CHANNEL'S BUFFER
	LHL	R3,BF,R2,		:READ INCOMING CHANNEL NUMBER INTO R3
	LR	R1,R7			:GET THE SPEED BITS FROM NEEDLE
	SRHLS	R1,4
	NHI	R1,3
	CLHI	R3,LNKZFL		:IS INCOMING CIRCUIT FROM A NEIGHBOR?
	JL	CRQ90			:NO, INTERNAL, SKIP NETWORK BOOKKEEPING
	CLHI	R3,LNKLFL
	JGE	CRQ90
:	Needle came from a neighbor, need to set/reset various bits for the
:	incoming channel, some of them depending on needle flags.
	SBT	R3,BPSVCP-LNKZFL/8,,	:ENABLE RMAKE SERVICE OF THIS CHANNEL
	SBT	R3,LNKBPV-LNKZFL/8,,
	RBT	R3,PRIRTY-LNKZFL/8,,
	RBT	R3,CMDCTS-LNKZFL/8,,
	THI	R7,NF.PRI		:TEST FOR PRIORITY CIRCUIT
	JEFS	CRQ74			:NOT A PRIORITY CIRCUIT
	SBT	3,PRIRTY-LNKZFL/8,,
CRQ74	THI	R7,NF.CMD		:TEST FOR COMMAND CIRCUIT
	JEFS	CRQ76			:NOT A COMMAND CIRCUIT
	SBT	R3,CMDCTS-LNKZFL/8,,
:	If the needle is not headed toward a (T-II) neighbor
:	(internal or T-I termination), skip to CRQ80.  Otherwise,
:	inc the passthru count and init various bits for the out-going channel.
CRQ76	HS	0
	CLHI	CHN,LNKZFL		:IS IT TOWARDS A NEIGHBOR?
	JL	CRQ80			:NO
	CLHI	CHN,LNKLFL
	JGE	CRQ80
	LHL	R0,PASTHR		:INCREMENT PASSTHROUGH COUNT
	AIS	R0,1
	CLH	R0,MXPASS		:NEW HIGH FOR # OF PASSTHRUS?
	JLEFS	CRQMPS			:NO
	STH	R0,MXPASS		:YES, STORE THE NEW PEAK
CRQMPS	STH	R0,PASTHR
CRQ78	SBT	CHN,CHSRVD-LNKZFL/8,,	:MAKE SURE NEEDLE TRAVELS
	SBT	CHN,BPSVCP-LNKZFL/8,,
	RBT	CHN,PRIRTY-LNKZFL/8,,
	RBT	CHN,CMDCTS-LNKZFL/8,,
:	Inc NEDOUT (count of needles outstanding between CRQ and RMAKE).
:	(Can't let a shrink occur while this is true.)
	LIS	R0,1			:INCREMENT # OF NEEDLES OUTSTANDING
	AHM	R0,NEDOUT,KD		:BETWEEN CRQ AND RMAKE

	SBT	CHN,NEEDLE-LNKZFL/8,,	:NEW NEEDLE FOR THIS CHANNEL

	THI	R7,NF.CMD		:TEST FOR A COMMAND CIRCUIT
	JEFS	CRQ79			:NOT A COMMAND CIRCUIT
	SBT	CHN,CMDCTS-LNKZFL/8,,
CRQ79	THI	R7,NF.PRI		:TEST FOR PRIORITY CIRCUIT
	JEFS	CRQ80			:NO
	SBT	CHN,PRIRTY-LNKZFL/8,,	:YES - GIVE THIS CIRCUIT PRIORITY

:	Here after bookkeeping done for needle from one neighbor to another,
:	or from neighbor to internal termination (or T-I neighbor).
CRQ80	HS	0
	LHL	R0,IOTAB,R3,R3		:GET THE INCOMING BUFFER NUMBER
	OR	R0,R1			:OR IN THE SPEED BITS
	STH	R0,IOTAB,R3,R3
:	Merge the speed bits (R1) from the needle flags into
:	the incoming channels IOTAB and complete the IOTAB entry
:	for the outgoing channel.  Mark the new channel active (+/-ACP),
:	report "circuit built" to CRYPTO (CRYE0B), set the inbound buffer's
:	attention flag if appropriate, and return to mainline via CRQ20.
CRQ83	HS	0
	AR	R1,R2			:MERGE SPEED BITS INTO OUTGOING BUFFER
	STH	R1,IOTAB,CHN,CHN	:AND COMPLETE THE PERMUTER TABLE ENTRY
	RBT	CHN,ACP,,		:ACTIVE PORT
::Report International Record Carrier for Inet login to Hnet link here!
	IF	T2GATE
	IF	IRC
	CHI	R3,DISZFL
	JL	CRQ84			:SKIP IF NOT USER CIRCUIT
	CHI	R3,DISZFL+NDP
	JG	CRQ84
	SHI	R3,DISZFL
	LR	R8,R3			:SAVE TO R8 FOR LATER USE
	LR	R3,CHN			:ABSOLUTE CHAN# TO HNET LINK
	JAL	R9,FCHLNK		:FIND LINK#
	J	CRQ84			:ERR RETURN
        LR      R1,R0   :cannot index off of R0 ###sdw
	LB	R0,IRCTBL,R1		:FIND IRC VALUE FOR THIS LINK
	JE	CRQ84			:SKIP IF NO VALUE
	STB	R0,GB7REA		:STORE INTO CANNED MSG.
	STH	R8,GB7PRT		:R8 IS IRC REPORT DISP. RRT
	LHI	R1,0E00E		:MSG.# IS 14 FOR IRC LOCATN
	STH	R1,GB7INV		:Store anew message
	LIS	R1,0
	STB	R1,GB7INV+2		:(may have been previously used)
	LA	R1,GDB7M		:IRC REPORT
	LHI	R3,GDB7L		:LENGTH BYTE
	JAL	R8,DIZSMS		:REPORT TO INET SUP AT PORT 0
CRQ84		
	EI	:IRC

	EI	:T2GATE

	LCS	R0,1
	SR	R0,CHN
	RBT	R0,ACP,,		:MARK NEGATIVE ACP AS WELL
	LHL	R0,BF,R2,		:CRYPTO - ONE OF THE PORTS
	EXHR	R0,R0			:SHIFT UP 
	XHI	R2,4
	LHL	R8,BF,R2,		:THE OTHER PORT
	AR	R0,R8
	JAL	R8,CRYPTO,,
	HC	CRYE0B			:CRYPTO MESSAGE - CRQ BUILT
	IF	INTACC&(1-T2GATE)			:###EV
	JAL	R8,AASTRT
	GL	AASTRT
	NOP
	EI	:INTACC&(1-T2GATE)
CRQ110	LHL	R1,BCT,R2,		:ANYTHING IN BUFF?
	JE	CRQ20			:NIX, RETURN TO MAINLINE
	LHL	R1,BF,R2,		:SET ATTN FLAG
	SBT	R1,NFLAGS,,
	LHL	R0,PASTHR               :section moved here from CRQ78  ###sdw
	CLHI	R0,NPASTH		:out of passthroughs?		###wjl
	JL	CRQ20			:no				###wjl
	LHL	R0,PTHRPD		:what was our last report?	###wjl
	JE	CRQ20			:zero=out of passthrus reported	###wjl
	JAL	R10,SUP0B		:make Resources Report to Sup	###wjl
	J	CRQ20			:RETURN TO MAINLINE

:	Here because needle did not come from a neighbor.  If from an ??
CRQ90	HS	0
	CLHI	CHN,LNKZFL
	JL	CRQ80
	CLHI	CHN,LNKLFL
	JGE	CRQ80
	J	CRQ78

:	Here from CRQ50 if we are the destination of a needle.
CRQTRM	HS	0
	NHI	R1,7FFF			:TERMINATION - SAVE THE HOST #
	LR	HN,1
	STH	HN,CQHOST,,

:	If it is a REBILD needle, skip to CRQREB.
:	If for an internal circuit,
:	skip to CRQTR3 (no need to make circuit rebuildable).
	IF	REBILD
	THI	R7,NF.REB		:IS REBUILD BIT IN NEEDLE FLAGS SET?
	JN	CRQREB			:YES, THIS IS A REBUILD NEEDLE
	LHL	0,CQNLK			:IS ORIGIN IN THIS NODE (# LNKS=0)?
	JE	CRQTR3			:YES, CIRCUIT WILL NEVER NEED REBILDING

:	We are the termination of a new circuit that may be rebildable.
:	Save the invoice number for possible REBILD use, compute and save away
:	the max history buffer size (based on gouging level and number of
:	links in circuit), set/reset various REBILD bits, and stuff a SQFX0
:	into the buffer toward the circuit origin.
	LR	R4,R2			:FORM INDEX INTO INVOICE-NUMBER ARRAY
	SRHLS	R4,1			:BASED ON CIRCUIT BUFFER NUMBER
	L	R0,CQINV		:RECOVER THE INVOICE NUMBER
	ST	R0,RINVC+HBUFN,R4,	:AND SAVE FOR POSSIBLE FUTURE REBUILD
	LR	R5,R7			:COMPUTE HISTORY BUFFER SIZE
	HSIZE(R5)			:BASED ON THROUGHPUT CLASS	###CY
	STH	R0,RHBSZ+HBUFN,R4,	:STORE AWAY FINAL HISTORY BUFFER SIZE
	SRHLS	R4,2
	SBT	R4,CRQBSY		:MARK CREATION OF A REBUILDABLE CIRCUIT
	SBT	R4,CRQEND		:MARK CREATION OF A CIRCUIT TRMINATION
	RBT	R4,SQFTMO		:CLEAR REBUILD TIMEOUT BIT	###GT
	SBT	R4,SQFTMI		:SET BIT FOR TIMEOUT COUNTER	###GT
	XHI	R2,4			:FLIP TO OTHER BUFFER		###GT
	JAL	R9,SNDFX0		:SEND OUT SQFIX WITH SEQN = 0	###GT
	XHI	R2,4			:RESTORE BUFFER INDEX

	ELSE	:NOT REBILD
	THI	R7,NF.REB		:ZAP REBUILD NEEDLES
	JN	CRQZPN

	EI	:REBILD

:	If this is a command circuit, go to CRQLEP.
:	If for a T-I neighbor, go to CRQTNI.
CRQTR3	HS	0
	THI	R7,NF.CMD		:IS THIS A COMMAND CIRCUIT?
	JN	CRQLEP			:YES, IT'S FOR THE LEP
	THI	R7,NF.T1D		:TEST FOR TYMNET-I DESTINATION
	JN	CRQTNI			:YES

:	Must be for a host.  If not HST0, must be ISIS host, go to CRQHS2.
CRQHST	HS	0
	CLHI	HN,HST0			:CIRCUIT FOR A HOST
	IF	T2GATE
	JN	CRQHSZ			:Gateway should have a match w/HST0
	ELSE
	JN	CRQHS2			:FOR A DISPATCHER HOST
	EI	:T2GATE
	IF	EXPSEC			:Needle for internal host
	IF	(1-T2GATE)		:Gateway must save Needle for now
	JAL	R9,TRUNC		:DISCARD NEEDLE
	GL	TRUNC
	L	R3,BB,R2,		:INTERNAL HOST, CHECK USER NAME
	EI	:(1-T2GATE)		:Gateway discards it next time around
					:and does not need a reload of R3
	JAL	R9,PCIE			:This is TID
	STB	R1,CQTID		:Save for Gateway Log-in purposes
	GL	PCIE
	JAL	R9,PCIE			:SKIP OVER TID AND ORIGINATION DATA
	JAL	R9,PCIE			:WHICH MAY BE ESCAPED
	JAL	R9,PCIE
	JAL	R8,PCI
	LIS	R4,0			:COUNT USERNAME CHARS
	ST	R4,XUTMP,,		:CLEAR TEMP USERNAME AREA
	ST	R4,XUTMP+4,,		:FOR 12(D) CHARS
	ST	R4,XUTMP+8,,
	CLHI	R1,0A1			:= "!" ?
	JNFS	CRQH10
CRQH11	JAL	R8,PCI
CRQH10	NHI	R1,7F			:REMOVE MSB
	CLHI	R1,3B			:SEMICOLON?
	JEFS	CRQH12			:YES
	CLHI	R1,0D			:CARRIAGE RETURN
	JEFS	CRQH12			:YES
	CLHI	R4,0C			:UP TO 12(D) CHARS
	JGEBS	CRQH11			:AFTER 12 CHARS, JUST SCAN FOR CR OR ;
	STB	R1,XUTMP,R4,		:USER NAME FOR VALIDATION
	AIS	R4,1			:BUMP CHAR COUNT
	J	CRQH11			:LOOP UNTIL ALL USERNAME IS IN

CRQH12	LIS	R8,0			:INIT GG LIST INDEX 
CRQH13	LIS	R9,0			:INIT WORD POINTER INTO XUTMP
CRQH16	L	R1,XRAYGG+XGGNAM,R8,R9	:COMPARE TO GOODGUY LIST
	NI	R1,7F7F7F7F		:CLEAR MSB
	C	R1,XUTMP,R9,		:GET USERNAME FROM NEEDLE
	JNFS	CRQH14			:NAME DOESN'T THIS MATCH ENTRY
	AIS	R9,4			:BUMP FW INDEX INTO XUTMP
	CR	R9,R4			:ANY MORE FWS OF USERNAME IN XUTMP
	JGEFS	CRQH15			:NAME MATCH FOUND
	JBS	CRQH16			:CHECK MORE OF THIS ENTRY
CRQH14	AHI	R8,XGGSIZ		:BUMP GGLIST INDEX
	CLHI	R8,XGGLEN		:END OF GGLIST?
	JL	CRQH13			:NO, CHECK NEXT GGLIST ENTRY
	IF	T2GATE
	J	GCRTRM			:If no match and Gateway - user circuit
	EI	:T2GATE

	IF	(1-T2GATE)		:No Kernel stuff for Gateway
	IF	KERNEL!ISIS
	J	CRQHS1			:NOT AN INTERNAL HOST
	ELSE	:KERNEL!ISIS
	LCS	R8,1			:FLAG NO MATCH,
	EI	:KERNEL!ISIS		: INTHST WILL DETACH PROCESS
	EI	:(1-T2GATE)

CRQH15	LR	R4,R8			:BOUND FOR INTHST PROCESSING
					:SET UP INTUSR AS GGLIST INDEX

	ELSE	:EXPSEC			:Needle for internal host
	IF	(1-T2GATE)		:Gateway must save Needle for now
	JAL	R9,TRUNC		:DISCARD NEEDLE
	L	R3,BB,R2,		:INTERNAL HOST, PEEK AT USER NAME
	EI	:(1-T2GATE)		:Gateway discards Needle next time 
					:and does not need a pointer reset
	JAL	R9,PCIE			:This is TID
	STB	R1,CQTID		:Store it for Gateway Log-in
	JAL	R9,PCIE			:SKIP OVER TID AND ORIGINATION DATA
	JAL	R9,PCIE			:WHICH MAY BE ESCAPED
	JAL	R9,PCIE
	JAL	R8,PCI
	CLHI	R1,80+ASCEXP		:0A1 = "!" ?
	JNFS	CRQHX5
	JAL	R8,PCI
CRQHX5	LR	R4,R1			:ASSEMBLE USER NAME
	JAL	R8,PCI
	EXBR	R4,R4
	AR	R4,R1
	EXHR	R4,R4
	JAL	R8,PCI
	EXBR	R1,R1
	AR	R4,R1
	JAL	R8,PCI
	AR	R4,R1

	NI	R4,7F7F7F7F		:CLEAR MSB OF USER NAME
	CLI	R4,58524159		:USER NAME = "XRAY"?
	JEFS	CRQHS5			:YES
	IF	ISIS
	CLI	R4,58524953		:USER NAME = "XRIS"?
	JEFS	CRQHS5			:YES
	EI	:ISIS
	CLI	R4,54494944		:USER NAME = "TIID"?
	JEFS	CRQHS5			:YES
	CLI	R4,444C4F41		:USER NAME = "DLOA" ?
	JN	CRQHS1			:NO,NOT FOR THE INTERNAL HOST
	IF	T2GATE
	J	GCRTRM		:Gateway user circuit
	EI	:T2GATE
	EI	:EXPSEC

CRQHS5	LHI	CHN,INTZFL		:FOR INTERNAL HOST
	LHI	R1,TINTCH		:GET TOTAL # OF INTERNAL HOST CHANNELS
CRQHS4	JAL	R9,FNDCHN		:AND FIND AVAILABLE CHANNEL
	GL	FNDCHN
	J	CRQDL1			:NO,NONE AVAILABLE
	LR	R1,CHN			:FOUND ONE, GET
	SHI	R1,INTZFL		:RELATIVE INT HOST INDEX
	SLLS	R1,2			:FORM FW INDEX
	ST	R4,INTUSR,R1,		:STORE USERNAME
	JAL	R9,TRUNC		:EMPTY NEEDLE BUFF UP TO CURRENT POINTR
	LHL	R1,BCT,R2,		:ANYTHING IN THE BUFFER?!
	JNFS	CRQH23			:YES, LEAVE IT THERE TO SET ATTN FLAGS
	LHI	R1,80			:OTHERWISE STORE A NULL IN THE BUFFER
	JAL	R8,WCI			:TO CAUSE ATTN FLAGS TO BE SET
CRQH23	JAL	R8,NEDTIM		:TEST NEEDLE TIME, RECORD CIRCUIT TIME
	IF	T2GATE&INTACC		
	JAL	R8,AASTRT		:Begin internal host accounting
	NOP				:Range check error, skip accounting
	EI	:T2GATE&INTACC		:###EV
	J	CRQ70			:CONTINUE WITH CIRCUIT BUILDING
CRQDL1	LIS	R0,0
	JAL	R8,CRYPTO,,
	HC	CRYE2E			:MESSAGE - OUT OF INTERNAL HOST PORTS
	IF	ACCT			:###EV
	L	R1,CQINV		:Supply inv # to accounting
	LI	R0,AALR07		:and zap reason for addendum
	JAL	R8,AANCZP		:and send to Sup
	GL	AANCZP
	EI	:ACCT		
	J	CRQZPN

CRQHS1	IF	KERNEL&(1-T2GATE)
	IF	SIORNG
	LH	R0,SIRFLG,,		:IS SIO RING CARD UP?
	JGE	CRQER3			:NO,TREAT AS OUT-OF-PORTS CONDITION##GT
	EI	:SNRING         	: - TREAT DWL AS DOWN CONDITION
	IF	RKERNL
	L	R4,KERACP,,		:FIND AVAILABLE KERNEL PORT
	N	R4,KERCHS,,		:WHICH HAS NOT BEEN ZAPPED RECENTLY
	JFFO	R4,CRQHSK
	J	CRQER3			:NO PORTS
CRQHSK	AHI	CHN,KERZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER
	ELSE	:NOT RKERNL
	LHI	R1,NKU			:# OF KERNEL PORTS
	LHI	CHN,KERZFL
	JAL	R9,FNDCHN		:LOCATE A PORT
	J	CRQER3			:ALL OUT
	EI	:RKERNL
	LHI	R1,-KERZFL,CHN		:SET NEW LOG FLAG
	SBT	R1,KERNWL,,
:	FIRST 4 CHARS IN BUFFER ARE TID, 80, 8000+ORIG HOST. IF ORIG
:	HOST IS 04-07, KERNEL WILL INTERPRET AS NETWORK CHARACTERS SINCE
:	COMMAND CIRCUITS ONLY ESCAPE 00-03. THEREFORE, IF ORIG HOST IS
:	04-07, WE MUST INSERT AN ESCAPE...

:	COPY USER NAME STRING TO LINEAR ARRAY
	LIS	R7,0			:BYTE INDEX, HAS COUNT WHEN DONE
CRQH10	LH	R0,BCT,R2,
	JEFS	CRQH20			:BUFFER EMPTY - USER NAME COPIED
	JAL	R8,GCI
	STB	R1,KERUSR,R7,		:PUT USER NAME IN HOLD AREA
	AIS	R7,1
	JBS	CRQH10

:	USER NAME STRING COPIED
CRQH20	LIS	R6,0
	STB	R6,KERUSR,R7,		:DELIMIT USER NAME WITH NULLS
	STB	R6,KERUSR+1,R7,
	LHL	R1,KERUSR,,
	JAL	R9,WHWI			:RESTORE FIRST 2 BYTES BACK IN BUFFER
	LB	R1,KERUSR+2,,
	JAL	R8,WCI
	LB	R1,KERUSR+3,,		:GET CRITICAL BYTE
	JEFS	CRQH22			:IF ESCAPE, LO-ORDER 00-03 - O.K.
	CLHI	R1,8
	JGEFS	CRQH22			:VALUE ABOVE ESCAPED CHARACTER
:	WE GOT A 04-07...INSERT ESCAPE FOR KERNEL
	EXBR	R1,R1
	JAL	R8,WCI,,			:WRITE 00 (ESCAPE)
	EXBR	R1,R1
CRQH22	JAL	R8,WCI,,
	SIS	R7,4			:4 BYTES ALREADY STORED
	LIS	R6,4
CRQH30	LB	R1,KERUSR,R6,
	JAL	R8,WCI,,		:RESTORE USER NAME BACK IN BUFFER
	AIS	R6,1
	SIS	R7,1
	JGBS	CRQH30
	LHL	R7,CQNFLG,,		:RESTORE NEEDLE FLAGS IN R7
	J	CRQ70

	ELSE	:NOT KERNEL

	J	CRQHSZ
	EI	:KERNEL&(1-T2GATE)

CRQHS2	IF	ISIS			:FOR HOST OTHER THAN HST0
	LR	R1,HN			:DO WE KNOW THIS GUY
	JAL	R9,FNDHST
	J	CRQHSZ			:NO, ZAP

:	TEST FOR HOST OUT OF PORTS
	LHL	R1,HSTPTA,HN,HN		:GET # OF PORTS AVAILABLE, PER LAST MSG
	JE	CRQER6			:NONE, HANDLE HOST OUT OF PORTS

	LHI	R1,NDP-1		:MUST BE A DISPATCHER HOST
	LHI	CHN,DISZFL+1
	JAL	R9,FNDCHN
	J	CRQER4			:OUT OF DISPATCHER PORTS
	LHI	R1,-DISZFL,CHN		:RELIEVE BACKPRESSURE
	SBT	R1,DISBPV
	LHI	R0,INXLIM		:AND GIVE IT XMIT CAPACITY
	STH	R0,DIXLIM,R1,R1
	STH	R1,CQDCHN		:SAVE CHANNEL NUMBER FOR NEEDLE ACK
	J	CRQAK1			:AND GO FORMAT NEEDLE ACK
					:FOR SUPERVISOR STATISTICS
	ELSE	:NOT ISIS
	J	CRQHSZ			:THERE ARE NO OTHERS
	EI	:ISIS

CRQHSZ	LR	R0,HN			:NO SUCH HOST - ZAP
	JAL	R8,CRYPTO,,
	HC	CRYE0D
	J	CRQZPN

CRQLEP	JAL	R9,TRUNC		:LEP CIRCUIT - CLEAR NEEDLE
	LHI	R1,NLQ			:# OF COMM CIRCS
	LHI	CHN,LEPZFL		:BASE COMMAND CIRCUIT
	JAL	R9,FNDCHN		:GET A LEP PORT
	J	CRQER5			:OUT OF COMMAND PORTS
	JAL	R8,NEDTIM		:RECORD TIME
	SBT	CHN,TRCHAN,,		:ENABLE CHARACTER TRACE OF COMMAND CIRC
	J	CRQ70			:BUILD CIRC

CRQTNI	JAL	R9,TRUNC		:TYMNET-I TERMINATION
	LR	R1,HN			:NODE #
	JAL	R9,FNDLNK		:LOCATE LINK
	J	CRQNNE			:NO SUCH LINK
	TBT	KN,ALINKS		:LINK ACTIVE?
	JE	CRQNNE			:NO
	JAL	R9,GHWI			:GET THE CHANNEL # ON THIS LINK
	STH	R1,CQDCHN		:SAVE IT
	LHL	CHN,LKZFKN,KN,KN	:COMPUTE ABSOLUTE CHANN #
	AR	CHN,R1
	LHL	R3,IOTAB,CHN,CHN	:IS THERE DATA WAITING
	JE	CRQSAK			:NO
	NHI	R3,-4
	LR	R1,R1			:IS IT FOR THE SUP CHANNEL?
	JNFS	CRQTN2
	LR	R2,R3			:YES, ZAP THE EXISTING CIRCUIT
	JAL	R9,ZAPHRD
	LHL	R2,CQNBUF
	J	CRQSAK			:BUILD LAST HALF
CRQTN2	LHL	R0,BF,R3,		:BETTER BE EARLY DATA
	CLHI	R0,EARLFL
	JN	CRQCHU			:CHANNEL IN USE
	LIS	R0,0			:EARLY DATA, CLEAR IOTAB ENTRY
	STH	R0,IOTAB,CHN,CHN
	SBT	CHN,ACP,,
	LCS	R2,1			:MARK NEGATIVE ACP ARRAY
	SR	R2,CHN
	SBT	R2,ACP,,
	LR	R2,R3			:SEE IF EARLY ZAPPER WAITING
	JAL	R8,PCIS
	CLHI	R1,3
	JNFS	CRQTN3
	JAL	R8,PCI
	CLHI	R1,ZAPPN&0FF
	JNFS	CRQTN3
	JAL	R8,RFCBUF		:YES, RETURN BUFF & ZAP
	GL	RFCBUF
	J	CRQZPN
CRQTN3	LR	R3,R2
	LHL	R2,CQNBUF
	XHI	R2,4
	L	R0,BB,R3,
	ST	R0,BB,R2,
	L	R0,BE,R3,
	ST	R0,BE,R2,
	LHL	R0,BCT,R3,
	STH	R0,BCT,R2,
	JEFS	CRQTN1			:IF THERE'S DATA...
	LHL	R0,BF,R2,		:	SET THE ATTENTION FLAG
	SBT	R0,NFLAGS,,
CRQTN1	LIS	R0,0
	ST	R0,BB,R3,		:CLEAR THE BUFFER
	ST	R0,BE,R3,
	STH	R0,BF,R3,
	STH	R0,BCT,R3,
	LR	R2,R3
	JAL	R8,RFCBUF		:RETURN THE EARLY DATA BUFFER

:	SEND NEEDLE ACK TO SUPERVISOR
CRQSAK	HS	0
	LIS	R2,1			:BUMP NUMBER OF CHANNELS
	AHM	R2,ANCHN,KD		:ON A TYMNET-I LINK
CRQAK1	LHL	R2,TVRBUF		:'TO SUP' BUFFER INDEX
	JE	CRQAK2			:NO CIRCUIT TO SUPERVISOR
	JAL	R10,SUPMHD		:BUILD HEADER FOR SUP MESSAGE
	GL	SUPMHD
	LB	R1,CQDCHN+1,,		:GET RELATIVE CHANNEL FOR THIS LINK
	OHI	R1,1500			:TYPE 15, FOLLOWED BY 1 BYTE CHANNEL
					:NUMBER AND FOUR BYTES INVOICE NUMBER
	JAL	R9,WHWI
	LH	R1,CQINV		:GET FIRST 2 BYTES OF INVOICE
	JAL	R9,WHWI			: AND ECHO BACK TO SUP
	LH	R1,CQINV+2,,
	JAL	R9,WHWI			:SAME FOR LAST 2 BYTES OF INVOICE
CRQAK2	LHL	R2,CQNBUF		:RESTORE NEW CIRCUIT BUFFER INDEX
	JAL	R8,NEDTIM		:COMPUTE NEEDLE TIME, SET CIRCUIT TIME
	J	CRQ72			:BUILD LAST HALF OF CIRCUIT

CRQCHU	HS	0			:CHANNEL IN USE - ZAP NEEDLE
	IF	ACCT		:###EV
	CLHI	HN,HST0			:Is this for an internal host?
	JN	CRQCH1			:If not dont do accounting
	L	R1,CQINV		:Supply inv # to accounting routine
	LI	R0,AALR07		:Provide zap reason
	JAL	R8,AANCZP		:and send to Sup
CRQCH1	HS	0
	EI	:ACCT		
	JAL	R10,SWRCHU		:FORMAT CHANNEL IN USE NODE REPORT,
					:CIRCUIT LIFETIME NODE REPORT, CRYPTO
	J	CRQZPN


CRQNNE	HS	0			:NO SUCH NEIGHBOR - ZAP CIRCUIT
:	SEND NODE REPORT FOR 'NO NEIGHBOR'
	LHI	R0,NR.NNE
	STH	R0,SUPMBF		:REPORT TYPE
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER IN ERROR
	LH	R0,CQNFLG,,
	STH	R0,SUPMBF+4		:NEEDLE FLAGS
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP LOG
	JFS	CRQZPN			:ZAP CIRCUIT

CRQZPS	LHI	R1,ZAPPS		:SOFT ZAPPER
	JFS	CRQZP2

CRQZPN	HS	0			:CIRCUIT BUILDING ERROR - ZAP IT
	LIS	R1,1
	AHM	R1,NC.CRZ		:COUNT CRQ CIRCUIT BUILDING ERRORS
	LHI	R1,ZAPPH		:HARD ZAPPER

CRQZP2	LHL	R2,CQNBUF
	XHI	R2,4			:ZAP NEEDLE CIRCUIT (NOTE ZAPPER...
	JAL	R9,ZAPX			:...TRAVELS TOWARDS ORIGIN)
	GL	ZAPX
	J	CRQ20

:	ZAPPER, GOBBLER OR OTHER 03-XX PAIR DETECTED IN CRQ BUFFER
:	INSTEAD OF A NEEDLE POINT

CRQZOG	HS	0
	LHI	R0,300
	OR	R0,R1			:FORM THE OFFENDING CHARACTER PAIR
	JAL	R8,CHNLNK,,		:GET THE NEIGHBOR # FROM THE CHANNEL
	GL	CHNLNK
	J	CRQZ02			:straight return, nghbr isn't there#wjl
	LHI	R3,MACHNM		:+4 return, internal termination###wjl
CRQZ02	STH	R3,CRYSBF+2		:+8 return - STORE IT AWAY
	JAL	R8,CRYPTO,,		:REPORT NEEDLE GOBBLED TO XRAY
	HC	CRYE08
	THI	R1,-8			:IS IT A ZAPPER?
	JN	CRQZPN			:GOBBLER OR ??, ZAP TOWARDS CIRC SOURCE
	JAL	R9,ZAPV			:ZAP SECOND HALF OF CIRCUIT...
	LIS	R1,1
	AHM	R1,NC.CRZ		:AND COUNT CRQ ERROR
	J	CRQ20

:	GET HERE FOR A VARIETY OF CIRCUIT BUILDING ERRORS. MAKE
:	CRYPTOGRAM AND ZAP CIRCUIT.

CRQER1	HS	0			:NEEDLE POINT GARBAGE
	LR	R0,R1			:SAVE FIRST BYTE OF GARBAGED NEEDLE
	EXBR	R0,R0
	JAL	R8,PCI			:GET NEXT BYTE AND
	OR	R0,R1			:COMBINE WITH FIRST
	STH	R0,CQNLK		:SAVE REG 0
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE1A			:NEEDLE POINT GARBAGE
	LHL	R0,CQNLK		:RESTORE REG 0
	CLHI	R0,01FD			:IS IT BLACK BALL ?
	JE	CRQZPN			:YES, ZAP CIRCUIT
	CRASH.(.CRQC0)
CRQER2	HS	0			:OUT OF CHANNELS TO T-1.5 OR T-II LINK
	LB	R0,KTYP,KD
	JE	CRQE22			:NO - TYMNET-1		###EV	###wjl
	JAL	R8,BUBBLE		:ALLOCATE ANOTHER 1/2 PAGE TO LINK
	J	CRQE22			:CAN'T DO IT - OUT OF 1/2 PAGES	###wjl
	LHL	R2,CQNBUF		:RESTORE BUFFER NUMBER
	J	CRQ64			:SUCCEEDED - CONTINUE CIRCUIT BUILD
CRQE22	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER		###wjl
	STH	R0,CRYSBF+2,,		:SAVE FOR CRYPTO
	LIS	R0,0			:NO DATA
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE19			:OUT OF CHANNELS
	J	CRQZPN			:ZAP CIRCUIT

CRQER3	HS	0			:OUT OF KERNEL PORTS
	LIS	R0,0
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE1B			:NO KERNEL PORTS
	IF	INTACC			:###EV
	L	R1,CQINV		:Supply inv # to accounting
	LI	R0,AALR07		:and zap reason for addendum
	JAL	R8,AANCZP		:and send to Sup
	EI	:INTACC

:	SET UP TO DETACH CIRCUIT. DETACH TYPE 03 INFORMS USER OF NO
:	KERNEL PORTS.
	LIS	R1,3
	JAL	R8,WCI,,		:NEEDLE POINT TRIGGERS 'DETCIR' TO
	LHI	R1,NEEDP&0FF		:SEND TEXT, START TIMER
	JAL	R8,WCI,,
	LR	R7,R2			:(CRQE4B EXPECTS BUFFER INDEX IN R7)
	LIS	R1,3			:DETACH TYPE
	J	CRQER7			:GO DETACH CIRCUIT

:	OUT OF DISPATCHER PORTS -- SEND NODE REPORT, CLOSE ACCOUNTING,
:	AND DETACH CIRCUIT...
CRQER4	HS	0
	LR	R7,R2			:SAVE BUFFER #
	LI	R10,NR.ODP*10000+NDP
	ST	R10,SUPMBF		:NODE ERR # AND # OF DISPI PORTS
	LH	R10,CQHOST,,		:GET HOST # (FROM NEEDLE)
	OHI	R10,8000		:SET MSB ON HOST #
	STH	R10,SUPMBF+4
	JAL	R10,SUP12		:SEND MESSAGE TO SUP
	L	R1,CQINV		:GET INVOICE NUMBER
	OI	R1,070000000		:MAKE IT A TYPE '07' RECORD
	NI	R1,07FFFFFFF
	JAL	R10,SUP14A		:SEND NODE CODE GEN'D 07-TYPE
	GL	SUP14A			: ACCOUNTING MSG

	LIS	R1,0
	STH	R1,DETTSV		:SAVE DETACH MESSAGE TYPE
	LI	R1,0E000000F		:ACCOUNTING MSG
CRQE4B	JAL	R10,SUP14A		:SEND ACCOUNTING ADDENDUM, VALUE=0F
:	CLOSE ACCOUNTING FOR THIS SESSION. SEND TYPE B MSG, CHARACTER
:	COUNT ZERO.
	LI	R1,0B0000000		:FINAL CHAR COUNT (0)
	JAL	R10,SUP14A		:NODE CODE GENERATED ACCOUNTING MSG

	LR	R2,R7			:RESTORE BUFF #

:	DETACH CIRCUIT. FIND AVAILABLE CHANNEL TO DISPATCH PROCESS IN CIOTAB 
:	(STARTING WITH DETZFL). CONNECT NETWORK HALF-CIRCUIT TO DETACH PROCESS
:	FOR SENDING APPROPRIATE TEXT TO USER, BOUNCING YELLOW BALL, AND TIMING
:	OUT CIRCUIT IF NO ORANGE BALL RETURNED. TEXT TO USER IS DETERMINED BY
:	VALUE STORED IN DETMTY BYTE ARRAY.

	L	R4,DETACP,,		:GET DETACH PROCESS ACTIVE PORT ARRAY
	JFFO	R4,CRQE4A		:ANY PORTS AVAILABLE?
	J	CRQZPN			:NO, JUST ZAP NEW CIRCUIT
CRQE4A	HS	0			:FOUND ROOM TO DETACH THIS ONE
	LH	R0,DETTSV		:GET DETACH MESSAGE TYPE
	STB	R0,DETMTY,CHN		:AND SAVE IT
	AHI	CHN,DETZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER
	J	CRQ70			:CONNECT IT UP

CRQER5	HS	0			:OUT OF COMMAND PORTS
	L	R0,CQINV		:INVOICE NUMBER
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE17			:NO COMMAND PORTS
	J	CRQZPN			:ZAP CIRCUIT

CRQER6	HS	0			:HOST OUT OF PORTS
	LR	R7,R2			:SAVE BUFFER #
	L	R0,CQINV		:INVOICE NUMBER
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE2F			:ISIS HOST OUT OF PORTS

:	SEND ACCOUNTING RECORDS TO CLOSE ACCTING ON THIS CIRCUIT

	L	R1,CQINV		:GET INVOICE NUMBER
	OI	R1,070000000		:MAKE IT A TYPE '7' ACCT REC
	NI	R1,07FFFFFFF
	JAL	R10,SUP14A		:SEND 07/INVOICE #

	LIS	R1,1
CRQER7	STH	R1,DETTSV		:SAVE DETACH MESSAGE TYPE
	LI	R1,0E0000007		:0E=CODE,0=MSG,00=SUB-MSG,0007=VALUE,
:	ACCOUTING ADDENDUM TO INDICATE HOST OUT OF PORTS
	J	CRQE4B			:SEND AND FINISH OFF

	IF	REBILD

:	HERE TO PROCESS THE ARRIVAL AT THE TERMINUS OF A REBUILD
:	NEEDLE.

CRQREB	JAL	R9,PHWI			:GET SEQN OF CHAR WE SHOULD SEND
	STH	R1,CQXSEQ		:AND SAVE IT
	JAL	R9,PHWI			:				###GT
	STH	R1,CQXSEQ+2
	JAL	R9,PHWI			:GET SEQN OF CHAR WE'LL GET FIRST
	STH	R1,CQVSEQ		:SAVE THAT, TOO
	JAL	R9,PHWI			:				###GT
	STH	R1,CQVSEQ+2
	JAL	R9,TRUNC		:DISCARD NEEDLE DATA UP TO CURRENT 'R3'
	JAL	R9,FNDCRQ		:LOCATE CIRCUIT BASED ON INVOICE NUMBER
	GL	FNDCRQ
	J	CRQRE1			:FAILED, MAKE REPORT, ZAP REBUILD CIRC

:	FNDCRQ SUCCESSFUL. R6 (XBF) CONTAINS THE ORIGINAL OUTBOUND BUFFER
:	NUMBER AND R7 (HBF) CONTAINS THE CORRESPONDING HISTORY BUFFER NUMBER.
:	R2 CONTAINS THE NEEDLE BUFFER NUMBER.

CRQRE8	LHL	R5,CQNFLG,,		:RECOMPUTE SIZE OF HIST BUFF
	HSIZE(R5)			:BASED ON SPEED BITS		###CY
	STH	R0,RHBSZ,HBF,		:STORE AWAY NEW HISTORY BUFFER SIZE
	XHI	R2,4			:FLIP OVER TO OUTGOING BUFFER
	LHL	R1,BF,R2,		:GET THE NEEDLE-ENTRY CHANNEL NUMBER
	SRHLS	R5,1			:POSITION SPEED BITS FOR IOTAB  ###CY
	AHM	R5,IOTAB,R1,R1		:SET ENTRY CHAN PERMUTER TBL SPEED BITS
	LR	R2,XBF			:R2=ORIGINAL OUTBOUND BUFFER FOR CSETUP
	JAL	R8,CSETUP		:SET UP REBUILD PARAMETERS FOR CRYPTO
	JAL	R8,CRYPTO,,
	HC	CRYE6A			:MESSAGE - CHAN STATUS
	JAL	R9,CSTUP2		:2ND PORTION OF MESSAGE		###GT
	L	R0,CQVSEQ		:GET CQVSEQ
	ST	R0,CRYSBF		:AND SAVE FOR XRAY
	L	R0,CQXSEQ		:GET CQXSEQ FOR XRAY		###GT
	JAL	R8,CRYPTO,,		:CRQREB REPORT
	HC	CRYE67
CRQREA	JAL	R9,MERGE		:COPY H-BUF TO FRONT OF OUT-BUF.
	GL	MERGE			: CLEAR H-BUF
	LR	R2,XBF			:PURGE REDUNDANT DATA IN OUTBOUND BUFF
	L	R4,XSEQN,XBF,		:SEQUENCE # OF FIRST CHAR IN OUT-BUF
	L	R5,CQXSEQ		:FIRST CHAR OTHER END WANTS TO RECEIVE
	JAL	R9,PURGE		:RECONCILE THEM BY DISCARDING BYTES
	GL	PURGE			: IF NEEDED
	J	CRQRE2			:LOST DATA - DON'T REBUILD, ZAP
	L	R0,XSEQN,R6,		:UPDATE SEQN OF HISTORY BUFF	###GT
	ST	R0,HSEQN,R7,

:	NOW PROCESS THE OTHER BUFFER PAIR - THE ONE ASSIGNED TO THE
:	REBUILD NEEDLE. IT'S INBOUND BF WILL BE SET TO 'INCPFL' TO
:	INDICATE INTERCEPT MODE. HISTORY DATA FORM THE OTHER END WILL
:	ACCUMMULATE HERE UNTIL THE FIRST NEW CHARACTER ARRIVES.

	LHL	R2,CQNBUF		:INCOMING BUFF ASSIGNED TO REBILD NEEDL
	LR	R7,R2			:COMPUTE IT'S ASSOCIATED HISTORY BUFFER
	SRHLS	R7,1
	NHI	R7,-4
	AI	R7,HBUFN
	XHI	XBF,4			:FORM ORIGINAL INCOMING BUFFER NUMBER
	STH	R6,RBIBUF,R7,		:SAVE IT INDEXED ON NEEDLE HISTORY BUFF
	SRHLS	R6,3			:MAKE CRQ INDEX			###CY
	SBT	R6,REBTMI		:REFRESH CRQ TIMEOUT		###CY
	RBT	R6,REBTMO		:REFRESH CRQ TIMEOUT		###CY
	SLHLS	R6,2			:				###CY
	AI	R6,HBUFN		:MAKE HISTORY BUFFER INDEX	###CY
	STH	R6,RBHIS,R7,		:SAVE IN NEEDLE HIST BFR DESCRIPTOR##CY
	L	R0,CQINV		:GET INVOICE NO.		###CY
	ST	R0,RBKEY,R7,		:SAVE IN NEEDLE HIST BFR DESCRIPTOR##CY
	L	R1,CQVSEQ		:GET SEQN OF CHAR THAT FOLOWS NEEDLE#GT
	ST	R1,RBVSEQ,R7,		:SAVE IT INDEXED ON NEEDLE HISTORY BUFF
	AM	R1,VSEQN,R2,		:INIT SEQ# TO EXPECT HISTORY BUFF DATA
	LHI	R1,INCPFL		:SO CRQ KNOWS WE'RE INTERCEPTING
	STH	R1,BF,R2,
	LIS	R3,1
	AHM	R3,NC.CRC		:INCREMENT COUNT OF CRQ'S COMPLETED
	LHL	R7,CQNFLG		:GET NEEDLE FLAGS BACK
	XHI	R2,4
	LHL	R3,BF,R2,		:CHANNEL # OF ENTRY (LINK) CHANNEL
	XHI	R2,4
	SBT	R3,BPSVCP-LNKZFL/8,,
	SBT	R3,LNKBPV-LNKZFL/8,,	:INSURE CHANNEL SERVICE
	RBT	R3,PRIRTY-LNKZFL/8,,
	RBT	R3,CMDCTS-LNKZFL/8,,
	THI	R7,NF.PRI		:PRIORITY CIRCUIT?
	JEFS	CRQRE0			:NO
	SBT	R3,PRIRTY-LNKZFL/8,,	:YES - INDICATE SUCH
CRQRE0	THI	R7,NF.CMD		:COMMAND CIRCUIT?
	JE	CRQ10			:NO
	SBT	R3,CMDCTS-LNKZFL/8,,	:YES
	J	CRQ10			:WAIT FOR INTERCEPT LOGIC TO HANDLE

CRQRE1	LR	R0,R0			:FNDCRQ FAILURE - INVOICE# OR STUB?
	JE	CRQRE9			:R0=0, FNDCRQ COULDN'T MATCH INVOICE #

:	GOT A REBUILD NEEDLE FOR AN APPARENTLY GOOD CIRCUIT. PRESUME THAT
:	A FAT ZAPPER IS ON IT'S WAY AND WILL EVENTUALLY ARRIVE. CLEAR OUT
:	THE ORIGINAL CIRCUIT AND MERGE BACK INTO REBUILD LOGIC. NOTE THAT
:	WE MAY GET SOME 'DATA ON UNASSIGNED CHANNEL' ON THE OLD CIRCUIT

	SIS	R6,4			:GET THE ORIGINAL INCOMING BUFER
	LHL	R0,BF,R6,		:GET THE TERMINATING CHANNEL NUMBER
	JAL	R8,CRYPTO,,		:TELL XRAY
	HC	CRYE6C			:MESSAGE = EARLY REBUILD NEEDLE
	LR	R2,R6			:COPY ORIGINAL INCOMING BUFFER	###CY
	LHI	R1,ZAPPS		:SIMULATE ARRIVAL OF A FAT ZAPPER##CY
	JAL	R10,TRCIRC		:AND USE COMMON TEARDOWN LOGIC	###CY
	JAL	R9,FNDCRQ		:CHECK TO SEE IF CRQ IS STILL THERE##CY
	J	CRQRE9			:NOT REBUILDABLE ACCORDING TO TRCIRC#CY
	J	CRQRE8			:HANDLE STUB IN NORMAL FASHION  ###CY

CRQRE9	L	R0,CQINV		:UNKNOWN REBUILD (INVOICE #)
	JAL	R8,CRYPTO,,
	HC	CRYE13			:MESSAGE - REBUILD REJECT
	J	CRQZPN			:ZAP BACKWARDS ALONG NEEDLE PATH

CRQRE2	XHI	R6,4			:LOST DATA - INBOUND BUFF #
CRQR22	LHL	R0,BF,R6,		:TERMINATION #
	JAL	R8,CRYPTO,,
	HC	CRYE14			:MESSAGE - REBUILD DATA LOST
	J	CRQZPN			:ZAP THE CIRCUIT - NOT SALVAGABLE
CRQRE3	LR	R6,R7			:LOST DATA
	JBS	CRQR22
CRQRE4	JAL	R8,CRYPTO,,		:LOST CRQ WHILE IN INTERCEPT STATE###CY
	HC	CRYE6D
	J	CRQZPN			:ZAP BACK TOWARDS ORIGIN	###CY

:	INTERCEPT -- WAITING FOR HISTORY DATA TO ARRIVE FROM SOURCE TO
:	COMPLETE CIRCUIT. WHEN EXPECTED SEQN ARRIVES, TOSS LEADING DATA
:	AND FUSE NEW CRQ WITH EXISTING CIRCUIT STUB...

CRQINT	LR	R9,R2			:INTERCEPT - GET THE REQUIRED DATA
	SRHLS	R9,1
	NHI	R9,-4
	AI	R9,HBUFN
	L	R4,RBVSEQ,R9,		:GET VSEQN OF FIRST CHARACTER IN NB##GT
	LHL	R7,RBIBUF,R9,		:GET ORIGINAL INBOUND BUFFER NUMBER
	LHL	R1,RBHIS,R9,		:GET ORIG CRQ STUB HISTORY BFR	###CY
	L	R0,RBKEY,R9,		:ALSO GET INVOICE NO.		###CY
	CL	R0,RINVC,R1,		:CONSISTENCY CHECK ORIGINAL CRQ STUB#CY
	JN	CRQRE4			:ABANDON INTERCEPT, TIMED OUT?	###CY
	L	R1,VSEQN,R2,		:GET CURRENT RECEIVE SEQUENCE NUMBER
	S	R1,VSEQN,R7,		:COMPARE TO VSEQN OF THE ORIGINAL CIRC
	JGEFS	CRQIN1			:INCOMING HIST DATA CAUGHT UP, PROCESS
	JAL	R8,CBCLR		:NOT CAUGHT UP YET - DISCARD OLD DATA
	L	R1,SEQN,R2,		:THIS'LL NOW BE #1 IN BUFF	###GT
	ST	R1,RBVSEQ,R9,
	J	CRQ10			:DONE PROCESSING REBUILD STUB FOR NOW

CRQIN1	L	R5,VSEQN,R7,		:HIST DATA CAUGHT UP - RECONCILE
	JAL	R9,PURGE		:ORIGINAL IN-BUFFER AND CURRENT IN-BUFF
	J	CRQRE3			:DATA LOST - REJECT REBUILD ATTEMPT
	JAL	R8,CBCCT		:UPDATE ORIGINAL IN-BUFFER'S SEQUENCE #
	AM	R1,VSEQN,R7,		:BY EXCESS BYTES LEFT OVER AFTER PURGE
	LR	R6,R2			:COPY CURRENT IN-BUFF>ORIGINAL IN-BUFF
	JAL	R9,APPEND		:THIS ALSO CLEARS THE CURRENT IN-BUFFER
	GL	APPEND
	LR	R2,R6	
	XHI	R6,4			:GET THE NEW NETWORK CHANNEL NUMBER
	LHL	CHN,BF,R6,		:CHN = EXIT PORT #
	LR	R0,R2			:COPY NEEDLE BUFFER NO.		###CY
	SRHLS	R0,3			:MAKE CRQ INDEX			###CY
	TBT	R0,SQFIXV,,		:HAVE WE SEEN A SEQ-FIX OR ACK?	###CY
	JEFS	CRQINA			:SKIP IF NOT			###CY
	LR	R0,R7			:COPY CRQ STUB BUFFER NO.	###CY
	SRHLS	R0,3			:MAKE CRQ INDEX			###CY
	SBT	R0,SQFIXV,,		:SET FOR CRQ STUB		###CY
CRQINA	JAL	R8,RFCBUF		:RETURN NEEDLE BUFF,NO LONGER NEEDED#CY
	LR	R2,R7			:CONNECT THE ORIGINAL IN-BUFFER TO THE
	JAL	R9,CRQHCR		:NEW NETWORK CHANNEL
	SRHLS	R2,3			:CLEAR TIMEOUTS
	RBT	R2,REBTMO
	RBT	R2,REBTMI
	SBT	R2,CRQBSY		:MARK CREATION OF A REBUILDABLE CIRCUIT
	SBT	R2,CRQEND		:MARK CREATION OF A CIRCUIT TERMINATION
	TBT	R2,SQFIXV,,		:DO WE HAVE FIX OR ACK ALREADY?	###CY
	JNFS	CRQINB			:SKIP IF SO			###CY
	RBT	R2,SQFTMO		:INIT REBUILD TIMEOUT
	SBT	R2,SQFTMI		:SET REBUILD TIMER COUNT
CRQINB	LR	R2,R7			:GET INBOUND BUFFER		###CY
	XHI	R2,4			:SWITCH TO OUTPUT BUFFER NUMBER	###GT
	JAL	R9,SNDFX0		:SEND A SQFIX WITH SEQN=0	###GT
	LHL	R6,BF,R7,
	LIS	R8,3
	NH	R8,IOTAB,R6,R6
	AHM	R8,IOTAB,CHN,CHN
	XHI	R7,4			:OUTPUT BUFFER #
	LHL	R0,BCT,R7,		:SET ATTN FLAG IF CHARS IN OB
	JEFS	CRQIN2
	SBT	CHN,NFLAGS,,
CRQIN2	CLHI	R6,LNKZFL		:IS DESTINATION CHANNEL A LINK CHAN?#CY
	JL	CRQIN3			:NO, NOT A PASSTHROUGH		###CY
	CLHI	R6,LNKLFL		:IS IT GREATER THAN LAST LINK CHAN?##CY
	JGE	CRQIN3			:YES, NOT A PASSTHROUGH		###CY
	CLHI	CHN,LNKZFL		:IS SOURCE CHANNEL A LINK CHANNEL?###CY
	JL	CRQIN3			:NO, NOT A PASSTHROUGH		###CY
	CLHI	CHN,LNKLFL		:IS IT GREATER THAN LAST LINK CHAN?##CY
	JGEFS	CRQIN3			:YES, NOT A PASSTHROUGH		###CY
	LHL	R0,PASTHR		:increment passthrough count	###wjl
	AIS	R0,1			:				###wjl
	STH	R0,PASTHR		:				###wjl
	CLHI	R0,NPASTH		:out of passthroughs?		###wjl
	JLFS	CRQIN3			:no				###wjl
	LHL	R0,PTHRPD		:what was the last report?	###wjl
	JEFS	CRQIN3			:zero=out of passthrus reported ###wjl
	JAL	R10,SUP0B		:make Resources Report to Sup	###wjl
CRQIN3	LR	R2,R7			:MOVE OUTPUT BUFFER TO R2 FOR CSETUP#CY
	JAL	R8,CSETUP		:SET UP REBUILD DATA FOR CRYPTO
	JAL	R8,CRYPTO,,
	HC	CRYE12
	JAL	R9,CSTUP2		:2ND PART OF CRYPTO MESSAGE	###GT
	J	CRQ20

	EI	:REBILD

	IF	T2GATE
::*********************************************************************
::
::	ENTRY POINT:	GCRTRM:	Gateway CiRcuit TeRMination
::	FUNCTION:	Recieves a Needle inbound from HNET, via CRQ.
::			Gets info to send a Type 07 to ISIS, marks 
::			buffer and sets timer.
::	INPUT:		Expects buffer number in R2.
::	CALLS:		JAL	R8,DIZSMS
::			JAL	R9,FNDCHN
::	RETURNS:	Jumps directly to further processing at CRQ20.
::
::*********************************************************************

GCRTRM	HS	0		:Here for Gateway Log-in
	CLHI	HN,HHOST	:Sanity check - destination always HHOST
	JE	GCRL00		:OK - proceed
	J	CRQHSZ		:Some problem - error, zap circuit
GCRL00	LHI	R1,NDP-1
	LHI	CHN,DISZFL+1
	JAL	R9,FNDCHN	:Just see if ports are available at all
	J	CRQER4		:If not - error, zap circuit
GCRL07	STH	R2,GLOKEY,,	:Local Key becomes our buffer number
	LHL	R1,CQNFLG,,	:Get flags from Needle
	THI	R1,NF.SMC	:Is this a smart circuit?
	JE	GCRL08		:No, don't set IIX bit
	LHI	R1,0C000	:IIX and ELS
	J	GCRL09
GCRL08	LHI	R1,04000	:Always ELS, but not IIX
GCRL09	STH	R1,GIXELF,,	:Store into Typ07 message
	LB	R1,CQTID,,	:Get TID (CCT)
	NHI	R1,1F		:MASK OUT TO GET TID
	LBR	R1,R1		:Is it 00
	JN	GCRL10		:NO
	LHI	R1,GAXTID	:Yes, exchange for Gateway Aux TID
	JFS	GCRL11
GCRL10	LB	R1,CQTID
GCRL11	STB	R1,GHINID	:and store in message
	LA	R1,GDM07M,,	:Load message address
	LHI	R3,GDM07L	:and length
	JAL	R8,DIZSMS,,	:Send Typ 07 (pseudo needle request)
::Now set up BF to show Log-in state and set timer
	LHI	R0,LGST.N	:(used only as a check)
	STH	R0,BF,R2,,
	SRLS	R2,1
	L	R9,SLOWC,,
	AHI	R9,GLGTMR	:Set up 2 minute time out
	ST	R9,BUFTIM,R2,
	J	CRQ20		:Thats all folks!

	EI	:T2GATE

::*********************************************************************
::
::	SUBROUTINES:	CSETUP:/CSTUP2:
::	FUNCTION:	SET UP REBUILD DATA FOR CRYPTO
::	INPUT:		R2 = BUFFER NUMBER
::		CSETUP RETURNS R0 = CHAN, CRYSBF = HSEQN.
::		CSTUP2 COMPLETES REMAINING PART OF CRYPTO LOG - WRITES
::			VSEQN AND XSEQN. TO BE USED WITH CSETUP ONLY!
::	DESTROYED:	R0, R1
::
::*********************************************************************

	IF	REBILD
CSETUP	HS	0
	LR	R1,R2
	XHI	R1,4			:GET OTHER BUFFER NUMBER	###GT
	LHL	R0,BF,R1,		:CHANNEL			###GT
	SRLS	R1,3
	SLLS	R1,2
	L	R1,HBSEQN,R1,		:HB SEQN NUMBER			###GT
	ST	R1,CRYSBF		:SET UP FOR CRYPTO		###GT
	JR	R8

CSTUP2	HS	0
	L	R0,XSEQN,R2,		:XSEQN NUMBER			###GT
	LR	R1,R2			:				###GT
	XHI	R1,4
	L	R1,VSEQN,R1,		:VSEQN NUMBER			###GT
	ST	R1,CRYSBF
	JAL	R8,CRYPTO,,		:LOG THE SEQUENCE NUMBERS	###GT
	HC	CRYE6E
	JR	R9

	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	SWRCHU:
::	FUNCTION:	FORMAT CHANNEL IN USE NODE REPORT TO SUPERVISOR.
::	CALLING SEQ:	JAL	R10,SWRCHU
::	INPUT:		R5 = CHN = ABSOLUTE CHANNEL NUMBER OF CHANNEL IN USE
::		IF CHANNEL IS TO NEIGHBOR, HW3 CONTAINS RELATIVE CHANNEL
::		NUMBER AND HW2 HAS NEIGHBOR NUMBER.
::		IF CHANNEL NOT TO NEIGHBOR, HW3 CONTAINS ABSOLUTE CHANNEL #,
::		AND HW2 IS SET TO -1.
::	DESTROYED:	R0, R1, R2, R3, R4, R8, R9
::
::*********************************************************************

SWRCHU	HS	0
	ST	R10,CHUSAV		:SAVE LINK REGISTER
	LIS	R0,NR.CHU
	STH	R0,SUPMBF		:INDICATE CHANNEL IN USE NODE REPORT
	CLHI	CHN,LNKZFL		:IS THIS A LINK CHANNEL?
	JL	SWRCU2			:NO
	SH	CHN,LKZFKN,KN,KN	:YES - COMPUTE RELATIVE CHANNEL NUMBER
	STH	CHN,SUPMBF+4
	AH	CHN,LKZFKN,KN,KN	:RESTORE CHN
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER IN HW2
	JFS	SWRCU3
SWRCU2	STH	CHN,SUPMBF+4		:ABSOLUTE CHANNEL NUMBER
	LCS	R0,1
	STH	R0,SUPMBF+2		:INDICATE NOT A NEIGHBOR CHANNEL
SWRCU3	STH	R0,CRYSBF+2		:NGHBR# FOR CRYPTO
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP

:	NOW COMPUTE CIRCUIT TIME FOR COMPANION NODE REPORT. HW2 CONTAINS
:	THE LIFETIME OF THE CIRCUIT IN SECONDS, AND HW3 REMAINS THE SAME.
	LHL	R1,IOTAB,CHN,CHN
	SRLS	R1,1			:COMPUTE BUFTIM INDEX
	NHI	R1,-4
	L	R0,SLOWC,,		:GET CURRENT TIME AND
	S	R0,BUFTIM,R1,		:SUBTRACT TIME WHEN CIRCUIT WAS BUILT
	CI	R0,0FFFF		:LONG TIME?
	JLEFS	SWRCH4			:NO
	LCS	R0,1			:YES, EXCEEDS HW RANGE. MAKE MAX VALUE
SWRCH4	STH	R0,SUPMBF+2		:STORE CIRCUIT LIFETIME
	LIS	R0,NR.CTM
	STH	R0,SUPMBF		:INDICATE CIRCUIT LIFETIME NODE REPORT
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP

:	FORMAT CRYPTOGRAM. LOW-ORDER HW CONTAINS CHN, UPPER BYTE HAS
:	CIRCUIT LIFETIME (IN SECONDS).
	LH	R0,SUPMBF+2		:GET CIRCUIT LIFETIME BACK
SWRCH6	SLL	R0,10			:ALIGN TO UPPER BYTE AND
	OR	R0,CHN			:COMBINE WITH CHANNEL
	JAL	R8,CRYPTO,,		:SEND CRYPTOGRAM FOR
	HC	CRYE10			:CHANNEL IN USE
	L	R10,CHUSAV		:RESTORE R10
	JR	R10

::*********************************************************************
::
::	TABLE:		CIRSPK:
::	FUNCTION:	CIRCUIT SPEED TABLE
::
::*********************************************************************

CIRSPK	HS	0		:CIRCUIT SPEEDS
	HC	CIRSP0
	HC	CIRSP1
	HC	CIRSP2
	IF	1-\SUPGCS	:ALLOW FOR MODIFICATION OF LEVEL 3 GOUGE SPEED
	HC	CIRSP3
	ELSE	:LEVEL 3 GOUGE OPTION SPECIFIED
	HC	SUPGCS
	EI	:1-\SUPGCS

	SUBTTL	CRQ (Circuit building routines)

::*********************************************************************
::
::	SUBROUTINE:	CRQFCR:
::	FUNCTION:	BUILD A FULL CIRCUIT
::	CALLING SEQ:	JAL	R9,CRQFCR
::	INPUT:		R2 = BUFF #
::			R3 = SPEED (2 BITS)
::			R4 = ORIGIN PORT #
::			R5 = CHN = DESTINATION PORT NUMBER
::
::*********************************************************************

CRQFCR	HS	0
	NHI	R3,3			:MAKE SURE SPEED IS LEGAL
	STH	R2,IOTAB,R4,R4		:MAKE PERMUTER TABLE ENTRY AND
	AHM	R3,IOTAB,R4,R4		:INCLUDE SPEED BITS
	RBT	R4,ACP,,		:INDICATE ACTIVE PORT
	LCS	R0,1
	SR	R0,R4			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		:MARK THAT ACTIVE
	STH	CHN,BF,R2,
	XHI	R2,4
	STH	R2,IOTAB,CHN,CHN	:COMPLEMENTARY PERMUTER TABLE ENTRY
	AHM	R3,IOTAB,CHN,CHN	:WITH SPEED BITS
	RBT	CHN,ACP,,		:FULL CIRCUIT MARKED AS ACTIVE
	LCS	R0,1
	SR	R0,CHN			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		:FLAG AS ACTIVE PORT
	STH	R4,BF,R2,
	XHI	R2,4
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	CRQHCR:
::	FUNCTION:	CREATES ONE HALF OF A CIRCUIT BY MAKING ENTRY
::		IN PERMUTER TABLE AND SETTING THE ATTENTION FLAG POINTER
::		OF THE CORRESPONDING BUFFER.
::	CALLING SEQ:	JAL	R9,CRQHCR
::	INPUT:		R2 = BUFFER #
::			R5 = CHN = ABSOLUTE CHANNEL #
::
::*********************************************************************

CRQHCR	HS	0
	XHI	R2,4			:THE CHAN # IS THE ATTENTION FLAG
	STH	CHN,BF,R2,
	XHI	R2,4
	STH	R2,IOTAB,CHN,CHN	:THE BUFF # IS THE PERMUTER TABLE ENTRY
	RBT	CHN,ACP,,		:CHANNEL NOW ACTIVE
	LCS	R0,1
	SR	R0,CHN			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		:INDICATE ACTIVE PORT

	IF	CBZDBG			:DEBUGGER		###LSH
	ST	R4,REGST,,
	JAL	R4,CRHDB1,,
	GL	CRHDB1
	L	R4,REGST,,
	EI	:CBZDBG

	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	CRQALT:
::	FUNCTION:	SIGNALS CRQ OF NEEDLE BY PUTTING NEEDLE BUFF #
::			IN THE CRQ BUFFER (BUFF 0).
::	CALLING SEQ:	JAL	R9,CRQALT
::	INPUT:		R2 = NEEDLE BUFFER #
::	DESTROYED:	R1, R8
::
::*********************************************************************

CRQALT	HS	0
	ST	R9,CRQASV		:SAVE LINK REG
	CLHI	R2,CIRZBF		:RANGE CHECK BUFFER NUMBER
	JL	CRQAL1			:TOO LOW
	CLI	R2,HBUFN-8
	JG	CRQAL1			:TOO HIGH
	LHI	R1,CRQZFL		:SET CRQ ATTN FLAG
	STH	R1,BF,R2,
	LR	R1,R2			:ALERT CRQ FIRST
	LIS	R2,CRQBUF
	JAL	R9,WHWI0		:WHWI0 ALLOWS USE OF BUFFER # 0
	LIS	R2,1			:INCREMENT CONSISTENCY COUNT
	AHM	R2,NC.CRQ		: OF CIRCUITS ATTEMPTED
	LR	R2,R1			:RESTORE BUFF #
	L	R9,CRQASV
	JR	R9			:RETURN

CRQAL1	HS	0
	CRASH.(.CRQC2)

::*********************************************************************
::
::	SUBROUTINE:	SUPCRQ:
::	FUNCTION:	BUILDS THE INITIAL CIRCUIT FROM THE SUPERVISOR
::			TO THE LEPRECHAUN OF ITS OWN BASE
::
::*********************************************************************

	IF	SUPER
SUPCRQ	HS	0
	ST	R9,WCDSAV		:SAVE RETURN
	JAL	R8,GFCBUF		:GET A FREE BUFFER PAIR
	J	OP8463			:immed. return - out of buffers!###wjl
	LHI	CHN,SUPER+2		:+4, ok - GET REL CHN FOR SUP INTERFACE
	IF	SNRING
	SBT	CHN,SUPBPV,,		:ENABLE FLOW TOWARDS SUPERVISOR
	EI	:SNRING
	AHI	CHN,SUPZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER
	JAL	R9,CRQHCR
	XHI	R2,4			:COMPLEMENTARY BUFFER
	LHI	CHN,LEPZFL
	JAL	R9,CRQHCR
	L	R9,WCDSAV		:RESTORE R9
	JR	R9
	EI	:SUPER

::*********************************************************************
::
::	SUBROUTINE:	TRCRFT:/TRCIRC:
::	FUNCTION:	TEARS DOWN CIRCUIT AND REQUESTS REBUILD IF APROPPRIATE
::	LINK:		R10
::	INPUT:		R1 = ZAPPER (SOFT OR HARD)
::			R2 = BUFFER #
::
::*********************************************************************

:	TRCRFT - ENTRY POINT IF CALLED AS A RESULT OF FAT ZAPPER.
:	'PRD' POINTS TO NODE PAIR (FAT) WHICH FOLLOWS FAT ZAPPER.

TRCRFT	HS	0
	LB	R0,0,PRD
	STB	R0,RFAT			:MUST DO A BYTE AT A TIME SINCE NOT
	LB	R0,1,PRD		:ASSURED OF HALFWORD ALIGNMENT
	STB	R0,RFAT+1
	LB	R0,2,PRD
	STB	R0,RFAT+2
	LB	R0,3,PRD
	STB	R0,RFAT+3
	JFS	TRCR02

:	TRCIRC - ENTRY POINT IF NODE PAIR OF LINK OUTAGE NOT KNOWN.
:	REBUILD REQUEST WILL SEND -1'S IN NODE NUMBER FIELDS.

TRCIRC	HS	0
	LCS	R0,1
	ST	R0,RFAT			:NO FAT
TRCR02	ST	R10,TRCSV1		:SAVE LINK REG
	ST	R2,TRCSV2		:BUFFER INDEX OF CIRCUIT BEING ZAPPED
	CLHI	R1,ZAPPF		:IS IT A FAT ZAPPER?
	JEFS	TRCR10			:YES, REBUILDABLE
	CLHI	R1,ZAPPS		:SOFT ZAPPER REBUILDABLE TOO
	JN	TRCZP1			:NONE OF THE ABOVE
TRCR10	LHL	R0,REBREN,,		:REBUILD REQUESTS ENABLED?
	JE	TRCZPH			:NO, JUST HARD ZAP CIRCUIT
	LR	R10,R2			:COMPUTE CIRCUIT #
	SRHLS	R10,3
	LR	R9,R10			:PRESERVE CRQBSY INDEX
	TBT	R9,CRQEND		:ARE WE A TERMINATION?		###GT
	JE	TRCZP1			:NO, PASS SOFT ZAPPER ON

	IF	REBILD			:REQUEST REBILD ONLY IF ENABLED	###gt
	TS	TRCSV2			:INDICATE CALLER SHOULD NOT

:	DEPOSIT NODE PAIR INFORMATION IN CIRCUIT'S BUFFER
	SLHLS	R10,2			:COMPUTE HBUFN			###GT
	AI	R10,HBUFN		:				###GT
	RBT	R9,SQFTMI		:CANCEL ACTIVE REBUILD TIMER	###CY
	RBT	R9,SQFTMO		:				###CY
	RBT	R9,SQFIXV		:NO SEQ FIX OR ACK SEEN ON THIS CRQ##CY
	TBT	R9,CRQBSY		:REBUILD ENABLED FOR THIS CIRCUIT?###CY
	JE	TRCZPH			:NO, MAKE NO REBUILD REQUEST	###CY
	LHL	R0,RNFLAG,R10,		:ARE WE THE CIRCUIT ORIGIN?
	JE	TRCZHC			:NO, CLEAR PERMUTER TABLE ENTRY ONLY
	LHL	R2,TVRBUF		:MAKE REBUILD REQUEST TO SUP
	JE	TRCZPH			:NO SUP, MUST HARD ZAP CIRCUIT
	LHI	R1,8000+MACHNM
	JAL	R9,WHWI,,
	LHI	R1,0D80
	JAL	R9,WHWI,,
	LHL	R1,RNFLAG,R10,		:NEEDLE FLAGS
	JAL	R9,WHWI,,
	LHI	R1,8080			:***TEMP PORT #
	JAL	R9,WHWI,,
	LHL	R1,RBASE,R10,		:BASE & HOST
	JAL	R9,WHWI,,
	LHL	R1,RHOSTN,R10,
	JAL	R9,WHWI,,
	LHL	R1,RINVC,R10,		:INVOICE
	JAL	R9,WHWI,,
	LHL	R1,RINVC+2,R10,
	JAL	R9,WHWI,,
	LHL	R1,RFAT
	JAL	R9,WHWI,,		:NODE PAIR OF LINK WHICH WENT OUT
	LHL	R1,RFAT+2
	JAL	R9,WHWI,,
	LHL	R2,TRCSV2+2		:GET ZAPPER-ENTRY BUFFER INDEX
	XHI	R2,4			:FLIP TO OPPOSITE BUFFER FOR CSETUP
	JAL	R8,CSETUP		:SET UP FOR REBUILD PARAMETERS
	JAL	R8,CRYPTO,,		:REBUILD REQUEST
	HC	CRYE11
	JAL	R9,CSTUP2		:REST OF LOG			###GT

TRCZHC	LHL	R2,TRCSV2+2		:GET BACK THE ZAPPER-ENTRY BUFFER
	LHL	R8,BF,R2,		:GET THE ZAPPER-EXIT CHANNEL NUMBER
	XHI	R2,4			:GET THE OPPOSITE BUFFER NUMBER
	LHL	R3,BF,R2,		:GET THE ZAPPER-ENTRY CHANNEL NUMBER
	CLHI	R8,LNKZFL		:IS ZAPPER-EXIT CHANNEL A TERMINATION?
	JLFS	TRCZH1			:YES, THIS WASN'T A PASSTHRU	###CY
	CLHI	R8,LNKLFL		:GREATER THAN LAST LINK CHANNEL?###CY
	JGEFS	TRCZH1			:				###CY
	CLHI	R3,LNKZFL		:TEST THE OTHER CHANNEL
	JLFS	TRCZH1			:IT TERMINATES, WASN'T A PASSTHRU##CY
	CLHI	R3,LNKLFL		:GREATER THAN LAST LINK CHANNEL?###CY
	JGEFS	TRCZH1			:				###CY
	LCS	R0,1			:THIS WAS A PASSTHRU
	AHM	R0,PASTHR		:DECREMENT COUNT OF ACTIVE PASSTHROUGHS
:	NOTE CRQREB MUST INCREMENT AGAIN IF STUB REBUILT		###CY

TRCZH1	LIS	R0,0
	STH	R0,IOTAB,R3,R3		:CLEAR PERMUTER TABLE ENTRY
	SBT	R3,ACP,,		:PORT IS  NOW IDLE
	RBT	R3,CHS,,		:SUSPEND CHANNEL		###CY
	SBT	R3,CHS1,,		:		 		###CY
	LCS	R0,1			:ALSO SET NEGATIVE ACP ARRAY	###CY
	SR	R0,R3			:				###CY
	SBT	R0,ACP,,		:				###CY
	RBT	R0,CHS,,		:###CY
	SBT	R0,CHS1,,		:###CY
	RBT	R3,NFLAGS,,		:FREEZE OUTBOUND BUFFER
	LHI	R0,STUBFL
	STH	R0,BF,R2,		:CORRESPONDING BF IS SET TO STUBFL
	XHI	R2,4
	LR	R0,R2			:SET TIMEOUT
	SRHLS	R0,3
	SBT	R0,REBTMI
	L	R10,TRCSV1		:RESTORE LINK REG
	JR	R10			:RETURN

	EI	:REBILD	###GT

TRCZPH	LHI	R1,ZAPPH		:TO HARD ZAP WHEN NEEDED
	TS	TRCSV2			:PREVENT 'FAT' FROM TRAVELING
	LHL	R2,TRCSV2+2		:TO PASS A ZAPPER ON
	J	TRCZP3			:COMMON EXIT			###GT

:	AVOID CLEARING NEEDLE POINT IN BUFFER				###CY
TRCZP1	LHL	R0,BCT,R2,		:ANYTHING IN BUFFER?		###GT
	JE	TRCZP3			:SKIP IF EMPTY			###GT
	LR	R0,R1			:COPY ZAPPER TYPE		###GT
	JAL	R8,PCIS,,		:PEEK AT 1ST CHAR		###GT
	SIS	R1,3			:IS IT A ZAPPER PAIR?		###GT
	JNFS	TRCZP2			:SKIP IF NOT			###GT
	JAL	R8,PCI,,		:LOOK AT 2ND OF PAIR		###GT
	CLHI	R1,NEEDP&0FF		:CHECK FOR NEEDLE POINT		###GT
	JNFS	TRCZP2			:SKIP IF NOT			###GT
	LR	R1,R0			:RECOVER ZAPPER TYPE		###GT
	JAL	R9,ZAPXN		:ZAP WITHOUT CLEARING BUFFER	###GT
	JFS	TRCZP4			:ALMOST DONE			###GT
TRCZP2	LR	R1,R0			:RECOVER ZAP TYPE		###GT
TRCZP3	JAL	R9,ZAPX			:ZAP 1/2 CRQ			###GT
TRCZP4	L	R10,TRCSV1		:RESTORE RETURN ADDR		###GT
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	ZAPHRD:/ZAPX:/ZAPXN:/ZAPXNG:
::	FUNCTION:	Zaps first half of a circuit.  If the other half
::		is dead, returns the buffer (R2) to the free list.
::		May or may not clear the buffer (R2), depending on type of
::		zapper (R1) or entry point.
::	ENTRY POINTS:
::		ZAPHRD - Zaps circuit (hard zapper).
::		ZAPX   - Zaps circuit (zapper in R1).
::		ZAPXN  - Zaps circuit (zapper in R1), does not CBCLR.
::		ZAPXNG - Zaps circuit (2nd byte of zapper in R1),does not CBCLR
::	LINKS:		R9
::	INPUT:		R2 = buffer index.
::			R1 = zapper (not expected by ZAPHRD).
::	DESTROYED:	R0, R3, R8
::
::*********************************************************************

ZAPHRD	HS	0			:Enter here to force hard zapper
	LHI	R1,ZAPPH

ZAPX	HS	0			:Enter here with zapper of choice in R1
	IF	CBZDBG			:DEBUGGER			###LSH
	ST	R4,REGST,,
	JAL	R4,ZPHDB1,,
	GL	ZPHDB1
	L	R4,REGST,,
	EI	:CBZDBG		

	CLHI	R1,ZAPPN		:IF A NON-GOBBLING TYPE...
	JE	ZAPXN			:DONT CLEAR BUFFER

	LR	R2,R2			:R2 = ORIG. BUFFER #.	###LSH
	JLR	R9			:IF BUFFER IS NOT THERE, JUST RETURN

	JAL	R8,CBCLR,,		:ELSE CLEAR THE ORIG. BUFFER FIRST
        IF      T2GATE          :gateway keeps another char count
        LHL     R8,BF,R2                :get maybe isis port number
        SHI     R8,DISZFL               :port get fixed 9/16/87         ###sdw
        JLFS    ZAPXN                   :not isis dport
        CLHI    R8,NDP                  :small enough?
        JGEFS   ZAPXN                   :too big
        TBT     R8,LOGING             :for ports in login mode
        JEFS    ZAPXN
        LIS     R3,0            :now the zapper cannot look like an already
        STB     R3,GLGCNT,R8,   :read and known about character pair.  ###sdw
        EI      :T2GATE

:	Enter here to bypass CBCLR.  Deposit zapper (R1) into buffer (R2)
:	and SPEED it along.
ZAPXN	HS	0			:R2 = ORIG. BUFFER NUMBER
	LH	R3,BF,R2,		:IS IT DEAD-END OR ZAPPED CIRCUIT?##LSH
	JLE	ZAPX0			:IF YES, DON'T SEND ZAPPER. SKIP.###LSH

	EXBR	R1,R1			:DEPOSIT ZAPPER (ALWAYS A PAIR)	###CY
	JAL	8,WCI,,
	EXBR	R1,R1

ZAPXNG	HS	0	:ENTRY POINT FOR ESYNC RTD DETECTING NON-GBBLNG ZPPER
	JAL	R8,WCI,,
	LHL	R3,BF,R2,		:PORT OF ZAPPER EXIT
	JAL	R8,SPEED		:SPEED ZAPPER ALONG
:	Get zapper destination channel # (BF of entry buffer) to R3.
:	Switch R2 to complementary buffer index, get channel # of
:	zapper origin to R8.  If both channels are link channels,
:	decrement passthrough count.
ZAPX0	HS	0			:###LSH
	XHI	R2,4			:R2 = COMP. BUFFER NUMBER
	LHL	R8,BF,R2,		:POINT OF ENTRY
	CLHI	R3,LNKZFL		:DEC PASSTHRU CNT IF APPROPRIATE
	JLFS	ZAPX2
	CLHI	R3,LNKLFL		:R3 = BF OF ORIG. BUFFER
	JGEFS	ZAPX2			:R8 = BF OF COMP. BUFFER
	CLHI	R8,LNKZFL
	JLFS	ZAPX2
	CLHI	R8,LNKLFL
	JGEFS	ZAPX2
	LCS	R0,1			:PASSTHROUGH CIRCUIT
	AHM	R0,PASTHR		:DECREMENT PASSTHROUGH COUNT

:	Skip to here if not passthrough or fall thru after decrementing
:	passthru count.
ZAPX2	HS	0
	IF	T2GATE
::Count a port and send "cleared" message if appropriate
        STH     CHN,GZAPSV,,            :save some regs to allow some work regs
        STH     R8,GZSAVE,,
        STH     R3,GASAVE,,
        LIS     R0,0
        STH     R0,GRSAVE+2,,           :mark no ISIS port known yet
	CLHI	R8,DISZFL               :r8 (channel received zap) ISIS port?
	JGEFS	GZPCX0			:nope too small
        CLHI    R3,DISZFL               :either a dispatcher port?
        JL      GZPCX6                  :check added 9/16/87            ###sdw
        J       GZPCX2
GZPCX0	CLHI	R8,DISZFL+NDP		:
        JGE     GZPCX2                  :thus r3 is the ISIS port
::Zapper came from I-Net, if not login  we must re-emit zap to clear port
	LHI	R5,-DISZFL,R8		:Get dispatcher port from known BF
        STH     R8,GRSAVE+2,,           :we have an ISIS port (channel #)
	TBT	R5,LOGING		:Skip if in log-in mode
	JN	GZPCY1
	LHI	R1,09F00
	JAL	R8,DIRMES,,		:Re-issue Zap to clear port
GZPCY1	LHL	R3,GASAVE,,             :was clobberred and needed again
GZPCX2	CLHI    R3,DISZFL               :is r3 an ISIS port?
        JL      GZPCX4                  :nope do accounting
        CLHI    R3,DISZFL+NDP           :
        JGE     GZPCX4
        LHI     R5,-DISZFL,R3           :channel to isis port
        TBT     R5,LOGING               :login mode means others does msgs
        JN      GZPCX6                  :can't account for these either
::Now send "inter-link cleared" message if appropriate
	TBT	R5,GORGPT		:and being from the host to terminal
	JE	GZPCX4			:(an I-net to H-net log-in)
	TBT	R5,GTTRNS		:No messages for transparent
	JN	GZPCX4
	LA	R1,GNGONE,,
	JAL	R8,DIMMES,,
	DROUTE(ISISN,HOMEN)		:Send it to dispatcher directly
	LA	R1,CRLF,,
	JAL	R8,DIMMES,,
	LHI	R1,09E00
	JAL	R8,DIRMES,,		:Send detatch
	SBT	CHN,DISZNK		:Prepare for zap ack
 	RBT	CHN,DISFLG		:Ensure no future service
::Now perform Log-out accounting if appropriate
GZPCX4	LHL     R1,GRSAVE+2,,           :was r8 an ISIS port?
        JEFS    GZPCX5                  :nope
        SHI     R1,DISZFL               :knock down to port
        TBT     R1,GDSTPT               :destination port?
        JEFS    GZPCX5                  :r8 was not dest ISIS port
        LR      R5,R1                   :it was so set it up
GZPCX5  TBT     R5,GDSTPT               :this and above handles iif both ISIS
	JE	GZPCX6
	LHI	R3,DISZFL,CHN		:Make absoulute channel
	CLHI	R3,MNACHN
	JL	GZPCX6
	CLHI	R3,MXACHN		:do accounting range check
	JGE	GZPCX6
	LHL	R0,AAREAS,,		:Load previously stored reason
	JE	GZPCX6			:Skip if no reason
	LHI	R3,-MNACHN,R3		:Make relative accounting port index
	ST	R2,GESAVE,,		:Better save buffer number
	ST	R9,GRSAVE,,		:(We are in reg 9 right now)
	JAL	R8,AARLO,,		:Perform accounting logout stuff
	GL	AARLO
	LIS	R0,0
	STH	R0,AAREAS,,		:Re-init accounting logout reason
	L	R2,GESAVE,,		:Get back Loretta'
	L	R9,GRSAVE,,
GZPCX6	LHL	R3,GASAVE,,		:...and proceed ....
	LHL	R8,GZSAVE,,		:and continue
	LHL	CHN,GZAPSV,,
	LIS	R0,0
	EI	:T2GATE

	EXHR	R0,R8		:###EV is this a possible bug without T2GATE??
	OR	R0,R3			:AND COMBINE
	JAL	R8,CRYPTO,, 
	HC	CRYE0C			:ENTRY ON LEFT, EXIT ON RIGHT
:	Clear the complementary buffer.  
:	If the zapper entry point is a real channel (>CRQZFL), make sure
:	its IOTAB entry is consistent (i.e., it should be the buffer index
:	we entered with).  If not, crash.
	JAL	R8,CBCLR,,		:CLEAR THE COMPLEMENTARY BUFFER
					:R3 = BF OF COMP. BUFFER
	LHL	R3,BF,R2,		:GET ENTRY PORT (AGAIN)
	CLHI	R3,CRQZFL		:IS THERE AN IOTAB ENTRY?
	JLE	ZAPX1			:NO
	LHL	R0,IOTAB,R3,R3		:MAKE SURE IT'S ALL CONSISTENT
	NHI	R0,-4
	XHI	R0,4
	CR	R2,R0
	JEFS	ZAPX1
	CRASH.(.ZAPCR)
:	Now see if the zapper is traveling toward LOGGER.
:	If not, skip to ZAPX5.
ZAPX1	HS	0
	XHI	R2,4			:R2 = ORIG. BUFFER NUMBER
	LHL	R0,BF,R2,
	CLHI	R0,LOGMIN
	JL	ZAPX5			:NOT TRAVELING TOWARD LOGGER
	CLHI	R0,LOGMAX
	JG	ZAPX5			:NOT TRAVELING TOWARD LOGGER

	IF	T2GATE
::************************************************************
::	If this is a Gateway, we must provide for the case of
::	a log-in from HNET to INET which will find the BF
::	in log-in state and no B2 message having been processed.
::	This is called an Early Zapper, and we must return the 
::	buffer in this case.  If a DIOTAB entry already exists,
::	then we can just pass the Zapper on and let GDB3 find it and
::	return the buffer at that time.
::	INPUT:	R2	=  buffer of inbound (from term)
::first be sure this comes from H-net
	XHI	R2,4
	LHL	R1,BF,R2,
	CLHI	R1,LNKZFL
	JL	GDZ001		:If not from Hnet, go around
	XHI	R2,4		:Return to f. t. buf
	STH	R3,AAR1SV	:save R3 for use later in Zapx7
	STH	R0,AAR2SV	:Save R0 for use in normal zap
	LR	R8,R2		:Load buffer to find complimentary CHN
	LHI	R1,NDP-1	:Number of channels to be considered
	XHI	R8,4		:Now use the complimentary buf # to match
MATCHN	HS	0
	LHL	R0,DIOTAB,R1,R1	:Get a table entry
	CR	R0,R8		:Is it the one we want?
	JN	MATCH8		:No
	LR	R8,R0		:Save it
	XHI	R0,4		:Should be .. let's check
	CR	R0,R2		:Better be equal
	JE	MATCHD		:Yes, found a match  (R1 = relative channel #)
	CRASH.(.FNCHC)		:Problem .. but wed'vd crashed anyway
MATCH8	SIS	R1,1		:End of range yet?
	JG	MATCHN
	J	MATCON		:Could be a problem .. if so we'll crash
MATCHD	LR	CHN,R1		:load  relative channel # discovered
	XHI	R8,4
	LHL	R1,BF,R8,	:Let's see if this is really it
	CLHI	R1,LOGMIN
	JGE	MATCH9
	CRASH.(.ZAPCR)		:Unmistakeable MESS
MATCH9	CLHI	R1,LOGMAX
	JLE	MATHOK
	CRASH.(.ZAPCR)		:Same mess
::Found a match- make sure we are HNET to INET log-on - reset bits etc.
MATHOK	TBT	CHN,GDSTPT		:(this test may not be necessary)##ev
	JE	MATCON
::Continue..expect ZAPPER PASSED IN GDB3 returns buffer 
	LHL	R3,AAR1SV
	J	ZAPX7	:The above will have been executed in lieu
			: of the code below for "normal" node code
			:log-ins, so jump around the following
			:clear tables and expect GDB3 to RFCBUF and Zap prt

::Come here for Hnet login not initiated with B2 response yet
MATCON	HS	0
	LHL	R3,AAR1SV
	LHL	R0,AAR2SV
	J	ZAPX6	:Needle not sent down yet .. return buffer and
			:expect GDB2 to catch this
::If in login mode and not from H-net, come here
GDZ001	HS	0
	XHI	R2,4
			:Fall through here to Inet - Hnet login
	EI	:T2GATE
::	Come here for normal Node Code Log-in processing
:	The needle has not been sent down yet.	The port is in login mode, 
:	and the zapper is traveling toward LOGGER, see if the TID has 
:	been sent to the sup.  If it has, let the zapper go to the sup
:	and RETURN.  The sup will respond with a zapper ack, at which time
:	we will clear the channel and free the buffer.  If TID not yet sent,
:	we can clean things up ourselves without fear of a race condition
:	in reassigning a port which the sup thinks is still in login mode.
	IF	T2GATE
	OHI	R0,LOGSUP		:Gateway only requires bit 4
	ELSE
	OHI	R0,LOGSUP+LOGNDC	:MAKE SURE ZAPPER TRAVELS
	EI	:T2GATE
	STH	R0,BF,R2,
	THI	R0,LG.TID		:HAS TID BEEN SENT TO SUP?
	JER	R9			:YES, SEND ZAPPER TO SUP.
:	ZAPPER CONFIRMATION WILL FREE CHANNEL AND BUFFER (SEE LEPZLI).

::For Gateway we must emit a Zap to free dispatcher port
::Or we will clear tables and return buffer below, in which case we are in 
::log-in mode and must send a Zap to Dispatcher to clear the port for reuse.
	IF	T2GATE
	XHI	R2,4			:Get to-terminal buffer
	LHL	R5,BF,R2,		:Get channel number
        XHI     R2,4                    :restore from terminal buffer
	SHI	R5,DISZFL		:Make into dispatcher port

:  The following test for loging is to take care of INET which logged
:  into HNET and back to INET.  While in login mode the orig INET channel
:  has BF of being in loging mode when in fact the secondary channel is
:  actually sending the B3 messages.  The secondary channel BF are to the
:  orig INET port and of login mode.  The trouble is that a zap on the orig
:  channel while the secondary is in login would notice that is built a
:  circuit (by the loging bit) and that it was in login mode (by BF) and
:  send two zaps back on the origin channel and none one the secondary chann
:  and return the buffers.  Thus, a test for the LOGING bit determines whether
:  this channel is really an INET-HNET (LOGING set) or INET-HNET-INET (loging
:  reset).       ###sdw

        TBT     R5,LOGING               :make sure login port
        JE      ZAPX7                   :###sdw
	LHI	R1,09F00
        STH     R3,GASAVE,,
	JAL	R8,DIRMES,,		:Send zapper
        LHL     R3,GASAVE,,             :save R3 and fix link snip ###sdw
	EI	:T2GATE

:	Fall thru to here for the case that port in login mode,
:	zapper is travelling toward LOGGER, and the TID is still in buffer.
:	Remove the buffer from the LOGGER list.  Set the buffer's BF to 0
:	so it will be treated like a dead end below (buffer released).
:	Return the buffer, and stop circuit right here.

ZAPX6	HS	0
	IF	SOLOCS
	XHI	R2,4			:get ANI channel from BF of .ALBUF+4
	LHL	R0,BF,R2,		:				###LSH
	XHI	R2,4			:restore R2 to .ALBUF
	SHI	R0,ANIZFL
	RBT	R0,LOGSTB,,		:Since we're removing from LOGGER list,
	IF	NMPVC
	RBT	R0,SUBSTB,,		:Also need reset SUBSTB. ###LSH
	GL	SUBSTB
	EI	:NMPVC
	EI	:SOLOCS			:there is no need to protect ASYLOU

	LIS	R0,0			:ZERO BF SO THAT BUFFER GETS RETURNED 
	STH	R0,BF,R2,		:(SEE TEST BELOW)

	J	ZAPX7			:RETURN BUFFER AND INDICATE PORT
					:AVAILABLE. ALSO CLEAR LOGGER LIST##LSH

:	Skip to here for the case that the needle has been sent down already.
:	If solo consat, see if complementary buffer's destination channel
:	is ANI channel.  If yes, means that the needle eye has not been
:	processed yet.  The port is still in login mode.  We need to reset
:	LOGSTB flag.  We do not need special treatment by ASYLOU.
ZAPX5	HS	0
	IF	SOLOCS
	XHI	R2,4			:SWITCH COMPLEMENTARY BUFFER
	LHL	R0,BF,R2,		:R0 = BF OF COMP. BUFFER
	XHI	R2,4			:RESTORE R2 WITH ORIG. BUFFER #
	SHI	R0,ANIZFL		:SEE IF IN THE RANGE OF ANI
	JL	ZAPX7			:NO
	CLHI	R0,NANIPT	
	JGE	ZAPX7			:NO
	RBT	R0,LOGSTB,,		:YES, IN LOGIN MODE, NEED RESET LOGSTB
	IF	NMPVC
	RBT	R0,SUBSTB,,		:NEED RESET SUBSTB TOO ###LSH
	EI	:NMPVC
	EI	:SOLOCS

:	Skip to here for:
:		1.  all the passthrough nodes.
:		2.  solo consat originating node, and the circuit is built
:			 already.
:		3.  ISIS originating node, as long as the needle has been sent
:			 down already.
:		4.  after cleaning up for login port with TID still in buffer
:			 (see ZAPX6).
:	Flip to the complementary buffer and set its BF to 0.
:	Set the zapper entry port's IOTAB entry to 0.  Free the port (ACP),
:	and temporaily suspend it (CHS, CHS1).
ZAPX7	HS	0			:###LSH
        IF      T2GATE
        IF      CBZDBG                  :debug this too (like ZAPV)
        ST      R4,REGST,,
        JAL     R4,GPZDB2,,
        GL      GPZDB2
        L       R4,REGST,,
        EI   :CBZDBG
        EI    :T2GATE

	XHI	R2,4			:R2 = COMP. BUFFER NUMBER
	LIS	R0,0
	STH	R0,BF,R2,		:CLEAR COMPLEMENTARY BUFFER'S BF
	STH	R0,IOTAB,R3,R3		:CLEAR THE PERM TAB ENTRY
	SBT	R3,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R3,CHS,,		:SUSPEND PORT WHILE ZAPPER CLEARS,
	SBT	R3,CHS1,,		:MAKE IT AVAILABLE IN 30-60 SECS
	LCS	R0,1
	SR	R0,R3			:COMPUTE NEGATIVE ACP INDEX
	SBT	R0,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R0,CHS,,		:BUT TEMPORARILY SUSPENDED
	SBT	R0,CHS1,,		:8-SECOND LOGIC WILL REINSTATE CHANNEL

:	Flip back to the original buffer.  If it doesn't point to a dead-end
:	circuit (BF=0) or circuit stub (BF=STUBFL) then just RETURN.
	XHI	R2,4			:R2 = ORIG. BUFFER NUMBER
	LHL	R0,BF,R2,		:IS THIS A DEAD-END CIRCUIT
	JEFS	ZAPX3			:YES, RETURN BUFFER
	CLHI	R0,STUBFL
	JNR	R9			:NOT A STUB EITHER
ZAPX3	HS	0	:Dead-end or stub, release buffer, then RETURN.
	ST	R1,YAKT1
	JAL	R8,RFCBUF		:RETURN BUFFER
	ST	R9,ZAPXS1,,		:STORE LINK REGISTER		###LSH
	ST	R6,ZAPXS2,,		:STORE R6 			###LSH 
	LR	R6,R2			:COPY BUFFER # INTO R6		###LSH
	JAL	R9,LOGCLR		:REMOVE BUFFER # FROM LOGGER LIST##LSH
	L	R9,ZAPXS1,,		:RESTORE LINK REGISTER		###LSH
	L	R6,ZAPXS2,,		:RESTORE R6 			###LSH
	L	R1,YAKT1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	ZAPV:
::	FUNCTION:	Zaps the last half of a circuit.
::	CALLING SEQ:	JAL	R9,ZAPV
::
::*********************************************************************

:	See if zapper destination is real circuit.  If so, make sure
:	IOTAB is consistent (crash if not). If not, skip to ZAPV1.
ZAPV	HS	0
	IF	CBZDBG			:DEBUGGER			###LSH
	ST	R4,REGST,,
	JAL	R4,ZPVDB1,,
	GL	ZPVDB1
	L	R4,REGST,,
	EI	:CBZDBG		

	LHL	R1,BF,R2,		:GET DESTINATION CHANNEL NUMBER
	CLHI	R1,CRQZFL		:SHOULD WE HAVE AN IOTAB ENTRY?
	JLE	ZAPV1			:NO - CIRCUIT NOT YET BUILT
	LHL	R0,IOTAB,R1,R1		:YES, DO CIRCUIT CONSISTENCY CHECK.
					:GET OPPOSITE CHANNEL'S BUFFER INDEX,
	NHI	R0,-4			:STRIP SPEED BITS,
	XHI	R0,4			:COMPUTE COMPLEMENTARY BUFFER INDEX,
	CR	R2,R0			:SHOULD EQUAL BFR INDEX WE ENTERED WITH
	JEFS	ZAPV1			:IOTAB ENTRY CONSISTENT
	CRASH.(.ZAPC0)			:Failed consistency check.
:	Here if circuit not real or if real and consistent.
:	Clear destination channel's IOTAB entry, clear port (ACP),
:	suspend it temporarily (CHS, CHS1).
ZAPV1	HS	0
	LIS	R0,0
	STH	R0,IOTAB,R1,R1		:CLEAR IOTAB ENTRY
	SBT	R1,ACP,,		:PORT NO LONGER IN USE
	RBT	R1,CHS,,		:BUT SUSPENDED TEMPORARILY
	SBT	R1,CHS1,,		:ENABLE REINSTATEMENT BY 30-SEC LOGIC
	LCS	R0,1
	SR	R0,R1			:COMPUTE NEGATIVE ACP INDEX
	SBT	R0,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R0,CHS,,		:SUSPENDED FOR BOTH NEGATIVE
	SBT	R0,CHS1,,		: AND POSITIVE

:	Make sure complementary buffer's BF is 0.  Crash if not.

	LR	R1,R2			:COMPLEMENTARY BF BETTER BE 0
	XHI	R1,4
	LHL	R8,BF,R1,
	JEFS	ZAPV2
	CRASH.(.ZAPC1)
ZAPV2	HS	0		:Everything OK, return buffer and RETURN.
	JAL	R8,RFCBUF		:AOK, RETURN BUFFER
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	GOBBLN:/GOBBLE:
::	FUNCTION:	Eat buffer contents, override backpressure,
::			put gobbler into buffer.
::	ENTRY POINTS:	GOBBLN, GOBBLE
::	LINK:		R9
::	INPUT:		R2 =  BUFFER INDEX
::	CALLS:		CBCLR, PCIS, SPEED, AND WCI
::
::*********************************************************************

:	Enter here to ignore gobbler if needle point or SQFIX in buffer.
GOBBLN	HS	0
	LIS	R8,1			: ONLY 1 CHARACTER IN THE BUFFER?##GT
	CLH	R8,BCT,R2,		:03 WAS JUST WRITTEN IN		###GT
	JEFS	GOBBLE			:YES, DON'T CHECK FOR NEEDLE IN BUFFER
	JAL	R8,PCIS,,		:PEEK AT FIRST BYTE
	SIS	R1,3			:POSSIBLE NEEDLE POINT?
	JNFS	GOBBLE			:NO
	JAL	R8,PCI,,		:YES - CHECK NEXT BYTE
	CLHI	R1,NEEDP&0FF
	JER	R9			:NEEDLE POINT - IGNORE GOBBLER
	CLHI	R1,SQFIX&0FF		:SEQUENCE FIX?			###GT
	JER	R9			:YES - IGNORE GOBBLER		###GT

:	Here to gobble.
:	Clear buffer, SPEED it along, deposit gobbler, and RETURN.
GOBBLE	HS	0
	JAL	R8,CBCLR,,		:CLEAR BUFFER
	LHL	R3,BF,R2,		:GET GOBBLER DESTINATION CHANNEL AND
	JAL	R8,SPEED		:EXPEDITE GOBBLER
	LIS	R1,3			:PUT A GOBBLER IN IT
	JAL	R8,WCI,,		:				###OAS
	LIS	R1,GOBBL&0FF
	JAL	R8,WCI,,		:				###OAS
	JR	R9			:RETURN

	SUBTTL	CRQ (Utilities)

::*********************************************************************
::
::	SUBROUTINE:	CKTCON:
::	FUNCTION:	CIRCUIT CONSISTENCY TESTS.
::	CALLING SEQ:	JAL	R10,CKTCON  CALLED FROM 4-MINUTE LOGIC (G04MIN)
::
::*********************************************************************

:	ALL CIRCUIT ERRORS ARE COUNTED (SUCH AS CHANNEL IN USE, NO NEIGHBOR,
:	ETC.), AND, IF THEIR OCCURRENCES EXCEED A THRESHOLD, ARE REPORTED
:	TO THE PROBE LOG. IN ADDITION, THE NUMBER OF CIRCUITS ATTEMPTED
:	AND COMPLETED BY CRQ ARE COUNTED. IF THE SUM OF CIRCUITS IN ERROR
:	AND CIRCUITS COMPLETED DOES NOT EQUAL THE NUMBER OF CIRCUITS 
:	ATTEMPTED, A CONSISTENCY ERROR NODE REPORT IS GENERATED.

CKTCON	HS	0
	ST	R10,LNKRGS		:SAVE LINK REG
	LHL	R2,NC.LPE		:LEP CIRCUIT BUILDING ERRORS DETECTED
	AH	R2,NC.CRZ		:PLUS # OF CRQ CIRCUIT BUILDING ERRORS
	CLH	R2,NC.THS		:REPORTING THRESHOLD EXCEEDED?
	JL	CKTC10			:NO

	LHI	R0,NR.NCE		:SHOW CIRCUIT BUILDING ERRORS DETECTED
	STH	R0,SUPMBF
	LHL	R0,NC.LPE
	OHI	R0,8000			:NUMBER OF LEP ERRORS (+8000)
	STH	R0,SUPMBF+2
	LHL	R0,NC.CRZ
	OHI	R0,8000			:NUMBER OF CRQ ERRORS (+8000)
	STH	R0,SUPMBF+4
	JAL	R10,SUP12

CKTC10	LHL	R2,NC.CRC		:NUMBER OF CIRCUITS COMPLETED PLUS
	AH	R2,NC.CRZ		:NUMBER OF CIRCUITS IN ERROR
	SH	R2,NC.CRQ		:SHOULD EQUAL # OF CIRCUITS ATTEMPTED
	JE	CKTC40			:IT DOES

:	INTERNALLY DETECTED CONSISTENCY ERROR FOR COUNTING CIRCUITS
:	COMPLETED AND IN ERROR.
	LHI	R0,NR.CKC		:NODE REPORT
	STH	R0,SUPMBF		: FOR CIRCUIT BUILDING CONSISTENCY
	OHI	R2,8000
	STH	R2,SUPMBF+2		:WE ARE OFF BY THIS MANY
	LHL	R0,NC.CER
	AIS	R0,1			:INCREMENT COUNT OF
	STH	R0,NC.CER		: CIRCUIT CONSISTENCY ERRORS DETECTED

	OHI	R0,8000
	STH	R0,SUPMBF+4		:NUMBER OF OCCURRENCES
	JAL	R10,SUP12		:SEND NODE REPORT

CKTC40	LIS	R0,0
	ST	R0,NC.LPE		:CLEAR COUNTERS
	ST	R0,NC.CRZ
	L	R10,LNKRGS

        JR      R10

::*********************************************************************
::
::	SUBROUTINE:	SPEED:
::	FUNCTION:	Expedite zapper or gobbler by overridding backpressure
::			and setting channel service flag.
::	CALLING SEQ:	JAL	R8,SPEED
::	INPUT:		R3 = DESTINATION CHANNEL NUMBER
::
::*********************************************************************

:	Expedite zappers, gobblers.
:	If not dispatcher or link channel, just RETURN.
SPEED	HS	0
	IF	ISIS
	CLHI	R3,DISZFL		:DISPATCHER PORT?
	JLR	R8			:NO - TOO LOW
	CLHI	R3,DISZFL+NDP		:RANGE CHECK FOR DISPATCHER PORT
	JGEFS	SPEED2			:OUT OF RANGE
:	Dispatcher port--override backpressure (DISBPV)
:	and set service flag (DISSVD), then RETURN.
	SBT	R3,DISBPV-DISZFL/8,,	:OVERRIDE BACKPRESSURE AND
	SBT	R3,DISSVD-DISZFL/8,,	:INSURE PROMPT SERVICE
	JR	R8
	EI	:ISIS
:	Link channel, override backpressure (BPSVCP)
:	and set service flag (CHSRVD), then RETURN.
SPEED2	HS	0
	CLHI	R3,LNKZFL		:LINK CHANNEL?
	JLR	R8			:NO - TOO LOW
	CLHI	R3,LNKLFL		:RANGE CHECK FOR LINK CHANNEL
	JGER	R8			:OUT OF RANGE
	SBT	R3,BPSVCP-LNKZFL/8,,	:OVERRIDE BACKPRESSURE AND
	SBT	R3,CHSRVD-LNKZFL/8,,	:INSURE PROMPT SERVICE
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	NEDTIM:
::	FUNCTION:	COMPUTE AMOUNT OF TIME IT TOOK NEEDLE TO
::			COMPLETE TRIP THROUGH NODE.
::	CALLING SEQ:	JAL	R8,NEDTIM
::	INPUT:		R2 = BUFTIM INDEX IS 1/2 BUFFER INDEX
::	DESTROYED:	R0, R1, R3
::
::*********************************************************************

:	BUFTIM FOR THIS CIRCUIT CONTAINS THE FASTC TIME THAT NEEDLE
:	ORIGINATED IN NODE. THIS ROUTINE IS CALLED AS NEEDLE IS TERMINATING
:	CIRCUIT IN NODE. THE DIFFERENCE BETWEEN CURRENT FASTC AND BUFTIM
:	IS THE NUMBER OF FASTC TICKS THAT NEEDLE TOOK TO COMPLETE CIRCUIT
:	IN THIS NODE.

NEDTIM	HS	0
	LR	R1,R2
	SRLS	R1,1			:COMPUTE BUFTIM INDEX
	NHI	R1,-4
	L	R3,FASTC,,		:GET CURRENT TIME AND SUBTRACT
	S	R3,BUFTIM,R1,		:TIME NEEDLE ORIGINATED IN NODE
	CI	R3,10000		:check for halfword overflow	###jhl
	JLFS	NEDT08			:				###jhl
	LHI	R3,$A9999		:corresponds to about 16 2/3 secs##jhl
:	should be converted to msecs somewhere for display
	JFS	NEDT09			:				###jhl
NEDT08	CLH	R3,NEDHWM,,		:MORE THAN PREVIOUS HIGH-WATER MARK?
	JLEFS	NEDT10			:NO
NEDT09	STH	R3,NEDHWM,,		:YES - SAVE NEW HIGH-WATER MARK
NEDT10	LIS	R0,1
	AHM	R0,NEDCNT,,		:COUNT ALL NEEDLES TIMED
	SRLS	R3,2			:HISTOGRAM RECORDS IN FASTC/4 UNITS
	CLHI	R3,NEDTSZ/2		:IS TIME OUTSIDE OF HISTOGRAM RANGE?
	JLFS	NEDT20			:NO
	LHI	R3,NEDTSZ/2-1		:YES - SET TO MAX VALUE
NEDT20	AHM	R0,NEDHST,R3,R3		:RECORD NEEDLE TIME IN HISTOGRAM
	L	R0,SLOWC,,
	ST	R0,BUFTIM,R1,		:RECORD TIME THAT CIRCUIT IS BUILT
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	CHSUPD:
::	FUNCTION:	UPDATE CHS ARRAY.
::	CALLING SEQ:	JAL	R0,CHSUPD
::
::*********************************************************************

:	CHS IS RESET WHEN A ZAPPER TRAVELS ON A CIRCUIT TO
:	SUSPEND THAT CHANNEL UNTIL ZAPPER CLEARS MACHINE. WHEN CHS IS RESET,
:	CHS1 IS SET. THIS CAUSES THE CHANNEL TO BE REINSTATED 30 TO 60 SECONDS
:	LATER BY CHSUPD.

CHSUPD	HS	0
	LHI	R3,-ACPSZP*2		:SIZE OF CHS, CHS1, & CHS2 ARRAYS
	LR	R2,R3			: (POSITIVE AND NEGATIVE)

CHSUP2	L	R1,CHS2+ACPSZP,R3,
	O	R1,CHS+ACPSZP,R3,	:REINSTATE CHANNELS SUSPENDED
	ST	R1,CHS+ACPSZP,R3,
	AIS	R3,4
	JLBS	CHSUP2

CHSUP4	L	R1,CHS1+ACPSZP,R2,	:LATEST CANDIDATES FOR REINSTATEMENT
	ST	R1,CHS2+ACPSZP,R2,	:COPY TO CHS2 TO UPDATE CHS NEXT TIME
	ST	R3,CHS1+ACPSZP,R2,	:CLEAR CHS1 TO ZERO
	AIS	R2,4
	JLBS	CHSUP4
	JR	R0			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	CRTOUT:
::	FUNCTION:	PROCESS CIRCUIT TIME-OUTS
::	CALLING SEQ:	JAL	R10,CRTOUT	Called from 1-minute logic
::
::*********************************************************************

:	Bits set in REBTMI will be timed out next time.
:	Time out circuits whose buffers have bits set in REBTMO this
:	time, and then copy REBTMI into REBTMO.

CRTOUT	LIS	R7,0			:zap circuits that have timed out
	LIS	R4,0			:word index into bit array,bits by buf#
CRTOU2	L	R1,REBTMO,R7,		:get a word of bit flags
	JE	CRTOU3			:none set--move on
	JAL	R8,BID,,		:else consider working
	AR	R2,R4			:bit index + word index into bit array
	RBT	R2,REBTMO,,		:turn off--pay attention only once
	SLHLS	R2,3			:POINTS TO THE RELEVANT BUFFER PAIR
	LHL	R0,BF,R2,		:ZAPPER MUST TRAVEL TOWARDS PORT
	CLHI	R0,CRQZFL		:if in CRQ range OK,
	JGFS	CRTO10			: else look other direction	###JHL
	XHI	R2,4
CRTO10	LHL	R0,BF,R2,		:report port # to XRAY		###jhl
	JAL	R8,CRYPTO,,
	HC	CRYE0F			:MESSAGE = NEEDLE TIMEOUT
	JAL	R9,ZAPHRD		:zap the circuit--clean up leftovers
	J	CRTOU2			:and check bit array for more
CRTOU3	L	R0,REBTMI,R7,		:move next version of attention flags
	ST	R0,REBTMO,R7,		: for subsequent pass
	ST	R1,REBTMI,R7,		:clear the next-pass array
	AHI	R4,20			:increment our base buffer #
	AIS	R7,4			:increment our word index
	CLHI	R4,NCIRCS		:check for end of buffer range
	JL	CRTOU2			:do more
	JR	R10			:looked at flags for all buffers,return

::*********************************************************************
::
::	SUBROUTINE:	RBDOUT:
::	FUNCTION:	PROCESS REBUILD TIME-OUTS			###GT
::	CALLING SEQ:	JAL	R10,RBDOUT
::
::*********************************************************************

:	WHEN THE SOURCE SENDS ON A NEEDLE, A SPECIAL SQFIX		###GT
:	(SEQN = 0) IS ALSO SENT. WHEN THE DESTINATION GETS		###GT
:	A NEEDLE, IT ALSO SENDS A SQFIX 0 TOWARDS THE SOURCE.		###GT
:	IF A FIX0 IS NOT RECEIVED ON EITHER END 1-2 MINUTES
:	AFTER A FIX0 IS SENT OUT, THE CIRCUIT WILL BE MARKED
:	AS NOT REBUILDABLE. HISTORY BUFFERS WILL BE CLEARED.

	IF	REBILD
RBDOUT	HS	0
	LIS	R7,0			:LOOK AT ALL CIRCUITS
	LIS	R4,0
RBDOU1	L	R1,SQFTMO,R7,		:CHECK FOR CIRCUITS THAT TIMED-OUT
	JE	RBDOU4			:NOTHING HERE
	JAL	R8,BID,,		:LOOK FOR FIRST CIRCUIT
	AR	R2,R4			:GET NUMBER
	RBT	R2,SQFTMO		:RESET TIME-OUT FLAG
	TBT	R2,SQFIXV		:CHECK IF A SQFIX HAS BEEN RECEIVED
	JN	RBDOU1			:YES - THE CIRCUIT IS REBUILDABLE
	SLLS	R2,3			:NO - FLAG AS NOT REBUILDABLE
	JAL	R9,RBCOUT		:RELEASE HISTORY BUFFERS AND LOG
	J	RBDOU1			:CHECK NEXT CIRCUIT
RBDOU4	L	R0,SQFTMI,R7,		:PROCESS TIME-OUT
	ST	R0,SQFTMO,R7,
	ST	R1,SQFTMI,R7,		:CLEAR THIS
	AHI	R4,20			:NEXT SET OF CIRCUITS
	AIS	R7,4
	CLHI	R4,NCIRCS		:ALL DONE?
	JL	RBDOU1			:NOT YET
	JR	R10			:YES - RETURN
	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	RBCOUT:
::	FUNCTION:	CLEAN UP AFTER A CIRCUIT IS FLAGGED AS NOT REBUILDABLE
::	CALLING SEQ:	JAL	R9,RBCOUT
::	INPUT:		R2 = BUFFER NUMBER
::
::*********************************************************************

	IF	REBILD
RBCOUT	LR	R1,R2			:SAVE BUFFER INDEX      	###GT
	XHI	R2,4			:GET INCOMING BUFFER
	LHL	R0,BF,R2,,		:GET THE INCOMING CHANNEL NUMBER
	JAL	R8,CRYPTO,,
	HC	CRYE6B			:MESSAGE = REBUILD DISABLED
	XHI	R2,4			:RESTORE BUFFER INDEX
RBCOU1	SRLS	R2,3			:FORM INDEX INTO BIT ARRAY
	RBT	R2,CRQBSY		:INDICATE CIRCUIT NOT REBUILDABLE
	RBT	R2,SQFTMI		:CLEAR REBUILD TIMEOUT		###CY
	RBT	R2,SQFTMO		:				###CY
	SLLS	R2,2			:GET HISTORY BUFFER INDEX
	LI	R2,HBUFN,R2		:FORM HISTORY BUFFER NUMBER
	JAL	R8,CBCLR,,		:CLEAR HISTORY BUFFER
	LIS	R0,0
	ST	R0,RINVC,R2,		:AND INVOICE NUMBER TO PREVENT REBUILDS
	LR	R2,R1			:RESTORE BUFFER INDEX        	###GT
	JR	R9
	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	DETOUT:
::	FUNCTION:	DETACH TIMEOUT ROUTINE, RUN EVERY 30 SEC.
::	CALLING SEQ:	JAL	R10,DETOUT
::
::*********************************************************************

DETOUT	HS	0
	L	R4,DETACP,,		:ANY PORTS ACTIVE ?
	XHI	R4,-1			:COMPLEMENT WORD
	JER	R10			:NO, SKIP IT
	ST	R4,DETSVC		:SAVE THOSE NEEDING SERVICE

DETONX	L	R4,DETSVC		:DETACH TIMEOUT NEXT
	JFFO	R4,DETTO2
	JR	R10			:NONE LEFT, RETURN

DETTO2	RBT	CHN,DETSVC		:THIS ONE IS SERVICED
	LHL	R2,CIOTAB,CHN,CHN	:PERMUTER TABLE ENTRY
	SRLS	R2,1			:GET BUFTIM INDEX
	NHI	R2,-4
	L	R1,BUFTIM,R2,		:START TIME
	AHI	R1,$A60			:+ 60 SEC GIVES TIME TO STOP
	C	R1,SLOWC,,		:> NOW ?
	JG	DETONX			:NO, CONTINUE

:	PORT IN DETACH STATE HAS NOT BOUNCED ORANGE BALL IN OVER 60 SECONDS.
:	ZAP CIRCUIT...
	LHL	R2,CIOTAB,CHN,CHN	:GET BUFFER INDEX BACK
	NHI	R2,-4			:MASK OUT GOUGING BITS,
	JAL	R9,ZAPHRD		:AND ZAP CIRCUIT
	J	DETONX			:CONTINUE

	SUBTTL	CRQ  (DETCIR - Handle data for 'Detached Ports')

::*********************************************************************
::
::	SUBPROCESS:	DETCIR:
::	FUNCTION:	CIRCUITS ARRIVING FOR HOSTS OUT OF PORTS
::			ARE DETACHED INSTEAD OF MERELY BEING ZAPPED.
::	SCHEDULED:	Dispatched by SWITCH based on data being
::		detected on port in detached mode.  Returns to SWITCH
::		(DETRET) when done.
::
::*********************************************************************

:	THE TERMINATING HALF OF THE CIRCUIT IS BUILT TO THE DETACH PROCESS,
:	WHICH SUPPORTS $A32 PORTS BEGINNING WITH 'DETZFL'.  THE SETUP FOR
:	THE DETACH PROCESS INCLUDES STORING A VALUE IN THE 'DETMTY' BYTE
:	ARRAY (INDEXED BY CHANNEL) TO SPECIFY THE TEXT TO THE USER, AND
:	PASSING A NEEDLE POINT TO THE NEW CIRCUIT TERMINATION. WHEN DETCIR
:	DETECTS A NEEDLE IT SENDS TEXT TO THE USER FOLLOWED BY A YELLOW BALL,
:	AND STORES THE CURRENT TIME IN BUFTIM. IF AN ORANGE BALL IS RETURNED,
:	WE ZAP THE CIRCUIT (ALL OTHER INPUT IS TOSSED). IF NO ORANGE BALL IS
:	BOUNCED BACK, DETOUT WILL DETECT AND ZAP.

DETCIR	HS	0			:FOUND DATA ON A PORT IN 'DETACH' MODE
	L	R4,DETFLG,,		:SEE WHICH PORTS NEED ATTENTION
	ST	R4,DETSVC		:SAVE PORTS SERVICED ARRAY

DETNXT	HS	0			:PROCESS NEXT PORT
	L	R4,DETSVC		:GET PORTS THAT NEED ATTENTION
	JFFO	R4,DETCR2		:FIND FIRST
	J	DETRET,,		:NONE LEFT, EXIT

DETCR2	RBT	CHN,DETSVC		:MARK AS SERVICED
	LHL	R2,CIOTAB,CHN,CHN 	:GET BUFFER INDEX
	NHI	R2,-4
	XHI	R2,4			:POINT TO INCOMING BUFFER
	JFS	DETCR4			:START LOOKING FOR DATA

DETCR3	HS	0			:TEST FOR DATA REMAINING
	HC	3A12		:More reliable ##ev
	HC	BB/4
	HC	BBSIZE
	LR	R1,R1
::	LHL	R1,BCT,R2,		:CHARS LEFT IN BUFFER?
	JE	DETNXT			:NO, TRY NEXT BUFFER
DETCR4	JAL	R8,GCI,,		:GET CHARACTER
	LR	R1,R1			:ESCAPE?
	JNFS	DETCR5			:NO
	JAL	R8,GCI,,		:YES, GET DATA BYTE (AND IGNORE)
	JBS	DETCR3

DETCR5	CLHI	R1,03			:ZAPPER, GOBBLER, NEEDLE?
	JE	DETCR7			:YES
	SIS	R1,01			:PREFIX CODE?
	JN	DETCR3			:NO, KEEP LOOKING
	JAL	R8,GCI,,		:YES, LOOK FOR ORANGE BALL
	CLHI	R1,0FE			:ORANGE BALL?
	JN	DETCR3			:NO, KEEP LOOKING

:	FOUND AN ORANGE BALL, ZAP CIRCUIT BOTH WAYS
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP IT ALL
	J	DETNXT			:LOOK AT NEXT PORT

DETCR7	HS	0			:FOUND ZAPPER, GOBBLER, ETC
	JAL	R8,GCI,,		:GET SECOND BYTE
	CLHI	R1,NEEDP&0FF		:NEEDLE?
	JEFS	DETCR8			:YES
	CLHI	R1,ZAPPN&0FF		:ZAPPER?
	JG	DETCR3			:NO, KEEP LOOKING
	JAL	R9,ZAPV			:ZAP 2ND HALF
	J	DETNXT			:LOOK AT NEXT PORT

DETCR8	HS	0			:FOUND NEEDLE
:	FOUND NEEDLE, CLEAR BUFFER, SEND CANNED MESSAGE BACK TO USER

	JAL	R8,CBCLR,,		:CLEAR INPUT BUFFER (NEEDLE AND DATA)
	LB	R4,DETMTY,CHN		:GET MESSAGE TYPE
	LHL	R4,DETMTB,R4,R4		:GET ADDRESS OF MESSAGE (LESS SEG1)
:	AI	R4,10000
	AI	R4,SEG1
	XHI	R2,4			:POINT OPPOSITE THE NEEDLE JUST READ
	JAL	R9,BUFCAN,,		:OUTPUT 'CANNED MESSAGE' TO BUFFER
	LIS	R1,1			:OUTPUT YELLOW BALL
	JAL	R8,WCI,,
	LHI	R1,0FF
	JAL	R8,WCI,,

	SRLS	R2,1			:SET UP BUFTIM INDEX - BUFFER
	NHI	R2,-4			:NUMBER TIMES 2
	L	R0,SLOWC,,
	ST	R0,BUFTIM,R2,		:STORE TIME FOR POSSIBLE TIME-OUT

	J	DETNXT			:LOOK AT NEXT PORT

	SUBTTL	CRQ (TRACE - Circuit tracing logic)

::*********************************************************************
::
::	SUBROUTINE:	TRACE:
::	FUNCTION:	CIRCUIT TRACING LOGIC
::	CALLING SEQ:	JAL	R10,TRACE
::	INPUT:		R5 = CHN = ABSOLUTE CHANNEL NUMBER TO BE TRACED
::			REJECTS TRACE REQUEST IF NO CIRCUIT EXISTS
::
::*********************************************************************

TRACE	HS	0
	LHL	R2,IOTAB,CHN,CHN	:IS THERE A CIRCUIT THERE
	NHI	R2,-4
	JE	TRACE6			:NO
	LHL	CHN,BF,R2,		:EXIT PORT #
	LCS	R1,4			:GET HOST OR NODE AND RELATIVE PORT #
TRACE1	AIS	R1,4
	CLH	CHN,CHNMAP,R1,
	JLBS	TRACE1
	SH	CHN,CHNMAP,R1,
	LHL	R1,CHNMAP+2,R1,
	THI	R1,8000			:TEST FOR INTERNAL CIRC, R1 HAS HOB SET
	JN	TRACE4			:YES, INTERNAL TERMINATION

	LHL	R1,CHNMPD,R1,		:GET NEIGHBOR NUMBER
	THI	R1,8000			:TEST FOR T-I TERMINATION, C000+NODE#
	JN	TRACE4			:YES

TRACE2	JAL	R9,FNDLNK		:IT'S A T-II NEIGHBOR, MAKE SURE ITS UP
	J	TRACE6			:NOT FOUND
	LHL	R2,LKZFKN,KN,KN		:UP, GET IT'S ILC BUFFER #
	LHL	R2,IOTAB,R2,R2
	NHI	R2,-4
	XHI	R2,4
	LIS	R0,1
	AHM	R0,LEPMES+2		:INC THE NODE COUNT
	STH	R1,LEPMES,PRD		:ADD NODE, CHANN TO LIST
	STH	CHN,LEPMES+2,PRD
	LHI	LRC,4,PRD
	LIS	PRD,0			:MOVE MESSAGE TO ILC BUFFER
	LHI	R1,1,LRC		:BYTE COUNT
	JAL	R8,WCI,,
TRACE3	LB	R1,LEPMES,PRD
	JAL	R8,WCI,,
	AIS	PRD,1
	CR	PRD,LRC
	JLBS	TRACE3
	JR	R10

TRACE4	HS	0			:TERMINATION, ADD HOST AND PORT #
	IF	ISIS
	CI	R1,0FFFD		:THIS A DISPATCHER PORT?(-3 FOR 16BITS)
	JNFS	TRACE7			:NO, SKIP IT
	LHL	R1,DHSTIX,CHN,CHN	:GET HOST NUMBER
	OHI	R1,8000			:WITH MSB SET
	EI	:ISIS

TRACE7	HS	0
	STH	R1,LEPMES,PRD
	STH	CHN,LEPMES+2,PRD	:<COUNT OF NODES>
	LHI	R1,148A			:GENERAL FUNCTION (14),
	STH	R1,LEPMES		:TRACE RESPON. (0A)+80

	LHI	LRC,4,PRD		:GET SIZE OF LEP MESSAGE
	LIS	PRD,0
	LHL	R2,TVRBUF		:TEST FOR SUP
	JER	R10			:NO ACTIVE SUP, SKIP IT
	LHI	R1,MACHNM+8000		:SEND NODE NUMBER AS 1ST HW
	JAL	R9,WHWI,,
TRACE5	LHL	R1,LEPMES,PRD		:SEND ALL OF LEP MESSAGE
	JAL	R9,WHWI,,
	AIS	PRD,2
	CR	PRD,LRC
	JLBS	TRACE5
	JR	R10

TRACE6	LCS	R1,1
	LCS	CHN,1			:NONEXISTENT CIRCUIT
	J	TRACE4

	IF	T2GATE
::*********************************************************************
::
::	SUBROUTINE:	GLZPV:	Gateway Login ZaPV
::	FUNCTION:	Used to Zap half a circuit in response to a
::			Zap Ack from dispatcher...or second time around
::			if Zap from Inet is received and aked with 
::			DISZNK set for the channel.
::	CALLING SEQ:	JAL	R9,GLZPV
::	INPUT:		CHN	Relative Dispatcher port
::	RETURNS:	JR	R9
::
::*********************************************************************
GLZPV	HS	0
        IF      CBZDBG                  :debug this too (like ZAPV)
        ST      R4,REGST,,
        JAL     R4,GPZDB1,,
        GL      GPZDB1
        L       R4,REGST,,
        EI   :CBZDBG

	LR	R1,CHN
	RBT	R1,DISFLG,,
	AHI	R1,DISZFL		:Make absolute channel #
	LIS	R0,0
	STH	R0,IOTAB,R1,R1		:CLEAR IOTAB ENTRY
	SBT	R1,ACP,,		:PORT NO LONGER IN USE
	RBT	R1,CHS,,		:BUT SUSPENDED TEMPORARILY
	SBT	R1,CHS1,,		:ENABLE REINSTATEMENT BY 30-SEC LOGIC
	LCS	R0,1
	SR	R0,R1			:COMPUTE NEGATIVE ACP INDEX
	SBT	R0,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R0,CHS,,		:SUSPENDED FOR BOTH NEGATIVE
	SBT	R0,CHS1,,		: AND POSITIVE
GLPZV2	JR	R9
	EI	:T2GATE

	ENDMO.(CRQ)

	EI	:1-KILLIT

	KILMSG(CRQ)

:	***NOTHING PAST THIS POINT***
	SUBTTL	INTHST

:		***** *   * ***** *   *  **** *****
:		  *   **  *   *   *   * *       *
:		  *   * * *   *   *****  ***    *
:		  *   *  **   *   *   *     *   *
:		***** *   *   *   *   * ****    *

::#####################################################################
::
::	MODULE:		INTHST
::
::	FUNCTION:	Process data for internal hosts (remote XRAY,
::		downline load, delay measurement processing).
::
::	SUBTTLS:
::		INTHST - Internal host processor
::		Utilities
::		DWLIN - Handle Down-Line Load record from neighbor
::		DLYSRC - Delay measurement source
::		INTTIM - Internal Host Time-Out logic
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	SEG	1

::*********************************************************************
::
::	SUBPROCESS:	INTHST:
::	FUNCTION:	INTERNAL HOST PROCESSOR
::	SCHEDULED:	Dispatched by SWITCH based on internal host
::		channels with data requesting service.  Returns to
::		SWITCH (INTRET) when done.
::
::*********************************************************************

:	THE INTERNAL HOST ATTENTION FLAGS START AT INTZFL
:
:	THE INTERNAL HOST PROCESSOR FIRST TESTS THE CHN FOR A ZAPPER,
:	AND COMPLETES THE ZAP IF ONE IS FOUND. ELSE, THE DISPATCH ADDRESS
:	ARRAY INTDSP IS EXAMINED FOR A VALID ( >0 ) ADDRESS, AND A DISPATCH
:	IS DONE ACCORDINGLY.  FOR A ZERO DISPATCH ADDRESS THE CHANNEL IS
:	PRESUMED IN LOGIN MODE AND THE USERNAME IS STRIPPED AND THE FUNCTION
:	BYTE EXAMINED.  CERTAIN USER NAMES REQUIRE NO FUNCTION BYTE
:	INITIALLY TIMEOUT IS ENABLED ON ALL NEW INTERNAL HOST CHANNELS 
:	BY SETTING THE CORRESPONDING BIT IN INTOUT. SUBSEQUENTLY TIMEOUT
:	IS DISABLED FOR CERTAIN FUNCTIONS.

INTHST	HS	0
	LH	R3,INTFLG,,		:TEST ALL THE FLAGS
	JNFS	INTH10
	CRASH.(.INTCR)
INTH10	STH	R3,INTLST		:SAVE FOR LATER REFERENCE
INTNXT	LH	R3,INTLST		:FIND NEXT CHANNEL WITH WORK
	JFFOH	R3,INTH12	
	J	INTRET,,			:ALL DONE
INTH12	CLHI	R4,TINTCH		:IS THIS A VALID CHANNEL?
	JLFS	INTH16			:YES, GO HANDLE IT
	J	INTRET,,			:NO, ALL DONE

INTH16	RBT	R4,INTLST		:MARK THIS ONE AS DONE
	LHL	R2,INTTAB,R4,R4		:GET OUTBOUND BUFFER NUMBER
	XHI	R2,4			:FLIP TO INCOMING BUFFER
	NHI	R2,-4			:STRIP SPEED BITS

	JAL	R8,PCIS,,		:TEST FOR CONTROL CHAR OR ZAPPER
	CLHI	R1,3			
	JE	INTZAK			:FOUND ONE, INVESTIGATE FURTHER

	LHL	R1,INTDSP,R4,R4		:ALREADY GOT ROUTINE ADDRESS?
	JN	SEG1,R1,		:YES, GO TO IT (NOTE R1=0 ISN'T VALID)
	TBT	R4,INTUSE		:NO, ALREADY STRIPPED USER NAME?
	JN	INTDWL			:YES, GET FUNCTION

	IF	EXPSEC
	ELSE	:EXPSEC			:NEW CODE STRIPS WHOLE USERNM IN CRQ

INTHS3	HS	0
	JAL	R8,GCI,,			:FALLTHROUGH => NEED TO STRIP USER NAME
	NHI	R1,7F			:REMOVE MSB
	CLHI	R1,3B			:SEMICOLON?
	JEFS	INTHS2			:YES, DONE
	CLHI	R1,0D			:CARRIAGE RETURN?
	JNBS	INTHS3			:NO, CONTINUE

	EI	:EXPSEC

INTHS2	SBT	R4,INTUSE		:MARK COMPLETION OF LOGIN
	SBT	R4,INTOUT		:ENABLE TIMEOUT UNTIL TOLD OTHERWISE
	LHL	R1,BCT,R2,		:ANY MORE DATA?
	JEFS	INTHS4			:NO, EXAMINE USER NAME
	JAL	R8,GCI,,		:YES
	CLHI	R1,80			:IS IT A PAD CHARACTER?
	JEFS	INTHS4			:YES, STRIP IT
	JAL	R8,WCD,,			:NO, RESTORE T

	IF	EXPSEC

INTHS4	HS	0
	LR	R1,R4			:FORM FW INDEX INTO
	SLLS	R1,2			:USERNAME GGLIST INDEX (STORED IN CRQ)
	L	R8,INTUSR,R1,,		:GET GGLIST INDEX
	JE	INTDWL			:DLOAD USER, LOOK FOR FUNCTION BYTE
	JL	INTH60			:INVALID USER, SOLO MACHINE W/O KERNEL

	LIS	R1,1			:ANY XRAY SLOTS? (SLOT 0 FOR TTY)
INTH40	SBT	R1,XUSIUA
	JN	INTH41			:NOT THIS ONE, GO TRY AGAIN
	STB	R1,XNINT,R4,		:XN INTO ARRAY BY INTERNAL HOST PORT
	LHL	XD,XDXN,R1,R1		:GET POINTER TO USER BLOCK
	GL	XDXN
	STH	R8,XUNAME,XD		:USER GG INDEX INTO XRAYUSER BLOCK
	IF	XRYTMC			:###wjl
	CLI	R8,XGGNTC		:GG list index = Network Console?
	JE	INTIIX			:go initialize IIX
	EI	:XRYTMC
	J	INTXR1			:AND GO PROCESS REMOTE XRAY
INTH41	AIS	R1,1
	CLHI	R1,NXUBLK-1
	JLE	INTH40
	LIS	R1,1			:NO SLOTS EMPTY, CHECK FOR OVERRIDE
INTH42	LHL	XD,XDXN,R1,R1		:GET SLOT USERS XRAY USERBLOCK
	LH	R9,XUNAME,XD		:GET SLOT USERS GOODGUY INDEX
	LB	R9,XRAYGG+XGGOVR,R9,	:GET SLOT USERS OVERRIDE LEVEL
	CLB	R9,XRAYGG+XGGOVR,R8,	:COMPARE WITH REQ USERS OVERRIDE LEVEL
	JL	INTH45			:REQUESTOR OVERRIDES CURRENT SLOT
	AIS	R1,1			:TRY NEXT SLOT
	CLHI	R1,NXUBLK-1		:UNTIL WE RUN OUT
	JLE	INTH42
	J	INTH49			:NO SLOTS, REJECT REQUESTOR

INTH60	HS	0			:REJECT REQUESTOR, BAD USERNAME
	IF	INTACC		
	LR	R3,R4			:Internal port index
	LI	R0,AALR11		:Accounting logout reason
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###EV
	STH	R4,INTSAV+4		:SAVE OUR INTHOST INDEX
	L	R4,DETACP,,		:FIND A DETACH PORT
	JFFO	R4,INTH61
	LHL	R4,INTSAV+4		:ELSE RECOVER OUR INTHOST INDEX
	J	INTZPH			:AND GET ZAPPED
INTH61	LHL	R4,INTSAV+4		:FOUND ONE, RECOVER INHOST INDEX
	LIS	R0,7			:DETACH MESSAGE (BAD USERNAME)
	STB	R0,DETMTY,CHN		:SET UP FOR DETACH PROCESS
	LHI	R1,ASCCR^8+ASCLF	:FAKE ZAPPER - CRLF (0D0A)
	XHI	R2,4			:FLIP TO OUT BUFF#
	JAL	R9,ZAPX			:ZAP HALF
	JAL	R10,INTZA1		:AND INTHOST CLEANUP
	AHI	CHN,DETZFL		:ABS CHN # FOR DETACH PROCESS
	JAL	R9,CRQHCR		:CONNECT CRQ STUB TO DETACH PROCESS
	XHI	R2,4			:POINT TOWARD DETACH PROCESS AND
	LIS	R1,3			:WRITE NEEDLE POINT INTO BUFFER
	JAL	R8,WCI,,
	LHI	R1,NEEDP
	JAL	R8,WCI,,
	J	INTNXT			:BACK TO THE TOP

	ELSE	:EXPSEC

INTHS4	LR	R1,R4			:FORM FULL-WORD INDEX
	SLLS	R1,2			:TO INDEX INTO USERNAME (STORED IN CRQ)
	LI	R0,54494944			
	CL	R0,INTUSR,R1,,		:USER NAME = TIID?
	JN	INTHS5			:NO
INTH4A	LIS	R1,1			:ANY XRAY SLOTS AVAILABLE? NOTE-SLOT 0
					:RESERVED FOR TTY USER.
INTH40	SBT	R1,XUSIUA
	JNFS	INTH41			:NOT THIS ONE, GO TRY AGAIN
	STB	R1,XNINT,R4,		:XN INTO ARRAY BY INTERNAL HOST PORT
	LHL	XD,XDXN,R1,R1		:GET POINTER TO USER BLOCK
	LCS	R0,1			:INDICATE PRIVILEGED USER
	STH	R0,XUNAME,XD
	J	INTXR1
INTH41	AIS	R1,1
	CLHI	R1,NXUBLK-1
	JLE	INTH40
	LIS	R1,1			:NO. ANY LOW-POWER SLOTS LOGGED IN?
INTH42	LHL	XD,XDXN,R1,R1
	LH	R0,XUNAME,XD		:PRIVILEGED USER?
	JE	INTH45			:NO
	AIS	R1,1			:TRY NEXT SLOT
	CLHI	R1,NXUBLK-1		:UNTIL WE RUN OUT
	JLEBS	INTH42

	EI	:EXPSEC

					:NO SLOTS AVAIALABLE
INTH49	STH	R4,INTSAV+4		:SAVE OUR INTHOST INDEX
	L	R4,DETACP,,		:FIND A DETACH PORT
	JFFO	R4,INTH48
	LHL	R4,INTSAV+4		:ELSE RECOVER OUR INTHOST INDEX
	IF	INTACC		
	LR	R3,R4
	LI	R0,AALR19		:Get logout reason
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###ev
	J	INTZPH			:AND GET ZAPPED
INTH48	LHL	R4,INTSAV+4		:FOUND ONE, RECOVER INHOST INDEX
	LIS	R0,5			:DETACH MESSAGE (OUT OF XRAY SLOTS)
	STB	R0,DETMTY,CHN		:SET UP FOR DETACH PROCESS
	LHI	R1,0D0A			:FAKE ZAPPER - CRLF
	XHI	R2,4			:FLIP TO OUT BUFF#
	JAL	R9,ZAPX			:ZAP HALF
	JAL	R10,INTZA1		:AND INTHOST CLEANUP
	AHI	CHN,DETZFL		:ABS CHN # FOR DETACH PROCESS
	JAL	R9,CRQHCR		:CONNECT CRQ STUB TO DETACH PROCESS
	XHI	R2,4			:POINT TOWARD DETACH PROCESS AND
	LIS	R1,3			:WRITE NEEDLE POINT INTO BUFFER
	JAL	R8,WCI,,
	LHI	R1,NEEDP
	JAL	R8,WCI,,
	J	INTNXT			:BACK TO THE TOP
INTH45	STH	R2,INTSAV		:SAVE OUR BUFFER #
	STH	R1,INTSAV+2		:AND OUR SLOT# * 4
	STH	R4,INTSAV+4		:AND OUR INTHOST INDEX

	IF	EXPSEC
	STH	R8,INTSAV+8		:SAVE GGLIST INDEX
	EI	:EXPSEC

	LHL	XD,XDXN,R1,R1		:GET OUR VICTIM'S POINTER
	IF	INTACC		
	LHL	R3,XUINTH,XD		:Get internal port index (poor guy)
	LI	R0,AALR26		:and logout reason (tuff luck buddy)
	JAL	R8,AARLO		:Tell Sup this guy is finished
	EI	:INTACC			:###EV
	LHL	R2,XRYBFO,XD		:GET HIS OUT BUFFER #
	L	R4,DETACP,,		:FIND AN AVAIL. DETACHED PROCESS PORT
	JFFO	R4,INTH46		:IF POSSIBLE
	LHL	R4,XUINTH,XD		:ELSE GET VICTIM'S INTHOST PORT INDEX
	JAL	R10,INTZAP		:AND JUST ZAP 
	J	INTH47			:AND CONTINUE
INTH46	LHL	R4,XUINTH,XD		:GET VICTIM'S INTHOST INDEX
	LIS	R0,6			:DETACH MESSAGE #6 (XRAY SLOT OVERRIDE)
	STB	R0,DETMTY,CHN
	LHI	R1,0D0A			:CRLF FOR FAKE ZAPPER
	JAL	R9,ZAPX			:REMOVE INTTAB ENTRY, SET ACP
	STH	R2,INTSAV+6		:SAVE R2 FROM INTZA1
	JAL	R10,INTZA1		:INTHOST CLEANUP
	LHL	R2,INTSAV+6		:RECOVER R2
	AHI	CHN,DETZFL		:DETACH PROCESS ABS CHAN #
	JAL	R9,CRQHCR		:CONNECT CRQ STUB TO DETACH PROCESS
	XHI	R2,4			:POINT TOWARD DETACH PROCESS AND
	LIS	R1,3			:WRITE NEEDLE POINT INTO BUFFER
	JAL	R8,WCI,,			:TO ALERT DETCIR OF NEW PORT
	LHI	R1,NEEDP
	JAL	R8,WCI,,
INTH47	LHL	R1,INTSAV+2		:RECOVER OUR SLOT# * 4
	LHL	R2,INTSAV		:AND OUR OUT BUFFER#
	LHL	R4,INTSAV+4		:AND OUR INTHOST INDEX

	IF	EXPSEC
	LHL	R8,INTSAV+8		:RECOVER GGLIST INDEX
	EI	:EXPSEC

	RBT	R1,XUSIUA		:FREE UP THE SLOT
	J	INTH40			:TAKE OVER THE SLOT

	IF	EXPSEC
	ELSE	:EXPSEC

INTHS5	LHI	R0,5852
	CLH	R0,INTUSR,R1,,		:USER NAME = XRAY OR XRIS?
	JN	INTDWL			:NO, GO GET FUNCTION BYTE
	LIS	R1,1			:FIND AVAILABLE XRAY SLOT
INTHS7	SBT	R1,XUSIUA		:IE, FIND A 0 FLAG HERE
	JEFS	INTHS6			:FOUND ONE
	AIS	R1,1			:TRY NEXT
	CLHI	R1,NXUBLK-1		:TILL WE RUN OUT
	JG	INTH49			:NONE. ZAP.
	JBS	INTHS7
INTHS6	STB	R1,XNINT,R4,		:XN BY INT HOST PORT
	LHL	XD,XDXN,R1,R1		:GET POINTER TO USER BLOCK IN R15
	LIS	R0,0			:INDICATE NON-PRIVILEGED USER
	STH	R0,XUNAME,XD
	J	INTXR1			:JUMP TO REMOTE XRAY HANDLER

	EI	:EXPSEC

INTDWL	JAL	R9,INTGET		:GET FUNCTION BYTE
	CLHI	R1,40			:LINE NUMBER (0-63) ?
	JGE	INTPLI			:NO, THIS ISN'T A DWL COMMAND
	SBT	R4,INTDWF		:MAKE ENTRY INTO DWL ARRAY
	RBT	R4,INTOUT		:NO TIMEOUT
	LHI	R0,DWLOUT-SEG1		:STORE ROUTINE ADDRESS
	STH	R0,INTDSP,R4,R4
	J	DWLOUT			:GO TO DWL ROUTINE

INTPLI	CLHI	R1,82			:PLI MESSAGE?
	JN	INTDLY			:NO
	XHI	R2,4			:GET OUTBOUND BUFFER NUMBER
	JAL	R8,WCI,,			:ECHO COMMAND BYTE
	XHI	R2,4
	LCS	R0,1
	STH	R0,PLICNT		:INITIALIZE PLICNT
	LHI	R0,PLIMSG-SEG1		:ROUTINE ADDRESS
	STH	R0,INTDSP,R4,R4
	J	PLIMSG

INTXR1	RBT	R4,INTOUT		:NO TIMEOUT FOR REMOTE X-RAY
	JAL	R8,CBCLR,,		:CLEAR TRAILING DATA
	XHI	R2,4			:GET OUTGOING BUFFER NUMBER
	STH	R2,XRYBFO,XD		:OUTBOUND BUFFER NO. THIS USER
	STH	R4,XUINTH,XD		:INTERNAL HOST CHANNEL#
	STH	R1,XUSLTN,XD		:XRAY USER SLOT NO.
	SBT	R4,INTXRF		:NOTE THE PRESENCE OF REMOTE XRAY

	SEG	0			:###TZ
XWMFLG	HS	1

	SEG	1
	SBT	R4,XWMFLG,,		:###TZ
	LHI	R0,REMXRY-SEG1		:GET ROUTINE ADDRESS
	STH	R0,INTDSP,R4,R4
	LIS	R0,0
	STH	R0,EKOTYP,XD		:INIT TO REMOTE ECHO
	LIS	R0,1
	STH	R0,CRYMOD,XD		:INIT AUTO CRYPTO DISPLAY OFF
	STH	R0,XPOWER,XD
	J	REMXRZ			:JUMP TO INITIALIZE ROUTINE

	IF	XRYTMC			:###wjl
INTIIX	RBT	R4,INTOUT		:NO TIMEOUT FOR TMCS X-RAY
	JAL	R8,CBCLR,,		:CLEAR TRAILING DATA
	XHI	R2,4			:GET OUTGOING BUFFER NUMBER
	STH	R2,XRYBFO,XD		:OUTBOUND BUFFER NO. THIS USER
	STH	R4,XUINTH,XD		:INTERNAL HOST CHANNEL#
	STH	R1,XUSLTN,XD		:XRAY USER SLOT NO.
	SBT	R4,INTXRF		:NOTE THE PRESENCE OF REMOTE XRAY
	RBT	R4,XWMFLG,,		:disable warning message
	LHI	R0,IIXXRY-SEG1		:GET ROUTINE ADDRESS for TMCS XRY
	STH	R0,INTDSP,R4,R4
	TS	EKOTYP,XD		:init to local echo
	LIS	R0,1
	STH	R0,CRYMOD,XD		:INIT AUTO CRYPTO DISPLAY OFF
	STH	R0,XPOWER,XD
	LHL	R0,CRYPRI		:clear Crypto buffer
	STH	R0,CRYPTU,XD
	LHL	R0,XRYPTF,XD		:FLUSH INPUT RING
	STH	R0,XRYPTE,XD
	LHI	R1,01F-PXRAY
	SBT	R1,SQUEUE		:SCHEDULE XRAY OFF EXEC QUEUE
	LHL	XN,XUSLTN,XD		:THIS USER'S XRAY SLOT NO.
	SBT	XN,XQUEM,,		:SET XRAY USER QUEUE
	LHL	XD,XDXN,XN,XN		:RESTORE XRAY USER BLOCK POINTER
	LI	R1,XRAYIX		:INITIAL ADDRESS FOR TMCS XRAY USER
	GL	XRAYIX
	ST	R1,XRYADR,XD,
	J	INTNXT
	EI	:XRYTMC

INTDLY	CLHI	R1,44			:ROUND-TRIP DELAY MEASUREMENT?
	JN	INTLPB			:NO, PERHAPS LOOPBACK
	RBT	R4,INTOUT		:YES, NO TIMEOUT HERE
	SBT	R4,INTDSF		:SET THE DELAY CHECK CHANNEL FLAG
	LHI	R0,01F-PDLYSR		:GET SCHEDULE PRIORITY FOR DLYSRC
	LHI	R1,3C			:CLEAR POSSIBLE EARLIER SCHEDULE OF
INTDL1	RBT	R0,SCHTAB,R1,		:DLYSRC ROUTINE
	SIS	R1,4
	JGEBS	INTDL1
	LHL	R1,DLYINT,,		:GET CURRENT DLYSRC RATE
	SLLS	R1,2			:FORM FW INDEX
	SBT	R0,T08SEC,R1,		:AND SCHEDULE DLYSRC OFF TIMEOUT LIST
	LHI	R0,DLYSFL-SEG1		:INITIAL ENTRY POINT FOR DLYSRC
	GL	DLYSFL
	STH	R0,INTDSP,R4,R4
	J	INTNXT

INTLPB	CLHI	R1,4C			:LOOPBACK TEST?
	JNFS	INTEND			:NO,BAD COMMAND. ZAP!
	LHI	R0,LOOPBK-SEG1
	STH	R0,INTDSP,R4,R4		:YES, SET UP FOR LOOPBACK
	RBT	R4,INTOUT		:NO TIMEOUT
	J	INTNXT

INTEND	LR	R0,R1
	JAL	R8,CRYPTO,,		:MESSAGE = BAD INT HOST FUNCTION BYTE
	HC	CRYE50
	J	INTZPH			:ZAP THE CIRCUIT

INTZAK	JAL	R8,GCI,,			:DEAL WITH 03-XX CHARACTER PAIR
	JAL	R8,GCI,,
	CLHI	R1,ZAPPH&0FF		:IS IT A HARD-ZAPPER?
	JE	INTZK1			:YES
	IF	IDTACH			:ISIS Detach			###wjl
	CLHI	R1,ZAPPN&0FF		:Is it a Non-Gobbling Zapper?
	JE	INTZK1			:Yes
	EI	:IDTACH							###wjl
	TBT	R4,INTXRF		:NO, IS THIS A REMOTE XRAY CHN?
	IF	INTACC		
	JE	INAZ24			:Go do final accounting
	ELSE
	JE	INTZPH			:NO, ZAP THE CRQ
	EI	:INTACC			:###EV
	CLHI	R1,GOBBL&0FF		:REM XRAY MAY GET A GOBBLER FROM NAD
	JEFS	INTZK2			:SKINNY GOBBLER
	CLHI	R1,GOBBF&0FF		:OR FAT GOBBLER
	IF	INTACC		
	JN	INAZ24			:Go do final accounting
	ELSE	
	JN	INTZPH			:OTHER STUFF. ZAP CHANNEL
	EI	:INTACC			:###EV
INTZK2	LIS	R1,3			:NAD SENDS GOBBLER INSTEAD OF ^C
	LHL	R2,INTTAB,R4,R4		:SO WE MUST INSERT ^C
	NHI	R2,-4
	XHI	R2,4
	JAL	R9,WCIE,,
	J	INTNXT			:AND RETURN TO MAINLINE
INTZK1	HS	0
	IF	INTACC		
	LR	R3,R4			:Get internal port index 
	LI	R0,AALR03		:Logout reason (zap from user)
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###EV
	JAL	R9,ZAPV			:ZAPPER, ACKNOWLEDGE
	JAL	R10,INTZA1		:GO DO THE CLOSING BOOKKEEPING
	J	INTNXT

	IF 	INTACC		
INAZ24	HS	0			:Final accounting, circuit reject
	LR	R3,R4			:Get internal port index
	LI	R0,AALR24		:and logout reason
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###EV
INTZPH	JAL	R10,INTZAP
	J	INTNXT


::*********************************************************************
::
::	ENTRY POINT:	DWLOUT:
::	FUNCTION:	FORMAT DOWN-LINE LOAD RECORD FOR NEIGHBOR
::	FORMATS A RECORD FOR THE MACHINE BEING LOADED
::	R4	=	ACTIVE DWL CHANNEL INDEX
::	R6	=	2 X R4
::
::*********************************************************************

DWLOUT	HS	0
	LR	R6,R4
	AR	R6,R4
	IF	SIORNG
:	MAYBE SIO RING DOWN-LINE LOAD
	CLHI	R1,SIRILN		:'FAKE' SIO RING LINE NUMBER?
	JE	DWLSIR			:YES - GO HANDLE
	EI	:SIORNG
	CLHI	R1,NLINES		:IS IT A VALID PORT NUMBER?
	JLFS	DWLOU9			:YES IT IS
SDWKER	XHI	R1,0FEFF		:INSERT FAULT INDICATOR AND COMPLEMENT
	STH	R1,DWLNUM,R6,
	IF	INTACC		
	J	DWAZ19			:Accounting and zap
	ELSE
	J	INTZPH			:AND ZAP THE CHANNEL
	EI	:INTACC			:###ev
DWLOU9	LR	LN,R1			:NEED 2*LINE #
	AR	LN,LN
	IF	STRHUB
	LB	R0,LTYP,LN,
	JEFS	DWLC09
	J	SDWL09			:Departure for Starhub DWL processing
	EI	:STRHUB
DWLC09	L	R0,KDLN,LN,LN		:LINE BETTER BE UNATTACHED
	JLFS	DWLOU8			:IT IS
SDLUP	XHI	R1,0FDFF		:INSERT FAULT INDICATOR AND COMPLEMENT
	STH	R1,DWLNUM,R6,
	IF	INTACC		
	J	DWAZ19			:Accounting and zap
	ELSE
	J	INTZPH			:AND ZAP THE CHANNEL
	EI	:INTACC			:###EV

::Downline load proceeds here for load over downed line
DWLOU8	SBT	LN,DWLDSP,,		:TEST AND SET THE DWL DISPATCH ARRAY
	JEFS	DWLOU7			:IT IS AVAILABLE
SDNAVL	XHI	R1,0FCFF		:INSERT FAULT INDICATOR AND COMPLEMENT
	STH	R1,DWLNUM,R6,		:AND STORE BACK
	IF	INTACC		
	J	DWAZ19			:Accounting and zap
	ELSE
	J	INTZPH			:AND ZAP THE CHANNEL
	EI	:INTACC			:###EV

DWLOU7	XHI	R2,4
	JAL	R9,WCIE,,		:ECHO LINE NUMBER BACK TO HOST
	XHI	R2,4
DWST07	LCS	R0,2			:MARK IT IN DOWNLINE MODE
	ST	R0,KDLN,LN,LN
	STH	LN,DWLNUM,R6,
	LHI	R0,INTZFL,R4		:TELL XRAY ABOUT NEW DWL CHANNEL
	STH	R1,CRYSBF,,		:STORE LINE NUMBER FOR CRYPTO
	JAL	R8,CRYPTO,,		:LINE # IN TOP, CHANNEL # IN BOTTOM
	HC	CRYE2C
	IF	SILINS
	CLHI	LN,(NLINES-SILINS)*2	:SIO LINE?
	JGEFS	DWLSI1			:YES, IT GETS DIFFERENT TREATMENT
	EI	:SILINS
	LR	R1,LN
	SRHLS 	R1,1			:IDLE LINE
	RBT	R1,VRSTDL		:INSURE WE STAY IDLE
	RBT	R1,LINATT
	RBT	R1,LINDET
	LIS	R0,0
	IF	ISIS
	SVC	IO,60
	ELSE	:NOT ISIS
	SVC	0F,SV.CSY		:SVC05--sync I/O connect
	EI	:ISIS
	JFS	DWLOU3

	IF	SILINS
DWLSI1	LHI	R0,SIOIDL-SEG1		:PUT SIO LINE INTO IDLE STATE
	STH	R0,SIOTST,LN		:BY STORING ADDRESS OF THE IDLE ROUTINE
	LR	R1,LN
	SHI	R1,(NLINES-SILINS)*2	:REMOVE SIO LINE BIAS
	SLLS	R1,3
	LIS	R0,7			:INITIALIZE COMMAND AREA FOR SIO BOARD
	STB	R0,SIDWCM,R1,
	EI	:SILINS

DWLOU3	HS	0
	LIS	R0,0			:INITIALIZE RECORD OUT PTR
	STH	R0,DWLOPT,R6,,
	STH	R0,DWLCIN,,
	STH	R0,DWLCOU,,
	STH	R0,DWLCLI,,
	STH	R0,DWBUSY,R6,		:INPUT BUFFER IS FREE
	LHI	R0,DWLOU2-SEG1		:STORE NEW ENTRY ADDRESS
	STH	R0,INTDSP,R6,
	LHL	R0,BCT,R2,		:ANY MORE BYTES IN BUFFER?
	JE	INTNXT			:NO, DISMISS

	IF	INTACC		
DWAZ19	HS	0			:Here for bad dwl function accounting
	LR	R3,R4			:Get DWL channel index
	LI	R0,AALR19		:Logout reason 19 bad DWL function
	JAL	R8,AARLO		:Perform final accounting
	J	INTZPH			:Now Zap the circuit
	EI	:INTACC			:###ev
::*********************************************************************
::
::	ENTRY POINT:	DWLOU2:
::	FUNCTION:	INTHST DISPATCHES TO HERE AFTER A VALID LINE
::			NUMBER HAS BEEN RECEIVED
::
::*********************************************************************

DWLOU2	HS	0
	SBT	R4,INTACT		:MARK AS ACTIVE TO AVOID TIMEOUT
	LR	R6,R4
	AR	R6,R6
	LHL	LN,DWLNUM,R6,		:GET LINE NUMBER
	IF	SILINS
	CLHI	LN,(NLINES-SILINS)*2	:SIO LINE?
	JGE	DWLSI3			:YES, BRANCH AWAY FOR SPECIAL TREATMENT
	EI	:SILINS

	LR	R1,LN			:WAIT FOR OUTPUT COMPLETION
	SRHLS	R1,1
	IF	ISIS
	SVC	IO,70
	ELSE	:NOT ISIS
	SVC 	0F,SV.SOI		:SVC06--sync output idle
	EI	:ISIS
	J	INTNXT			:MUST WAIT S'MORE

	LR	R7,R6			:FORM DWOBUF OFFSET (66*DWL LINE INDEX)
	SLLS	R7,5			:...= (33 X R6)
	AR	R7,R6
	LHL	PRD,DWLOPT,R6,,		:GET OUTPUT PTR
	JN	DWLOU1
	JAL	R8,CBCCT,,		:WAIT FOR A FEW BYTES
	SIS	R1,4
	JLE	INTNXT
	JAL	R9,INTGET
	CLHI	R1,32			:WAIT FOR HEADER
	JN	INTNXT
	JAL	R8,GCI,,			:DISCARD NEXT 32
	LHI	R1,3232			:SET HEADER
	STH	R1,DWOBUF,R7
DWLOU1	JAL	R9,INTGET		:GET NEXT BYTE
	STB	R1,DWOBUF+2,PRD,R7
	AIS	PRD,1
	NHI	PRD,3F
	STH	PRD,DWLOPT,R6,,
	JN	DWLOU1

:	TARGET MACHINE RECORD ASSEMBLED...SET UP SVC CALL TO TRANSMIT
:	BLOCK. R0=HANDLER CODE FOR DOWN-LINE LOAD RECORD TRANSMISSION, 
:	R1=LINE NUMBER, R2 POINTS TO RECORD TO BE TRANSMITTED, R3 HAS
:	THE BLOCK LENGTH.
	LR	R1,LN
	SRLS	R1,1			:TARGET LINE NUMBER
	LA	R2,DWOBUF,R7		:POINT TO BLOCK TO BE TRANSMITTED
	LIS	R0,3			:SET UP HANDLER CODE TO XMIT DLD BLOCK
	IF	ISIS
	LHI	R3,21			:ISIS EXPECTS LENGTH IN HALFWORDS
	SVC	IO,60
	ELSE	:NOT ISIS
	LHI	R3,42			:...SOLO WANTS BYTE COUNT
	SVC	0F,SV.CSY
	EI	:ISIS
	IF	INTACC			
	LHI	R0,42			:Load byte count - expected in R0
	LR	R3,R4			:Internal host port index in wrk reg
	JAL	R8,AARDIC		:Accumulate to INput count to DWload
	EI	:INTACC			:###EV
	SRLS	R6,1
	SBT	R6,INTACT		:MARK LINE AS ACTIVE FOR INTOUT
	LIS	R0,1
	AHM	R0,DWLCOU,,
	J	INTNXT			:AND GO TO NEXT LINE

:	FOR SIO LINES A DIFFERENT SVC IS CALLED. THE MOTHERBOARD IS 
:	PASSED A QUAD WORD ADDRESS IN R1 WHICH IS THE BEGINNING OF THE
:	CHANNEL OUTPUT COMMAND ROUTINE. FOR SOLO, R0 = 2 X LINE NO.  FOR
:	ISIS RO = LINE NO.

	IF	SILINS
DWLSI3	IF	STRHUB
	LB	R0,LTYP,LN,
	JE	DWLS33
	L	KD,DWLKDS,R6,R6		:Get KD for Starload
	EI	:STRHUB
DWLS33	LR	R7,LN
	SHI	R7,(NLINES-SILINS)*2	:REMOVE SIO LINE BIAS
	SLLS	R7,3			:USE LINE# X 10 (HEX) FOR CONVENIENCE
	LB	R0,SIDWCM,R7,		:SIO CARD DONE TRANSMITTING?
	JE	INTNXT			:NOPE, DISMISS
	SLLS	R7,3			:USE LINE# X 80 (HEX) FOR CONVENIENCE
	IF	STRHUB
	LB	R0,LTYP,LN,
	JE	DWLS3A			:REGULAR SIO LINE ##AL
	LHL	PRD,DWLOPT,R6,		:IN THE MIDDLE OF SOMETHING?
	JN	DWLS34			:YES
	JFS	DWLS3B			:STARLINE ##AL
DWLS3A	EI	:STRHUB
	LHL	PRD,DWLOPT,R6,		:IN THE MIDDLE OF SOMETHING?
	JN	DWLSI4			:YES
DWLS3B	JAL	R8,CBCCT,,		:NO, DO WE HAVE 4 BYTES TO WORK WITH?
	SIS	R1,4
	JL	INTNXT			:NO, DISMISS UNTIL WE DO
	JAL	R9,GHWI,,		:GET FIRST TWO BYTES
	CLHI	R1,3232			:AND CHECK FOR DWL HEADER
	JN	INTNXT			:ISN'T A HEADER, DISMISS
	IF	STRHUB
	LB	R9,LTYP,LN,
	JE	DWLSIA
	L	R9,LNKKEY,KD		:GET STRLINK KEY FOR SIDWBF
	ST	R9,SIDWBF+2,R7,PRD	:STORE IT INTO OUT-BUFFER AFTER CT.
	STH	R1,SIDWBF+6,R7,PRD	:IS A HEADER. STORE INTO OUT-BUFFER
DWLS34	JAL	R9,INTGET		:GET ANOTHER BYTE
	STB	R1,SIDWBF+8,PRD,R7	:AND STORE INTO OUT-BUFFER
	AIS	PRD,1			:INCREMENT POINTER
	NHI	PRD,3F			:MOD 40 (HEX)
	STH	PRD,DWLOPT,R6,
	JN	DWLS34			:LOOP BACK TILL WE HAVE 40 (HEX) BYTES
	J	DWLS15
DWLSIA	EI	:STRHUB			:##AL
	STH	R1,SIDWBF+2,R7,PRD	:IS A HEADER. STORE INTO OUT-BUFFER
DWLSI4	JAL	R9,INTGET		:GET ANOTHER BYTE
	STB	R1,SIDWBF+4,PRD,R7	:AND STORE INTO OUT-BUFFER
	AIS	PRD,1			:INCREMENT POINTER
	NHI	PRD,3F			:MOD 40 (HEX)
	STH	PRD,DWLOPT,R6,
	JN	DWLSI4			:LOOP BACK TILL WE HAVE 40 (HEX) BYTES
DWLS15	SRLS	R7,3			:USE LINE #  X  10 (HEX) FOR EASE...
	LA	R1,SIDWCM,R7,		:R1=ADDRESS OF CHANNEL COMMAND ROUTINE
	LR	R0,LN			:R0= 2*LINE NUMBER
	LIS	R2,1			:FORM OUTPUT COMMAND
	STH	R2,SIDWCM,R7,		:AND STORE IT INTO COMMAND AREA
	IF	ISIS
	SRLS	R0,1			:ISIS WANTS ACTUAL LINE NO
	TBT	R0,SIOPTA,,		:IS SIO PORT AVAILABLE?		###OAS
	JNFS	SIOPT7			:NO, SKIP SVC
	SVC	IO,0B0
	JAL	R12,SVCR3B		:ERROR, HANDLE IT		###OAS
SIOPT7	HS	0
	ELSE	:NOT ISIS
	SVC	0F,SV.OSI
	JAL	R12,SVCR0E		:ERROR, HANDLE IT		###OAS
	EI	:ISIS

	LIS	R0,1			:EVERYTHING OK
	AHM	R0,DWLCOU,,
DBZRET	SRLS	R6,1
	SBT	R6,INTACT		:MARK LINE AS ACTIVE
	IF	INTACC			
	LHI	R0,40			:SIO records are 40 hex bytes
	LR	R3,R6			:SIO uses R6 for port index wrk reg
	JAL	R8,AARDIC		:Accumulate character count
	EI	:INTACC			:###EV
	J	INTNXT			:GO SERVICE NEXT LINE


	IF	STRHUB
::*********************************************************************
::
::	ENTRY:		SDWL09:
::	FUNCTION:	For Starlines, does a Key match and if matched
::			proceedes with DownLine load.  Uses old DWL logic
::			for first link on Starline.  Uses new Starhub logic
::			for all subsequent link DWLs on the Starline.
::			DWL uses two bits in the link descriptor status
::			flags.  Their meaning is as follows.
::	STATUS FLAGS:
::
::	DWLXFL	*	DWL Transmit flag
::			1=DWL has data ready for the transmitter to transmit
::			  ( changed to 0 by transmitter when data moved to 
::			      SIO output buffer).
::			0=Transmitter has taken data - ready for more DWL data.
::	DWLVFL	*	DWL Receive flag
::			1=Transmitter has placed DWL data in DWL input buffer.
::			0=DWL has copied from DWL buffer to circuit buffer, and
::			  is ready to receive more data.
::**********************************************************************
STFUNC	EQ	40
::Subsequent link for DWL on attached Starline - Starload processing.
SDWL09	HS	0
	LR	R1,LN
	SRLS	R1,1		:get line number
	OHI	R1,STFUNC	:and indicate as Starline
	XHI	R2,4
	JAL	R9,WCIE
	XHI	R2,4		:Echo line number back to host
	STH	LN,DWLNUM,R6,	:Store line number for DWL (as 2*actual line#)
	LHL	R1,BCT,R2,
	JN	SDWL10		:Set up for re-entry or test for key
	LHI	R0,SDWL10-SEG1
	STH	R0,INTDSP,R6,
	J	INTNXT

SDWE00	LR	R1,LN			:Restore real line number
	SRLS	R1,1
	J	SDWKER			:and jump to error section - Zap etc.

SDWL10	LR	R6,R4
	AR	R6,R6			:Form internal host channel index
	JAL	R9,INTGET
	LR	R5,R1	
	JAL	R9,INTGET
	EXBR	R5,R5			:Get target node number
	OR	R1,R5
:	NHI	R1,0FFF			:Remove high order bit
	NHI	R1,03FFF		:Remove high order bit FOR 5
					: DIGIT NODE NUMBER (14-bits) ##AL
	LH	LN,DWLNUM,R6,		:Restore target line index (2*line #)
	L	R5,SKDPTR,LN,LN		:Get Starline block pointer
	JAL	R8,STKDMT		:Match target node number
	J	SDWE00			:Error - Zap circuit
	LR	R1,LN
	SRLS	R1,1
	ST	KD,DWLKDS,R6,R6		:Store link descriptor pointer
	L	R0,KDLN,LN,LN
	JGEFS	DWS12C			:Not first link, continue
	LIS	R0,0						###ev 10/10
	STB	R0,STAFLG,KD		:Ensure 1st link status set to 0
	SBT	LN,DWLDSP,,		:First link, test dispatch bit
	JE	DWST07			:It is available - jump to old logic
	J	SDNAVL			:Not available .. error
DWS12C	TBT	LN,DWLDSP,,		:Is this line's DWL facility available?
	JN	SDNAVL			:for error routine ... return
	LB	R0,STAFLG,KD		:Test current link status
	JN	SDLUP			:Link not down - Zap
DWS12T	LHI	R0,INTZFL,R4
	STH	R1,CRYSBF,,
	JAL	R8,CRYPTO,,
	HC	CRYE2C			:Send Crypto Log report
::Set up Starlink descriptor with DWL parameters
	LR	R7,R6
	SLLS	R7,5
	AR	R7,R6		:Form offset into DWOBUF
	LI	R7,DWOBUF,R7	:Make address of DWL output 
	ST	R7,DWLXBF,KD	:Store in Starlink descriptor
	LR	R6,R4
	SLLS	R6,6
	LI	R6,DWIBUF,R6	:Address of DWL input for this Strlnk
	ST	R6,DWLVBF,KD	:Store it
	STH	R4,DWLNDX,KD	:Store channel index in link descriptor
	LIS	R0,DWLSTA
	STB	R0,STAFLG,KD	:Set link descriptor status to DW Load
	LIS	R0,0
	STH	R0,DWLOPT,R4,R4
	STH	R0,DWLCIN,,
	STH	R0,DWLCOU,,
	STH	R0,DWLCLI,,
	STH	R0,DWBUSY,R4,R4
::Now is there more DWL data?  If not come back later.
	LHI	R0,SDWL02-SEG1
	STH	R0,INTDSP,R4,R4,
	LHL	R0,BCT,R2,
	JE	INTNXT
::More DWL data is in .. so begin Starloading
SDWL02	HS	0
	SBT	R4,INTACT	:Remove timeout
	LR	R6,R4
	AR	R6,R6		:Form internal host channel index
	L	KD,DWLKDS,R6,R6
	LB	R1,STAFLG,KD
	NHI	R1,DWLXFL	:Is transmit bit (still) on?
	JN	INTNXT		:Yes .. must wait and come back later		

	LR	R7,R6			:Form dwobuf offset (66*dwl line index)
	SLLS	R7,5			:...= (33 X R6)
	AR	R7,R6
	LHL	PRD,DWLOPT,R6,,		:Get output ptr
	JN	SDWL01
	JAL	R8,CBCCT,,		:Wait for a few bytes
	SIS	R1,4
	JLE	INTNXT
	JAL	R9,INTGET
	CLHI	R1,32			:Wait for header
	JN	INTNXT
	JAL	R8,GCI,,		:Discard next 32
	LHI	R1,3232			:Set header
	STH	R1,DWOBUF,R7
SDWL01	JAL	R9,INTGET		:Get next byte
	STB	R1,DWOBUF+2,PRD,R7
	AIS	PRD,1
	NHI	PRD,3F
	STH	PRD,DWLOPT,R6,,
	JN	SDWL01
::Set flag in KD to inform transmitter of data ready
	LB	R0,STAFLG,KD		:Get current link status
	OHI	R0,DWLXFL		:with data ready to send
	STB	R0,STAFLG,KD
::Do accounting and finish up 
	IF	INTACC
	LHI	R0,42			:Load byte count - expected in R0
	LR	R3,R4			:Internal host port index in wrk reg
	JAL	R8,AARDIC		:Accumulate to INput count to DWload
	EI	:INTACC			
	SRLS	R6,1
	SBT	R6,INTACT		:MARK LINE AS ACTIVE FOR INTOUT
	LIS	R0,1
	AHM	R0,DWLCOU,,
	J	INTNXT			:AND GO TO NEXT LINE

STKDMT	HS	0			:Match Star link NEIGH and get KD
	L	KD,STHEAD,R5
STKDM1	CLH	R1,NDID,KD		:Match to node ID
	JEFS	STKDM2
	L	KD,NXTLNK,KD		:Get next link in chain
	JNBS	STKDM1
	JR	R8			:Error .. not found
STKDM2	J	4,R8			:Found match  ... got KD

	

	EI	:STRHUB



	IF	ISIS
SVCR3B	J	SVCE3B,,		:HANDLE SVC ERROR IN LINKER
	ELSE	:NOT ISIS
SVCR0E	J	SVCE0E,,		:HANDLE SVC ERROR IN LINKER
	EI	:ISIS
	EI	:SILINS

:	DWLSIR - HANDLE SIO RING DOWN-LINE LOAD
:	SIO RING DOWN-LINE LOAD. ECHO LINE NUMBER BACK TO HOST (LOADII),
:	MAKE CRYPTO REPORT, INITIALIZE SIO RING ZERO AND RING POINTERS.
	IF	SIORNG
DWLSIR	HS	0
	RBT	R4,INTOUT		:TURN OFF TIMEOUT FOR RING LOAD
	LH	R0,SIRFLG		:STATUS OF SIO RING INTERFACE
	JEFS	DWLSR0			:SIO RING INTERFACE DOWN
	CLHI	R0,STSRM0		:RING MISMATCH FOR RING PAIR 0?
	JN	INTZPH			:NO - CAN'T DO LOAD NOW
DWLSR0	XHI	R2,4
	JAL	R8,WCI			:ECHO LINE NUMBER BACK TO HOST
::This could be an error ie. LN = 2*line # and DWLNUM should contain LN.###evg
	STH	R1,DWLNUM,R6,		:SAVE 'LINE NUMBER'
	EXHR	R1,R1
	LR	R0,R6
	SRLS	R0,1			:INTERNAL HOST CHANNEL NUMBER,
	AHI	R0,INTZFL		:ABSOLUTE
	OR	R0,R1			:COMBINE WITH 'LINE NUMBER'
	JAL	R8,CRYPTO,,		:SEND CRYPTO TO XRAY
	HC	CRYE2C
	LCS	R0,1
	STH	R0,SIRDLD		:FLAG FOR DOWN-LINE LOAD IN PROGRESS
:	INSURE SIO RING CARD DEAD
	LHI	R0,SIRDIE		:DIE COMMAND
	JAL	R9,SIRCMD,,		:KILL SIO RING CARD
	NOP				:TIME-OUT RETURN
:	INITIALIZE SIO RING POINTERS
	LHI	R0,-SIRDLS		:RING SIZE FOR LOAD
	STH	R0,DWLKII,,
	STH	R0,DWLKIO,,
	STH	R0,DWLKOI,,
	STH	R0,DWLKOO,,
:	NOW SEND SIO RING DESCRIPTOR FOR LOAD RING
	LA	R1,(SIRDRD-SEG1+S1PH)/10 :QUAD-WORD DESCRIPTOR ADDRESS
	LHI	R0,SIORNG		:FOR RING 0
	JAL	R9,SIRCMD,,		:SEND COMMAND TO SIO CARD
	NOP				:IGNORE TIME-OUTS
	LHI	R0,SIRALV		:BRING SIO RING CARD TO LIFE
	JAL	R9,SIRCMD,,		:ISSUE SVC, HANDLE TIME-OUTS
	STH	R0,SIRFLG		:TIME-OUT RETURN

	LHI	R0,DWLSIW-SEG1		:ROUTINE TO WAIT FOR SIO LINE UP
	STH	R0,INTDSP,R6,
	J	INTNXT

::*********************************************************************
::
::	ENTRY POINT:	DWLSIW:
::	FUNCTION:	WAITING FOR INTERRUPT FROM SIO CARD INDICATING
::		LINE UP AND READY FOR LOAD...
::
::*********************************************************************

DWLSIW	HS	0
	LR	R6,R4			:PRESERVE R4 (CLOBBERED IN SIRCIN)
	JAL	R9,SIRCIN,,		:CHECK FOR INTERRUPTS FROM SIO CARD
	LR	R4,R6
	LH	R0,SIRFLG		:GET STATUS FLAG AND TEST FOR LINE UP
	JGE	INTNXT			:NOT YET
	LHI	R0,SIRALD		:LINE UP - SET STATUS
	STH	R0,SIRFLG		:TO ACTIVE LOAD STATE

	AR	R6,R6			:INTHST CHN*2
	LHI	R0,DWLSRG-SEG1
	STH	R0,INTDSP,R6,		:DISPATCH ADDRESS FOR ACTIVE LOAD

::*********************************************************************
::
::	ENTRY POINT:	DWLSRG:
::	FUNCTION:	HANDLE DATA PASSING BACK AND FORTH FOR SIO RING LOAD
::
::*********************************************************************

DWLSRG	HS	0
	JAL	R9,DLSIRM		:IS THERE ROOM FOR A COMPLETE RECORD?
	CLHI	PRC,$A66
	JL	DLSROT			:NO
	JAL	R8,CBCCT		:HAS ANY DATA FROM HOST TRICKLED IN?
	CLHI	R1,$A08			:AT LEAST 8 BYTES TO START
	JL	DLSROT			:NO
:	FIRST 2 BYTES MUST BE SYNC, SYNC (32, 32)
	JAL	R8,GCI
	CLHI	R1,32			:ARE WE IN SYNC WITH HOST?
	JN	DLSROT			:NO
	JAL	R8,GCI
	CLHI	R1,32
	JN	DLSROT			:MUST BE 2 SYNCS
	STB	R1,DWLKIB,PRD,		:STORE FIRST SYNC IN LOAD RING
	AIS	PRD,1
	JLFS	DLSR02
	SHI	PRD,SIRDLS		:NEGATIVE RING WRAP
DLSR02	LHI	PRC,$A65		:DLD RECORD SIZE - 1, MOVE THIS MANY
	JFS	DLSR12
DLSR10	JAL	R9,DWLSGC		:GET NEXT CHAR FROM HOST, ESCAPED
DLSR12	STB	R1,DWLKIB,PRD,		:AND PUT IT AWAY
	AIS	PRD,1
	JLFS	DLSR14
	SHI	PRD,SIRDLS		:NEGATIVE RING WRAP
DLSR14	SIS	PRC,1
	JGBS	DLSR10			:MORE TO DO THIS BLOCK
	STH	PRD,DWLKII,,		:STORE LEAD POINTER

:	GET ECHOED DATA FROM KERNEL BOOT AND PASS BACK TO HOST
DLSROT	HS	0
	JAL	R9,DLSORM
	LR	PRC,PRC			:ANY DATA IN OUTPUT RING?
	JLE	INTNXT			:NO, MAYBE NEXT TIME
	XHI	R2,4			:FLIP BUFFER INDEX
DLSR50	LB	R1,DWLKOB,PRD,		:GET BYTE FROM RING
	CLHI	R1,7			:NEED ESCAPING?
	JGFS	DLSR52			:NO
	EXBR	R1,R1
	JAL	R8,WCI			:PUT ESCAPE IN BUFFER
	EXBR	R1,R1
DLSR52	JAL	R8,WCI			:PUT DATA BYTE IN BUFFER
	AIS	PRD,1			:ADVANCE RING INDEX
	JLFS	DLSR54
	SHI	PRD,SIRDLS		:NEGATIVE RING WRAP
DLSR54	STH	PRD,DWLKOO,,		:SLOWS LOOP DOWN, BUT CATCH SIO POLL
	SIS	PRC,1
	JG	DLSR50			:MORE TO DO
	J	INTNXT
	EI	:SIORNG

::*********************************************************************
::
::	ENTRY POINT:	PLIMSG:
::	FUNCTION:	PLI MESSAGE
::	RECEIVES A SLOT NUMBER, TYPE BYTE, BYTE COUNT, DATA, AND CHECKSUM
::	FROM A HOST MACHINE. PLICNT SERVES AS A STATE COUNTER AS WELL AS BYTE 
::	COUNT
::
::*********************************************************************

PLIMSG	HS	0
	SBT	R4,INTACT		:NOTE WE ARE ACTIVE FOR TIMEOUT
	LH	R3,PLICNT		:GET PRESENT STATUS FROM PLICNT
	JGE	PLIMS0			:=>0 MEANS TAKING DATA
	CLHI	R3,0FFFC		:-4 MEANS TAKING BYTE COUNT
	JE	PLIMS2
	CLHI	R3,0FFFE
	JE	PLIMS1			:-2 MEANS TAKING TYPE BYTE 
	LIS	R0,0			:FALLTHROUGH MEANS TAKING SLOT#
	STH	R0,PLIXOR		:INITIALIZE CHECKSUM AND
	STH	R0,PLINDX		:CURRENT BYTES RECEIVED COUNT
	JAL	R9,INTGET		:GET SLOT NUMBER
	CLHI	R1,3F			:MAX SLOT NUMBER = 63
	IF	INTACC		
	JG	PLAZ19			:Accounting and zap
	ELSE
	JG	INTZPH			:RIDICULOUS SLOT NUMBER, ZAP!
	EI	:INTACC			:###EV
	STH	R1,PLISLT		:OK, STORE
	LCS	R0,2
	STH	R0,PLICNT		:SET PLICNT TO -2
PLIMS1	JAL	R9,INTGET		:GET THE TYPE BYTE
	LR	R1,R1			:VERIFY THAT ITS 0
	IF	INTACC		
	JN	PLAZ19			:Accounting and zap
	ELSE
	JN	INTZPH			:NO, ZAP THE CRQ
	EI	:INTACC			:###EV
	LCS	R0,4
	STH	R0,PLICNT		:SET PLICNT TO -4 
PLIMS2	JAL	R9,INTGET		:GET THE BYTE COUNT
	STH	R1,PLICNT		:MESSAGE IS OK. STORE COUNT
PLIMS0	JAL	R9,INTGET		:GET A CHARACTER
	LHL	R3,PLINDX
	CLH	R3,PLICNT		:GOT ALL THE DATA?
	JEFS	PLIMS5			:YES, DEAL WITH CHECKSUM
	STB	R1,PLIDAT,R3		:STORE DATA
	AIS	R3,1			:INCREMENT DATA RECEIVED COUNT
	STH	R3,PLINDX
	LHL	R3,PLIXOR		:PERFORM CHECKSUM
	XR	R3,R1
	STH	R3,PLIXOR
	J	PLIMS0			:AND LOOP BACK
PLIMS5	CLH	R1,PLIXOR		:DO CHECKSUMS MATCH?
	IF	INTACC		
	JN	PLAZ19			:Accounting and zap
	ELSE
	JN	INTZPH			:NO, ZAP THE CRQ
	EI	:INTACC			:###EV
	XHI	R2,4			:YES, SO ECHO CHECKSUM, ESCAPED
	JAL	R9,WCIE,,
	LHL	R0,PLICNT		:MOVE PLICNT TO PLICN2
	JEFS	PLIMS6			:0-LENGTH MESSAGE--reset from IULMSG
	TS	PLIXOR			:SET PLIXOR TO FFFF TO TURN MESSAGE ON
	STB	R0,PLICN2		:PERMIT USE OF 'BUFCAN' ROUTINE
PLIMS6	HS	0

	IF	SOLOCS			:###jhl
	GL	ULMSIZ,SCULMS,ULMEND,IULMND	:byte size of ULMSG area, and
:	pseudonym for ULMSG, ptr to last HW of (I)ULMSG
:	PLIDAT is 256 bytes, 3.01 ULMSG is 128 bytes, 3.02 ULMSG is 256 bytes.
	LR	R4,R0			:test byte count
	JNFS	PLIM20			:zero length is reset to IULMSG
	LI	R3,IULMND-2		:source is IULMSG
	JFS	PLIM30
:	otherwise copy new msg into ULMSG area.  Never touch last HW (00).
PLIM20	CLHI	R4,ULMSIZ-1		:is byte count < msg area size?
	JGEFS	PLIM40			:branch if it is--COPY skips last HW
	LIS	R3,0			:be sure msg ends with a zero byte
	STB	R3,PLIDAT,R4		:store null-char terminator
PLIM40	LI	R3,PLIDAT+(ULMSIZ-4)	:source end HW--ensure last HW is 00
PLIM30	LI	R4,ULMEND-2		:destination end HW
	LHI	R1,(ULMSIZ/2-2)*10	:(# HW's -1) * 10
	COPY	R3,R1			:copy new msg into PLI msg place
	EI	:SOLOCS			:###jhl

	IF 	ISIS
	AIS	R0,6			:R0 = LENGTH OF DISPATCHER MESSAGE
	JAL	R8,DIROOM,,		:DISMISS UNTIL THE SPACE IS AVAILABLE
	LHL	R15,DRIF,,		:CURRENT FILL POINTER
	LHL	R3,PLISLT		:SLOT NUMBER
	SLLS	R3,2			:WE WANT 4*SLOT#
	AHI	R3,IN1DWN^8		:R3=<00><00><0E><4*SLOT#>
	ST	R3,DIRNG,R15,,		:FIRST FOUR BYTES OF MESSAGE
	AIS	R15,4
	NHI	R15,DRSZ-1
	LHL	R3,PLICNT
	STH	R3,DIRNG,R15,,		:STORE TYPE AND COUNT
	AIS	R15,2			:INCREMENT FILL INDEX
	NHI	R15,DRSZ-1
	LIS	R2,0			:INITIALIZE PLIDAT INDEX
PLIMS8	SIS	R3,1			:ZERO MESSAGE BYTES LEFT?
	JLFS	PLIMS7			:YES,EXIT
	LB	R1,PLIDAT,R2		:GET NEXT MESSAGE BYTE
	STB	R1,DIRNG,R15,,		:STORE IT INTO THE DISPATCHER RING
	AIS	R15,1			:INCREMENT FILL INDEX
	NHI	R15,DRSZ-1		:AND REDUCE MOD DRSZ
	AIS	R2,1			:INCREMENT PLIDAT INDEX
	JBS	PLIMS8			:AND REPEAT
PLIMS7	AIS	R15,3
	NHI	R15,DRSZ-4		:ROUND FILL POINTER UP TO NEXT WORD
	STH	R15,DRIF,,
	EI	:ISIS
	IF	INTACC			
	LHL	R0,PLICNT		:Count of charaters input
	LR	R3,R4			:Get port index in wrk register
	JAL	R8,AARDIC		:Accumulate characters
	EI	:INTACC			:###EV
	J	INTNXT			:GO SERVICE NEXT INTHST CHANNEL

	IF	INTACC		
PLAZ19	HS	0			:Here for bad dwl function accounting
	LR	R3,R4			:Get DWL channel index
	LI	R0,AALR19		:Logout reason 19 bad DWL function
	JAL	R8,AARLO		:Perform final accounting
	J	INTZPH			:Now Zap the circuit
	EI	:INTACC			:###ev

::*********************************************************************
::
::	ENTRY POINT:	REMXRY:
::	FUNCTION:	INTERFACE BETWEEN XRAY AND THE NETWORK.
::	SCANS THE DATA STREAM FOR 'Z' (LOGOUT) OR ^C OR & (BREAK, RESTART XRAY)
::	& RESTARTS XRAY BECAUSE ^C HAS A SPECIAL MEANING FOR NAD IN PDP MODE
::	****	NOTE	****
::	R4 IS NOT EXPLICITLY USED BUT CONTAINS THE INTERNAL HOST PORT INDEX
::	AND IS NEEDED SHOULD THE BRANCH TO INTZPH OCCUR.
::
::*********************************************************************

REMXRY	HS	0
	JAL	R8,CBCCT,,		:GET CHARACTER COUNT 
	LR	R5,R1
	LB	XN,XNINT,R4,
	LHL	XD,XDXN,XN,XN		:GET USER BLOCK POINTER
	LHL	R6,XRYPTF,XD
	IF	INTACC			
	GL	AARDIC
	LIS	R14,0			:Init character counter
	EI	:INTACC			:###ev	
REMXR1	LR	R5,R5
	JE	REMXR2			:NO MORE DATA
	AIS	R6,1			:MAKE SURE WE HAVEN'T WRAPPED AROUND
	NHI	R6,XBFSZE-1		:MOD BUFFER SIZE
	CLH	R6,XRYPTE,XD,		:TO EMPTY POINTER
	JE	REMX20			:NO ROOM
	SIS	R6,1			:OK SO RESTORE FILL POINTER AND PROCEDE
	NHI	R6,XBFSZE-1		:MOD BUFFERSIZE
	JAL	R9,GCXRAY		:GET NEXT CHARACTER
	STB	R1,XRYBFI,R6,XD		:AND MOVE TO XRAY BUFFER
	NHI	R1,7F			:STRIP MSB
	CLHI	R1,1A			:UNCONDITIONALLY END SESSION IF ^Z
	IF	INTACC			
	JE	AARXLG			:Perform logout accounting
	JFS	REMXJ1			:REMOVE AFTER TESTING
	EI	:INTACC			:###EV	
	JE	INTZPH			:GO ZAP AND DO CLOSING BOOK-KEEPING
REMXJ1	CLHI	R1,03			:CHECK FOR ^C
	JEFS	REMXZ1			:YES
	CLHI	R1,26			:OR &
	JN	REMXR9			:NO

REMXZ1	HS	0
	IF	INTACC			
	LR	R0,R14			:Expect counts in R0
	LR	R3,R4			:Get port index in work reg
	JAL	R8,AARDIC		:Accumulate characters so far
	EI	:INTACC			:###EV
	XHI	R2,4
	JAL	R9,GOBBLN		:SEND GOBBLER TOWARDS USER

REMXRZ	HS	0			:ENTRY POINT TO RESTART XRAY
	LHL	R0,XRYPTF,XD		:FLUSH INPUT RING
	STH	R0,XRYPTE,XD
	LHI	R1,01F-PXRAY
	SBT	R1,SQUEUE		:SCHEDULE XRAY OFF EXEC QUEUE
	LHL	XN,XUSLTN,XD		:THIS USER'S XRAY SLOT NO.
	SBT	XN,XQUEM,,		:SET XRAY USER QUEUE
	LHL	XD,XDXN,XN,XN		:RESTORE XRAY USER BLOCK POINTER
	LI	R1,XRAYIS		:INITIAL ADDRESS FOR XRAY USER
	GL	XRAYIS
	ST	R1,XRYADR,XD,
	J	INTNXT

	IF	INTACC			
AARXLG	HS	0			:Perform logout accounting
	LR	R3,R4			:Get internal port index in wrk reg
	LIS	R0,AALR03		:Pass logout reason to accting 
	JAL	R8,AARLO		:Call accounting
	GL	AARLO
	J	INTZPH			:Zap & do closing cleanup
	EI	:INTACC			:###EV

REMXR9	AIS	R6,1			:INCREMENT FILL INDEX
	NHI	R6,XBFSZE-1		:MOD BUFFER SIZE
	SIS	R5,1			:DECREMENT BYTE COUNT INDEX
	IF	INTACC			
	AIS	R14,1			:And add to character count
	EI	:INTACC			:###EV
	J	REMXR1			:AND LOOP BACK

REMX20	SIS	R6,1			:RAN OUT OF ROOM IN INPUT RING,SO
	NHI	R6,XBFSZE-1		:RESTORE FILL POINTER
REMXR2	STH	R6,XRYPTF,XD		:STORE AWAY FILL POINTER
	IF	INTACC			
	LR	R0,R14			:Expects count in R0
	LR	R3,R4			:Get port index in work reg
	JAL	R8,AARDIC		:Accumulate character count
	EI	:INTACC			:###EV
	LHI	R0,01F-PXRAY		:SCHEDULE XRAY OFF EXEC LOOP
	SBT	R0,SQUEUE
	LHL	XN,XUSLTN,XD		:THIS USER'S XRAY SLOT NO.
	SBT	XN,XQUEM,,		:SCHEDULE IN XRAY USER'S QUEUE
	LHL	XD,XDXN,XN,XN		:RESTORE POINTER TO XRAY USER BLOCK
	J	INTNXT			:AND RETURN TO MAINLINE

::*********************************************************************
::
::	ENTRY POINT:	IIXXRY:
::	FUNCTION:	INTERFACE BETWEEN XRAY AND TMCS
::	****	NOTE	****
::	R4 CONTAINS THE INTERNAL HOST PORT INDEX (channel #)
::
::*********************************************************************

	IF	XRYTMC			:###wjl
IIXXRY	JAL	R8,CBCCT,,		:GET CHARACTER COUNT 
	LR	R5,R1
	LB	XN,XNINT,R4,
	LHL	XD,XDXN,XN,XN		:GET USER BLOCK POINTER
	LHL	R6,XRYPTF,XD
	IF	INTACC			
	LIS	R14,0			:Initialize character counter
	EI	:INTACC			:###EV
IIXXR1	LR	R5,R5
	JE	IIXXR2			:NO MORE DATA

	AIS	R6,1			:MAKE SURE WE HAVEN'T WRAPPED AROUND
	NHI	R6,XBFSZE-1		:MOD BUFFER SIZE
	CLH	R6,XRYPTE,XD,		:TO EMPTY POINTER
	JE	IIXXR3			:NO ROOM
	SIS	R6,1			:OK, RESTORE FILL POINTER AND PROCEDE
	NHI	R6,XBFSZE-1		:MOD BUFFERSIZE
	JAL	R9,GCIXRY		:GET NEXT CHAR (IIXXR2 if empty)
	STB	R1,XRYBFI,R6,XD		:AND MOVE TO XRAY BUFFER
	AIS	R6,1			:INCREMENT FILL INDEX
	NHI	R6,XBFSZE-1		:MOD BUFFER SIZE
	SIS	R5,1			:DECREMENT BYTE COUNT INDEX
	IF	INTACC			
	AIS	R14,1			:Add to character count
	EI	:INTACC			:###EV
	J	IIXXR1			:AND LOOP BACK

IIXXR3	SIS	R6,1			:RAN OUT OF ROOM IN INPUT RING,SO
	NHI	R6,XBFSZE-1		:RESTORE FILL POINTER

IIXXR2	STH	R6,XRYPTF,XD		:STORE AWAY FILL POINTER
	IF	INTACC			
	LR 	R0,R14			:Expects counts in R0
	LR	R3,R4			:Get port index in work register
	JAL	R8,AARDIC		:Accumulate character count
	EI	:INTACC			:###EV
	LHI	R0,01F-PXRAY		:SCHEDULE XRAY OFF EXEC LOOP
	SBT	R0,SQUEUE
	LHL	XN,XUSLTN,XD		:THIS USER'S XRAY SLOT NO.
	SBT	XN,XQUEM,,		:SCHEDULE IN XRAY USER'S QUEUE
	LHL	XD,XDXN,XN,XN		:RESTORE POINTER TO XRAY USER BLOCK
	J	INTNXT			:AND RETURN TO MAINLINE
	EI	:XRYTMC			:###wjl

::*********************************************************************
::
::	ENTRY POINT:	DLYREC:
::	FUNCTION:	RECEIVING END FOR DELAY MEASUREMENT.
::		RECEIVES DATA AS HW OF FASTC, COMPUTES DELAY, STORES INTO
::		DLYTBL, AND DOES MINOR SIGNAL PROCESSING TRAVEL TIME IS STORED
::		IN UNITS OF 8/600 SEC, OR 13.333 MS
::		R2 = BUFFER NUMBER
::		R4 = INTERNAL HOST CHANNEL INDEX
::
::*********************************************************************

DLYREC	HS	0
	LHL	R7,FASTC+2,,		:GET CURRENT TIME
	LR	R6,R4			:SAVE INDEX BEFORE GHWI CLOBBERS IT
DLYRE1	LR	R5,R7			:COPY FASTC OVER
	JAL	R8,CBCCT,,		:GET CHARACTER COUNT IN BUFFER
	SIS	R1,2			:WANT HW OF FASTC (NEVER ESCAPED)
	JL	INTNXT			:NO, NOT ENOUGH DATA. GO AWAY
	JAL	R9,GHWI,,		:GET THE HW 
	CHI	R1,FILLCH		:IS IT A FILL CHARACTER?
	JEBS	DLYRE1			:YES,GET ANOTHER
	SR	R5,R1			:GOT FASTC, SUBTRACT OUT TRAVEL TIME 
	JGFS	DLYRE2			:NO WRAP-AROUND
	AI	R5,10000		:CORRECT FOR WRAP-AROUND
DLYRE2	LHL	R1,CHNDLY,R6,R6		:CHAN NUMBER TO USER ADDRESS LINK TBL
	LHL	R3,DLYPTF,R1		:FILL POINTER FOR THIS TEST
	STH	R5,DLYTBL,R1,R3		:AND STORE INTO DATA TABLE
	AIS	R3,2			:INCREMENT DLYTBL FILL PTR
	NHI	R3,DLYTSZ-1		:AND REDUCE
	STH	R3,DLYPTF,R1
	LHL	R3,DLYAV1,R1		:GET RUNNING AVERAGE
	JEFS	DLYREZ			:0 SO DON'T FILTER
	SRLS	R5,4			:1/16 OF SAMPLE
	SRLS	R3,4			:1/16 OF RUNNING AVERAGE
	SR	R5,R3			:(NEW-OLD)/16
DLYREZ	AHM	R5,DLYAV1,R1		:UPDATE RUNNING AVERAGE (OLD)
	LHL	R5,DLYAV1,R1		:GET R/A#1
	LHL	R3,DLYAV2,R1		:GET R/A#2
	JEFS	DLYREY			:IF 0 DON'T FILTER
	SRLS	R5,3			:1/8 OF R/A#1
	SRLS	R3,3			:1/8 OF R/A#2
	SR	R5,R3			:1/8*(R/A#1 - R/A#2)
DLYREY	AHM	R5,DLYAV2,R1		:UPDATE R/A#2
	J	DLYRE1			:AND RETURN

::*********************************************************************
::
::	ENTRY POINT:	DLYSFL:
::	FUNCTION:
::		THE FIRST two DATA BYTEs RECEIVED ON THE DATA SOURCE
::		CHANNEL IS CONSIDERED TO BE THE HW FILL COUNT FOR THAT
::		CHANNEL. ALL SUBSEQUENT DATA RECEIVED IS CONSIDERED TO
::		BE AN ERROR.
::
::*********************************************************************

DLYSFL	HS	0
	JAL	R9,INTGET		:GET THE HW FILL COUNT
	STB	R1,CHNFIL+1,R4,R4	:first is low order byte	###JHL
	JAL	R9,INTGET		:				###JHL
	STB	R1,CHNFIL,R4,R4		:next is the high order byte	###JHL
	LHI	R0,DLYERR-SEG1		:ACCEPT NO MORE DATA HERE
	STH	R0,INTDSP,R4,R4
	J	INTNXT

::*********************************************************************
::
::	ENTRY POINT:	DLYERR:
::	FUNCTION:	BIT BUCKET FOR UNWANTED DATA
::
::*********************************************************************

DLYERR	HS	0
	J	INTNXT			:BIT BUCKET FOR UNWANTED DATA

::*********************************************************************
::
::	ENTRY POINT:	LOOPBK:
::	FUNCTION:	CHASES ITS TAIL...
::
::*********************************************************************

LOOPBK	HS	0
	LHL	R10,INTLPF		:GET LOOPBACK BIT ARRAY
	JFFOH	R10,LOOPB1		:FIND INT HOST CHANNEL THAT IS SENDING
	J	LOOPNX			:NOT THERE, PROBABLY ZAPPED
LOOPB1	JAL	R8,CBCCT,,		:GET BYTE COUNT IN OUR INPUT BUFFER
	LR	R10,R1			:AND SAVE IT
	LHL	R11,INTTAB,R11,R11	:GET INPUT BUFFER FOR OTHER SIDE
	NHI	R11,-4			:STRIP SPEED BITS
	LR	R12,R2			:SAVE BUFFER #
LOOPB2	LR	R2,R12
	JAL	R8,GCI,,		:READ ONE CHARACTER FROM OUR IN-BUFFER
	LR	R2,R11
	JAL	R8,WCI,,		:AND WRITE INTO OTHER CHANL'S BUF##AL
	SIS	R10,1			:MORE DATA?
	JGBS	LOOPB2			:YES, GET IT
	J	INTNXT

LOOPNX	JAL	R8,CBCLR,,		:CLEAR ALL DATA THAT HAS NOWHERE TO GO
	J	INTNXT

	SUBTTL	INTHST (Utilities)

::*********************************************************************
::
::	SUBROUTINE:	INTGET:
::	FUNCTION:	GET A BYTE
::	CALLING SEQ:	JAL	R9,INTGET
::
::*********************************************************************

INTGET	HS	0
	LHL	R1,BCT,R2,
	JE	INTNXT			:THIS BUFFER IS EMPTY
	JAL	R8,GCI,,
	LR	R1,R1
	JNR	R9			:UNESCAPED, RETURN
	JAL	R8,GCI,,		:ESCAPED, GET NEXT CHARACTER
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	INTZAP:
::	FUNCTION:	INTZAP ZAPS THE FIRST HALF OF A CRQ AND DOES
::		THE CLEAN-UP OF THE INTERNAL HOST STATUS FLAGS AND ARRAYS
::	LINK:		R10, R11 (R10 PRESERVED IN R11 FOR RETURN LINK)
::	INPUT:		R2 = BUFFER NO.
::			R4 = INTERNAL HOST CHANNEL INDEX
::	DESTROYED:	R0, R1, R3, R8, R9
::
::*********************************************************************

INTZAP	HS	0
	XHI	R2,4			:WE EXPECT THE INBOUND BUFFER NO.
	JAL	R9,ZAPHRD		:SO FLIP  AND ZAP
INTZA1	LIS	R0,0			:ALTERNATE ENTRY POINT FOR INTZAK
	STH	R0,INTDSP,R4,R4		:CLEAR DISPATCH ADDRESS
	RBT	R4,INTUSE		:CLEAR LOGIN OVER BIT
	RBT	R4,INTWRN		:CLEAR TIMEOUT WARNING BIT
	RBT	R4,INTOUT		:CLEAR TIMEOUT ENABLE BIT
					:CLEAR FLAGS FOR SPECIFIC FUNCTIONS
	RBT	R4,INTDSF		:CLEAR DELAY MEASUREMENT SOURCE CHN BIT
	RBT	R4,INTLPF		:CLEAR LOOPBACK CHANNEL BIT
	JNFS	INTZ11			:LOOPBACK FUNCTION, SPECIAL CLEANUP
	RBT	R4,INTXRF		:TEST AND CLEAR REMOTE XRAY BIT
	JEFS	INTZA8
	JAL	R12,REMZAP		:DO CLOSING BOOK KEEPING FOR REM XRAY
	JR	R10

INTZA8	RBT	R4,INTDRF		:CLEAR AND TEST DELAY RECEIVER CHN BIT
	JE	INTZA6
INTZ11	LHL	R1,CHNDLY,R4,R4		:CHN INDEX TO DELAY USER OFFSET TABLE
	LCS	R0,1
	STH	R0,DLSTAT,R1		:NOTE THE CHAN ZAPPED IN STATUS FIELD
					:###JHL
	LHL	R3,INTNDX,R4,R4		:READ INDEX FROM ARRAY BY INTHST CHAN#
	AR	R3,R3			:GET HW INDEX FROM BYTE INDEX
	LCS	R0,1			:STORE -1 TO SHOW USED--IDLE INFO ONLY
	ST	R0,DB0USE,R3,R3		:ERASE XRY USRBLK ENTRY FOR INDEX
	STH	R0,INTNDX,R4,R4		:ERASE INDEX ARRAY ENTRY FOR CHAN

INTZA6	RBT	R4,INTDWF		:TEST AND CLEAR DWL BIT
	JER	R10			:DONE
	LR	R11,R10			:Save return register
	LH	LN,DWLNUM,R4,R4		:Get line index (2*line #)
	JL	INTZ15

	IF	STRHUB			:Starhub logic		###ev
	LB	R0,LTYP,LN,		:For Starlines only
	JE	INTZA5			:Non Starline - regular logic

:Starhub downline load circuit zap proceeds here
	LR	R6,R4
	AR	R6,R6			:Get FW index for int. host chan
	L	KD,DWLKDS,R6,R6		:Assure correct link descriptor
	LB	R0,STAFLG,KD
	NHI	R0,0FFCD		:Reset all DWL status
	STB	R0,STAFLG,KD	
	L	R1,SKDPTR,LN,LN		:Now -  if subsequent link
	LHL	R1,NASTLK,R1		:we do not need rststr
	JN	INTZ66			:###EV
	STH	R4,INTCHN,,		:save R4 from being clobbered	###wjl
	JAL	R9,RSTSTR,,		:PUT LINE BACK IN RESET MODE
	LHL	R4,INTCHN,,		:recover INTHST channel number	###WL	
INTZ66	RBT	LN,DWLDSP,,		:RESET DWL DISPATCH ARRAY BIT
	LIS	R0,0			:REASON FOR ZAP = ZAPPER RECEIVED
	SRLS	LN,1			:Get real line # for Crypto mesg.
	J	INTZA4
	EI	:STRHUB
	J	INTZA5			:For non-Starhub machines
INTZ15	XHI	LN,-1			:INVALID LINE NUMBER, COMLEMENT
	LR	R0,LN			:MOVE LINE # AND REASON TO R0
	LBR	LN,R0			:ISOLATE LINE NUMBER (LOWER BYTE OF LN)
	SRLS	R0,8			:MOVE REASON FOR REJECT TO LOWER BYTE
	J	INTZA4			:MAKE CRYPTO REPORT

INTZA5	HS	0
	IF	SIORNG
	CLHI	LN,SIRILN		:SIO RING 'LINE NUMBER'?
	JE	INTZA4			:YES - NOT VALID NODE LINE	###OAS
	EI	:SIORNG
	RBT	LN,DWLDSP,,		:RESET DWL DISPATCH ARRAY BIT
	STH	R4,INTCHN,,		:save R4 from being clobbered	###wjl
	JAL	R9,RSTSTR,,		:PUT LINE BACK IN RESET MODE
	LHL	R4,INTCHN,,		:recover INTHST channel number	###wjl
	LIS	R0,0			:REASON FOR ZAP = ZAPPER RECEIVED
	SRLS	LN,1			:GET TRUE LINE NUMBER FOR XRAY	###OAS
INTZA4	STH	LN,CRYSBF,,		:AND STORE AWAY INTO HW3
	JAL	R8,CRYPTO,,

	HC	CRYE2D			:DWL LINE ZAP MESSAGE
	LCS	R0,1
	STH	R0,DWLNUM,R4,R4		:REINITIALIZE DWLNUM TO -1

	IF	1-SIORNG
	JR	R11
	ELSE	:SIORNG
	CLHI	LN,SIRILN		:IS THIS SIO RING LOAD BEING ZAPPED?
	JNR	R11			:NO
	LIS	R0,0
	STH	R0,SIRDLD		:NO LONGER LOADING
	STH	R0,SIRFLG		:SIO RING INTERFACE DOWN
	JAL	R10,IZKNRG,,		:INITIALIZE KERNEL RINGS
	JAL	R10,IZSUP		:INITIALIZE SUP RINGS
	JAL	R10,IZSIRG,,		:INITIALIZE SIO RING CARD
	JR	R11			:RETURN
	EI	:1-SIORNG

::*********************************************************************
::
::	SUBROUTINE:	REMZAP:
::	FUNCTION:	DO CLOSING BOOK KEEPING FOR REMOTE XRAY
::	CALLING SEQ:	JAL	R12,REMZAP
::
::*********************************************************************

REMZAP	HS	0
	LIS	R1,0
	JAL	R11,XWRITE,,		:GET SEG1 WRITE ACCESS
	LB	XN,XNINT,R4,		:SET UP XD
	STB	R1,XNINT,R4,
	LHL	XD,XDXN,XN,XN
REMZAI                                  :alt entry for ISIS DDT quitters
	IF	1-ISIS
	IF	ZITEL
:	When an XRAY user logs out see if he has any tracing going
:	on, and if he does, clear the condition so he doesn't hang up
:	the process
	CLH	XD,TRCUSE,,		:see if user has TRACE interrupt set
	JN	RZNOTR			:no cleanup necessary
	ST	R10,XRSAVE+0C,XD	:save R10 for INTZAP
	LIS	R5,0
	STH	R5,TRCUSE,,		:zero out the INUSE halfword
	LIS	R10,0
	LIS	R11,0
	SVC	0F,SV.TCC		:zero out trace ctrl word, stop trace
	L	R10,XRSAVE+0C,XD	:restore link reg R10
RZNOTR	HS	0
	EI	:ZITEL
	IF	(XRSZLV-2)		:XRAY SIZE SAVING LEVEL ##AL
	LIS	R2,0			:MAKE SURE ANY TRAPS BELONGING
	LIS	R0,0			:TO THIS USER ARE CLEARED
REMZA1	STH	R0,VALUE1+2,R2,XD	:TRAPS 0-3
	AIS	R0,1
	AIS	R2,4
	CLHI	R2,10			:4 ARGUMENTS?
	JLBS	REMZA1			:NO
	EI	:(XRSZLV-2)		:XRAY SIZE SAVING LEVEL ##AL
	ELSE	:ISIS
	IF	(XRSZLV-2)		:XRAY SIZE SAVING LEVEL ##AL
        IF      SDW.TR          :swedels isis traps
        ELSE                    :swedel has REMTR0 do all of dis
	L	R0,TRPSAV,,		:IS TRAP SET?
	JE	REMZA3			:NO
	C	XD,TRPXD,,		:DOES THIS GUY OWN IT?
	JN	REMZA3			:NO
        EI   :SDW.TR
	EI	:(XRSZLV-2)		:XRAY SIZE SAVING LEVEL ##AL
	EI	:1-ISIS
	IF	(XRSZLV-2)		:XRAY SIZE SAVING LEVEL ##AL
	JAL	R9,REMTR0,,		:GO RESET ANY TRAPS
	GL	REMTR0
	EI	:(XRSZLV-2)		:XRAY SIZE SAVING LEVEL ##AL
REMZA3	LHI	R11,TINTCH-2		:SET HW OFFSET TO LOOP DB INDICES
:	DB0USE STARTS A WORD-ARRAY, DLYCHN IS A HW ARRAY, EACH BY DB-INDEX
REMZA4	C	XD,DB0USE,R11,R11	:CLEAR DELAY CIRCUIT IF NECESSARY
	JN	REMZA5			:NOT THIS GUY
	LHL	R6,DLYCHN,R11,		:INT HOST CHN # FOR DB-R11
	RBT	R6,INTDRF		:MAKE SURE IT'S BEING USED
	JN	REMZA6			:YES				###JHL
	RBT	R6,INTLPF		:IF NOT, IS IT LOOPBACK CH?
	JE	REMZA5			:JUMP IF CHANNEL NOT IN USE
REMZA6	LIS	R0,0			:CH IN USE--ZAP IT		###JHL
	STH	R0,INTDSP,R6,R6		:CLEAR DISPATCH ADDRESS
	RBT	R6,INTUSE		:CLEAR LOGIN OVER BIT
	RBT	R6,INTWRN		:T/O WARNING
	RBT	R6,INTOUT		:T/O
	AHI	R6,INTZFL		:GET ABS CHN NO.
	LHL	R2,IOTAB,R6,R6		:OUT BUFFER
	JE	REMZA5			:ALREADY ZAPPED
	NHI	R2,-4			:STRIP SPEED BITS
	JAL	R9,ZAPHRD		:ZAP DB0 CIRCUIT
	LHL	R6,DLYCHN,R11,		:INT HOST CHN # FOR DB-R11
	LCS	R0,1
	ST	R0,DB0USE,R11,R11	:CLEAR XRY USRBLK PTR BY DB-INDEX
	STH	R0,INTNDX,R6,R6		:CLEAR DB-INDEX BY INTHST CHAN #
	LHL	R6,CHNDLY,R6,R6		:DATA AREA POINTER
	LCS	R0,2			:INDICATE ZAPPED BY USER
	STH	R0,DLSTAT,R6		:LOGOFF
REMZA5	SIS	R11,2			:STEP BACK TO NEXT DB-INDEX
	JGE	REMZA4			:LOOP THROUGH ALL DB-INDICES
	
REMZA2	JAL	R11,XCLEAN,,		:DO CLOSING CLEANUP
	GL	XCLEAN
	STH	R0,XPOWER,XD
	LHL	XN,XUSLTN,XD		:GET USER SLOT #
	RBT	XN,XUSIUA,,		:RESET SLOT IN USE BIT
	RBT	XN,XQUEM,,		:CLEAR HIM FROM
	RBT	XN,XQUEC,,		:XRAY QUEUES
	JAL	R11,XPRTKT,,		:RESTORE SEG1 WRITE PROTECT
	JR	R12

::*********************************************************************
::
::	SUBROUTINE:	GCXRAY:
::	FUNCTION:	GET NEXT CHARACTER FROM REMOTE XRAY CIRCUIT.
::		STRIP ESCAPES, AND TOSS NETWORK CONTROL CHARACTERS.
::		BRANCH TO REMXR2 IF BUFFER EMPTY.
::	CALLING SEQ:	JAL	R9,GCXRAY
::	OUTPUT:		R1 = CHARACTER
::			R5 = DECREMENTED AS NEEDED
::
::*********************************************************************

GCXRAY	HS	0
	LHL	R8,BCT,R2,		:EXTRA CARE, NO GCI CRASH
	JE	REMXR2			:BUFFER EMPTY...
	JAL	R8,GCI,,		:GET NEXT CHARACTER FROM BUFFER
	CLHI	R1,8			:NORMAL CHARACTER?
	JGER	R9			:YES - RETURN
	LR	R1,R1			:ESCAPED CHARACTER?
	JEFS	GCXR00			:YES - GET NEXT
	SIS	R1,1			:NETWORK CHARACTER PAIR?
	JEFS	GCXR10			:YES - ADJUST COUNT IN R5 AND TOSS
	SIS	R5,1			:NO - SOME BALL. IGNORE IT TOO...
	JN	GCXRAY			:MORE TO DO
	J	REMXR2			:NO MORE - UPDATE POINTER
GCXR00	SIS	R5,1			:DEC COUNT SINCE '00' CHAR. TOSSED
	JE	REMXR2			:SHOULDN'T HAPPEN, DON'T TAKE GCI CRASH
	JAL	R8,GCI,,		:GET ESCAPED CHARACTER AND
	JR	R9			:RETURN
GCXR10	LH	R8,BCT,R2,
	JE	REMXR2			:NEXT CHAR. NOT PRESENT...
	JAL	R8,GCI,,		:TOSS IT
	SIS	R5,2			:ADJUST COUNT FOR CHARACTER PAIR
	JG	GCXRAY			:MORE TO DO
	J	REMXR2			:DONE

::*********************************************************************
::
::	SUBROUTINE:	GCIXRY:
::	FUNCTION:	GET NEXT CHARACTER FROM TMCS XRAY CIRCUIT.
::		STRIP ESCAPES, AND INTERPRET NETWORK CONTROL CHARACTERS.
::		BRANCH TO IIXXR2 IF BUFFER EMPTY.
::	CALLING SEQ:	JAL	R9,GCIXRY
::	OUTPUT:		R1 = CHARACTER
::			R5 = DECREMENTED AS NEEDED
::
::*********************************************************************

	IF	XRYTMC			:###wjl
GCIXRY	HS	0
	LHL	R8,BCT,R2,		:EXTRA CARE, NO GCI CRASH
	JE	IIXXR2			:BUFFER EMPTY...
	JAL	R8,GCI,,		:GET NEXT CHARACTER FROM BUFFER
	CLHI	R1,8			:NORMAL CHARACTER?
	JGER	R9			:YES - RETURN
	LR	R1,R1			:ESCAPED CHARACTER?
	JEFS	GCIX00			:YES - GET NEXT
	SIS	R1,1			:NETWORK CHARACTER PAIR?
	JEFS	GCIX01			:YES - check for IIX
GCIXR1	SIS	R5,1			:NO - SOME BALL. IGNORE IT
	JN	GCIXRY			:MORE TO DO
	J	IIXXR2			:NO MORE - UPDATE POINTER

GCIX00	SIS	R5,1			:DEC COUNT SINCE '00' CHAR. TOSSED
	JE	IIXXR2			:DON'T TAKE GCI CRASH
	JAL	R8,GCI,,		:GET ESCAPED CHARACTER AND
	JR	R9			:RETURN

GCIX01	SIS	R5,1			:decrement count
	LHL	R8,BCT,R2,		:check for next character
	JE	IIXXR2			:not present
	JAL	R8,GCI,,		:get next character
	CLHI	R1,IIX0F6		:check for SIIX
	JE	GCIRET			:go store SIIX flag
	CLHI	R1,IIX0F7		:check for TIIX
	JE	GCIRET			:go store TIIX flag
	J	GCIXR1			:no??  ignore it

GCIRET	SIS	R5,1			:decrement count
	JR	R9			:return
	EI	:XRYTMC	###wjl

:	SIO RING LOAD RING UTILITIES

	IF	SIORNG

::*********************************************************************
::
::	SUBROUTINE:	DLSIRM:
::	FUNCTION:	COMPUTE SPACE AVAILABLE IN INPUT LOAD RING.
::	CALLING SEQ:	JAL	R9,DLSIRM
::	OUTPUT:		R10 = PRC = AVAILABLE SPACE IN PRC.
::			R12 = PRD
::
::*********************************************************************

DLSIRM	HS	0
	LH	PRD,DWLKII,,		:LEAD POINTER
	LH	PRC,DWLKIO,,		:TRAIL POINTER
	SHI	PRC,2,PRD		:COMPUTE RING SPACE AVAILABLE
	JGER	R9
	AHI	PRC,SIRDLS
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	DLSORM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA IN OUTPUT LOAD RING
::	CALLING SEQ:	JAL	R9,DLSORM
::	OUTPUT:		R10 = PRC = AMOUNT OF DATA (IN BYTES)
::			R12 = PRD
::
::*********************************************************************

DLSORM	HS	0
	LH	PRD,DWLKOO,,		:TRAIL POINTER
	LH	PRC,DWLKOI,,		:LEAD POINTER
	SR	PRC,PRD			:COMPUTE AMOUNT OF DATA WAITING
	JGER	R9
	AHI	PRC,SIRDLS
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	DWLSGC:
::	FUNCTION:	GET CHARACTERS FOR SIO RING DOWN-LINE LOAD
::	CALLING SEQ:	JAL	R9,DWLSGC
::	OUTPUT:		RETURNS CHARACTERS ESCAPED
::
::	IF NO CHARS IN BUFFER, DISMISSES AFTER PRESERVING CRITICAL REGISTERS.
::
::*********************************************************************

DWLSGC	HS	0
	LHL	R0,BCT,R2,		:GOT ANY DATA?
	JEFS	DWLSGW			:NO, PRESERVE CONTEXT AND WAIT FOR MORE
	JAL	R8,GCI
	LR	R1,R1			:ESCAPE?
	JNR	R9			:NO
	JAL	R8,GCI			:YES - GET ESCAPED CHARACTER
	JR	R9			:AND RETURN

DWLSGW	ST	R9,DWSISV,,		:SAVE LINK ADDRESS
	STH	PRD,DWSISV+4,,		:CURRENT RING POINTER
	STH	PRC,DWSISV+6,,		:COUNT
	STH	R2,DWSISV+8,,		:BUFFER INDEX
	STH	R4,DWSISV+0A,,		:INTERNAL HOST CHANNEL
	LHI	R0,DWLSGR-SEG1
	STH	R0,INTDSP,R4,R4		:SAVE NEW DISPATCH VECTOR
	J	INTNXT

::*********************************************************************
::
::	ENTRY POINT:	DWLSGR:
::	FUNCTION:	RETURN HERE WAITING FOR CHARS FROM HOST
::
::*********************************************************************

DWLSGR	HS	0
	LHL	R2,DWSISV+8,,		:BUFFER INDEX
	LHL	R0,BCT,R2,		:ANY DATA YET?
	JE	INTNXT			:NO
	LHL	R4,DWSISV+0A,,		:YES - GET INTHST CHANNEL
	LHI	R0,DWLSRG-SEG1
	STH	R0,INTDSP,R4,R4		:RESTORE DISPATCH VECTOR
	L	R9,DWSISV,,		:RETURN ADDRESS
	LH	PRD,DWSISV+4,,		:CURRENT RING POINTER
	LHL	PRC,DWSISV+6,,		:COUNT
	J	DWLSGC			:GO GET DATA

	EI	:SIORNG
	
	SUBTTL	INTHST (DWLIN - Handle Down-Line Load record from neighbor)

::*********************************************************************
::
::	PROCESS:	DWLIN:
::	FUNCTION:	DOWNLINE LOAD RECEIVER
::	SCHEDULED:	Upon demand by SYLVER (SIO and SYNC input processing),
::		to process downline load records echoed to the node from it's
::		loading neighbor on unattached lines.  DWLIN processes one
::		downline load record for each line requiring it, and yields
::		between each one, until no more downline load records are 
::		received by SYLVER, when DWLIN dismisses to the EXEC loop.
::
::*********************************************************************

:	DOWNLINE RECORD TEAR DOWN. RECEIVES A 33-HW RECORD FROM
:	NEIGHBOR BEING LOADED AND SENDS IT ON TO THE HOST PROGRAM.
:	UPON COMPLETION, DWLIN DISMISSES ITSELF FROM THE EXEC JOB QUEUE BY
:	CLEARING ITS BIT IN SQUEUE.  HOWEVER IT DOES SO ONLY PROVIDED THAT
:	LINKER HASN'T CREATED MORE WORK IN THE MEANTIME.  IT CHECKS FOR THIS BY
:	EXAMINING DWQUEU UNDER THE PROTECTION OF THE SEMAPHORE DWTEST.  THIS
:	CONDITION CAN ONLY ARISE UNDER ISIS, WHERE LINKER IS RUN INDEPENDENTLY
:	AND MAY INTERRUPT DWLIN.

DWLIN	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(DWLIN )			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU
	LHL	R5,DWQUEU,,		:GET DWL JOB QUEUE
	LCS	R4,1
DWLIN5	LR	R5,R5			:R5 EMPTY?
	JN	DWLIN3			:NO, CONTINUE
	TS	DWTEST,,		:TEST AND SET SEMAPHORE
	LHL	R5,DWQUEU,,		:EXAMINE DWL JOB QUEUE
	JNFS	DWLIN6			:LINKER HAS RUN. DONT RESET SQUEQE
	LHI	R0,01F-PDWLIN		:LINKER HASNT BEEN RUN....
	RBT	R0,SQUEUE		:...SO RESET SQUEUE.
DWLIN6	LIS	R0,1
	STH	R0,DWTEST,,		:CLEAR THE SEMAPHORE...
	LA	R0,DWLIN
	J	EXYLD,,			:AND RETURN TO EXEC

DWLIN3	AIS	R4,1			:INCREMENT R4 AND
	SLHLS	R5,1			:TEST NEXT LINE
	JCFS	DWLIN4			:FOUND ONE. PROCESS IT
	J	DWLIN5			:HAVENT FOUND ONE.  KEEP LOOKING

:	THROUGHOUT THE CODE R5 = DWL JOB QUEUE
:	AND R4 = INTERNAL HOST CHANNEL INDEX

DWLIN4	RBT	R4,DWQUEU,,
	LHL	R2,INTTAB,R4,R4		:BUFFER #
	JE	DWLIN5
	NHI	R2,-4
	LHI	R1,32			:SEND THE SYNCS
	JAL	R8,WCI,,
	JAL	R8,WCI,,
	LIS	R6,1
	AHM	R6,DWLCIN,,
	LR	R6,R4
	LIS	PRD,0			:TEAR DOWN RECORD
	SLLS	R6,6			:OBTAIN APPROPRIATE OFFSET (64 X R4)
DWLIN1	LB	R1,DWIBUF,PRD,R6	:...AND INDEX INTO DWIBUF
	CLHI	R1,8			:ESCAPE IF NEEDED
	JGEFS	DWLIN2
	EXBR	R1,R1
	JAL	R8,WCI,,
	EXBR	R1,R1
DWLIN2	JAL	R8,WCI,,
	AIS	PRD,1
	CLHI	PRD,40
	JL	DWLIN1
	IF	INTACC			
	LR	R0,PRD			:Get byte count into R0 for accumulator
	LR	R3,R4			:Get internal port index in work reg
	JAL	R8,AARDOC		:Accumulate byte count for accounting
	GL	AARDOC
	EI	:INTACC			:###EV
	LIS	R0,0			:CLEAR BUSY FLAG
	STH	R0,DWBUSY,R4,R4
	J	DWLIN5			:CONTINUE...

	SUBTTL	INTHST (DLYSRC - Delay measurement source)

::*********************************************************************
::
::	PROCESS:	DLYSRC:
::	FUNCTION:	SOURCE OF THE TEST DATA USED IN ROUND-TRIP
::		DELAY MEASUREMENTS.  FILLS ALL REQUESTING CHANNELS WITH
::		THE SPECIFIED NUMBER OF FILL HALF-WORDS.
::	SCHEDULED:	IN INTDLY WHENEVER A DELAY MEASUREMENT IS DETECTED,
::		AND SUBSEQUENTLY RUNS PERIODICALLY OFF THE TIME-OUT LIST.
::
::*********************************************************************

FILLCH	EQ	04141			:this is our fill character

DLYSRC	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(DLYSRC)			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU
	LHL	R4,INTDSF		:MAKE SURE THERE IS AT LEAST 1 CHANNEL
	JNFS	DLYSR9			:YES
	LHI	R0,01F-PDLYSR		:NO, SO UN-SCHEDULE DLYSRC
	LHI	R1,3C
DLYSR8	RBT	R0,SCHTAB,R1,		:BY CLEARING ALL THE TIMEOUT-LIST BITS
	SIS	R1,4
	JL	EXDISM,,		:CLEARED ALL BITS
	JBS	DLYSR8			:SOME LEFT, LOOP BACK

DLYSR9	LHL	R1,FASTC+2,,		:GET CURRENT TIME
	THI	R1,0FC00
	JE	EXDISM,,		:FASTC REQUIRES ESCAPES...TRY LATER
	THI	R1,0FC
	JE	EXDISM,,		:IT WILL REQUIRE ESCAPES HERE, TOO...

	LR	R10,R1			:SAVE FASTC
DLYSR5	JFFOH	R4,DLYSR3		:GET NEXT CHANNEL
	J	EXDISM,,		:NONE LEFT,RETURN
DLYSR3	XH	R4,HMSK,R5,R5		:MARK AS DONE
	LHL	R2,INTTAB,R5,R5		:GET OUTGOING BUFFER NUMBER
:	subject delay msmt circuits to backpressure from source		###jhl
	LR	R7,R2			:copy buffer index to R7
	NHI	R7,3			:read speed bits
	NHI	R2,-4			:strip speed bits
	LHL	R0,CIRSPK,R7,R7		:if BCT > TP class limit, do nothing
	CLH	R0,BCT,R2,		:compare the BCT for the channel
	JL	DLYSR5			:go to service next channel
:	OK to put more chars in buffer	
	LHL	R6,CFLCNT,R5,R5		:read channel count array
	JN	DLYS10			:if non-zero, take it from there
:	time to start a new barrage of CHNFIL worth of chars
	LHL	R6,CHNFIL,R5,R5		:reset CFLCNT to top value
	STH	R6,CFLCNT,R5,R5
	JAL	R9,WHWI,,		:send FASTC from R1 as a starter
DLYS10	SR	R6,R0			:HW 'to send' count - TP class limit
	JL	DLYS20			:branch if < TP left
:	here if > TP limit left to put in buffer for this message
	STH	R6,CFLCNT,R5,R5		:reset 'to send' count
	LR	R6,R0			:move TP no. of chars into the buffer
	J	DLYS30
:	here if < TP limit left -- end of this message
DLYS20	LHL	R6,CFLCNT,R5,R5		:get 'to send' count 
	LIS	R0,0			:zero out CFLCNT
	STH	R0,CFLCNT,R5,R5
DLYS30	HS	0
	LI	R1,FILLCH		:load fill character
DLYSR6	JAL	R9,WHWI,,		:WRITE IN NEXT FILL HW
	SIS	R6,1
	JGBS	DLYSR6			:LOOP BACK

	LHL	R6,CFLCNT,R5,R5		:this is 'end of msg' test	###jhl
	JN	DLYSR5			:send FASTC only at end of msg	###jhl

	LR	R1,R10			:RECOVER FASTC
	JAL	R9,WHWI,,		:AND PUT INTO END OF PACKET
	J	DLYSR5			:REPEAT

	SUBTTL	INTHST (INTTIM - Internal Host Time-Out logic)

::*********************************************************************
::
::	SUBROUTINE:	INTTIM:
::	FUNCTION:	Internal Host Time-Out logic
::	CALLING SEQ:	JAL	R11,INTTIM	CALLED BY THE 4-MINUTE PROCESS.
::		INTTIM ACTUALLY RUNS EVERY 8 MINUTES THROUGH THE USE OF THE
::		INT8MN CELL
::
::*********************************************************************

:	TIMEOUT IS ENABLED FOR AN INTERNAL HOST CRQ WHEN THE CORRESPONDING
:	BIT IN INTOUT IS SET. SUCH A CRQ KEEPS FROM BEING ZAPPED BY KEEPING
:	ITS BIT IN INTACT SET.
:
:	INTTIM EXAMINES THE INTACT ARRAY AND SETS A BIT IN THE INTWRN
:	ARRAY FOR EACH CRQ THAT HAS NOT BEEN ACTIVE. IF INTWRN HAS
:	ALREADY BEEN SET INTTIM ZAPS THE CRQ.

INTTIM	HS	0
	LCS	R0,1			
	AHM	R0,INT8MN		:DECREMENT CLOCK
	JGR	R11			:NOT TIME TO RUN INTTIM  YET

	ST	R11,INTTSV
	LIS	R1,3			:REINITIALIZE CLOCK
	AHM	R1,INT8MN
	LH	R3,INTACP,,		:EXAMINE ALL INT HOST CHANNELS	###jhl
:	recall that set bits in ACP are inactive channels.
	OH	R3,INTACT		:OR in the active channels
	XR	R3,R0			:EACH 1 => (PORT IN USE) AND (NO DATA)
	NH	R3,INTOUT		:MASK WITH TIMEOUT ENABLE ARRAY
	STH	R3,INTSAV
INTTI2	LHL	R3,INTSAV		:LOOP OVER ALL POSSIBILITIES
	JFFOH	R3,INTTI3
	J	INTTI1			:ALL DONE. RETURN
INTTI3	CLHI	R4,TINTCH		:IS IT WITHIN RANGE?
	JGE	INTTI1			:NO..  ALL DONE,RETURN
	RBT	R4,INTSAV		:FOUND A POSSIBILITY
	SBT	R4,INTWRN		:TEST AND SET ITS WARNING BIT
	JEBS	INTTI2			:WARNING HADN'T BEEN GIVEN.  CONTINUE
	LHL	R2,INTTAB,R4,R4 	:TIME TO ZAP... GET BUFFER NUMBER
	NHI	R2,-4
	XHI	R2,4			:FLIP FOR INTZAP (WANTS INCOMING #)
	JAL	R10,INTZAP		:ZAP AND DO CLOSING BOOK-KEEPING
	LHI	R0,INTZFL		:CRYPTO MESSAGE HAS ABS CHN #
	AR	R0,R4
	JAL	R8,CRYPTO,,
	HC	CRYE2B			:CRYPTO MESSAGE:INT HST TIMEOUT
	J	INTTI2			:CONTINUE...
INTTI1	LIS	R0,0
	STH	R0,INTACT		:CLEAR THE ACTIVE ARRAY
	L	R11,INTTSV
	JR	R11			:RETURN TO EXEC


	ENDMO.(INTHST)

	EI	:1-KILLIT

	KILMSG(INTHST)

:	***NOTHING PAST THIS POINT***
	SUBTTL	UTIL

:			*   * ***** ***** *
:			*   *   *     *   *
:			*   *   *     *   *
:			*   *   *     *   *
:			 ***    *   ***** *****

::#####################################################################
::
::	MODULE:		UTIL
::
::	SUBTTLS:
::		TRACER
::		Measurement routines
::		BUBBLE
::		SHRINK
::		FIND
::		ACCOUNTING
::		SOLOCS
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA 0
	SEG  1

::*********************************************************************
::
::	ROUTINE:	TRACER:
::	FUNCTION:	UPSW trace interrupt routine.  If the PSW trace bit is
::		set, the interrupt will send us here just before every jump
::		instruction is executed.  The PSD (with PC=jump destination)
::		has been stored at 10x mac'd (TRPSW) and the trace bit has
::		been turned off.  TRACER runs in set 0F mac'd.  We return 
::		by loading the mainline PSW from TRPSW.  Trace table (TRCTAB)
::		entries are the LO HW's of the jump destination addresses.
::		TRNDEX points to the next entry in the table.  When a node
::		crashes, the trace table is copied into SEGC at TRSTAB where
::		it can be examined at leisure with the XRAY 'TT' command.
::		(TRSTAB is created so that its last entry is the address of
::		of the last jump before the crash.  Trace is turned off when
::		the node crashes.)
::
::		TRACER may only be enabled when the Tymfile OPTION(UTRC) is
::		invoked.  This sets assembly switch (DB.TRC).  Under the
::		DB.TRC switch, the trace bit is set by writing a 1000 at
::		EXEPSW+2.  It is also enabled/disabled by the XRAY 'TR'
::		command, though this causes a special kind of tracing to take
::		place (see below).  TRACER requires an expanded async ring in
::		Solo CONSAT configurations which is also only assembled only
::		under the DB.TRC switch.  This OPTION should not be used on
::		4800 baud CONSATS!
::
::		We will do one of 3 things in TRACER, depending on the
::		value of TRCRRQ:
::			1) If it is >0, we will simply return without making
::				a trace table entry.  This allows us to disable
::				tracing while the PSW trace bit is set.
::			2) If it is =0, we will unconditionally make an entry
::				in the trace table.  This is the default state
::				when trace is enabled via DB.TRC or by setting
::				the trace bit in EXEPSW.  When we reach the end
::				of the table, we'll wrap back around to the
::				beginning again.
::			3) If it is <0 (-1), we will make table entries only
::				for jumps which are within, into, or out of a
::				specified address range (TRCBEG to TRCEND).  
::				See XRAY 'TR' command for use of this trace.
::
::*********************************************************************

	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl

:	Save some registers which will be clobbered by what follows.
:	TRCRRQ tells us what to do next:
:		If >0, exit via TREND.
:		If =0, do regular trace at TRACR0.
:		If <0, fall through to do special trace-in-range.
TRACER  HS	0
	STM	R13,TRSAVE,,		:SAVE SOME REGISTERS
	LH	R14,TRCRRQ,,		:SPECIAL TRACE REQUEST?
	JG	TREND			:FORCE NO TRACE IF > 0
	JE	TRACR0			:NO

:	Fall thru to here to trace jumps in a specified address range
:	(TRCRRQ set to -1 by 'TR' command).  If the jump destination is
:	in the range (TRCBEG to TRCEND), then make an entry in the trace table.
:	If the jump destination is out of the range and the previous entry
:	was in range, make an entry to show how we left the range.
:	If the jump destination	is in range and the previous entry was
:	out of range, preserve the previous entry to show how we got into
:	the range.

	LHL	R14,TRNDEX,,		:INDEX INTO TRACE TABLE
	L	R15,TRPSW+4		:GET JUMP DESTINATION ADDRESS
	C	R15,TRCBEG,,		:IN RANGE?
	JL	TRACR1			:NO, TOO LOW

	C	R15,TRCEND,,		:UPPER LIMIT
	JGE	TRACR1			:NO, TOO HIGH

	LH	R13,TRCRFL,,		:WAS PREVIOUS ENTRY IN RANGE?
	JLFS	TRACR4			:YES

	AIS	R14,2
	NHI	R14,TRTBSZ-1		:MASK FOR WRAP

TRACR4	HS	0
	STH	R15,TRCTAB,R14,,	:MAKE ENTRY
	TS	TRCRFL,,		:INDICATE THAT LAST ENTRY WAS IN RANGE
	AIS	R14,2			:BUMP INDEX
	NHI	R14,TRTBSZ-1		:MASK FOR WRAP
	STH	R14,TRNDEX,,		:NEW INDEX
TRACR2	LM	R13,TRSAVE,,		:RESTORE REGISTERS
	UPSW	TRPSW			:CONTINUE

TRACR1	HS	0			:JUMP ADDRESS OUT OF RANGE
	STH	R15,TRCTAB,R14,,	:MAKE TABLE ENTRY
	LH	R13,TRCRFL,,		:WAS PREVIOUS ENTRY IN RANGE?
	JGEFS	TRACR3			:NO

	AIS	R14,2			:BUMP INDEX
	NHI	R14,TRTBSZ-1		:MASK FOR WRAP
	STH	R14,TRNDEX,,		:SAVE NEW INDEX
	STH	R14,TRCRFL,,		:INDICATE LAST ENTRY OUT OF RANGE
TRACR3	HS	0
	LM	R13,TRSAVE,,		:RESTORE REGISTERS
	UPSW	TRPSW			:CONTINUE

TRACR0	HS	0			:Here for regular trace.
	LHL	R15,TRPSW+6		:GET BRANCH ADDRESS
	LH	R14,TRNDEX,,		:GET INDEX INTO TRACE TABLE
	AIS	R14,2			:INC TO NEXT ENTRY
	NHI	R14,TRTBSZ-1
	STH	R15,TRCTAB,R14,,	:STORE IN TABLE
	STH	R14,TRNDEX,,		:SAVE INDEX FOR NEXT TIME
	J	TREND
	WS	8			:PLACE TO PATCH IN SPECIFIC TESTS

:	Here to restore registers and UPSW back to mainline.
TREND	HS	0
	LM	R13,TRSAVE,,		:RESTORE REGISTERS
	UPSW	TRPSW

	EI	:DB.TRC

	SUBTTL 	UTIL (Measurement routines)

::*********************************************************************
::
::	SUBROUTINE:	MTRFIC:
::	FUNCTION:	MEASURES CHARACTER TRAFFIC ON THE NETWORK LINKS.
::	CALLING SEQ:	JAL	R10,MTRFIC	(called from 1sec logic)
::
::*********************************************************************

:	EACH LINK MAINTAINS COUNTS FOR LOGICAL CPS IN AND OUT, PHYSICAL
:	CPS IN AND OUT, RMAKE CALLS IN WHICH NO PACKETS WERE MADE, AND
:	PACKETS MADE. THE RUNNING COUNTS ARE STORED IN
:	THE "LAST MINUTE'S"  LINK DESCRIPTOR FIELD AND COMPARED TO THE
:	"HI-WATER MARK" FIELD. THE SUM  OF ALL LINKS' COUNTS FOR LOGICAL
:	CHARACTERS IS SAVED, AND COMPARED TO HI-WATER MARKS FOR THE NODE.
:
:	IN ADDITION RMAKE STORES THE TIME EACH PACKET IS MADE IN THE AREA
:	PKTTIM, INDEXED BY RECORD NUMBER. THE SYNC INTERRUPT ROUTINE USES THIS
:	VALUE TO COMPUTE HOW LONG THE PACKET WAS QUEUED. A RUNNING COUNT OF
:	PACKET QUEUEING TIMES IS MAINTAINED IN KS.PQC

MTRFIC	HS	0
	LH	R7,SLOWC+2,,		:CURRENT TIME
	LH	R6,MTLTIM,,		:LAST TIME WE WERE HERE
	STH	R7,MTLTIM,,
	SR	R7,R6
	CHVR	R7,R7
	STH	R7,MTTINT,,		:EXACT TIME INTERVAL BETWEEN SAMPLES.
	LHL	R8,FASTC+2,,
	LHL	R6,MTLFST,,		:LAST FASTC TIME
	STH	R8,MTLFST,,
	SR	R8,R6
	JGEFS	MTRFI1			:CAN'T USE CHVR HERE
	AI	R8,10000		:BECAUSE R8 MAY HAVE 8000 BIT SET
MTRFI1	HS	0
	ST	R10,MTRSAV,,		:save return to free up register###wjl
	LIS	R10,0			:sum of all links phys counts output
	LIS	R5,0			:sum of all links phys counts input
	LIS	R0,0
	LIS	LRC,0			:SUM OF ALL LINKS LOGICAL COUNTS OUTPUT
	LIS	R12,0			:SUM OF ALL LINKS LOGICAL COUNTS INPUT

	LHI	KN,NLINKS-1		:DO FOR ALL LINKS
MTRFI2	SLL	KN,1
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR INDEX
	SRL	KN,1
	LB	R1,NLAT,KD		:ANY LINES UP ON THIS LINK?
	JE	MTRFI5			:NO, GO DIRECTLY TO THE NEXT LINK
	A	LRC,KS.LCO,KD		:INCREMENT CUMULATIVE COUNTERS
	A	R12,KS.LCI,KD
	A	R10,KS.PCO,KD		:###wjl
	A	R5,KS.PCI,KD		:###wjl
	LIS	R1,5			:UPDATE 5 GROUPS OF COUNTERS,
	LA	R2,KS.PCO,KD		:BEGINNING WITH PCO

MTRFI3	L	R3,0,R2			:GET RUNNING COUNT AND
	ST	R3,4,R2			:STORE IN 'LAST MINUTE' FIELD
	ST	R0,0,R2			:CLEAR RUNNING COUNT
	C	R3,8,R2			:NEW HI-WATER MARK?
	JLEFS	MTRFI4			:NO
	ST	R3,8,R2			:YES - SAVE IT
MTRFI4	AIS	R2,0C			:ADVANCE TO NEXT GROUP
	SIS	R1,1			:IF MORE TO DO
	JGBS	MTRFI3

	LR	R1,R8			:MOVE TIME INTERVAL OVER
	DH	R1,KS.RRC,KD		:DIVIDE BY RMAKE R-ROBIN COUNT
	STH	R0,KS.RRC,KD		:CLEAR OUT ROUND ROBIN COUNT
	SRLS	R2,1			:DIVIDE BY 2
	STH	R2,KS.RRT,KD		:AND STORE BACK AVERAGE R-ROBIN DELAY

	IF	STRHUB			:##AL FOR STRLINK
	LHL	R2,STRXMT,KN,KN		:READ CURRENT RUNNING COUNT(REXMIT)
	LHL	R3,KS.TRF,KD		:READ  PREVIOUS MIN'S START COUNT
	STH	R2,KS.TRF,KD		:SAVE NEW START MINUTE COUNT	
	SR	R2,R3			:RUNNING - SAVE	
	JGEFS	MTRI71			:HAVE WE WRAPPED??
	AI	R2,10000		:IF SO ADD ON MODULO HW
MTRI71	STH	R2,KS.TSV,KD		:SAVE NEW MINUTE'S TOTAL	
	LHL	R2,SRCTRS,KN,KN		:READ CURRENT RUNNING COUNT(TRANSMIT)
	LHL	R3,KS.RRF,KD		:READ  PREVIOUS MIN'S START COUNT
	STH	R2,KS.RRF,KD		:SAVE NEW START MINUTE COUNT	
	SR	R2,R3			:RUNNING - SAVE	 = NEW TOTAL
	JGEFS	MTRI72			:HAVE WE WRAPPED??
	AI	R2,10000		:IF SO ADD ON MODULO HW
MTRI72	STH	R2,KS.RSV,KD		:SAVE NEW MINUTE'S TOTAL	
	EI	:STRHUB
	LH	R2,LRMSAV,KD		:GET LRM SAVE VALUE
	LH	R3,LRM,KD		:AND LAST REC MADE ON LINK
	STH	R3,LRMSAV,KD		:UPDATE LRMSAV
	SR	R3,R2			:SUBTRACT TO GET NUMBER OF RECORDS MADE
	JGEFS	MTRFI7
	AI	R3,10000
MTRFI7	STH	R3,KS.PKM,KD		:SAVE NUMBER OF PACKETS MADE
	L	R1,KS.PQC,KD		:GET CUMMULATIVE QUEUEING DELAYS
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRI88			:SET ZERO ##AL
	STH	R3,KS.AQU,KD		:STORE 0 DELAY (IN FASTC TICKS)
	JFS	MTRFI9
MTRI88	DHR	R1,R3			:DIVIDE BY NUMBER OF PACKETS MADE
	STH	R2,KS.AQU,KD		:STORE AVERAGE DELAY (IN FASTC TICKS)
MTRFI9	ST	R0,KS.PQC,KD		:CLEAR OUT QUEUEING DELAY ACCUMULATOR

	IF	BFLTMR			:for buffer delay timing pairs	###JHL
	LHL	R1,BDLCNT,KD		:read running occurrence counter
	STH	R0,BDLCNT,KD		:start fresh for new minute
	STH	R1,KS.BFC,KD		:save minute count for display
	LHL	R1,BDLACC,KD		:read running delay accumulator
	STH	R0,BDLACC,KD		:start fresh for new minute
	STH	R1,KS.BFD,KD		:save minute count for display
	EI	:BFLTMR			:				###JHL

:	COLLECT LOGICAL RECORDS FOR RECDS/PKT STAT.			###JHL
	LHL	R1,KS.LRM,KD		:GET COUNT OF LOGICAL RECORDS MADE
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRFIA			:SET ZERO ##AL
	STH	R3,KS.LRA,KD		:PUT 0 IF NO LRM
	JFS	MTRFIB
MTRFIA	DHR	R1,R3			:DIVIDE BY NUMBER OF PACKETS MADE
	STH	R2,KS.LRA,KD		:QUOTIENT IS AVG RECS/PKT
MTRFIB	STH	R0,KS.LRM,KD		:CLEAR COUNT -- START NEXT MINUTE ANEW
					:				###JHL

	L	R1,KS.PMO,KD		:GET TOTAL NUMBER OF BYTES
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRICC			:SET ZERO ##AL
	STH	R3,KS.ASZ,KD		:RESULT= 0 PACKET SIZE
	JFS	MTRFID
MTRICC	DHR	R1,R3			:DIVIDE BY NUMBER OF PACKETS
	STH	R2,KS.ASZ,KD		:RESULT=AVERAGE PACKET SIZE
MTRFID	LB	R1,KSPD,KD		:FIGURE OUT LINE SPEED IN CPS
	NHI	R1,01F
	SLLS	R1,2
	LHL	R6,KSPCPF,R1,		:LOOK UP THE CPS RATE IN FASTC	###wjl
	GL	KSPCPF
	LB	R4,NLAT,KD		:GET NUMBER OF LINES ON LINK
	MHR	R2,R4			:FORM <AVE SIZE>*<NLINES>
	LHR	R6,R6			:DIVIDER CAN'T BE 0
	JNFS	MTRFIE			:SET ZERO ##AL
	STH	R6,KS.XMT,KD		:0 XMIT TIME...
	JFS	MTRFIF
MTRFIE	DHR	R2,R6			:DIVIDE BY LINK CPS RATE TO GET MEAN
	STH	R3,KS.XMT,KD		: XMIT TIME... THIS RESULT IS IN FASTC
MTRFIF	LHL	R1,KS.BAK,KD		:GET BACKLOG COUNT FOR LINK
	STH	R1,KS.BAM,KD		:AND MOVE TO SAVE AREA
	STH	R0,KS.BAK,KD		:CLEAR BACKLOG COUNT

	LH	R2,LRTSAV,KD		:GET OLD LRT VALUE
	LH	R3,LRT,KD		:AND CURRENT VALUE
	STH	R3,LRTSAV,KD		:UPDATE LRTSAV
	SR	R3,R2
	JGEFS	MTRFI8
	AI	R3,10000
MTRFI8	L	R1,KS.SRC,KD		:GET CUMMULATIVE SYLVER-RTD DELAYS
	ST	R0,KS.SRC,KD		:AND CLEAR THE ACCUMULATOR
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRI8N			:SET ZERO ##AL
	STH	R3,KS.SRA,KD		:STORE 0 DELAY (IN FASTC TICKS)
	JFS	MTRFI5
MTRI8N	DHR	R1,R3			:GET AVERAGE SYLVER-RTD DELAY IN FASTC
	STH	R2,KS.SRA,KD		:AND SAVE IT

MTRFI5	SIS	KN,1			:DO FOR ALL LINKS
	JGE	MTRFI2

:	COLLECT MARK, REXMT, AND XMT STATS FOR LINES ON THIS LINK
:	--SHOWN IN KS COMMAND						###JHL
	LHI	R1,(NLINES-1)*2		:				###wjl
NXTLI3	L	R2,KDLN,R1,R1		:SEE IF THIS LINE IS ATTACHED	###wjl
	JL	NXTLI1			:NEG VALUE SAYS NO
	LHL	R2,LXMSET,R1,		:READ CURRENT RUNNING COUNT(MARKING)
	LHL	R3,KL.LRF,R1,		:READ  PREVIOUS MIN'S START COUNT##wjl
	STH	R2,KL.LRF,R1,		:SAVE NEW START MINUTE COUNT	###wjl
	SR	R2,R3			:RUNNING - SAVE	 = NEW TOTAL
	JGEFS	NXTLI4			:HAVE WE WRAPPED??
	AI	R2,10000		:IF SO ADD ON MODULO HW
NXTLI4	STH	R2,KL.LSV,R1,		:SAVE NEW MINUTE'S TOTAL	###wjl
	LHL	R2,TRRXMT,R1,		:READ CURRENT RUNNING COUNT(REXMIT)
	LHL	R3,KL.TRF,R1,		:READ  PREVIOUS MIN'S START COUNT##wjl
	STH	R2,KL.TRF,R1,		:SAVE NEW START MINUTE COUNT	###wjl
	SR	R2,R3			:RUNNING - SAVE	
	JGEFS	NXTLI5			:HAVE WE WRAPPED??
	AI	R2,10000		:IF SO ADD ON MODULO HW
NXTLI5	STH	R2,KL.TSV,R1,		:SAVE NEW MINUTE'S TOTAL	###wjl
	LHL	R2,RCTRNS,R1,		:READ CURRENT RUNNING COUNT(TRANSMIT)
	LHL	R3,KL.RRF,R1,		:READ  PREVIOUS MIN'S START COUNT##wjl
	STH	R2,KL.RRF,R1,		:SAVE NEW START MINUTE COUNT	###wjl
	SR	R2,R3			:RUNNING - SAVE	 = NEW TOTAL
	JGEFS	NXTLI6			:HAVE WE WRAPPED??
	AI	R2,10000		:IF SO ADD ON MODULO HW
NXTLI6	STH	R2,KL.RSV,R1,		:SAVE NEW MINUTE'S TOTAL	###wjl
NXTLI1	SIS	R1,2			:STEP BACK TO NEXT LOWEST LINE
	JGE	NXTLI3			:LOOP UNTIL ALL LINES DONE
					:				###JHL

	IF	SOLOCS
	LR	R1,R8			:COPY OVER TIME INTERVAL
	DH	R1,ASYCNT,,		:DIVIDE BY NUMBER OF ASYNC EXECUTIONS
	GL	ASYCNT
	STH	R2,ASYAVE,,		:SAVE AVERAGE RESULT
	GL	ASYAVE
	STH	R0,ASYCNT,,		:CLEAR ASYNC COUNT
	EI	:SOLOCS

	DH	R8,SYLXEC		:DIVIDE TIME INTERVAL BY # SYLVER RUNS
	SRLS	R9,1			:DIVIDE AVERAGE INTERVAL BY 2
	STH	R9,SYLXAV		:AND STORE INTO AVERAGE DELAY CELL
	STH	R0,SYLXEC		:CLEAR COUNT OF SYLVER RUNS

:	SAVE COUNTS FOR ALL LINKS AND TEST FOR NEW HI-WATER MARK
	ST	LRC,TOTCHR,,		:SAVE TOTAL CHARS OUT
	AM	R12,TOTCHR,,		:PLUS TOTAL CHARS IN
	DHR	LRC,R7			:CONVERT EACH TO SECONDS
	STH	R15,NSCPSO,,		:AND SAVE
	DHR	R12,R7
	STH	R13,NSCPSI,,		:INPUT COUNT
	CLH	R15,NSCPHO,,		:NEW HI-WATER MARK?
	JLEFS	MTRFI6			:NO
	STH	R15,NSCPHO,,		:YES - SAVE
MTRFI6	CLH	R13,NSCPHI,,		:TEST FOR HWM FOR INPUT CHRAS
	JLEFS	MTRF10			:NO
	STH	R13,NSCPHI,,

:	NODE LINKS' TOTAL PHYSICAL CPS RATES
MTRF10	HS	0
	DHR	R10,R7			:convert physical chars out	###wjl
	STH	R11,NS.PCO+2,,		:store HW value in FW location	###wjl
	DHR	R5,R7			:convert physical chars in	###wjl
	STH	R6,NS.PCI+2,,		:store HW value in FW location	###wjl
	CLH	R11,NS.PHO,,		:new hi-water mark for PCO?	###wjl
	JLEFS	MTR020			:no				###wjl
	STH	R11,NS.PHO,,		:yes, save			###wjl
MTR020	CLH	R6,NS.PHI,,		:new hi-water mark for PCI?	###wjl
	JLEFS	MTR022			:no				###wjl
	STH	R6,NS.PHI,,		:yes, save			###wjl
MTR022	L	R10,MTRSAV,,		:load return			###wjl

	IF	SOLOCS
	L	R2,CS.(CTASYI),,
	GL	CTASYI
	ST	R0,CS.(CTASYI),,
	STH	R0,CS.(CTASBK),,
	GL	CTASBK
	DHR	R2,R7			:COMPUTE ASYNC CPS IN
	STH	R3,NSASYI,,
	GL	NSASYI
	CLH	R3,NSASHI,,		:NEW HWM?
	GL	NSASHI
	JLEFS	MTRF12			:NO
	STH	R3,NSASHI,,		:YES - SAVE
MTRF12	L	R2,CS.(CTASYO),,
	GL	CTASYO
	ST	R0,CS.(CTASYO),,
	DHR	R2,R7			:COMPUTE ASYNC CPS OUT
	STH	R3,NSASYO,,
	GL	NSASYO
	CLH	R3,NSASHO,,		:NEW HWM?
	GL	NSASHO
	JLEFS	MTRF14			:NO
	STH	R3,NSASHO,,		:YES - SAVE
MTRF14	IF	NUMPRN
	L	R2,CTPRNO,,
	GL	CTPRNO
	ST	R0,CTPRNO,,
	DHR	R2,R7			:COMPUTE PRINTER CPS OUT	###wjl
	STH	R3,NSPRNO,,
	GL	NSPRNO
	CLH	R3,NSPRHO,,		:NEW HWM?
	GL	NSPRHO
	JLEFS	MTRF16			:NO
	STH	R3,NSPRHO,,		:YES - SAVE
	EI	:NUMPRN
	EI	:SOLOCS
MTRF16	JR	R10			:RETURN TO CALLER

::*********************************************************************
::
::	SUBROUTINE:	MAKNDL:
::	FUNCTION:	MAKES A NEEDLE IN ACCORDANCE WITH THE DATA
::			SUPPLIED IN NODLS AND DLYFLG, AND NOTIFYS CRQ
::	CALLING SEQ:	JAL	R10,MAKNDL
::	INPUT:		CHN = ABSOLUTE CHANNEL NUMBER TO BE USED
::			R6  = OFFSET INTO DLYBSE, THE DATA AREA
::
::*********************************************************************

MAKNDL	HS	0
	JAL	R8,GFCBUF,,		:GET A FREE BUFFER PAIR
	J	MAKOOB			:immed. return - out of buffers!###wjl
	LHI	R1,NEEDP		:+4, ok -WRITE NEEDLE POINT INTO BUFFER
	EXBR	R1,R1
	JAL	R8,WCI,,
	EXBR	R1,R1
	JAL	R8,WCI,,
	LIS	R1,0
	JAL	R8,WCI,,		:ESCAPE THE BYTE COUNT
	JAL	R8,WCI,,		:LEAVE SLOT FOR BYTE COUNT
	L	PRD,BE,R2,		:SAVE POINTER TO BYTE COUNT SLOT
	JAL	R8,WCI,,		:ESCAPE THE LINK COUNT
	LHL	R1,NODCNT,R6		:NODCNT = 2X # OF 1-WAY NODES 
	OHI	R1,80
	JAL	R8,WCI,,		:WHICH = TOTAL ROUND TRIP LINK COUNT
	LHI	R1,0FFFF		:DUMMY INVOICE NUMBER
	JAL	R9,WHWI,,
	JAL	R9,WHWI,,
	LHL	R1,DLYFLG,R6		:FLAGS
	JAL	R9,WHWI,,
	LHI	R1,MACHNM		:REQUESTING NODE NUMBER
	JAL	R9,WHWI,,
	LR	R1,CHN			:ABSOLUTE PORT NUMBER
	JAL	R9,WHWI,,
	LHL	R7,NODCNT,R6		:NUMBER OF NODES IN 1-WAY PATH
	JE	MAKND4			:ZERO, SOMEONE WNTS AN INTERNAL PATH
	LIS 	R4,0			:NONZERO, COPY NODE LIST INTO NEEDLE
MAKND1	LHL	R1,NODLST,R6,R4		:GET THE NEXT NODE OFF THE LIST
	JAL	R9,WHWI,,		:AND WRITE INTO NEEDLE
	AIS	R4,2
	CR	R7,R4			:AT END OF LIST?
	JGBS	MAKND1			:NO,LOOP BACK
	SIS	R4,4			:YES,BACK UP TO NEXT-TO-LAST NODE
	JLFS	MAKND3 			:SPECIAL CASE:ONLY 1 NODE IN LIST
MAKND2	LHL	R1,NODLST,R6,R4		:WORK BACKWARDS FOR RETURN PATH
	JAL	R9,WHWI,,
	SIS	R4,2
	JGEBS	MAKND2			:MORE NODES LEFT, LOOP BACK
MAKND3	LHI	R1,MACHNM		:WE ARE THE DESTINAION NODE
	JAL	R9,WHWI,,
MAKND4	LHI	R1,HST0+8000		:AND THE DESTINATION HOST
	JAL	R9,WHWI,,
	LHI	R1,7FFF			:DEPOSIT DUMMY ID'S
	JAL	R9,WHWI,,
	JAL	R9,WHWI,,
	LHI	R1,444C
	JAL	R9,WHWI,,		:DEPOSIT DLOAD USER NAME
	LHI	R1,4F41
	JAL	R9,WHWI,,
	LHI	R1,440D
	JAL	R9,WHWI,,
	JAL	R8,CBCCT,,		:GET THE BYTE COUNT FOR THE NEEDLE
	STB	R1,0,PRD		:AND DEPOSIT INTO ITS SLOT
	JAL	R9,CRQHCR		:BUILD HALF CRQ
	JAL	R9,CRQALT		:ALERT CRQ
	LR	R3,R2
	SRLS	R3,3
	SBT	R3,CRQEND,,

	JR	R10			:RETURN TO CALLER

MAKOOB	J	OP8463,,		:out of buffers! - crash	###wjl
::*********************************************************************
::
::	SUBROUTINE:	CKOVLD:
::	FUNCTION:	CHECKS ALL ACTIVE LINKS TO SEE WHICH ONES HAVE
::			BEEN OVERLOADED DURING THE PREVIOUS 1/2 SECOND.
::			INCS A COUNTER FOR THOSE WHICH HAVE.
::	CALLING SEQ:	JAL	R10,CKOVLD  CALLED FROM 1/2 SEC LOGIC.
::
::*********************************************************************

CKOVLD	HS	0
	LIS	R2,0
CKOV2	L	R3,ALINKS,R2		:COPY ALINKS INTO CKOSAV
	ST	R3,CKOSAV,R2
	AIS	R2,4
	CI	R2,LKSIZE
	JL	CKOV2
	LIS	R3,1			:FOR INCREMENT COUNTERS
	LIS	R0,0			:FOR REFRESHING IDLE ARRAY
	LIS	R5,0			:R5 = INDEX INTO ARRAY
CKOVA	L	R1,CKOSAV,R5
	JFFO	R1,CKOVC		:ACT ON ACTIVE LINKS
	AIS	R5,4			:NO BITS SET
	CLI	R5,LKSIZE
	JLBS	CKOVA
	JR	R10			:NO MORE ACTIVE LINKS
CKOVC	RBT	R2,CKOSAV,R5		:FIRST BIT FOUND
	SLLS	R5,3			:FORM LINK NO.
	OR	R2,R5
	IF	0:	ELSE
	L	R2,ALINKS		:PROCESS ACTIVE LINKS
	ST	R2,CKOSAV
	LIS	R3,1			:FOR INCREMENTING COUNTERS
	LIS	R0,0			:FOR REFRESHING IDLE ARRAY
CKOVA	L	R1,CKOSAV
	JFFO	R1,CKOVC		:ACT ON ACTIVE LINKS
	JR	R10			:RETURN IF NO MORE ACTIVE LINKS

CKOVC	RBT	2,CKOSAV
	EI	:TONY
	SLL	R2,1
	L	R4,KDKN,R2,R2		:GET LINK DESCRIPTOR INDEX
	SRL	R2,1
	SBT	R2,LKRR			:RESET IF ROUND-ROBIN SERVICED FOR 
					: ALL CHANNELS ON LINK
	JEFS	CKOVB			:ALL CHANNELS SERVICED
	AHM	R3,LKOVLD,R2,R2		:BUMP COUNT FOR LINK OVERLOADED
CKOVB	LH	R1,IDLE,R4		:NEGATIVE IF LINK EVER WENT IDLE
					: DURING PAST 1/2 SECOND
	STH	R0,IDLE,R4		:REFRESH CELL, STH DOESN'T ALTER PSW CC
	JL	CKOVA			:LINK NOT SATURATED
	AHM	R3,LKSTCT,R2,R2		:INCREMENT COUNT OF LINK SATURATED
	J	CKOVA

	SUBTTL	UTIL (BUBBLE)

::*********************************************************************
::
::	SUBROUTINE:	BUBBLE:
::	FUNCTION:	THIS ROUTINE IS CALLED WHEN:
::		A)  A NEW LINK IS COMING UP,
::		B)  ADDITIONAL CHANNELS FROM T-II TO T-II ON A LINK ARE NEEDED.
::		    TYMNET-1.5 AND TYMNET-I DO NOT BUBBLE.
::	CALLING SEQ:	JAL	R8,BUBBLE
::	RETURNS:	IMMEDIATE - NO SPACE IS AVAILABLE
::			+4 - BUBBLED
::
::*********************************************************************

:	WHEN THE NEED FOR MORE CHANNELS IS REALIZED, THE FOLLOWING
:	CODE STARTS OUT AT THE LINK NUMBER REQUESTING THE ADDITIONAL
:	CHANNELS AND SCANS TO THE RIGHT (HIGHER MEM ADDR'S) LOOKING
:	FOR AN AREA OF EMPTY PERMUTER TABLE SPACE.  IF IT FINDS SPACE
:	AVAILABLE IT MOVES ANY INTERMEDIATE LINKS INTO THAT SPACE, 
:	LEAVING THE FREE SPACE IMMEDIATELY BEHIND THE EXISTING LINK'S
:	PERMUTER TABLES.  THE LINK'S POINTERS ARE THEN ADJUSTED TO
:	REFLECT THE INCREASED CAPACITY.
:	IF NO SPACE IS FOUND AFTER THE LINK, THE PERMUTER TABLES
:	ARE SEARCHED FROM THE BEGINNING, AGAIN LOOKING FOR FREE SPACE.
:	WHEN THAT FREE SPACE IS FOUND ALL LINKS FROM THAT SPACE TO THE
:	LINK REQUESTING SPACE (INCLUSIVE) ARE SHIFTED LEFT LEAVING 
:	ROOM AGAIN BEHIND THE LINK IN QUESTION.  IT'S POINTERS ARE 
:	AGAIN UPDATED TO INCLUDE AN ADDITIONAL 1/2 PAGE OF P.T.
:	IF NO SPACE IS AVAILABLE THEN THIS ROUTINE TAKES AN ERROR
:	RETURN (NO SKIP).  

:	TRY TO FIND A HALF-PAGE FROM THE PERMUTER TABLE POOL. IF NO HALF-
:	PAGES AVAILABLE, TAKE IMMEDIATE RETURN. IF A HALF-PAGE IS FOUND,
:	INCLUDE IT IN THE DOMAIN OF PERMUTER TABLE SPACE ALLOCATED TO
:	THE LINK 'KN'.
BUBBLE	HS	0
	LR	R5,KN			:START WITH CURRENT LINK, SCAN TO END
BUBL1	LH	R0,TBDPKN+2,R5,R5	:GET NEXT LINK'S BEGIN POINTER AND
	SH	R0,EBDPKN,R5,R5		:COMPARE TO THIS LINK'S END POINTER
	JG	BUBL3			:GREATER - FOUND A BUBBLE
	AIS	R5,1			:INCREMENT LINK INDEX
	CLHI	R5,NLINKS		:END?
	JLBS	BUBL1			:NOT YET

:	REACHED FINAL LINK WITHOUT FINDING A BUBBLE. START FROM BEGINNING
:	AND SCAN UP TO LINK WE ENTERED WITH.
	LIS	R5,0
BUBL2	LH	R0,TBDPKN+2,R5,R5	:GET NEXT LINK'S BEGIN POINTER AND
	SH	R0,EBDPKN,R5,R5		:COMPARE TO THIS LINK'S END POINTER
	JG	BUBL13			:FOUND A BUBBLE
	AIS	R5,1
	CLR	R5,KN			:SCANNED ALL LINKS FOR BUBBLES?
	JLBS	BUBL2			:NO - CONTINUE
	IF	DB.DEB
	LH	R0,NUMPAG,,		:CONSISTENCY TEST - PAGES AVAIL > 0?
	JER	R8			:NO - O.K.
	DBOOPS
	ELSE	:NOT DB.DEB
	JR	R8			:YES, NON-SKIP RETURN - NO BUBBLE FOUND
	EI	:DB.DEB

BUBL3	STH	R5,BUBS1		:SAVE NUMBER OF LINK PRIOR TO BUBBLE
	LH	R3,EBDPKN,R5,R5
	LH	R4,TBDPKN+2,R5,R5
	LR	R5,R4
	SR	R5,R3			:COMPUTE SIZE OF EXISTING BUBBLE
	STH	R5,BUBS2		:AND SAVE
	SRLS	R5,1			:NUMBER OF CHANNELS IN BUBBLE
	LR	R1,R3			:GET BEGIN-BUBBLE POINTER, COMPUTE DIST
	SH	R1,EBDPKN,KN,KN		:BACK TO END OF CURRENT LINK'S TABLES
	STH	R1,BUBS3		:SAVE FOR POSSIBLE POST-MORTEM

:	BUBS1 -	LINK NUMBER OF LINK PRIOR TO BUBBLE
:	BUBS2 -	BUBBLE SIZE
:	R1 -	# BYTES FROM END OF CURRENT LINK'S TABLES TO BEGINNING OF BUBBL
:	R3 -	POINTER TO BEGINNING OF BUBBLE
:	R4 -	POINTER TO END OF BUBBLE
:	R5 -	NUMBER OF CHANNELS IN BUBBLE

:	ALL TABLES FROM THE END OF THE CURRENT LINK TO THE BEGINNING OF THE
:	BUBBLE MUST BE MOVED SO THAT THE BUBBLE FOLLOWS THE CURRENT LINK (KN).
BUBL4	SIS	R3,2
	SIS	R4,2			:MOVING A HW AT A TIME
	SIS	R1,2			:NUMBER OF BYTES REMAINING TO MOVE
	JL	BUBL5			:DONE

	LHL	R2,NIOTAB,R3,		:MOVING FROM LEFT..
	STH	R2,NIOTAB,R4,		:..TO RIGHT
	JEBS	BUBL4			:NULL ENTRY
	LIS	R0,0
	STH	R0,NIOTAB,R3,		:DON'T LEAVE JUNK BEHIND
	LHL	R0,BPSCNT,R3,
	STH	R0,BPSCNT,R4,		:MOVE BACKPRESSURE RESTRICTION COUNT
	NHI	R2,-4			:ISOLATE BUFFER INDEX FROM P.T. ENTRY
	XHI	R2,4			:BUFFER INDEX POINTS TO P.T. ENTRY
	LH	R0,BF,R2,
	JE	BUBL4			:BF ZERO
	AR	R0,R5			:RE-COMPUTE BF BASED ON NUMBER
	STH	R0,BF,R2,		:OF CHANNELS DIFFERENCE
	SHI	R0,LNKZFL		:CONSISTENCY CHECK TO INSURE BF POINTS
	SLLS	R0,1			:TO CHANNEL JUST MODIFIED
	CR	R0,R4
	JE	BUBL4			:POINTER CONSISTENT WITH NIOTAB INDEX
	CRASH.(.BUBCR)
:	PERMUTER TABLES MOVED...NOW COPY BIT ARRAYS
BUBL5	LH	R5,BUBS1		:GET BACK NUMBER OF LINK PRIOR TO BUBBL
	CLR	R5,KN			:BUBBLE DIRECTLY BEHIND CURRENT LINK?
	JE	BUBL9			:YES, NO TABLES MOVED,
					: SO NO BIT ARRAYS TO COPY
	LH	R3,EBDPKN,R5,R5
	LH	R4,TBDPKN+2,R5,R5
	LR	R1,R3			:RE-COMPUTE NUMBER OF TABLE BYTES MOVED
	SH	R1,EBDPKN,KN,KN		:TO KNOW HOW MUCH OF BIT ARRAYS TO COPY
	SRLS	R3,4			:SET UP INDEX REGS
	SRLS	R4,4			: FOR COPYING BIT ARRAYS
BUBL6	SIS	R3,4
	SIS	R4,4			:DECREMENT FOR NEXT FULLWORD COPY
	SHI	R1,40			:20 CHANNELS/WORD * 2 BYTES/CHANNEL
	JLFS	BUBL7			:FINISHED BIT ARRAY COPY
	JAL	R2,BUBSUB		:COPY BIT VALUES TO NEW POSITION
	JBS	BUBL6
:	NOW UPDATE POINTERS FOR ALL LINKS WHICH HAD P.T. TABLES MOVED
BUBL7	LH	R0,BUBS2		:BUBBLE SIZE
	LR	R1,R0
	SRLS	R1,1			:NUMBER OF CHANNELS MOVED
	LR	R3,R1
	SRLS	R3,3			:NUMBER OF CHANNELS/8 = BYTE
					: DISPLACEMENT FOR LINK BIT ARRAYS
	LHI	R4,1,KN			:LINK NUMBER OF LINK AFTER CURRENT LINK
BUBL8	AHM	R1,LKZFKN,R4,R4		:ADJUST ABS CHANNEL # WHERE LINK BEGINS
	AHM	R0,TBDPKN,R4,R4		:ADJUST ALL TABLE ADDRESS POINTERS BY
	AHM	R3,FLDPKN,R4,R4		: ACTUAL BYTE DISPLACEMENT
	AHM	R3,LKFGND,R4,R4
	AHM	R3,LKSVND,R4,R4
	AHM	R3,LKBPND,R4,R4
	AHM	R0,EBDPKN,R4,R4
	LR	R2,R3			:ASSUME WE'RE SLAVE ON THIS LINK
	LB	R6,MASTKN,R4,		:0 IF SLAVE, 1 IF MASTER
	JEFS	BUBL8C			:SLAVE, ALLOCATE CHANS FROM BOTTOM UP
	LIS	R2,0			:MASTER.  WE USE NEGATIVE ACP, CHS,
	SR	R2,R3			: AND MUST ADJUST POINTERS IN NEGATIVE
					: DIRECTION, CHANNEL SCAN FROM TOP DOWN
BUBL8C	AHM	R2,LKAPND,R4,R4		:POINTER TO LAST HW IN ACP ARRAY
	AHM	R2,LKCSND,R4,R4		:POINTER TO LAST HW IN CHS ARRAY
	AIS	R4,1			:ANY MORE LINKS REQUIRE ADJUSTMENT?
	CLR	R4,R5
	JLE	BUBL8			:YES - CONTINUE

:	ALLOCATE BUBBLE TO CURRENT LINK'S (KN) DOMAIN
BUBL9	LHI	R0,80			:NUMBER OF CHANNELS PER HALF-PAGE
	AHM	R0,NCHN,KD
	LHI	R3,10			:BYTE DISPLACEMENT FOR CHAN BIT ARRAY
	AR	R0,R0
	AHM	R3,LKFGND,KN,KN		:ADJUST END POINTERS TO REFLECT
	AHM	R3,LKSVND,KN,KN		:ADDITIONAL CHANNELS AVAILABLE TO LINK
	AHM	R3,LKBPND,KN,KN
	AHM	R0,EBDPKN,KN,KN
	LB	R0,MASTKN,KN,		:ARE WE MASTER OR SLAVE ON THIS LINK?
	JNFS	BUBL9C			:MASTER
	AHM	R3,LKAPND,KN,KN		:SLAVE - ADJUST END POINTERS
	AHM	R3,LKCSND,KN,KN
BUBL9C	LH	R0,NUMPAG,,
	SIS	R0,1			:DECREMENT NUMBER OF AVAILABLE PAGES
	STH	R0,NUMPAG,,
	SIS	R0,2			:RUNNING LOW ON FREE HALF-PAGES?
	JGFS	BUBL10			:NO
	LHI	R0,1F-PGMSRK		:YES - SCHEDULE PROCESS TO SEE
	SBT	R0,SQUEUE		:IF ANY LINKS COULD USE SOME SHRINKING
:	NEW HALF-PAGE ALLOCATED TO LINK. INITIALIZE NIOTAB ENTRIES TO ZERO.
BUBL10	LIS	R0,0
	LHI	R1,40
	LHL	R2,EBDPKN,KN,KN		:END OF TABLES POINTER
BUBL11	ST	R0,NIOTAB-4,R2,		:ZERO PERMUTER TABLE ENTRY
	SIS	R2,4			:WORKING BACKWARDS THROUGH TABLE
	SIS	R1,1			:DONE?
	JGBS	BUBL11			:NO - CONTINUE
:	INITIALIZE FLAGS TO ZERO AND ACP, CHS (POSITIVE AND NEGATIVE) TO
:	ONES. CLEAR GUSH AND TRIKLE.
	LHL	R2,LKZFKN,KN,KN		:CHANNEL 0 FOR LINK (DISTANCE FROM ACP)
	AH	R2,NCHN,KD		:NEW NUMBER OF CHANNELS MINUS 80 POINTS
	SHI	R2,80			:TO NEWLY ACQUIRED HALF-PAGE
	SRLS	R2,3			:DIVIDE BITS/8 FOR BYTE DISPLACEMENT
	LCS	R3,4
	SR	R3,R2			:INDEX FOR NEGATIVE ACP, CHS
	LCS	R4,1
	LIS	R1,4			:HALF-PAGE BIT ARRAY IS 4 WORDS LONG
BUBL12	ST	R0,NFLAGS,R2,
	ST	R0,GUSH-LNKZFL/8,R2,
	ST	R0,TRIKLE-LNKZFL/8,R2,
	ST	R0,NEEDLE-LNKZFL/8,R2,
	ST	R0,PRIRTY-LNKZFL/8,R2,
	ST	R0,CMDCTS-LNKZFL/8,R2,
	ST	R4,ACP,R2,
	ST	R4,CHS,R2,		:INDICATE THESE CHANNELS AVAILABLE
	ST	R4,ACP,R3,
	ST	R4,CHS,R3,
	SIS	R3,4
	AIS	R2,4
	SIS	R1,1
	JG	BUBL12
:	TABLES, ARRAYS, AND FLAGS FIXED. RE-COMPUTE CHANNEL MAP.
	LIS	R2,4			:START WITH 2ND ENTRY IN CHNMAP
	LHI	R1,(NLINKS-1)*2		:CHNMAP ORDERED FROM HIGHEST LINK
BUBLF	LHL	R0,LKZFKN,R1,		:GET ABS CHAN # FOR THIS LINK'S CHN 0
	STH	R0,CHNMAP,R2,		:STORE IN CHANNEL MAP FOR PROBE TRACE
	AIS	R2,4
	SIS	R1,2
	JGEBS	BUBLF			:DO FOR ALL LINKS

:	CONSISTENCY CHECK FOR LKAPND IF WE ARE SLAVE...
	LHI	R9,NLINKS-1
BUBLF1	LB	R0,MASTKN,R9,		:ONLY EDIT IF WE ARE SLAVE
	JN	BUBLF2			:WE'RE MASTER
	LHL	R0,LKSVND,R9,R9
	SI	R0,CHSRVD,		:COMPARE 'END OF' POINTER WE HAVE
	LHL	R10,LKAPND,R9,R9	:CONFIDENCE IN TO LKAPND FOR SAME
	SHI	R10,LNKACP		:DISTANCE FROM RESPECTIVE ORIGINS
	CR	R0,R10			:SHOULD BE EQUAL
	JEFS	BUBLF2			:O.K.
	CRASH.(.BUBC0)
BUBLF2	SIS	R9,2			:DO FOR ALL LINKS
	JGE	BUBLF1

	TBT	KN,ALINKS		:LINK JUST COMING UP?
	JE	4,R8			:YES, MAKE NO REPORT FOR INITIAL BUBBLE
	ST	R8,RTMT2		:SAVE LINK REGISTER FOR CALL TO SUP12
	LIS	R0,NR.BUB		:INDICATE TYPE OF REPORT 
	JAL	R10,SUP12L,,		:REPORT LINK BUBBLE TO SUPERVISOR LOG
	L	R8,RTMT2
	J	4,R8			:SKIP RETURN

:	FOUND A BUBBLE BEFORE CURRENT LINK
BUBL13	STH	R5,BUBS1		:SAVE NUMBER OF LINK PRIOR TO BUBBLE
	LH	R3,TBDPKN+2,R5,R5	:FIRST HW AFTER BUBBLE
	LH	R4,EBDPKN,R5,R5		:FIRST HW OF BUBBLE
	LR	R5,R4
	SR	R5,R3			:COMPUTE NEGATIVE BUBBLE SIZE
	STH	R5,BUBS2
	SRA	R5,1			:NEGATIVE NUMBER OF CHANNELS IN BUBBLE
	LH	R1,EBDPKN,KN,KN		:# OF BYTES TO MOVE IS DIFF BETWEEN
	SR	R1,R3			: END OF CURRENT LINK'S TABLES (KN)
					: AND END OF BUBBLE
	STH	R1,BUBS3		:SAVE FOR INTERESTED OBSERVER

:	BUBS1 -	LINK NUMBER OF LINK PRIOR TO BUBBLE
:	BUBS2 -	NEGATIVE BUBBLE SIZE
:	R1 -	NUMBER OF BYTES TO MOVE
:	R3 -	POINTER TO END OF EXISTING BUBBLE
:	R4 -	POINTER TO BEGINNING OF EXISTING BUBBLE
:	R5 -	NEGATIVE NUMBER OF CHANNELS IN BUBBLE
	SIS	R3,2
	SIS	R4,2
:	MOVE TABLES INTO AREA WHICH IS CURRENTLY A BUBBLE. MEMORY WHICH IS
:	VACATED BY MOVE BECOMES NEW BUBBLE, DIRECTLY BEHIND CURRENT LINK.
BUBL14	AIS	R3,2
	AIS	R4,2
	SIS	R1,2			:MOVED ALL PERMUTER TABLE ENTRIES?
	JL	BUBL15			:YES

	LHL	R2,NIOTAB,R3,		:MOVING FROM RIGHT..
	STH	R2,NIOTAB,R4,		:..TO LEFT
	JEBS	BUBL14			:NULL P.T. ENTRY
	LIS	R0,0
	STH	R0,NIOTAB,R3,		:CLEAN UP BEHIND US
	LH	R0,BPSCNT,R3,
	STH	R0,BPSCNT,R4,		:MOVE BUFFER RESTRICTION COUNT
	NHI	R2,-4
	XHI	R2,4			:GET BF WHICH POINTS TO THIS P.T. ENTRY
	LH	R0,BF,R2,
	JE	BUBL14			:BF ZERO
	AR	R0,R5			:DECREMENT BF, P.T. ENTRY AT LOWER ADDR
	STH	R0,BF,R2,
	SHI	R0,LNKZFL		:TEST CHANNEL # AGAINST NIOTAB INDEX
	SLLS	R0,1
	CR	R0,R4			:INSURE POINTING TO PROPER IOTAB ENTRY
	JE	BUBL14			:O.K.
	CRASH.(.BUBC1)
:	PERMUTER TABLE ENTRIES MOVED...COPY BIT ARRAYS
BUBL15	LH	R5,BUBS1		:GET # OF LINK WHICH WAS BEFORE BUBBLE
	LH	R3,TBDPKN+2,R5,R5	:SOURCE..
	LH	R4,EBDPKN,R5,R5		:..DESTINATION
	LH	R1,EBDPKN,KN,KN
	SR	R1,R3			:RE-COMPUTE NUMBER OF BYTES MOVED
	SRLS	R3,4
	SRLS	R4,4			:BIT ARRAY INDEX
	SIS	R3,4
	SIS	R4,4
BUBL16	AIS	R3,4
	AIS	R4,4			:INCREMENT FOR NEXT FULLWORD COPY
	SHI	R1,40
	JLFS	BUBL17			:FINISHED BIT ARRAY COPY
	JAL	R2,BUBSUB		:COPY BIT VALUES TO NEW POSITION
	JBS	BUBL16
:	NOW DECREMENT POINTERS FOR ALL LINKS WHICH HAD P.T. ENTRIES MOVED
BUBL17	LH	R0,BUBS2		:NEGATIVE BUBBLE SIZE
	LR	R1,R0
	SRA	R1,1			:NEGATIVE NUMBER OF CHANNELS
	LR	R3,R1
	SRA	R3,3			:NUMBER OF CHANNELS/8 = BYTE
					: DISPLACEMENT FOR LINK BIT ARRAYS
	AIS	R5,1			:INCREMENT R5 TO FIRST LINK MOVED
BUBL18	AHM	R1,LKZFKN,R5,R5		:ADJUST ABS CHAN # WHERE LINK BEGINS
	AHM	R0,TBDPKN,R5,R5		:ADJUST ALL TABLE ADDRESS POINTERS BY
	AHM	R3,FLDPKN,R5,R5		: ACTUAL BYTE DISPLACEMENT
	AHM	R3,LKFGND,R5,R5
	AHM	R3,LKSVND,R5,R5
	AHM	R3,LKBPND,R5,R5
	AHM	R0,EBDPKN,R5,R5
:	DECREMENTING POINTERS IS ACTUALLY MOVING THEM CLOSER TO ORIGIN. IF
:	WE ARE MASTER ON THIS LINK, ACP AND CHS POINTERS SHOULD BE INCREMENTED.
	LR	R2,R3			:ASSUME WE ARE SLAVE
	LB	R6,MASTKN,R5,		:ARE WE MASTER OR SLAVE?
	JEFS	BUB18C			:SLAVE
	LIS	R2,0			:MASTER - CHANGE DIRECTION OF
	SR	R2,R3			:POINTER UPDATE
BUB18C	AHM	R2,LKAPND,R5,R5		:POINTER TO LAST HW IN ACP FOR LINK
	AHM	R2,LKCSND,R5,R5		:POINTER TO LAST HW IN CHS FOR LINK
	AIS	R5,1			:DO FOR ALL LINKS WHICH GOT P.T. MOVED
	CLR	R5,KN
	JLE	BUBL18			:UP TO AND INCLUDING CURRENT LINK
	J	BUBL9

::*********************************************************************
::
::	SUBROUTINE:	BUBSUB:
::	FUNCTION:	COPY BIT ARRAYS
::	CALLING SEQ:	JAL	R2,BUBSUB
::
::*********************************************************************

BUBSUB	HS	0			:SUBROUTINE FOR COPYING BIT ARRAYS
	L	R0,GUSH,R3,
	ST	R0,GUSH,R4,		:COPY 'GUSH', R3 SOURCE, R4 DESTINATION
	L	R0,TRIKLE,R3,
	ST	R0,TRIKLE,R4,		:TRIKLE
	L	R0,LNKFLG,R3,
	ST	R0,LNKFLG,R4,
	IF	APLYBP		:For Aply Backpressure only
	L	R0,APBPVD,R3,
	ST	R0,APBPVD,R4,
	EI	:APLYBP
	L	R0,LNKBPV,R3,
	ST	R0,LNKBPV,R4,
	L	R0,CHSRVD,R3,
	ST	R0,CHSRVD,R4,
	L	R0,BPSVCP,R3,
	ST	R0,BPSVCP,R4,
	L	R0,NEEDLE,R3,
	ST	R0,NEEDLE,R4,
	L	R0,PRIRTY,R3,
	ST	R0,PRIRTY,R4,
	L	R0,CMDCTS,R3,
	ST	R0,CMDCTS,R4,
	L	R0,LNKACP,R3,
	ST	R0,LNKACP,R4,
:	COPY 'NEGATIVE' ACP, CHS. USE R14, R15 AS INDEX REGS FOR OPPOSITE
:	POLARITY.
	STM	R14,LNKRGS		:PRESERVE REGS
	LCS	R14,4
	SR	R14,R3			:NEGATIVE SOURCE
	LCS	R15,4
	SR	R15,R4			:NEGATIVE DESTINATION
	L	R0,EKNACP,R14,
	ST	R0,EKNACP,R15,
	L	R0,EKNCHS,R14,
	ST	R0,EKNCHS,R15,
	LM	R14,LNKRGS
	JR	R2			:RETURN

	SUBTTL	UTIL (SHRINK)

::*********************************************************************
::
::	PROCESS:	MSHRNK:
::	FUNCTION:	SEE IF ANY LINKS NEED P.T. SHRINK
::	SCHEDULED:	Every 8 minutes.  Dismisses to EXEC loop.
::
::*********************************************************************

MSHRNK	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(MSHRNK)			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU
:	LHI	R9,-2*NLINKS
:MSHRN1	L	KD,KDKN+2*NLINKS,R9,R9
	LHI	R9,4*(NLINKS-1)         :do link 0,1,n-1                ###sdw
MSHRN1	L	KD,KDKN,R9,
	LB	R0,KTYP,KD		:GET LINK TYPE	###EV
	JE	MSHRN2			:NO - CAN ONLY SHRINK T-II LINKS
	LH	R0,SHSTAT,KD		:IS SHRINK IN PROGRESS?
	JN	MSHRN2			:YES - ONLY ONE AT A TIME
	LB	R0,NLAT,KD		:IS LINK UP?
	JE	MSHRN2			:NOT IF NO LINES ATTACHED
	LH	R0,NEDOUT,KD		:ARE ANY NEEDLES OUTSTANDING BETWEEN
					: CRQ AND RMAKE?
	JN	MSHRN2			:YES, AVOID POSSIBLE RACE, DEFER SHRINK
:	SEE IF ENOUGH INACTIVE CHANNELS TO CALL FOR SHRINK.
:	IF 4*(# INACTIVE CHANNELS) >= (MAX # CHANNELS)+600,
:	THEN REQUEST A SHRINK FOR THIS LINK
	LH	R0,NCHN,KD		:3*NCHN-4*ANCHN-600
	CLHI	R0,80
	JLEFS	MSHRN2			:DON'T CONSIDER LINK WITH ONLY 80 CHANS
	SH	R0,ANCHN,KD
	SLLS	R0,2
	SH	R0,NCHN,KD
	SHI	R0,$A 600
	JLFS	MSHRN2
	LIS	R0,2			:LOTS OF SPARE CHANNELS...
	STB	R0,SHSTAT,KD		:DO A SHRINK
MSHRN2
	SIS	R9,4                    :standard loop all links        ###sdw
	JGE	MSHRN1			:CHECK ALL LINKS
	J	EXDISM,,		:DONE

	SUBTTL	UTIL (FIND)

::*********************************************************************
::
::	SUBROUTINE:	FNDHST:
::	FUNCTION:	LOCATES A HOST IN THE HOST TABLES.
::	CALLING SEQ:	JAL	R9,FNDHST
::	INPUT:		R1  = HOST NUMBER
::	OUTPUT:		R13 = HN = HOST INDEX
::	PRESERVED:	R1
::	RETURNS:	IMMEDIATE = NONEXISTENT HOST
::			+4 = HOST FOUND
::
::*********************************************************************

FNDHSL	LIS	R1,0			:>>ENTER HERE TO FIND NEXT FREE ENTRY<<
FNDHST	HS	0			:>>ENTER HERE TO FIND A GIVEN HOST<<
	LHI	HN,NHOSTS-1
FNDHS1	CLH	R1,HOSTN,HN,HN
	JE	4,R9			:FOUND IT, SKIP 4 BYTES
	SIS	HN,1
	JGEBS	FNDHS1
        LR      HN,R1   	        :RESTORE HOST NUMBER AND EXIT  ###LH
	JR	R9			:NONEXISTENT HOST

::*********************************************************************
::
::	SUBROUTINE:	FNDLNK:
::	FUNCTION:	LOCATES THE LINK DESCRIPTOR TO A GIVEN NEIGHBOR.
::			SETS REGISTERS 'KN' AND 'KD' TO THE APPROPRIATE VALUES.
::	CALLING SEQ:	JAL	R9,FNDLNK
::	INPUT:		R1 = NEIGHBOR # (PRESERVED)
::	RETURNS:	SKIP RETURN IF FOUND, ELSE TAKES IMMEDIATE RETURN.
::
::*********************************************************************
FNDLNK	HS	0
	LHI	KN,NLINKS-1		:HIGHEST LINK #
FNDLN1	SLL	KN,1
	L	KD,KDKN,KN,KN		:LINK DESCRIPTOR FOR THIS LINK
	SRL	KN,1
	CLH	R1,NDID,KD
	JE	4,R9			:FOUND IT, SKIP 4 BYTES
	SIS	KN,1
	JGEBS	FNDLN1
	JR	R9			:NONEXISTENT LINK, TAKE IMMED RETURN

::*********************************************************************
::
::	SUBROUTINE:	FCHLNK:
::	FUNCTION:	LOCATES THE LINK NUMBER TO THE ABSOLUTE CHAN#
::	CALLING SEQ:	JAL	R9,FCHLNK
::	INPUT:		R3 = ABSOLUTE CHAN NUMBER
::	DESTROYED:	R0,R1
::	RETURNS:	SKIP RETURN IF FOUND, ELSE TAKES IMMEDIATE RETURN.
::	OUTPUT:		R0 IS THE LINK#
::
::*********************************************************************
FCHLNK	HS	0
	LHI	R0,0		:INIT LINK# 0
	CLH	R3,LKZFKN,,	:TABLE OF ABSOLUTE CHAN# FOR 1ST CHANS
	JLR	R9		:ERR RETURN IF <LNKZFL
	CHI	R3,LNKLFL	:MAX CHAN#
	JGR	R9		:ERR RETURN IF >LNKLFL
	LIS	R1,2		:LINK PTR. TO LKZFKN TABLE
FCK01	CLH	R3,LKZFKN,R1,
	JL	4,R9		:WE GOT IT, GOOD RETURN
	CHI	R1,2*TCHANS	:MAX. PTR.
	JE	4,R9		:END OF LAST CHAN#
	AIS	R0,1		:INC. LINK#
	AIS	R1,2		:INC. PTR.
	JBS	FCK01		:TRY NEXT ONE

::*********************************************************************
::
::	SUBROUTINE:	FNDCRQ:
::	FUNCTION:	LOCATES A GIVEN CIRCUIT FOR CRQ/LEP.
::	CALLING SEQ:	JAL	R9,FNDCRQ
::	OUTPUT:
::		IF INVOICE NUMBER FOUND:
::			R6 = OUTBOUND BUFF #
::			R7 = HISTORY BUFFER #
::		IF INVOICE NUMBER NOT FOUND, R0 = 0
::		IF INVOICE NUMBER FOUND BUT BF ISN'T A STUB, R0 = -1
::	DESTROYED:	R0, R1
::	RETURNS:	IMMEDIATE RETURN IF BUFFER NOT FOUND
::			+4 SKIP RETURN IF A MATCH IS FOUND
::
::*********************************************************************

:	FNDCRQ STEPS THROUGH ALL HISTORY BUFFER NUMBERS, BEGINNING AT HBUFN,
:	LOOKING FOR A BUFFER WHOSE INVOICE NUMBER MATCHES CQINV AND WHOSE
:	BF IS A STUB. SKIP RETURNS IF A MATCH IS FOUND, ELSE IMMEDIATE RETURN

	IF	REBILD
FNDCRQ	L	R1,CQINV		:SEARCH ON INVOICE #
	LIS	R0,0			:SET R0=0, INDICATE INVOICE # NOT FOUND
	LI	R7,LBUFN-HBUFN-4	:START AT LAST HISTORY BUFFER
FNDCR1	CL	R1,RINVC+HBUFN,R7,	:DOES IT'S INVOICE NUMBER MATCH CQINV?
	JEFS	FNDCR2			:YES, POSSIBLE MATCH
	SIS	R7,4			:NO, ADVANCE TO NEXT BUFFER
	JGEBS	FNDCR1			:KEEP LOOKING IF MORE LEFT
	JR	R9			:AT END OF HISTORY BUFFERS, NO MATCH.
					: RETURN
FNDCR2	LCS	R0,1			:SET R0= -1 TO INDICATE INVOICE # FOUND
	LR	R6,R7			:COMPUTE OUTBOUND BUFF #
	AI	R7,HBUFN		:AND THE ABSOLUTE HISTORY BUFFER NUMBER
	SLHLS	R6,1
	LHL	R1,BF,R6,		:CHECK FOR STUB AT THE OTHER END
	CLHI	R1,STUBFL
	JE	4,R9			:YES, THIS IS A GOOD STUB... RETURN
	AIS	R6,4			:NO, ARE WE LOOKING AT WRONG SIDE...
	LHL	R1,BF,R6,
	CLHI	R1,STUBFL
	JE	4,R9			:FOUND THE STUB, RETURN
	JR	R9			:CAN'T FIND A STUB, RETURN WITH R0= -1
	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	FNDCHN:
::	FUNCTION:	LOCATES A FREE PORT
::	CALLING SEQ:	JAL	R9,FNDCHN
::	INPUT:		R5 = INITIAL CHANNEL # (CHN)
::			R1 = # OF CHANNELS TO SEARCH
::	DETROYED:	R0
::	RETURNS:	SKIPS IF FOUND, ELSE TAKES IMMEDIATE RETURN.
::
::*********************************************************************

FNDCHN	HS	0
	LHL	R0,IOTAB,CHN,CHN	:IS THIS CHANNEL FREE?
	JN	FNDCH2			:NO
	TBT	CHN,ACP,,		:YES - ACP SHOULD BE CONSISTENT
	JE	FNDCRS			:ACP INDICATES CHANNEL NOT AVAILABLE,
					: - OOOPS!
	LCS	R0,1			:CHECK NEGATIVE ACP ARRAY
	SR	R0,CHN
	TBT	R0,ACP,,
	JE	FNDCRS			:WHY IS CHANNEL NOT AVAILABLE??
	IF	ISIS
	LR	R0,R2
	LHI	R2,-DISZFL,CHN		:CHECK IF DISPATCHER PORT
	JGEFS	FNDCH1			:YES - CHECK ISIS
	LR	R2,R0
	J	4,R9			:NO - RETURN
FNDCH1	LHL	R2,PTABLE,R2,R2,	:CHECK ISIS PERMUTER TABLE
	JNFS	FNDCRS			:ISIS INDICATES CHANNEL IN USE
	LR	R2,R0			:PRESERVE R2
	EI	:ISIS
	J	4,R9			:TAKE OK RETURN
FNDCRS	CRASH.(.FNCHC)
FNDCH2	AIS	CHN,1
	SIS	R1,1
	JG	FNDCHN
	JR	R9			:NO FREE PORT FOUND

::*********************************************************************
::
::	SUBROUTINE:	FNDKNC:
::	FUNCTION:	FIND CHANNEL FOR LINK.
::	CALLING SEQ:	JAL	R9,FNDKNC
::	RETURNS:	IMMEDIATE = NO CHANNEL FOUND
::			+4 = CHANNEL FOUND
::
::*********************************************************************

:	CHANNEL IS AVAILABLE IF ACP .AND. CHS ARE SET. ARRAYAND
:	INSTRUCTION IS USED TO SCAN ACP AND CHS BIT ARRAYS.
:	EACH LINK PROVIDES POINTER TO LAST HALFWORD IN ARRAY. NCHN (NUMBER OF
:	CHANNELS ALLOCATED TO LINK) PROVIDES THE BIT COUNT FOR THE ARRAYAND.
:	THE BYTE ARRAY MASTKN INDICATES WHETHER WE ARE MASTER OR SLAVE ON THIS
:	LINK. IF WE ARE SLAVE, POINTERS DIRECT US TO THE 'POSITIVE' ACP AND CHS
:	WHERE WE SCAN FROM THE BOTTOM UP. IF WE ARE MASTER, POINTERS ARE TO
:	'NEGATIVE' ACP AND CHS, AND WE SCAN FROM THE TOP DOWN WITH REGARD TO
:	CHANNEL NUMBERS.

FNDKNC	HS	0
	STM	R14,LNKRGS		:SAVE WORK REGS
	LHL	R14,LKAPND,KN,KN	:LAST HW IN ACP ARRAY
	LHL	R15,LKCSND,KN,KN	:LAST HW IN CHS ARRAY

	IF	ESYNC
	SIS	R1,1			:NUMBER OF CHANNELS MINUS 1
	ARAND	R14,R1			:ARRAYAND, POINTERS IN R14, R15,
					: COUNT IN R1
	JFS	FNDC10			:GOT A HIT
	J	FNDC40			:NO CHANNELS AVAILABLE
FNDC10	HS	0
	ELSE	:ESYNC			:NOT ENHANCED SYNC
	SRLS	R1,3			:# OF CHANS/8 FOR BYTE COUNT
	SIS	R1,2			:LESS 2 FOR THE LAST HW
	SR	R14,R1			:FIRST WORD IN ACP FOR KN
	SR	R15,R1			:FIRST WORD IN CHS FOR KN
	LIS	CHN,0			:CHANNEL COUNT (BUMP FOR EACH WD)
FNDC09  HS	0			:START ARRAY AND LOOP
	L	R0,0,R14		:GET A WD OF ACP
	N	R0,0,R15		:AND A WD OF CHS
	JFFO	R0,FNDC10		:SEARCH FOR FREE CHANNEL
	AIS	R14,4			:NONE FREE HERE TRY AGAIN
	AIS	R15,4
	AHI	CHN,20			:BUMP # OF CHANNEL
	CLH	R15,LKCSND,KN,KN	:AT LAST HW YET?
	JLEBS	FNDC09			:NO, LOOK SOME MORE
	J	FNDC40			:YES, NONE FREE
FNDC10  HS	0
	AR	R1,CHN			:FOUND ONE, GET CHANNEL NUMBER
	EI	:ESYNC
	LM	R14,LNKRGS		:RESTORE REGISTERS.
	LB	R0,MASTKN,KN,		:ARE WE THE MASTER ON THIS LINK?
	JNFS	FNDC20			:YES
	LR	CHN,R1			:NO, SINCE WE WORK FROM BOTTOM UP,
	JFS	FNDC30			: R1 HAS LINK RELATIVE CHANNEL NUMBER
FNDC20	LHL	CHN,NCHN,KD		:NUMBER OF CHANNELS ALLOCATED TO LINK
	SIS	CHN,1			:CHN HAS HIGHEST ALLOCATD CHAN FOR LINK
	SR	CHN,R1			:HIGHEST AVAILABLE CHANNEL
FNDC30	AH	CHN,LKZFKN,KN,KN	:CONVERT TO ABSOLUTE CHANNEL
	LH	R0,IOTAB,CHN,CHN	:IS CHANNEL REALLY FREE?
	JE	4,R9			:YES - SKIP RETURN
	CRASH.(.FNCH0)
FNDC40	LM	R14,LNKRGS		:RESTORE REGS
	JR	R9			:NORMAL RETURN FOR NO CHANNEL FOUND


::*********************************************************************
::
::	SUBROUTINE:	CNTPRT	(CouNT PoRT)
::	FUNCTION:	Counts number of available ports in a port range
::	CALLING SEQ:	JAL	R10,CNTPRT
::	INPUT:		R5	=	Beginning of range
::			R1	=	Number of ports to consider
::	OUTPUT:		R3	=	Number of available ports
::	RETURNS:	JR	R10
::
::*********************************************************************
CNTPRT	HS	0
	LIS	R3,0			:Intitialize counter
CNT00	LHL	R0,IOTAB,CHN,CHN	:Check table entry
	JNFS	CNT01			:If not empty, don't count
	AIS	R3,1			:Else equal to zero - available
CNT01	AIS	CHN,1			:Next channel
	SIS	R1,1			:Done yet?
	JGBS	CNT00			:Check again
	JR	R10			:RETURN


	SUBTTL	UTIL (ACCOUNTING)

	IF	ACCT!T2GATE	:###EV

::*********************************************************************
::
::	SUBROUTINE:	AASTRT:
::	FUNCTION:	Initiates session accounting - puts invoice 
::			number in circuit accounting block - puts
::			zeroes in count fields.
::	CALLING SEQ:	JAL  R8,AASTRT
::	INPUT:		CHN = terminating channel number
::	DESTROYED:	R3, R11, R0
::	CALLS:		JAL  R9,AAMKPT	:Make pointer to accounting block
::	RETURNS:	JR  R8		:Range check error
::			JR   4,R8	:Normal return
::
::*********************************************************************

AASTRT	HS	0		:Begin accounting record
	LR	R3,CHN		:Terminating channel # (CHN is R5)
	CLHI	R3,MNACHN	:Compare with  lowest accountable chn#
	JL	AASER1		:If lower, is channel error
	CLHI	R3,MXACHN	:Compare with max  accountable channel
	JL	AASPR1		:If within, process!
AASER1	HS	0		:Circuit consistency error
	:Posssibly add some error stuff  ###ev
	JR	R8
AASPR1	HS	0		:Initiate accounting block
	SHI	R3,MNACHN	:Make accounting port index from chn #
	JAL	R9,AAMKPT	:Get FW pointer to circuit's block
GASTR1	HS	0		:Entry point for Gateway start
   IF	ACCT2
	LIS	R0,0
	STH	R0,AAIC+4,R11
    ELSE
	LI	R0,80000000
   EI		:ACCT2
	ST	R0,AAIC,R11	:Init to zeroes and acc'ting message type
   IF	ACCT2
	LIS	R0,0
	STH	R0,AAOC+4,R11
    ELSE
	LI	R0,90000000
   EI		:ACCT2
	ST	R0,AAOC,R11	:Init to zeroes and message type
   IF	ACCT2
	LH	R0,CQINV+4
	STH	R0,AAINV+4,R11
   EI	:ACCT2
	L	R0,CQINV
	ST	R0,AAINV,R11	:Store Invoice number
	J	4,R8


::*********************************************************************
::
::	SUBROUTINE:	AAMKPT
::	FUNCTION:	Gets a fullword pointer to the accounting block
::			from the array of pointers AABPNT.
::	CALLING SEQ:	JAL	R9,AAMKPT
::	INPUT:		R3 = Terminating port index
::	OUTPUT:		R11 = Fullword pointer to accounting block
::	DESTROYED:	R3
::	RETURNS:	JR	R9
::*********************************************************************

AAMKPT	HS	0
	SLHLS	R3,2		:Make fullword index
	L	R11,AABPNT,R3	:Retrieve pointer from table
	JR	R9

	EI	:###EV

	IF	ACCT	:###EV
::*********************************************************************
::
::	SUBROUTINE:	AARDIC:
::	FUNCTION:	Receive an incremental data count into a
::			host process and accumulate it in the AAIC field
::			for that circuit's accounting block.
::	CALLING SEQ:	JAL	R8,AARDIC
::	INPUT:		R0 =  Count to accumulate in AARDIC
::			R3 =  Internal host port index
::	DESTROYED:	R0, R3, R9, R11
::	CALLS:		JAL	R9,AAMKPT
::	RETURNS:	JR	R8
::
::*********************************************************************
AARDI1	HS	0		:Entry point for adding only one char
	LIS	R0,1
AARDIC	HS	0		:Expects port index in R3
	JAL	R9,AAMKPT	:Get FW pointer to acctng block
   IF	ACCT2
	AHM	R0,AAIC+4,R11	:Low halfword first if expanded field
	JNCR	R8		:Exit if no carry
	LIS	R0,1
   EI	:ACCT2
	AM	R0,AAIC,R11	:Add to count
	JR	R8		:And return


::*********************************************************************
::
::	SUBROUTINE:	AARDOC:
::	FUNCTION:	Receive an incremental data count out of a
::			host process and accumulate it in the AAOC field
::			for that circuit's accounting block.
::	CALLING SEQ:	JAL	R8,AARDOC
::	INPUT:		R0 =  Count to accumulate in AARDOC
::			R3 =  Port index
::	DESTROYED:	R0, R3, R9, R11
::	CALLS:		JAL	R9,AAMKPT
::	RETURNS:	JR	R8
::
::*********************************************************************
AARDO1	HS	0		:Entry point for adding only one char
	LIS	R0,1
AARDOC	HS	0		:Expects port index in R3
	JAL	R9,AAMKPT	:Get FW pointer to acctng block
   IF	ACCT2
	AHM	R0,AAOC+4,R11	:Low halfword first if expanded field
	JNCR	R8		:Exit if no carry
	LIS	R0,1
   EI	:ACCT2
	AM	R0,AAOC,R11	:Add to count
	JR	R8		:And return


::**********************************************************************
::
::	SUBROUTINE:	AANCZP:
::	FUNCTION:	Receives Node Code Zap reason and sends it.
::	CALLING SEQ:	JAL	R8,AANCZP
::	INPUT:		R1 = Invoice number from CQINV
::			R0 = Logout reason, for Addendum message
::	CALLS:		JAL	R9,AAMKPT	:Make pointer to acct. blk
::			JAL	R9,AAPIR	:Provides and sends inv #
::			JAL	R9,AADNDM	:Sends Addendum to accounting
::	RETURNS:	JR	R8
::
::*********************************************************************

AANCZP	HS	0		:Receive Zap reason and process
	STM	R1,AARGSV	:Save registers here
	ST	R0,AAREAS	:Save logout reason for AADNDM
	JAL	R9,AAPIR	:Provides and sends invoice number
	L	R0,AAREAS	:Get logout reason for Adendum message
	JAL	R9,AADNDM	:Sends Addendum to accounting
	LM	R1,AARGSV	:Restore registers here
	JR	R8



::**********************************************************************
::
::	SUBROUTINE:	AARLO:
::	FUNCTION:	Receives logout reason and sends final counts.
::	CALLING SEQ:	JAL	R8,AARLO
::	INPUT:		R3 = Internal host port index
::			R0 = Logout reason, for Addendum message
::	CALLS:		JAL	R9,AAMKPT	:Make pointer to acct. blk
::			JAL	R9,AAMIR	:Sends invoice number
::			JAL	R9,AACNTS	:Sends input and output counts
::			JAL	R9,AADNDM	:Sends Addendum to accounting
::	RETURNS:	JR	R8
::
::*********************************************************************

AARLO	HS	0		:Receive logout and process
	STM	R1,AARGSV	:Save registers here
	ST	R0,AAREAS	:Save logout reason for AADNDM
	JAL	R9,AAMKPT	:Make pointer to acct. blk
	JAL	R9,AAMIR	:Sends invoice number
	JAL	R9,AACNTS	:Sends input and output counts
	LIS	R0,0		:Now to reset inv # area
   IF	ACCT2
	STH	R0,AAINV+4,R11	:Put zeroes back in inv# field
   EI	:ACCT2
	ST	R0,AAINV,R11
	L	R0,AAREAS	:Get logout reason for Adendum message
	JAL	R9,AADNDM	:Sends Addendum to accounting
	LM	R1,AARGSV	:Restore registers here
	JR	R8





::*********************************************************************
::
::	SUBROUTINE:	AAMIR:	GAMIR:
::	FUNCTION:	Makes an Invoice record and sends it if necessary
::	CALLING SEQ:	JAL	R9,AAMIR
::			JAL	R9,AAPIR	: Entry for Inv # provided
::	INPUT:		R11 = Pointer to circuit's Accounting block
::			or    R1 = Invoice number from CRQ routine
::	CALLS:		JAL	R10,SUP14A
::	RETURNS:	JR	R9	:Normal return
::			JE	R8	:ERROR -- skip accounting if
::					 inv # is zero
::	:###ev (acct2 stuff to be added)
::*********************************************************************
::Gateway requires  R10 return to  skip AASWAP
GAMIR	HS	0		:Make an Accounting Invoice record
	L	R1,AAINV,R11	:Get invoice number
	JER	R10		:Error -  Skip accounting (Gateway return)
	JFS	AAPIR
AAMIR	HS	0		:Make an Accounting Invoice record
	L	R1,AAINV,R11	:Get invoice number
	JER	R8		:Error --  Skip accounting
AAPIR	ST	R9,AAR1SV	:Save return address
	C	R1,AALINS	:Compare with last inv# sent
	JER	R9		:No need to send same inv# twice
	ST	R1,AALINS	:If new, store for reference
	OI	R1,070000000	:and make a new record
	NI	R1,07FFFFFFF	:
	JAL	R10,SUP14A,,	:to send to Supervisor
	L	R9,AAR1SV	:Restore return address
	JR	R9		:  .. and return

::*********************************************************************
::
::	SUBROUTINE:	AACNTS:
::	FUNCTION:	Gets input and output counts and sends to Sup
::	CALLING SEQ:	JAL	R9,AACNTS
::	INPUT:		R11 = Pointer to circuit's accounting block
::	CALLS:		JAL	R10,SUP14A
::	RETURNS:	JR	R9
::
::*********************************************************************

AACNTS	HS	0		:Send input and ouput counts
	ST	R9,AAR1SV	:Save return register
	L	R1,AAIC,R11	:Get input count
   IF	ACCT2
	SRLS	R1,8		:Examine HO HW
	JEFS	AACNT1		:Nything there? if not skip ahead
	OI	R1,8F000000	:else build HO message
	JAL	R10,SUP14A	:and send to Sup
AACNT1	L	R1,AAIC+2,R11	:Now get low order count field
	NI	R1,00FFFFFF	:and get bits not already sent
	OI	R1,8E000000	:formulate message
   EI	:ACCT2
	JAL	R10,SUP14A,,	:and send to Sup 

	L	R1,AAOC,R11	:Get output count
   IF	ACCT2
	SRLS	R1,8		:Examine HO HW
	JEFS	AACNT2		:Nything there? if not skip ahead
	OI	R1,9F000000	:else build HO message
	JAL	R10,SUP14A,,	:and send to Sup
AACNT2	L	R1,AAOC+2,R11	:Now get low order count field
	NI	R1,00FFFFFF	:and get bits not already sent
	OI	R1,9E000000	:formulate message
   EI	:ACCT2
	JAL	R10,SUP14A,,	:and send to Sup 
	L	R9,AAR1SV	:Restore return register
	JR	R9		:and return


::*********************************************************************
::
::	SUBROUTINE:	AADNDM:
::	FUNCTION:	Sends Addendum to Accounting message
::	CALLING SEQ:	JAL	R9,AADNDM
::	INPUT:		R0 = logout reason for Addendum message
::			R11= pointer to crcuit's accounting block
::	CALLS:		JAL	R10,SUP14A,,
::	RETURNS:	JR	R9
::
::*********************************************************************

AADNDM	HS	0		:Send Addendum to Accounting
	ST	R9,AAR1SV	:Save return address
	LI	R1,0E0000000	:Load Addendum message type 
	OR	R1,R0		:Put in logout reason
	NI	R1,0F0FFFFFF	:Ensure Addendum subtype zero
	JAL	R10,SUP14A,,	:Send to Sup
	L	R9,AAR1SV	:Restore return
	JR	R9



::*********************************************************************
::
::	SUBROUTINE:	AATIME:
::	FUNCTION:	Provides periodic reporting of accounting
::	CALLING SEQ:	JAL	R11,AATIME,,
::	CALLS:		JAL	R9,AAMKPT
::			JAL	R9,AAPIR
::			JAL	R9,AACNTS
::	RETURNS:	JR	R11
::
::*********************************************************************
AATIME	HS	0			:Perform periodic accounting
	ST	R11,AAR2SV		:Save return
	LHI	R3,NACCTS-1		:R3 used for  port index
AATM01	ST	R3,AASVCT		:Got to save R3
	JAL	R9,AAMKPT		:Get pointer to accounting block
	L	R1,AAINV,R11		:Check inv # - see if active	
	JEFS	AATM02			:If inactive go to next port
	LR	R0,R1
	NI	R0,80000000		:Is high order bit set?
	JL	AATM02			:If so, skip reporting
	JAL	R9,AAPIR		:Else make invoice record
	JAL	R9,AACNTS		:  ... and send counts
AATM02	L	R3,AASVCT		:What was that count of ports?
	SHI	R3,1			:Decrement counter to nxt port ndx
	JGE	AATM01			:Repeat until port 0 completed
	L	R11,AAR2SV		:Restore return
	JR	R11

	IF	T2GATE
::*********************************************************************
::
::	SUBROUTINE:	AASWAP:
::	FUNCTION:	Swaps invoice numbers between networks
::	CALLING SEQ:	JAL	R10,AASWAP,,
::	INPUT:		CHN	=  Relative Dispatcher port to send
::			ININV	=  Invoice number from INET
::	CALLS:	AAMIR,SUP14A,DIZSMS
::	DESTROYED:	R8,R9,R1,R3,R4
::	RETURNS:
::
::*********************************************************************

AASWAP	HS	0
	ST	R10,AAR2SV,,		:SAVE RETURN
	PUSH(R5)			:Save Channel number (CHN)
:	SEND DATA TO HNET
	JAL	R9,GAMIR		:SEND INVOICE RECORD
	L	R1,ININV,,		:GET PRIMARY INVOICE#
	OI	R1,0E9000000		:ADD ACCT MSG TYPE
	JAL	R10,SUP14A,,		:Send to HNET sup
:	NOW SEND DATA TO INET
	L	R4,AAINV,R11,		:GET SECONDARY NET INVOICE#
	OI	R4,0E9000000		:ADD MSG TYPE
	ST	R4,GB7INV,,		:STORE IN CANNED MSG
	LA	R1,GDB7M,,		:ADDR OF CANNED MSG
	LHI	R3,GDB7L
	POP(R5)				:Restore CHN
	SHI	CHN,DISZFL		:and make into Dispatcher port #
	STH	CHN,GB7PRT,,		:for insertion into message
	JAL	R8,DIZSMS,,		:Output to dispatcher
	L	R10,AAR2SV,,		:RESTORE RETURN
	JR	R10			:RETURN
	EI	:T2GATE	

	EI	:ACCT		###EV

	SUBTTL	UTIL (SOLOCS)

::*********************************************************************
::
::	LABEL:		NCS0ND:
::	FUNCTION:	MARK END OF NODE CODE'S PORTION OF SEG0
::	NOTE:		DO NOT MOVE - PLACED AT END OF TII05.R## FILE
::			TO MARK BEGINNING OF SEG0 FOR CONSAT
::
::*********************************************************************

	IF	SOLOCS
	SEG	0
NCS0ND	EQ	.
	ORG	CSS0BG
	EI	:SOLOCS


	ENDMO.(UTIL)

	EI	:1-KILLIT

	KILMSG(UTIL)

:	***NOTHING PAST THIS POINT***
  1K/X