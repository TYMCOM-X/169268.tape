
	SUBTTL  SHARE

:			*****     ***** *****
:			  *         *     *
:			  *   ***   *     *
:			  *         *     *
:			  *       ***** *****

:		   	TYMNET II NODE CODE

: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source  code  listing  constitutes  the proprietary   **
: **  property of MDC-TYMNET.  The recipient, by receiving this   **
: **  program listing, agrees that neither this listing nor the   **
: **  information disclosed herein nor any part thereof shall be  **
: **  reproduced or transferred to other documents or used or dis-**
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by MDC-TYMNET. **
: ******************************************************************

  REMARK%%This is special test code.  Unauthorized use is strictly prohibited
  remark%%and very unwise.  The code is to be used only where authorized by
  remark%%NTS/STS.                                    sdw    7/11/89%%%

        if      (netid-1)*((netid-$a56)&$00ffff)  :not tymnet or nts
  remark%%The target network is not an approved network.  This code is
  remark%%highly modified Node Code and you had better have a very good
  remark%%reason to use experimental code.  Only a fool would try code
  remark%%without knowing about the changes.
  remark%%%
        ei

:			 **** *   *   *   ****  *****
:			*     *   *  * *  *   * *
:			 ***  ***** ***** ****  ****
:			    * *   * *   * *  *  *
:			****  *   * *   * *   * *****

::#####################################################################
::
::	MODULE:		SHARE
::
::	FUNCTION:  Define the default value of 'IF' switches and
::		   equates symbols.  Checks configuration and kills
::		   the tymfile macros that are no longer needed.
::
::	SUBTTLS:   None
::		   
::#####################################################################

:	DEFINE KILLIT TO ENABLE ASSEMBLY.  IF KILLIT GETS SET > 0,
:	ASSEMBLY STOPS IMMEDIATELY!

KILLIT	EQ	0
	IF	(1-KILLIT)	:OK to assemble

	RA	0		:INITIALIZE TO HEX RADIX

::*********************************************************************
::
::      KILL TYMFILE MACROS
::
::*********************************************************************

        KILL    TIILNK,TYMNET,GGHOST,HLIMIT,SLIMIT,BAUD,STRLNK
        KILL    STRLIN
	KILL	TYMNODE,ASSMBL,SLOT,LINES,TYMLINK

	KILL	NODE,HARDWARE,SLOT,CIRCUITS,LIMITS,LU,TYMNET,.SET.,SET
	KILL	ERROR,ERREND,.RANGE,.LURNG,.MLURG,.BIT.,ENABLE,DISABLE
	KILL	Q,QQ,SI.AV0,SI.AV1,SI.AV2,SI.AV3,S.AV,A.AV,P.AV
	KILL	XPI.AV,EBS.AV,DT.AV,..EQ..,..GT..,..LT..,..35..
	KILL	MINI,TSI,PICO,NANO,HDLC,HDLCMI,MAC1,MACI,MAC2,MACII
	KILL	MAC3,MACIII,XPI,XPIMI,EBUS,EBUSMI,DISK,TAPE,DISK10
	KILL	XRAY,DISPAT,PASSTH,AUX.AUXCIR,SUS,SUSPEND,PRINT
	KILL	ASAT,ACOM,XCOM,PBH,PBT,TII,BBXS,ELF,RAM,VAL,NVAL
	KILL	ISCS,SDLC,TNTT,UTSH,NTRH,VMB,NEM,TMCS,CMTI,TRSW
	KILL	ITI,UTST,TOM,LEM,MUX,PBOM,SOM,PAOM,TLXG,XOM,NTRT
	KILL	XPC,SNA,SNAT,SNAH,TNTH,CMTU,NTCN,ISRM,MSRV,MSV
	KILL	SHMN,IHSA,I2G2,LHOS,MDT,MDH,PTI,CMH,MBAS,PHI
	KILL	EXPE,MCP,TUNL
	KILL	.SETG.,SETGL

TII	EQ	1

	SUBTTL	SHARE (ConFIGuration DEFAULts)

::*********************************************************************
::
::	CFIG:  CONFIGURATION DEFAULTS FOR TEST PURPOSES ONLY!
::	   ==> These configuration switches must be set to zero! <==
::
::*********************************************************************

	CFIG(AL1,0)
:	CFIG(ALBERT,0)
	CFIG(TEST,0)		:TEST CODE				##al
	CFIG(MNTST1,0)		:Multi-NC compound circuit testing	###ev
	CFIG(KOPFJ,0)
	CFIG(JIM,0)		:###wjl
	CFIG(LADEN,0)		:###wjl

::*********************************************************************
::
::	CFIG:  GENERAL NODE CODE CONFIGURATION DEFAULTS
::
::*********************************************************************

:	CONFIGURATION DEFAULTS ON
NOSEG	EQ	1		:NOSEG always on                        ###sdw
        DEFAULT(NCV530,0)       :check to make sure ISIS has patch which
                                :puts shared mem in seg C.              ###sdw
       IF       \IKNRNG         :if defined
        IF      1-IKNRNG        :only works with isis v7.00+            ###sdw
        REMARK%%%%
        REMARK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%
        REMARK!!!  FATAL CONFIGURATION ERROR             !!!%
        REMARK!!!  ASSEMBLY HAS BEEN KILLED              !!!%
        REMARK!!!  THIS VERSION OF NODE CODE DOES NOT    !!!%
        REMARK!!!  RUN WITH ISIS VERSIONS PRIOR TO V7.00 !!!%
        REMARK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%%%%%
        KILLER(1)
        EI      :1-IKNRNG
       EI       :\IKNRNG
	CFIG(REBTST,1)          :better and faster rebuild code

CKSM    EQ      0               :need to add code for it to work
:	CONFIGURATION DEFAULTS OFF
	CFIG(CKSM,0)		:DON,T SEND CHECKSUM FOR NON-STAR SIO LINE#LSH
				:MUST SEND CHECKSUM FOR STAR LINE	###LSH
	CFIG(BLAB,0)
	CFIG(SUP,0)		:FOR ISIS GOODGY LIST COMPATABILITY	###OAS
	CFIG(NANIPT,0)
	CFIG(CRHRMK,0)
	CFIG(SYNFCS,0)		:SYNC LINE SW FCS ERR CHECKING		##al
	CFIG(INTACC,0)		:INTERNAL HOST ACCOUNTING 		##AL
	CFIG(PKTSAV,0)		:SAVE PACKETS ON CRASH 			###LSH
	CFIG(NDREAD,0)		:enable reading of last org ndl in node
	CFIG(NEWTRP,0)		:New Trapdoor (SVC29 - unimplemented)	###tz
        CFIG(SPAM,0)            :issue SVC sending node CPS to SPAM     ###sdw
	CFIG(BFLTMR,0)		:for buffer timer pairs
	CFIG(NETNAM,0)
	CFIG(IDTACH,0)		:ISIS Detach				###wjl
	CFIG(SUPTRC,0)		:SUP RING TRACE DEBUG CODE		###OAS
	CFIG(.PROF.,0)		: Disable PROFILE			###JOK
	CFIG(NETMOD,0)		:NETWORK MODIFIER (TYMFILE SPEC)	###OAS
	CFIG(SUBNET,0)		:SUBNET NUMBER (TYMFILE SPEC)		###OAS
				:THESE PARAMETERS ARE USED IN THE
				:EXPANDED SUPERVISOR TAKEOVER RESPONSE
	CFIG(DIALUP,0)		:and in the Expanded Reset pattern	###wjl
				:AND WILL EVENTUALLY BE A TYMFILE SPEC	###OAS
	CFIG(ACCT2,0)		:Default for current accounting formats 
				:19-apr-85  supports 24bit fields only	###EV
	CFIG(T2GATE,0)		:Gateway not configured normally
        if      t2gate
swtchr  eq      0
        ei      :t2gate
	CFIG(BPFIX,0)		:Apply backpressure testing
SIOFXI  EQ      1               :fix initializtion wait logic           ###sdw

	DEFAULT(SPLCSZ,180)     :BCT of both buffers before use SPLICE 
                                :instead of APPEND (new rebuild logic)
        if      \nslot          :if defined (could be a gateway)
        if      nslot           :if have slots then probably not a swtchr
        cfig(SWTCHR,0)          :ISIS Switcher (removes SVC DISMISS from BG)
        else    :0 slots        
        cfig(SWTCHR,1)          :ISIS Switcher (removes SVC DISMISS from BG)
        ei      :nslot
        ei      :\nslot
        cfig(multln,1)          :1 fully support multi-line link
        cfig(notrik,1)          :1 remove trickle logic (always gush)
                                :0 removes that time consuming code

::*********************************************************************
::
::	CFIG:  XRAY RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

	DEFAULT(XRSZLV,3)	:XRAY SIZE ASSEMBLY LEVEL SWITCHES 	##AL
	CFIG(PRIMSG,1)		:PRIORITY CRYPTO MESSAGE BUFFER
				: DEFAULTED FOR XRAY ##AL
	CFIG(XRYMES,0)		:DEFAULT FOR XRAY MESSAGE ENTERED IN TYMFILE
        CFIG(WSZTST,1)          :allow WSZ to be non multiple of 4 and do
                                :restore full windowsize when link goes
                                :down and allow XRAY cmd to reduce WSZ  ###sdw
	CFIG(EFFDIS,1)          :for new more efficient dispi logic
	CFIG(XRYRMK,0)          :xray cmd PK to display packetsize
	CFIG(NCSLOT,0)          :for NC nonslot 0 testing
       if       swtchr          :if we are a switcher
ncslot  eq      1               :we do not send messages to dispatcher
numhst  eq      4               :only 1 host (numhst must be mult of 4)
ndp     eq      0               :and no dispatcher ports
       ei       :swtchr
CHNSIO  EQ      1               :new SIO chaining logic                 ###sdw
        CFIG(CHNCHK,0)          :if 1 crash on any error in CHNSIO      ###sdw
        if      \nslot          :if node code
        if      nslot           :if slots
        cfig(tii.fg,1)          :if 1 then run syvler in FG, else in BG
        else    :nslot=0
        cfig(tii.fg,0)          :if 1 then run syvler in FG, else in BG
        ei      :nslot
        else    :\nslot not defined
        cfig(tii.fg,1)          :if 1 then run syvler in FG, else in BG
        ei      :nslot defined
effexc  eq      1               :new EXEC optomization                  ###sdw
        DEFAULT(XRONSZ,0A0)     :max # of chars to put in output buffer
        CFIG(REBTAK,1)          :resend rebuild requests after takeover
        DEFAULT(NCHAIN,2)       :max len of new sio chains              ###sdw



::*********************************************************************
::
::	CFIG: GENERAL HARDWARE RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************


	DEFAULT(MACHIN,1)	:ISIS Tymfile parameter - 1=Engine,	###wjl
	CFIG(HMICRO,0)		:	2=HDLC Micro, 3=TSI		###wjl
	CFIG(TSI,0)		:					###wjl
:	INSERT FUTURE SWITCHES AT THE TOP OF THE LIST BELOW		###wjl
	IF	MACHIN-2
TSI	EQ	1
	ELSE	MACHIN-1
HMICRO	EQ	1
	ELSE	:MACHIN
:	DEFAULT
	EI	:MACHIN

::*********************************************************************
::
::	CFIG:  MXP RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

	DEFAULT(NMACH,1)	:NUMBER OF MACHINES FOR ISIS-MXP SUPPORT
	CFIG(MXPNM,0)		:FOR ISIS-MXP SUPPORT
	IF	MXPNM		:###wjl
	DEFAULT(NUMHST,$A 128)	:TYMFILE spec for NHOSTS
	ELSE	:not MXPNM
	DEFAULT(NUMHST,$A 64)
	EI	:MXPNM

::*********************************************************************
::
::	CFIG:  GATEWAY RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

       IF       INTACC          :internal host accounting
ACCT    EQ      1               :include the 'normal' accouting routines
       EI       :INTACC

	CFIG(IRC,0)		:INTERNATNAL RCD CARRIER FOR GATEWAY##AL
	CFIG(ACCT,0)		:GATEWAY ACCOUNTING 			##AL

	IF	T2GATE
	DEFAULT(INCOST,0)
	DEFAULT(HNCOST,0)
IDTACH	EQ	1		:Gateway will use Isis detatch logic
NUSLT	EQ	0
NUMHST  EQ      4               :must be a multiple of four  ###sdw
KNRING	EQ	0
PTHRU	EQ	1		:Gateway does not allow passthroughs
LOGII   EQ      0               :no LOG II yet
SWTCHR  eq      0               :not a switcher
	EI	:T2GATE	

::*********************************************************************
::
::	CFIG:  TYMSTAR RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

	CFIG(NAKCOD,0)		:Starlink NAK protocol
	CFIG(STRHUB,0)		:TYMSTR CENTRAL HUB STATION SWITCH	##AL
	CFIG(RBTHUB,0)		:TYMSTR CENTRAL HUB REMOTE BOOT SWITCH	##AL
	CFIG(RBTRMT,0)		:TYMSTR REMOT STATION REMOTE BOOT SWITCH ##AL
	CFIG(STRDCD,0)		:TYMSTAR SIOUT SWITCH TO TEST DCD BIT ###LSH
	DEFAULT(RESTRY,0A)	:Tymstar remote reset retry counter	##ev
	CFIG(STRRMT,0)		:TYMSTAR REMOTE EARTH STATION SWITCH
	DEFAULT(RSTFRQ,4)	:Tymstar remote sends initial reset 4 x 4 (sec)
	DEFAULT(TH.ACK,2)	:NULL REC ACK THRESHOLD			###sdw
        DEFAULT(MINWSZ,4)       :smallest allowed windowsize            ###sdw
	CFIG(STCNSW,0)		:TYMSTAR SIOCO/SIONO SWAPING ##AL
	CFIG(ALDUM,0)		:NEW SEND DUMMY PER STAR LINK ##AL
	CFIG(NODUM,0)
	CFIG(NGRDTM,0)		:THRESHOLD FOR NO GOOD DATA REPORT	###AL
	CFIG(ALhub,0)

	CFIG(MAKNUL,0)		:Checks for sending null rec
	DEFAULT(RRXLIM,3)	:Threshold of repeat rexmissions before null
	CFIG(APLYBP,0)

::*********************************************************************
::
::	CFIG:  LOGII RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

       IF       \LOG.II         :what ISIS decided to use
LOGII   EQ      LOG.II
       EI
	CFIG(LOGII,1)		:Include LOG II code                    ###sdw
       IF       LOGII
IDTACH  EQ      1
       EI
        DEFAULT(X4NENT,40)      :max number of elements in an X.409 message

::*********************************************************************
::
::	CFIG:  TYMTUNNEL RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

	CFIG(TUNL,0)		:Tymtunnel code				###AL
	DEFAULT(TNLTMR,$A 120)	:2 MINUTE LOGIN TIMER			###AL
	DEFAULT(SNETMR,$A 2)	:2 SECOND SENDING NEEDLE TIMER		###AL
	DEFAULT(SRSTMR,$A 16)	:16 SECOND SENDING RESET TIMER		###AL
	DEFAULT(SNETCT,$A 10)	:sending needle retry threshold		###AL


::*********************************************************************
::
::	CFIG:  SKYWALKER RELATED CONFIGURATION DEFAULTS
::
::*********************************************************************

	CFIG(SCLP,0)		:Single Channel Link Protocol support	###wjl
	CFIG(NAD68,0)		:NAD to 68020 assembler			###wjl
	CFIG(MNC68K,0)		:Multi-NC/68020 environment		###wjl
	DEFAULT(KGWSIZ,8)	:Keg window size arbitrary default	###ev
	DEFAULT(NMNCC,0)	:Non MNC configs for tables & flags	###ev

::*****************************************************************
::
::      EXEC OPTOMIZATION
::
::*****************************************************************

:       define maximum number of ticks for each of the major processes.
:       This lets that process run for that long before checking EXEC to
:       yield (EXYLD).  This is to prevent important processes from
:       checking exec after doing virtually nothing.  Thus, RTEAR will
:       not check exec after servicing each link, same for rest.        ###sdw

:       give ticks to each of the major data movers
        DEFAULT(TICDSI,07)              :DISIN (data out of NC)
        DEFAULT(TICDSO,07)              :DISOUT (empty ISIS ring to NC) 
                                        :extra large to prevent dispatcher
                                        :from buffering
        DEFAULT(TICRTD,04)              :RTEAR
        DEFAULT(TICRMK,04)              :RMAKE 
        DEFAULT(TICXRY,09)              :prevent xray cmds from hogging cpu
        DEFAULT(SIOTHR,$a 100)          :more than 100 ticks between servicing
                                        :an sio line means stop RTd calls from
                                        :sio input and instead copy that data
                                        :Prevents possibility of sio ring wrap


::*********************************************************************
::
::	DEFAULT:	PHSIZE:/P0SIZE:/P1SIZE:
::	FUNCTION:
::	The following symbols may be defined in the TYMFILE if the defaults
::	listed below are not satisfactory for patching.
::	PHSIZE defines the length in bytes of the PATHIS area.
::		default: 140 hex
::	P0SIZE defines the length in bytes of the PATCH0 area.
::		default: 200 hex
::		default: an area will be defined by this library
::	P1SIZE defines the length in bytes of the PATCH1 area.
::		default: 400 hex
::
::*********************************************************************

	DEFAULT(PHSIZE,200)
PHSIZE	EQ	(PHSIZE+0F)/10*10
	DEFAULT(P0SIZE,200)
	DEFAULT(P1SIZE,400)
        GL      PATHIS


	DEFAULT(BAUDR,0)	:Async rate: 0=1200, 1=not used, 2=4800 BPS

:	SET UP DEBUGGING AND TEST OPTIONS. THE OPTIONS MAY BE SPECIFIED
:	BY EXPLICIT DEFINITION OF FLAGS TO BE SET, BY USE OF THE OPTION MACRO,
:	OR BY SETTING THE SYMBOL O.FLAG WITH THE PROPER BIT ARRAY VALUE.
	DEFAULT(O.FLAG,0)		:DEFAULT TO 0 IF NOT DEFINED
	IF	BAUDR-1			:IF 4800 BAUD CONSAT		###wjl
DB.TRC	EQ	0			:DON'T ALLOW UPSW JUMP TRACE OPTION
	EI	:BAUDR-1		:				###wjl
	CFIG(DB.TRC,O.FLAG&UTRC)	:DB.TRC ENABLES UPSW JUMP TRACE OPTION
	CFIG(DB.CIR,O.FLAG&CIRD)	:DB.CIR ENABLES XRAY DISPLAY OF
					: CIRCUITS BUILT AND ZAPPED.
	IF	(1-\DB.SYN)
Q	EQ	O.FLAG&NTLV	:NTLV DISABLES TLEV TRACING		###OAS 
	IF	Q
DB.TSN	EQ	0
	ELSE	:Q
DB.TSN	EQ	TLEV		:DB.TSN ENABLES SYNC LINE DIAGNOSTIC TRACE
	EI	:Q
	EI	(1-\DB.SYN)

	CFIG(DB.DEB,O.FLAG&DBUG)	:GENERAL NODE CODE DEBUGGING OPTION

	CFIG(REBILD,(O.FLAG&REBLD)/REBLD)	:REBUILD LOST CIRCUITS
        if      1-rebild
rebtak  eq      0                :if no rebuild then no fancy recovery logic
        ei

	GLOBAL(NSYMBL,0)	:init count of symbols for XRAY symbol table
	GLOBAL(ADRESZ,0C)	:size of symbol table entry

::*********************************************************************
::
::	DEFINE DEFAULT VALUES FOR CONFIGURATION PARAMETERS
::
::*********************************************************************


	CFIG(EXPNDL,0)		:expanded needle handling and SNI's (UUN)

	DEFAULT(PTHRU,0)	:DEFAULT TO PASSTHROUGHS ENABLED
	DEFAULT(NPTHR,100)	:DEFAULT TO $A 256 PASSTHROUGHS
	DEFAULT(NDP,100)	:DEFAULT TO $A 256 DISPATCHER PORTS
	DEFAULT(NSP,180)	:DEFAULT TO $A 384 SUP PORTS FOR SUP NODE

:	NETID MUST BE SPECIFIED IN TYMFILE
	IF	\NETID
	ELSE	:NETID NOT DEFINED
	REMARK	%
	REMARK	%****************************************
	REMARK	%!! NETID MUST BE SPECIFIED IN TYMFILE !!
	REMARK	%****************************************
	REMARK	%
	KILLER(1)		:KILL ASSEMBLY!!
	EI	:\NETID

        if      1-netid         :0 is not a valid netid
        Remark%%%       ERROR!!!!   NETID of 0 is not valid.%%%
        quit    ;       kill rseg0,privbg :prevent writeout.
        ei

XGGER1	ERRCNT
	XGG
XGGER2	ERRCNT
	IF	XGGER2-XGGER1
	REMARK	%
	REMARK	%****************************************
	REMARK	%!!!! XGG MACRO ERROR !!!!!!!!!!!!!!!!!!!
	REMARK	%!!!! GOODGUY LIST MUST BE PROVIDED !!!!!
	REMARK	%****************************************
	REMARK	%
	EI	:XGGER2-XGGER1

	IF	XGGCNT
	ELSE	:XGGCNT
	REMARK	%
	REMARK	%*****************************************
	REMARK	%!!!!! NO XRAY GOODGUY LIST PROVIDED !!!!!
	REMARK	%*************************************
	REMARK	%
	EI	:XGGCNT

	IF	\MICRO
	IF	(2-MICRO)		:MICRO 0 OR 1
	REMARK	%>>> MICRO = 0, AND MICRO = 1 NOT SUPPORTED!!!!!! <<<
	REMARK	%>>> CHANGE TYM-FILE IF YOUR MACHINE CAN RUN SYNC <<<
	REMARK	%>>> E N H A N C E D !!!!!!!!!!!!!!!!!!!!!!!!!!!! <<<%
	KILLER(1)		:kill assembly
	EI	(2-MICRO)
	ELSE	:NOT \MICRO
MICRO	EQ	2		:DEFAULT, AND ONLY ACCEPTABLE VALUE
	EI	(\MICRO)

EASYNC	EQ	1		:NO OTHER LEGAL VALUES
ESYNC	EQ	1

: COMPUTE NUMBER OF SYNC (NLINES) AND SIO (SILINS) FROM TYMFILE INFO
: THEN RECOMPUTE TOTAL LINES (NLINES = NLINES + SILINS)

      IF	1-NAD68		:Engine Tymfile only
	IF	T2GATE		:For T2 Gateway use sync logical units
NLINES	EQ	T2SYLU		:###EV
        DEFAULT(SILINS,0)       :no SILINS unless given in gateway tymfile
	ELSE
:       MACRO TO SAVE THE REPEAT LOOP FROM 640 CHAR OVERFLOW
QQQ MACRO[REMARK%*****************************************************************]
Q       EQ      0
QSIO    EQ      0
NLINES  EQ      0
        RE      NLUS0           :max number of lines                    ###sdw
        IF      \S0L|$A Q|      :logical unit defined?
NLINES  EQ      NLINES+1
         IF     S0L|$A Q|-1000  :sync 0-fff   SIO 10000 and up
QSIO    EQ      QSIO+1          :another SIO
         ELSE QSIO              :must be a sync ref after a SIO ref
        REMARK%%%;    QQQ
    REMARK %!!       C O N F I G U R A T I O N    E R R O R                !!
    REMARK %!!   All sync references must precede the first SIO reference  !!%
        QQQ; REMARK%%%
        KILLER(1)
         EI     :S0L|Q|-1000
        EI      :\S0L|Q|
Q       EQ      Q+1
        ER      :20
SILINS  EQ      QSIO            :what I count to be the SIO lines       ###sdw
NLINES  EQ      NLINES-SILINS   :number of sync lines, temporarily
        KILL    QQQ     :KILL THAT GOOFY MACRO
	EI	:T2GATE
      EI	:1-NAD68
:	(SEE RE-DEFINITION OF NLINES BELOW TO REFLECT TOTAL NETWORK PORTS)


SIBFRL  EQ      1               :force SIO output into same DMA window as the
                                :packets
:	SYNLNA:	FW WITH 1-BIT FOR EACH SYNC LINE GEN'D

Q	EQ	0
SYNLNA	EQ	0
	IF	NLINES
	RE	NLINES
SYNLNA	EQ	SYNLNA+(80000000^Q)
Q	EQ	Q-1
	ER	:NLINES
	EI	:NLINES

NLINES	EQ	NLINES+SILINS	:NLINES = TOTAL NUMBER OF NETWORK PORTS

LNSIZE	EQ	(((NLINES-1)/20)+1)*4  :SIZE OF ARRAY IN BYTES
NLINEW	EQ	$A (NLINES+31)/32	: Number of words of bits to reserve

SBASE	EQ	2*(NLINES-SILINS)	:2*FIRST SIO LINE, RELATIVE

	CFIG(DB.CPU,0)		:DEFAULT EXEC LOOP DISPATCH-DISMISS TRACE OFF
	CFIG(DSPCNT,0)		:DEFAULT TO NOT TRACK DISPATCH COUNTS
				:(USED WITH DB.CPU ONLY)		###OAS
	CFIG(DB.CLK,0)		:DEFAULT EXEC LOOP TIME TRACE OFF 
				:(USED WITH DB.CPU ONLY)		###OAS
	CFIG(DSPTRC,0)		:DEFAULT DISPATCH ADDRESS AND COUNT TRACE OFF
				:(USED WITH DB.CPU ONLY)		###OAS
	IF	1-DB.CPU	:force DB.CPU-related parameters off if
DSPCNT	EQ	0		:	DB.CPU is not set
DB.CLK	EQ	0
DSPTRC	EQ	0
	EI	:DB.CPU

	DEFAULT(XLINKS,0)	:DEFAULT TO 0 XLINKS
	DEFAULT(STRXLK,0)	:Starlink Xlinks
	CFIG(MACERR,0)		:MAC ERROR RECOVERY NOT ENABLED
	CFIG(INFLGT,0)		:DEFAULT TO INFINITE LOGON TIMER NOT ENABLED
	DEFAULT(NXUBLK,3)	:DEFAULT TO 4 CONCURRENT REMOTE XRAY USERS
	DEFAULT(MEMRMK,0)	:NO SPECIAL MEMORY REMARKS

DB56KB	EQ	0		:OBSOLETE, FORCE OFF

NXUBLK	EQ	NXUBLK+1	:ADD 1 FOR TTY ACCESS
	IF	(2-NXUBLK)	:NO REMOTE XRAY ACCESS.
	REMARK	%***NO REMOTE XRAY PORTS DEFINED (NXUBLK < 1)***%
	EI	(2-NXUBLK)
	IF	(NXUBLK-0F)	:NO MORE THAN 15d XRAY USERS TOTAL
	REMARK	%***NXUBLK TOO LARGE, HAS BEEN RESET TO MAX VALUE (14d)***%
NXUBLK	EQ	0F
	EI	(NXUBLK-0F)

SUPER	EQ	MACHNM%400	:SUPER # (IF APPLICABLE)
	IF	(SUPER-7)
SUPER	EQ	0		:NOT A SUP NODE
	ELSE	:(SUPER-7)
       if       1-NCV530        :must have ISIS put share mem in seg C
                                :this symbol instructs ISIS to move it, we
                                :make sure ISIS was told to move it     ###sdw
        REMARK%%%%
        REMARK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%
        REMARK!!!  FATAL CONFIGURATION ERROR                     !!!%
        REMARK!!!  ASSEMBLY HAS BEEN KILLED                      !!!%
        REMARK!!!  THIS VERSION OF NODE CODE WILL ONLY RUN WITH  !!!%
        REMARK!!!  ISIS IF ISIS HAS PATCH TO MOVE SHARED MEMORY  !!!%
        REMARK!!!  TO SEGMENT C.  PATCH ENABLED BY SWITCH NCV530 !!!%
        REMARK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%%%%%
        KILLER(1)
       ei       :1-NCV530
	EI	:(SUPER-7)

 IF	(1-\KNRING)
KNRING	EQ	0	:NORMAL RING HANDLING FOR ISIS
 EI	(1-\KNRING)


	IF	\SRING
SNRING	EQ	SRING		:SUP DEFINES SNRING INTERFACE W/ SRING VALUE.
	EI	(\SRING)	:INSURE CONSISTENT CONFIGURATION.

	DEFAULT(SNRING,1)	:DEFAULT TO SUP NEGATIVE RING		###OAS
	DEFAULT(SIORNG,0)	:DEFAULT TO NO SPLIT CONFIGURATION (SIO RING)

	IF	SIORNG
KNRING	EQ	1		:NEGATIVE INDEXING FOR SIO RING
SNRING	EQ	1		:SUP NEGATIVE INDEXED RING ALSO
	EI	:SIORNG

:	INSURE COMPATIBLE INITIALIZATION FILE USED...
Q	EQ	0	:Q WILL GET SET IF OLD INITIALIZATION FILE
 IF	(1-\INITVR)
Q	EQ	1
 ELSE		:INITVR DEFINED. TEST FOR PROPER VERSION
  IF	($8INITVR%34)
Q	EQ	1
  EI	($8 INITVR%34)
 EI	(1-\INITVR)
	IF	Q
	REMARK %* Must use TII05.I34 initialization file! *%
	KILLER(1)		:kill assembly 
	EI	:Q

	CFIG(NACARD,0)		:DEFAULT TO NO ASYNC CARDS

	CFIG(BUBLAB,0)		:NOT IN BUBB-NET LAB ENVIRONMENT
	CFIG(RESHST,0)		:NO RESTRICTED HOSTS

:	THE CODFLT (CRASH OPTION DEFAULT) MACRO SETS THE SYMBOL
:	C.xxxx TO 1 IF THE OPTION IS TRUE, ELSE SETS IT TO 0. THE xxxx
:	MNEMONIC VALUE IS BASED ON THE COMMON CRASH ACTION DEFINITIONS.


	CODFLT(NRSH)
	CODFLT(NRSS)
	CODFLT(NHTH)
	CODFLT(NHTS)
	CODFLT(NBTH)
	CODFLT(NBTS)
	CODFLT(NSTH)
	CODFLT(NSTS)

:	IF NO HARDWARE OPTION DEFINED, DEFAULT TO NRSH
	IF	(1-(C.NHTH+C.NBTH+C.NSTH))
C.NRSH	EQ	1		:RESTART ON HARDWARE CRASH
	EI	(1-(C.NHTH+C.NBTH+C.NSTH))

:	IF NO SOFTWARE OPTION DEFINED, DEFAULT TO NRSS
	IF	(1-(C.NHTS+C.NBTS+C.NSTS))
C.NRSS	EQ	1		:RESTART ON SOFTWARE CRASH
	EI	(1-(C.NHTS+C.NBTS+C.NSTS))

	IF	((C.NRSH+C.NHTH+C.NBTH+C.NSTH)-1)
	REMARK %ERROR - MULTIPLE HARDWARE CRASH OPTIONS DEFINED!%
	KILLER(1)		:kill assembly
	EI	((C.NRSH+C.NHTH+C.NBTH+C.NSTH)-1)

	IF	((C.NRSS+C.NHTS+C.NBTS+C.NSTS)-1)
	REMARK %ERROR - MULTIPLE SOFTWARE CRASH OPTIONS DEFINED!%
	KILLER(1)		:kill assembly
	EI	((C.NRSS+C.NHTS+C.NBTS+C.NSTS)-1)

:	SET UP CRASH HANDLING OPTION.  VALUE OF CRSTOP DETERMINES THE ACTION
:	TAKEN ON HARDWARE (MAC, ILLEGAL INST) AND SOFTWARE ( JAL R0,OOPS)
:	CRASHES. THE UPPER BYTE OF CRSTOP IS FOR HARDWARE, THE LOWER FOR
:	SOFTWARE. THE CODES ARE:
:		0	=>	RESTART
:		1	=>	STOP NODE CODE, LEAVE XRAY ON
:		2	=>	DISABLE WATCHDOG TIMER AND DO BOOT SVC
:		3	=>	HALT MACHINE, TURN WAIT BAR ON

HLTNOD	EQ	3
DOBOOT	EQ	2
STOPLK	EQ	1
RSTRT	EQ	0

	DEFAULT(CRSTOP,0000)	:DEFAULT TO RESTART IN ALL CASES


	IF	(C.NHTH)
CRSTOP	EQ	(CRSTOP&0FF)+0300
	EI	(C.NHTH - HALT ON HARDWARE CRASH)

	IF	(C.NBTH)
CRSTOP	EQ	(CRSTOP&0FF)+0200
	EI	(C.NBTH - BOOT ON HARDWARE CRASH)

	IF	(C.NSTH)
CRSTOP	EQ	(CRSTOP&0FF)+0100
	EI	(C.NSTH - STOP ON HARDWARE CRASH)

	IF	(C.NHTS)
CRSTOP	EQ	(CRSTOP&0FF00)+03
	EI	(C.NHTS - HALT ON SOFTWARE CRASH)

	IF	(C.NBTS)
CRSTOP	EQ	(CRSTOP&0FF00)+02
	EI	(C.NBTS - BOOT ON SOFTWARE CRASH)

	IF	(C.NSTS)
CRSTOP	EQ	(CRSTOP&0FF00)+01
	EI	(C.NSTS - STOP ON SOFTWARE CRASH)

	DEFAULT(RPTHCE,2)	:REPORTING THRESHOLD FOR CIRCUIT ERRORS

	IF	\NBFLET
	KILL	NBFLET		:PREVENT OLD TYM FILE OPTION FROM LIVING
	GL	NBFLET
	EI	(\NBFLET)

::	Define the links of each type declared.				###ev
TNLTYP	EQ	0A				:Link type of TymTunnel
:	FIRST ALL TIILNKS
	IF 	TIICNT
X	EQ	0
	RE	TIICNT
	.TII|X|
X	EQ	X+1
	ER
	EI	:TIICNT

:	NEXT ALL TUNNEL LINKS

:	COMPUTE MAXIMUM NUMBER OF LINKS
NLINKS	EQ	XLINKS+STRXLK	:START WITH NUMBER OF WILD CARD LINKS
Q	EQ	0
:	FOR EACH LINK DESCRIPTOR DEFINED, INCREMENT NUMBER OF LINKS
	RE	MAXLNK
	IF	\NEI|$AQ|
NLINKS	EQ	NLINKS+1
	ELSE
NLINKS	EQ	NLINKS
	EI	:(\NEI|$AQ|)
Q	EQ	Q+1
	ER

:Now for Starhub machines, give StarXlinks a dummy Key


NLINKW	EQ	$A (NLINKS+31)/32	: Number of words needed for bits

LKSIZE	EQ	(((NLINKS-1)/20)+1)*4	:SIZE OF ARRAY IN BYTES

::	DETERMINE MEMORY AVAILABLE
      IF	1-NAD68		:Engine Tymfile only
       IF	T2GATE		:Not used for gateway
MEMAVL  EQ      MEMORY*400              :Gateway declares memory in Tymfile
       ELSE  :NOT T2GATE
       IF	(1-\KIOAR)
MEMAVL	EQ	S0CORE*400
       ELSE	:\KIOAR
MEMAVL	EQ	KIOAR
       EI	(1-\KIOAR)
       EI	:T2GATE
      EI	:1-NAD68

:	DEFINE THE NUMBER OF CONSECUTIVE OCCURRENCES OF FOUR SECONDS
:	WITH NO RECORDS RECEIVED IN A LINE, WHICH IS ALLOWED BEFORE
:	DETACH IS TAKEN.	###LH

	DEFAULT(LNCKTM,4)	:DEFAULT TO 4 IF NOT DEFINED IN TYMFILE

	IF	SUPER
	IF	\HST0
Q	EQ	$A 120+SUPER
	IF	(Q%HST0)	:BITCH IF HST0 INCORRECT FOR SUP NODE...
	REMARK %** SUP HOST NUMBER SPECIFIED INCORRECTLY - 
	REMARK SETTING TO $A 
	NUMBER $A Q
	REMARK  **%
	EI	(Q%HST0)
	EI	(\HST0)

HST0	EQ	$A 120+SUPER	:SET HOST NUMBER FOR SUPERVISOR

	ELSE	:NOT SUPER
	DEFAULT(HST0,MACHNM-$82000+$A520)
	EI	:SUPER

	IF	T2GATE		:Gateway uses a specified or default
	IF	\HHOST		:for Network host number
HST0	EQ	HHOST	:If specified, it can be either as HHOST
	ELSE	: (use HST0, either specified or default)  <<<--- OR
HHOST	EQ	HST0	:as HST0.
	EI	:\HHOST
	EI	:T2GATE

NSP	EQ	NSP*SUPER/SUPER		:NO LIMITS TO NSP		###GT
	IF	(NSP&1F)
	REMARK	%>>WARNING - NSP not a multiple of 32d!!<<%
	EI	:(NSP&1F)
	IF	MXPNM		:ISIS-MXP SUPPORT
NUSLT	EQ	NMACH*$A16	:# SLOTS = # MACHINES * 16		###GT
	ELSE			:DEFINE A NEW SYMBOL FOR # SLOTS	###GT
	IF	1-T2GATE		:###EV
NUSLT	EQ	NSLOT		:OLD ISIS
	EI	:1-T2GATE		:###EV
	EI	:MXPNM

	IF	(1-SUPER)
SUPNKU	EQ	0	:0 SUP KERNEL USERS IF NO SUPERVISOR
	EI	(1-SUPER)
	IF	T2GATE		:###EV
NKU	EQ	0		:T2 Gateway has no kernel ports
NSLOT	EQ	0		:Nor does Gateway have slots!
	ELSE
NKU	EQ	2+NSLOT+SUPNKU	:# OF KERNEL USERS
	EI	:T2GATE		:###EV

	SUBTTL	SHARE (Parameter DEFAULTs)

::*********************************************************************
::
::	PARAMETER DEFAULTS:
::
::*********************************************************************

	IF	T2GATE
	IF	PRIMSG
	DEFAULT(CRYPPS,100)
	EI	:PRIMSG
	DEFAULT(CRYPRS,400)	:Gateway will always default to smaller buffers
	DEFAULT(TRRSIZ,200)
	DEFAULT(TRTBSZ,80)
	DEFAULT(HISTSZ,40)
	ELSE
	IF	PRIMSG
	DEFAULT(CRYPPS,100)	:SIZE OF PRIORITY MSG BUFFER (MUST BE PWR 2)
	EI	:PRIMSG
        if      swtchr          :lots of lines fill up the crypto log
	DEFAULT(CRYPRS,4000)	:SIZE OF CRYPTOGRAM BUFFER (MUST BE PWR 2)
       else     :swtchr         :not switcher so memory might matter
	DEFAULT(CRYPRS,1000)	:SIZE OF CRYPTOGRAM BUFFER (MUST BE PWR 2)
       ei       :swtchr
	DEFAULT(TRRSIZ,400)	:CHARACTER TRACE RING SIZE
	DEFAULT(TRTBSZ,100)	:UPSW TRACE CAN STORE $A 64 ENTRIES
	DEFAULT(HISTSZ,80)
	EI	:T2GATE
       IF       T2GATE          :ring must be bigger when node code     ###sdw
        DEFAULT(DRSZ,400)
       ELSE     :node code
	DEFAULT(DRSZ,800)	:!!!NOTE: MUST BE POWER OF 2!!!
       EI       :T2GATE
       if       swtchr          :switcher's have no need for dispatcher rings
DRSZ    EQ      0               :minimum size
       ei       :swtchr
	SYAD(DRSZ  )
	IF	DB.CPU
	DEFAULT(CPUTNE,0)	:INIT COUNT OF CPUT ENTRIES
	DEFAULT(CPUTMX,$A50)	:MAX NO. ENTRIES IN CPUTLB
	DEFAULT(CPUTSZ,6)	:SIZE OF ENTRY IN CPUTTB
	DEFAULT(CPTBHW,2)	:COUNT OF TIMES PROCESS CPUTIL WAS TERMINATED
				:WITHOUT YIELDING OR DISMISSING, TO INDICATE
				:HOW NAMY FALSE DISMISSES WILL BE INDICATED.
				:USED TO RECONCILE DISPATCH COUNT WITH DISMISS
				:COUNT###OAS
	DEFAULT(CPTBCT,4)	:COUNT FIELD IN CPUTTB
	EI 	:DB.CPU

        KILL    .SPED.          :kill macros used only in Share         ##sdw

	EI	(1-KILLIT)

	KILMSG(SHARE)

:	***NOTHING PAST THIS POINT***



	
	SUBTTL	DATA

:			****    *   *****   *
:			*   *  * *    *    * *
:			*   * *****   *   *****
:			*   * *   *   *   *   *
:			****  *   *   *   *   *

::#####################################################################
::
::	MODULE:		DATA
::
::	FUNCTION:	Define Data Storage areas, equates and constants,
::		tables structures, parameter defaults, crash codes,
::		crypto messages, etc.
::
::	SUBTTLS:
::		Define register, segment, SVC naming conventions
::		Define ASCII equates
::		Define codes for node Faults, Node Reports
::		Crash Codes
::		Parameter Defaults
::		Equates and Constants
::		Crypto Messages
::		Table Structure Variables
::		Low Core SEG 0 Variables
::		Segment 0 -  Data Areas
::		Segments 2 & 3 - Buffer Descriptors
::		Segment 4 - Kernel Communications
::		Segment 5 - Supervisor Communications
::		Segment 6,7,8,9 - IOTAB and Bufferlets
::		Segment B - SYNC Input 
::		Segment C - Table Storage
::		Segment E - Control Table Area (CTA)
::		Segment F - ISIS Data Area (IDA)
::
::#####################################################################

	IF 1-KILLIT
	BEGMO.

:	Define General Registers

	GLOBAL(R0,0)			: register 0
	GLOBAL(R1,1)			: register 1
	GLOBAL(R2,2)			: register 2
	GLOBAL(R3,3)			: register 3
	GLOBAL(R4,4)			: register 4
	GLOBAL(R5,5)			: register 5
	GLOBAL(R6,6)			: register 6
	GLOBAL(R7,7)			: register 7
	GLOBAL(R8,8)			: register 8
	GLOBAL(R9,9)			: register 9
	GLOBAL(R10,0A)			: register 10
	GLOBAL(R11,0B)			: register 11
	GLOBAL(R12,0C)			: register 12
	GLOBAL(R13,0D)			: register 13
	GLOBAL(R14,0E)			: register 14
	GLOBAL(R15,0F)			: register 15

:	Special Register Definitions

CD	EQ	R13		:pointer to reCord Descriptor
KD	EQ	R15		:pointer to linK Descriptor
KN	EQ	R11		:linK Number 
KX	EQ	KN		:pointer to linK descriptor (Xray)
LN	EQ	R14		:Line Number
PRD	EQ	R12		:Pointer to Record Data
R2BE	EQ	R2		:EVEN BUFFER INDEX
R2BO	EQ	R2		:ODD BUFFER INDEX

SD	EQ	PRD		:pointer to reSet Data buffer
XD	EQ	R15		:pointer to Xray user block Descriptor
XN	EQ	XD		:Xray user slot Number

TC	EQ	R15		:FOR TRUNCATING RING POINTERS (POWER OF 2 MASK)
LRC	EQ	R14		:LOGICAL RECORD BYTE COUNT
PRC	EQ	R10		:PHYSICAL DITTO
CHN	EQ	R5		:CHANNEL #

TYC	EQ	R11		:HOLDS MAGIC CONSTANT (03 OR 07)
HN	EQ	CD		:HOST #
KP	EQ	R7		:KERNEL PORT BUFFER OFFSET

:	DEFINE VIRTUAL SEGMENTS
      IF	1-NAD68		:not for 68K environment		###wjl
SEG1	EQ	10000
SEGD	EQ	0D0000
      EI	:1-NAD68

:	DEFINE SYMBOLS TO IDENTIFY ISIS SVC'S
DISMIS	EQ	0		:dismiss
FAST	EQ	1		:fast dismiss
SYS	EQ	2		:system
IO	EQ	3		:I/O control
KIO     EQ      0D              :KIO control

::*********************************************************************
::
::  ISIS-68K TRAP function codes
::
::*********************************************************************

ISIS	EQ	0
DRMEM.	EQ	$A 147		:Drop Shared Memory
XNDCD.	EQ	$A 149		:Exchange NodeCode Information
SNDIA.	EQ	$A 150		:Create User Entry in System Log
MFALT.	EQ	$A 159		:Shared Memory Fault Handler
MYMEM.	EQ	$A 160		:Present Shared Memory Area
CSMEM.	EQ	$A 161		:Connect to Shared Memory Area
QSMEM.	EQ	$A 170		:Query Shared Memory Areas

	SUBTTL DATA (ASCII EQuates)

::*********************************************************************
::
::	ASCII equates for character comparison ###JHL
::
::*********************************************************************

ASC7BT	EQ	7F	:SEVEN BITS OF CHARACTER
ASCLF	EQ	0A	:ASCII LINE FEED
ASCCR	EQ	0D	:ASCII CARRIAGE RETRUN
ASCESC	EQ	1B	:ASCII ESCAPE CHAR
ASCSPC	EQ	20	:ASCII SPACE
ASCEXP	EQ	21	:ASCII EXCLAMATION POINT
ASCAST	EQ	2A	:ASCII *
ASCPLS	EQ	2B	:ASCII +	
ASCCOM	EQ	2C	:ASCII COMMA
ASCDSH	EQ	2D	:ASCII DASH (HYPHEN)
ASCDOT	EQ	2E	:ASCII PERIOD
ASCFSL	EQ	2F	:ASCII FORESLASH
ASCZRO	EQ	30	:ASCII ZERO
ASCONE	EQ	31	:ASCII ONE
ASCTWO	EQ	32	:ASCII TWO
ASCTHR	EQ	33	:ASCII THREE
ASCFOU	EQ	34	:ASCII FOUR
ASCFIV	EQ	35	:ASCII FIVE
ASCSIX	EQ	36	:ASCII SIX
ASCSEV	EQ	37	:ASCII SEVEN
ASCEIG	EQ	38	:ASCII EIGHT
ASCNIN	EQ	39	:ASCII NINE
ASCCOL	EQ	3A	:ASCII COLON
ASCSMC	EQ	3B	:ASCII SEMICOLON
ASCQST	EQ	3F	:ASCII ?
ASCAT	EQ	40	:ASCII @
ASCA	EQ	41	:ASCII A
ASCB	EQ	42	:ASCII B
ASCC	EQ	43	:ASCII C
ASCD	EQ	44	:ASCII D
ASCE	EQ	45	:ASCII E
ASCF	EQ	46	:ASCII F
ASCG	EQ	47	:ASCII G
ASCH	EQ	48	:ASCII H
ASCI	EQ	49	:ASCII I
ASCJ	EQ	4A	:ASCII J
ASCK	EQ	4B	:ASCII K
ASCL	EQ	4C	:ASCII L
ASCM	EQ	4D	:ASCII M
ASCN	EQ	4E	:ASCII N
ASCO	EQ	4F	:ASCII O
ASCP	EQ	50	:ASCII P
ASCQ	EQ	51	:ASCII Q
ASCR	EQ	52	:ASCII R
ASCS	EQ	53	:ASCII S
ASCT	EQ	54	:ASCII T
ASCU	EQ	55	:ASCII U
ASCV	EQ	56	:ASCII V
ASCW	EQ	57	:ASCII W
ASCX	EQ	58	:ASCII X
ASCY	EQ	59	:ASCII Y
ASCZ	EQ	5A	:ASCII Z
ASCBSL	EQ	5C	:ASCII BACKSLASH
ASCAP	EQ	5F	:and-mask to force upper case 
ASCUC	EQ	0DF	:and-mask with HOB set


	SUBTTL	DATA (Define node Faults, Node Reports)

:###JHL--THESE CODES UNUSED AS OF (BEFORE) REL 502
:	DEFINE VALUES TO IDENTIFY NODE FAULTS. THE VALUE WILL BE STORED
:	IN 'CRSHAD', AND IS USED AS THE ADDRESS PORTION OF A HALT PSW.
F.MMAL	EQ	84	:MACHINE MALFUNCTION - OLD PSW @ LOCATION 20
F.ILDV	EQ	86	:ILLEGAL DEVICE INTERRUPT - DEVICE ADDRESS IN R2
F.ILNS	EQ	88	:ILLEGAL INSTRUCTION - PSW IN R14, R15
F.MACI	EQ	8A	:MAC INTERRUPT - MAC STATUS STORED @ 'SMACSV'
F.POWU	EQ	8C	:POWER UP INTERRUPT
F.DMAT	EQ	8E	:DMA TIMEOUT INTERRUPT
F.ILXX	EQ	90	:ILLEGAL INSTRUCTION, 

:	CODES TO IDENTIFY VARIOUS CRASH CAUSES. THESE VALUES ARE STORED
:	INTO THE 'CRSHID' FIELD, AND ALSO INTO THE 'ANHALT' FIELD. THE
:	LATTER SERVES AS A FLAG BETWEEN THE PRIVILEGED CODE AND XRAY TO
:	INDICATE WHEN THE NODE CODE HAS UNDERGONE A TRAUMATIC CRASH

SLEEPF	EQ	2		:OPERATOR-HALTED
OUTWTF	EQ	2		:OUTPUT WAIT
ILLERF	EQ	4		:ILLEGAL INSTRUCTION
DMATOF	EQ	5		:DMA TIMEOUT
MACNTF	EQ	8		:MAC INTERRUPT
MALNTF	EQ	20		:MACHINE MALFUNCTION INTERRUPT
ABSNTF	EQ	80		:NO SUCH PROCESS
PWFLF	EQ	1		:POWER FAIL

NMACR	EQ	0F		:# OF MAC REGISTERS IN USE
MRN	EQ	10-NMACR	:FOR MULTIPLE LOAD/STORE OF MAC REGS


::*********************************************************************
::
::	NR.###:	DEFINE VALUES TO IDENTIFY NODE REPORTS TO SUPERVISOR.
::	NODE REPORTS ARE THE 'REPORT TO SUPERVISOR'S LOG' MESSAGE, TYPE 1280.
::	THE NODE REPORT CONTAINS 3 HALFWORDS OF DATA.  THE FIRST
::	HALFWORD IS THE NODE REPORT MESSAGE TYPE, DEFINED AS FOLLOWS:
::
::*********************************************************************

NR.CHU	EQ	1		:CHANNEL IN USE
NR.UAC	EQ	2		:DATA ON UNASSIGNED CHANNEL
NR.BFZ	EQ	3		:BUFFER ZAP
NR.RLK	EQ	4		:RESPONSE TO REMOVE NEIGHBOR COMMAND
NR.ALK	EQ	5		:RESPONSE TO ADD NEIGHBOR COMMAND
NR.BUB	EQ	6		:LINK BUBBLE
NR.SHK	EQ	7		:LINK SHRINK
NR.NPT	EQ	8		:OUT OF PERMUTER TABLE SPACE
NR.NKD	EQ	9		:OUT OF LINK SPACE FOR NEW LINE ATTACH
NR.PLI	EQ	0A		:NUMBER CIRCUITS ZAPPED DUE TO LINK OUT
NR.ODP	EQ	0B		:NODE OUT OF DISPATCHER PORTS
NR.NRJ	EQ	0C		:NEEDLE REJECTED BY SLOT
NR.HIM	EQ	0D		:HOST IS IMPOSTER, DETECTED BY NODE CODE
NR.CTM	EQ	0E		:REPORT CIRCUIT LIFETIME (IN SECONDS) FOLLOWING
				:CHANNEL IN USE REPORT
NR.SNP	EQ	0F		:LINK SNIP - NEIGHBOR SPLIT CHARACTER PAIR OR
				:SENT INVALID CHANNEL NUMBER IN PACKET
NR.DGN	EQ	10		:GENERAL DIAGNOSTIC NODE REPORT - FIRST BYTE OF
				:HW2 CONTAINS SUB-TYPE
NR.NNE	EQ	11		:NEEDLE BOUND FOR NEIGHBOR NOT FOUND
NR.XMN	EQ	12		:INVALID NODE NUMBER ON COMMAND CIRCUIT MESSAGE
NR.XCM	EQ	13		:INVALID COMMAND TYPE ON COMMAND CIRCUIT
NR.NCE	EQ	14		:CIRCUIT BUILDING ERRORS DETECTED
NR.CKC	EQ	15		:CIRCUIT BUILDING CONSISTENCY ERRORS
NR.LFR	EQ	16		:LINK FROZEN
NR.LTH	EQ	17		:LINK THAWED
NR.CCZ	EQ	18		:COUNT OF CMD CRCUITS ZAPPED DUE TO LINK OUTAGE
NR.CRP	EQ	19		:NODE CRASH REPORT
NR.SSX	EQ	1A		:REPORT # SIO, SYNC, XLINKS, NLINKS
NR.PPT	EQ	1B		:REPORT # PORTS, PASSTHROUGHS
NR.UNL	EQ	1C		:REPORT UNUSED LINES
NR.LNR	EQ	1D		:LINE/LINK REPORT (INSTEAD OF SYNPRT)
NR.SML	EQ	1E		:SLOT REPORT LIMIT EXCEEDED
NR.INH	EQ	1F		:INVALID HOST ON RESTRICTED HOST NODE
NR.CLE	EQ	20		:SLOT/HOST CIRCUIT LIMIT EXCEEDED
NR.DLD	EQ	21		:COUNT OF CIRCUITS ZAPPED DUE TO DLOAD COMMAND
NR.I3C	EQ	22		:INVALID 03-CHAR PAIR ON COMMAND CIRCUIT
NR.MAC	EQ	23		:NODE TOOK MAC INTERRUPT AND RECOVERED
NR.K56	EQ	24		:56KB DIAGNOSTIC - SIO TIMEOUT ON OUTPUT
				:25 UNUSED
NR.T13	EQ	26		:INVALID 03-CHAR PAIR ON T-I COMMAND CIRCUIT
NR.T1L	EQ	27		:T-I SUP RECORD WITH INVALID LENGTH
NR.DMA	EQ	28		:MAC INTERRUPT CASED BY DMA HARDWARE TIMEOUT
NR.KZF	EQ	29		:KERNEL PORT ZAP SVC GAVE NON-SKIP RETURN
NR.CR1	EQ	2A		:FIRST ADDENDUM TO CRASH REPORT, CRASH ID
NR.CR2	EQ	2B		:2ND ADDENDUM TO CRASH REPORT,REGISTER CONTENTS
NR.HVR	EQ	2C		:REPORT KERNEL HOST NUMBER AND VERSION NUMBER
NR.SQF	EQ	2D		:SQFIX ERROR. HW1=BUFFER, HW2=COUNT
NR.TMP	EQ	2E		:TEMPERATURE EXCEEDS DESIRABLE RANGE
				:(OR IS BELOW ACCEPTABLE).		###JHL
NR.NID	EQ	2F		:NETID mismatch for potential new link	###wjl
NR.WSZ	EQ	30		:WSIZ match down for new link		###wjl
NR.XID	EQ	31		:XRAY NETID change for new link		###wjl
NR.RRF	EQ	32		:STARLINK Remote Reset Failure		###ev
NR.ARW	EQ	33		:Async Ring Wrap			###wjl

:	DEFINE SUB-TYPES FOR GENERAL DIAGNOSTIC NODE REPORT (NR.DGN)

DR.SYM	EQ	0		:SYNC SCAN INSTRUCTION TOOK NON-SKIP RETURN
:	INDICATING 'START BIT' FOUND IN SYNC RING, BUT MEMORY POINTED TO
:	BY INDEX REGISTERS (R11 & R13) CONTAINED ALL ONES.  SECOND BYTE
:	OF HW2 HAS 2*LINE NUMBER, HW3 HAS R13 (SYNC RING BASE INDEX,
:	OFFSET INTO SEGMENT 0B).

DR.SIO	EQ	1		:SIO BUFFER LENGTH FIELD = 0 OR > 90,
:	SHOULD BE NEGATIVE UNTIL POSITIVE COUNT STORED BY MOTHER
:	BOARD.  SECOND BYTE OF HW2 HAS 2*LINE NUMBER, HW3 HAS NUMBER OF
:	OCCURRENCES.

DR.SZC	EQ	2	:TIMEOUT ON M-BOARD WHILE ATTEMPTING CONNECT.
:	SECOND BYTE OF HW2 = LINE NUMBER, HW3= NEIGHBOR NUMBER (+8000 IF UP)

DR.SZI	EQ	3	:IDENTICAL TO DR.SZC FOR INPUT TIMEOUT
DR.SZO	EQ	4	:IDENTICAL TO DR.SZC FOR OUTPUT TIMEOUTS
DR.SZS	EQ	5	:IDENTICAL TO DR.SZS FOR STATUS SVC TIMEOUTS

:	THE FOLLOWING MESSAGE TYPES ARE FOR REPORTING LINE DIAGNOSTICS.
:	THE FIRST 16 BITS ARE OF THE FORMAT TTLL, WHERE TT IS THE
:	MESSAGE TYPE, AND LL IS THE LINE NUMBER FOR WHICH THE DIAGNOSTIC
:	REPORT IS BEING MADE.

LL	EQ	0		:VALID VALUES ARE 0 - NLINES-1

NR.SRT	EQ	8000+LL		:TOTAL PACKETS SENT AND RECEIVED
NR.BRI	EQ	8100+LL		:# OF BAD BORI'S
NR.ACK	EQ	8200+LL		:# OF BAD ACKS
NR.RCN	EQ	8300+LL		:# OF BAD RECORD NUMBERS
NR.CHS	EQ	8400+LL		:# OF CHECKSUM ERRORS
NR.RTR	EQ	8500+LL		:# OF RETRANSMISSIONS RECEIVED
NR.RTS	EQ	8600+LL		:# OF RETRANSMISSIONS SENT
NR.4SG	EQ	8700+LL		:# OF 4-SECOND GAPS W/ NO GOOD RECORDS RECEIVED
NR.CRS	EQ	8800+LL		:# OF CROSS-TALK ERRORS
NR.SPC	EQ	8900+LL		:# OF TIMES SPACING DETECTED ON INPUT
NR.HCK	EQ	8A00+LL		:# OF SIO HDLC CHECKSUM ERRORS
NR.HAB	EQ	8B00+LL		:# OF SIO HDLC ABORTS

	SUBTTL	DATA (Crash Codes)

::*********************************************************************
::
::	CRASH CODES:
::	All crash codes are defined here.  New crash codes should be added
::	at the end of this list, they must not be inserted since this would
::	change the definition of codes which follow the insertion.  They
::	should not be under any switches.
::
::*********************************************************************

.EXCRH	DFCRH.(.EXCRH,C.SWCE,0,EXCRH EXEC tried to dispatch to nonexistent process%(PROCID*2 in R2))
.BIDCR	DFCRH.(.BIDCR,C.INML,0,BIDCR BIDDY found nothing to do.%  (R1 = dispatch array - should be non-zero))
.YKMCR	DFCRH.(.YKMCR,C.HWCE,0,YKMCR YAKMAC tried to recover from MAC error`, failed.  %KD contains difference between expected and actual KD's.)
.BIDHC	DFCRH.(.BIDHC,C.INML,0,BIDHC JFFOH failure.)
.BIDC0	DFCRH.(.BIDC0,C.INML,0,BIDC0 JFFO error.)
.SV39C	DFCRH.(.SV39C,C.SVER,39*2,SV39C ISIS connect SIO line SVC error.)
.SV3BC	DFCRH.(.SV3BC,C.SVER,3B*2,SV3BC ISIS start SIO output SVC error.)
.SV3AC	DFCRH.(.SV3AC,C.SVER,3A*2,SV3AC ISIS start SIO input SVC error.)
.SV0CC	DFCRH.(.SV0CC,C.SVER,0C*2,SV0CC SOLO connect SIO line SVC error.)
.SV0EC	DFCRH.(.SV0EC,C.SVER,0E*2,SV0EC SOLO start SIO output SVC error.)
.SV0DC	DFCRH.(.SV0DC,C.SVER,0D*2,SV0DC SOLO start SIO input SVC error.)
.SV38C	DFCRH.(.SV38C,C.SVER,38*2,SV38C ISIS get SIO status SVC error.)
.SV0FC	DFCRH.(.SV0FC,C.SVER,0F*2,SV0FC SOLO get SIO status SVC error.)
.SV32C	DFCRH.(.SV32C,C.SVER,32*2,SV32C ISIS force SYNC output SVC error.)
.SV30C	DFCRH.(.SV30C,C.SVER,30*2,SV30C ISIS connect SYNC SVC error.)
.LKER0	DFCRH.(.LKER0,C.SWCE,0,LKER0 LINKER found more than 0 lines on inactive link.)
.O1263	DFCRH.(.O1263,C.SWCE,0,O1263 LINKER found active link with 0 lines.)
.O1463	DFCRH.(.O1463,C.SWCE,0,O1463 LINKER found KDKN/KDSVLN inconsistency.)
.O1663	DFCRH.(.O1663,C.SWCE,0,O1663 LINKER found active line marked inactive.)
.O1863	DFCRH.(.O1863,C.SWCE,0,O1863 LINKER found NLAT .NE. sum of lines fields.)
.SIER0	DFCRH.(.SIER0,C.SWCE,0,SIER0 SOLO SIO CCW chaining failure.)
.RTZC0	DFCRH.(.RTZC0,C.SWCE,0,RTZC0 RTD detected zapper for circuit with null P/T entry.)
.RMEB0	DFCRH.(.RMEB0,C.SWCE,0,RMEB0 RMAKE found buffer empty.)
.RMZLR	DFCRH.(.RMZLR,C.SWCE,0,RMZLR RMAKE couldn't find 2nd character of 00/01 pair.)
.RMZL3	DFCRH.(.RMZL3,C.SWCE,0,RMZL3 RMAKE couldn't find 2nd character of 03 pair.)
.RMNER	DFCRH.(.RMNER,C.SWCE,0,RMNER NEDOUT <= 0 in RMAKE.)
.RMKNE	DFCRH.(.RMKNE,C.SWCE,0,RMKNE RMAKE NEEDLE ERROR)
.RMKHS	DFCRH.(.RMKHS,C.SWCE,0,RMKHS RMAKE NEGATIVE LOGICAL RECORD COUNT)
.RMHS3	DFCRH.(.RMHS3,C.SWCE,0,RMHS3 RMAKE NEGATIVE LOGICAL RECORD COUNT)
.RMZL0	DFCRH.(.RMZL0,C.SWCE,0,RMZL0 RMAKE ZERO LENGTH RECORD)
.RMNE0	DFCRH.(.RMNE0,C.SWCE,0,RMNE0 RMAKE NEEDLE OUTSTANDING, NEEDOUT NOT POSITIVE)
.RMPER	DFCRH.(.RMPER,C.SWCE,0,RMPER RMAKE BAD PERF MON CHAR)
.RMZL1	DFCRH.(.RMZL1,C.SWCE,0,RMZL1 RMAKE ZERO LENGTH RECORD)
.RMBE0	DFCRH.(.RMBE0,C.SWCE,0,RMBE0 RMAKE BUFFER EMPTY)
.RMTIE	DFCRH.(.RMTIE,C.SWCE,0,RMTIE RMAKE BAD 03-PAIR TO T-I NEIGHBOR)
.RMTNS	DFCRH.(.RMTNS,C.SWCE,0,RMTNS RMAKE):???
.RMHS2	DFCRH.(.RMHS2,C.SWCE,0,RMHS2 RMAKE ILLEGAL 02 FOR HISTORY):###TZ
.KERIC	DFCRH.(.KERIC,C.INML,0,KERIC JFFO failure.)
.KERI0	DFCRH.(.KERI0,C.SWCE,0,KERI0 KERIN found 0 P/T entry.)
.KICTC	DFCRH.(.KICTC,C.SWCE,0,KICTC XHOSTS found invalid 03 pair from kernel.)
.KRCXC	DFCRH.(.KRCXC,C.SWCE,0,KRCXC XHOSTS detected invalid control record from kernel.)
.KRXCA	DFCRH.(.KRXCA,C.SWCE,0,KRXCA XHOSTS detected invalid ack from kernel.)
.SUPIC	DFCRH.(.SUPIC,C.SWCE,0,SUPIC XHOSTS supe interface - no circuit.)
.SUPI0	DFCRH.(.SUPI0,C.SWCE,0,SUPI0 XHOSTS supe interface 0 length record.)
.SUPI1	DFCRH.(.SUPI1,C.SWCE,0,SUPI1 XHOSTS supe interface empty buffer.)
.DISI0	DFCRH.(.DISI0,C.SWCE,0,DISI0 DISPI found no dispatcher circuit.)
.DISO0	DFCRH.(.DISO0,C.SWCE,0,DISO0 DISPI got RPORT out of range from dispatcher.)
.DSOC0	DFCRH.(.DSOC0,C.SWCE,0,DSOC0 DISPI dispatcher output msg type invalid.)
.DSZE0	DFCRH.(.DSZE0,C.SWCE,0,DSZE0 DISPI got junk from dispatcher on channel 0.)
.DSIO0	DFCRH.(.DSIO0,C.SWCE,0,DSIO0 DISPI invalid message from dispatcher)
.DSKP0	DFCRH.(.DSKP0,C.SWCE,0,DSKP0 DISPI DSK type too large.)
::*	Crash codes used in SWITCH
.WCIC0	DFCRH.(.WCIC0,C.SWCE,0,WCIC0 SWITCH illegal WCI to buffer 1 or 0.)
.WCIC1	DFCRH.(.WCIC1,C.SWCE,0,WCIC1 SWITCH invalid WCI buffer index.)
.WRECR	DFCRH.(.WRECR,C.SWCE,0,WRECR SWITCH reserve tank empty.)
.GCICR	DFCRH.(.GCICR,C.SWCE,0,GCICR SWITCH GCI buffer 0.)
.GCIC0	DFCRH.(.GCIC0,C.GCEB,0,GCIC0 SWITCH GCI for empty buffer or bad buffer index.)
.CBCLC	DFCRH.(.CBCLC,C.SWCE,0,CBCLC SWITCH CBCLR bad buffer index.)
.CBCL0	DFCRH.(.CBCL0,C.SWCE,0,CBCL0 SWITCH CBCLR invalid channel number.)
.RTBLC	DFCRH.(.RTBLC,C.SWCE,0,RTBLC SWITCH RETBLT BCT went < 0)
.CRQCR	DFCRH.(.CRQCR,C.SWCE,0,CRQCR SWITCH CRQ bad buffer index.)
.CRQC0	DFCRH.(.CRQC0,C.SWCE,0,CRQC0 SWITCH CRQ needle garbage.)
.LEPCR	DFCRH.(.LEPCR,C.SWCE,0,LEPCR SWITCH LEP invalid rebild reject.)
.INTCR	DFCRH.(.INTCR,C.SWCE,0,INTCR SWITCH INHST found no work to do.)
.SUPCR	DFCRH.(.SUPCR,C.SWCE,0,SUPCR SWITCH invalid accounting data type from supe.)
.CRQC2	DFCRH.(.CRQC2,C.SWCE,0,CRQC2 SWITCH CRQ buffer out of range.)
.ZAPCR	DFCRH.(.ZAPCR,C.SWCE,0,ZAPCR SWITCH ZAPX bad IOTAB entry.)
.ZAPC0	DFCRH.(.ZAPC0,C.SWCE,0,ZAPC0 SWITCH ZAPV bad IOTAB entry.)
.ZAPC1	DFCRH.(.ZAPC1,C.SWCE,0,ZAPC1 SWITCH ZAPV bad compementary BF.)
.GFCR0	DFCRH.(.GFCR0,C.SWCE,0,GFCR0 SWITCH GFCBUF no more buffers.)
.GFCR1	DFCRH.(.GFCR1,C.IFLP,0,GFCR1 SWITCH GFCBUF invalid free list pointer.)
.GFCR2	DFCRH.(.GFCR2,C.SWCE,0,GFCR2 SWITCH GFCBUF invalid link buffer pointer.)
.GFCR3	DFCRH.(.GFCR3,C.SWCE,0,GFCR3 SWITCH GFCBUF bad buffer index.)
.RFCR0	DFCRH.(.RFCR0,C.SWCE,0,RFCR0 SWITCH RFCBUF invalid buffer index.)
.FNCHC	DFCRH.(.FNCHC,C.SWCE,0,FNCHC SWITCH FNDCHN ACP consistency error.)
.FNCH0	DFCRH.(.FNCH0,C.SWCE,0,FNCH0 SWITCH FNDCHN ACP/IOTAB consistency error.)
.BUBCR	DFCRH.(.BUBCR,C.SWCE,0,BUBCR SWITCH BUBBLE BF/NIOTAB consistency error.)
.BUBC0	DFCRH.(.BUBC0,C.SWCE,0,BUBC0 SWITCH BUBBLE LKAPND consistency error.)
.BUBC1	DFCRH.(.BUBC1,C.SWCE,0,BUBC1 SWITCH BUBBLE IOTAB consistency error.)
.CBCT0	DFCRH.(.CBCT0,C.SWCE,0,CBCT0 SWITCH CBCCT-BCT consistency error.)
.ASLO0	DFCRH.(.ASLO0,C.SWCE,0,ASLO0 ASYNC ASYLOU no ANITAB entry for port.)
.ASLO1	DFCRH.(.ASLO1,C.SWCE,0,ASLO1 ASYNC ASYLOU ANITAB entry not complement of .LGBUF.)
.ASC20	DFCRH.(.ASC20,C.SWCE,0,ASC20 ASYNC 02 character pair toward port.)
.ASC30	DFCRH.(.ASC30,C.SWCE,0,ASC30 ASYNC invalid 03 character pair toward port.)
.ASY30	DFCRH.(.ASY30,C.SWCE,0,ASY30 ASYNC illegal ALIERR code.)
.GCHCR	DFCRH.(.GCHCR,C.SWCE,0,GCHCR ASYNC invalid prefix code.)
.PTSGC	DFCRH.(.PTSGC,C.SWCE,0,PTSGC ASYNC invalid signal from CONSAT.)
.ASLO2	DFCRH.(.ASLO2,C.SWCE,0,ASLO2 ASYNC)
.CPKCR	DFCRH.(.CPKCR,C.SWCE,0,CPKCR ASYNC)
:
:	NEW CRASH CODES TYPE C.SWCE ARE ADDED HERE REGARDLESS OF LOCATION
:	IN THE CODE IN ORDER TO LEAVE PREVIOUS C.SWCE CRASH SUBTYPES THE SAME
:	(C.SWCE CRASH SUBTYPES ARE SEQUENTIAL BY ORDER OF DFCRH. INVOKATIONS).
:
.RMHS4  DFCRH.(.RMHS4,C.SWCE,0,RMHS4 YAKYAK RMAKE LRC<0 after fat gob shrink.)
.NEGBF	DFCRH.(.NEGBF,C.SWCE,0,NEGBF YAKYAK BFLTSV<0 AFTER BUFFERLET ACQ OR REL)
.NEGHB	DFCRH.(.NEGHB,C.SWCE,0,NEGHB YAKYAK HBFTSV<0 AFTER HIST BUF ACQ OR REL)
.WREFL	DFCRH.(.WREFL,C.SWCE,0,WRE SWITCH ILLEGAL CALL TO WRE - POSSIBLE MACERROR)
.CSCRS	DFCRH.(.CSCRS,C.SWCE,0,CONSAT CRASH - R10 = CALLER)
.XSCRH	DFCRH.(.XSCRH,C.SWCE,0,XRAY set-by-user crash: SC command)
.SNICR	DFCRH.(.SNICR,C.SWCE,0,DISPI bad SNI recv'd from sup)

.STKOV	DFCRH.(.STKOV,C.SWCE,0,stack storage overflow)  :##AL
.STKUN	DFCRH.(.STKUN,C.SWCE,0,stack storage underflow) :##AL

:	The following crash codes are for solo consat.	###LSH

.GCBF0	DFCRH.(.GCBF0,C.SWCE,0,GETCHR negative buffer number)
.GCBF1	DFCRH.(.GCBF1,C.SWCE,0,GETCHR invalid buffer 0)
.GCBF2	DFCRH.(.GCBF2,C.SWCE,0,GETCHR BF of buffer is dead)
.GTCR1	DFCRH.(.GTCR1,C.SWCE,0,GETCHR negative value in PFXSIG table)
.GTCR2	DFCRH.(.GTCR2,C.SWCE,0,GETCHR illegal 02 pair)
.GTCR3	DFCRH.(.GTCR3,C.SWCE,0,GETCHR invalid 03 pair)
.PCBF1	DFCRH.(.PCBF1,C.SWCE,0,PUTCHR invalid buffer 0)
.PCBF2	DFCRH.(.PCBF2,C.SWCE,0,PUTCHR BF of buffer is dead)
.PSBF1  DFCRH.(.PSBF1,C.SWCE,0,PUTSIG invalid buffer 0)
.PSBF2	DFCRH.(.PSBF2,C.SWCE,0,PUTSIG BF of buffer is dead)
.PSGR0	DFCRH.(.PSGR0,C.SWCE,0,PUTSIG signal number too large)
.PSGR1	DFCRH.(.PSGR1,C.SWCE,0,PUTSIG invalid signal)
.SNDR0	DFCRH.(.SNDR0,C.SWCE,0,SNDLOG get a signal from .LGBUF)
.EMTR0	DFCRH.(.EMTR0,C.SWCE,0,EMPTY BF of buffer is dead)
.ASYRW	DFCRH.(.ASYRW,C.SWCE,0,ASYNC RING WRAP)
::      Some crashes of log 2
.LEP0A  DFCRH.(.LEP0A,C.SWCE,0,LEP0A Illegal message)
.DSISN  DFCRH.(.DSISN,C.SWCE,0,ISN needle data missing)
.GCD0   DFCRH.(.GCD0,C.SWCE,0,GCD discovered corrupted bufferlet chain)

	SUBTTL	DATA (EQuates and constants)

::*********************************************************************
::
::	EXEC PARAMETERS:
::
::*********************************************************************

VERSION	EQ	$8 0534!10000!30000*T2GATE :VERSION NUMBER

REVLEV	EQ	(VERSION)&($877)	:REVISION LEVEL
CTBVER	EQ	1			:CRASH TABLE VERSION

FASTC	EQ	0F0004		:FASTC
LO.CLK	EQ	0F001C		:SEGF HW REFERENCE PTR TO SLOT CLOCKS	###OAS
	SYAD(FASTC )
SLOWC	EQ	0F0008		:ISIS MAINTAINS SLOWC RESOLVED TO A SECOND
	SYAD(SLOWC )
     IF T2GATE                  :gateway has no kernel
IKERNL  EQ      0
     ELSE
IKERNL	EQ	1		:ENABLE ISIS KERNEL CODE
     EI
NHOSTS	EQ	NUMHST		:# OF HOSTS, TYMFILE SPEC (DEFAULTED 64 OR 128)
MLINEL	EQ	1F		:MASK FOR MAX NUMBER OF LINES

:	OTHER DEFINITIONS:
RECBSZ	EQ	$A 144	:SIZE OF RECORD BUFFERS +16 so no copy sio output
SVNBSZ	EQ	100		:SIZE OF SYNC LINE INPUT BUFFERS
RATE	EQ	$A600		:FAST CLOCK TICKS/SEC

:	NSTART WILL MOVE SIOBYT BYTES FROM SIOINT TO SIOIPG FOR SIO INIT
	IF	SILINS
SIOBYT	EQ	30
	EI	:SILINS

::*********************************************************************
::
::	LINKER PARAMETERS:
::
::*********************************************************************

	RA	0A		:SET DECIMAL RADIX

	DEFAULT(DEFWSZ,8)		:DEFAULT WSIZ (Tymfile parameter)##wjl

::	Compute total number of physical records to be reserved
NRECDS	EQ	0		
Q	EQ	0
	RE	NLINKS
	DEFAULT(WSIZ|Q|,DEFWSZ)		:Window size defaults to 8	###wjl
NRECDS  EQ      NRECDS+2*WSIZ|Q|	:this link is tunnel or not, the
Q	EQ	Q+1			:			###EV
	ER

	RA	0		:RESTORE HEX RADIX

:	CALCULATE PERMUTER TABLE SPACE - INCLUDE NSP IN CALCULATIONS	###gt
:                                       - include NDP                   ###sdw
TCHANS	EQ	80*(NLINKS+2+2*NPTHR/80+NSP/80+ndp/80) :TOTAL NUMBER OF LINK CHNS

TINTCH	EQ	$A 16		:TOTAL NUMBER OF INTERNAL HOST CHANNELS
				:.... MUST BE POWER  OF 2

:	SYNC LINE TRACE OPTION:

	IF	DB.TSN
	IF	T2GATE
	DEFAULT(TSTSZE,80)
	ELSE
	DEFAULT(TSTSZE,200)	:200 BYTES, 200/TSESZE ENTRIES
	EI	:T2GATE
	ELSE	:NOT DB.TSN
TSTSZE	EQ	0		:IF NOT DB.TSN, TRACE-SYNC TABLE SIZE = 0
	EI 	:DB.TSN

:	NOTE THAT IF DB.TSN IS SPECIFIED AND TSTSZE IS DEFINED WITH
:	A ZERO VALUE, THE TRACE-SYNC OPTION IS NOT ENABLED. IF TSTSZE IS
:	SPECIFIED, IT MUST BE A POWER OF 2.

	IF	TSTSZE

:	TRACE-SYNC PACKAGE ENABLED. AN ENTRY IS MADE IN A TABLE FOR EACH
:	SYNC LINE EVENT DETECTED FOR A PARTICULAR LINK OF INTEREST. WHEN THE
:	OPTION IS ENABLED IN A NODE, THE TRACING BEGINS WHEN THE 'TSLINK'
:	HALFWORD IS PATCHED WITH THE NEIGHBOR NUMBER ON THE LINK TO BE TRACED.
:	SYNC LINE EVENTS FOR ALL LINES ON THE LINK ARE RECORDED. THE TRACING
:	ENDS WHEN THE NODE DECLARES THE LINK OUT, EITHER BY DETECTING A RESET
:	OR BY RECEIVING NO GOOD RECORDS IN A FOUR-SECOND INTERVAL. EACH SYNC
:	ENTRY IS TSESZE (8) BYTES LONG, WITH THE FORMAT:
:
:	______________________________________________________________
:
:	| TYPE | LINE |      PACKET HEADER     |      FASTC TIME     |
:	______________________________________________________________
:	   1       1	       3 BYTES		       3 BYTES
:
:	SINCE THE SYNC LINE RECEIVER ROUTINES (SYLVER) RUN AS A FOREGROUND
:	PROCESS IN ISIS, TWO TABLES ARE MAINTAINED: TSFTBL FOR FOREGROUND (LINE
:	RECEIVER) EVENTS, AND TSBTBL FOR BACKGROUND (ATTACH, DETACH, RTD, AND
:	RMAKE) EVENTS. THE EVENT TYPES ARE DEFINED AS FOLLOWS:
:
:	BACKGROUND:
TS.ATT	EQ	3	:LINE ATTACH - HAS 'NLAT' VALUE FROM LINK DESCRIPTOR
			: INSTEAD OF HEADER IN BYTES 2 AND 3.
TS.DET	EQ	2	:LINE DETACH - HAS 'LRT' VALUE FROM LINK DESCRIPTOR
			: INSTEAD OF HEADER IN BYTES 2 AND 3,
			: AND 'DREASON' IN BYTE 4.
TS.MAK	EQ	0	:PACKET QUEUED FOR TRANSMISSION BY RMAKE. BYTE 1 IS
			: 'LAS', BYTE 2 IS FIRST BYTE OF PACKET,
			: BYTE 3 IS 'LRT', BYTE 4 IS PACKET RECORD NUMBER.
TS.RTD	EQ	1	:PACKET TORN BY RTEAR. BYTE 1 IS 'LAS', BYTES 2 - 4
			: ARE ACTUAL PACKET HEADER.

:	FOREGROUND:
TS.HDR	EQ	0	:A ZERO BIT HAS BEEN DETECTED WHILE LINE IS IN MARKING
			: STATE. ALIGNED POTENTIAL HEADER IS IN FIRST 2
			: BYTES OF HEADER FIELD.
TS.RST	EQ	1	:RESET DETECTED ON ATTACHED LINE.
TS.DUM	EQ	2	:DUMMY RECORD DETECTED.
TS.REC	EQ	7	:ENTIRE RECORD RECEIVED WITH GOOD CHECKSUM.
TS.CSE	EQ	3	:ENTIRE RECORD RECEIVED, CHECKSUM ERROR DETECTED.
TS.BAK	EQ	4	:ENTIRE GOOD RECORD RECEIVED, BAD ACK. HAS 'LAR' VALUE
			: FROM LINK DESCRIPTOR IN BYTES 5 AND 6.
TS.RXC	EQ	5	:ENTIRE GOOD RECORD RECEIVED, RETRANSMISSION.
TS.BRN	EQ	6	:ENTIRE GOOD RECORD RECEIVED, BAD RECORD NUMBER.
TS.UAL	EQ	8	:HEADER RECEIVED ON UNASSIGNED LINE
	IF	NAKCOD
TS.NAK	EQ	9	:FORGROUND TRACE FOR NAK PACKET			###AL
	EI
:	NOTE THAT SOME EVENTS UTILIZE ONLY 2 BYTES OF HEADER FIELD
:	IN THAT CASE ALL FOUR BYTES OF FASTC APPEAR.

TSESZE	EQ	8		:ENTRY SIZE (IN BYTES)
	EI	:TSTSZE

WBORIM	EQ	$2 00100000     :T-II MASTER BORI
WBORIS	EQ	$2 00010000     :T-II SLAVE BORI
NAKORI	EQ	$2 01010000	:T-II STARLINK NEGATIVE ACK PACKET
SATSPD  EQ      $2 01000000     :FOR DENOTING SATELLITE TO SUP

RBOTHD	EQ	3010		:TYMSTAR HUB REMOTE-BOOT HEADER		###AL

:	RESET HEADERS
TTRSHD	EQ	30A0		:T-II RESET HEADER FOR NEW LINK
TSRSHD	EQ	30B0		:T-II RESET HEADER FOR SUBSEQUENT LINE ON LINK
TRRSHD	EQ	30C0		:SCLP reset header			###wjl

TWDMHD	EQ	306978AB	:TYMNET-II DUMMY RECORD
DWNLHD	EQ	3232		:DOWNLINE LOAD RECORD HEADER

KDIGTM	EQ	$A 120		:NUMBER OF SECONDS TO IGNORE LINE WHICH DID
:	NOT PASS PROPER KEY IN RESET SEQUENCE, OR COULDN'T BE ATTACHED DUE TO
:	LACK OF PERMUTER TABLE SPACE.

:	SUP REPORTS ARE TYPE 14, SUBTYPE xx, WHERE xx IS:
LKOVMS	EQ	93		:LINK OVERLOADED SUBTYPE
LKSTMS	EQ	94		:LINK SATURATED SUBTYPE

:	DEFAULT THRESHOLDS ARE DEFINED AS FOLLOWS:

	DEFAULT(LKOVTH,$A 10)	:DEFAULT LINK OVERLOAD THRESHOLD TO 10
	DEFAULT(LKSTTH,$A70)	:DEFAULT SATURATED THRESHHOLD		###TZ


::*********************************************************************
::
::	YAKYAK PARAMETERS:
::
::*********************************************************************

	DEFAULT(TRIKLV,4)	:THRESHOLD FOR RTD TO DETERMINE 'GUSH' OR
				: 'TRIKLE' BACKPRESSURE REQUIREMENTS

	DEFAULT(T2SRVS,40)	:T-II THRESHOLD FOR SUCCESSIVE CHANNEL SERVICE
				: (SEE RMK10)

::*********************************************************************
::
::	XHOSTS PARAMETERS:
::
::*********************************************************************

:	HOST PID EQUATES
I2ISTP	EQ	37		:ISIS PID				###OAS
TIITYP	EQ	38		:SOLO NODE CODE PID			###OAS
CNSTYP	EQ	39		:SOLO CONSAT PID			###OAS
SUPTYP	EQ	43		:SUPVERSIOR KERNEL PID			###OAS
SKERTY	EQ	48		:SPLIT SUPERVISOR(KERNEL) PID		###OAS

	IF	KNRING
:	DEFINE MESSAGE TYPES FOR CONTROL RINGS
KR.ZAP	EQ	0		:ZAPPER
KR.GOB	EQ	1		:GOBBLER
KR.NLG	EQ	2		:NEWLOG SET-UP
KR.ACK	EQ	80		:INDICATES ACK RESPONSE
KR.ZAK	EQ	KR.ZAP+KR.ACK	:ZAPPER ACK
KR.GAK	EQ	KR.GOB+KR.ACK	:GOBBLER ACK

	IF 	SIORNG		:ALSO IF KNRING
SIRDIE	EQ	30^8+SIORNG	:COMMAND FOR SIO RING CARD TO DIE
SIRALV	EQ	31^8+SIORNG	:COMMAND FOR SIO RING CARD TO COME ALIVE
SIRDWN	EQ	30		:STATUS INDICATING SIO BOARD DOWN (LINE OUT)
SIRUP	EQ	70		:STATUS INDICATING SIO BOARD UP
SIRRM0	EQ	20		:STATUS FOR RING PAIR 0 MISMATCH FROM SIO CARD
STSRM0	EQ	3F		:'SIRFLG' VALUE FOR RING MISMATCH 0
SIRALD	EQ	403F		:'SIRFLG' VALUE FOR ACTIVE LOAD
SIRILN	EQ	3F		:'LINE NUMBER' FOR DOWN-LINE LOAD
SIRDLS	EQ	$A 66*2		:SIO LOAD RING SIZE
DWLKIB	EQ	SIRDLS+40000	:INPUT LOAD RING (NODE-->KERNEL)
DWLKII	EQ	DWLKIB		:LOAD RING LOAD POINTER (NODE INDEXED)
DWLKIO	EQ	DWLKII+2	:LOAD RING TRAIL POINTER (KERNEL INDEXED)
DWLKOB	EQ	DWLKIO+2+SIRDLS	:OUTPUT LOAD RING (KERNEL-->NODE)
DWLKOI	EQ	DWLKOB		:OUTPUT RING LEAD POINTER (KERNEL INDEXED)
DWLKOO	EQ	DWLKOI+2	:OUTPUT RING TRAIL POINTER (NODE INDEXED)

SIRXSZ	EQ	80		:SIZE OF INTERRUPT COMMUNICATION RING
	EI	:SIORNG
	EI	:KNRING

::*********************************************************************
::
::	DISPI PARAMETERS:
::
::*********************************************************************


:	Intra-node messages.  Compare with DSZETB jump table for
:	from-dispatcher messages.
INRSRQ	EQ	0	:restart request (unused)
INRSRP	EQ	1	:restart response (unused)
INTKVR	EQ	2	:node has been taken over (from node code)
INRPLG	EQ	3	:report to sup's log (from slot to node code)
INRPHT	EQ	4	:report host status (from ISIS or slot)
INRPAC	EQ	5	:report accounting (ISIS to node code)
INSTTM	EQ	6	:tell host what time it is (from node code)
INPNRQ	EQ	7	:pseudo-needle request (from slot to node code)
INACRQ	EQ	8	:aux-circuit request (from slot to node code)
INPNFL	EQ	9	:pseudo needle request failed (from ISIS or node code)
INRPPT	EQ	0A	:report host port availability (from slot)
INHTRJ	EQ	0B	:host unacceptable (from node code)
INRPCT	EQ	0C	:report host cost (from slot to node code)
INNOSP	EQ	0D	:no supervisor (node code to all slots)
IN1DWN	EQ	0E	:1_DOWN text follows (to slot)
INHTRQ	EQ	0F	:request for report of all hosts (from node code)
INRPHE	EQ	10	:extended host status report (from slot or ISIS)
NCHCST	EQ	88	:host status host cost message type
:	Host status codes for HSTAT
HANSW	EQ	0	:###EV
HDOWN	EQ	1
HSHUT	EQ	2
HGONE	EQ	3

:	Bits in HSTATN byte for EXPANDED HOST STATUS	###jhl
:	The format of this word matches the host status word in the
:	expanded takeover response, node-to-sup msg 19.
EHANSW	EQ	0
EHDOWN	EQ	40
EHSHUT	EQ	80
EHGONE	EQ	0C0
EHSTTS	EQ	0C0		:location of status bits
EHHOPT	EQ	20		:set if host out of ports
EHIIX	EQ	10		:IIX host
EHORGN	EQ	8		:origination only host
EHDSTN	EQ	4		:destination only host

:	Translated values of network messages to send to ISIS
ISDTCH	EQ	09E	:DETACH	###wjl
ISZAPR	EQ	09F	:ZAPPER
ISSTBP	EQ	0A0	:SET BACKPRESSURE
ISRLBP	EQ	0A1	:RELEASE BACKPRESSURE
ISGBLR	EQ	0A2	:GOBBLER
ISBLKB	EQ	0A4	:BLACK BALL
ISGRYB	EQ	0A5	:GREY BALL
ISEDEM	EQ	0A6	:ENTER DEFERRED ECHO MODE
ISLDEM	EQ	0A7	:LEAVE DEFERRED ECHO MODE
ISETRM	EQ	0A8	:ENTER TRM
ISLTRM	EQ	0A9	:LEAVE TRM
ISGRBL	EQ	0AA	:GREEN BALL
ISRDBL	EQ	0AB	:RED BALL
ISYLWB	EQ	0AC	:YELLOW BALL
ISRNGB	EQ	0AD	:ORANGE BALL
ISBRKD	EQ	0AE	:DETECTED BREAK
ISHANG	EQ	0AF	:HANG UP
ISQPRM	EQ	0B0	:QUERY PARAMETER
ISSPRM	EQ	0B1	:SET PARAMETER
ISLGCH	EQ	0B3	:LOGON CHAR
ISACCT	EQ	0B7	:ADDENDUM TO ACCOUNTING
ISHNG	EQ	0B8	:SUPERHANG
ISXLIM	EQ	0B9	:SET XMIT LIMIT
ISEBRK	EQ	0BA	:END OF BREAK
ISZACK	EQ	0BB	:ZAP ACK
ISEADM	EQ	0BC	:ENTER ALTERNATE DEVICE MODE
ISLADM	EQ	0BD	:LEAVE ALTERNATE DEVICE MODE
ISZRSN	EQ	0BE	:ZAP WITH REASON
ISSIIX	EQ	0BF	:ENTER IIX EXCHANGE
ISTIIX	EQ	0C0	:LEAVE IIX EXCHANGE
ISLISN  EQ      0C2     :Log2 ISIS needle
ISRCRI  EQ      0C3     :Log2 response for terminal in logon mode
ISICRS  EQ      0C4     :Log2 supplemental logon information
ISASLP  EQ      0C5     :Log2 Assign Logon port
ISLGSC  EQ      0C6     :Log2 Logon Successful (to origination)

INXLIM	EQ	9D		:INITIAL XMIT LIMIT
DTDAT	EQ	9D		:LAST DATA TYPE
       IF       LOGII           :logon has last few new messages
DTCON   EQ      0C4
       ELSE     :LOGII
DTCON	EQ	0C0		:LAST CONTROL TYPE
       EI       :LOGII

:	SET DEFAULT VALUES FOR SCLTDF AND SMLTDF TO -1, INDICATING
:	NO LIMITS FOR CIRCUITS/MINUTE AND SLOT REPORTS/MINUTE BY SLOT.
	DEFAULT(SCLTDF,-1)
	DEFAULT(SMLTDF,-1)

:	SET VALUES FOR LIMITS FOR EACH SLOT TO THE DEFAULT IF NOT
:	ALREADY DEFINED.
	IF	(1-T2GATE)
Q	EQ	1
	RE	NUSLT
	DEFAULT(SCLT|$0Q|,SCLTDF)
	DEFAULT(SMLT|$0Q|,SMLTDF)
Q	EQ	Q+1
	ER
	EI	:(1-T2GATE)		###EV

        SUBTTL	DATA (X.409 Identifiers for LOG II)

::****************************************************************
::
::       The following equates the LOG2 x.409 ID and MOs with
::       their name and number.  It should not cause any concern that
::       many (if not most) of the equates are never used again.
::       Under LOG 2, NC passes most of the x,409 data without examining
::       it.
::
::****************************************************************

IDLGSC  EQ      1               :Logon success indicator (to origination)
ID.CCT  EQ      2               :MO containing the CCT
ID.RIX  EQ      3               :boolean IIX request indicator
ID.LGS  EQ      4               :logon status (normal response code)
ID.RUN  EQ      5               :boolean UUN request indicator
ID.BAT  EQ      6               :boolean batch circuit request
ID.OAD  EQ      7               :origination address
ID.ULC  EQ      8               :unparsed logon characters
ID.TPC  EQ      9               :throughput class
ID.COS  EQ      0A              :cost table
ID.ZAP  EQ      0B              :logon zap
ID.IRC  EQ      0C              :username's IRC
ID.THS  EQ      0D              :term host #
ID.OHS  EQ      0E              :orig host #
ID.HDX  EQ      0F              :boolean half duplex indication
ID.REV  EQ      10              :reverse charge call request
ID.NNL  EQ      11              :needle node list
ID.UNM  EQ      12              :username
ID.UUN  EQ      13              :UUN value
:       EQ      14              :acknowledge logon zap
ID.TAR  EQ      15              :target selection and qualification
ID.OPT  EQ      16              :logon options list
ID.SDL  EQ      17              :specified destination list
ID.RDA  EQ      18              :resultant destination address
ID.EXT  EQ      19              :host extension
ID.PRT  EQ      1A              :originating port number (real dport#)
ID.INF  EQ      1B              :ISN needle flags
ID.PWD  EQ      1C              :password for transparent logons
ID.ISN  EQ      1D              :ISN needle identifier
:       EQ      1E              :unused
ID.NCB  EQ      1F              :Node Code needle body identifier
ID.MSG  EQ      20              :message from supe to logon terminal
ID.NCF  EQ      21              :NCN flags
ID.NCH  EQ      22              :NCN head identifier
ID.ESC  EQ      23              :logon session reset (escape typed)
ID.NRJ  EQ      24              :node code generated rejects
ID.CNF  EQ      25              :CCN flags
ID.INV  EQ      26              :invoice number
ID.SRJ  EQ      27              :supe generated reject codes
ID.LNK  EQ      28              :number of links (nodes) circuit crosses
ID.ERC  EQ      29              :early (like psn reject) reject codes
ID.CCN  EQ      2A              :CCN identifier
ID.ONM  EQ      2B              :orig node number
ID.LTM  EQ      2C              :not a log 2 destination
ID.CCS  EQ      2D              :circuit cost
ID.TLI  EQ      2E              :transparent logon indication
ID.SHT  EQ      2F              :shut override
ID.SHN  EQ      30              :sub host number
ID.TIX  EQ      31              :tells origination if dest iix cap
IDRCRI  EQ      32              :RCRI identifier
ID.RMF  EQ      33              :RCRM flags
IDICRM  EQ      34              :ICRM identifier
:       EQ      35              :
ID.DIS  EQ      36              :dispatcher info sequence
ID.IMF  EQ      37              :ICRM flags
IDECRI  EQ      38              :ECRI identifier
ID.EIF  EQ      39              :ECRI flags
IDICRS  EQ      3A              :ICRS identifier
IDRCRM  EQ      3B              :ICRM identifier
IDNCRM  EQ      3C              :NCRM identifier
ID.NMF  EQ      3D              :NCRM flags
ID.RIF  EQ      3E              :RCRI flags
:       EQ      3F              :undefined
ID.NDT  EQ      40              :needle data (contain data for ISN)
ID.RPD  EQ      41              :PID of rejecting host
ID.OPD  EQ      42              :PID of originating host
ID.TPD  EQ      43              :PID of terminating host
ID.GOM  EQ      44              :gateway to origination logon msg
ID.OGM  EQ      45              :origination to gateway msg
ID.PGT  EQ      46              :passthrough generated text msg
ID.GGT  EQ      47              :gateway generated text msg

:       the following two are defined as part of x.409.  ie the
:       leading bits do not indication application ID.

RMOID   EQ      30              :with the constructor bit set (app bit off)
SMOID   EQ      31              :with the constructor bit set (app bit off)

:       following defined equates for the leading bits of the x.409 id

MO.C    EQ      20              :the constructor bit
IDBITS  EQ      1F              :the ID bits
MO.A    EQ      40              :the application bit
MO.AC1  EQ      60              :application/construction header for onebyte id
MO.AC2  EQ      7F00            :application/construction header for twobyte id
MO.A1   EQ      40              :application bit for 1 byte ID
MO.A2   EQ      5F00            :application bit for 2 byte ID
MO.LFM  EQ      80              :len is long form

:       following are names for bits in bit string MOs

L2F.AX  EQ      80              :aux circuit request
L2F.SQ  EQ      40              :subsequent logon info
L2F.ZA  EQ      40              :logon zapper ack
L2F.RJ  EQ      20              :logon is being rejected
L2F.CC  EQ      80              :command circuit needle - not supported
L2F.RC  EQ      40              :rebuild needle - not supported
L2F.IC  EQ      20              :intra node circuit
L2F.N2  EQ      10              :not log 2 dest
L2F.PN  EQ      08              :passthrough log II
L2F.PT  EQ      80              :partial log II ISIS msg
L2F.SP  EQ      40              :second piece of an ISIS log II msg
L2F.DL  EQ      1               :licensed to build aux circuit
L2F.NC  EQ      0
       IF       LOGII           :report to supe as LOG II NC
L2F.NC  EQ      4000            :in takeover say NC is log II capable
       EI       :LOGII
L2F.TK  EQ      40              :bit in takeover msg saying LOG II supe
L2F.DK  EQ      80              :tell dispatcher a LOG II supe
L2F.BT  EQ      4               :tell if circuit path is batch cost table

:       following are used in the MO create logic to determine the status
:       and location of the data for the MO

X4C.DT  EQ      0               :data is stored in table
X4C.UC  EQ      1               :unfinished constructor
X4C.BF  EQ      2               :data is stored in buffer (address in table)
X4C.MM  EQ      4               :data is stored in memory (address in table)
X4C.CC  EQ      8               :constructor completed


::*********************************************************************
::
::	SWITCH PARAMETERS:
::
::*********************************************************************

LOGBUF	EQ	4

:	TOTAL NUMBER OF CIRCUITS TERMINATING ON THE NODE
NLQ	EQ	8			:# of circuits to the LEPrechaun
NIQ	EQ	2*NLINKS		:# of Internode circuits (ILC, BPM)
	DEFAULT(NNODES,80)		:ISIS Sup/Node Code Tymfile parameter
NSPC	EQ	NNODES*SUPER/SUPER	:# of Sup circuits		###wjl
NTERMS	EQ	NLQ+NIQ+NKU+NDP+NSPC	:# of terminations

:	NUMBER OF CIRCUITS PASSING THROUGH THE NODE
NPASTH	EQ	(1-PTHRU)*NPTHR		:number of passthroughs allowed

:	NUMBER OF EXTRA COMMAND CIRCUITS in case node goes out of passthrus
	DEFAULT(NXCMDC,20)		:Tymfile parameter 		###wjl

:	NUMBER OF EXTRA LOGIN CIRCUITS

:	TOTAL NUMBER OF CIRCUITS ON THE NODE
	IF	T2GATE
NCIRCS	EQ	NLQ+NIQ+NDP+NXCMDC		:total cks thru gw node
	ELSE	:NOT GATEWAY
NCIRCS	EQ	NTERMS+NPASTH+NXCMDC	:total circuits thru node##LSH
	EI	:T2GATE


:       do BCT since microcode won't help us
CBCCTM  MACRO(RA,RB,RS)[
        LHL     RS,BB+2,RB,
        NHI     RS,CBSZ-1
        LHL     RA,BE+2,RB,
        NHI     RA,CBSZ-1
        SR      RA,RS
        LHL     RS,BCT,RB,              :for BCT > 7FFF                 ###wjl
        AR      RA,RS                   :  will cause crash             ###wjl
]
        DEFAULT(CBSZL,6)        :default to 64 byte bufferlets
CBSZ	EQ	1^CBSZL		:SIZE OF BUFFERLETS
CBPTSZ  eq      2               :size of pointer

:	DEFINE CIRCUIT BACKPRESSURE CONSTANTS FOR THROUGHPUT CLASSES 0 TO 3.
:	EACH CIRCUIT MAY MOVE THIS MANY CHARACTERS PER HALF-SECOND BEFORE
:	BEING BACK-PRESSURED.

CIRSP0	EQ	$A32		:BPS CONSTANTS FOR CIRCUIT SPEEDS
CIRSP1	EQ	$A80
CIRSP2	EQ	$A256
CIRSP3	EQ	$A1024

:	TYMNET CONTROL CHARACTERS AND CHARACTER PAIRS:

ZAPPH	EQ	0301	:HARD ZAPPER
ZAPMIN	EQ	0301	:SMALLEST ZAPPER
ZAPPS	EQ	0302	:SOFT ZAPPER
ZAPPN	EQ	0303	:NON-GOBBLING ZAPPER
ZAPMAX	EQ	0303	:LARGEST SKINNY ZAPPER
ZAPPF	EQ	0304	:FAT ZAPPER (NODE PAIR FOLLOWS)
GOBBL	EQ	0308	:GOBBLER
GOBBF	EQ	0309	:FAT GOBBLER (NEW SEQUENCE NUMBER IN SECOND HW)
SQSET	EQ	030A	:SQSET - FORCES RECEIVE SEQNUMBER TO FOLLOWING DATA HW
SQFIX	EQ	030B	:SQF - SEQUENCE NUMBER FIX FOR REBUILD
SQACK	EQ	030C	:SQACK - SEQUENCE NUMBER ACK FOR REBUILD
NEEDP	EQ	0310	:NEEDLE POINT
NEEDE	EQ	0311	:NEEDLE EYE
TILIM	EQ	0312	:MESSAGE FOR TERMINAL IN LOGIN
LOGRR	EQ	0313	:ERROR IN CIRCUIT REQUEST
COMET	EQ	0314	:buffer timer pair ###jhl

:       following are new network control pairs for LOG 2
:       these are internal and are directed only towards the dispatcher

L2SRJT  EQ      0315            :for dispi, response/reject logon from supe
L2NRJT  EQ      0316            :for dispi, response/reject logon from node
LG2EYE  EQ      0317            :for dispi, needle eye for log 2
NEEDCV  EQ      0318            :tells dispi this LOGI needle has LOG II ISN
:       control pairs that can be sent along the circuit
NEEDHD  EQ      0329            :needle head for log 2
NEEDBD  EQ      032A            :needle body for log 2
NEEDTL  EQ      032B            :needle tail


:	PERFORMANCE MONITORING CONTROL CHARACTERS
:	CONTROL CHAR PAIRS 03-20 TO 03-3F ARE RESERVED FOR THIS PURPOSE
:	THESE CHARS ARE THE SECOND BYTE IN A 03-XX CHAR PAIR

XLAX	EQ	20	:XLAX IS LIKE TIMER, BUT HOPS TO HEAD OF USER DATA
XLACK	EQ	21	:XLAX ACK IS RETURNED BY TERMINATING NODE
TIMER	EQ	22      :TIMER MEASURES DELAY ON USER CRQ, MOVES WITH USER DATA
TIMACK	EQ	23      :TIMER ACK IS RETURNED BY TERMINATING NODE
REJECT	EQ	24	:RESPONSE BY TERMINATING NODE TO UNKNOWN CHAR PAIR
REAMER	EQ	25	:REAMER OPENS UP A CRQ

:	DEFINE BIT POSITIONS IN NEEDLE FLAG:

NF.REB	EQ	1	:REBUILD CIRCUIT
NF.CMD	EQ	2	:COMMAND CIRCUIT
:NF.T1O	EQ	4	:TYMNET-I ORIGINATION :no longer used
:NF.T1D	EQ	8	:TYMNET-I DESTINATION :no longer used
NF.LG2	EQ	8	:set if LOG II information follows needle
NF.BAT  EQ      40      :batch circuit request
NF.PRI	EQ	100	:PRIORITY CIRCUIT
NF.SMC	EQ	200	:SMART CIRCUIT (SIQ ORIGINATION, HIQ HOST)
	IF	EXPNDL
NF.SNI	EQ	4000	:set by sup if SNI list present in needle	###jhl
	EI	:EXPNDL
NF.INT	EQ	8000	:INTERNAL CIRCUIT IF RESET (SET, RESET BY NODE CODE)
:       these flags are in the user flag HW in the needle
NF.HDX  EQ      200     :halfduplex
NF.CCL  EQ      40      :collect call

:	Login state flags.  These values are stored in the BF of a
:	login input buffer and they indicate the state of the login.
LOGSUP	EQ	04		:Bit means OK to send data to sup
LOGNDC	EQ	02		:Bit means node code ready to xmit login data
LG.TID	EQ	01		:Bit means TID is still in login buffer (hasn't
				:been sent to the sup yet).
LGSNT.	EQ	10+LOGSUP+LG.TID+LOGNDC	:SUP=Y, NC=Y, TID=Y
LGST.N	EQ	10+LOGSUP+LG.TID	:SUP=Y, TID=Y, NC=N
LGN.ST	EQ	10+LOGNDC		:NC=Y, SUP=N, TID=N
LG.SNT	EQ	10			:SUP=N, NC=N, TID=N
LGSN.T	EQ	10+LOGSUP+LOGNDC	:SUP=Y, NC=Y, TID=N
LOGXMT	EQ	10+LOGSUP+LOGNDC	:SUP=Y, NC=Y, TID=N
LOGMIN	EQ	10			:Minimum valid state flag
LOGMAX	EQ	17			:Maximum valid state flag

:	EQUATES FOR TEMPERATURE REPORTING--RANGES AND DELAY TIME.	###JHL
DLYTMP	EQ	$A 14		:INHIBIT TEMP RPT FOR 15 4 MIN INTERVALS
TOOHOT	EQ	26		:ISIS CONVERTS MF READING TO CENTIGRADE

:	HANDLE DATA FOR 'DETACHED PORTS'
:	THE FOLLOWING EQUATES IDENTIFY THE DETACH REASONS:
DETR00	EQ	0	:DISPATCHER OUT OF PORTS. DETECTED IN CRQ.
DETR01	EQ	1	:HOST OUT OF PORTS. DETECTED IN CRQ.
DETR02	EQ	2	:ZAP WITH REASON, HOST OUT OF PORTS. HANDLED IN DSOZWR
DETR03	EQ	3	:KERNEL OUT OF PORTS. DETECTED IN CRQ.
DETR04	EQ	4	:KERNEL SIO INTERFACE DOWN. SET UP IN KCQDET.

	SUBTTL	DATA (CRYPTO messages)

::*********************************************************************
::
::	CRYPTO MESSAGES:
::	HO NIBBLE MAPS BY BIT TO HW'S CONTAINING SIGNIFICANT DATA
::	2ND NIBBLE SPECIFIES CRYPTO MESSAGE CLASS:
::		0 = GENERAL, ALWAYS DISPLAYS
::		1 = CRYDIS, CIRCUIT BUILT, ZAPPED MESSAGES
::		2 = ASYDIS, ASYNC MESSAGES
::		3 = REBDIS, REBUILD MESSAGES
::		4-0F = RESERVED
::	LO BYTE IS MESSAGE NUMBER
::
::*********************************************************************

CRYE00	EQ	7000	:CRASH. HW1=CRSHID, HW2&3=CRASH ADDRESS
			:CRASH ID : 0=> OOPS, 1=> POWER FAIL, 2=>OPERATOR
			:HALT, 4=> ILLEGAL INST, 8=> MAC ERROR
CRYE01	EQ	3001	:LINK UP - HW2=LINK#, HW3=NEIGHBOR#
CRYE02	EQ	3002	:LINK DOWN. HW3 = NEIGHBOR NUMBER
CRYE03	EQ	3003	:NO PERMUTER TABLE HALF PAGES AVAILABLE FOR NEW
			: LINK - HW2=LINK#, HW3=NEIGHBOR#
CRYE04	EQ	7004	:LINE DETACHED. HW1=REASON, HW2=LINE#, HW3=NEIGHBOR#.
			:REASON : 1 => NO REC RECEIVED, 2=> NO GOOD REC
			: RECEIVED, 3=> RESET RECEIVED, 4 => BORI ZAP
CRYE05	EQ	4005	:TAKEOVER. HW1 = SUPERVISOR NUMBER
CRYE06	EQ	0006	:SUPERVISOR STOP
CRYE07	EQ	4007	:SUPERVISOR CRQ LOST. HW1 = SUPERVISOR NUMBER
CRYE08	EQ	5008	:NEEDLE GOBBLED IN CRQ. HW1= 03XX PAIR HW3= NEIGHBOR#
CRYE09	EQ	5009	:ZAPPER ON UNASSIGNED CHANNEL FROM T-I NEIGHBOR -
			:HW1=CHANNEL#, HW3=NEIGHBOR#
CRYE0A	EQ	100A	:NO NEIGHBOR - HW3=NEIGHBOR#
CRYE0B	EQ	0C10B	:CRQ BUILT. HW0&1 = NEEDLE ENTRY PORT, EXIT PORT
CRYE0C	EQ	0C10C	:CRQ ZAP. HW0&1 = ZAPPER ENTRY PORT, EXIT PORT
			:THE PRECEEDING TWO MESSAGES MUST BE MANUALLY ENABLED
			:BY LETTING CRYDIS > 0
CRYE0D	EQ	400D	:TERMINATING NEEDLE SPECIFIES A DESTINATION HOST NOT
			:ON THIS NODE. CRQ IS ZAPPED.  HW1 = HOST NUMBER
CRYE0E	EQ	500E	:GOBBLER OR OTHER CHARACTER PAIR FOLLOWS NEEDLE.
			:HW1 = CHARACTER. HW3=NEIGHBOR#
CRYE0F	EQ	400F	:TIMEOUT ON CHANNEL PROCESSING NEEDLE.
			:HW1=ABS CHN#
CRYE10	EQ	0C010	:CHANNEL IN USE - HW?= CHANNEL NUMBER
CRYE11	EQ	7311	:REBUILD REQUEST.
CRYE12	EQ	7312	:CRQ REBUILD COMPLETE.
CRYE13	EQ	0C013	:REBUILD REJECT
CRYE14	EQ	4014	:REBUILD DATA LOST
CRYE15	EQ	5015	:CHANGE IN HOST STATUS - HW1=STATUS, HW3=HOST #
CRYE16	EQ	7016	:NEW LINE ATTACHED. HW1=NLAT,HW2= LINE #, HW3= NGHBR
CRYE17	EQ	0C017	:OUT OF COMMAND PORTS, HW0= , HW1= .
CRYE18	EQ	0C018	:EARLY ZAPPER FOLLOWS NEEDLE.CHAN, NEIGHBOR
CRYE19	EQ	1019	:OUT OF CHANNELS TO NEIGHBOR. HW3= NEIGHBOR #
CRYE1A	EQ	401A	:BAD NEEDLE POINT RECEIVED. HW1= 'NEEDLE POINT'
CRYE1B	EQ	001B	:OUT OF PORTS TO NODE KERNEL
CRYE1C	EQ	501C	:NO MORE PORTS TO ISIS DISPATCHER. HW1=NDP, HW3=HOST#
CRYE1D	EQ	0F01D	:SIO INTERRUPT REPORT - HW1=INTERRUPT,
			: HW2=CONDITION CODE, HW3=LINE#, HW4=NEGHBR#
			: INTERRUPT CODE - 1 =ASYNC INTERRUPT, 2 =CCW ERROR,
			: 6 =UNDERRUN, 8 =I/O COMMAND ERROR, FFFF =BAD REC SIZE
			: CONDITION CODE - 0 = MBOARD AVAILABLE, 4 =NON-
			: FUNCTIONING BOARD, 8 =MBOARD BUSY		###OAS
CRYE1E	EQ	301E	:TYMNET-I LINE WENT 4 SECONDS WITH NO GOOD RECORDS
			: RECEIVED - HW2=LINE#, HW3=NEIGHBOR NUMBER
CRYE1F	EQ	401F	:RTD DETECTED NON-GOBBLING ZAPPER - HW1= NEIGHBOR
CRYE20	EQ	7020	:LINE SUSPENDED DUE TO RESET ERROR - HW1=NO. SEC'S
			:HW2=LINE#, HW3=NEIGHBOR#
CRYE21	EQ	5021	:LINK SHRINK - HW1=NCHN,  HW3=NEIGHBOR NUMBER
CRYE22	EQ	5022	:LINK BUBBLE - HW1=NCHN,  HW3=NEIGHBOR#
CRYE23	EQ	0C023	:INVALID LOGGER ENTRY - HW0=BUFFER,HW1=ILLEGAL BF
CRYE24	EQ	4024	:SUP DATA ON UNASSIGNED CHANNEL - HW1=CHN#
CRYE25	EQ	4025	:SUP ZAP ON UNASSIGNED CHANNEL - HW1=CHN#
CRYE26	EQ	5026	:INVALID MACHINE NUMBER ON SUP COMMAND CIRCUIT - HW1=
			: ERRONEOUS NEIGHBOR NUMBER (WE COULD BE OUT OF SYNC
			: ON COMMAND CIRCUIT)
CRYE27	EQ	0C027	:INVALID COMMAND TYPE FROM SUP - HW1=BAD COMMAND
CRYE28	EQ	5028	:DATA ON UNASSIGNED CHANNEL FROM NEIGHBOR - HW1=
			: CHANNEL NUMBER, HW3= NEIGHBOR #
CRYE29	EQ	5029	:NEEDLE ON ASSIGNED CHANNEL - HW1=CHANNEL NUMBER
			: HW3= NEIGHBOR NUMBER
CRYE2A	EQ	0C02A	:RECEIVED 03 CHARACTER PAIR WHICH IS INVALID -
			: HW0=2ND CHAR, HW1=ABS CHN#
CRYE2B	EQ	402B	:INTERNAL HOST CHANNEL TIMEOUT. A CHANNEL
			:WITH TIMEOUT ENABLED HASNT RECEIVED DATA FOR 30 SEC
			:CRQ IS ZAPPED. R0 =  FUNCTION BYTE, ABSOLUTE CH #
			:SEE INTHST IN SWITCH FOR FUNCTION BYTE MEANINGS
CRYE2C	EQ	602C	:A NEW DOWNLINE LOAD CRQ HAS BEEN ESTABLISHED.
			:R0 = TARGET LINE #,  ABSOLUTE CH # TO HOST.
CRYE2D	EQ	602D	:DOWNLINE LOAD LINE CRQ ZAP.  R0=LINE NUMBER,REASON.
			:REASON : 0=> ZAPPER, 1=> LINE # TOO BIG, 2=> LINE
			:ATTACHED, 3 => LINE ALREADY IN USE FOR DWL
CRYE2E	EQ	002E	:OUT OF INTERNAL HOST LOAD PORTS
CRYE2F	EQ	0C02F	:ISIS HOST OUT OF PORTS
CRYE30	EQ	0C030	:SYNC SCAN ERROR.  R0 - LN*2, SEGB OFFSET
CRYE31	EQ	0031	:DETDGN CALLING ERROR - R0 MEANINGLESS
CRYE32	EQ	0C032	:SIO BUFFER COUNT ERROR. R0 - LN*2, COUNT
CRYE33	EQ	0C033	:M-BOARD TIMEOUT. R0 - LN, SVC INDEX.
			:INDEX : 2 = CONNECT SVC, 3 = INPUT SVC, 4 = OUTPUT
			: 5 = STATUS SVC
CRYE34	EQ	0C034	:CIRCUIT BUILDING ERRORS. HW0=LEP ERRS, HW1=CRQ ERRS
CRYE35	EQ	0C035	:CIRCUIT COUNTING INCONSISTENCY. R0 HAS NUMBER
			: OF OCCURRENCES, MAGNITUDE OF INCONSISTENCY.
CRYE36	EQ	5036	:LINK OVERLOADED - R0 HAS COUNT, HW3 HAS NGHBR	###OAS
CRYE37	EQ	5037	:LINK SATURATED - R0 HAS COUNT, HW3 HAS NGHBR	###OAS
CRYE38	EQ	1038	:LINK ERROR - ILC BUF ZERO. HW3=NGHBR
CRYE39	EQ	5039	:LINK SNIP DUE TO LINK ERROR. HW3 HAS NEIGHBOR NUMBER
CRYE3A	EQ	403A	:SIO CARD BUSY. R0 HAS COMMAND
CRYE3B	EQ	403B	:SIO CARD RING INTERRUPT. R0 HAS STATUS
CRYE3C	EQ	0C23C	:TID RECEIVED FROM ASYNC PORT. R0 = PORT#, TYPE
CRYE3D	EQ	0C23D	:NEEDLE EYE RECEIVED FOR ASYNC PORT. R0 = PORT#
CRYE3E	EQ	0C03E	:SERIOUS TYMSAT ERROR
CRYE3F	EQ	0C23F	:ASYNC PORT ANSWERED
CRYE40	EQ	0F040	:TOTAL PACKETS REC'D/SENT
CRYE41	EQ	7041	:BAD BORI
CRYE42	EQ	7042	:BAD ACK
CRYE43	EQ	7043	:BAD REC NO.
CRYE44	EQ	7044	:BAD CHECKSUM
CRYE45	EQ	7045	:RETRANSMISSIONS REC'D
CRYE46	EQ	7046	:RETRANSMISSIONS SENT
CRYE47	EQ	7047	:4 SEC GAPS
CRYE48	EQ	7048	:CROSS-TALK
CRYE49	EQ	7049	:SPACING ON INPUT
CRYE4A	EQ	704A	:HDLC CHECKSUM ERRORS
CRYE4B	EQ	704B	:HDLC ABORTS
CRYE4C	EQ	104C	:UNTAKER TO TYMNET-I NEIGHBOR
CRYE4D	EQ	704D	:LINK OUT ZAP COUNT. HW1=CNT, HW2=KN, HW3=NGHBR
CRYE4E	EQ	704E	:CMD CT ZAP COUNT. HW1=CNT, HW2=KN, HW3=NGHBR
CRYE4F	EQ	0C04F	:ASYNC RING WRAP. HW0=MAX, HW1=WRAP		###wjl
CRYE50	EQ	4050	:BAD INTERNAL HOST FUNCTION
CRYE51	EQ	1051	:LINK FROZEN. HW3=NEIGHBOR
CRYE52	EQ	1052	:LINK THAWED. HW3=NEIGHBOR
CRYE53	EQ	3053	:BAD SIO RECORD LENGTH - HW2=LN, HW3=NEIGHBOR#
CRYE54	EQ	0F054	:XRAY AUDIT. HW1=COMMAND, HW2,3,4=USERNAME
CRYE55	EQ	0C055	:TIMEOUT ON XMISSION OF SIO RECORD. HW0=FASTC, HW1=LN
CRYE56	EQ	4056	:SOFT RECOVERY FROM MAC ERROR. HW1=ADDRESS
CRYE57	EQ	4057	:DMA TIMEOUT CAUSED MAC INTERRUPT. HW1 = MAC STATUS
CRYE58	EQ	0C058	:SLOT REPORT LIMIT EXCEEDED
CRYE59	EQ	4059	:ASYNC DATA ON PORT WITH SBA OFF. HW1 = PORT NUMBER
CRYE5A	EQ	505A	:SLOT/HOST CIRCUIT LIMIT EXCEEDED - HW1=SLOT, HW3=HOST#
CRYE5B	EQ	505B	:INVALID HOST FOR RESTRICTED NODE
CRYE5C	EQ	505C	:INVALID 03-PAIR ON T-I CMD CIRCUIT
CRYE5D	EQ	505D	:T-I SUP RECORD WITH INVALID LENGTH
CRYE5E	EQ	405E	:INVALID 03-PAIR ON OUR COMMAND CIRCUIT
CRYE5F	EQ	505F	:CHANNEL IN USE - HW1=REL CHAN, HW3=NEIGHBOR
CRYE60	EQ	7060	:BUFFER ZAP - HW0=COUNT, HW1=CHAN, HW3=BUFFER
CRYE61	EQ	5061	:NEEDLE REJECTED BY SLOT - HW1= # PORTS, HW3=HOST
CRYE62	EQ	5062	:IMPOSTER HOST - HW1= SLOTS, HW3=HOST
CRYE63	EQ	0C063	:SQA ERROR - HW0=DIF, HW1=TERM CHAN
CRYE64	EQ	1064	:KERNEL PORT ZAP FAILED.
CRYE65	EQ	0F365	:RTDSQA - TERM PORT, NET PORT, SQA
CRYE66	EQ	0F366	:RECEIVED A SQACK
CRYE67	EQ	0F367	:CRQREB -  FIRST CHAR IN SEQ#, EXPECTED SEQN
CRYE68	EQ	3068	:NO P/T SPACE
CRYE69	EQ	3069	:NO L/D FOR NEW LINE
CRYE6A	EQ	736A	:GENERAL CIRCUIT STATUS - CHAN, HSEQN
CRYE6B	EQ	436B	:REBUILD DISABLED - CHAN
CRYE6C	EQ	406C	:EARLY REBUILD NEEDLE - CHAN			###CY
CRYE6D	EQ	0C06D	:INTERCEPT ABANDONED DUE TO STUB TIMEOUT	###CY
CRYE6E	EQ	0F36E	:CIRCUIT STATUS - VSEQN, XSEQN
CRYE6F	EQ	736F	:SQF SENT - CHAN, XSEQN
CRYE70	EQ	3070	:SIO ERROR MBOARD RC=4 HW2=LN#, HW3=NEIGHBOR	###OAS
CRYE71	EQ	0F071	:WILD-CARD MESSAGE
CRYE72	EQ	4072	:SIO PORT UNAVAILABLE HW1 = LN#			###OAS
CRYE73	EQ	4073	:BAD ZAP REASON FROM ISIS, HW1 = REASON		###GT
CRYE74	EQ	0C074	:TAKEOVER RESP #LNK NOT MATCH #NBR,HW0=#LNK,HW1=#NBR#AL
CRYE75	EQ	0C075	:NETID MISMATCH - HW0=LINE, HW1=NETID		###wjl
CRYE76	EQ	0C076	:WSIZ MATCH DOWN - HW0=LINE, HW1=WSIZ		###wjl
CRYE77	EQ	0C077	:XRAYS NETID MOD - HW0=LINE, HW1=NETID		###wjl
CRYE78	EQ	4078	:UNRECOGNIZED SIGNAL RECEIVED, HW1=CHN		###LSH
CRYE79	EQ	3079	:STARLINK REMOTE RESET RETRY FAILURE		###EV
CRYE7A	EQ	707A	:STAR REMOTE NBR# MISMATCH  KEY=HW1,HW2 NBR#=HW3###AL
CRYE7B	EQ	407B	:SIO INIT SOFTWARE TIMEOUT - HW1=LINE		###wjl
CRYE7C	EQ	407C	:NODE IN THE NETWK REVED BOOT CMD - NBR#=HW1	###AL
CRYE7D	EQ	707D	:STRRMT LINE WENT 8 SECONDS WITH NO GOOD RECORDS
			: RECEIVED - HW2=LINE#, HW3=NEIGHBOR NUMBER 	###AL
CRYE7E	EQ	407E	:I/O QUERY ERROR - HW1=TYPE
CRYE7F	EQ	707F	:BAD RETURN CODE - HW1=TRAP, HW2&3=RC

:	Tymtunnel stars here						###cwc
CRYE80	EQ	07080	:TymTunnel building in process - tnhost=hw2, neig=hw3
			:						###cwc
CRYE81	EQ	0F081	:TymTunnel building error - err=hw0, code=hw1,
			:tnhost=hw2, neig=hw3				###cwc
CRYE82	EQ	07082	:TymTunnel opened - type=hw1, tnhost=hw2, neig=hw3
			:						###cwc
CRYE83	EQ	07083	:TymTunnel operation error - err=hw0, tnhost=hw2,
			:neig=hw3					###cwc
CRYE84	EQ	07084	:TymTunnel closed - cause=hw0, type=hw1,tnhost=hw2,
			:neig=hw3					###cwc
:	Tymtunnel messages end here					###cwc
CRYE85	EQ	4085	:CONSISTENCY CHECK ERROR - HW1=RESIDENT		###wjl

::*********************************************************************
::
::	LINK SNIP REASONS FOR XRAY, NODE REPORTS
::
::*********************************************************************

LS.SCP	EQ	01	:SPLIT CHARACTER PAIR - 00 OR 01
LS.I3P	EQ	02	:INVALID 03 CHARACTER PAIR
LS.S3P	EQ	03	:SPLIT 03 CHARACTER PAIR
LS.BPC	EQ	04	:BAD CHANNEL NUMBER DETECTED IN BACKPRESSURE REC
LS.COR	EQ	05	:CHANNEL NUMBER OUT OF RANGE
LS.ILC	EQ	06	:ILC PERMUTER TABLE ENTRY ZERO FOR T-II NEIGHBOR
LS.BPV	EQ	07	:BPMV PERMUTER TABLE ENTRY 0 FOR T-I NEIGHBOR
LS.UCR	EQ	08	:UNRECOGNIZED CONTROL RECORD RECEIVED
LS.SNC	EQ	09	:SHRINK FROM NEIGHBOR, NO CHANNELS TO SHRINK
LS.MCE	EQ	0A	:MICROCODE CLOBBERED R12 (PRD)

LS.ARC	EQ	10	:ARRAYAND ERROR, BOTH BITS NOT SET
LS.ACR	EQ	11	:ARRAYAND ERROR, CHANNEL OUT OF RANGE
LS.ZPT	EQ	12	:ZERO PERMUTER TABLE ENTRY FOR ACTIVE CHANNEL
LS.BPZ	EQ	13	:BPSCNT ZERO
LS.EBF	EQ	14	:EMPTY BUFFER BUT BUFFER FLAG SET
LS.ZLR	EQ	15	:ATTEMPT TO BUILD ZERO-LENGTH RECORD
LS.MAC	EQ	16	:RECOVERY FROM MAC INTERRUPT IN RMAKE OR RTEAR
LS.OOB	EQ	17	:out of buffers					###wjl

	SUBTTL	DATA (Table structure variables)

:	CRASH TABLE STRUCTURES

Q	EQ	.		:HERE WE ARE

::*********************************************************************
::
::	CRASH SUMMARY TABLES:
::
::*********************************************************************

	ORG	0
CS.CNT	HS	1		:CRASH COUNT
CS.CID	HS	1		:CRASH ID
CS.PSD	HS	4		:CRASH PSD
CS.TIM	HS	2		:GMT OF CRASH
CS.SIZ	EQ	.		:SIZE OF SUMMARY ENTRY

::*********************************************************************
::
::	CRASH DETAIL TABLES:
::
::*********************************************************************

	ORG 	0
CD.CNT	HS	1		:CRASH COUNT
CD.CID	HS	1		:CRASH ID
CD.PSD	HS	4		:CRASH PSD
CD.TIM	HS	2		:CRASH TIME (GMT)
CD.RS0	HS	20		:R-SET 0 REGISTERS
CD.RSF	HS	20		:R-SET F REGISTERS
CD.MAC	HS	30		:MAC REGISTERS (LOC'S 300-35F)
CD.SLT	HS	1		:NOT USED (USED BY ISIS)
CD.SIZ	EQ	.		:SIZE OF DETAIL TABLE
CS.NEN	EQ	10		:NUMBER OF ENTRIES IN SUMMARY TABLE
CSMTBS	EQ	CS.SIZ*10	:SIZE OF SUMMARY TABLE AREA
CDTTBS	EQ	CD.SIZ*2

::*********************************************************************
::
::	CRYPTO MESAGE FORMAT:
::
::*********************************************************************

	ORG	0
CRYGMT	WS	1
CRYFAS	HS	1
CRYFLG	BS	1
CRYTYP	BS	1
CRYHW0	HS	1
CRYHW1	HS	1
CRYHW2	HS	1
CRYHW3	HS	1

::******************************************************************
::
::	SIO TRANSMIT BLOCK LAYOUT:	###JOK
::	(See also SIORIZ, where this layout is used)
::
::******************************************************************

	IF	SILINS
	ORG	0
SB.CMD	HS	1			: CCW Command field
SB.DQA	HS	1			: CCW Data Quad-word Address
SB.CD2	HS	1			: Second CCW Command field
	HS	1			: init'ed to Quad-word addr of next CCW
SB.OBA	HS	1			: Output Buffer Address (Absolute)
SB.QBA	HS	1			: Quad-word Output Buffer Address
	BND	10			: extra padding to fill out to Quad-wrd
SB.SIZ	WS	0			: how big the entry is
	EI	:SILINS

::*********************************************************************
::
::	SIO STATUS BLOCK LAYOUT TABLE:		###wjl
::	Index into SIOSTT, three halfwords for engine, four halfwords
::	for HDLC micro	(See LDRPRT and XSIOST for usuage)
::
::*********************************************************************

	IF	SILINS
	ORG	0
SS.REG	HS	1	:read REG 0 on the SIO chip	(bits 0 - 7)
			:read REG 1 on the SIO chip	(bits 8 -15)
SS.IDL	BS	1	:idle line counter		(bits 16-23)
SS.CRC	BS	1	:CRC error counter		(bits 24-31)
SS.ABR	HS	1	:HDLC abort counter		(bits 32-43)
			:				(bits 44-47)
SS.HM1	BS	1	:HDLC MICRO-engine receive overrun counter
SS.HM2	BS	1	:HDLC MICRO-engine (reserved)
	EI	:SILINS

::*********************************************************************
::
::	LINK DESCRIPTOR VARIABLES:
::
::*********************************************************************

	ORG	0
NDID	HS	1		:NODE NUMBER
KTYP	BS	1		:LINK TYPE (***HWB)
BORI	BS	1		:RECEIVED B-O-R INDICATOR
NLAT	BS	1		:# OF LINES ATTACHED
WSIZ	BS	1		:WINDOW SIZE
KSPD	BS	1		:LINK SPEED
LKNM	BS	1		:LINK NUMBER
NCHN	HS	1		:NUMBER OF CHANNELS
ISEC	HS	1		:PTR TO START OF INPUT RING
NRTR	HS	1		:PTR TO NEXT RECORD TO TEAR
AMSK	HS	1		: MASK FOR ACK TRUNCATION
OSEC	HS	1		:DITTO OUTPUT
NRMK	HS	1		:PTR TO NEXT RECORD TO MAKE
NRXM	HS	1		: PTR TO NEXT RECORD TO TRANSMIT
LRT	HS	1		: LAST RECORD TORN
LAS	HS	1		: LAST ACKNOWLEDGEMENT SENT
LRM	HS	1		:LAST RECORD MADE
LAR	HS	1		: LAST ACKNOWLEDGEMENT RECEIVED
NAS	HS	1		:NEXT ACKNOWLEDGEMENT TO BE SENT
ONDID	HS	1		:NODE NUMBER WHEN DOWN OR 0
IDLE	HS	1		: FLAG FOR IDLE OUTPUT
LNIDLE  hs      1               :<0 if link has a line sending stuff
PKTMSZ  EQ      1F
PKTTIM	HS	PKTMSZ+1	:FASTC TIME PACKET WAS MADE, INDEXED BY REC#
KS.PQC	HS	2		:RUNNING COUNT OF PACKET QUEUEING TIMES
:	ISIS-INDEPENDENT DESCRIPTORS BEGIN HERE
RKEY	HS	2		:RESET KEY RECEIVED FROM NEIGHBOR FOR
				: MULTI-LINE ATTACHMENT VERIFICATION
SHSTAT	BS	1		:SHRINK STATE, VALUES AS FOLLOWS:
:	0     NO SHRINK ACTIVITY IN PROGRESS
:	1     RTD DETECTED SHRINK COMMAND FROM NEIGHBOR
:	2     MSHRINK FOUND MANY SPARE CHANNELS THIS LINK
:	3     RMAKE FROZEN WAITING FOR NEIGHBOR TO COMPLETE SHRINK

NEDSUS	BS	1		:NON-ZERO IF LINK SHRINK SUSPENDED DUE TO
				: NEEDLES OUTSTANDING
:	!! SHSTAT AND NEDSUS MUST BE IN SAME HALFWORD !!
:	SOME CODE DOES A LH OF SHSTAT TO TEST BOTH SHSTAT AND NEDSUS

NEDOUT	HS	1		:# OF NEEDLES OUTSTANDING BETWEEN CRQ AND RMAKE

ANCHN	HS	1		:NUMBER OF ACTIVE CHANNELS

KFROZN	HS	1		:INDICATE LINK'S NETWORK STATUS - 0 FOR UP,
				:-1 FOR FROZEN,LINK UP BUT REPORTED OUT TO SUP
PRICNT	HS	1			:COUNTER FOR PRIORITY CHANNEL LOGIC
RMKFLG  HS      1               :complete round robin for this link in rmk?
SIOROT  BS      nlines          :list of lines on this link         ###dmj
SIOROR  BS      1               :pointer to line on the sio rotation    ###dmj
SIOBTT  ws      1               :time of last SIO retransmission        ###dmj

:	THE FOLLOWING FIELDS EXIST TO RECORD LOAD STATISTICS FOR EACH LINK

KS.PCO	HS	2		:RUNNING COUNT OF PACKET CHARACTERS OUTPUT
KS.PMO	HS	2		:LAST MINUTE, COUNT OF PACKET CHARACTERS OUTPUT
KS.PHO	HS	2		:HI-WATER MARK OF PACKET CHARACTERS OUTPUT

KS.PCI	HS	2		:RUNNING COUNT OF PACKET CHARACTERS INPUT
KS.PMI	HS	2		:LAST MINUTE'S COUNT OF PACKET CHARACTERS INPUT
KS.PHI	HS	2		:HI-WATER MARK OF PACKET CHARACTERS INPUT

KS.LCO	HS	2		:RUNNING COUNT OF LOGICAL CHARACTERS OUTPUT
KS.LMO	HS	2		:LAST MINUTE, COUNT OF LOG CHARACTERS OUTPUT
KS.LHO	HS	2		:HI-WATER MARK OF LOGICAL CHARACTERS OUTPUT

KS.LCI	HS	2		:RUNNING COUNT OF LOGICAL CHARACTERS INPUT
KS.LMI	HS	2		:LAST MINUTE, COUNT OF LOGICAL CHARACTERS INPUT
KS.LHI	HS	2		:HI-WATER MARK OF LOGICAL CHARACTERS INPUT

KS.NPC	HS	2		:RUNNING COUNT OF TIMES NO PACKET MADE IN RMAKE
KS.NPM	HS	2		:SAVE AREA FOR KS.NPC
KS.NPH	HS	2		:HIGH-WATER MARK FOR NO PACKETS MADE

KS.RRC	HS	1		:COUNT FOR NUMBER OF ROUND ROBINS
KS.RRT	HS	1		:AVERAGE TIME PER ROUND ROBIN IN FASTC

KS.OVL	HS	1		:LAST MINUTE'S LINK OVERLOAD COUNT
KS.SAT	HS	1		:LAST MINUTE'S LINK SATURATED COUNT

KS.BAK	HS	1		:RUNNING COUNT OF BACKLOGS
KS.BAM	HS	1		:SAVE AREA

KS.PKM	HS	1		:COUNT OF PACKETS MADE
KS.ASZ	HS	1		:AVERAGE PACKET SIZE

KS.LRM	HS	1		:RMK COUNT OF LOGICAL RECORDS PUT INTO PACKETS
KS.LRA	HS	1		:MTRFIC STORAGE FOR LOG REC/PACKET	###jhl

	IF	BFLTMR		:###JHL for buffer delay timer pairs
BDLACC	HS	1		:buffer delay accumulator
BDLCNT	HS	1		:buffer timer-pair counter
KS.BFD	HS	1		:last minute's acc'ed bfr delay
KS.BFC	HS	1		:last minute's count of bfr pairs
	EI	:BFLTMR		:###JHL

KS.SRC	HS	2		:CUMMULATIVE SUM, SYLVER-RTEAR DELAYS
KS.SRA	HS	1		:AVERAGE TIME BETWEEN SYLVER AND RTEAR

KS.AQU	HS	1		:AVERAGE QUEUEING DELAY, RMAKE TO SYLVEX

KS.XMT	HS	1		:AVERAGE PACKET TRANSMISSION TIME

KS.SEM	HS	1		:SEMAPHORE BETWEEN INTERRUPT-DRIVEN SYLVEX AND SIO
				:ROUTINES IN SYLVER. NEEDED ONLY ON SIO-SYNC LINKS
LRMSAV	HS	1		:SAVE AREA FOR LRM
LRTSAV	HS	1		:SAVE AREA FOR LRT

INTIME	HS	PKTMSZ+1	:SAME FOR TIME PACKET ARRIVED

KSSZ	EQ	.-KS.PCO	:SIZE OF STATISTICS AREA

	HS	0
KVERNO	HS	1		:NEIGHBOR VERSION NUMBER (-1 IF UNKNOWN)
KNETID	HS	1		:Neighbor's NETID
KHOST0	HS	2		:Neighbor's Kernel Host Number
KLINE	BS	1		:Neighbor Line Number
:       Following is to be able to restore the windowsize each time the
:       link goes down.  Allow a windowsize matchdown use the full window
:       as soon as the neighbor's window is expanded.                   ###sdw
       IF       WSZTST!TUNL     :testing or tunnel
ISECSV  HS      1               :Address of the break in ISEC chain
ISECS1  HS      1               :adrress of the broken piece in ISEC chain
OSECSV  HS      1               :Address of the break in the OSEC chain
OSECS1  HS      1               :Address of the broken piece in OSEC chain
       EI       :WSZTST!TUNL
KDPATC  HS      8               :give space for patches
	HS	0
KDSZ	EQ	.-NDID		:SIZE OF LINK DESCRIPTOR, NOT STRLNK


	IF	TUNL		:TYMTUNNEL PARAMETERS IN KD ###AL/EV/cwc
OHST	HS	1		:TUNNEL END HST# THIS NODE (AS ORIGINATION)
DHST	HS	1		:TUNNEL END HST# AT THE OTHER END (AS 
				: DESTINATION)
X25HST	HS	1		:X25 SLOT HST# FROM HOSTLINKS MACRO THIS NODE
TNSDST	BS	1		:TUNNEL IIX MSG SENDING STATES
:: The following are bit-displacements for transmit states, in one byte
:: Keep the order of the bits for polling in priority 			###AL
TNZA9F	EQ	 0		:TUNNEL SEND ISIS 9F TO X25
SNDSQM	EQ	 1		:SEND IIX SEQUENCE MESSAGE/MESSAGES
TKYLVM	EQ	 2		:SEND TURKEY LEVEL MESSAGE
SDLGIN	EQ	 3		:SEND LOGIN STRING
SDTRST	EQ	 4		:SEND TYMNET RESET PACKET IN IIX, BIT 
				: DISPLACEMENT
SDTDAT	EQ	 5		:SEND TYMNET DATA PACKET IN IIX, BIT

SNERCT	BS	1		:SENDING NEEDLE RETRY COUNT

	HS	0		:ANOTHER FLAG FROM A HALFWORD BOUNDARY
TNSTAT	HS	1		:TUNNEL STATUS FLAG
:: The following are the bit-definition for configuration or status
:: EQ value is the displacement from the leftmost
ORGDES	EQ	0		:ORIGINATION NODE (DEFAULTED 0), ELSE DESTINATN
SVCPVC	EQ	1		:SVC (DEFAULTED 0), ELSE PVC (BIT=1)
DEDBAK	EQ	2		:DEDICATED TUNNEL (DEFAULTED 0), ELSE BACKUP 
				: TUNNEL
TNLCPL	EQ	3		:TUNNEL CIRCUIT COMPLETE BOTH SIDE (KEEP 
				: SETTING UNLESS ERROR CONDITION)
TYLKUP	EQ	4		:TYMNET LINK UP WHEN BIT=1
TNBLDG	EQ	5		:bit set for tunnel building in progress
				:reset when TNLCPL is set
TNOTCT	EQ	6		:set when either 'OT' or 'CT' is issued
				:reset to 0 when either process completes
TNSIIX	EQ	7		:START IIX  FOR TUNL
BOZARS	EQ	8		:BORI-ZAP RESENDING RESET PACKET

TNCHN	HS	1		:TUNNEL RELATIVE DESPATCHER CHANNEL NUMBER

TNLNAM	WS	1		:POINTER TO TUNNEL LOGIN USERNAME
SVCCAD	WS	1		:POINTER TO TUNNEL SVC CALLED ADDRESS STRING
TISPTR	WS	1		:TUNL INPUT SECTOR POINTER FOR INCOMPLETE RCV
TNRSVB	WS	1		:POINTER TO RESET PACKET RECEIVE BUFFER
:: The following two timers must be in order in two halfwords 
TNLGTM	HS	1		:TUNNEL LOGIN TIMER
TNSDTM	HS	1		:TUNNEL SENDING NEEDLE TIMER

TNGMTM	WS	1		:TIME OF TUNNEL LINK ATTATCHED
PVCKN	HS	1		:PVC LINK NUMBER TARGET
PVCHN	HS	1		:PVC CHANNEL NUMBER TARGET
TNNM	BS	1		:tunnel number
WSIZSV	BS	1		:remember previous window size (WSIZ,KD) if
				:had been through MCHDWN routin
TIDCT	BS	1		:TUNL INPUT DATA REMAINING BYTE COUNT
	HS	0
TNMDBF	WS	1		:small buffer for xray MD comd handler to 
				:hold user input
TNKDSZ	EQ	.-NDID		:END SIZE OF TUNNEL KD
	EI	:TUNL

::**********************************************************************
::
::	 STARLINK CHAIN DESCRIPTOR LAYOUT  /  PER STARLINE
::
::**********************************************************************

	ORG	0

::*********************************************************************
::
::	MACROS:		LKD./LKD.2		(###JOK)
::	FUNCTION:	Load a link-descriptor pointer into register KD.
::	The global use of these macros centralizes the functionality,
::	and permits changes to data-structures [e.g. the KDKN pointer-array]
::	to be easily centralized in the macro-definition:
::
::	RS -	source register (containing link number)
::
::*********************************************************************

:	given actual link number:
LKD.	MACRO(RS)[ LHL	KD,KDKN,RS,RS ]

:	given twice actual link number:
LKD.2	MACRO(RS)[ LHL	KD,KDKN,RS, ]


::*********************************************************************
::
::	RESET BUFFER DESCRIPTOR:
::
::*********************************************************************

	ORG	0
VRSTP	HS	1		:Received Reset Pattern
VNDID	HS	2		:Received Node Number
VVERNO	HS	1		:Received Version Number
VNETID	HS	1		:Received Network ID
VSUBNT	HS	1		:Received Subnet Number
VWSIZ	BS	1		:Received Link Window Size
VLINE	BS	1		:Received Line Number
VHOST0	HS	2		:Received Kernel Host Number
VRSRSN	BS	1		:Received Reset Reason
VKSPD	BS	1		:Received Link Capabilities
VKATTR	HS	2		:Received Link Attributes
VDIAL	HS	2		:Received Dial-Up Number
	HS	0
VSDSZ	EQ	.-VRSTP		:Size of Received Reset Buffer

XRSTP	HS	1		:Transmitted Reset Pattern
XNDID	HS	2		:Transmitted Node Number
XVERNO	HS	1		:Transmitted Version Number
XNETID	HS	1		:Transmitted Network ID
XSUBNT	HS	1		:Transmitted Subnet Number
XWSIZ	BS	1		:Transmitted Link Window Size
XLINE	BS	1		:Transmitted Line Number
XHOST0	HS	2		:Transmitted Kernel Host Number
XRSRSN	BS	1		:Transmitted Reset Reason
XKSPD	BS	1		:Transmitted Link Capabilities
XKATTR	HS	2		:Transmitted Link Attributes
XDIAL	HS	2		:Transmitted Dial-Up Number
XCKSUM	HS	2		:Transmitted Checksum
	HS	0
XSDSZ	EQ	.-XRSTP		:Size of Transmitted Reset Buffer
XSDCNT	EQ	((XSDSZ-1)/8)^8	:Reset Length Count Code for header 
TXRSHD	EQ	TTRSHD!XSDCNT	:T-II Expanded Reset Header for new link
TYRSHD	EQ	TSRSHD!XSDCNT	:T-II Expanded Reset Header for subsequent line
TZRSHD	EQ	TRRSHD!XSDCNT	:SCLP reset header			###wjl

RSCNT	HS	1		:RESET COUNT
RSTIM	HS	1		:HOLDS TIMEOUT DURING RESET PROCEDURE
	HS	0
SDBSZ	EQ	.-VRSTP		:SIZE OF RESET DESCRIPTOR

::*********************************************************************
::
::	RECORD DESCRIPTOR:
::
::*********************************************************************

	ORG	0
RECN	HS	1		: RECORD NUMBER
RLNK	HS	1		: PTR TO NEXT RECORD IN BUFFER
EREC	WS	1		:: PTR TO END OF DATA (FOLLOWS RLINK)
BREC	WS	1		:: PTR TO BEGINNING OF DATA (VERT CHKSM)
LLXM	BS	1		: LINE LAST TRANSMITTED BY (DEV NUM)
	HS	0		:make sure CDSZ is not odd 		###cwc
CDSZ	EQ	.-RECN		:SIZE OF RECORD DESCRIPTORS


::*********************************************************************
::
::	DEFINE FORMAT OF XRAY GOODGUY LIST
::
::*********************************************************************

	ORG	0
XGGPRV	BS	1		:USER'S PRIVILEGE CAPABILITY
XGGOVR	BS	1		:USER'S OVERRIDE CAPABILITY
XGGTAR	HS	2		:user's TARGET dispatch address		###wjl
XGGNAM	HS	6		:USER NAME (UP TO 12 CHARS)
XGGSIZ	HS	0		:GOODGUY ENTRY SIZE

::*********************************************************************
::
::	DEFINE FORMAT OF XRAY USER BLOCK
::
::*********************************************************************

XBFSZE	EQ	10

	ORG	0
XUNAME	HS	1		:INDEX TO USER IN GOODGUY LIST	###OAS
XULGTM	WS	1		:LOG IN TIME
XUSLTN	HS	1		:XRAY USER SLOT NUMBER
XUINTH	HS	1		:XRAY USER INTERNAL HOST CHANNEL
XPOWER	HS	1		:XRAY USER POWER
CURCOM	HS	1		:SEG1 ADR OF COMMAND CURRENTLY EXECUTING
COMPWR	HS	1		:ORIGINAL POWER OF CURCOM
XRYBFO	HS	1		:OUTPUT BUFFER NO.
XRYPTF	HS	1		:FILL POINTER
XRYPTE	HS	1		:EMPTY POINTER
CRYMOD	HS	1		:AUTO CRYPTO DISPLAY MODE
EKOTYP	HS	1		:CHARACTER ECHO MODE
XRYADR	WS	1		:SCHEDUING ADDRESS
XHDSAV	WS	1		:LINK SAVE AREA
XRSAVE	WS	6
DPRSAV	WS	1
XREGSV	WS	10		:REGISTER SAVE AREA
ARGMAX	HS	1
ARGCT	HS	1
VALUE1	WS	10*4            :number of args allowed
CRYMSK	WS	8
CRYPPU	HS	1		:CRYPTO PRIO. BUF OUT PTR	###AL
CRYPTU	HS	1
XKNSAV	HS	1
:::
XKDSAV	WS	1
XPRTTP	WS	1
	GL XPRTTP
XRYBFI	BS	XBFSZE		:INPUT BRACELET
	HS	0
XNDSAV	HS	1		:NODE # SAVE AREA FOR ND COMMAND###SHM
XUBSZ	EQ	.-XUNAME	:SIZE OF XRAY USER BLOCK

::*********************************************************************
::
::	DELAY-TABLE LAYOUT:	###JK
::
::*********************************************************************

	ORG	0
DLSTAT	HS	1		:STATUS OF DELAY MEASUREMENT PROCESS
DLYFLG	HS	1		:PRIORITY SELECT FOR TEST CHANNEL
DLYFIL	HS	1		:NUMBER OF FILL HW PER TEST PACKET
DLYPTF	HS	1		:FILL POINTER TO DLYTBL
DLYAV1	HS	1		:RUNNING AVERAGE OF SAMPLES
DLYAV2	HS	1		:RUNNING AVERAGE OF AVERAGES.
NODLST	HS	10		:NODE LIST FOR THIS PATH		###wjl
NODCNT	HS	1		:2 X NUMBER OF ONE WAY NODES IN THIS TEST PATH
DLYTSL	EQ	5		:LOG OF TABLE SIZE
DLYTSZ	EQ	40		:2 * DLYTBL SIZE
DLYTBL	HS	DLYTSZ/2	:32h DATA VALUES
DLYBSZ	HS	0		:TOTAL DELAY MEASUREMENT AREA

	ORG	Q		:RESTORE PC


::************************************************************
::
::      X4TBBG  is a table containing info on all X.409 elements that
::              were parsed while the parser was looking for some element
::
::************************************************************


Q       EQ      .
        ORG     0
X4T.AP  BS      1               :application/constructor bits
X4T.ID  BS      1               :ID of this element
X4T.LN  HS      1               :length :this first three must be inthis order
X4T.DI  HS      1               :distance from start to ID
X4T.DD  HS      1               :distance from start to data field
X4T.BB  WS      1               :address within buf of start of element
X4T.LB  WS      1               :address within buf of len field
X4T.DB  WS      1               :address within buf of data field
X4T.EB  WS      1               :address within buf of end of element
X4TBSZ  HS      0               :table size (HW boundary)
        ORG     Q


::*****************************************************************
:
:       Define structure of create X.409 element table.
:
::*****************************************************************

       IF       LOGII
Q       EQ      .
        ORG     0
X4CDTA  WS      1               :a word for either address of data or data
X4CLEN  HS      1               :halfword for len of this element
X4CFLG  BS      1               :save info on data and if constructor
X4CHLN  BS      1               :sum of len of len and len of id
X4CID   HS      1               :the ID and application bits
X4CTSZ  HS      0               :size of table
        ORG     Q               :restore old PC
       EI       :LOGII


::*********************************************************************
::
::	LINE DESCRIPTOR:
::	FUNCTION:	This section defines the layout of a line-descriptor.
::	This is used with RX1 references relative to register "L.".
::	All symbol names are prefixed with "L." to indicate line-parameters.
::
::	  The descriptor contains three subsections:
::	A.	parameters common to both SYNC and SIO
::	B.	parameters unique to SYNC
::	C.	parameters unique to SIO
::	The latter two overlay each other!
::
::	(NOTE...">name" corresponds to old usage!)
::
::*********************************************************************

Q	EQ	.			: remember where we are now
	ORG	0
L.STAT	HS	1			: Status-bits:
					: 8000 - set if SIO-line, reset if SYNC
L.NEIG	HS	1			: (last) neighbor on line	>NGSVLN
L.KDSV	HS	1			: (last) link line attached to 	>KDSVLN
					:  0 -	never attached
					: <0 -	detached
L.DRSN	BS	1			: Detach reason:		>DREASN
					: 2 -	No records
					: 3 -	Reset received
L.LNO	BS	1			: duplicate copy of line-number
L.RSE	HS	1			: Reset Key for step E		>RESETE
L.RSF	HS	1			: Reset Key for step F		>RESETF
L.BRAT	HS	1			: Line speed			>BAUDRT
L.RTIM	HS	1			: for computing line speeds 	>LNRTIM
L.RPOS	HS	1			: Ditto.			>LNRPOS
L.SYLP	HS	1			: SYLVER state-variables - P-counters
					: 				>QSYLVR
L.TIME	HS	2			: Line time			>LINTIM
:	The following are for gathering statistics:
L.LDAR	HS	1			: bit-array for error-history 	>LDARLN
L.RCVD	HS	1			: good records received 	>RCRCVD
L.TRNS	HS	1			: records transmitted		>RCTRNS
L.RRF	HS	1			: -- Count at end of last min 	>KL.RRF
L.RSV	HS	1			: -- Count during last min 	>KL.RSV
L.ERR	HS	1			: detected errors		>LINERR
L.SPAC	HS	1			: Spacing (all 0's) detected 	>SPACNG
L.BACK	HS	1			: Bad acknowledgements		>BADACK
L.BRNO	HS	1			: Bad record numbers		>BADRCN
L.BCSM	HS	1			: Bad checksum			>BADCSM
L.RTR	HS	1			: retransmissions received 	>RCRXMT
L.RTC	HS	1			: retransmissions considered 	>LXMSET
L.LRF	HS	1			: -- Count at end of last min	>KL.LRF
L.LSV	HS	1			: -- Count during last min 	>KL.LSV
L.CROS	HS	1			: cross-talk errors		>LCROSS
L.RTS	HS	1			: retransmissions sent		>TRRXMT
L.TRF	HS	1			: -- Count at end of last min 	>KL.TRF
L.TSV	HS	1			: -- Count during last min 	>KL.TSV
L.SIZE	HS	0			: size of (basic) descriptor

:	The following are SYNC-unique parameters:
L.TAIL	HS	1			: trailing pointer		>SYNTOP
L.SHFT	HS	1			: left-shift counter storage 	>SYLSHF
L.BCNT	HS	1			: record byte count		>SYBCNT
L.HEDR	HS	2			: record header			>SYHEDR
L.CNSG	HS	1			: # 4-sec gaps with no records received
					: 				>CONFSG
L.FRSG	HS	1			: total # 4-sec gaps with no records
					: received			>FOURSG
L.SYSZ	HS	0			: (total) size of SYNC descriptor

:	The following are SIO-unique parameters:
	ORG	L.SIZE			: back up for overlay
L.SIBF	HS	1			: Index into SIBUF		>SIBUFN
L.SIST	HS	1			: SIO Output-state		>SIOTST
L.SICO	HS	1			: SIO current output-block addr >SIOCO
L.SINO	HS	1			: SIO next output-block address >SIONO
L.SISZ	HS	0			: (total) size of SIO descriptor

L.SIZE	HS	0			: maximum size of descriptor
	IF	L.SYSZ-L.SIZE
L.SIZE	EQ	L.SYSZ
	EI

	ORG	Q			: return to real address-space

::*********************************************************************
::
::	MACROS:		LL./LL.2
::	FUNCTION:	Load a line-descriptor pointer into a register.
::	The global use of these macros centralizes the functionality,
::	and permits changes to data-structures [e.g. the L.POINT pointer-array]
::	to be easily centralized in the macro-definition:
::
::	RD -	destination register
::	RS -	source register (containing line number)
::	OFF -	offset to line-number
::
::*********************************************************************

:	given actual line number:
LL.	MACRO(RD,OFF,RS)[ LHL	RD,L.POINT+(2*OFF),RS,RS ]

:	given twice actual line number:
LL.2	MACRO(RD,OFF,RS)[ LHL	RD,L.POINT+(2*OFF),RS, ]

	SUBTTL	DATA (Low Core SEG 0 variables)

:	Memory Layout Summary
:
:
:	SEGMENT	Usage			Remarks
:	   0	Node code Data		RX1 addressible (+ catch-all for junk)
:	   1	Node code Code		RX2 addressible (most of the time)
:	   2-0C	Data then bufferlets	No segmentation restrictions
:	  0D	XRAY execute & data	(execute only)
:	  0E	CTA Table		(ISIS)
:	  0F	SEGF			(ISIS)
:
:
:	THIS AREA RESERVED FOR DATA AREAS WHICH MUST BE ASSEMBLED
:	LOW IN SEG 0 FOR RX1 INDEXING.

::*********************************************************************
::
::	EXEC VARIABLES:
::
::*********************************************************************

	SEG.(0)				:DATA SEGMENT 0 BEGINS HERE
	ORG	0
SEG0	HS	0

:	***NOTE: FIRST 10x BYTES ARE UNUSED***

	ORG	10			:REQUIRED FOR MICROCODE TRACE INTERRUPT
TRPSW	WS      2       		:OLD PSW FOR TRACE ROUTINE
	WS	1			:POINTER TO TRACE ROUTINE

:	NODE DESCRIPTOR:

NODEID	HS	1			:NODE NUMBER
VERSID	HS	1			:VERSION NUMBER
CRHCNT	HS	1			:CRASH COUNT
CRSHID	HS	1			:CRASH ID #
	SYAD(CRSHID)
CRSHPS	WS	1			:CRASH PSW
CRSHAD	WS	1			:CRASH ADDRESS
	SYAD(CRSHAD)
CRSHTM	WS	1			:GMT OF LAST CRASH
ERRREG	WS	10			:CRASH REGISTERS
CRYPPI	HS	1			:Pointer into regular crypto buffer
CRYPRI	HS	1			:Pointer into priority crypto buffer

CRTYPE	HS	1			:CRASH TYPE (<0 =HRDWR, >=0 =SFTWR)##TZ

CRASHX	WS	1			:CRASH ADDRESS FOR XRAY 'ND' COMMAND

TRRIX	HS	1			:INDEX FOR TRRING,
	SYAD(TRRIX )			:CHARACTER TRACE BY CHANNEL

XFIRST	WS	1			:FIRST TIME (GMT) NODE WAS TAKEN OVER

ABRSAV	WS	10			:REGISTER SAVE AREA FOR SOFT MAC CRASH
	SYAD(ABRSAV)
REBNEB	HS	1			:TEMPORARY,DELETE WHEN REBILD TEST OVER
CSMCNT	HC	0			:# OF SUMMARY TABLE ENTRIES MADE###GT
CDTPTR	HS	1			:OFFSET TO NEXT DETAIL TABLE ENTRY
CDTCNT	HS	1			:COUNT OF CRASH DETAIL ENTRIES

ERREG0	WS	10			:CRASH SAVE AREA FOR REG SET 0
	IF	DB.DEB
CRHSAV	HS	2
	EI	:DB.DEB
NXTCRP	HS	1			:OFFSET INTO CRASH SUMMARY TABLE FOR
					:NEXT CRASH TO REPORT TO SUPERVISOR

	IF	T2GATE
::	Gateway to Dispatcher port Zero Message templates
GAVPTS	HC	NDP		:gateway available ports,init by NDP##al
MG148F	BC	0		:TO HNET SUP MSG 148F SENT FLAG##AL
G0DFG	BC	0		:NO SUP 0D MSG FLAG
: Type 03,0A,0C,10 messages
GDZ03M	HC	00	:5 bytes message report to port 0 (msg 03)
	BC	03,00
	AC	/GW/	:DATA2 fld put an identifier, may change later
DZ03NR	HC	00	:Node Report parameter (msg subtype & DATA1)
DZ03LK	BC	8B	:product ID for T2G2
GDZ03L	EQ	.-GDZ03M	:msg length

GDZ0AM	HC	00	:8 sec. check for port sts chang (msg 0A)
	BC	0A,00	:Message type and key
DZ0AHN	HC	IHOST	:host number
	GL	IHOST
DZ0APT	HC	00	:ports available 
DZ0ARH	HC	00	:relative host number
GDZ0AL	EQ	.-GDZ0AM	:msg length

GDZ0CM	HC	00	:hst cost configuratn (msg 0C)
	BC	0C,00	:Message type and key
DZ0CHN	HC	IHOST	:host number
DZ0CCT	HC	INCOST	:tymfile defines isis netwk cost
DZ0CRH	HC	00	:relative host number
GDZ0CL	EQ	.-GDZ0CM

GDZ10M	HC	00	:report hst sts (msg 10)
	BC	10,00	:Message type and key
DZ10HN	HC	IHOST	:host number
DZ10PT	HC	00	:ports available 
DZ10RH	HC	00	:relative host number
DZ10ST	BC	0	:host status
GKEY	BC	0	:host key
GHIQ	BC	80	:host IQ,I bit set
GPID	BC	8B	:product ID code
GDZ10L	EQ	.-GDZ10M	:Length of mesage in Bytes

::Other control message tables for Gateway dispatcher
GDB7M	HS	0
GB7PRT	HC	00	:INsert Dispatchr port number
	BC	0B7,00	:Type B7 message
GB7INV	BC	0E0,00	:Addendum to accounting 
	BC	00	:use for invoice exchange or ....
GB7REA	BC	00	:Insert reason for disconnect
GDB7L	EQ	.-GDB7M	:Length of message

GD9FM	HS	0
	HC	00
	BC	9F	:Zapper
GD9FL	EQ	.-GD9FM

GDM07M	HC	00		:Port zero message
	BC	07		:Type 07 (Pseudo Needle Request)
GSLKEY	BC	00		:Key  (slot# * 4)
GLOKEY	HC	00		:Local Key (for Gateway is buffer #)
GIXELF	HC	00		:IIX and ELS field
	HC	IHOST		:always IHOST is circuit origin to INET
GHINID	BC	00		:TID (CCT) from HNET to INET
GDM07L	EQ	.-GDM07M	:Message length

::	IRC (International Record Carrier) report for T2GATE	###AL
Q	EQ	0
	RE	NLINKS		:LINK NUMBERS ASSIGNED
	IF	\IRC|Q|
IRC	EQ	1		:IRC VALUE DEFINED
	ELSE	:IRC|Q| NOT DEFINED
IRC|Q|	EQ	0
	GL	IRC|Q|
	EI	:IRC|Q|
Q	EQ	Q+1
	ER

	IF	IRC
IRCTBL	HS	0
Q	EQ	0
	RE	NLINKS		:LINK NUMBERS ASSIGNED
	BC	IRC|Q|
Q	EQ	Q+1
	ER
	EI	:IRC
	EI	:T2GATE		:not to Bbe zeroed during init
::*********************************************************************
::
:: 	TYMTUNNEL IIX message templates for variable contents		###AL
::
::*********************************************************************
	IF	TUNL
SVCCA1	HC	000A		:START WITH HALFWORD BOUNDARY
SVCCAA	EQ	SVCCA1+1	:MESSAGE LENGTH FOR CALLED ADDRESS
	HC	CALDAD		:TYPE
	BS	1		:NUMBLE OF NIBBLES FOLLOWING
	BS	7		:CALLED STRING IS STORED IN HALFWORD BOUNDARY
				: WHEN IT'S SENT
CALNG1	HC	000A		:START WITH HALFWORD BOUNDARY
CALNGA	EQ	CALNG1+1	:MESSAGE LENGTH FOR CALLING ADDRESS
	HC	CALGAD		:TYPE
	BC	0A		:NUMBER OF NIBBLES FOLLOWING
	BS	5		:CALLING DNIC AND OHST ARE STORED WHEN SENT
	BC	00,00		:DUMMY BYTES
FACIL1	HC	0006		:MESSAGE LENGTH FOR FACILITY
FACILA	EQ	FACIL1+1
	HC	FACILI		:TYPE
	HC	0302		:TWO LENGTH FIELDS
	BC	02		:CODE FOR THROUPUT CLASS
	BS	1		:THROUPUT CLASS IS STORED WHEN SENT
PVCRQ1	HC	000C		:START WITH HALFWORD BOUNDARY, LO BYTE IS
PVCRQA	EQ	PVCRQ1+1	: THE LENGTH OF PVC REQUEST
	HC	PVCREQ		:TYPE
	HC	0008		:NUMBER OF BYTES FOLLOWING
	HS	4		:X25HST#, PVCHN AND PVCKN ARE STORED WHEN SENT

::									###cwc
::	allocate a short buffer for each tunnel KD for used in xray MD handler		::
TMDBSZ	EQ	20
TMDBF0	BS	NMTNLS*TMDBSZ

	EI	:TUNL
RSEG0	HS	0			:**SEGMENT 0 WRITTEN OUT TO HERE**

:*******FROM HERE TO CLSEG0 (BELOW) FOR CRASH TABLE STUFF ONLY*******

:	COMMON CRASH TABLE AREAS

:	COMMON CRASH TABLE HEADER

CRSHDR	WS	0		:LOADII crash dump option expects FW bndry##wjl
NODENU	HS	1		:NODE NUMBER
NODETY	HS	1		:MACHINE TYPE
TABVER	HS	1		:COMMON CRASH TABLE VERSION
CODVER	HS	1		:CODE VERSION
TAKETI	HS	2		:GMT OF FIRST TAKEOVER
CRCNT	HS	1		:CURRENT CRASH COUNT

CSMTBL	BS	CSMTBS		:CRASH SUMMARY TABLE AREA (16d OF THEM)
CDTTBL	BS	CDTTBS		:CRASH DETAIL TABLE AREA (2 OF THEM)
:*******FROM RSEG0 (ABOVE) TO HERE FOR CRASH TABLE STUFF ONLY*******

CLSEG0	HS	0		:SEG0 CLEARED FROM HERE

SQNSAV	HS	1		:SEQUENCE NUMBER SAVE AREA
BUFSAV	HS	1		:BUFFER INDEX SAVE AREA
      IF REBTST
R1RBFT  WS      1               :return bufferlets routine
R0RBFT  WS      1               :return bufferlets routine
R4RBFT  WS      1               :return bufferlets routine
     EI
PROCID	HS	1		:CURRENT PROCESS NUMBER
::
ALINES	BS	LNSIZE		:ACTIVE LINES
ALINKS	BS	LKSIZE		:ACTIVE LINKS
NALNKA	WS	1		:STORAGE FOR BE ADDR. FOR NALINK FLD.	###AL
TEMPHS	HS	1		:TEMPORARY STORAGE FOR A HW		###AL
MXLINK	HS	1		:MAXIMUM NUMBER OF ACTIVE LINKS
NALINK	HS	1		:# OF ACTIVE LINKS
MXPASS	HS	1		:MAXIMUM NUMBER OF PASSTHRU CIRCUITS
PASTHR	HS	1		:# OF PASSTHRU CIRCUITS
nbrcmd  hs      1               :# of passthru that are cmd circuits
PTHRPD	HS	1		:# of passthrus reported as available	###wjl
TERMIN	HS	1		:# OF CIRCUIT TERMINATIONS
MXPORT	HS	1		:PEAK ACTIVE KERNEL OR ISIS PORTS
CREPRT	HS	1		:CRASH REPORT INDICATOR, -1 IF REPORT SENT
CONSOL	WS	2		:CURRENT CONSOLE OUTPUT

:	OTHER VARIABLES:

:	SCHEDULER CLOCKS AND QUEUE:

SQUEUE	WS	1		:PROCESS QUEUE

SCHTAB	WS	0		:SCHEDULER TABLE

T08MIN	WS	1		:SCHEDULE TABLE LABELS
T04MIN	WS	1
T02MIN	WS	1
T01MIN	WS	1

T30SEC	WS	1
T16SEC	WS	1
T08SEC	WS	1
T04SEC	WS	1

T02SEC	WS	1
T01SEC	WS	1
T500MS	WS	1
T250MS	WS	1

T125MS	WS	1
T064MS	WS	1
T032MS	WS	1
T016MS	WS	1

QEXEC	WS	20		:PROCESS P-COUNTERS
SQLAST	WS	1		:FOR SAVING LAST RUN QUEUE

PROTIM	WS	20		:FASTC TIME THAT PROCESS LAST RAN
PROHWM	WS	20		:HIGH-WATER MARK FOR EACH PROCESS'S EXECUTION
				: TIME (IN FASTC UNITS)
PROCNT	WS	20		:COUNT OF PROCESS EXECUTION OCCURRENCES
PACTIM	WS	20		:ACCUMULATOR FOR TIME SPENT IN A PROCESS
PSVTIM	HS	20		:SAVE AREA FOR PACTIM, SAVED IN 1-MIN LOGIC

EXLAVG	HS	1		:AVG EXEC LOOP ITERATIONS/SEC OVER LAST MINUTE
EXLALW	HS	1		:LOW-WATER AVG EXEC LOOPS/SECOND
EXLAHW	HS	1		:HIGH-WATER AVG EXEC LOOPS/SECOND
EXDHWM	HS	1		:DISMISS HIGH-WATER MARK (FASTC UNITS)
EXEHWM	HS	1		:EXEC LOOP HIGH-WATER MARK (FASTC UNITS)
SYLHWM	HS	1		:SYLVER INTERVAL HIGH-WATER MARK (FASTC UNITS)
NEDHWM	HS	1		:NEEDLE TRANSIT TIME HI-WATER MARK(FASTC UNITS)
	SYAD(NEDHWM)
NEDCNT	HS	1		:NUMBER OF NEEDLES THROUGH NODE
RMKRMS	HS	2		:NUMBER OF RMK CALLS LAST MINUTE AND
RMKNRS	HS	2		: NUMBER OF TIMES NO RECORD MADE
rmklrs	HS	2		: number of logical records made
rtdlrr	HS	2		: number of logical records torn (running)
rtdlrs	HS	2		: number of logical records torn (last min)
rtdpkr	HS	2		: number of packets torn (running)
rtdpks	HS	2		: number of packets torn (last min)

EXTIME	HS	2		:TIME OF ENTRY/EXIT FOR EXEC LOOP
EXLCNT	HS	2		:EXEC LOOP COUNT (RESET EACH MINUTE)
EXLTLA	HS	2		:SLOWC TIME OF LAST AVERAGE COMPUTATION
RMKRMW	HS	2		:WORKING FIELDS FOR RMK CALLS AND
RMKNRW	HS	2		: TIMES NO RECORD MADE
DISSAV	HS	2		:SAVE RETURN FOR FAST DISMISS

DUESCH	WS	1		:SEE EXEC
syvsch	WS	1		:when syvler is to run again
EISECC	HS	1		:INC'D EVERY 1/8 SEC IF ISIS
      IF        EFFEXC          :                                       ###sdw
GOVSWI  HS      1               :limit switch to 40 times a second
      EI        :EFFEXC
TEMPER	EQ	0F0010		:ISIS-SUPPLIED TEMPERATURE
VOLTS	EQ	0F0011		:AND VOLTAGE
      IF	1-NAD68		:not in 68K environment			###wjl
	SYAD(TEMPER)		:ADD TO XRAY SYMBOL TABLE FOR
      EI	:NAD68		:  EASY REMOTE INSPECTION	###JHL	###wjl

CRYSAV	WS	10		:REG SAVE FOR CRYPTO
CRYSBF	WS	2		:CRYPTO MESSAGE BUFFER

HISTI	HS	1		:HISTORY BUFFER PTR

XLCRSH	WS	1		:TIME OF LAST CRASH FOR XRAY
CLKSAV	WS	1		:SAVE LOC FOR CLOCK TESTS
BIDDSV	WS	1		:SAVE LOC FOR BIDDY ADDRESS

      IF	1-NAD68		:not used in 68K environment		###wjl
DLDFLG	HS	1		:SET TO -1 IN LEP, CHECKED IN 4-SEC LOGIC
      EI	:NAD68

MTRTIM	WS	1		:TIME TO RUN NEXT 60 SECOND PERFORMANCE LOGIC
LDRTIM	HS	1		:SCHED LDRPRT EVERY 4 MTRFIC'S		###JHL
MININT	HS	1		:EXACT INTERVAL BETWEEN 1-MIN LOGIC EXECUTIONS
MINSAV	HS	1		:SAVE AREA USED IN COMPUTING MININT
S1SLOC	WS	1		:COUNTS OCCURRENCES OF 1-SECOND LOGIC.
				: DIFFERENCE BETWEEN 'S1SLOC' AND 'SLOWC'
				: INDICATES DRIFT IN 'G01SE1' SCHEDULING.

RTDGOV  HS      1                 :LIMIT RTD CALLS FROM SIO INPUT
rtdgvt  hs      2               :time to start governing
BFLTMX	WS	1		:14*(MAX NUMBER OF BUFFERLETS IN USE)
BFLTSV	WS	1		:RUNNING COUNT CELL FOR DETERMINING BFLTMX

	IF	REBILD
HBFTMX	WS	1		:14*(MAX NUMBER OF BUFFERLETS IN USE) HISTORY
HBFTSV	WS	1		:RUNNING COUNT CELL FOR DETERMINING HBFTMX
	EI 	:REBILD

::**********************************************************************
::
::	STARLINE LINK CHAIN DESCRIPTOR
::
::**********************************************************************

::*********************************************************************
::
::	LINKER VARIABLES:
::
::*********************************************************************

KDLN	WS	NLINES		:LINK DESCRIPTOR POINTERS
	SYAD(KDLN  )
                                :Moved SDSC, DWOBUF, DWIBUF out of low core
                                :                                       ###sdw
::
INHRST	BS	LNSIZE		:INHIBIT RESETS ON THESE LINES
INHRLS	BS	LNSIZE		:PREVIOUS STATE OF INHRST
LINATT	BS	LNSIZE		:LINES TO BE ATTACHED
LINDET	BS	LNSIZE		:LINES TO BE DETACHED
LINKAS	BS	LNSIZE		:TEMP STORAGE FOR LINKER
VRSTDL	BS	LNSIZE		:RESET DETECTED ON DETACHED LINES
:       please note that bori zap is now 0 to zap               ###sdw
BORZAP	BS	LKSIZE		:0 TO CAUSE 'BORI ZAP'
LNSUSC	BS	LNSIZE		:CURRENT COPY OF LINES SUSPENDED
LNSUSO	BS	LNSIZE		:OLD (1-MINUTE) COPY OF LINES SUSPENDED
OSRLIR  BS      LNSIZE          :idle lines sending old style resets    ###sdw
OSRLIH  BS      LNSIZE          :history of OSRLIR (only send OSR for a second)

SIORPC  BS      LNSIZE          :Bits set in 1 sec logic to let SIORR send it
LINSPT	WS	1		:LINKER FLAGS LINES NEEDING LINE SPEED CALC
	SYAD(LINSPT)
LINSPD	WS	1		:1-SEC LOGIC FLAG LINES NEEDING LINE SPEED CALC

LNCHLR	WS	1		:LNCHCK LINK REG
IZLNLR	WS	1		:IZLNKR LINK REG
FREELR	WS	1		:HEAD OF FREE RECORD-BUFFER CHAIN

LNGREC	BS	LNSIZE		:GOOD RECORD RECEIVED ON LINE
LKGREC	BS	LKSIZE		:DITTO ON LINK
OLDKGR	BS	LKSIZE		:LAST 4 SECOND'S LKGREC
      IF	SCLP
SCLPLK	BS	LKSIZE		:bit set = SCLP link for LNCHCK		###wjl
SCLPSV	WS	1		:save area for working copy of SCLPLK	###wjl
      EI	:SCLP

SIOBTR  BS      LKSIZE          :last packet sent was retransmission    ###dmj

BGLSIZ  EQ      10
BGLIST	HS	BGLSIZ		:BAD GUY LIST (DO NOT TALK TO THEM)
MRESTZ	EQ	NLINKS/2+1
MRESET	HS	MRESTZ		:LIST OF LINES IN RESET STATE FOR WHICH
				: WE ARE MASTER
RSRSHD	HS	1		:for reset header setup for call to RSTORE#wjl
ATTSAV	HS	1		:register save area for ATTLIN		###wjl
OSRLSV  WS      1               :save link register for OSRLIN          ###sdw
OSRTMP  HS      1               :temp within OSRLIN

:	STORAGE SPACE FOR BUILDING RESET AND
:	NULL RECORDS DURING SYNC LINE INPUT.

SYSTOR	WS	2*((XSDSZ+7)/8)	:Must be multiple of 8 bytes
SYSTSZ	EQ	(.-SYSTOR)/2	:Size of Sync Storage in HW

::*********************************************************************
::
::	LINE DESCRIPTOR PARAMETERS:
::	NOTE:  ">name" corresponds to proposed new usage
::
::*********************************************************************

QSYLVR	HS	NLINES		:SYLVER STATE VARIABLES - P COUNTERS	>L.SYLP
      IF	SCLP
SKYCHN	HS	NLINES		:INTHST CHN storage for SCLP link estab	###wjl
      EI	:SCLP

:	The following are for gathering statistics
LDARLN	WS	(NLINES+1)/2	:1 HW BIT ARRAY FOR EACH LINE KEEPS	>L.LDAR
				: TRACK OF ERRATE FOR ND DISPLAY
RCRCVD	HS	NLINES		:GOOD RECORDS RECEIVED			>L.RCVD
RCTRNS	HS	NLINES		:NUMBER RECORDS TRANSMITTED		>L.TRNS

:	The following are sync-unique parameters
SVNTOP	HS	NLINES		:DATA BUFFER OUTPUT POINTER		>L.TAIL
SYLSHF	HS	NLINES		:LEFT SHIFT COUNT STORAGE		>L.SHFT
SYBCNT	HS	NLINES		:RECORD BYTE COUNT			>L.BCNT
SYHEDR	WS	NLINES		:RECORD HEADER				>L.HEDR

	IF	SILINS
:	The following are SIO-unique parameters
SIOPSZ	EQ	$A 128			: SIO packet size
SIOFSZ	EQ	SIOPSZ+2		: SIO Frame size (allow for size HW)
SOBFSZ	EQ	(SIOFSZ+0E)&0FFFF0	: SIO Output Buffer Size
SIBFSZ	EQ	(8*SIOFSZ)		: SIO Input Buffer size

:: SIBFSZ ADJUSTED IN RUNNING TIME IF IT IS STAR LIN BY SIBFSZ+20 ##AL

:	The following are SIO-unique storage
Q       EQ      (NLINES-SILINS)*2      	: 2*first line #
SIBUFN	EQ	.-Q			: INDEX INTO SIBUF		>L.SIBF
	SYAD(SIBUFN)
	HS	SILINS
       EI       :SILINS

SIOTST	HS	NLINES			: SIO OUTPUT STATE		>L.SIST

:       fix initialization to not loop for while waiting to complete
:       initialization.                                                 ###sdw

SIOTSV  HS      NLINES                  :saved state while waiting      ###SDW
SIOTIM  HS      NLINES*2

SIOFB   HS      NLINES                  :next free output area
SIOTB   EQ      SIOFB+1                 :interleaved byte arrray with SIOFB
        SYAD(SIOFB )
	IF	NGRDTM
LCRPCT	BS	NLINES			:LINE CHECK REPORT COUNT FOR NON-4SEC
	EI				: REPORTING			###AL
	HS	0
linsvd  hs      lnsize
ccwdsv  ws      1               :link save
rmlnsv  hs      1                       :sve line # during rmake
SDUMM	WS	2		: DUMMY RECORD ARRAY
SSENT	WS	2			: RECORD SENT ARRAY
SIONOG  HS      LNSIZE                  :no go on this line
SIOROL  HS      1                       : whether rotating multiline link###dmj
SIOROS  HS      1                       : first line in this pass of rotat##dmj
SIOBRS	HS	1			: BAD RECORD SIZE COUNTER
SIOREG  HS      20                      :place to save all registers    ###dmj
srtdsv  hs      20              :save regs
srtdsp  hs      2               :for SIORTD (rtd from sio buffer)
SIOBCS	HS	1			: BAD COMPUTED CHECKSUM COUNTER
	SYAD(SIOBCS)
SIOMIS	HS	1			: RECORD SIZE MISMATCH
SIONEW	EQ	.-SBASE			: BIT ARRAY IS 1 IF VERSION E MICROCODE
	SYAD(SIONEW)
	HS	1+SILINS/8		: BIT ARRAY IS ADDRESSED BY 2*LN
SIOIZL	HS	2			: SAVE AREA FOR RETURN LINK IN SIOIZ
SIOECT	HS	1			: NUMBER OF TIMES BUFFER COUNT INVALID
SIOPTA	WS	(NLINES+1F)/20		: SIO PORT AVAILABLE BIT ARRAY	###OAS
					: 0 = PORT AVAIL., USED FOR PORT SWITCH
:	HDLC micro SIO init software 'timeout' crpyto ignore flag	###wjl
	IF	HMICRO		:HDLC micro only			###wjl
SIOIGN	BS	LNSIZE		:bit array to ignore crypto 7B		###wjl
	EI	:HMICRO		:					###wjl


       IF       SPAM
SPMINI  HC      0               :used to indicate SPAM sync done        ###dmj
SPSYNC  WC      0               :used to synchronize spam               ###dmj
       EI       :SPAM
SYLTIM	WS	1		:FASTC TIME TO CHECK FOR SYNC RING OVERRUN
SYLINT	HS	1		:FASTC INTERVAL FOR LINE SPEED CALC'S
LNKRET	HS	2		:RETURN LINK FOR LKVOLT
SYLXEC	HS	1		:COUNT OF NUMBER OF SYLVER EXECUTIONS
SYLXAV	HS	1		:AVERAGE INTERVAL BETWEEN SYLVER EXECUTIONS

ISECAD	WS	1		:I SEC ADDR. STORED##AL
FCSGOT	WS	1		:SOFTWARE SYNC FCS CKSM,HO HW IS DATA
				:FCS, LO HW IS 3 BYTE HEADER FCS##AL

:	TRACE-SYNC WORK AREAS:
	IF	TSTSZE
TSLINK	HS	1		:LINK OF INTEREST (TRACING ENABLED BY
	SYAD(TSLINK)		: PATCHING NEIGHBOR NUMBER IN THIS CELL
				: TSLINK ZEROED WHEN LINK GOES OUT.)
TSLINE	HS	1		:LINE OF INTEREST - SAME CONVENTION AS TSLINK
	SYAD(TSLINE,1)
TSRSVE	HS	4		:REGISTER SAVE - FOREGROUND
TSBSVE	HS	2		:REGISTER SAVE - BACKGROUND
TSFPTR	HS	1		:CURRENT ENTRY PNTR FOR FOREGROUND TRACE TBL
	SYAD(TSFPTR)
TSFTBL	BS	TSTSZE		:FOREGROUND EVENT TRACE TABLE
TSBPTR	HS	1		:CURRENT ENTRY POINTER FOR BACKGROUND TRACE TBL
TSBTBL	BS	TSTSZE		:BACKGROUND EVENT TRACE TABLE
	SYAD(TSBTBL)
	EI 	:TSTSZE

:	STORAGE AREA FOR SIO TIMEOUT CODE
SBZSAV	WS	10		:SAVE AREA FOR REGISTERS

LDRGSV	HS	2		:SAVE LINK REGISTER
TIK4MN	HS	2		:4-MINUTE TICKER (# OCCURRENCES OF LDRPRT)
LDTARY	HS	(NLINES+0F)/10	:SET BIT FOR LINE WHICH MADE DIAGNOSTIC REPORT

	IF	SILINS
SIOHCK	HS	SILINS		:SAVE CUMULATIVE # OF SIO HDLC CKSM ERRORS
SIOHAB	HS	SILINS		:SAVE CUMULATIVE # OF SIO HDLC ABORTS

MSBASE	EQ	(SILINS-NLINES)*2
	EI	:SILINS

	DEFAULT(SCHFAS,0)
	IF	SCHFAS
	IF	SCHFAS-SILINS
	REMARK %FATAL ERROR--ASSEMBLY KILLED
	QUIT
	EI	:SCHFAS-SILINS
SCHCNT	HS	1
	EI	:SCHFAS

::*********************************************************************
::
::	YAKYAK VARIABLES:
::
::*********************************************************************
::
LKTEAR	BS	LKSIZE		:LINKS BEING PROCESSED BY RTEAR
LKMAKE	BS	LKSIZE		:DITTO RMAKE
LKSRVD	BS	LKSIZE		:LINKS BEING SERVICED BY RTD/RMK
       IF       EFFEXC          :make sure all links gets serviced equally
DIDALL  HS      1               :by servicing a packet for each link before
DIXLFT  HS      1               :for handling multiple messages for one port in
dsi.r2  HS      1               :have to save r2
ds.chn  HS      1               :for quickly finding ports to service in DSINXT
                                :one pass through DISIN
       EI       :EFFEXC         :seeing if have to return to spider (check
                                :second packetif time exists            ###sdw

NEWLNR	WS	1		:SAVE RETURN FOR NEWLNK/TRLINK
BPMPRC	WS	1		:TEMP STORAGE FOR BPMV
LKRR	BS	LKSIZE		:CLEARED WHEN LINK COMPLETES ROUND ROBIN
	DEFAULT(RTRMAX,7F)	: max. no. of chars RTEAR will do for one line
RTRCNT	HS	1		: where we keep track of the above

RMTSR1	HS	1		:TEMP STORAGE
RMTSR2	HS	1
RMTSR3	HS	1
RMTSR4	HS	1
RMRFLG	HS	1                       :so can count round robin accurately

RMT1SL	HS	1		:SAVE SIZE OF EACH T-I SUP RECORD HERE
RMT1SB	HS	1		:SAVE BUFFER# WHEN ZAPPING T-I COMMAND CRQ

MINLR	HS	1		:MINIMUM LOGICAL RECORD SIZE (3 FOR T-I,
				: 1 FOR T-II). USED BY RTD TO DETERMINE IF
				: ANY LOGICAL RECORDS REMAINING IN PACKET
LSNIPS	HS	1		:COUNT LINK SNIPS
	SYAD(LSNIPS)
ZAPCNT	HS	1		:COUNT ZAPPED CIRCUITS FOR LINK OUT NODE REPORT
CMDZCT	HS	1		:COUNT ZAPPED COMMAND CIRCUITS FOR REPORTING
TRREGS	WS	10		:REGISTER SAVE FOR CALLING TRACE, SUP12

:	MISCELLANEOUS FLAGS:

:	GUSH AND TRIKLE ARE CHANNEL BIT ARRAYS WHICH INDICATE RATE OF DATA
:	FLOW INBOUND. RTD TESTS THE SIZE OF EACH LOGICAL RECORD TORN,
:	AND SETS THE GUSH ARRAY IF L.R. SIZE IS 'TRIKLV' OR GREATER.
:	IF L.R. SIZE IS LESS THAN 'TRIKLV', THE TRIKLE ARRAY IS SET
:	FOR THAT CHANNEL. EVERY 2 SECONDS THE TRIKLE ARRAY IS OR'D
:	INTO THE GUSH ARRAY. WHEN RMAKE SENDS BACKPRESSURE RECORDS, IT
:	WILL ONLY TEST THE CHANNELS WITH GUSH SET TO SEE IF
:	BACKPRESSURE MAY BE RELIEVED.

RTMXSV	WS	1		:TEMP STORAGE FOR RTD/RMK
RTMT1	WS	1
RTMT2	WS	1
RTMT3	WS	1
RMTNSV	WS	1
RMTNFL	HS	1
	IF	DB.DEB
RMKHWM	HS	1		:HIGH-WATER MARK FOR INTERVALS BETWEEN
				: RMAKE EXECUTIONS (IN FASTC UNITS)
RMKTIM	HS	2		:TIME OF LAST RMAKE EXECUTION
	EI	:DB.DEB

CKOSAV	WS	1		:WORK SPACE FOR LINK OVERLOAD CHECKER

XWMFLG	HS	1               :flag for XRAY warning msg

ARRIVX	WS	1               :storage for XLACK char
ARRIVT	WS	1

:	EQUATES FOR IMMEDIATE INSTRUCTIONS
:	(NEEDED BECAUSE OF NAD LIMITATION CONCERNING FORWARD-REFERENCED
:	LABELS IN IMMEDIATE INSTRUCTIONS)


:	Consider for possible future additions to link descriptor


	DEFAULT(SQNUMB,200)	:###TZ

::*********************************************************************
::
::	XHOSTS VARIABLES:
::
::*********************************************************************

:	HOST TABLES
:	Consider for possible future Host descriptor
HSTPTA	HS	NHOSTS		:# OF HOST PORTS AVAILABLE
HNPORT	HS	NHOSTS		:# OF HOST PORTS ACTIVE
:	NOTE:  Portions of host table not cleared at restart.	
:	The previous two entries MUST precede HOSTN for the
:	reinitialization of the host tables at (re)start to work
:	properly in NSTART.###jhl (this is not real smooth)
:	We zero out HNPORT and reset HSTPTA to HMAXP.

:*******FROM HERE TO NEWSUP LABEL (BELOW) FOR HOST TABLE STUFF ONLY****

HOSTN	HS	NHOSTS		:HOST #S
HMAXP	HS	NHOSTS		:MAX # OF PORTS
	HS	0		:HSTAT STARTED AT HW BOUNDARY		##AL
HSTAT	BS	NHOSTS		:STATUS BITS
HSTKEY	BS	NHOSTS		:KEY (4*SLOT #), FOR EACH HOST
:	EXPANDED HOST STATUS INFORMATION
HSTMBK	BS	NHOSTS		:MULTI-BASED HOST KEY			###OAS
	IF	T2GATE
HSTATN	EQ	HSTAT		:ONLY ONE SLOT HOST & STATUS FOR T2G	##AL
	ELSE
HSTATN	BS	NHOSTS		:EXPANDED HOST STATUS(sup19 status byte)###OAS
	EI	:T2GATE##AL	:BITS 0,1 - STATUS (SAME AS HSTAT 6,7)
				:BIT 2 SET IF OUT OF PORTS
				:BIT 3 SET INDICATES IIX
				:BIT 4 SET - ORG ONLY HOST
				:BIT 5 SET - DEST ONLY HOST
				: (IF 4 AND 5 SET, SAME AS BOTH NOT SET)
				:Bits 6,7 - unused
HSTYPE	BS	NHOSTS		:HOST TYPE (PID)			###OAS
HSTCST	BS	NHOSTS		:HOST COST (MULTI TARGET HOST)		###OAS
HSTTIM	WS	NHOSTS		:TIME OF LAST HOST STATUS UPDATE	###OAS
HSTAT3	BS	NHOSTS		:Additional host status byte		###wjl
				:Bit  0     - unused			###wjl
				:Bit  1 - LOG II host			###sdw
				:Bit  2     - unused			###wjl
				:Bit 3 - set if proxy host		###wjl
				:Bits 4,5 - Collect-calls		###wjl
				: 00 = never accept Collect-calls	###wjl
				: 01 = only accept calls		###wjl
				: 10 = leave decision to destination host##wjl
				: 11 = unused				###wjl
				:Bits 6,7 - unused			###wjl

:*******FROM HOSTN (ABOVE) TO HERE FOR HOST TABLE STUFF ONLY***********

:	NEWSUP label used by NSTART to resume clearing
NEWSUP	HS	1		:NEW/OLD (1/0) SUPERVISOR FLAG		###OAS

HSTFLG	HS	(NHOSTS+0F)/10	:FLAG INDICATING NODE CODE HAS GOT HOST
:	STATUS REPORT (MESSAGE 04 OR 10) FROM ISIS FOR SPECIFIC HOST.
:	ONE BIT FOR ONE HOST.  ***NEED CLEAR ALL FLAGS WHEN RESTART***
HSTSAV	WS	1		:TEMP. STORAGE TO SAVE R2

	IF	RESHST		:RESTRICTED HOST STUFF
HCTSM	HS	NHOSTS		:CIRCUITS/MINUTE LIMIT
HCTSCT	HS	NHOSTS		:CIRCUITS/MINUTE COUNT
RESHMS	HS	(NHOSTS+0F)/10	:BIT ARRAY TO THROTTLE NODE REPORTS FOR
				: RESTRICTED HOST VIOLATIONS
	EI	:RESHST

KERNWL	WS	(NKU+1F)/20	:NEW CIRCUITS TO KERIO
KERBPX	WS	(NKU+1F)/20	:BACKPRESSURE OUTBOUND DATA FROM KERNEL IF ZERO

	IF	KNRING

KOFSAV	WS	1		:BIT SET FOR POTENTIAL ACTIVE PORT
KRZAPI	WS	1		:BIT SET FOR ZAPPER SENT TO KERNEL
KRGOBI	WS	1		:BIT SET FOR GOBBLER SENT TO KERNEL
NLOGDF	WS	1		:BIT SET FOR DEFERRED NEWLOG REPORT TO KERNEL
NLOGCT	WS	1		:BIT SET FOR NEWLOG CONTROL TO KERNEL
NLOGOK	WS	1		:BIT SET IF O.K. TO HANDLE NEW LOGIN
KERSTT	HS	1		:KERNEL STATUS				###GT

	IF	DB.DEB
KRNRPS	HS	1		:SAVE ORIGINAL PRD (NODE INDEX)
KRNLRS	HS	1		:SAVE ORIGINAL LRC (KERNEL INDEX)
KNLRCS	HS	1		:SAVE COMPUTED ROOM AVAILABLE
	EI 	:DB.DEB

	IF	SIORNG
:	INTERRUPT COMMUNICATION RING
SIRI	HS	1		:IN POINTER (INDEXED BY INTERRUPT ROUTINE)
	SYAD(SIRI  )
SIRO	HS	1		:OUT POINTER (INDEXED BY SIRCIN)
SIRX	BS	SIRXSZ		:INTERRUPT COMMUNICATION RING

SIRXIZ	HS	1		:INITIALIZE INTERFACE IF NON-ZERO
	SYAD(SIRXIZ)
SIRFLG	HS	1
	SYAD(SIRFLG)
:	SIO RING FLAG, STATE VALUES AS FOLLOWS:
:	=0	SIO CARD IS DEAD (DOWN)
:	-1	SIO CARD IS ALIVE (UP)
:	>0	SIO CARD TIMED-OUT. SIRFLG CONTAINS COMMAND WHICH TIMED-OUT.
:		STSRM0 KERNEL IN BOOT, AWAITING SIO RING LOAD.

SIRDLD	HS	1		:SIO RING DOWN-LINE LOAD FLAG:
:	=0	NO SIO RING LOAD IN PROGRESS
:	-1	SIO RING LOAD IN PROGESS

	EI 	:SIORNG
	EI 	:KNRING

:	COMMON STUFF

FASSAV	WS	1		:FASTC AT TIME OF SUP CRASH
KERSVD	WS	(NKU+1F)/20	:KERNEL PORTS BEING PROCESSED BY KERIO
SUPSVD	WS	NSP/20		:SUP SIMILAR

XHSVRT	WS	1		:SAVE RETURNS
SBPTMP	WS	1		:TEMP STORAGE
XHPRCS	HS	1		:PRC SAVE

KERICC	HS	1		:COUNT OF CHARS INTO THE KERNEL
KEROCC	HS	1		:DITTO OUT
SUPICC	WS	1		:GUESS
SUPOCC	WS	1

SUICHR	HS	1		:SAVE AREA FOR INVALID CHARACTER PAIRS
				: ARRIVING AT A SUP PORT
SUERCH	HS	1		:SAVE CHANNEL FOR ERRONEOUS NETWORK CHARACTERS
SUERTP	HS	1		:SAVE TYPE OF ERRONEOUS CHARACTERS DETECTED

	IF	SIORNG
SIRCSV	WS	1		:SAVE LINK FOR SIRSCK
	EI 	:SIORNG

	IF	SNRING
SUPBPV	WS	NSP/20		:RESET IF BP'D FROM NODE-->SUP
SUPBPX	WS	NSP/20		:RESET IF BP'D FROM SUP-->NODE
	IF	DB.DEB
SRNRPS	HS	1		:SAVE ORIGINAL PRD (NODE INDEX)
	SYAD(SRNRPS)
SRNPRS	HS	1		:SAVE ORIGINAL PRC (SUP INDEX)
	SYAD(SRNPRS)
SRNRCS	HS	1		:SAVE COMPUTED ROOM
	SYAD(SRNRCS)
	EI 	:DB.DEB
	EI 	:SNRING

::*********************************************************************
::
::	DISPI VARIABLES:
::
::*********************************************************************

DSOLGH	HS	2		:'HOST #', 'TID', 'ESC' FOR DSOLGC
DSOSPC	WS	1		:CONTROL CHARACTER ARRAY FOR LOGIN STRING

DIXLIM	HS	NDP		:TRANSMIT LIMITS (PER PORT)

DISBPV	WS	(NDP+1F)/20	:RECEIVED BACKPRESSURE FLAGS
	SYAD(DISBPV)
DISBPX	WS	(NDP+1F)/20	:TRANSMITTED SUCH
	SYAD(DISBPX)
DISSVD	WS	(NDP+1F)/20	:PORT SERVICED FLAGS

       if       t2gate
GISSVD  WS      (NDP+1F)/20     :GATEWAY LOGING SERVICED FLAGS
       ei

DISAUX	WS	(NDP+1F)/20	:AUX CIRCUIT REQUEST FLAGS
DISHNG	WS	(NDP+1F)/20	:HANG SENT TO DISP PORT, NOT YET ZAPPED
	SYAD(DISHNG)
DISZNK	WS	(NDP+1F)/20	:ZAP SENT TO DISP PORT, AWAITING ZAP ACK
	SYAD(DISZNK)
DISELS	WS	(NDP+1F)/20	:REQUEST EXTENDED LOGIN STATUS FLAGS

	IF	EXPNDL		:###jhl
DISUUN	WS	(NDP+1F)/20	:bit set when circuit requests UUN	###jhl
LNDLSV	WS	1		:saves BB ptr for LEP09 PEEKing at SNI's###jhl
SNCSV1	WS	1		:saves BE ptr for LOGGER to fill msg length
SNIBUF	WS	1		:holds buffer number containing SNI list
SNCTSV	WS	1		:save SNI-length subcount in LOGGER

:	equates for SNI (supplementary needle items) and their types
SNIUUN	EQ	08		:request for UUN or "follows UUN"
SNIPRX	EQ	0C		:proxy login token
SNIHST	EQ	10		:originating host number
SNIIIX	EQ	14		:request for IIX circuit
SNILGC	EQ	18		:login characters
SNINOP	EQ	0F4		:SNI no-op
SNITRM	EQ	0FC		:terminates SNI list
SNTYP0	EQ	0		:bits for type 0
SNTYP1	EQ	1		:bits for type 1
SNTYP2	EQ	2		:bits for type 2
SNTYP3	EQ	3		:bits for type 3
SNITYP	EQ	3		:mask to isolate type bits
	EI	:EXPNDL

       IF       LOGII
L2CHSV	WS	1		:reg save area for LogII CRQ utility
ICRMS1  WS      1               :temp area
ICRMS2  WS      1               :temp area
ICRMS3  WS      1               :temp area
ICRMSZ  WS      1               :temp area for MO size
ICRMSB  HS      1               :save x.409 flags field
DORLKY  HS      1               :save area for local key in ICRM
DORDKY  HS      1               :save area for dispacher key in ICRM
DORCHN  HS      NSLOT+1         :CHN for ICRM arriving in pieces
SLTRJT  BS      (NSLOT+8)/8     :set if rejecting ICRM pieces for slot

DISLG2  WS      (NDP+1F)/20     :port using/used LOG II login? (org ports only)
        SYAD(DISLG2)
       IF       T2GATE          :for gateway log2
GDBUFT  WS      1               :temporary buffer address
       EI       :T2GATE
       EI       :LOGII

DSSVRT	WS	1		:FOR SAVING RETURN
      IF        EFFDIS
DSOREG  WS      10              :for saving all regs (DSODBP)
      EI        :EFFDIS

DIDTIM	WS	1		:DISPATCHER PROCESS DISMISS TIME

:       The following is used for expansive IS command          ###sdw
DISICC	WS	1		:CHARACTER COUNTS - INTO DISPATCHER
DISOCC	WS	1		:FROM DISPATCHER
DISOCH  WS      1               :highwater dispatcher movement          ##sdw
DISICH  WS      1               :input highwater dispatcher movement
DISOCM  WS      1               :output new 1 min history
DISICM  WS      1               :input new 1 min history
DISOCT  WS      1               :output time of highwater
DISICT  WS      1               :input time of highwater
DSOHGM  WS      8               :output histogram
DSIHGM  WS      8               :input histogram
:       Following 8 hw are expected to be contigious in this order by xray IS
:       command display                                                 ###sdw
DISICP  HS      1               :high amount of ring fill
DISOCP  HS      1               :high amount of ring fill for output    ###sdw
DSICHN	HS	1		:NEW NEEDLE CHANNEL NUMBER
				: (SEE 0310 MESSAGE)
DSINOD	HS	1		:CIRCUIT ORIGINATING NODE NUMBER
				: (SEE 0310 MESSAGE)
DORHST	HS	1		:ORIGINATING HOST NUMBER
				: (SEE 07 MESSAGE)
DOILLG	HS	1		:NUMBER OF ILLEGAL LOGIN CHARACTERS
				: FROM DISPATCHER PORTS NOT IN LOGIN MODE
				: (SEE B3 MESSAGE)
DIDISM	HS	1		:NUMBER OF FORCED DISMISSES FOR DISIN
DODISM	HS	1		:NUMBER OF FORCED DISMISSES FOR DISOUT

DORSLT	HS	1		:SLOT NUMBER * 2
				: LAST SLOT WHICH ORIGINATED CIRCUIT
RPSAV	HS	1		:TEMP STORAGE
DSIPRT	HS	1		:CIRCUIT ORIGINATING PORT NUMBER
DSIHST	HS	1		:CIRCUIT ORIGINATING HOST NUMBER
DSINFL	HS	1		:SAVE NEEDLE FLAGS
DSITLG	HS	1		:INDICATE TRANSPARENT LOGIN IF POSITIVE
DORSIQ	HS	1		:SAVE SIQ
DSOHYP	HS	1		:INDICATE IF HOST STATUS MESSAGE CONTAINS HYPE
	IF	(1-T2GATE)
SCLCNT	HS	NUSLT		:COUNT NUMBER OF CIRCUITS, BY SLOT
SMLCNT	HS	NUSLT		:COUNT NUMBER OF SLOT REPORTS, BY SLOT
	EI	:(1-T2GATE)		###EV
DIMMSV	HS	2*2		:SAVE FOR REG'S 14,15

XFNDSV	WS	1	:XFNDLK ROUTINE


::*********************************************************************
::
::	SWITCH VARIABLES:
::
::*********************************************************************

PFMTYP	HS	1		:RTD STORES ARRIVING PERF MON.CHAR HERE
ARRIVL	WS	1		:RTD STORES ARRIVAL TIME OF PERF MON CHAR PAIRS

TVRSUP	HS	1		:CONTAINS SUP # AFTER TAKEOVER
	SYAD(TVRSUP,1)
TVRBUF	HS	1		:SUP UPSTREAM BUFFER #
TVRSTT	HS	1		:SUPERVISOR STATUS (5=AWK,4=SLP,3=FRZN)
LOGZPF	HS	1		:TO CAUSE LOGGER TO ZAP CIRCUITS ON TVR
TAKOVR	HS	1		:SHOW RECENT TAKEOVER,DEFERRED RESOURCES REPORT
LEPINB	HS	1		:BUFFER BEING PROCESSED BY LEP
LEPNOD	HS	1		:BUFFER FOR LEP MESSAGES
LEPMES	HS	80
SUPMBF	HS	5		:BUFFER FOR SUP UPSTREAM MESSAGES
       IF       LOGII
LEPAS1  HS      2               :series of saves for LOG2 LEP
LEPAS2  HS      2
LEPAS3  HS      2
LEPAS4  HS      2
LEPAS5  HS      2
       EI       :LOGII
KDISP	HS	1		:FOR FLASHING DISPLAY OF NETWORK STATUS
SUPIBF	HS	3		:TEMPORARY BUFFER FOR DIAGNOSTIC MESSAGES
				: GENERATED IN ISIS FOREGROUND ROUTINE

LEPNPF	HS	2		:LEFT HALFWORD POSITIVE IF HANDLING SUP NOPP
:	COMMAND FOR LOAD TEST. RIGHT HALFWORD HAS LOOP COUNTER. SEE 'LEPNOP'.
LEPNSF	HS	2		:SUP FASTC SAVE AREA FOR SUP NOP
LEPXER	HS	1		:NUMBER OF LEP ERRORS (SEE LEPXMN, LEPXCM)





:	THE STORAGE FOR THE DEBUGGER				###LSH

:	TURN OFF ALL THE ASSEMBLY SWITCHES FOR  ALL THE DEBUGGERS
DEFAULT(LNFDBG,0)		:LOGON/LOGOFF DEBUGGER OFF
DEFAULT(CBZDBG,0)		:CIRCUIT BUILDING/ZAPING DEBUGGER OFF
DEFAULT(BFSDBG,0)		:BUFFER STRUCTURE DEBUGGER OFF
DEFAULT(LPGDBG,0)		:LEP/LOGGER DEBUGGER OFF
DEFAULT(LNKDBG,0)		:LINE/LINK DEBUGGER OFF
DEFAULT(DBGON,LNFDBG!CBZDBG!BFSDBG!LPGDBG!LNKDBG)

        WS      0
REGST	WS	10              :temp storage for registers in background
RGST	WS	10              :used for any foreground debugs
	IF	LPGDBG
LPGSSV	WS	1		:TEMP STORAGE FOR RING POINTER
	EI	:LPGDBG

	IF	LNFDBG
LGINUS	HS	1		:"LG" XRAY COMMAND IN USE INDICATOR
	EI	:LNFDBG
	IF	CBZDBG
CZINUS	HS	1		:"CZ"XRAY COMMAND IN USE INDICATOR
	EI	:CBZDBG
	IF	BFSDBG
BFINUS	HS	1		:"BF" XRAY COMMAND IN USE INDICATOR
	EI	:BFSDBG
	IF	LPGDBG
LLINUS	HS	1		:"LL" XRAY COMMAND IN USE INDICATOR
	EI	:LPGDBG
        IF      LNKDBG
LKINUS  HS      1               :"LK" XRAY COMMAND IN USE INDICATOR
        EI      :LNKDBG


:	TURN OFF ALL THE ENABLE/DISABLE FLAGS FOR ALL THE DEBUGGERS

	IF	LNFDBG		:FOR LOGON/LOGOFF DEBUGGER

LINDIS	HS	1		:FLAG FOR LOGIN. 
	SYAD(LINDIS)
	EI	:LNFDBG

	IF	CBZDBG		:FOR CIRCUIT BUILDING/ZAPPING DEBUGGER
CRQDIS	HS	1		:FLAG FOR CRQ, AND CRQHCR.
	SYAD(CRQDIS)
ZAPDIS	HS	1		:FLAG FOR ZAPHRD, AND ZAPV.
	SYAD(ZAPDIS)
	EI	:CBZDBG

	IF	BFSDBG		:FOR BUFFER STRUCTURE DEBUGGER
GRFDIS	HS	1		:FLAG FOR GFCBUF, AND RFCBUF.
	SYAD(GRFDIS)
WREDIS	HS	1		:FLAG FOR WRE, CKZB, REBZ, BUFZAP
	SYAD(WREDIS)
CBCDIS	HS	1		:FLAG FOR CBCLR.
	SYAD(CBCDIS)
	EI	:BFSDBG

       IF	LPGDBG		:FOR LEP/LOGGER DEBUGGER
LPGDIS	HS	1		:FLAG FOR LEP AND LOGGER.
	SYAD(LPGDIS)
LPDDIS	HS	1		:FLAG FOR LEP0D, LEP09, AND LEPZLI
	SYAD(LPDDIS)
	EI	:LPGDBG


       IF	LNKDBG		:FOR LINE/LINK DEBUGGER
LKLDIS	HS	1		:FLAG FOR LINK/LINE DEBUGGER
	SYAD(LKLDIS)
        DEFAULT(PKSVLH,20)              : How many bytes to save of bad SIO rec
PSLNUM	HS	1			: FLAG SET WILL TURN-ON SIPKSV
	SYAD(PSLNUM)
       EI       :LNKDBG

:	THE END OF STORAGE FOR DEBUGGER		###LSH


LOGSAV	WS	1		:TEMP STORAGE FOR LOGIN
LOGTBF	WS	1
LOGTID	BS	1
       IF       REBTAK
LP8RS1  WS      1               :ave for new rebuild resend             ###sdw
       EI       :REBTAK

LGCSAV	WS	1		:TEMP STORAGE FOR LOGCLR		###LSH
CRDSAV	WS	1		:TEMP STORAGE FOR CIRDIS		###LSH
CRDSSV	WS	1		:TEMP STORAGE FOR CIRDIS		###LSH
ASMSSV	WS	1		:TEMP STORAGE FOR ASYMPC		###LSH

FREELB	HS	1		:HEAD OF THE FREE BUFFER-PAIR LIST
	SYAD(FREELB)
FREELT	HS	2		:HEAD OF FREE BUFFERLET LIST
	SYAD(FREELT)
REBL	HS	2		:POINTER TO RESERVE TANK LIST
WRERET  WS      1       	:RETURN POINTER FOR WRE ROUTINE

       IF       LOGII           :log II (new logon stuff including X.409)
GTLNSV  WS      1               :temp for X4GTLN
X4WTSV  WS      1               :temp for X4WTEL
X4TBPT  WS      1               :pointer into table X4TBBG (for parsing)
X4NXVL  WS      2               :contains bits, ID, LEN from parser
ELEPOS  WS      1               :current address within buf of parser
ELEDIS  HS      1               :how many char parsed from start
X4CPTR  WS      1               :pointer to current position in table
X4CWSV  WS      1               :save area when writing X.409 element to buffer
X4CWS1  WS      1               :save area when writing X.409 element to buffer
       EI       :log II
X4NXSV  WS      1               :save for X4NXTEL
SWIVSV	WS	1		:TEMPORARY STORAGE FOR SWITCH
YAKT1	WS	1		:TEMP
LEPSV1	WS	1		:DITTO
:::
BPMTII	BS	LKSIZE		:DO FLOW CONTROL FOR TYMNET-II LINKS
CRQASV	WS	1		:SAVE LINK REG FOR CRQALT
BPMXSR	WS	1		:SAVE RETURN FOR BPMX
BPSHSV	WS	1		:TEMP STORAGE FOR BPMSHF
BPSHRT	WS	1
GETRSV	WS	1
RFCSAV	WS	1
TRCSV1	WS	1
TRCSV2	WS	1
HPRUNV	WS	1
ZAPXS1	WS	1		:SAVE AREA FOR CALLING LOGCLR FROM ZAPX
ZAPXS2	WS	1
SPLSV1  WS      1               :work area for splice
SPLSV2  WS      1
SPLSV3  WS      1
BUBS1	HS	1		:WORK AREAS FOR BUBBLE
BUBS2	HS	2
BUBS3	HS	1
LNKRGS	WS	2		:REG STORAGE FOR SHRK4, FNDKNC, BUBBLE
WCDSAV	WS	2		:TEMP STORAGE FOR WCD
GCDSV   HS      1               :TEMP STORAGE FOR GCD
CHUSAV	WS	1		:TEMP STORAGE FOR SWRCHU

RFAT	WS	1		:DATA FROM FAT ZAPPER FOR REBUILD REQUEST

DETSVC	WS	1		:SERVICED FLAGS FOR 'DETACH'
DETMTY	BS	$A32		:MESSAGE TYPE FOR EACH DETACHED PORT
				: OUTPUT IT ON RECEIPT OF NEEDLE
DETTSV	HS	1		:TEMP AREA FOR ABOVE

ACT7	WS	3		:LAST '07' TYPE ACCOUNTING MESSAGES
ACTLST	BS	1		:INDEX TO LAST TYPE '07' MSG SENT

WATCHDOG BS	1		:WATCHDOG TIMER FLAG

NEDFLG	HS	1		:LEP SAVE NEEDLE FLAGS

:	CIRCUIT BUILDING CONSISTENCY FIELDS
NC.LPE	HS	1		:NUMBER OF LEP CHAN IN USE, NO NEIGHBOR ERRORS
NC.CRQ	HS	1		:TOTAL NUMBER OF CIRCUITS ATTEMPTED BY CRQ
NC.CRZ	HS	1		:NUMBER OF CIRCUITS ZAPPED BY CRQ
NC.CRC	HS	1		:TOTAL NUMBER OF CIRCUITS COMPLETED BY CRQ
NC.THS	HS	1		:CIRCUIT ERROR REPORTING THRESHOLD
NC.CER	HS	1		:TOTAL NUMBER OF CONSISTENCY ERRORS

PLISLT	HS	1		:STORAGE FOR ISIS SLOT NO. FOR PLI MESSAGE
PLICNT	HS	1		:BYTE COUNT IN PLI MESSAGE
PLINDX	HS	1		:CURRENT RECEIVED BYTE COUNT FOR PLI MESSAGE
PLIXOR	HS	1		:CHECKSUM
PLICN2	BS	1		:ANOTHER BYTE COUNT FIELD, FOR BUFCAN ROUTINE
PLIDAT	HS	100/2		:PLI MESSAGE DATA AREA (HW aligned)	###jhl

INTSAV	HS	8		:WORKING AREA FOR INTERNAL HOST PROCESSOR

INTTSV	WS	1
INTDWF	HS	1		:INTERNAL HOST DWL CHANNELS ARRAY
	SYAD(INTDWF)
INTOUT	HS	1		:INTERNAL HOST TIMEOUT ENABLE BIT ARRAY
SI1DBG	HS	1
SI2DBG	HS	1
INTUSE	HS	1		:INTERNAL HOST CHANNEL IN USE BIT ARRAY
	SYAD(INTUSE)
INTLST	HS	1		:WORKING AREA FOR INTERNAL HOST PROCESSOR
INTACT	HS	1		:INTERNAL HOST ACTIVE CHANNEL BIT ARRAY
INTWRN	HS	1		:INTERNAL HOST TIMEOUT WARNING BIT ARRAY
INT8MN	HS	1		:8-MINUTE CELL FOR INTTIM
INTXRF	HS	1		:INTERNAL HOST REMOTE XRAY CHANNEL BIT ARRAY
XUSIUA	HS	1		:XRAY USER SLOTS IN USE ARRAY
INTLPF	HS	1		:LOOPBACK TEST BIT ARRAY
	SYAD(INTLPF)

INTDSF	HS	1		:CRQ DELAY CHECK SOURCE CHANNEL BIT ARRAY
INTDRF	HS	1		:CRQ DELAY CHECK RECEIVING CHANNEL BIT ARRAY

XRYRUN	HS	1		:RUN FLAG FOR XRAY
XDDTAD	WS	1		:address where XDDT job wants background to do
                                :something (prevent job collision)###sdw
XDDTSV  WS      20              :XDDT registers for BG task
DBEGS1  WS      1               :link register save for begin delay circuit
DLYES1  WS      1               :link register save for end delay circuit
XWRBS1  WS      1               :link register save for write buffer cmd
XNIDS1  WS      1               :link register save for change NEITD cmd
XRPFS1  WS      1               :link register save for perf mon cmd (PM)

DWLCOU	HS	1		:THIS AND THE NEXT THREE LOCATIONS ARE FOR
	SYAD(DWLCOU)
DWLCLI	HS	1		:SPOTTING DWL PROBLEMS
DWLCIN	HS	1
DWLDSP	WS	2		:BIT ARRAY FOR SPEEDY DISPATCH OF DWL LINES
STDWDS	WS	2		:FOR STARLINE LOADS BOTH INDEXED BY 2*Line#
DWQUEU	HS	1		:DWL JOB QUEUE FOR DWLIN
DWTEST	HS	1		:SEMAPHORE BETWEEN LINKER AND DWLIN

dlyrat  hs      1               :so dlysrc can pace delay source data
DLYINT	HS	10		:INTERVAL in 1/8 seconds-1 between test data

NETDCT	HS	2		:THROTTLE COUNTER FOR DIAGNOSTIC NODE REPORTS
NTDRET	HS	2		:SAVE LINK REGISTER FOR NETDGN

	WS	0		:WORKING STORAGE FOR CRQ
CQNBUF	HS	1		:NEEDLE BUFFER #

CQNLK	HS	1		:WORKING STORAGE FOR CRQ
GDNINV	WS	0		:Overlay invoice numbers
CQINV	WS	1		:INVOICE #
TSTSAV	WS	1		:###TESTING SAVE AREA
	IF	ACCT2
	HS	1		:Extra HW for Acct2 format
	EI	:ACCT2
	IF	ACCT
GASTOR	WS	1
	EI	:ACCT
CQNFLG	HS	1		:FLAGS
CQNODE	HS	1		:REQUESTING NODE
CQPORT	HS	1		:REQUESTING PORT
CQDHST	HS	1		:DESTINATION HOST IF INTERNAL CIRCUIT
CQTID	BS	1		:Originating TID (CCT)
	BS	1		:Could store User Flags if needed
CQHOST	HS	1		:HOST # (DESTINATION NODE IF T-I)

CQNSZ	HS	1
CQVSEQ	WS	1		:SEQN NUMBERS ARE NOW 32 BITS		###GT
	SYAD(CQVSEQ)
CQXSEQ	WS	1
	SYAD(CQXSEQ)

CRQARL	EQ	((NCIRCS+1F)/20)*4	:# BYTES IN CRQ BIT ARRAYS
CRQEND	WS	CRQARL/4	:EACH BIT REPRESENTS BUFFER PAIR, BIT SET FOR
	SYAD(CRQEND)		: CIRCUIT TERMINATION (INTERNAL OR T-1)
CRQBSY	WS	CRQARL/4	:EACH BIT REPRESENTS BUFFER PAIR, BIT SET FOR
	SYAD(CRQBSY)		: REBUILDABLE TERMINATION (NOT TPUT CLASS 3)
BURSAV	WS	1		:Register save area
REBTMO	WS	CRQARL/4	:CIRCUIT BUILDING TIMEOUT FLAGS
REBTMI	WS	CRQARL/4
	IF	REBILD
SQFIXV	WS	CRQARL/4	:SET IF REBILD QUAD EVER RECEIVED FOR THIS CRQ
SQFTMI	WS	CRQARL/4	:REBUILD TIMEOUT FLAGS			###GT
SQFTMO	WS	CRQARL/4
	EI 	:REBILD

CHNMPD	HS	NLINKS		:NODE NUMBERS FOR PROBE TRACE
CHNMAP	WS	NLINKS+6+SUPER        :CHANNEL MAP FOR PROBE TRACE

	IF	ACCT!T2GATE!INTACC
::	INTERNAL HOST ACCOUNTING PARAMETERS	###ev
::	DESCRIPTORS AND EQUATES
::	Accounting block descriptor per virtual circuit
Q	HS	0
	ORG	0
AAINV	HS	2		:Invoice number	
	IF	ACCT2
	HS  1			:expanded to 48 bits
	EI	:ACCT2
AAIC	HS	2		:Input character count
	IF	ACCT2
	HS  1			:with room to expand
	EI	:ACCT2
AAOC	HS	2		:Output character count
	IF	ACCT2
	HS  1			:with expansion
	EI	:ACCT2
AADSIZ	HS	0		:Size of block per circuit
	ORG	Q		: (in bytes)

       EI       :ACCT!T2GATE!INTACC                                     ###sdw


       IF       ACCT!INTACC!T2GATE      :                               ###sdw
::	Accounting logout and zap reason equates
AALR02	EQ	02		:Normal disconnect by host
AALR03	EQ	03		:Normal disconnect by user
AALR07	EQ	07		:Out of internal host ports
AALR11	EQ	11		:User-name rejected .. bad Xray username
AALR19	EQ	19		:Host rejected caller .. out of Xray slots
				:or invalid DWL or PLI Message Function
AALR24	EQ	24		:Circuit rejected as invalid .. bad control
				:character or bad Internal Host function
AALR25	EQ	25		:host not answering .. circuit timeout
AALR26	EQ	26		:Resource limit exceeded .. bumped by
				:higher status Xray user
	EI	:ACCT!T2GATE!INTACC

::	ACCOUNTING VARIABLE PARAMETERS
::	Number of circuits to keep accounting for
	IF	T2GATE

	IF	INTACC		:Internal host accouting
NACCTS	EQ	TINTCH+NDP	:Internal host plus gateway ports
	ELSE	:NOT INTACC
NACCTS	EQ	NDP
	EI	:INTACC
	ELSE	:NOT T2GATE
	IF	ACCT
NACCTS	EQ	TINTCH+NKU	:Internal Host ports plus Kernel ports
	ELSE	:NOT ACCT
NACCTS	EQ	0
	EI	:ACCT

	EI	:T2GATE

::	STORAGE
	IF	T2GATE!INTACC
AAREAS	WS	1		:Logout reason save area
AAR1SV	WS	1		:Return save
AAR2SV	WS	1		:Ditto
ININV	WS	1		:Store INET Invoice number for AASWAP
	EI	:T2GATE!INTACC
::	Linear array to contain pointers to each accounting block
	IF	ACCT!T2GATE!INTACC
AABPNT	WS	NACCTS		:Word address to each accounting block
AARGSV	WS	10		:Accounting routines register save area
AALINS	WS	1		:Last Invoice Number Sent save area
AA20MN	WS	1		:Timer count save area
AASVCT	WS	1		:Port counter for periodic report
::	end of accounting descriptions and parameter storage	###ev

	EI	:ACCT!INTACC

	IF	T2GATE
::*********************************************************************
::
::	FUNCTION:	Data storage areas for gateway logon process
::*********************************************************************

::Bit arrays for Gateway ports
CCTTBL	BS	NDP		:Save area for CCT's for Gateway circuits
LOGING	WS	(NDP+1F)/20	:Ports marked when in Log-in mode
	SYAD(LOGING)
GDSTPT	WS	(NDP+1F)/20	:Ports marked as circuit destinations
GORGPT	WS	(NDP+1F)/20	:Ports marked as circuit origins
GTAUX	WS	(NDP+1F)/20	:Gateway circuits originated as Aux circuits
GIIXCT	WS	(NDP+1F)/20	:Circuits marked as IIX capable
GTTRNS	WS	(NDP+1F)/20	:Circuits originating as transparent log-ons
GTHDX	WS	(NDP+1F)/20	:Circuits originating from HDUX terminals
GTASCI	WS	(NDP+1F)/20	:Circuits determined as 2741 or 3767 origin
GTECHO	WS	(NDP+1F)/20	:Echo mask per port - primary Echo switch
GTLGEC	WS	(NDP+1F)/20	:Echo for log-on processing
GMSG0F	HS	0		:Companion array to mark log-on status
LOGDAT	WS	(NDP+1F)/20	:Ports with data for Log-in
GLGDAT	WS	(NDP+1F)/20	:Ports for more data log-in (B3)
::Storage areas for Gateway log-ins
GASAVE	WS	1		:Return save area
GDSAVE	WS	1		:Return save area
GESAVE	WS	1		:Return save area
GRSAVE	WS	1		:Return save area
GZSAVE	WS	1		:Return save area
GZAPSV	WS	1		:Return save area
GDPRD	HS	1		:Save area for Dispatcher ring pointer
GDDIAL	HS	1		:Saved from Needle - Dialect field
GDCCT	BS	1		:Saved from Needle - CCT field
GDUNSZ	BS	1		:Saved from Needle - Username size
GDSPED	BS	1		:From Needle - Speed bits ready in low nible
GDTPC	BS	1		:From Needle - Throughput class field
GDNLEN	HS	1		:From Needle - additional length of Needle
GDUSRF	HS	1		:From Needle - User Flags
GDFLGS	HS 	1		:From Needle - Needle Flags
GLGSTA	HS	1		:Log-on status storage
::Miscellaneous	Gateway variables and equates
DZLEN	WS	1		:Storage for message length reg	
UPDOWN	HS	1		:Storage for host status
GT.VER	EQ	((VERSION*4)&0FF00)!(REVLEV)
::Some equates
GAXTID	EQ	0CE		:Aux circuit TID (CCT) is '0E'
GXPRNT	EQ	0BF		:Test for transparent log-on is "?"
GLGTMR	EQ	$A120		:Log-on timer is two minutes

	EI	:T2GATE		:###ev

:	Internal host processor arrays

INTDSP	HS	TINTCH		:Dispatch vectors (less SEG1 offset)
INTUSR  WS      TINTCH		:Username save area
INTCHN	HS	1		:temp storage for INTHST channel number ###wjl

:	Downline load arrays, indexed by internal host channel number
DWLNUM	HS	TINTCH		:Downline load line number (* 2)
DWLOPT	HS	TINTCH		:DWL output pointers
DWBUSY	HS	TINTCH		:DWL buffer busy flags

:	Delay measurement arrays, indexed by internal host channel number

CHNFIL	HS	TINTCH		:TABLE TELLS SOURCE ROUTN # OF FILL HW TO USE
CFLCNT	HS	TINTCH		:working FILL ch depletion array	###jhl
CHNDLY	HS	TINTCH		:INT HST CHAN # TO DELAY USER # PERMUTER TABLE
DLYCHN	HS	TINTCH/2	:DELAY USER # TO INT HOST CHANNEL # TABLE
INTNDX	HS	TINTCH		:DB-INDEX BY INTHST CHAN #
DB0USE	WS	1		:0 IF DLY CHN 0 NOT IN USE, ELSE XD OF USER
DB1USE	WS	1		:0 IF DLY CHN 1 NOT IN USE, ELSE XD OF USER
DB2USE	WS	1		:0 IF DLY CHN 2 NOT IN USE, ELSE XD OF USER
DB3USE	WS	1		:0 IF DLY CHN 3 NOT IN USE, ELSE XD OF USER
DB4USE	WS	1		:0 IF DLY CHN 4 NOT IN USE, ELSE XD OF USER
DB5USE	WS	1		:0 IF DLY CHN 5 NOT IN USE, ELSE XD OF USER
DB6USE	WS	1		:0 IF DLY CHN 6 NOT IN USE, ELSE XD OF USER
DB7USE	WS	1		:0 IF DLY CHN 7 NOT IN USE, ELSE XD OF USER

XUTMP	WS	3		:TEMP STORAGE FOR USERNAME VALIDATION

:	Node performance statistics storage
TOTCHR	WS	1		:INPUT+OUTPUT LOGICAL CHARS FOR LAST MINUTE
NSCPSO	HS	1		:LAST MINUTE'S CPS OUT FOR NODE'S LINKS
NSCPSI	HS	1		:LAST MINUTE'S CPS IN FOR NODE'S LINK
NSCPHO	HS	1		:NODE'S CPS OUT HI-WATER MARK
NSCPHI	HS	1		:NODE'S CPS IN HI-WATER MARK
MTLTIM	HS	1		:LAST TIME LINK TRAFFIC MEASUREMENT WAS DONE
MTLFST	HS	1		:LIKE MTLTIM BUT IN FASTC UNITS
MTTINT	HS	1		:TIME INTERVAL BETWEEN TWO LINK TRAFFIC MEAS.

:	Physical addr of NS.PCO (PHPCPS) sent to ISIS in SVC SYS,$A 51
:	in NSTART if SPAM enabled.  Expects FW storage for NS.PCO and NS.PCI.
NS.PCO	WS	1		:last minute's Physical CPS Out		###wjl
NS.PCI	WS	1		:last minute's Physical CPS In		###wjl
NS.PHO	HS	1		:node's Physical CPS Out Hi-water mark	###wjl
NS.PHI	HS	1		:node's Physical CPS In Hi-water mark	###wjl
MTRSAV	WS	1		:register save area for MTRFIC routine	###wjl

BPMSAV	WS	10		:REGISTER SAVE AREA USED IN 'BPMV' (YAKYAK)

:	LINKER line descriptor arrays indexed by line number
:	NOTE:  ">name" corresponds to proposed new usage
NGSVLN	HS	NLINES		:LAST NEIGHBOR ON LINE			>L.NEIG
KDSVLN	WS	NLINES		:LINK TO WHICH LINE WAS LAST ATTACHED	>L.KDSV
DREASN	BS	NLINES		:REASON FOR DETACH 2= NO REC, 3= RESET	>L.DRSN
RREASN	BS	NLINES		:Reason for Reset **to be implemented**
RESETE	HS	NLINES		:RESET KEY FOR STEP E			>L.RSE
RESETF	HS	NLINES		:RESET KEY FOR STEP F			>L.RSF
BAUDRT	HS	NLINES		:LINE SPEEDS				>L.BRAT
LNRTIM	HS	NLINES		:FOR COMPUTING LINE SPEEDS		>L.RTIM
LNRPOS	HS	NLINES		:DITTO					>L.RPOS
LINTIM	WS	NLINES		:FOR EACH LINE, TIME OF LAST ATT/DET	>L.TIME
LNETID	HS	NLINES		:NETID for each line
BNETID	HS	NLINES		:neighbor of netid mismatch             ###sdw
rtrdel	hs	nlines		:delay wait for retrans pacing		###sdw

:	The following are for gathering statistics
KL.RRF	HS	NLINES		:REF COUNT AT END OF LAST MIN (RCTRNS)	>L.RRF
KL.RSV	HS	NLINES		:COUNT DURING LAST MINUTE (RCTRNS)	>L.RSV
LINERR	HS	NLINES		:LINE STATISTICS - NOISE		>L.ERR
SPACNG	HS	NLINES		:SPACING (ALL ZEROES) DETECTED ON INPUT	>L.SPAC
BADACK	HS	NLINES		:BAD ACKNOWLEDGEMENTS			>L.BACK
BADRCN	HS	NLINES		:BAD RECORD #'S				>L.BRNO
BADCSM	HS	NLINES		:BAD CHECKSUMS				>L.BCSM
RCRXMT	HS	NLINES		:RETRANSMISSIONS RECEIVED		>L.RTR
LXMSET	HS	NLINES		:NUMBER OF RETRANSMISSIONS CONSIDERED	>L.RTC
KL.LRF	HS	NLINES		:REF COUNT AT END OF LAST MIN (LXMSET)	>L.LRF
KL.LSV	HS	NLINES		:COUNT DURING LAST MINUTE (LXMSET)	>L.LSV
LCROSS	HS	NLINES		:CROSS-TALK ERRORS			>L.CROS
TRRXMT	HS	NLINES		:RETRANSMISSIONS SENT			>L.RTS
KL.TRF	HS	NLINES		:REF COUNT AT END OF LAST MIN (TRRXMT)	>L.TRF
KL.TSV	HS	NLINES		:COUNT DURING LAST MINUTE (TRRXMT)	>L.TSV

:	The following are sync-unique parameters
CONFSG	HS	NLINES		:# CONSECUTIVE 4-SEC GAPS WITH NO RECORDS RCVD
:	OVER TYMNET-I LINK (TAKE LINK OUT AFTER 16 SECONDS)		>L.CNSG
FOURSG	HS	NLINES		:TOT # 4-SEC GAPS WITH NO RECORDS RECEIVED
:	OVER TYMNET-I LINK (FOR STATISTICS)				>L.FRSG
SYLLNK	WS	NLINES		:save return for SYLXRS
	
XRSTBT	HS	(NLINES+7)/8	:bit array - index by LN*2 and (LN*2)+1

:::


       IF       DB.CPU

:	HISTOGRAMS TO RECORD DISMISS AND EXEC LOOP TIMES.

EXEHSZ	EQ	80		:NUMBER OF BYTES IN EXEC DISMISS AND EXEC LOOP
				: HISTOGRAMS. NUMBER OF ENTRIES IS EXEHSZ/4
				: FULLWORD COUNTERS, RECORDS IN FASTC/4 UNITS.
EXDHGM	WS	EXEHSZ/4	:DISMISS TIME HISTOGRAM
EXEHGM	WS	EXEHSZ/4	:EXEC LOOP TIME HISTOGRAM
       EI       :DB.CPU

:	VARIABLES FOR TEMPERATURE REPORTING--RANGES AND DELAY TIME.	###JHL
TMCHFG	HS	1		:FLAG TO DISABLE TEMP CHECK (NON-0 IS OFF)
INHTMP	HS	1		:FLAG FOR INHIBITING TEMP RPTING TO 1/HR
	SYAD(TMCHFG)		:LET USER FIND FLAG TO SET IT		###JHL

:	DATA AREAS FOR GMT ROUTINES
CYRCOD	HS	1		:=0 IF CURRENT YEAR IS LEAPYR,ELSE 1,2,OR 3
GMTSLC	WS	1		:SLOWC TIME AT TIME WE GOT BASE GMT
GMTHEX	WS	1		:BASE GMT SEC'S INTO CURRENT YEAR CORRESPONDS
				:TO GMTSLC + 1DAY
GMTNOW	WS	1		:CURRENT GMT
CYRMAX	WS	1		:NO. SEC'S IN CURRENT YEAR + 1 DAY
GETGMT	HS	1		:FLAG WHETHER TO GET GMT FROM SUP (ONLY IF
				:=0), IE ONLY AFTER CRASH/TAKEOVER.
NODSLC	WS	1		:SLOWC AT STARTUP
XYSAVE	WS	1		:SAVE AREA FOR CRYPTO/GMTCAL
SUPTIM	WS	1		:RAW GMT FROM SUP
SUPSLC	WS	1		:SLOWC EQUIVALENT OF SUPTIM

CNTXOR	HS	1		:FOR COUNT0/1 IN XRAY.
XQUEC	HS	1		:CURRENT XRAY USER QUEUE
XQUEM	HS	1		:MASTER XRAY USER QUEUE
XNINT	BS	10		:XRAY USER SLOT NO. BY INTERNAL HOST PORT NO.

BFZPRS	HS	20		:REG SAVE AREA FOR BUFFER ZAP ROUTINE (BUFZAP)

::*********************************************************************
::
::	XRAY VARIABLES:
::
::*********************************************************************

BFLTHS	HS	8
BFLTHG	WS	8		:BUFFERLET USE HISTOGRAMS
BZAPCT	HS	1		:COUNT OF BUFFER ZAPS

EXPSSV	HS	1		:SAVE AREA FOR EXEPSW FOR TR COMMAND

XTDASC  hs      1                       :1 if doing ascii display (TA)
XTDESC  hs      1                       :1 if showing escaping (TE)
XTDATO  hs      1                       :1 if doing continous display (Y option
XTDCPT  HS      NXUBLK                  :last displayed for continous display
XTDLNZ  HS      NXUBLK                  :line display size (depends on mode)
XTDMSN  hs      NXUBLK

LOSEG0	HS	0	:END OF NODE CODE'S SHARE OF FIRST 16K OF SEG 0

	SUBTTL	DATA (SEGMENT 0 - Data Areas)

	SEG.(0)			:DATA SEGMENT 0 RESUMES HERE

:	NOTE: DATA AREAS DEFINED FROM HERE CANNOT BE ASSUMED TO
:	BE RX1 ADDRESSABLE.

::*********************************************************************
::
::	ATTENTION FLAGS:
::
::*********************************************************************

	GL	BEGZRO,FLAGS
BEGZRO	WS	0
NFLAGS	WS	0
	SYAD(NFLAGS)
FLAGS	WS	0
CRQFLG	WS	1		:ALL SAVE LO-ORD BIT UNUSED
LEPFLG	HS	1		:LEPRECHAUN FLAGS
INTFLG	HS	1		:INTERNAL HOST FLAGS
KERFLG	WS	(NKU+1F)/20	:KERNEL PORT FLAGS (1/PORT)
SUPFLG	WS	NSP/20		:SUP FLAGS (1/PORT)
DISFLG	WS	(NDP+1F)/20	:DISPATCHER FLAGS (1/PORT)
MNCFLG	WS	(NMNCC+1F)/20	:MNCTAB Flags (1/Port)			###ev
LNKFLG	WS	TCHANS/20	:LINK CHANNEL ATTN FLAGS (1/CHAN)
ILCFLG	WS	1		:ILC FLAGS (1/LINK)
BPMFLG	WS	1		:BPM FLAGS (1/LINK)
DETFLG	WS	1		:DETACHED PORTS
ENDFLG	HS	0		:LAST FLAG ADDR+1

::*********************************************************************
::
::	aaaZFL:	Absolute channel numbers corresponding to processes'
::		relative channel 0.
::
::*********************************************************************

CRQZFL	EQ	(CRQFLG-NFLAGS)*8+1F	:CRQ.
STUBFL	EQ	CRQZFL-1		:Circuit stub in process of rebild.
INCPFL	EQ	STUBFL-1		:Circuits in intercept state (see CRQ)
EARLFL	EQ	INCPFL-1		:Early data from??? T-I z-flag.
ILCZFL	EQ	(ILCFLG-NFLAGS)*8	:Interlink control
BPMZFL	EQ	(BPMFLG-NFLAGS)*8	:Backpressure monitor
LEPZFL	EQ	(LEPFLG-NFLAGS)*8	:Leprechaun
KERZFL	EQ	(KERFLG-NFLAGS)*8	:Kernel
SUPZFL	EQ	(SUPFLG-NFLAGS)*8	:Supervisor
DISZFL	EQ	(DISFLG-NFLAGS)*8	:Dispatcher
	SYAD(DISZFL)
INTZFL	EQ	(INTFLG-NFLAGS)*8	:Internal host ports
MNCZFL	EQ	(MNCFLG-NFLAGS)*8	:M-Ring first port		###ev
LNKZFL	EQ	(LNKFLG-NFLAGS)*8	:Links
LNKLFL	EQ	LNKZFL+TCHANS	 	:Last link flag + 1
DETZFL	EQ	(DETFLG-NFLAGS)*8	:Detached ports
ENDZFL	EQ	(ENDFLG-NFLAGS)*8	:Last flag +1

::	ACP:	ACTIVE PORTS
::		ACtive-Port bit array, corresponds exactly to the node's
::		absolute channel numbers.  A set (1) bit means a port
::		(channel) is available.  A reset (0) bit means the channel
::		is in use.  Note that the negative portion of the ACP array
::		(from ACPBQE to ACP) is a mirror image of the positive
::		portion of ACP.  Negative ACP is used for top-down channel
::		assignment on T-II links on which we are the master.

ACPBSE	WS	0		:The bottom (lower limit) of negative ACP.
	SYAD(ACPBSE)
	WS	3		:DET, BPM, ILC
	WS	TCHANS/20	:NEGATIVE MIRROR OF LNKACP
EKNACP	WS	0		:End of link portion of negative ACP.
	WS	(NMNCC+1F)/20	:MNC ports (neg range for compatibility)
	WS	(NDP+1F)/20
	WS	NSP/20
	WS	(NKU+1F)/20
	WS	2		:CRQ, LEP, INT HST
ACPSZN	EQ	.-ACPBSE	:Size of negative ACP (must = ACPSZP).

ACP	WS	0		:Start of positive ACP.
	SYAD(ACP   )
CRQACP	WS	1		:CRQ (unused).
LEPACP	HS	1		:Leprechaun.
INTACP	HS	1		:Internal host.
KERACP	WS	(NKU+1F)/20	:Kernel
SUPACP	WS	NSP/20		:Supervisor
DISACP	WS	(NDP+1F)/20	:Dispatcher (ISIS only)
MNCACP	WS	(NMNCC+1F)/20	:M-Ring permuter table (MNCTAB) ports	###ev
LNKACP	WS	TCHANS/20	:Link channels
ILCACP	WS	1		:Inter-link control (unused)
BPMACP	WS	1		:BPM??? (unused)
DETACP	WS	1		:Detached ports
ACPSZP	EQ	.-ACP		:Size of positive ACP (must = ACPSZN)

	IF	ACPSZN%ACPSZP
	REMARK	%!!ACP ALLOCATION ERROR!!%
	KILLER(1)		:kill assembly
	EI 	:ACPSZN%ACPSZP

::	CHS:	CHANNEL SUSPENDED ARRAY
::		CHannel-Suspended bit array.  Same structure as ACP
::		(positive and negative portions, a bit for each channel,
::		0-bit means channel suspended).  A channel is temporarily
::		suspended to allow a recent zapper to clear a circuit.
::		A link channel is considered available only if its ACP and
::		CHS bits are set.  SWITCH initialization expects CHS to
::		follow ACP.

CHSBSE	WS	0		:Bottom of negative CHS
	WS	3		:DET, BPM, ILC
	WS	TCHANS/20
EKNCHS	WS	0		:Top of links' negative CHS
	WS	(NMNCC+1F)/20	:M-ring channels			###ev
	WS	(NDP+1F)/20
	WS	NSP/20
	WS	(NKU+1F)/20
	WS	2		:LEP, INTERNAL HOST
CHS	WS	0		:Beginning of positive CHS
	SYAD(CHS   )		:ORIGIN OF CHS ARRAY
	WS	2		:LEP, INTERNAL HOST
KERCHS	WS	(NKU+1F)/20	:KERNEL
	WS	NSP/20		:SUPERVISOR
	WS	(NDP+1F)/20	:DISPATCHER
	WS	(NMNCC+1F)/20	:M-Ring channels			###ev
LNKCHS	WS	TCHANS/20	:LINKS
	WS	3		:ILC, BPM, DET

:       CHSRVD and LNKBPV must be in seg 0 since their addresses are stored as
:       halfwords in several places.
LNKBPV	WS	TCHANS/20	:RCVD BACK-PRESSURE RELIEF (ENABLE SERVICE)
CHSRVD	WS	TCHANS/20	:CHANNEL SERVICED FLAGS (1/CHAN)


	IF	T2GATE
	IF	INTACC
MNACHN	EQ	INTZFL
	ELSE	:NOT INTACC
MNACHN	EQ	DISZFL		:Dispacher zero port flag
	EI	:INTACC
MXACHN	EQ	MNACHN+NACCTS	:Highest accountable  channel number
	ELSE	:NOT T2GATE
	IF	ACCT!INTACC  		:###EV
:	Accounting parameters  - Minimum and Maximum channel numbers
MNACHN	EQ	INTZFL		:INTZFL is always first accountable ch
MXACHN	EQ	MNACHN+NACCTS	:Highest accountable  channel number
	EI	:ACC!INTACC		###EV
	EI	:T2GATE



::*********************************************************************
::
::	SWITCH VARIABLES:
::
::*********************************************************************


CDSC	BS	NRECDS*CDSZ	:Packet record descriptors


:	Data structures for buffer delay timer pairs
	IF	BFLTMR		:###JHL
BFDARY	WS	TCHANS/20	:a bit for each link channel
BFDEND	HS	0		:end marker for COPY instruction
BFDSCH	HS	1		:EXEC cell for scheduling from G08SEC
BFDFRQ	EQ	4		:# times G08SEC runs per sched of BFRUPD
BFDOPT	HS	1		:cell to select bfr timer use in XRAY
	EI	:BFLTMR		:###jhl
:::
	IF	SIORNG
DWSISV	HS	6		:CONTEXT SAVE FOR SIO DLD DISMISS
	EI 	:SIORNG

:	DEFINE WORK AREAS ASSOCIATED WITH NEEDLE TIMING
	DEFAULT(NEDTSZ,RATE/4)	:DEFAULT SIZE OF NEEDLE TIME HISTOGRAM - ALLOW
				: FOR UP TO 1 SECOND, RECORDED IN FASTC/4 UNITS
NEDHST	HS	NEDTSZ/2	:NEEDLE TIME HISTOGRAM
        SYAD(NEDHST)

KERUSR	BS	40		:USER NAME STRING OF LAST KERNEL LOGIN
        SYAD(KERUSR)

	if	1-alhub
XUBLK	BS	XUBSZ*NXUBLK	:XRAY USER BLOCK AREA
	SYAD(XUBLK )
	ei



:	STORAGE AREA FOR ISIS-STYLE TRAPS
        IF      1-\NTRAP
NTRAP   EQ      4
        EI

        WS      0
TRPREG	WS	10*NTRAP	:SAVE AREA FOR TRAP REGISTERS
TRPPSW	WS	2		:how to return from a sprung trap
TRPADR	WS	NTRAP		:FOR TRAP PC
TRPXD	WS	NTRAP		:TRAP OWNER
TRPSAV	WS	2*NTRAP		:FOR CLOBBERED MEMORY
TRPTIM  WS      NTRAP           :time of trap springing
TRPCNT  HS      NTRAP           :how many springs left
TRPFLG	HS	1		:AND FOR TRAP SPRUNG INDICATION



XPWRCT	HS	1		:TIMEOUT CELL FOR ACCESS CONTROL

	IF	EXPNDL
SNFGSV	WS	1		:holds ptr to B6-hdr for DSINDY
	EI	:EXPNDL

DBCRSV	WS	2


        SUBTTL	DATA (SEGMENT 1 START AND TEXT AREA)

::*****************************************************************
::
::      SEGMENT 1 - CODE and TEXT
::
::*****************************************************************

	SEG	1		:SEGMENT 1 DATA BEGINS HERE
	ORG	10000
SEG1	HS	0

VERSSV	WC	VERSION		:VERSION # ALWAYS AT 10000
CRACTN	HC	CRSTOP		:CRASH STOP OPTION

	IF	DB.CPU
CPUTLB	HC	0
	ORG	.+(CPUTMX*7)+1
	EI	:DB.CPU

::*********************************************************************
::
::	FAIL:	RESTART SVC FOR NODE
::
::*********************************************************************

FAIL	WS	2			:PSW
	WS	2			:R0,R1
	STH	R1,CRSHID		:SAVE CRASH CODE
	SIS	R1,1			:IF POWER UP OR MANUAL RESTART, 
	JLE	NSTART			: INIT NODE WITHOUT SAVING REGS, ETC...
	TS	CRTYPE			:INDICATE NOT OOPS CRASH
	L	R1,FAIL+4		:SAVE CRASH ADDRESS
	ST	R1,CRSHAD		:AS SUPPLIED BY ISIS
	L	R1,FAIL			:CRASH PSW
	ST	R1,CRSHPS
	L	R0,FAIL+8		:SAVE REGISTERS
	L	R1,FAIL+0C
	J	SFAIL			:PROCEED AS USUAL
        GL      SFAIL

REBCEN	HC	REBILD			:REBUILD CONTROL CHARACTERS ENABLED
	SYAD(REBCEN)	
REBREN	HC	1			:REBUILD REQUESTS ENABLED
	SYAD(REBREN)	

::*********************************************************************
::
::	TABLE:		DETMTB:
::	FUNCTION:	CANNED DETACH MESSAGES
::
::*********************************************************************

	NOLIST
DETM00	SC	/"8A"8Ddestination node out of ports/
DETM01	SC	/"8A"8Dhost out of ports./	:NC DETECTED
DETM02	SC	/"8A"8Dhost out of ports!/	:SLOT DETECTED
DETM03	SC	/"8A"8Ddestination node out of kernel ports/
DETM04	SC	/"8A"8DKernel SIO ring interface down/
DETM05	SC	/"8A"8Dout of xray slots/
DETM06	SC	/"8A"8Dxray slot overridden/
DETM07	SC	/"8A"8DBAD XRAY USERNAME/
	IF	T2GATE
DTM08X	HC	DTM08L
DETM08	EQ	DTM08X+1
	AC	/inter-link cleared from /
	IF	NETNAM
	HNAME()
	ELSE
	AC	/HOME NETWORK/
	EI	:NETNAM
	AC	/ to /
	IF	NETNAM
	INAME()
	ELSE
	AC	/ISIS NETWORK/
	EI	:NETNAM
	AC	/"8D"8A/
DTM08L	EQ	.-DETM08-1
	EI	:T2GATE
	LIST

DETMTB  HC	DETM00-SEG1,DETM01-SEG1,DETM02-SEG1,DETM03-SEG1,DETM04-SEG1
	HC	DETM05-SEG1,DETM06-SEG1,DETM07-SEG1
	IF	T2GATE
	HC	DETM08-SEG1
	EI	:T2GATE

	SUBTTL	DATA (SEGMENTS 2 & 3 - Buffer Descriptors)

::*********************************************************************
::
::	SEGMENT 2 & 3 - Buffer Descriptors, DMA Region, and Link Tables
::
::*********************************************************************

	SEG.(2)
SEG2	HS	0
CRQBUF	EQ	0		:CRQ LIST BUFFER
LOGBUF	EQ	4		:LOGGER DITTO
NCCBUF	EQ	8		:TEMPORARY BUFFER WHEN NO COMMAND CIRCUIT
ILCZBF	EQ	10		:# OF ILC BUFF FOR LINK 0
BPMZBF	EQ	ILCZBF+8*NLINKS	:# OF BPM BUFF FOR SAME
CIRZBF	EQ	BPMZBF+8*NLINKS	:# OF FIRST AVAILABLE BUFFER
HBUFN	EQ	8*NCIRCS	:NUMBER OF FIRST HISTORY BUFFER
	SYAD(HBUFN )
LBUFN	EQ	0C*NCIRCS	:LAST LEGAL BUFF # (PLUS 4)

:	CHARACTER BUFFERS:
:	IF CONFIGURATION HAS REBILD ENABLED, THE NUMBER OF BUFFERS REQUIRED
:	IS 3*NCIRCS. IF REBILD = 0, ONLY 2*NCIRCS BUFFERS REQUIRED.

	IF	REBILD
BUFFAC	EQ	3
	ELSE	:NOT REBILD
BUFFAC	EQ	2
	EI 	:REBILD

BB	WS	BUFFAC*NCIRCS	:NEXT CHARACTER OUT PTR
	SYAD(BB    )
BE	WS	BUFFAC*NCIRCS	:LAST CHARACTER IN PTR
	SYAD(BE    )
BBSIZE  EQ      BE-BB
BF	WS	BUFFAC*NCIRCS	:ATTENTION FLAG POINTER
	SYAD(BF    )
BCT	EQ	BF+2		:BYTE COUNT (INTERLEAVED W/ BF)

BUFTIM	WS	NCIRCS		:USED TO TIME NEEDLES IN FASTC UNITS. WHEN
:	NEEDLE COMPLETES CIRCUIT BUILDING, BUFTIM WILL CONTAIN SLOWC
:	TIME THAT CIRCUIT BUILDING WAS COMPLETED. ALSO USED TO TIME
:	OUT PORTS IN LOGIN THAT HAVE SENT FROM TID UP TO BUT NOT
:	INCLUDING SEMI-: OR 'CR'.  AFTER THAT THE SUP TIMES THEM OUT.
:	ALSO USED TO TIME OUT DETACHED PORTS DUE TO OUR DISCOVERY OF
:	'OUT OF DISPATCHER PORTS', ...


:       bit of logic to handle large configs.  trouble is that sio dma region
:       is limited to 20000 (2 segs) so idea is to put as many records before
:       the sio stuff then put rest after that (and killing if it is still
:       too many records).  changes to initializing brec and attlin has to call
:       sioiz0 to reinit the line and sioiz0 sees where to set the dma window.

:       600 is a reasonable approx of what sio takes per line (actually
:       more like 540x, but might as leave room for growth).
        if      (nrecds*recbsz)+silins*600-20000
bigcon  eq      1               :we have the big config
        else
bigcon  eq      0
        ei

        if      bigcon
nrecd0  eq      (20000-silins*540)/recbsz       :records before sio
nrecd1  eq      nrecds-nrecd0                   :the rest
       if       nrecd1-(3*nrecd0)         :half the output has to be in 1st 1/2
        remark%%Too many windows declared for the number of sio lines.
        remark %Reduce by 
        number $A(NRECD1/3-NRECD0)/2
        remark  d.  Assembly killed.
        quit
       ei       :too big
        else    :not bigcon
nrecd0  eq      nrecds
        ei      :bigcon

        bnd     10              :for sio nocopy
RECBUF  BS      nrecd0*RECBSZ   :as many of the output buffers that fit
        HS      1               :so SIO doesn't have to copy for output

::*********************************************************************
::      SIBFRL forced to 1 and SIO is put right after the records so don't
::      have to copy from record to sio output area.  simply give the address
::      of the record buffer and insert the count and transmit from the the
::      record buffers.                                         ###sdw
::
::*********************************************************************
:       Macro defines SIO usage so FIN and here will always be the same
:       To change the SIO storage, change the value inside the macro###sdw

SIODF.  MACRO[

        BND     20              :QUAD WORD BOUNDARY
:	>>NOTE--FOLLOWING MUST NOT CROSS 100 BOUNDARY<<
:       A SIO output chain cannot cross 100 boundary, other stuff can
                                :before doing next.
Q       EQ      0
        RE      SILINS          :for each line
SOPG|Q| WS      8               :7 CCWS FOR HDLC INITIALIZATION
Q       EQ      Q+1
        ER      :SILINS
SIODUM  WS      4               :WILL CONTAIN DUMMY RECORD
:       note that are limited to one starline (or nakline) per machine
:       since these fields have values and if two or more lines tried
:       to do the same msg at same time then earlier msg gets clobered.
:       should be described for each line.                              ###sdw
	IF	RBTHUB		:###AL
STRRBT	WS	4		:WILL CONTAIN RMT-BOOT RECORD FOR STARLINE
STRRRS	WS	4		:WILL CONTAIN RMT-RESTART RECORD FOR STARLINE
	EI	:RBTHUB		:###AL
Q       EQ      0
        RE      SILINS
SIOD|Q| BS      10*NCHAIN                       :the chains for this line
Q       EQ      Q+1
        ER
SIOBLI  WS      4*SILINS        :CCW FOR INPUT
SIOBLR	WS	0C*SILINS	:for Expanded Reset
SIOSTT  WS      4*SILINS	:STATUS BLOCKS
        SYAD(SIOSTT)
SIDWCM	BS	10*SILINS	:SIO DWL CCW AREA
SIDWBF	BS	80*SILINS	:SIO DWL OUTPUT BUFFERS
SIBUF	BS	SIBFSZ*SILINS		:INPUT BUFFERS	###LSH
	SYAD(SIBUF )
SIOXQW	WS	4		:SIO MOTHER BOARD NEEDS EXTRA QUAD WORD###LSH
SIOEND	EQ	.		:END OF SIO DMA AREA

]                       :end of the standard SIO definition             ###sdw

       IF       SILINS
        SIODF.                          :define SIO storage
	EI	:SILINS			:###LSH

        if      bigcon                  :rest of the records
        bnd     10
recbu1  bs      nrecd1*recbsz           :rest of the records
        hs      1                       :for sio no copy
        ei      :bigcon

        if      silins                  :only if sio
        if      sioend-recbuf-20000     :sio isn't fitting
        remark%%Fatal Error.  Record buffers are not all within one
        remark%%SIO DMA region.  Serious code problem.  Please Panic.
        quit
        ei
        ei      :silins



:       general output rotor is set up to emulate the SIO CCWs.  the first
:       and third rotors are used for output.  The second and fourth rotors
:       are used to jump to the third and first rotors, respectively.  This
:       allows putting the output rotors (1,3) the same distance (16 bytes)
:       and linked the same as the SIO CCWs.  So the output logic can be
:       largely done without caring about sync and SIO.
        BND     10
OROTOR  BS      4*8*(NLINES-SILINS)     :general output rotor
SYDUMZ  EQ      8                       :size of a dummy record with cksum
SYNDUM  HS      4                       :place for dummy record
:::
SDSC	BS	NLINES*SDBSZ	:RESET DATA BUFFERS

:	buffers for sending downline load records and receiving the
:	echo from the neighbor
DWIBUF	BS	TINTCH*40	:DOWNLINE-LOAD BUFFERS - INPUT
DWOBUF	BS	TINTCH*42	:OUTPUT


::	Generate link descriptor block space for all link types		###ev
Q	EQ	0
KDSC	BS	0
	SYAD(KDSC  )
	RE	(NLINKS-1)		:For all except last link, allocate
	IF	\K.S|$A Q|
	BS	SKDSZ			:either starlink size
	ELSE	\T.OH|$A Q|
	BS	TNKDSZ			:or tunnel link size
	ELSE
	BS	KDSZ			:or regular TII link size.
	EI
Q	EQ	Q+1			:Next link please
	ER
KDLST	EQ	.			:Last link begins here
	IF	\K.S|$A Q|
	BS	SKDSZ
	ELSE	\T.OH|$A Q|
	BS	TNKDSZ
	ELSE
	BS	KDSZ
	EI


KNNLAT	HS	NLINKS			:USED BY LNCHCK TO DETERMINE MAX NUMBER
					:OF LINES PER LINK TO DETACH
RTPAGE	HS	NLINKS			:CHANNEL PAGE #'S
RMPAGE	HS	NLINKS
LKOVLD	HS	NLINKS			:LINK OVERLOAD COUNTERS
LKSTCT	HS	NLINKS			:LINK SATURATED COUNTERS
SNPTYP	HS	NLINKS			:LINK SNIP TYPE IF NON-ZERO
MASTKN	BS	NLINKS			:MASTER/SLAVE INDICATOR FOR T-II LINKS
LKZFKN	HS	NLINKS			:# OF CHANNEL 0 FLAG FOR EACH LINK
	SYAD(LKZFKN)
TBDPKN	HS	NLINKS+1		:START OF TABLES FOR EACH LINK (EXTRA
					:ONE NEEDED BY BUBBLE)
EBDPKN	HS	NLINKS			:END OF TABLES FOR EACH LINK
FLDPKN	HS	NLINKS			:START OF FLAGS FOR EACH LINK
LKFGND	HS	NLINKS			:PTR TO LAST HW OF ATTN FLAGS FOR LINK
LKSVND	HS	NLINKS			:PTR TO LAST HW OF SERVICE ARRAY
LKBPND	HS	NLINKS			:PTR TO LAST HW OF BACKPRESSURE ARRAY
LKAPND	HS	NLINKS			:PTR TO LAST HW OF ACTIVE PORT ARRAY
LKCSND	HS	NLINKS			:PTR TO LAST HW IN CHAN SUSP ARRAY
NUMPAG	HS	1			:NUMBER OF AVAILABLE HALF PAGES
LKNEDS	HS	NLINKS			:NO. OF TIMES NEEDLE GOBBLED BY ZAPPER

::	CHS1, CHS2:
::		are used to cause a suspended channel (CHS) to become
::		available 30-60 seconds after a zapper has traveled.  When
::		CHS is reset, CHS1 is set.  Every 30 seconds, CHS2 is OR'd
::		into CHS and CHS1 is copied into CHS2.  Same layout as CHS.

	WS	0		:ENSURE WORD ALIGNMENT
	BS	ACPSZP		:CORRESPOND TO NEGATIVE CHS
CHS1	HS	0		:Center (negative below here, positive above)
	BS	ACPSZP		:CORRESPOND TO POSITIVE CHS

	WS	0
	BS	ACPSZP
CHS2	HS	0		:Center (negative below here, positive above)
	BS	ACPSZP

BPSVCP	WS	TCHANS/20	:COPY OF RECEIVED BP FLAGS (UPDATE T-PUT COUNT)
PRIRTY	WS	TCHANS/20	:PRIORITY FLAGS
CMDCTS	WS	TCHANS/20	:COMMAND CIRCUITS
GUSH	WS	TCHANS/20	:SET FOR CHANNELS WITH DATA GUSHING IN
       if       1-notrik
TRIKLE	WS	TCHANS/20	:SET FOR CHANNELS WITH DATA TRICKLING
       ei       :1-notrik
EGUSH	EQ	GUSH+TCHANS/8
       if       1-notrik
ETRIKL	EQ	TRIKLE+TCHANS/8
       ei       :1-notrik

:	Misc. bit arrays indexed by channel number

TRCHAN	HS	ENDZFL/10	:ARRAY FOR CHARACTER TRACING BY CHANNEL
NEEDLE	HS	TCHANS/10	:ARRAY TO RECORD NEW NEEDLE ON LINK CHANNEL

	IF	REBILD
:
:	NOTE THAT THERE IS ONLY A SINGLE 'SEQN' ARRAY, AND THE 'XSEQN',
:	'VSEQN' AND 'HSEQN' REDEFINITIONS ARE ONLY TO AVOID CONFUSION.
:
:	ALSO NOTE THAT SEQN IS A FULL-WORD ARRAY, SINCE BUFFER-NUMBERS
:	ARE DIVISIBLE BY 4. HOWEVER, NO GOOD USE HAS BEEN FOUND FOR THE UPPER
:	HW SINCE SEQUENCE NUMBERS ARE HW VALUES. THIS STORAGE COULD BE
:	COMPRESSED AT THE EXPENSE OF FREQUENTLY DIVIDING BUFFER NUMBER BY 2 AND
:	THEN RESTORING.
SEQN	WS	3*NCIRCS	:CHARACTER SEQUENCE #
	SYAD(SEQN  )
XSEQN	EQ	SEQN		:REDEFINITION - XMITTED SEQUENCE NUMBER
VSEQN	EQ	SEQN		:REDEFINITION - RECEIVED SEQUENCE NUMBER
HSEQN	EQ	SEQN		:REDEFINITION - HISTORY BUFFER SEQ NUMBER
HBSEQN	EQ	HSEQN+HBUFN	:CONVENIENCE CONSTANT
XBF	EQ	6
HBF	EQ	7		:R6,R7 USED IN CRQREB, CRQINT CODE
				: SPLIT ACROSS BUFFERLET

:	REBUILDABLE TERMINATION VARIABLES:

RBASE	EQ	.-HBUFN		:DESTINATION BASE
	SYAD(RBASE )
RHOSTN	EQ	RBASE+2		:DESTINATION HOST
	SYAD(RHOSTN)
	WS	NCIRCS
RNFLAG	EQ	.-HBUFN		:NEEDLE FLAGS
	SYAD(RNFLAG)
RHBSZ	EQ	RNFLAG+2	:SIZE OF HISTORY BUFFER
	SYAD(RHBSZ )
	WS	NCIRCS
RINVC	EQ	.-HBUFN		:INVOICE NUMBER INDEXED BY BUFFER NUMBER
	WS	NCIRCS

RBIBUF	EQ	RBASE		:TEMPORARY USE BY CRQREB
	SYAD(RBIBUF)
RBVSEQ	EQ	RINVC		:					###GT
	SYAD(RBVSEQ)
RBHIS	EQ	RHOSTN		:HIST BFR ASSOCIATED WITH RBIBUF	###CY
	SYAD(RBHIS )
RBKEY	EQ	HSEQN		:INVOICE ASSOCIATED WTIH RBIBUF		###CY
	SYAD(RBKEY )
	EI 	:REBILD

	SUBTTL	DATA (SEGMENT 4 - KERNEL Communications)

::*********************************************************************
::
::	SEGMENT 4 - KERNEL Communication Area
::
::*********************************************************************

SEG4	HS	0

:	KERNEL COMMUNICATION AREA

KBASE	WS	0			: The base address for this stuff###wjl
KBSZL	EQ	6		:LOG2 OF KERNEL BUFFER SIZE
KBSZ	EQ	1^KBSZL		:SIZE OF KERNEL BUFFERS
KIB	BS	NKU*KBSZ	:KERNEL PORT INPUT BUFFERS
KOB	BS	NKU*KBSZ	:DITTO OUTPUT
	SYAD(KOB   )
NII	HS	NKU		:IN BUFF IN PTR
NMI	HS	NKU		:BETWEEN NII AND NIO
NOI	HS	NKU		:INBUFFER OUT PTR
NIO	HS	NKU		:OUTPUT BUFFER IN PTR
NOO	HS	NKU		:DITTO OUT PTR
KOF	WS	(NKU+1F)/20	:PORTS THAT HAVE CHARS FOR OUTPUT
NEWLOG	WS	(NKU+1F)/20	:NEW LOGIN FLAGS (1/PORT)
	SYAD(NEWLOG)

KQ	EQ	1		:POINTER OFFSET, DIFFERENT FOR ISIS
KBST	EQ	2*KBSZ-1	:FOR COMPUTING SPACE, DIFF FOR ISIS

:	ISIS Kernel

	IF	IKERNL
KBSZL	EQ	6		:LOG2 OF KERNEL BUFFER SIZE
KBSZ	EQ	1^KBSZL		:SIZE OF KERNEL BUFFERS


KOF	WS	(NKU+1F)/20	:PORTS THAT HAVE CHARS FOR OUTPUT
KOFF	WS	(NKU+1F)/20	:TO OVERRIDE BACKPRESSURE
KPARMS	WS	3		:PARAMETER AREA FOR LOGON/ZAP SVC
KRINGS	BS	NKU*(KBSZ+4)*2	:KERNEL RINGS AREA


:	DEFINE KERNEL RING STRUCTURE

Q	EQ	.		:REMEMBER WHERE WE ARE
	ORG 	0		:DEFINE KERNEL RING STRUCTURE
	BS	KBSZ		:OUTPUT RING (FROM KERNEL)
KOB	HS	0		:RING LABEL POINTS PAST END OF RING
NIO	HS	1		:OUT BUFF IN PTR (KERNEL INX)
NOO	HS	1		:OUT BUFF OUT PTR (NODE INX)
	BS	KBSZ		:INPUT RING (TO KERNEL)
KIB	HS	0		:RING LABEL POINTS PAST END OF RING
NII	HS	1		:IN BUFF IN PTR (NODE INX)
NOI	HS	1		:IN BUFF OUT PTR (KERNEL INX)
	ORG	Q		:GO BACK TO THE REAL WORLD
	WS	0


KQ	EQ	0		:POINTER OFFSET
KBST	EQ	KBSZ-1		:FOR COMPUTING BUFF SPACE

	EI 	:IKERNL

	SUBTTL	DATA (SEGMENT 5 - Supervisor Communication Area)

::*********************************************************************
::
::	SEGMENT 5 - Supervisor Communication Area
::
::*********************************************************************

      IF        SUPER           :ISIS supe shares in seg C now          ###sdw
        SEG.(0C)
      EI        :SUPER
SEG5	HS	0

:	SUPERVISOR COMMUNICATION AREA

	IF	SUPER

SUPBSZ	EQ	800		:SIZE OF SUP BUFFERS

	IF	SNRING		:AND IF SUPER
SIBPSZ	EQ	NSP*4+2
SOBPSZ	EQ	NSP*4+2
	IF	SIBPSZ-1FFE
SIBPSZ	EQ	1FFE		:SET THE UPPER LIMIT FOR RING SIZE
SOBPSZ	EQ	1FFE		:    TO ALLOW FOR MORE SUP PORTS   	###GT
	EI	:
SICSZ	EQ	10
SOCSZ	EQ	10

	WS	1		:RINGS START AFTER 1 WORD INTO SEGMENT!

SIBBSE	HS	0		:BASE OF SIB RING
	SYAD(SIBBSE)
	HS	SUPBSZ/2	:INPUT RING
SIB	HS	0
NISI	HS	1		:FILL INDEX FOR SIB
	SYAD(NISI  )
NOSI	HS	1		:EMPTY INDEX FOR SIB
	SYAD(NOSI  )

SOBBSE	HS	0		:BASE OF SOB RING
	SYAD(SOBBSE)
	HS	SUPBSZ/2	:OUTPUT RING
SOB	HS	0
NISO	HS	1		:FILL INDEX FOR SOB
	SYAD(NISO  )
NOSO	HS	1		:EMPTY INDEX FOR SOB
	SYAD(NOSO  )

SIBPBS	HS	0		:BASE OF SIBP RING
	SYAD(SIBPBS)
	HS	SIBPSZ/2	:BACKPRESSURE FROM NODE
SIBP	HS	0
NISIBP	HS	1		:FILL INDEX
	SYAD(NISIBP)
NOSIBP	HS	1		:EMPTY INDEX
	SYAD(NOSIBP)

SOBPBS	HS	0		:BASE OF SOBP RING
	SYAD(SOBPBS)
	HS	SOBPSZ/2	:BACKPRESSURE SET BY SUPERVISOR
SOBP	HS	0
NISOBP	HS	1		:FILL INDEX
NOSOBP	HS	1		:EMPTY INDEX


SICBSE	HS	0		:BASE OF SIC RING
	HS	SICSZ/2		:INPUT CONTROL RING
SIC	HS	0
NISIC	HS	1		:FILL INDEX
	SYAD(NISIC )
NOSIC	HS	1		:EMPTY INDEX
	SYAD(NOSIC )

SOCBSE	HS	0		:BASE OF SOC RING
	SYAD(SOCBSE)
	HS	SOCSZ/2		:OUTPUT CONTROL RING
SOC	HS	0
NISOC	HS	1		:FILL INDEX
	SYAD(NISOC )
NOSOC	HS	1		:EMPTY INDEX
	SYAD(NOSOC )

	ELSE	:NOT SNRING AND IF SUPER
SIB	BS	SUPBSZ		:SUP INPUT BUFFER
SOB	BS	SUPBSZ		:SUP OUTPUT BUFFER
NISI	HS	1		:IN PTR FOR SUP INPUT (NODE-INDEXED)
NOSI	HS	1		:OUT DITTO (SUP-INDEXED)
NISO	HS	1		:IN PTR FOR SUP OUTPUT (SUP-INDEXED)
	SYAD(NISO  )
NOSO	HS	1		:GUESS (NODE-INDEXED)
	SYAD(NOSO  )
SBUFS	HS	1		:ABSOLUTE CHAN # OF SUP CH 0
NODINF	HS	1		:SUPERVISOR STATE FLGA (1=SLEEP)
SUPBPV	WS	NSP/20		:SUP RESETS THESE TO STOP INPUT
SUPBPX	WS	NSP/20		:NODE RESETS THESE TO STOP OUTPUT
NODFRZ	HS	1		:IF NONZERO, FREEZE NODE
	EI 	:(NOT)SNRING

        SEG.(2)                 :                                       ###SDW
	EI 	:SUPER

	SUBTTL	DATA (SEGMENTS 6,7,8,9 - IOTAB and Bufferlets)

::*********************************************************************
::
::	SEGMENT 6,7,8,9 - BULK STORAGE (BUFFERLETS AND IOTAB)
::
::*********************************************************************

SEG6	HS	0

:	PERMUTER TABLES AND CHARACTER BUFFERLETS:

:	THESE MUST CORRESPOND EXACTLY TO THE ATTENTION FLAGS DEFINED
:	PREVIOUSLY.

IOTAB	HS	20			:NOTE FIRST 20 CHANNS UNUSED
	SYAD(IOTAB )
LIOTAB	HS	10			:LEPRECHAUN PERMUTER TABLE
INTTAB	HS	10			:INTERNAL HOST PERMUTER TABLE
KIOTAB	HS	((NKU+1F)/20)*20	:KERNEL PERMUTER TABLE
SIOTAB	HS	NSP			:SUPER PERMUTER TABLE
DIOTAB	HS	((NDP+1F)/20)*20	:DISPATCHER PERMUTER TABLE
MNCTAB	HS	((NMNCC+1F)/20)*20	:Multi-NodeCode Permuter Table	###ev
NIOTAB	HS	TCHANS			:LINK PERMUTER TABLES
	SYAD(NIOTAB)
IIOTAB	HS	20			:ILC PERMUTER TABLES
BIOTAB	HS	20			:BPM PERMUTER TABLES
CIOTAB	HS	20			:DETACHED CIRCUITS

BPSCNT	HS	TCHANS			:LINK BACK PRESSURE COUNTERS
	SYAD(BPSCNT)

HISTBF	BS	HISTSZ			:HISTORY BUFFER
	IF	T2GATE
GDLGTB	HS	NDP		:Dummy permuter table for Gateway log-ins
GLGCNT	BS	NDP             :Log on char count storage I-net to H-net
	EI	:T2GATE

DLYBSE	HS	DLYBSZ*TINTCH/2	:START OF DATA BLOCKS FOR DELAY MEASUREMENT

:	DEFINE RINGS FOR NODE<-->ISIS DISPATCHER COMMUNICATIONS

DIRING	WS	0		:Dispatcher input ring (node==>ISIS).
	SYAD(DIRING)		: Structure required by ISIS.
DRIF	HS	1		:Fill index (node indexed)
DRIE	HS	1		:Empty index (ISIS indexed)
DIRNG	BS	DRSZ		:The ring itself

DORING	WS	0		:Dispatcher output ring (ISIS==>node).
	SYAD(DORING)		: Structure required by ISIS.
DROF	HS	1		:Fill index (ISIS indexed)
DROE	HS	1		:Empty index (node indexed)
DORNG	BS	DRSZ		:The ring itself

DHSTIX	HS	NDP		:Host # associated with each Dispatcher port
	SYAD(DHSTIX)


	if	alhub
XUBLK	BS	XUBSZ*NXUBLK	:XRAY USER BLOCK AREA
	SYAD(XUBLK )
	ei

LDNEVT  EQ      9               :9 table entries (see LDERTB in Linker)  ###sdw

LDTIME	WS	0
Q	EQ	0
	RE	LDNEVT
LDTIM|Q| WS	NLINES		:ONE LDTIMx ARRAY PER EVENT
Q	EQ	Q+1
	ER

       IF       LOGII
:       table into which parser puts info on each element
        HS      0               :ensure alignment
X4TBBG  BS      X4NENT*X4TBSZ   :store X.409 element info by parser
X4TBEN  HS      0               :end of table
        BS      X4TBSZ          :extra one for overflow

:       table for creating X.409 elements
        HS      0
X4CTBG  BS      X4NENT*X4CTSZ        :an entry for each element in contruction
       EI       :LOGII




	SUBTTL	DATA (SEGMENT B - SYNC Input rings)

::*********************************************************************
::
::	SEGMENT B - SYNC-LINE INPUT BUFFER
::
::*********************************************************************

SEGB	HS	0

:	DATA SEGMENT 'B' VARIABLES
SVNTIP	HS	1		:BUFFER INPUT POINTER
SVNTBF	BS	SVNBSZ		:SYNC-LINE INPUT BUFFER
	BS	(NLINES-1)*(2+SVNBSZ)

	IF	ACCT		:###EV

:: Storage allocation for accounting blocks

AABLKS	HS	0		:Beginning of block storage
	BS	NACCTS*AADSIZ	:# of accountable circuits times
				:size of each block (bytes)
AABLSZ	EQ	.-AABLKS	:Total block space allocated

	EI	:ACCT	###EV

	SUBTTL	DATA (SEGMENT C - Table Storage)

::*********************************************************************
::
::	SEGMENT C - Table Storage
::
::*********************************************************************

SEGC	HS	0

CRYPRB	WS	0		:CRYPTO BUFFER FOR PASSING MESSAGES TO XRAY
	BS	CRYPRS
CRYPSV	WS	0		:###LSH
	BS	CRYPRS		:SAVE AREA FOR CRYPTO (SAVED ON CRASH)
	SYAD(CRYPSV)

::	STORE PACKETS ON CRASH
      IF	PKTSAV		:					###wjl
PCKTSZ	EQ	NRECDS*RECBSZ	:THE SIZE OF ALL THE PACKETS		###LSH
PCKTSV	WS	0		:					###LSH
	BS	PCKTSZ		:SAVE AREA FOR PHYSICAL RECORD BUFFERS
	SYAD(PCKTSV)		:(SAVED ON CRASH)
      EI	:PKTSAV

	IF	SILINS
	DEFAULT(PKSVSZ,400)	:DEFAULTED 400X BYTES
PAKSAV	HS	0
	SYAD(PAKSAV)
	BS	PKSVSZ
	EI	:SILINS			:THE LAST WORD IS THE CALLER'S ADDR.

	DEFAULT(BUFZSZ,400)
BUFZSV	WS	0		:###LSH
	BS	BUFZSZ		:SAVE AREA FOR A BUFFER TO BE ZAPPED
	SYAD(BUFZSV)		:FOR DEBUGGING.
	IF	PRIMSG
CRYPPB	WS	0
	BS	CRYPPS
	EI	:PRIMSG
	IF	DB.TRC		:OPTION(UTRC) in Tymfile		###wjl
TRSTAB	WS	0		:JUMP TRACE TABLE - SAVED ON CRASH
	BS	TRTBSZ
	EI	:DB.TRC
TRRING	WS	0
	SYAD(TRRING)
	BS	TRRSIZ		:CHARACTER TRACE RING
TRIXSV	HS	1		:SAVE AREA FOR TRRIX (SAVED ON CRASH)
	SYAD(TRIXSV)
TRRSAV	WS	0
	BS	TRRSIZ		:SAME FOR TRRING
	SYAD(TRRSAV)
DIRSAV	HS	0
	BS	DRSZ+4		:DIRING...
DORSAV	HS	0
	BS	DRSZ+4		:AND DORING

::	DISPATCHER RINGS DUMP ROUTINE STORAGE AREAS	###wjl
:	-------------------------------------------
IRING	WS	0		:STORAGE FOR DIRING OR DIRSAV
	BS	DRSZ+4
ORING	WS	0		:STORAGE FOR DORING OR DORSAV
	BS	DRSZ+4


ABSSAV	WS	10		:SAVE AREA FOR DATA FROM ABSOLUTE MEMORY

RSEGC	HS	0	:SEGC INITED TO -1 UP TO THIS POINT, TO 0 AFTER HERE

	IF	DB.TRC		:OPTION(UTRC) in Tymfile		###wjl
TRSAVE	HS	6		:REG SAVE AREA FOR TRACE ROUTINE
TRCBEG	HS	2		:BEGINNING OF TRACE AREA
	SYAD(TRCBEG)
TRCEND	HS	2		:END OF TRACE AREA
TRCRFL	HS	1		:FLAG INDICATES IF PREVIOUS TABLE ENTRY WAS
				:IN RANGE (-1)
TRCRRQ	HS	1		:XRAY SETS TO -1 TO REQUEST SPECIAL TRACER
	SYAD(TRCRRQ)
TRNDEX  HS	1		:INDEX INTO TRACE TABLE
	SYAD(TRNDEX)
TRCTAB	BS	TRTBSZ
	SYAD(TRCTAB)
	EI	:DB.TRC

:	SUPERVISOR TRACE AREA:	>>MOVED FROM XHOSTS<<	###wjl

	IF	SIORNG
	IF	SNRING
	IF	SUPTRC

:	SIO RING TRACE TABLE ( 2X SUP RING SIZE)
:	FORMAT AS FOLLOWS -
:		N BYTES OF DATA
:		HW-BYTE COUNT OF DATA PRECEDING (N)
:		HW-FASTC MARK
:		HW-CHAN (OR 8000 - DATA TO BASE FROM SUP, OR 0000 - TO SUP)
SRNTBL	WS	SUPBSZ/2
SRNTSZ	EQ	.-SRNTBL		:BYTE SIZE OF SIO RING TRACE TABLE

:	SIO RING TRACE BYTE INDEX INTO SRNTBL
:	POINTS TO NEXT FREE ENTRY, WRAPS AT TABLE END
SRNTRX	HS	1

SRNSEC	HS	1			:SS COMMAND (0 = DISABLE, <>0 = ENABLE)
	SYAD(SRNSEC)

SRNSAV	WS	3			:SAVE AREA FOR SIO RING TRACE ROUTINE

:	BIT ARRAY FOR SUP PORT TRACE ENAB/DISAB (1/0)
:	IF BIT SET FOR THIS SUP PORT MAKE TRACE ENTRY
SRNTRE	WS	NSP/20
SRNBT1	EQ	.-SRNTRE		:SIZE OF SRNTRE ARRAY

:	BIT ARRAY FOR SUP PORT PRINT ENAB/DISAB (0/1)
:	IF BIT RESET FOR THIS SUP PORT DISPLAY ENTRY
SRNTRP	WS	NSP/20
SRNBT2	EQ	.-SRNTRP	:SIZE OF SRNTRP ARRAY
SRNBTZ	EQ	(.-SRNTRE)/2	:SIZE IN HW, FOR CLEARING BIT ARRAYS AT START

:	INPUT/OUTPUT MESSAGE TYPE CHECK BITS, 0=TRACE,
:	1=NO ENTRY, USED TO PARSE SUPIN/SUPOUT DATA.
SRNICK	WS	1
SRNOCK	WS	1

SRNCKN	EQ	20		:ALLOW THIS MANY INPUT/OUTPUT MESSAGE TYPES

	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	IF	TUNL		:					###cwc
TNOLDB	WS	(NMTNLS+1F)/20	:bit array indexed by tunnel#, if 1, the link
	:is a tunl and should be built, 0 otherwise. It is set initially as
	:configured for only dedicated tunnel, then a backup is set when 'OT'
	:in Xray is given and reset as 'CT' is done
TNWZSP	HS	NMTNLS		:array of backup tunl window-size and speed
TIWZSP	HS	NLINKS		:reserved for tii links' wsiz,sped 
				:<to be revised>
	EI	:TUNL							###cwc

:	THE STORAGE FOR THE DEBUGGER		###LSH

HSUMRK	EQ	0BBBB		:HISTORY RING MARKER

	DEFAULT(LNFSIZ,400)	:DEFAULT RING SIZE FOR NON-SOLO CONSAT
	DEFAULT(CBZSIZ,800)	:DEFAULT RING SIZE
	DEFAULT(BFSSIZ,800)	:DEFAULT RING SIZE
	DEFAULT(LPGSIZ,800)	:DEFAULT RING SIZE
	DEFAULT(LNKSIZ,1000)	:DEFAULT (extra big for interesting packets)

SAVSIZ	EQ	LNFSIZ		:DEFINE SAVSIZ AS THE LARGEST SIZE
	IF	CBZSIZ-SAVSIZ	:IF CBZSIZ IS BIGGER
SAVSIZ	EQ	CBZSIZ		:SAVSIZ = CBZSIZ
	EI
	IF	BFSSIZ-SAVSIZ	:IF BFSSIZ IS BIGGER
SAVSIZ	EQ	BFSSIZ		:SAVSIZ = BFSSIZ
	EI	
	IF	LPGSIZ-SAVSIZ	:IF LPGSIZ IS BIGGER
SAVSIZ	EQ	LPGSIZ		:SAVSIZ = LPGSIZ
	EI	
	IF	LNKSIZ-SAVSIZ	:IF LNKSIZ IS BIGGER
SAVSIZ	EQ	LNKSIZ		:SAVSIZ = LNKSIZ
	EI	
	

	IF	LNFDBG		:LOGON/LOGOFF DEBUGGER
LNFPTR	HS	1		:RING POINTER
	SYAD(LNFPTR)
LNFHST	BS	LNFSIZ		:LOGON/LOGOFF HISTORY RING
	SYAD(LNFHST)
	EI	:LNFDBG

	IF	CBZDBG		:CIRCUIT BUILDING/ZAPPING DEBUGGER
CBZPTR	HS	1		:RING POINTER
	SYAD(CBZPTR)
CBZHST	BS	CBZSIZ		:CIRCUIT BUILDING/ZAPPING HISTORY RING
	SYAD(CBZHST)
	EI	:CBZDBG

	IF	BFSDBG		:BUFFER STRUCTURE DEBUGGER
BFSPTR	HS	1		:RING POINTER
	SYAD(BFSPTR)
BFSHST	BS	BFSSIZ		:BUFFER STRUCTURE HISTORY RING
	SYAD(BFSHST)
	EI	:BFSDBG

	IF	LPGDBG		:LEP/LOGGER DEBUGGER
LPGPTR	HS	1		:RING POINTER
	SYAD(LPGPTR)
LPGHST	BS	LPGSIZ		:LEP/LOGGER HISTORY RING
	SYAD(LPGHST)
	EI	:LPGDBG

	IF	LNKDBG		:LINE/LINK DEBUGGER
LNKPTR	HS	1		:RING POINTER
	SYAD(LNKPTR)
LNKHST	BS	LNKSIZ		:LINK/LINE HISTORY RING
	SYAD(LNKHST)
	EI	:LNKDBG


	IF	DBGON		:IF ANY DEBUGGER OPTION ON
SAVHST	BS	SAVSIZ		:TEMP. STORE THE DATA FROM A RING TO
	EI	:DBGON

       IF       XRYRMK          :histogram of packetsizes               ###SDW
XRMKNE  HS      1               :neighbor to monitor
XRMKHS  HS      $A128/2*4       :
      EI        :XRYRMK

:	THE END OF STORAGE FOR DEBUGGER		###LSH

DEFAULT(SWITIM,0)		:SWITCH MAX PROCESS TIME debug switch	###wjl 
	IF	SWITIM		:					###wjl
PSVHWM	HS	20		:save area for PROHWM, saved at wrap time##wjl
	SYAD(PSVHWM)		:					###wjl
	EI	:SWITIM		:					###wjl

SCEND	HS	0

:	Bufferlet Area
        ORG     (./CBSZ)*CBSZ+CBSZ
        HS      1
CHRBUF  HS      0
        SYAD(CHRBUF)

	SUBTTL	DATA (SEGMENT 0D)

::*****************************************************************
::
::      TEXT is collected here to make it easier to find the label
::           connected to the text and reduce the need for RX3 jumps
::           by routines having to jump over text blocks.       ###sdw
::
::*****************************************************************

        SEG	0D		:put text in segment with some free room###sdw

EXMG1	SC	/"8D"8Aplease see your representative"8D"8Aif you are having trouble logging in/
EXMG2	SC	/"8D"8Abad mud/
EXMG3	SC	/"8D"8Acircuits busy/
EXMG4	SC	/"8D"8Ahost not available thru net/
EXMG5	SC	/"8D"8Ahost out of ports/
EXMG6	SC	/"8D"8Ahost down/
EXMG7	SC	/"8D"8Ahost shut/
EXMG8	SC	/"8D"8Atry again in 2 minutes/
EXMG9	SC	/"8D"8Aaccess not permitted/
EXMG10	SC	/"8D"8Ano host specified/
EXMG11	SC	/"8D"8Abad host number/
EXMG12	SC	/"8D"8Amud error/
	IF	T2GATE
EXMGDL  HC      XMGDL
EXMG13	EQ	EXMGDL+1
	AC	/"8D"8Aplease see your representative/
	AC	/"8D"8Aif you are having trouble logging in/
	AC	/"8D"8Ainter-link cleared from /
QQQ     EQ      0                       :assume not ISISN
Q       EQ      .
        ORG     Q-1
        IF      \ISISN
QQQ     EQ      1                       :ISISN true so make NETNAM true
QQ      EQ      .
        ORG     Q-1
        BC      0
        ORG     Q-1
        BC      A0                      :make a SC string look like a AC
        ORG     QQ
	ELSE
        ORG     Q                       :no worry about SC that should be AC
        IF      NETNAM
        INAME()
        ELSE    :NETNAME
	AC	/ISIS NETWORK/
	EI	:NETNAM
        EI      :ISISN
	AC	/ to /
Q       EQ      .
        IF      \HOMEN
        ORG     Q-1
        BC      0
        ORG     Q-1
        BC      A0                      :make a SC string look like a AC
        ORG     QQ
	ELSE
        ORG     Q                       :no worry about SC that should be AC
        IF      NETNAM
        HNAME()
        ELSE    :NETNAME
	AC	/HOME NETWORK/
	EI	:NETNAM
        EI      :HOMEN
	AC	/"8D"8A/
XMGDL	EQ	.-EXMG13-1
        IF      QQQ                     :was ISISN defined?
NETNAM  EQ      1                       :if so then we have netnames
        EI      :QQQ
	EI	:T2GATE

EXLGTB	HS	0		:LOOK UP TABLE
Q	EQ	1		:START AT 1
	RE	$A 12
	HC	EXMG|$AQ|-SEGD  :put in SEG D 9/27/87                   ###sdw
Q	EQ	Q+1
	ER

	IF	1-INFLGT
:	THE FOLLOWING MESSAGE INCLUDES A SUPER HANG, AND A HANG
PSRMSG	SC	/"03"12"12"8D"8Aplease see your representative"8D"8Aif you are having trouble logging in"03"12"11/
	EI	:1-INFLGT

	IF	T2GATE
::Address tables for Log-on response messages to callers for Gateway

LSMS27	WC	LSMS0	:08 - Continue
	WC	LSMS12	:09 - P.L.I.
	WC	LSMS22	:0A - error, type username
	WC	LSMS32	:0B - error, type password
	WC	LSMS42	:0C - user name
	WC	LSMS52	:0D - password
	WC	LSMS0	:0E - 
	WC	LSMS0	:0F - 
	WC	LSMS0	:10 - send Sup specified string
	WC	LSMS0	:11 - 
	WC	LSMS0	:12 - 
	WC	EXMG13	:13 - please se your rep.
	WC	EXMG2	:14 - bad mud
	WC	EXMG3	:15 - circuits busy
	WC	EXMG4	:16 - host not avail thru net
	WC	EXMG5	:17 - host out of ports
	WC	EXMG6	:18 - host down
	WC	EXMG7	:19 - host shut
	WC	EXMG8	:1A - try again
	WC	EXMG9	:1B - access not permitted
	WC	EXMG10	:1C - no host specified
	WC	EXMG11	:1D - bad host number
	WC	EXMG12	:1E - mud error
LSMSZ	EQ	.-LSMS27
::The Ascii table is below
LSMS	WC	LSMS0,LSMS1,LSMS2,LSMS3,LSMS4,LSMS5,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG13,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::The Half Duplex table is below
LSMSH	WC	LSMS0,LSMS1,LSMS2,LSMSC,LSMS4,LSMSE,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG13,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
LSMSTZ	EQ	.-LSMS27
::Same tables as above except for transparent Log-ons
LSM27T	WC	LSMS0,LSMS1T,LSMS2T,LSMS32,LSMS4T,LSMS52,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG1,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::Ascii
LSMST	WC	LSMS0,LSMS1T,LSMS2T,LSMS3,LSMS4T,LSMS5,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG1,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::Half Duplex
LSMSHT	WC	LSMS0,LSMS1T,LSMS2T,LSMSC,LSMS4T,LSMSE,LSMS0,LSMS0
	WC	LSMS0,LSMS0,LSMS0,EXMG1,EXMG2,EXMG3,EXMG4,EXMG5
	WC	EXMG6,EXMG7,EXMG8,EXMG9,EXMG10,EXMG11,EXMG12
::End of address tables for log-on responses from Supervisor
LSMS0	BC	0;
	HS	0
LSMS12	SC	/please log in: "05/;
LSMS22	SC	/error, type user name: "05/;


	HC	ZMS32
LSMS32	EQ	.-1
	AC	/error, type password: /
	AC	/###############"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/+++++++++++++++"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/OOOOOOOOOOOOOOO"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
        AC      /"05/
ZMS32	EQ	.-LSMS32-1;

LSMS42	SC	/user name: "05/;

	HC	ZMS52
LSMS52	EQ	.-1
	AC	/password: /
	AC	/###############"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/+++++++++++++++"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
	AC	/OOOOOOOOOOOOOOO"88"88"88"88"88"88"88"88"88"88"88"88"88"88"88/
        AC      /"05/
ZMS52	EQ	.-LSMS52-1;

	IF	NETNAM
	HS	0
I.NAME(ISISN)			:PRIMARY ISIS NET NAME;
	HS	0
H.NAME(HOMEN)			:SECONDARY HOME NET NAME;
	ELSE	:NETNAM NOT DEFINED, DEFAULT NAMES
	HS	0
ISISN	SC	/ISIS NETWORK/	:PRIMARY ISIS NET NAME;
	HS	0
HOMEN	SC	/HOME NETWORK/	:SECONDARY HOME NET NAME;
	EI	:NETNAM
	HS	0


:       text msgs for failed logon attempt
:       the third field is used to set a bit in the appropiate array

.LGTXT(LTX000,please log in: )
.LGTXT(LTX001,username: )
.LGTXT(LTX002,error"2C type username: )
.LGTXT(LTX003,password: )
.LGTXT(LTX004,error"2C type password: )

LSMS1   EQ      LTX000                  :equate log I msgs to same LOG II msg
LSMS2   EQ      LTX002                  :error type uname
LSMS3   EQ      LTX004                  :error type password
LSMS4   EQ      LTX001                  :username
LSMS5   EQ      LTX003                  :password


.LGTXT(LTX0T0,circuit cleared)          :transparent not allowed
.LGTXT(LTX0T1,username missing)
.LGTXT(LTX0T2,bad user name)
.LGTXT(LTX0H3,"8D"8Apassword:"8d"8a"ff###############"8D+++++++++++++++"8DOOOOOOOOOOOOOOO"8D)
.LGTXT(LTX0H4,"8D"8Aerror"2C type password:"8d"8a"0ff###############"8D+++++++++++++++"8DOOOOOOOOOOOOOOO"8D)

LSMS1T  EQ      LTX0T0                  :circuit cleared msg
LSMS2T  EQ      LTX0T2                  :bad user name
LSMS4T  EQ      LTX0T1                  :username missing
LSMSE   EQ      LTX0H3                  :HDX text
LSMSC   EQ      LTX0H4                  :HDX text

       IF       LOGII                   :only for LOG II gateway

:       text msgs for node code reject logon 
.LGTXT(LTX100,"8D"8AGateway internal error type 24"5C00)
.LGTXT(LTX101,"8D"8AGateway internal error type 24"5C01)
.LGTXT(LTX102,"8D"8AGateway internal error type 24"5C02)

       EI       :LOG II

.LGTXT(LTX103,"8d"8Ainter"2Dlink lost"2C please try again in a few minutes)

:       some of the general use text msgs
       IF       1-NETNAM        :if netname then these are already defined
.LGTXT(ISISN,ISIS NETWORK)
.LGTXT(HOMEN,HOME NETWORK)
       EI       :NETNAME
.LGTXT(TO, to )
.LGTXT(FROM, from )
.LGTXT(GNONET,"8D"8Aunable to complete inter"2Dlink...try again in a few minutes)
.LGTXT(GNETOK,"8D"8Ainter"2Dlink established)
.LGTXT(GNGONE,"8D"8Ainter"2Dlink cleared)


       EI       :T2GATE

	SUBTTL	DATA (SEGMENT E)

::*********************************************************************
::
::	SEGMENT E - Control Table Area (CTA)
::
::*********************************************************************

	SEG.(0E)
	ORG	0E0000
SEGE	HS	0

:	SEGMENT/SECTION PROTECTION BIT MASKS
P.ZERO	EQ	0	:SECTION not present
P.EXEC	EQ	1	:execution access permitted
P.WRIT	EQ	2	:write access permitted
P.READ	EQ	4	:read allowed (required for others)

:	PROTECTION FOR EACH SECTION/SEGMENT
APROT0	EQ	P.READ!P.WRIT
APROT1	EQ	P.READ!P.EXEC
APROT2	EQ	P.READ!P.WRIT
APROT3	EQ	P.READ!P.WRIT
APROT4	EQ	P.READ!P.WRIT
APROT5	EQ	P.READ!P.WRIT
APROT6	EQ	P.READ!P.WRIT
APROT7	EQ	P.READ!P.WRIT
APROT8	EQ	P.READ!P.WRIT
APROT9	EQ	P.READ!P.WRIT
APROTA	EQ	P.READ!P.WRIT
APROTB	EQ	P.READ!P.WRIT
APROTC	EQ	P.READ!P.WRIT
APROTD	EQ	P.READ!P.EXEC

:	CONTROL TABLE AREA:
CTA	WS	0		:ISIS CONTROL TABLE AREA
DCNTRL	WC	CNTRL		:DISPATCHER CONTROL FLAGS
	WC	SESZ		:CTASIZE -SEGMENT '0E' SIZE
	GL	SESZ
	WC	S0SZ		:AREAS - SEGMENT SIZES
	GL	S0SZ
	WC	S1SZ
	GL	S1SZ
	WC	S2SZ
	GL	S2SZ
	WC	S3SZ
	GL	S3SZ
	WC	S4SZ
	GL	S4SZ
	WC	S5SZ		:NO LIMIT FOR ISIS SEG5##AL
	GL	S5SZ
	WC	S6SZ
	GL	S6SZ
	WC	S7SZ
	GL	S7SZ
	WC	S8SZ
	GL	S8SZ
	WC	S9SZ
	GL	S9SZ
	WC	SASZ
	GL	SASZ
	WC	SBSZ
	GL	SBSZ
       IF       SUPER           :supe shared mem doesn't use this
        WC      0               :we don't use our memory for the shared mem
       ELSE     :not SUPER
	WC	SCSZ
	GL	SCSZ
       EI       :SUPER
	WC	SDSZ
	GL	SDSZ
	HC	0E		:NPROT - count of usable protection bytes
	BC	APROT0,APROT1,APROT2,APROT3 :PROT - memory protection
	BC	APROT4,APROT5,APROT6,APROT7
	BC	APROT8,APROT9,APROTA,APROTB
	BC	APROTC,APROTD
ISTART	WC	NSTART		:job execution start address
	GL	NSTART
DSTART	WC	XRAY		:DDT execution start address
	GL	XRAY
	WC	CONSOL+2	:STATUS - pointer to front-panel display cell
GATCTA	WC	HTBLPT		:host table pointer
	WC	PTBLPT		:port table pointer
	WC	PTABLE		:termination table pointer
       if       swtchr          :switcher has no rings
        wc      0
        wc      0               :no input or outp ring
       else     :normal
	WC	DORING		:Dispatcher's output (note reversed convention)
	WC	DIRING		:Dispatcher's input ring
       ei       :swtchr
	WC	0		:(unused)
	WC	0		:(unused)
	WC	PCBPNT		:project code bits pointer
	WC	0		:(unused)
	HC	MAXHST		:maximum number of hosts
       if       swtchr
        hc      0               :0 ports
        hc      0,0             :size 0 input and output rings
       else     :normal isis
	HC	NDP-1		:maximum number of ports
	HC	DRSZ		:Dispatcher ring sizes
	HC	DRSZ		:
       ei       :swtchr
	HS	1		:slot number filled in by ISIS
	HC	VERREV		:version number and revision level
	WC	ASCB		:pointer to Alfred block
	WC	0		:(unused)
	HC	0		:(unused)
	HC	PRODID		:product id
	HC	0		:patch version number
	HC	0		:(unused)
	WC	0		:(unused)
	WC	0		:(unused)
qq      CURGMT
        gentim(qq)
        bc      qqqmon,qqqday,qqqyr,qqqhrs,qqqmin,qqqsec :GENTIM
	WS	10		:reserved for future ISIS-II expansion

::******************************************************************
::
::	GATEWAY/NODECODE differences for CTA
::
::******************************************************************

      IF	T2GATE

:	Gateway's tables differ from NodeCode's
G.HTBL	HC	IHOST		:Gateway uses IHOST only (fixed for now)
G.UTBL	HC	NDP		:maximum port number
PTABLE	HS	NDP		:table of ports for Dispatcher
G.PCTB	HC	4,0,0,10,0,0,0,0
	HC	4,0,0,10,0,0,0,0	:Project Code terminator bits
DESCRI	AC	/TYMNET-II GATEWAY/	:slot description string...
	BC	0			:...null terminated
::	Gateway's CTA differs from NodeCode's.
::	Re-define the following symbols used in the CTA.
CNTRL	EQ	892			:control flags
HTBLPT	EQ	G.HTBL			:host table pointer
PTBLPT	EQ	G.UTBL			:user port table pointer
PCBPNT	EQ	G.PCTB			:project code bits pointer
MAXHST	EQ	1			:maximum number of hosts
VERREV	EQ	GT.VER			:version number and revision level
PRODID	EQ	8B			:Gateway product id

      ELSE	:NodeCode

:	NodeCode's tables differ from Gateway's
HTBL	WC	0
PTABLE	HS	NDP			:permuter table

::	NodeCode's CTA differs from Gateway's.
::	Re-define the following symbols used in the CTA.
DESCRI	AC	/TYMNET-II NODE CODE/	:slot description string...
	BC	0			:...null terminated
CNTRL	EQ	80			:control flags
HTBLPT	EQ	HTBL			:host table pointer
PTBLPT	EQ	HTBL			:port table pointer
PCBPNT	EQ	0			:project code bits pointer
MAXHST	EQ	0			:maximum number of hosts
VERREV	EQ	((VERSION*4)&0FF00)!(REVLEV)	:version/revlev
PRODID	EQ	38			:NC product id

      EI	:T2GATE

::*****************************************************************
::
::	ASCB:	Alfred-68K Slot Control Block
::	The ASCB defines the slot fields for Alfred-68K slot-related
::	functions.  It is pointed to by the slot's CTA table.  This
::	pointer and the context pointer are the only CTA entries
::	that relate to Alfred-68K.
::
::*****************************************************************

:	DISABLE POINTERS UNTIL IMPLEMENTED
ASCB	WC	0		:SLTSYM - pointer to slot symbol table
	WC	0		:ALCMD - pointer to slot extended command table


SESIZE	EQ	.-SEGE

	SUBTTL	DATA (SEGMENT F)

::*********************************************************************
::
::	SEGMENT F - ISIS only
::	1.  Merlin uses symbols defined below.
::	2.  ISIS Data Area, the "real" SEGF, is mapped to low-core.
::	IDA symbols (FASTC, SLOWC, TEMPER, VOLTS, LO.CLK) are defined
::	earlier using EQs.
::
::*********************************************************************

::	T-II Gateway will not need Merlin checking on this.
	IF	(1-T2GATE)		:Gateway does not use Merlin checks

	SEG.(0F)
	ORG	0F0000
SEGF	HS	0

:	DEFINE CRITICAL PARAMETERS FOR MERLIN EDITS
NODEVR	EQ	VERSION&0FFF	:NODE'S VERSION NUMBER

	HC	NDEFN		:NUMBER OF DEFINED SYMBOLS
	SYMDEF(NODEVR)
NDEFN	EQ	NDEF

	HC	NREFN		:NUMBER OF REFERENCE SYMBOLS
	SYMREF(NDP,2,NDP,NDP)
	SYMREF(NSLOT,2,NSLOT,NSLOT)
	SYMREF(HST0,2,HST0,HST0)
	SYMREF(MICRO,2,MICRO,MICRO)
	SYMREF(MACHNM,2,MACHNM,MACHNM)
	SYMREF(ISISVR,2,$A600,$A9999)
	SYMREF(NKU,2,NKU-1,NKU-1)
NREFN	EQ	NREF
SFSIZE	EQ	.-SEGF
	EI	:(1-T2GATE)



	ENDMO.(DATA)
	EI 	:1-KILLIT
	KILMSG(DATA)

:	***NOTHING PAST THIS POINT***

	
	SUBTTL  EXEC

:			***** *   * *****  ***
:			*      * *  *     *   *
:			***     *   ***   *
:			*      * *  *     *   *
:			***** *   * *****  ***

::#####################################################################
::
::	MODULE:		EXEC
::
::	FUNCTION:	PROCESS EXECUTIVE AND OTHER SUPPORT SOFTWARE
::			FOR TYMNET-II NODE CODE. 
::
::	SUBTTLS:	Read/only data
::			NSTART - Init routine for node code
::			EXEC - Process, schedule, dispatch and dismiss
::			Process execution statistics
::			Various dismiss methods for various processes
::			SPIDER - Schedule RMAKE, RTD, DISPI, SUP and SWITCH
::			Periodic processes
::			Utility routines
::			OOPS - Software error handler
::			CRYPTO - Diagnostic message generator
::			
::#####################################################################

:       macro to test whatever condition before freelt is stored
tsfree  macro(rx)[
        thi     rx,4
        jnfs    .+4
        hc      0
]


	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.

::*********************************************************************
::
::	EXEC READ/ONLY DATA -- EQUATES, CONSTANTS AND DATA AREAS
::
::*********************************************************************

	SEG	1		:SEGMENT 1 DATA CONTINUES HERE
        HS      0

::*********************************************************************
::
::	INITIAL PROCESS P-COUNTERS, PRIORITIES, AND FREQUENCIES
::
::      NOTE:   Any changes in this list requires changing the NS command
::              list of jobs with percent and max time.                 ###sdw
::*********************************************************************

Q	EQ	1F

QEXECZ	WS	0	:BUFFER ZAPS GET THE HIGHEST PRIORITY
	WC CKZB					;PCKZB	EQ	Q;Q EQ Q-1
	GL	CKZB

	WC SYLVSP	;TSYLVR EQ T016MS	;PSYLVR EQ	Q;Q EQ Q-1
	GL	SYLVSP

	WC SPIDER	;TSPIDR EQ 0		;PSPIDR EQ	Q;Q EQ Q-1

	WC SWITCH	;TSWICH EQ T032MS	;PSWICH EQ	Q;Q EQ Q-1
	GL	SWITCH

	WC LINKER	;TLINKR EQ T125MS	;PLINKR EQ	Q;Q EQ Q-1
	GL	LINKER

	WC	G250MS	;TG250M	EQ T250MS	;PG250M	EQ	Q;Q EQ	Q-1

	WC G500MS	;TG500M EQ T500MS	;PG500M EQ	Q;Q EQ Q-1

	WC DWLIN	;TDWLIN EQ 0		;PDWLIN EQ	Q;Q EQ Q-1
	GL	DWLIN

	WC DLYSRC	;TDLYSR EQ 0		;PDLYSR EQ	Q;Q EQ Q-1
	GL	DLYSRC

	WC XRYSCH	;TXRAY  EQ 0		;PXRAY	EQ	Q;Q EQ Q-1
	GL	XRYSCH

	WC G01SEC	;TG01SC EQ T01SEC	;PG01SC EQ	Q;Q EQ Q-1

	WC G02SEC	;TG02SC EQ T02SEC	;PG02SC EQ	Q;Q EQ Q-1

	WC G04SEC	;TG04SC EQ T04SEC	;PG04SC EQ	Q;Q EQ Q-1

	WC G08SEC	;TG08SC EQ T08SEC	;PG08SC EQ	Q;Q EQ Q-1

	WC G30SEC	;TG30SC EQ T30SEC	;PG30SC EQ	Q;Q EQ Q-1

	WC G01MIN	;TG01MN EQ T01MIN	;PG01MN EQ	Q;Q EQ Q-1

	WC G02MIN	;TG02MN EQ T02MIN	;PG02MN EQ	Q;Q EQ Q-1

	WC G04MIN	:4 MINUTE ROUTINE	;PG04MN	EQ	Q;Q EQ Q-1

	WC	MSHRNK				;PGMSRK	EQ	Q;Q EQ Q-1
	GL	MSHRNK	:8 MINUTE CHECK FOR LINKS WHICH NEED SHRINKING

	RE 20-(.-QEXECZ)/4
	WC EXCRH; NOLIST; ER; LIST

::*********************************************************************
::
::	INITIAL PROCESS SCHEDULE:
::
::*********************************************************************

SCHTBZ	WC 1^PGMSRK			:T08MIN
	WC 1^PG04MN			:T04MIN
	WC 1^PG02MN			:T02MIN
	WC 1^PG01MN			:T01MIN

	WC 1^PG30SC			:T30SEC
	WC 0				:T16SEC (ELSE)
	WC 1^PG08SC			:T08SEC
	WC 1^PG04SC			:T04SEC

	WC 1^PG02SC			:T02SEC
	WC 1^PG01SC			:T01SEC
	WC 1^PG500M			:T500MS
	WC	1^PG250M		:T250MS .. Apply Backpressure
	WC 0				:T125MS...UNUSED
	WC 1^PSWICH			:T032MS...SWITCH
	WC 1^PSYLVR			:TSYLVR = 16MS

::*********************************************************************
::
::	SIOINT:
::	A brief description of the initialization routine is as follows:
::	do a channel reset, reset external status latches, set SDLC
::	mode, reset external status latches, rcv interrupt disable,
::	null, set: (DTR, TX 8 bits/char, Tx enable, RTS, Tx CRC enable),
::	reset Tx CRC generator, enter flag char 7E, reset external 
::	status latches, set: (Rx 8 bits/char, enter hunt phase, Rx 
::	CRC enable, Rx enable), stop.
::
::*********************************************************************

	IF	SILINS
SIOINT	WC	30018,31420,31100,303D8,305EB	:CHANNEL RESET,30018,ADDED#JHL
	WC	3877E			:HDLC INITIALIZATION PROGRAM	###TZ
	IF	HMICRO			:HDLC Micro			###wjl
	WC	613D9,0
	ELSE	:ENGINE
	WC	313D9,0
	EI	:HMICRO
       EI       :SILINS
SIOIND	HC	4			:DUMMY RECORD (4 IS LENGTH
	HC	TWDMHD^(-10),TWDMHD&0FFFF,0,0,0,0,0

::*********************************************************************
::
::	MACHID:	DEFINE MACHID FOR CONSOLE DISPLAY.
::		UPPER HALFWORD HAS DECIMAL FORMAT HOST NUMBER,
::		LOWER HALFWORD HAS OCTAL FORMAT MACHINE NUMBER.
::
::*********************************************************************

      IF	1-NAD68		:No CONSOL display in 68K envir	###wjl
	RA	8		:SET OCTAL RADIX
MACHID	HS	0
	BC	0
	BC	((MACHNM&70000)^-14)
	BC	((MACHNM&7000)^-5)+((MACHNM&700)^-6)
	BC	((MACHNM&70)^1)+(MACHNM&7)
	RA	0		:RESTORE HEX RADIX
      EI	:1-NAD68

	SUBTTL	EXEC (NSTART)

::*********************************************************************
::
::	NSTART:		INITIAL ROUTINE RUN IN THE NODE CODE
::	FUNCTION:	INITIALIZES ALL DATA AREAS AND VARIABLES FOR
::		THE NODE CODE AND THEN JUMPS TO THE MAIN NODE CODE EXEC
::		LOOP (EXEC)
::
::*********************************************************************

NSTART	HS	0
	LIS	R0,0
	STH	R0,DRIF,,		:INITIALIZE DISPATCHER RING POINTERS
	STH	R0,DRIE,,
	STH	R0,DROF,,
	STH	R0,DROE,,
	LA	R0,FAIL			:R0 = ADDR of trap-block
	SVC	SYS,0			:Restart Syscall
	HC	0,0			:non-skip return = ADDR not valid

	IF	SUPER
	IF	\MSLOT			:NOT FOR SUPS USING ISRS
	ELSE	:\MSLOT
	SVC	SYS,$A 24		:FREEZE SUP
	EI	:\MSLOT
	EI	:SUPER

:	NOW BEGIN CLEARING THE SEGMENTS
	LHI	R1,CLSEG0		:start clearing from CLSEG0	###jhl
	LHL	R2,CRHCNT		:if crash count zero, clear all
	JNFS	NST04			:else, clear around host tables
	LHI	R2,(S0SIZE-CLSEG0)/2	:get range to end of SEG 0
	JFS	NST08			:branch to do one fell clear
NST04	LHI	R2,(HOSTN-CLSEG0)/2	:clear up to host tables
	JAL	R8,HCLEAR		:there is info in host tables
					:that we must not lose		###jhl
	LHI	R1,NEWSUP		:resume clearing after host tables
	LHI	R2,(S0SIZE-NEWSUP)/2	:assumes NEWSUP doesn't move
	GL	S0SIZE
NST08	JAL	R8,HCLEAR		:clear rest of seg 0

:       Clear SEG 2 through SEG C                                       ###sdw
	LA	R1,20000,,	
	LI 	R2,(SEGC-20000)/2	:CLEAR FROM 20000 TO SEGC   	:###LSH
	JAL	R8,HCLEAR

	LA	R1,SCEND,,	 	:CLEAR FROM SCEND TO THE END	###LSH
	LI 	R2,((CHRBUF-SCEND)+RCBFSZ)/2	:OF BUFFERLET    	###LSH
	GL	RCBFSZ				:AREA		 	###LSH
	JAL	R8,HCLEAR

:	now reset values of available ports to max for each host
	LHI	R10,NHOSTS-1		:init index into HW arrays
NSTH05	LHL	R1,HMAXP,R10,R10	:read host entries for max ports
	JEFS	NSTH10			:nothing doing if zero
	STH	R1,HSTPTA,R10,R10	:here's a value to move
NSTH10	SIS	R10,1			:decrement index to next host entry
	JGEBS	NSTH05			:loop for all possible entries	###jhl

	TS	SYLINT			:TO START SYNC SPEEDCALC	###OAS

	IF	SIORNG
	IF	SNRING
	IF	SUPTRC			:###OAS
	GL	SRNTRE,SRNBTZ,SRNSEC,SRNTRX,SRNICK,SRNOCK
	LA	R1,SRNTRE,,		:CLEAR SUP RING TRACE BIT FLAGS
	LHI	R2,SRNBTZ		:THIS MANY HW'S
					:DISABLES TRACE, ENABLES DISPLAY
	JAL	R8,HCLEAR
	STH	R0,SRNSEC,,		:DISABLE SS CMD (R0 HAS 0 AFTER HCLEAR)
	STH	R0,SRNTRX,,		:CLEAR TRACE TABLE INDEX
	ST	R0,SRNICK,,		:ENABLE TRACE OF ALL SUPIN MESSAGES
	ST	R0,SRNOCK,,		:ENABLE TRACE OF ALL SUPOUT MESSAGES
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	IF	TSTSZE
	TS	TSLINE			:TURN OFF LINE-LEVEL TRACING	###OAS
	EI	:TSTSZE

	GL	XUBLK,CRYMOD
	LIS	R1,1			:TURN OFF AUTO CRYPTO DISPLAY FOR TTY 
	LHI	R2,CRYMOD
	STH	R1,XUBLK,R2,

	L	R10,SLOWC,,		:###OAS
	ST	R10,NODSLC		:SEE COMMENT IN DATA AT NODSLC DEFN


	LHL	R10,CRHCNT
	AIS 	R10,1
	STH	R10,CRHCNT
	STH	R10,CRCNT		:CRASH TABLE'S COUNT

	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl
	LI	R10,TRACER
	GL	TRACER
	ST	R10,TRPSW+8		:POINTER TO JUMP TRACE
	EI	:DB.TRC

	LHL	R0,CRYPRI		:INITIALIZE CRYPTO POINTER FOR TTY
	LI	R1,TTYXD		:TTY USER BLOCK
	GL	TTYXD
	STH	R0,CRYPTU,R1

	IF	(1-T2GATE)		:GET HOSTS STATUS		
         IF     1-NCSLOT                 :special to let NC run in slot 1
	LHI	R0,INHTRQ^8		:HOST STATUS REQUEST MESSAGE	###jhl
	STH	R0,DIRNG+2,,		:STORE PORT #0/MESSAGE
	LHI	R0,INNOSP^8		:NO SUP MESSAGE			###jhl
	STH	R0,DIRNG+6,,
	LIS	R0,8
	STH	R0,DRIF,,		:SAVE FILL POINTER
         EI     :1-NCSLOT
	ELSE	:T2GATE	
	LIS	R3,HDOWN		:Pass host down during init.
	JAL	R10,GHSTST,,		:Send to dispatcher
	GL	GHSTST
	LHI	R3,INCOST		:Init send default hst cost##al
	JAL	R10,GHSTCT,,
	GL	GHSTCT
        LIS     R1,1                    :###sdw
        STB     R1,G0DFG                :init that we have an ISIS supe
	EI	:T2GATE	
	

	IF	ACCT			
	JAL	R8,AAINIT		:Initialize accounting block pointers
	EI	:ACCT						  :###LSH

	LHL	R0,CRHCNT		:TEST CRASH COUNT
	SIS	R0,1			:IF 1, WE'RE INITIALIZING FOR 1ST TIME
	JG	NST50			:NO, RESTART, LEAVE SEG C ALONE

:	INITIALIZING FOR THE FIRST TIME - INITIALIZE SEGMENT 'C'
	LA	R1,SEGC,,		:				###LSH
	LI	R2,(RSEGC-SEGC)/2	:FIRST PART OF SEG C TO -1	###LSH
	LCS	R0,1
	JAL	R8,HCSET		:CLEAR SEGMENT C
	LA	R1,RSEGC,,		:REST OF SEG C TO 0
	LI	R2,(SCEND-RSEGC)/2
	JAL	R8,HCLEAR


	LIS	R0,0
	STH	R0,CRYPRI

:	Put the XRAY symbol table in (approximate) alphabetical order.
	GL	SYMTBL,SYMTSZ
	JAL	R11,XWRITE,,		:Need to write to segment D
	GL	XWRITE
	LIS	R2,0
NST60	HS	0
	LHI	R1,ADRESZ,R2
NST61	L	R10,SYMTBL,R1,
	C	R10,SYMTBL,R2,
	JGE	NST62

	LM	R13,SYMTBL,R2,
	L	R11,SYMTBL+4,R1,
	L	R12,SYMTBL+8,R1,
	STM	R13,SYMTBL,R1,
	ST	R10,SYMTBL,R2,
	ST	R11,SYMTBL+4,R2,
	ST	R12,SYMTBL+8,R2,

NST62	HS	0
	AHI	R1,ADRESZ
	CLHI	R1,SYMTSZ
	JL	NST61

NST68	HS	0
	AHI	R2,ADRESZ
	CLHI	R2,SYMTSZ-ADRESZ
	JL	NST60

	LIS	R0,0			:###TZ
	STH	R0,CRHCNT
	JAL	R10,CTENTR,,
	LIS	R0,1
	STH	R0,CRHCNT		:###TZ

	LIS	R0,0			:re-initialize
	STH	R0,CSMCNT		:crash summary count		###wjl

	JAL	R11,XPRTKT,,		:Protect segments 1 and D
	GL	XPRTKT

:	INIT CRASH TABLE STUFF
	LHI	R1,MACHNM
	STH	R1,NODENU	
	LIS	R1,9			:T-II NODE TYPE
	STH	R1,NODETY
	LIS	R1,CTBVER
	STH	R1,TABVER
	LHL	R1,VERSSV+2,,
	STH	R1,CODVER

:	INITIALIZE ISIS KERNEL RING POINTERS
NST50	HS	0
	IF	(1-T2GATE)
	LCS	R0,1			:SET POINTERS TO -1
	LIS	R1,0			:KERNEL PORT OFFSET
	LHI	R2,NII			:IN POINTER (FOLLOWED BY NOI)
NST02	ST	R0,KRINGS,R2,R1		:INITIALIZES IN AND OUT POINTERS
	AHI	R1,2*(KBSZ+4)		:SIZE OF PORT'S RING AREA
	CLHI	R1,NKU*(2*(KBSZ+4))
	JLBS	NST02
	EI	:(1-T2GATE)

	IF	SUPER
	IF	\MSLOT			:NOT FOR SUPS USING ISRS
	ELSE	:\MSLOT
	SVC	SYS,$A 25		:Thaw the Sup Syscall
	EI	:\MSLOT
	EI	:SUPER


       IF       NLINES-SILINS           :initialize the sync rotors
        L       R0,SIOIND+2             :get dummy record
        ST      R0,SYNDUM,,             :save it where sync can use it
        LCS     R0,SYDUMZ-4             :size of dummy record withtout checksum
        LA      R1,SYNDUM,,
        LIS     R2,0                    :clear accumlators
        LIS     R3,0
        CKSUM   R2,R1                   :the the checksum
        LA      R1,SYNDUM,,             :CKSUM can alter R1
        STH     R2,SYDUMZ-4,R1		:vert checksum
        STH     R3,SYDUMZ-2,R1          :hori checksum
        LHI     R0,NLINES-SILINS
        LA      R1,OROTOR,,             :address of first rotor
        LHI     R2,10,R1                :address of third rotor
NST010  ST      R1,0C,R2                :the jump address
        ST      R2,0C,R1                :jump address set up
        AHI     R1,20
        AHI     R2,20                   :for next line
        SIS     R0,1
        JGBS    NST010                  :do all sync lines
       EI       :any sync lines


	IF	SILINS

:	INITIALIZE SIO LINES
        LHI     R13,(NLINES-SILINS)*2
NST070  LA      R1,SIOINT               :pointer to initialization prog
        L       R2,SIOIPG,R13,R13       :where to put initialization prog
        GL      SIOIPG,SIODUM
        LHI     R3,8*4                  :8 words
        JAL     R8,BCMOVE               :copy orig to dest
        AIS     R13,2
        CLHI    R13,NLINES*2
        JLBS    NST070                  :for all lines
        LA      R1,SIOIND               :get address of dummy record
        LA      R2,SIODUM,,
        LHI     R3,4*4                  :size of dummy record
        JAL     R8,BCMOVE               :only 1 dummy record since never chg
	LIS	R1,0			:NOW PREPARE ALL OTHER CCWS

        LI      R12,200^8               :init output state to completed
        LIS     R14,0
        LIS     R15,0                   :not used
	LI	R7,10000+SIBUF/10	:INPUT CCW WITH POINTER TO BUFFER
	GL	SIBUF
	LHI	R2,(NLINES-SILINS)*2	:USE R2 AS 1ST SIO LN ##AL

SIOIZP
	LI	R6,30000+SIBFSZ/2	:BUFFER SIZE FOR INPUT ###LSH
SIBFZ2	LHI	R5,7C			:SIZE OF RESET PATTERN
:	RESET PATTERN MADE LONG TO ALLOW ACCURATE LINE SPEED CALCULATION
:	BUT ONLY FIRST 1C BYTES HAVE USEFUL DATA ###wjl
        L       R9,SIOBLA,R2,R2         :address of output CCW
        GL      SIOBLA                  :actually defined in linker
        LR      R13,R9
        SRLS    R13,4                   :CCW/4
        LIS     R10,0
       RE       NCHAIN-1
        AIS     R13,1                   :address of next CCW for chaining
        STM     R12,0,R9,R10
        AHI     R10,10                  :setup next CCW offset
       ER       :nchain-1               :for all except last CCW
        LR      R13,R9                  :last CCW chains to first CCW
        SRLS    R13,4
        STM     R12,0,R9,R10            :save CCW block

        LIS     R10,0
        STB     R10,SIOTB,R2            :no active transmitting
        STB     R10,SIOFB,R2            :first CCW is free
	ST	R6,SIOBLI,R1,		:CCW for input
	ST	R7,SIOBLI+4,R1,
	LR	R3,R1
	AR	R3,R1			:FOR 30H BLK IN XRESET
	AR	R3,R1			:FOR 30H BLK IN XRESET
	STH	R5,SIOBLR,R3,		: for Expanded reset ##AL
	GL	SIOBLR
:	increment values for next set of stores
	AHI	R7,SIBFSZ/10		: input Qpointer


	AIS	R2,2			:INC LN ##AL
	AHI	R1,10			:increment block offset for next line
	CLHI	R2,2*NLINES		:check the range
	JL	SIOIZP			:OK to do another set of stores
	EI	:SILINS

      IF	NAD68
	JAL	R10,IZ68K,,		:init 68K environment		###wjl
	GL	IZ68K
      EI	:NAD68

	JAL	R10,IZLNKR		:INIT LINKER
	GL	IZLNKR
	IF	SUPER
	JAL	R10,IZSUP,,		:INITIALIZE SUPERVISOR INTERFACE FIELDS
	GL	IZSUP
	EI	:SUPER
	IF	SIORNG
	JAL	R10,IZKNRG,,		:INIT NEGATIVE RINGS FOR INTERFACES
	GL	IZKNRG
	JAL	R10,IZSIRG,,		:INITIALIZE SIO RING CARD
	GL	IZSIRG
	EI	:SIORNG
	JAL	R10,IZSWIT,,		:INIT SWITCH
	GL	IZSWIT
	JAL	R10,IZEXEC		:INIT EXEC
	L	R0,FASTC,,		:SAVE FASTC TIME FOR
	ST	R0,SYLTIM		: SYNC OVERRUN CALCULATION

        if      tii.fg
        la      r0,sylver
        gl      sylver
        svc     sys,1                   :run syvler in foregroun
        ei


        IF      SPAM                    :                               ###dmj
        L       R0,SLOWC,,              :INITIALIZE TIMERS              ###dmj
        AI      R0,$A60                 :ADVANCE 60 SECONDS             ###dmj
        ST      R0,MTRTIM               :INITIALIZE MEASUREMENT TIMER   ###dmj
        ST      R0,SPSYNC               :SET UP SPAM SYNC TIME          ###dmj
        LCS     R0,1                    :SET NEGATIVE ADDRESS           ###dmj
        SVC     SYS,$A 53               :TELL SPAM TO RE-INITIALIZE     ###dmj
        HC      0,0                                                     ###dmj
        LIS     R0,0                                                    ###dmj
        STH     R0,SPMINI               :RESET SPAM INITIALIZE FLAG     ###dmj
        EI      (SPAM)                  :                               ###dmj

	IF	DB.DEB
	L	R0,FASTC,,		:SAVE FASTC TIME FOR
	ST	R0,RMKTIM		: AND RMAKE INTERVAL CALCULATIONS
	EI	:DB.DEB

	L	R0,SLOWC,,		:SAVE SLOWC TIME FOR XRAY TO DISPLAY
	ST	R0,GMTSLC		:RESET BASE SLOWC


	J	EXEC			:AND BEGIN EXECUTING

	SUBTTL	EXEC (IZEXEC - Initialize the EXEC segment)

::*********************************************************************
::
::	SUBROUTINE:	IZEXEC:
::	FUNCTION:	INIT THE EXEC SEGMENT
::	CALLING SEQ:	JAL	R10,IZEXEC
::
::*********************************************************************

IZEXEC	HS	0
	LH	R0,VERSSV+2		:SET THE VERSION AND NODE #'S
	STH	R0,VERSID
	LHI	R0,MACHNM
	STH	R0,NODEID

	LA	R1,SCHTBZ		:INIT THE SCHEDULE TABLE
	LA	R2,SCHTAB
	LHI	R3,40
	JAL	R8,BCMOVE

	LA	R1,QEXECZ		:INIT THE PROCESS P-COUNTER TABLE
	LA	R2,QEXEC
	LHI	R3,80
	JAL	R8,BCMOVE

	L	R0,SLOWC,,		:INITIALIZE TIME TO COMPUTE AVERAGE
	ST	R0,EXLTLA		: # OF EXEC LOOP ITERATIONS PER SECOND
	LHI	R0,7FFF			:INSURE LOW-WATER MARK DOESN'T START
	STH	R0,EXLALW		: TOO LOW...
	L	R0,FASTC,,
	ST	R0,EXTIME		:MAKE TIME SINCE LAST EXEC REASONABLE

	L	R0,FASTC,,		:SCHEDULING DUE TIMES
	AHI	R0,RATE			:BEGIN 1 SEC FROM NOW
	ST	R0,DUESCH
	LHI	R0,1F-PSYLVR		:DON'T SCHEDULE SYLVER
	RBT	R0,TSYLVR		: --IT'S THE FOREGROUND

	JR	R10

	SUBTTL	EXEC (Process schedule, dispatch and dismiss)

::*********************************************************************
::
::	EXEC:	DISPATCHES TO PROCESS OF HIGHEST PRIORITY
::
::*********************************************************************

EXE2	HS	0
	LA	R3,EXEHWM		:POINT TO FIELDS TO RECORD
	JAL	R0,EXMTIM		:GO MEASURE TIME THROUGH EXEC LOOP



:	THE ISIS EXEC LOOP MAINTAINS ITS OWN TIME-OUT LIST. EVERY
:	1/8 SEC THE EXEC LOOP OR'S THE APPROPRIATE TIMEOUT
:	LOCATIONS T125MS-T08SEC INTO THE RUN QUEUE SQUEUE.
:
:	It does this by using the number of right-most 0-bits in EISECC
:	(which it increments every 125 ms) to select which timeout-period
:	bit to OR into the SQUEUE bit-array.  Thus only one get selected
:	on each pass, but all run at the appropriate rate, without imposing
:	bursts of load on the CPU.
:
:	NOTE THAT THE MOST FREQUENT PROCESS RUNS EVERY 1/8 SECOND

       IF       1-swtchr                :if no other slots then no need to 
                                        :dismiss since no other BG matters
	SVC	FAST,0			:DISMISS TO ISIS KERNEL

	LA	R3,EXDHWM		:POINT TO FIELDS TO RECORD
	JAL	R0,EXMTIM		:GO MEASURE TIME DISMISSED
       EI       :SWTCHR
        LIS     R5,1
	AM	R5,EXLCNT		:COUNT EXEC LOOPS

EXIDL	LHI	R0,1F-PSPIDR		:SCHEDULE SPIDER 
	SBT	R0,SQUEUE

EXEC	HS	0
:       schedule 1/8 logic to run 8 times a sec even if we enterred EXEC
:       a few hundrediths of a second late each time.  Before we would
:       schedule exec to run 1/8 from present so if few hundrediths late
:       they accumulate and might average out to only 7.5 times per second.
	L	R1,FASTC,,		:EVERY 16 TIKS, SCHEDULE SYLVER
       if       1-tii.fg                :only if sylver is in BG
        l       r0,syvsch               :sched syvler 
        sr      r0,r1                   :
        jgfs    execsy
        lhi     r0,1f-psylvr
        sbt     r0,squeue
execsy
       ei       :tii.fg
	L	R0,DUESCH		:SCHED EVERYTHING EVERY 1/8 SEC
	SR	R0,R1			:DUESCH IS NEXT FASTC SCHEDULE TIME
	JG	EXE4			:1/8 SEC HAS NOT YET ELAPSED
        AHI     R0,RATE/8,R1            :GET NEW DUE TIME (- POSSIBLE OVERRUN)

	ST	R0,DUESCH		:AND STORE INTO DUESCH
	LH	R0,EISECC		:EISECC IS INCREMENTED EVERY 1/8 SEC
	AIS	R0,1
	STH	R0,EISECC
	L	R2,T125MS		:SCHED THESE PROCESSES
	O	R2,SQUEUE
	ST	R2,SQUEUE
	LA	R1,T125MS		:NOW SCHEDULE THE REST
	LA	R2,T08MIN
EXE5	CR	R1,R2			:AT END OF TIMEOUT LIST?
	JEFS	EXE4			:YES
	SIS	R1,4			:MOVE TO NEXT TIMEOUT LOCATION
	SRHLS	R0,1
	JNCBS	EXE5			:NOT TIME TO SCHEDULE THIS ONE
	L	R2,0,R1			:FOUND A PROCESS - READ THE TABLE ENTRY
	O	R2,SQUEUE		:MERGE WITH CURRENT RUN QUEUE
	ST	R2,SQUEUE

EXE4	L	R1,SQUEUE		:PICKUP RUN QUEUE
	JFFO	R1,EXE6
	UPSW	EXEPSW

EXE6	ST	R1,SQLAST		:SAVE CURRENT STATE OF QUEUE
	SLHLS	R2,2
	STH	R2,PROCID		:SAVE IT
	LIS	R0,1
	AM	R0,PROCNT,R2		:COUNT EXECUTIONS FOR EACH PROCESS
	L	R0,FASTC,,
	ST	R0,PROTIM,R2		:SAVE PROCESS EXECUTION BEGIN TIME


::-------------------------------
::  TRAP <170> isis_qsmem - Query Status of Shared Memory Areas
::  This TRAP allows a NodeCode slot to query the shared memory bit
::  arrays for the board.  A two byte control area and a copy of the
::  two bit arrays (32-bytes each) associated with NodeCode shared
::  memory are placed in the area pointed to by QSINFO.  If there have
::  been any changes in the bit arrays since the last query, the control
::  area is set to 1.  If there have been no changes, the control area
::  is 0.

      IF	NAD68
      IF	MNC68K
	SRC68
	MOVE.L	#QSINFO,D1		!Query Shared memory info pointer in D1
	MOVE.L	#QSMEM.,D0		!function code in D0
	TRAP	#ISIS
	END68
	JN	BAD170			:non-zero return code indicates error

::  test control area
	LHL	R0,QSINFO		:control area
	JEFS	RET170			:no changes
	JAL	R10,QSMEM		:there have been changes
RET170
      EI	:NAD68
      EI	:MNC68K

	L	R0,QEXEC,R2		:DISPATCH TO PROCESS


	JR	R0

	SUBTTL	EXEC (Process execution statistics)

::*********************************************************************
::
::	SUBROUTINE:	EXMTIM:
::	FUNCTION:	RECORD INTERVAL, EITHER EXEC LOOP TIME OR DISMISS TIME
::	CALLING SEQ:	JAL	R0,EXMTIM
::	INPUT:		R3 POINTS TO HIGH-WATER MARK FIELD
::			R4 POINTS TO HISTOGRAM
::	Returns:	R5 contains 1 (Used by callers for counting)
::
::*********************************************************************

EXMTIM	HS	0			:MEASURE TIME, MAKE MARK IN HISTOGRAM
	L	R1,FASTC,,
	LR	R2,R1
	S	R1,EXTIME		:COMPUTE TIME SINCE LAST EXEC OF EXMTIM
	ST	R2,EXTIME		:AND SAVE CURRENT TIME FOR NEXT TIME

	CLH	R1,0,R3			:TEST FOR NEW HIGH-WATER MARK
	JLEFS	EXMT10			:NO
	STH	R1,0,R3			:YES - SAVE IT

:	MAKE HISTOGRAM ENTRY. FULLWORD COUNTER RECORDS FASTC/4 UNITS.
EXMT10	HS      0
	JR	R0			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	EXCAVG:
::	FUNCTION:	COMPUTE AVERAGE NUMBER OF EXEC LOOPS/SECOND.
::			RECORD NEW HIGHS AND LOWS AS APPROPRIATE.
::	CALLING SEQ:	JAL	R10,EXCAVG
::
::*********************************************************************

EXCAVG	HS	0
:	REFRESH COUNTERS FOR RMK ITERATIONS AND RMK CALLS FOR NO RECORD MADE.
	LIS	R1,0
	L	R2,RMKRMW
	ST	R2,RMKRMS		:SAVE LAST MINUTE'S TOTALS AND
	ST	R1,RMKRMW		: CLEAR WORKING FIELDS
	L	R2,RMKNRW
	ST	R2,RMKNRS		:# TIMES RMK CALLED, NO RECORD MADE
	ST	R1,RMKNRW
        l       r2,rtdlrr
        st      r1,rtdlrr
        st      r2,rtdlrs               :logical records torn
        l       r2,rtdpkr
        st      r1,rtdpkr
        st      r2,rtdpks               :number of packets torn

	L	R1,SLOWC,,
	LR	R2,R1
	S	R1,EXLTLA		:COMPUTE TIME SINCE LAST AVERAGE TAKEN
	ST	R2,EXLTLA		: AND SAVE CURRENT TIME FOR NEXT TIME

	LIS	R3,0			:R3 & R2 ARE 64-BIT COUNT OF
	L	R2,EXLCNT		: EXEC LOOP ITERATIONS
	ST	R3,EXLCNT		:REFRESH CNT FOR NEXT AVERAGING PERIOD
	DHR	R2,R1			:COMPUTE AVERAGE/SECOND
	STH	R3,EXLAVG		: AND SAVE

	CLH	R3,EXLAHW		:TEST FOR NEW HIGH-WATER MARK
	JLEFS	EXCA10			:NO
	STH	R3,EXLAHW		:YES - SAVE IT

:	Compare with low water mark in case we just did an NSZ.
EXCA10	CLH	R3,EXLALW		:NEW LOW-WATER MARK?
	JGER	R10			:NO - RETURN
	STH	R3,EXLALW		:YES - SAVE IT AND
	JR	R10			:RETURN

	SUBTTL	EXEC (Dismiss)

::*********************************************************************
::
::	EXDISM:/EXDIS:/EXYLDM:/EXYLD:  DISMISS METHODS FOR VARIOUS PROCESSES.
::
::*********************************************************************

:	Scheduled task may want to dismiss and yield to a higher
:	priority task if one is waiting, run again if not, or dismiss
:	and allow a lower priority task to run.  
:	Independent of either of these options, the dismissing task may
:	want to resume execution in its next scheduled time slot at the
:	top of the task, in which case no update of the PC in QEXEC is
:	needed, or it may want to resume at the point where it left off,
:	in which case an update the the PC table QEXEC is in order.
:	The fifth of these dismiss routines enables a mechanism from the
:	quarter second logic to schedule various of a sequence of
:	subtasks based upon the dismissing subtask updating a cell called
:	CSNEXT.

EXCRH	HS	0			:NON-EXISTENT PROCESS
	CRASH.(.EXCRH,R10)

:	Dismiss without changing p-counter
EXDISM	HS	0

	LHL	R2,PROCID		:DISMISS WITHOUT CHANGING P-COUNTER
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	SRLS	R2,2
	RBT	R2,SQUEUE
	J	EXEC

:	Here to dismiss - Update p-counter
EXDIS	HS	0

	LHL	R2,PROCID		:HERE TO DISMISS - UPDATE P-COUNTER
	ST	R0,QEXEC,R2
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	SRHLS	R2,2			:CLEAR RUN BIT
	RBT	R2,SQUEUE
	J	EXEC

:	Here to yield - Don't update pc...and don't clear run bit
EXYLDM	HS	0

	LHL	R2,PROCID		:HERE TO YIELD - DON'TUPDATE PC...
					:AND DONT CLEAR RUN BIT
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	J	EXEC

:	Here to yield - Update pc...but don't clear run bit
EXYLD	HS	0

	LHL	R2,PROCID		:HERE TO YIELD - UPDATE PC...
	ST	R0,QEXEC,R2		:BUT DONT CLEAR RUN BIT
	JAL	R8,CPRHWM		:TEST FOR NEW PROCESS HIGH-WATER MARK
	J	EXEC

	IF	DB.TRC
EXEPSW	WC	1000,EXE2		:ENABLE UPSW TRACE OPTION
	SYAD(EXEPSW)
	ELSE	:NOT DB.TRC
EXEPSW	WC	0,EXE2			:NORMAL MODE, NO TRACE
	EI	:DB.TRC
	
::*********************************************************************
::
::	SUBROUTINE:	CPRHWM:
::	FUNCTION:	COMPUTE PROCESS HIGH-WATER MARK.
::			THIS ROUTINE DETERMINES IF THE HIGH-WATER MARK
::			FOR A PROCESS HAS BEEN EXCEEDED, AND STORES A
::			NEW VALUE IF TRUE.
::	CALLING SEQ:	JAL	R8,CPRHWM
::	INPUT:		R2 = CURRENT PROCESS NUMBER
::	DESTROYED:	R1
::
::*********************************************************************

CPRHWM	HS	0
	L	R1,FASTC,,
	S	R1,PROTIM,R2		:COMPUTE PROCESS EXECUTION TIME
	AM	R1,PACTIM,R2		:AND ADD TO PROCESS TIME ACCUMULATOR
	C	R1,PROHWM,R2		:NEW HIGH-WATER MARK?
	JLER	R8			:NO
	ST	R1,PROHWM,R2		:YES - SAVE
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	MPRTIM:
::	FUNCTION:	SAVES THE CUMMULATIVE TIMES SPENT IN THE DIFFERENT
::			PROCESSES INTO PSVTIM, ZEROES OUT THE ACCUMULATORS
::			PACTIM, AND RETURNS.
::	CALLING SEQ:	JAL	R10,MPRTIM  CALLED BY THE 1-MINUTE PROCESS.
::
::*********************************************************************

MPRTIM	HS	0
	LIS	R0,0			:TO CLEAR ACCUMULATORS
	LHI	R1,1F*4			:MAX NUMBER OF PROCESSES
	LHI	R3,1F*2
MPRTI1	L	R2,PACTIM,R1
	STH	R2,PSVTIM,R3		:SAVE THE TIMES SPENT IN EACH PROCESS
	ST	R0,PACTIM,R1		:AND ZERO OUT ACCUMULATOR
	SIS	R1,4			:DECREMENT INDEX
	SIS	R3,2
	JGEBS	MPRTI1			:AND LOOP BACK IF MORE
	JR	R10			:RETURN

	SUBTTL	EXEC (SPIDER - Schedule RMAKE, RTD, DISPI, SUP and SWITCH)

::*********************************************************************
::
::	PROCESS:	SPIDER:
::	FUNCTION:	Main Node Code data handling process.
::			Schedules RMAKE, RTD, DISPI, SUP and SWITCH.
::	SCHEDULED:	Every pass through the top of the EXEC loop.
::
::*********************************************************************

:       exec calls here to ensure syvler has a high enough line input
:       service rate.
sylvsp  hs      0
        if      1-tii.fg
        jal     r10,sylver
        ei      :tii.fg
        j       exdism                  :and done

SPIDER	HS	0

	IF	SUPER
	JAL	R10,SUPOUT,,		:MOVE OUTBOUND SUP DATA
	GL 	SUPOUT
	EI	:SUPER

	IF	1-T2GATE		:Gateway has no Kernel I/O	
	JAL	R10,KEROPS,,		:MOVE OUTBOUND KERNEL DATA
	GL	KEROPS			:(KRORET MOVED TO XHOSTS)	###OAS
	EI	:1-T2GATE

        if      1-swtchr                :if switcher do it once a second
	JAL	R10,DISOUT,,		:MOVE OUTBOUND DISPATCHER DATA
	GL	DISOUT
        JAL     R0,EXYLD
        ei      :1-swtchr

       if       1-tii.fg                :don't do if have FG
        JAL     R10,SYLVER
       ei
        GL      SYLVER                  :RUN SYLVER AS PART OF SWITCH

        lhi     r2,lksize-4
SPD2	L	R3,ALINKS,R2		:COPY ALINKS TO LKMAKE
	ST	R3,LKMAKE,R2
	sIS	R2,4
	Jgebs	SPD2

:       following sets the the bits to service each line (for rmake)
q       eq      nlines
qqqq    eq      0
        re      (nlines+0f)/10
qq      eq      80000000
qqq     eq      0
        if      q-0f
        re      10
qqq     eq      qqq+qq
qq      eq      qq^-2
        er
        else    :not q-0f
        re      q
qqq     eq      qqq+qq
qq      eq      qq^-2
        er
        ei
        li      r2,qqq
        st      r2,linsvd+qqqq
qqqq    eq      qqqq+4
q       eq      q-10
        er


SPDRTD  J       RTEAR,,
	GL	RTEAR
SPDRMK
      IF	MNTST1			: MXRING
	JAL	R10,MXRING,,
	GL	MXRING
      EI	:MNC68K

        JAL     R0,EXYLD                :no longer call EXYLD inside RTEAR
	J       RMAKE,,                 :do RMAKE
	GL	RMAKE

:       SPIDE1 is where EFFEXC RMAKE returns
SPIDE1  HS      0
       IF      EFFEXC
        JAL     R0,EXYLD                :see if anything else came up before
                                        :doing rtear/rmake again
       EI       :EFFEXC

:       returning back to RTEAR is not a great idea.  because we are not
:       reenabling rmake we will tear packets and be unable to ack them
:       since rmake has already run for every link and is not allowed to run
:       again.  Also, returning back to exec and doing a dismiss will cause
:       rtear to be run just a bit later.  Under load testing this change
:       caused retransmissions to drop to zero (from hundred) and improve
:       delay and no drop in CPS.                               ###sdw

        JAL     R10,SIOUT               :DO LINE OUTPUT
        GL      SIOUT
	IF	1-T2GATE		:Gateway has no Kernel I/O	
	JAL	R10,KERIPS,,		:MOVE INBOUND KERNEL DATA
	GL	KERIPS

	EI	:1-T2GATE

	IF	SUPER
	JAL	R10,SUPIN,,		:MOVE INBOUND SUP DATA
	GL	SUPIN
	JAL	R10,SUPBPS,,		:RELIEVE BACKPRESSURE ON SUP PORTS
	GL	SUPBPS
	EI	:SUPER


       IF       1-SWTCHR                :if switcher then never data to dispi
	JAL	R10,DISIN,,		:MOVE INBOUND DISPATCHER DATA
	GL	DISIN
       EI       :1-SWTCHR

	IF	T2GATE
	JAL	R10,GDB3IN,,
	GL	GDB3IN
	EI	:T2GATE

 

:       do buffer histogram at end of moving data so that histogram is a
:       record of data left after the moving is complete.

	IF	REBILD
	L	R1,HBFTSV		:GET CURRENT CHAR CNT IN HIST BUFS#OAS
	C	R1,HBFTMX		:NEW PEAK			###OAS
	JLEFS	BIDBL2			:NO				###OAS
	ST	R1,HBFTMX		:YES, UPDATE MAX		###OAS
BIDBL2	HS	0
	EI	:REBILD

	L	R1,BFLTSV		:GET CURRENT COUNT OF BUFFERLETS IN USE
	C	R1,BFLTMX		:NEW PEAK?
	JLEFS	SPD5			:NO
	ST	R1,BFLTMX		:YES, STORE NEW PEAK
SPD5	LIS	R2,1
	SRL	R1,ISCALE		:SCALE DOWN ACCORDING TO TOTAL B'LETS
        NHI     R1,07
	GL	ISCALE			: ALLOCATED
	AHM	R2,BFLTHS,R1,R1		:INCREMENT APPROPRIATE CELL
      IF        tii.fg                  :put a foreground governor on switch
        TS      GOVSWI                  :oonly do switch 40 times a second
        JNFS    SPD6                    :skip switch this time          ###sdw
      EI        :tii.fg                 :                       1/14/87 ###sdw

	LHI	R1,01F-PSWICH		:SCHEDULE SWITCH
	SBT	R1,SQUEUE
SPD6	LA	R0,SPIDER
	J	EXDIS			:AND RETURN TO EXEC LOOP

SWIRET	HS	0			:SWITCH RETURNS HERE
	IF	DB.DEB
	L	R0,ALINKS		:ANY ACTIVE LINKS?
	JNFS	SPIDE2			:YES
	L	R0,FASTC,,		:NO - DON'T WANT RMAKE HIGH-WATER MARK
	ST	R0,RMKTIM		: BASED	ON NO LINKS ACTIVE...
	EI	:DB.DEB

SPIDE2	LA	R0,SWITCH,,
	J	EXDIS			:RETURN TO EXEC LOOP

	SUBTTL 	EXEC (Periodic processes)
::**********************************************************************
::
::	PROCESS:	G250MS
::	FUNCTION:	QUARTER SECOND APPLY BACKPRESSURE MESSAGE
::
::**********************************************************************

G250MS	HS	0
       IF APLYBP
	JAL	R10,APMX,,
	GL	APMX
	LA	R0,G250MS
       EI	:APLYBP

	J	EXDIS
:       Give enough len to allow RX3 to patch area to allow patch run 1/4 sec
        HS      1               :since does not reschedule itself no overhead
                                :and a patch could be added which runs 1/4 sec
                                :                                       ###sdw

::*********************************************************************
::
::	PROCESS:	G500MS:
::	FUNCTION:	HALF-SECOND LOGIC
::
::*********************************************************************

G500MS	HS	0
	JAL	R10,CKOVLD,,		:CHECK FOR OVERLOADED LINKS
	GL	CKOVLD
	JAL	R10,BPMX,,		:SYNC-LINE BACKPRESSURE
	GL	BPMX
       if       1-swtchr
	JAL	R10,DISBPS,,
	GL	DISBPS	
       ei       :1-swtchr
	JAL	R10,LNXDUM		:FORCE XMISSION OF DUMMY RECS
	GL	LNXDUM

	LHL	R0,XRYRUN		:DOES XRAY WANT TO DUMP OUTPUT?
	JEFS	G500M1			:NO
	LHI	R0,01F-PXRAY		:YES, SCHEDULE IT
	SBT	R0,SQUEUE
	LHL	R0,XUSIUA		:PUT EVERY XRAY USER
	STH	R0,XQUEM		:INTO THE QUEUE
G500M1	HS	0
        L       R8,XDDTAD               :XDDT job wants us to do something#sdw
        JEFS    G500M2                  :nothing to do
        JAL     R11,XWRITE,,            :allow XRAY routine to write to data
        JALR    R8,R8                   :go on R8 and put return in R8
        JAL     R11,XPRTKT,,            :restore write protection
        GL      XWRITE,XPRTKT
        LIS     R0,0                    :clear address
        ST      R0,XDDTAD               :did the job
G500M2  HS      0
	IF	DB56KB
	JAL	R10,KB56DB		:CHECK ON SIO LINES EVERY 1/2 SEC
	EI	:DB56KB
	LA	R0,G500MS		:NECESSARY BECAUSE BPMX MODIFIES QEXEC
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G01SEC:
::	FUNCTION:	ONE SECOND LOGIC
::
::*********************************************************************

G01SEC	HS	0

:       Have sio only send 1 resets packets per second.  Logic is to set a
:       a bit every second which is reset whenever a reset packet is sent
:       and the reset packet can only be sent when the bit is sent.     ###sdw
        LIS     R1,LNSIZE-4     :LNSIZE is bit array size (rounded to words)
        LCS     R0,1
G01PRS  ST      R0,SIORPC       :pace resets
        SIS     R1,4
        JGEBS   G01PRS

:       check if ready to switch back from old style reset to expanded resets
        JAL     R10,ESRLIN
        GL      ESRLIN                  :                               ###sdw

:       SPAM issues SVC immediately after value changes                ###sdw
        IF      SPAM                                                    ###dmj
        LH      R0,SPMINI               :GET SPAM INITIALIZE FLAG       ###dmj
        JN      SPMXIT                  :SKIP IF ALREADY INITIALIZED    ###dmj
        L       R0,SLOWC,,              :FETCH CURRENT FASTC TIME       ###dmj
        C       R0,SPSYNC               :TIME TO SYNCHRONIZE SPAM?      ###dmj
        JL      SPMXIT                  :NO, NOT YET                    ###dmj
        LA      R0,NS.PCO,,             :Address of physical CPS stats  ###dmj
        SVC     SYS,$A 53               :Inform Kernel of address       ###dmj
        HC      0,0                     :Immediate return - invalid addr###dmj
        LCS     R0,1
        STH     R0,SPMINI               :SET SPAM INITIAILIZED FLAG     ###dmj
SPMXIT  EQ      .                       :                               ###dmj
        EI      (SPAM)                  :                               ###dmj
	L	R0,SLOWC,,
	C	R0,MTRTIM		:RUN PERFORMANCE MEASUREMENT LOGIC?
	JL	G01PER			:NO
GOPFM	HS	0	
	SYAD(GOPFM )
	AHI	R0,$A60			:YES, 60 SECONDS FROM NOW
	ST	R0,MTRTIM
	JAL	R10,EXCAVG		:COMPUTE EXEC LOOP AVERAGE
	JAL	R10,MTRFIC,,		:MEASURE LINK TRAFFIC
	GL	MTRFIC
	JAL	R10,MPRTIM		:MEASURE TIME SPENT IN EACH PROCESS
	JAL	R10,LKVOLT		:TEST FOR LINKS OVERLOADED
	GL	LKVOLT
:	SCHEDULE LDRPRT SYNCHRONOUSLY WITH MTRFIC FOR KS PKT STATS	###JHL
:	LDRINT is a Tymfile parameter when can be used to specify
:	line diagnostic reporting interval in testing environment.
	DEFAULT(LDRINT,4)		:LDRINT Tymfile parameter	###wjl
	LIS	R0,1			:SCHEDULE LDRPRT EVERY LDRINT MINS.
	AHM	R0,LDRTIM		:BUMP THE COUNTER
	JL	G01PER			:STILL NEG--DON'T RUN LDRPRT
	LCS	R0,LDRINT		:REINIT THE SCHEDULING CELL	###wjl
	STH	R0,LDRTIM		:STORE A MINUS LDRINT THERE
	JAL	R10,LDRPRT		:RUN LINE DIAGNOSTICS
	GL	LDRPRT
:	LDRPRT WAS SCHEDULED FROM G04MIN BEFORE 5.02			###JHL
G01PER	HS	0
	L	R1,LINSPT
	JEFS	G01PE1
	NI	R1,SYNLNA		:NO SIO LINES
	JEFS	G01PE1
	ST	R1,LINSPD		:ALERT SYLVER TO PREFORM LINE SPEED
					: CALC'S FOR LINES REQUESTED
	LIS	R1,0			:RESET SPEED REQUEST BITS
G01PE1	ST	R1,LINSPT
	LIS	R1,1
	AM	R1,S1SLOC		:INCREMENT OCCURRENCES OF 1-SEC LOGIC
	LHL	R1,S1SLOC+2

:	CONSOLE OUTPUT IS DONE IN ISIS KERNEL
      IF	1-NAD68			:no CONSOL display for 68K envir###wjl
	THI	R1,3			:EVERY 4 SECONDS WANT TO FLASH 'MACHID'
	JN	G01SE0			:..NOT THIS TIME		###wjl
	IF	(1-T2GATE)		:				###wjl
	LHL	R0,MACHID		:HO digit of node number	###wjl
	STB	R0,KDISP+1		:ISIS ver 5 (and for us)	###wjl
	SVC	SYS,$A40		:				###wjl
	EI	:(1-T2GATE)		:				###wjl
	LI	R0,0A0000		:SWITCHER DISPLAYS A 'A'
	ST	R0,CONSOL+4
	L	R0,MACHID		:MAN-READABLE HOST, NODE NUMBER DISPLAY
	J	G01SE2			:DISPLAY COMPUTED, BRANCH

G01SE0	LHL	R0,CRHCNT		:COMPUTE CONSOLE DISPLAY
	THI	R0,0FFF0		:CRASH COUNT GREATER THAN 15D?
	JEFS	G01SE5			:NO
	LIS	R0,0F			:YES, JUST DISPLAY 15D
G01SE5	SLHLS	R0,4			:SHIFT UP ONE NIBBLE
	LH	R1,TVRSUP
	EXHR	R1,R1
	ST	R1,CONSOL+4		:STORE SUP NUMBER FOR CONSOL DISPLAY

	IF	1-T2GATE		:Gateway has no Kernel I/O	
	LHL	R1,KDISP
	ELSE	:NOT (1-T2GATE)
	LHL	R1,CONSOL+2
	EI	:1-T2GATE
	THI	R1,0F
	JNFS	G01SE1

	IF	SUPER			:EVERY 4 SEC UPDATE NETWORK STATUS
	AH	R0,TVRSTT		: DISPLAY
	ELSE	:not SUPER
	AIS	R0,1
	LH	R1,TVRSUP		:IS NODE IN THE NET?
	JEFS	G01SE1			:NOT IN NET
	AIS	R0,1			:STATUS OF '2' FOR NODE IN THE NET
	EI	:SUPER

G01SE1	HS	0
	LB	R1,HNPORT+1		:NUMBER OF TERMINATIONS ON KERNEL HOST
	EXBR	R1,R1			:INCLUDE TERMINATIONS
	OR	R0,R1			: IN WORKING DISPLAY
	LHL	R1,PASTHR
	EXHR	R1,R1			:# PASSTHROUGHS IN HIGH-ORDER HALFWORD
	OR	R0,R1			: OF CONSOLE DISPLAY
	IF	(1-T2GATE)		:Gateway does not use		
	SVC	SYS,$A40		:DISPLAY CRASH COUNT, STATUS
	STB	R0,KDISP+1		:CRASH COUNT, NET STATUS FLASHER
	SRLS	R0,8			:PASSTHRU, PORT COUNTS TO LO-ORDER HW
	EI	:(1-T2GATE)
G01SE2	ST	R0,CONSOL		:CONSOLE OUTPUT DONE IN 'SCHED' ROUTINE
					:IF NOT ISIS, ELSE HANDLED BY ISIS KERN
      EI	:1-NAD68

:: Two timers are implemented, one to check the login, the other to check
:: if needle is sent to the X25 slot or Tymnet reset packet sending time-out
:: If not, set TUNBLD array and reschedule LINKER or resend needle or Reset.
	IF	TUNL			:TYMTUNNEL CHECK LOGIN TIMER	###AL
	LIS	R1,0			:TUNNEL# AS INDEX
G01TN0	L	KD,TNLPTR,R1,		:CHECK EACH TUNNEL KD
	JEFS	G01TN1
	L	R2,TNLGTM,KD		:TIMERS FIELD, TNLGTM AND TNSDTM
	JNFS	G01TN2
G01TN1	AIS	R1,4			:NEXT KD
	CHI	R1,NMTNLS*4
	JLBS	G01TN0
	J	G01SE3			:DONE
G01TN2	LR	R0,R2
	NI	R0,0FFFF		:MASK TO TNSDTM
	JEFS	G01TN3
	LHL	R8,SLOWC+2,,		:COMPARE WITH CURRENT SLOW CLOCK
	CR	R0,R8
	JLE	G01TN4			:TNSDTM TIME-OUT
G01TN3	EXHR	R2,R2
	NI	R2,0FFFF		:MASK TO TNLGTM
	JE	G01TN1
	LHL	R8,SLOWC+2,,		:COMPARE WITH CURRENT SLOW CLOCK
	CR	R2,R8
	JG	G01TN1			:TNLGTM IS NOT TIME-OUT
	LIS	R0,SVCPVC		:IF PVC, SET TUNBLD
	TBT	R0,TNSTAT,KD
	JNFS	G01T22
	LIS	R0,ORGDES		:IF ORIGINATION NODE, SET TUNBLD
	TBT	R0,TNSTAT,KD
	JNFS	G01T23
G01T22	SRLS	R1,2			:INDEX/4
	SBT	R1,TUNBLD		:TIME-OUT, SET THE BIT & TRY AGAIN
G01T23	LHL	CHN,TNCHN,KD		:IF TUNNEL CHN IS THERE
	JE	G01T33
	LIS	R0,0			:RESET TNCHN AND DIOTAB
	STH	R0,TNSDST,KD		:RESET TUNNEL SEND STATES
	RBT	CHN,DISFLG
	STH	R0,TNCHN,KD
	STH	R0,DIOTAB,CHN,CHN
	LHI	R0,DISZFL,CHN		:REPORT CRQ ZAPPED
	SBT	R0,ACP			:PORT INACTIVE
	RBT	R0,CHS			:SUSPEND THE PORT FOR 30 SECONDS
	SBT	R0,CHS1
	LCS	R8,1
	SR	R8,R0
	SBT	R8,ACP
	RBT	R0,CHS			:SUSPEND THE PORT FOR 30 SECONDS
	SBT	R0,CHS1
	JAL	R8,CRYPTO,,
	HC	CRYE0C
	LIS	R0,4			:SEND ISIS ZAPPER 1ST TO CLEAR
	JAL	R8,DIROOM,,		: THE OLD PORT, FIND ROOM
	GL	DIROOM
	EXHR	CHN,CHN
	OI	CHN,9F00		:RPORT,9F00
	LHL	PRD,DRIF,,
	ST	CHN,DIRNG,PRD,
	AIS	PRD,4
	STH	PRD,DRIF,,		:STORE BACK THE POINTER
G01T33	LHI	R0,1F-PLINKR		:SCHEDULE LINKER
	SBT	R0,TLINKR
	SLLS	R1,2
	J	G01TN1			:NEXT KD
G01TN4	LIS	R0,TNLCPL		:IF TUNL IS COMPLETE, IT'S RESET TIMER
	TBT	R0,TNSTAT,KD
	JEFS	G01TN6
	LIS	R0,SDTRST		:RESET TIME-OUT SET THE BIT AGAIN
	SBT	R0,TNSDST,KD
	J	G01TN3
G01TN6	LB	R0,SNERCT,KD		:CHECK SENDING NEEDLE RETRY COUNT
	CHI	R0,SNETCT		:UNTIL A THRESHOLD
	JL	G01TN7
	LR	R4,R1			:SAVE R1
	EXHR	R0,R0
	OI	R0,XDNRTY		:report CRYPTO, retry fails
	TNCRYP(81)
	LR	R1,R4			:RESUME R1
	LH	R0,SLOWC+2,,		:set a bigger timer and try again
	AHI	R0,TNLTMR		:use TNLGTM
	STH	R0,TNLGTM,KD
	J	G01TN3
G01TN7	LIS	R0,SVCPVC		:SVC ORIGINATN NODE SETS TUNBLD
	TBT	R0,TNSTAT,KD
	JNFS	G01TN8			:PVC ALSO SETS TUNBLD
	LIS	R0,ORGDES
	TBT	R0,TNSTAT,KD
	JN	G01TN3
G01TN8	SRLS	R1,2			:INDEX/4
	SBT	R1,TUNBLD		:TIME-OUT, SET THE BIT & TRY AGAIN
	LHI	R0,1F-PLINKR		:SCHEDULE LINKER
	SBT	R0,TLINKR
	SLLS	R1,2
	J	G01TN3			:BACK TO CHECK THE OTHER TIMER
	GL	TNLPTR
	EI	:TUNL

G01SE3	LA	R0,G01SEC
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G02SEC:
::	FUNCTION:	TWO-SECOND LOGIC
::
::*********************************************************************

G02SEC	HS	0
	JAL	R10,G02SLK		:TEST FOR INOPERATIVE LINES
	GL	G02SLK
       if       swtchr                  :if no isis slots
        lhl     r0,drof,,
        sth     r0,droe,,               :empty the ring (some error message?)
        ei      :swtchr
	IF	SILINS
	JAL	R10,SIOIZ		:SEE IF ANY SIO LINES NEED
	GL	SIOIZ			: INITIALIZATION
	EI	:SILINS
:	UPDATE GUSH AND TRIKLE ARRAYS. TRIKLE GETS OR'D INTO GUSH
:	AND THEN CLEARED.
       if       1-notrik                :don't do trickle logic
	LIS	R0,0
	LHI	R1,-TCHANS/8
G02SC1	L	R2,EGUSH,R1,
	O	R2,ETRIKL,R1,
	ST	R2,EGUSH,R1,		:GUSH = GUSH + TRIKLE
	ST	R0,ETRIKL,R1,		:CLEAR TRIKLE
	AIS	R1,4
	JLBS	G02SC1
       ei       :1-notrik

G02BL2	LIS	R0,0			:UPDATE BUFFERLET USAGE HISTOGRAMS
	LHI	R1,2*NSTEPS-2		:HW INDEX FOR UP TO 8 SAMPLES OF BFLTHS
G02BL1	LHL	R2,BFLTHS,R1		:GET NEXT HISTOGRAM
	STH	R0,BFLTHS,R1		:CLEAR LITTLE HISTOGRAM
	AM	R2,BFLTHG,R1,R1		:AND ADD INTO BIG HISTOGRAM
	JLFS	G02BLT			:HISTOGRAM WRAPPED, CLEAR IT
	SIS	R1,2			:DECREMENT INDEX
	JGEBS	G02BL1			:AND REPEAT
	J	EXDISM

G02BLT	LHI	R1,2*NSTEPS-2		:CLEAR OUT BIG HISTOGRAM
        GL      NSTEPS
G02BL3	ST	R0,BFLTHG,R1,R1
	SIS	R1,2
	JGEBS	G02BL3
	J	EXDISM

::*********************************************************************
::
::	PROCESS:	G04SEC:
::	FUNCTION:	4-SECOND LOGIC
::
::*********************************************************************

G04SEC	HS	0

	JAL	R10,LNCHCK		:CHECK FOR NO RECORDS RECEIVED
	GL	LNCHCK


:	Check if LEP requested a Down Load (go to boot)
      IF	1-NAD68			:no down load (go to boot) for 68K##wjl
	IF	1-T2GATE		:no down line loading for GW
	LH	R0,DLDFLG		:DID LEP REQUEST A NODE BOOT?
	JGE	G04S00			:NO
	SIS	R0,1			:DECREMENT FLAG
	STH	R0,DLDFLG		:AND RESTORE IT
	AIS	R0,2			:FIRST TIME G04SEC HAS NOTICED THIS?
	JEFS	G04S00			:YES, DEFER BOOT FOR NEXT 4-SEC PERIOD
	LIS	R0,0			:FLAG MUST HAVE BEEN -2...CLEAR IT
	STH	R0,DLDFLG
	SVC	SYS,$A39
	EI	:1-T2GATE		:##al
      EI	:1-NAD68

G04S00
G04SE1	LA	R0,G04SEC
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G08SEC:
::	FUNCTION:	8-SECOND LOGIC
::
::*********************************************************************

G08SEC	HS	0
	IF	SUPER
	JAL	R10,G08SUP,,		:TEST FOR LAZY SUPER
	GL	G08SUP
	EI	:SUPER
	IF	SIORNG
	JAL	R10,SIRSCK,,		:REPORT KERNEL HOST DOWN
	GL	SIRSCK			: IF SIO RING FAILS
	EI	:SIORNG
	IF	BFLTMR			:buffer delay timing by spec char pairs
	LHL	R0,BFDSCH,,		:###JHL
	SIS	R0,1			:decrement scheduling cell
	JGFS	G08S10			:spring when reaches zero, and reset it
	JAL	R10,BFRUPD		:update the channel array
	GL	BFRUPD			: for sending pairs
	LIS	R0,BFDFRQ		:reset to top value
G08S10	STH	R0,BFDSCH,,		:store current value
	EI	:BFLTMR			:###jhl
	IF	T2GATE
:       don't count port 0 when counting dispatcher ports               ###sdw
	LHI	R5,DISZFL+1		:Start at dispatcher range
	LHI	R1,NDP-1		:and check all the dispatcher ports
	JAL	R10,CNTPRT,,		:Count available ports	###ev
	GL	CNTPRT
	STH	R3,GAVPTS		:and store new available port count
        LB      R1,G0DFG                :have Inet supe?
        JEFS    G08S22                  :nope
        LHL     R1,TVRBUF               :have Hnet supe?
        JN      G08S23                  :skip if yes
G08S22  LIS     R3,2                    :save host is shut
        CLB     R3,HSTAT                :what was old status
        JE      G08EXI                  :nope already reported shut
        STB     R3,HSTAT                :save new
        JAL     R10,GHSTST,,            :report as shut
        JAL     R10,SUP11,,             :to both supes
        GL      SUP11
        JFS     G08EXI
G08S23	JAL	R10,GCKPST,,		:report msg to disp. port 0
	GL	GCKPST			: (Inet sup) if changed. Report
G08EXI
	EI	:T2GATE##AL		: to Inet sup if out of port.
	LA	R0,G08SEC
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G30SEC:
::	FUNCTION:	30-SECOND LOGIC
::
::*********************************************************************

G30SEC	HS	0
	JAL	R0,CHSUPD,,		:UPDATE CHS ARRAY
	GL	CHSUPD
	JAL	R10,DETOUT,,		:CHECK DETACHED PORTS
	GL	DETOUT
	J	EXDISM

::*********************************************************************
::
::	PROCESS:	G01MIN:
::	FUNCTION:	1-MINUTE LOGIC
::
::*********************************************************************

G01MIN	HS	0
	LHL	R0,FASTC+2,,		:MEASURE INTERVAL, 1-MIN EXECUTIONS
	LHL	R1,MINSAV
	STH	R0,MINSAV
	SR	R0,R1
	JGEFS	G01MI2
	AI	R0,10000
G01MI2	STH	R0,MININT
	LHI	R0,-NR.DGN*6		:RE-INIT NETDGN COUNTER WHICH THROTTLES
	ST	R0,NETDCT		:DIAG NODE REPORTS (NR.DGN) AT 6/MIN
	JAL	R10,G01MLS		:REINSTATE SUSPENDED LINES
	GL	G01MLS
	JAL	R10,CRTOUT,,		:PROCESS CIRCUIT TIMEOUTS
	GL	CRTOUT
	IF	REBILD
	JAL	R10,RBDOUT,,		:REBUILD TIME-OUT		###GT
	GL	RBDOUT
	EI	:REBILD
:	CLEAR ACTIVITY COUNTERS
	LIS	R0,0
	IF	(1-T2GATE)		:Exclude for Gateway
	LHI	R1,(NUSLT-1)*2		:            			###LH
G01MI4	STH	R0,SCLCNT,R1		:CLEAR CIRCUITS/MINUTE COUNT FOR SLOT
	STH	R0,SMLCNT,R1		:CLEAR SLOT REPORTS/MIN COUNT FOR SLOT
	SIS	R1,2
	JGEBS	G01MI4
	EI	:(1-T2GATE)		:end exclude, Gateway
	IF	RESHST
	LHI	R1,(NHOSTS-1)*2
G01MI6	STH	R0,HCTSCT,R1		:CLEAR CIRCUITS/MINUTE COUNT FOR HOST
	SIS	R1,2
	JGEBS	G01MI6
	LHI	R1,(((NHOSTS+0F)/10)*2)-2
G01MI8	STH	R0,RESHMS,R1		:CLEAR ARRAY WHICH THROTTLES NODE RPTS
	SIS	R1,2
	JGEBS	G01MI8
	EI	:RESHST
	LA	R0,G01MIN
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G02MIN:
::	FUNCTION:	TWO-MINUTE LOGIC
::
::*********************************************************************

G02MIN	HS	0
	JAL	R10,SUP0B,,		:send Resources Report to Sup	###wjl
	GL	SUP0B
	IF	SIORNG
:	IF SIO RING DOWN, PERIODICALLY RE-INITIALIZE
	LH	R0,SIRFLG		:SIO RING STATUS FLAG
	JNFS	G02M10			:NON-ZERO IF SIO RING UP
	LIS	R0,2
	STH	R0,SIRXIZ		:FORCE INITIALIZATION IN 'KERIPS'
G02M10	EI	:SIORNG
:	TEST FOR RECENT TAKEOVER. WE WANT TO REPORT NODE'S LINE RESOURCES
:	2 - 4 MINUTES FOLLOWING TAKEOVER...
	LH	R0,TAKOVR		:CELL SET NEGATIVE WHEN TAKEN OVER
	JE	G02MEX			:NO RECENT TAKEOVERS
	JGFS	G02M20			:2 - 4 MINUTES AGO, MAKE REPORTS
	LIS	R0,1			:0 - 2 MINUTES AGO, SET CELL POSITIVE
	STH	R0,TAKOVR		: FOR NEXT TIME
	J	G02MEX

G02M20	LIS	R0,0
	STH	R0,TAKOVR
	LHL	R0,TVRBUF		:GOT A SUP?
	JE	G02MEX			:NO - DON'T BUFFER THESE...
:	MAKE NODE REPORT TO INDICATE NUMBERS OF--SIO LINES, SYNC LINES,
:	XLINKS, AND TOTAL LINKS.
	LI	R0,(SILINS^18)+((NLINES-SILINS)^10)+(XLINKS^8)+(NLINKS)+80808080
	ST	R0,SUPMBF+2
	LHI	R0,NR.SSX		:REPORT TYPE - NETWORK RESOURCES
	STH	R0,SUPMBF
	JAL	R10,SUP12,,
	GL	SUP12

:	NOW REPORT PORTS AND PASSTHROUGHS
	LI	R0,(NDP^10)+(NPTHR)+80008000
	ST	R0,SUPMBF+2
	LHI	R0,NR.PPT
	STH	R0,SUPMBF		:REPORT TYPE - PORTS AND PASSTHROUGHS
	JAL	R10,SUP12,,
:	REPORT UNUSED LINES...BIT ARRAY, 0 BIT FOR UNUSED
	LCS	R0,1
	ST	R0,SUPMBF+2		:ASSUME ALL LINES USED
	LHI	LN,NLINES-1
G02M22	LHL	R0,NGSVLN,LN,LN
	JNFS	G02M24			:LINE USED
	RBT	LN,SUPMBF+2		:INDICATE THIS LINE UNUSED
G02M24	SIS	LN,1
	JGEBS	G02M22
	LHI	R0,NR.UNL
	STH	R0,SUPMBF		:UNUSED LINES REPORT
	JAL	R10,SUP12,,
:	REPORT FOR EACH USED LINE:
:		HWXSSSSSLLLLLLLLUNNNNNNNNNNNNNNN
:	WHERE H = 1 FOR SIO LINES, 0 FOR SYNC
:	W = 1 FOR T-I WS8
:	X = 1 FOR SATELLITE LINK, 0 FOR TERRESTRIAL
:	SSSSS = LINK SPEED
:	LLLLLLLL = LINE NUMBER
:	U = 1 IF LINE UP, ELSE 0
:	NNNNNNNNNNNNNNN = NEIGHBOR NUMBER
	LHI	LN,NLINES-1
G02M30	LHL	R0,NGSVLN,LN,LN
	JE	G02M50			:LINE UNUSED
	STH	R0,SUPMBF+4		:NEIGHBOR, + 8000 IF UP
	SLLS	LN,1
	L	KD,KDLN,LN,LN		:GET LINK DESCRIPTOR
	JGFS	G02M32			:LINK UP
	SRLS	LN,1
	LHI	R0,80			:LINK NOT UP, ASSUME SIO LINE
	JFS	G02M34
G02M32	SRLS	LN,1
	LB	R0,KSPD,KD		:LINK TYPE, SPEED + 80
G02M34	LHI	R1,-(NLINES-SILINS),LN
	JGEFS	G02M40			:SIO LINE
	NHI	R0,7F			:SYNC LINE, TURN OFF HI-ORDER BIT
G02M40	EXBR	R0,R0
	OI	R0,(NR.LNR^10)+80,LN	:NODE REPORT TYPE, LINE # + 80
	ST	R0,SUPMBF
	JAL	R10,SUP12,,
G02M50	SIS	LN,1			:DO FOR ALL LINES
	JGE	G02M30
:	REPORT TIILNK NEIGHBORS NOT UP...SAME FORMAT AS ABOVE, BUT THE
:	LINE NUMBER FIELD IS -1.
	LHI	KN,NLINKS-1
G02M60	SLLS	KN,1
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR ADDRESS
	SRLS	KN,1
	GL	KDKN
	LHL	R0,ONDID,KD		:IS THIS AN XLINK?
	JE	G02M70			:YES - IGNORE
	LB	R1,NLAT,KD		:IS LINK UP?
	JNFS	G02M70			:YES - DON'T REPORT
:	GOT TIILNK LINK WITH NO LINES ATTACHED - REPORT IT
	STH	R0,SUPMBF+4		:NEIGHBOR NUMBER
	LB	R1,KSPD,KD		:MAYBE LINK SPEED ALREADY DEFINED
	EXBR	R1,R1
	OI	R1,(NR.LNR^10)+0FF	:REPORT TYPE, LINE # FF
	ST	R1,SUPMBF
	JAL	R10,SUP12,,		:MAKE NODE REPORT
G02M70	SIS	KN,1
	JGE	G02M60			:DO FOR ALL LINKS
G02MEX	HS	0
	LA	R0,G02MIN
	J	EXDIS

::*********************************************************************
::
::	PROCESS:	G04MIN:
::	FUNCTION:	FOUR MINUTE LOGIC
::			CALLS LINE DIAGNOSTIC REPORTING PROCESS AND
::			TESTS INTERNAL HOST CRQS FOR TIMEOUTS
::
::*********************************************************************

G04MIN	HS	0
	JAL	R10,CKTCON,,		:TEST FOR CIRCUIT BUILDING ERRORS
	GL	CKTCON
:       send old style resets on inactive lines to bring up stubborn 5.10
:       neighbors                                                       ###sdw
        JAL     R10,OSRLIN              :send old style resets
        GL      OSRLIN
	JAL	R11,INTTIM,,		:CHECK TIMEOUT ON INTERNAL HOST PORTS
	GL	INTTIM
      IF	1-NAD68			:not in 68K environment		###wjl
	JAL	R11,TEMPRP,,		:TEST FOR TEMP IN ACCEPTABLE RANGE#JHL
	GL	TEMPRP
      EI	:NAD68

:	PERFORM ACCOUNTING - EVERY 20 MIN FOR GATEWAY
	IF	T2GATE&ACCT			:GATEWAY accounting
	LHL	R0,AA20MN		:Is it time for 20 minute accounting?
	JEFS	G20MIN			:Yes
	AIS	R0,1			:No, Decrement counter (yes decrement!)
	STH	R0,AA20MN
	J	EXDISM			:Dismiss to Exec loop
G20MIN	HS	0			:Accounting 20 minute report
	LCS	R0,4			:Init counter to -5
	STH	R0,AA20MN
	JAL	R11,AATIME,,		:Perform periodic accounting
	GL	AATIME
	J	EXDISM			:Dismiss to Exec loop

	ELSE	:NOT CONSAT OR GATEWAY

	J	EXDISM			:Dismiss to Exec loop

	EI	:CONSAT OR GATEWAY	

	SUBTTL  EXEC (Utility routines)

::*********************************************************************
::
::	SUBROUTINE:	BCMOVE:
::	FUNCTION:	MOVE N BYTES OF DATA FROM SOURCE TO DESTINATION
::	CALLING SEQ:	JAL	R8,BCMOVE
::	INPUT:		R1 = SOURCE ADDR
::			R2 = DESTINATION ADDR
::			R3 = BYTE COUNT
::	DESTROYED:	R0 = SCRATCH
::
::*********************************************************************

BCMOVE	HS	0
	LB	R0,0,R1			:MOVE BYTES
	AIS	R1,1
	STB	R0,0,R2
	AIS	R2,1
	SIS	R3,1
	JGBS	BCMOVE
	JR	R8

::*********************************************************************
::
::	SUBROUTINES:	HCLEAR:/HCSET:
::	FUNCTION:	SET N HALF-WORDS TO ZERO OR TO CONTENTS OF R0
::	CALLING SEQ:	R8 = LINK
::	INPUT:		R0 = CONSTANT
::			R1 = DESTINATION ADDR
::			R2 = HW COUNT
::
::*********************************************************************

HCLEAR	LIS	R0,0
HCSET	STH	R0,0,R1			:SET HALF-WORDS
	AIS	R1,2
	SIS	R2,1
	JGBS	HCSET
	JR	R8


::*********************************************************************
::
::	SUBROUTINE:	AAINIT:
::	FUNCTION:	Routine to initialize accounting block pointers array
::	CALLING SEQ:	JAL	R8,AAINIT
::	DESTROYED:	R1,R2
::
::*********************************************************************

	IF	ACCT			
AAINIT	HS	0
	LHI	R2,(NACCTS-1)*4		: Number of addresses to be loaded
	LA	R1,AABLKS,,		: Start of block storage area
AAIN1	ST	R1,AABPNT,R2		: Store it, last first
	AHI	R1,AADSIZ		: Advance the pointer
	SIS	R2,4			: Move to next table entry
	JGEBS	AAIN1			: Repeat for entire table
	JR	R8
	EI	:ACCT			

::*********************************************************************
::
::	SUBROUTINE:	BIDDY:
::	FUNCTION:	MAGIC BID, DISPATCH, AND YIELD ROUTINE
::	CALLING SEQ:	GBIDDY(count,addr,proadr)
::			RETURNS HERE IF DATA=0
::
::	GBIDDY	MACRO(count,addr,proadr)	[
::		GL	ADDR
::		GL	BIDDY
::	Q	LHI	R4,COUNT	:size of array in bytes
::		LA	R3,ADDR,,	:array address
::		JAL	R9,BIDDY,,
::		SKIPAD(PROADR)		:processing routine
::		HC	Q/10000,Q&0FFFF	:avoid boundary problem
::		]
::	OUTPUT:		R2 = INDEX
::	RETURNS:	IMMEDIATE - dispatch to processing routine
::			+4 - not a return, but a constant address for
::			     reentry after yield
::			+8 - no bits set in array, data = 0
::
::*********************************************************************

BIDDY	HS	0
	ST	R9,BIDDSV		:SAVE RETURN ADDR

	LIS	R5,0			:R5 = BYTE COUNT
BIDD2	L	R1,0,R3
	JFFO	R1,BIDDY2		:FIND FIRST BIT SET IN R1
	AIS	R3,4
	AIS	R5,4
	CR	R5,R4	
	JL	BIDD2
	J	8,R9			:NO BITS SET IN ARRAY, SKIP RETURN#wjl
BIDDY2	RBT	R2,0,R3			:BIT FOUND
	SLLS	R5,3			:FORM INDEX in R2
	OR	R2,R5
	SKIP(0,R9)			:immediate return		###wjl

:	ENTRY POINT - RETURN FROM DISPATCH
BIDDRT	HS	0
	L	R9,BIDDSV		:get the saved return addr	###wjl
	L	R0,4,R9			:serve next customer by loading	###wjl
					: constant address.  See GBIDDY MACRO!
	J	EXYLD			:EXEC RETURNS TO INST PRECEDING CALL

	SUBTTL	EXEC (OOPS - Software error handler)

SVC1ER	TI	R0,0C00			:TEST FOR H-WARE
	JR	R0			:IGNORE IF TRUE
	JAL	R0,OOPS			:ELSE KAPUT

::*********************************************************************
::
::	SUBROUTINE:	OOPS:
::	FUNCTION:	Software error handler
::	CALLING SEQ:	CALL TO OOPS IS SET UP BY THE CRASH MACRO.
::			CALL TO OOPS WILL BE RX1/2 OR RX3 AS REQUIRED.
::	THE CRASH DATA ARE SET UP BY THE CRASH MACRO TO FOLLOW IMMEDIATELY THE
::	JAL,OOPS, AND CONSIST OF 1 OR 2 HW'S, AS FOLLOW:
::		FIRST HW = xxyy
::		WHERE: xx IS A 7-BIT (EVEN) SUBTYPE CODE, WITH THE LO BIT SET
::			IF ANY SPECIAL REGISTERS WERE SPECIFIED IN THE CRASH
::			MACRO CALL.
::			yy IS AN 8-BIT COMMON CRASH CODE
::		2ND HW = aabb ONLY IF THE LO BIT OF xx IS SET.
::			 ELSE IT ISN'T THERE.
::		WHERE: aa AND bb ARE REGISTER NO'S*4
::			aa IS ALWAYS MEANINGFUL
::			bb IS MEANINGFUL ONLY IF NON-0.
::		WE ALWAYS SAVE BOTH REGISTERS JUST BECAUSE IT TAKES LESS CODE.
::
::*********************************************************************

OOPS	HS	0
	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl
	LIS	R1,1			:STOP TRACER HARD
	STH	R1,TRCRRQ,,
	EI	:DB.TRC
	ST	R0,CRSHAD		:Save crash address
	LR	R1,R0			:Get crash address to index register
	LHL	R1,0,R1			:Get offset to crash code
	LHL	R1,CRCDTB,R1,		:Crash code
	GL	CRCDTB
	STH	R1,CRSHID		:Save crash code
					:Continue...fall through
        jfs     sfail1

:	GET HERE FROM 'FAIL' FOR FAULTS DETECTED BY THE ISIS DISPATCHER
:	OR KERNEL, OR FALL THROUGH FROM 'OOPS'. SAVES REGISTERS,
:	COPIES POSSIBLE UPSW TRACE DATA TO 'TRSTAB', AND RESTARTS NODE
:	IF CRSTOP=0.  
SFAIL	HS	0
	STM	R0,ERRREG		:SAVE ALL REGISTERS
sfail1	JAL	R9,GMTCAL,,		:RETURNS CURRENT TIME (GMT+FASTC)
	GL	GMTCAL			: IN GMTNOW
	L	R2,GMTNOW
	ST	R2,CRSHTM		:SAVE IT
	JAL	R10,CTENTR		:MAKE CRASH TABLE ENTRIES
	UPSW	NOTRAC			:INSURE TRACE NOT ON, PROCEED AT SFAIL2

:	ENTRY POINT FOR MAC ERRORS AND ILLEGAL INSTRUCTIONS DETECTED BY
:	THE PRIVELEGED CODE IN A SOLO MACHINE.

SFAIL2	HS	0
	L	R0,CRSHAD		:CRASH ADDR IN HW2&3 OF CRYPTO REPORT
	ST	R0,CRYSBF
	LHL	R0,CRSHID		:CRASH ID IN HW1
	JAL	R8,CRYPTO
	HC	CRYE00			:MESSAGE = CRASH

SFAIL3	HS	0
	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl
	LHI	R1,TRTBSZ-2		:SET UP INDEX REG FOR TRSTAB.
:	MOST RECENT JUMP ADDRESS WILL BE LAST ENTRY IN TRSTAB.
	LR	R3,R1			:ALSO USEFUL AS WRAP MASK
	LHL	R2,TRNDEX,,		:REAL-TIME TRCTAB INDEX
SFAIL4	LHL	R15,TRCTAB,R2,		:GET CURRENT TRCTAB ENTRY AND
	STH	R15,TRSTAB,R1,		: STORE IN SAVE TABLE
	SIS	R2,2			:DECREMENT, AND
	NR	R2,R3			: MASK FOR WRAP
	SIS	R1,2
	JGEBS	SFAIL4			:FILL IN ALL ENTRIES
	EI	:DB.TRC

	LA	R1,TRRING+TRRSIZ-2,,	:LAST SOURCE HW
	LA	R2,TRRSAV+TRRSIZ-2,,	:LAST DESTINATION HW
	LHI	R3,10*(TRRSIZ/2-1)	:NUMBER OF HW'S TO MOVE INDICATOR
	COPY	R1,R3			:SAVE TRRING--"COPY" MICROINSTRUCTION
	LHL	R1,TRRIX		:AND INDEX
	STH	R1,TRIXSV,,

       IF       1-SWTCHR                :NO NEED IF SWITCHER
	LA	R1,DIRING+DRSZ+2,,
	LA	R2,DIRSAV+DRSZ+2,,
	LI	R3,10*(DRSZ/2+1)
	COPY	R1,R3			:SAVE DIRING
	LA	R1,DORING+DRSZ+2,,
	LA	R2,DORSAV+DRSZ+2,,
	LI	R3,10*(DRSZ/2+1)
	COPY	R1,R3			:AND DORING
       EI       :SWTCHR

	LA	R1,CRYPRB+CRYPRS-2,,	:LAST SOURCE HW ###LSH
	LA	R2,CRYPSV+CRYPRS-2,,	:LAST DESTINATION HW ###LSH
	LHI	R3,10*(CRYPRS/2-1)	:NUMBER OF HW'S TO MOVE ###LSH
	COPY	R1,R3			:SAVE CRYPTO BUFFER -- "COPY"###LSH

:	STORE PACKETS ON CRASH - COPY 1000 BYTES EACH TIME
	IF	PKTSAV			:SAVE PACKETS ON CRASH	###LSH
        L       R3,RECBUF,,
        ST      R3,PCKTSV,,             :do 1st hw so avoid problem with copy
	LI	R3,10*(PCKTSZ/2-2)	:TOTAL BYTES TO BE COPIED
	LA	R1,RECBUF,,		:LAST SOURCE HW
	LA	R2,PCKTSV,,		:LAST DESTINATION HW
	COPY	R1,R3
	EI	:PKTSAV			:			###LSH

	LM	R0,ERRREG		:RESTORE REGS IN CASE WE STOP ON CRASH

	LH	R1,CRTYPE		:HARDWARE OR SOFTWARE?		###TZ
	JGEFS	SFAIL7			:SOFTWARE			###TZ
	LB	R0,CRACTN		:HARDWARE, LOOK AT H-WARE FIELD
	STH	R0,CRTYPE		:RESET CRASH TYPE		###TZ
	JFS	SFAIL8
SFAIL7	LB	R0,CRACTN+1		:SOFTWARE, LOOK AT SOFTWARE FIELD
SFAIL8	LR	R0,R0
	JE	RESTRT			:CRACTN = 0 => RESTART

      IF	T2GATE		:Gateway can only restart or halt.
        J       CRPACH                  :then halt it
      ELSE  	:not T2GATE
	SIS	R0,1
	JNFS	SFAILA

:	CRACTN = 1 => STOP NODECODE, XRAY CONTINUES TO RUN
SFAIL9	HS	0			:STOP (LOOP) ON CRASH
	SVC	FAST,0			:DISMISS TO ISIS KERNEL SO OTHER SLOTS
	JBS	SFAIL9			: HAVE A CHANCE

SFAILA	HS	0
	SIS	R0,1
	JNFS	CRPACH			:CRACTN > 2, PROVIDE PATCH AREA
:	EFFECTIVE FOR SFTWR CRASH ONLY AS HDW WOULD HAVE HALTED IN ANERNT.

:	CRACTN = 2 => BOOT MACHINE
      IF	NAD68			:no BOOT option for 68K environment
	J	SFAIL9			:STOP instead...
      ELSE	:Engine
	SVC	SYS,$A39
	J	.			:LOOP TILL TIMER TAKES EFFECT
      EI	:NAD68
      EI	:T2GATE

:	CRACTN = 0 => RESTART
RESTRT	UPSW	NSTPSW			:RESTART NODE CODE, POSSIBLY WITH TRACE
	SYAD(RESTRT)	

:	CRACTN = 3 => HALT
CRPACH	HS	0
	SVC	SYS,$A32		:TRUELY HALT THE NODE CODE	###GT
					: - ONLY TO BE USED IN APSS SYSTEMS SO
					: THAT THE ISRM WILL UNSUSPEND THE
					: BACK-UP NODE CODE		###GT

NOTRAC	WC	0,SFAIL2		:TURN OFF TRACE FOR COPY OF TABLE

	IF	DB.TRC
NSTPSW	WC	1000,NSTART		:RESTART NODE CODE WITH UPSW TRACE
	ELSE	:NOT DB.TRC
NSTPSW	WC	R0,NSTART		:RESTART NODE CODE WITHOUT TRACE
	EI	:DB.TRC



::*********************************************************************
::
::	SUBROUTINE:	CTENTR:
::	FUNCTION:	MAKE AN ENTRY IN THE COMMON CRASH SUMMARY TABLE
::			AND IN DETAIL TABLE IF APPROPRIATE.
::	CALLING SEQ:	JAL	R10,CTENTR
::
::*********************************************************************

:	THE SUMMARY TABLE IS A PUSH-DOWN STACK WITH ROOM FOR 16d
:	ENTRIES.  WE WILL MAKE AN ENTRY IN THIS TABLE FOR EVERY CRASH UNTIL
:	THE FIRST CRASH NOT YET REPORTED TO THE SUPERVISOR REACHES THE BOTTOM
:	OF THE LIST.  AT THAT POINT WE STOP PUSHING THE STACK DOWN AND SIMPLY
:	ENTR ANY NEW CRASHES AT THE TOP.  THIS PRESERVES THE ORIGINAL CRASH
:	FOR REPORTING TO THE SUP.  WHEN THE NODE COMES BACK INTO THE NET FROM
:	A CRASH, WE WILL REPORT THIS 'OLDEST' CRASH (IF ANY) AS WELL AS THE
:	MOST RECENT CRASH. SIMILARLY, ENTRIES ARE MADE IN THE DETAIL TABLE ONLY
:	FOR THE CRASH OF INTEREST FOLLOWING A LOAD AND FOR THE FIRST MOST
:	RECENT CRASH OF INTEREST THAT OCCURED WHILE THE NODE WAS IN THE NET.

CTENTR	HS	0
	LHI	R1,((CS.NEN-1)*CS.SIZ)	:POINT TO LAST ENTRY IN SUMMARY TABLE
CTE10	LM	R12,CSMTBL-CS.SIZ,R1	:GET PREVIOUS ENTRY
	STM	R12,CSMTBL,R1		:MOVE IT DOWN ONE ENTRY
	SHI	R1,CS.SIZ		:POINT TO NEXT ENTRY UP
	JGBS	CTE10			:NO, CONTINUE
:	STACK PUSHED, NOW MAKE NEW ENTRY
	LM	R12,CRHCNT		:COUNT,ID,PSD,TIME
	STM	R12,CSMTBL		:MAKE ENTRY
	LIS	R3,1			:increment			###wjl
	AHM	R3,CSMCNT		:count of summary table entries	###wjl
:	NEW ENTRY MADE, NOW MAKE DETAILED ENTRY IF APPROPRIATE.
	THI	R12,0E			:FOR ISIS, MAKE DETAIL ENTRY IF ID >1.
	JER	R10
	LHL	R3,CSMCNT		:ANY ENTRIES? 			###GT
	JER	R10			:NO, DON'T MAKE ANY ENTRIES
					: IN DETAIL TABLE		###GT
	LIS	R3,1			:				###GT
	AHM	R3,CDTCNT		:COUNT OF DETAIL ENTRIES	###GT
	LHL	R3,CDTPTR		:POINTER TO NEXT DETAIL ENTRY AREA
CTE20	HS	0
	STM	R12,CDTTBL,R3		:COUNT, CODE, PSD, TIME

	LA	R0,ERRREG+3E		:FOR COPY - LAST SOURCE HW
	LA	R1,CDTTBL+CD.RSF+3E,R3	:FOR COPY - LAST DESTINATION HW
	LHI	R2,1F0			:FOR COPY - NO. OF HW'S -1 * 10
	COPY	R0,R2			:MOVE CONTENTS OF USER REGISTER SET
					:INTO CRASH TABLE.

	LR	R3,R3			:FIRST ONE?
	JNR	R10			:NO
	LHI	R3,CD.SIZ		:YES,POINT TO SECOND
	STH	R3,CDTPTR
	JR	R10			:RETURN

	SUBTTL	EXEC (CRYPTO - Diagnostic message generator)

::*********************************************************************
::
::	SUBROUTINE:	CRYPTO:
::	FUNCTION:	SENDS A CRYPTOGRAM TO XRAY
::	CALLING SEQ:	JAL	R8,CRYPTO
::			HC	CRYExx	:CRYPTO NUMBER AND MESSAGE FLAGS
::	INPUT:		R0=HW0 & HW1 OF CRYPTOGRAM DATA
::			CRYSBF=HW2,HW3 OF CRYPTOGRAM DATA
::
::*********************************************************************

:	STORES A CRYPTOGRAM AS FOLLOWS: FW OF GMT, LO HW OF FASTC, HW OF
:	FLAGS AND MESSAGE TYPE (CRYEnn), 4 HW'S OF DATA.

CRYPT0	HS	0			:ENTRY POINT WHEN R0 NOT SET UP
	L	R0,CRYSBF+4		:CRYPTO ASSUMES R0 HAS SOME DATA

CRYPTO	HS	0
	ST	R1,CRYSAV+4		:SAVE R1 IMMEDIATELY
	LB	R1,1,R8			:GET CRYPTO NUMBER
	TBT	R1,CRYARY		:SEE IF THIS MESSAGE IS DESIRED
	JN	CRYPNO			:NO, DO NOT DISPLAY IT

	LB	R1,0,R8			:GET MESSAGE FLAGS
	NHI	R1,0F			:ISOLATE MESSAGE CLASS
	JEFS	CRYPTX			:CLASS 0 IS ALWAYS DISPLAYED

	LHL	R1,CRYPCL,R1,R1		:GET FLAG FOR THIS CLASS
	JNFS	CRYPTX			:DISPLAY IF NOT ZERO

CRYPNO	L	R1,CRYSAV+4		:NO DISPLAY, RESTORE R1
	J	2,R8			:AND RETURN PAST CRYPTO DATA

CRYPTX	HS	0
	LHL	R1,0,R8			:CRYPTO MESSAGE NO. AND FLAGS
	AIS	R8,2			:SET UP TO RETURN PAST CRYPTO DATA HC
	
:	CRYPT1 IS ENTRY POINT FOR WHEN MESSAGE FLAGS ARE SUPPLIED IN R1
:	INSTEAD OF IN THE HALFWORD FOLLOWING THE CALL TO CRYPTO
CRYPT1	STM	R2,CRYSAV+8		:SAVE WORK REGS
	ST	R0,CRYSAV		:	AND CRYPTO DATA
	LHL	R2,CRYPRI		:Get pointer into regular buffer
:	L	R3,CRYPRB+CRYGMT,R2,	:Anything there now?
:	JE	CRYPT3			:No

:	LB	R3,CRYPRB+CRYTYP,R2,	:Get number of old message
:	GL	CRYPRY
:	TBT	R3,CRYPRY,,		:See if it should be saved
:	JE	CRYPT3			:No				###AL

:	LM	R12,CRYPRB,R2,		:Get old message
:	LHL	R3,CRYPPI		:Pointer to priority buffer
:	STM	R12,CRYPPB,R3,		:Save old message
:	AHI	R3,10			:Adjust priority pointer
:	NHI	R3,CRYPPS-1		:Max size
:	STH	R3,CRYPPI		:Done
	
CRYPT3	LHL	R6,FASTC+2,,		:GET LO HW OF FASTC
	EXHR	R6,R6			:SHIFT TO HO HW
	OR	R6,R1			:COMBINE FASTC
					: WITH CRYPTO NUMBER AND MESSAGE FLAGS
	ST	R6,CRYPRB+CRYFAS,R2,	:STORE IT AWAY
	IF	PRIMSG
	LBR	R3,R1			:GET MEG. # BYTE
	GL	CRYPRY
	TBT	R3,CRYPRY,,		:SEE IF PRIORITY ON
	JEFS	CRPT31
	LHL	R3,CRYPPI		:STORE TO CRYPPB ALSO
	ST	R6,CRYPPB+CRYFAS,R3,
CRPT31	HS	0
	EI	:PRIMSG
	LR	R6,R1			:SAVE R1			###AL
	JAL	R9,GMTCAL,,		:GET CURRENT GMT AT GMTNOW
	LR	R1,R6			:RESUME R1			###AL
	L	R6,GMTNOW		:GET IT AND
	ST	R6,CRYPRB+CRYGMT,R2,	:STORE IT AWAY
	ST	R0,CRYPRB+CRYHW0,R2,	:STORE CRYPTO DATA HW0&1
	L	R4,CRYSBF		:USE R4				###AL
	ST	R4,CRYPRB+CRYHW2,R2,	:HW2&3
	IF	PRIMSG
	LBR	R5,R1			:GET MEG. # BYTE
	TBT	R5,CRYPRY,,		:SEE IF PRIORITY ON
	JE	CRPT32
	LHL	R3,CRYPPI		:RESUME INDICATER
	ST	R6,CRYPPB+CRYGMT,R3,	:STORE IT AWAY
	ST	R0,CRYPPB+CRYHW0,R3,	:STORE CRYPTO DATA HW0&1
	ST	R4,CRYPPB+CRYHW2,R3,	:HW2&3

	AHI	R3,10
	NHI	R3,CRYPPS-1		:Update crypto message index
	STH	R3,CRYPPI
CRPT32	HS	0
	EI	:PRIMSG

	AHI	R2,10
	NHI	R2,CRYPRS-1		:Update crypto message index
	STH	R2,CRYPRI

CRYPT6	HS	0
	LHL	R14,INTXRF		:REMOTE XRAY USER?
	JEFS	CRYPT9			:NO
	LHI	R14,01F-PXRAY		:YES,SCHEDULE XRAY
	SBT	R14,SQUEUE
	LHL	R14,XUSIUA		:PUT ALL XRAY USERS
	STH	R14,XQUEM		:INTO MASTER QUEUE
CRYPT9	LM	R0,CRYSAV		:RESTORE WORK REGS
	JR	R8			:RETURN
	
CRYARY	HS	10		:INDIVIDUAL BITS ENABLE DISPLAY OF
				:INDIVIDUAL CRYPTO MESSAGES

CRYPCL	HS	0		:CLASSES OF CRYPTO MESSAGES
CRYDEF	HC	1		:CLASS 0 ALWAYS DISPLAYS
	SYAD(CRYDEF)
CRYDIS	HC	DB.CIR		:CLASS 1 - CIRCUIT BUILT, ZAPPED
	SYAD(CRYDIS)
        HC      0
REBDIS	HC	0		:CLASS 3 - REBUILD EVENTS
	SYAD(REBDIS)
	HC	0	:CLASS 4
	HC	0	:CLASS 5
	HC	0	:CLASS 6
	HC	0	:CLASS 7
	HC	0	:CLASS 8
	HC	0	:CLASS 9
	HC	0	:CLASS A
	HC	0	:CLASS B
	HC	0	:CLASS C
	HC	0	:CLASS D
	HC	0	:CLASS E
	HC	0	:CLASS F

	SUBTTL	EXEC

::*********************************************************************
::
::	SUBROUTINE:	HSTORY:
::	FUNCTION:	SAVES EVENT IN HISTORY BUFFER
::	CALLING SEQ:	JAL	R8,HSTORY
::	INPUT:		R0 = EVENT (PRESERVED)
::	DESTROYED:	R1
::
::*********************************************************************

HSTORY	HS	0
	LHL	R1,HISTI
	STH	R0,HISTBF,R1,
	AIS	R1,2
	NHI	R1,HISTSZ-1
	STH	R1,HISTI
	JR	R8



	ENDMO.(EXEC)

:	***END EXEC***

	EI	:1-KILLIT

	KILMSG(EXEC)

:	***NOTHING PAST THIS POINT***


	SUBTTL	SWTCH2

:		 **** *   * *****  ***  *   *  ***
:		*     *   *   *   *   * *   * *   *
:		 ***  * * *   *   *     *****   *
:		    * ** **   *   *   * *   *  *
:		****  *   *   *    ***  *   * *****

::#####################################################################
::
::	MODULE:		SWTCH2
::
::	FUNCTION:	Circuit building and command channel
::			communications processes.
::
::	REGISTER CONVENTIONS:
::
::	SUBTTLS:	IZSWIT:  Switch initialization
::			SWITCH:  Switch exec
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA	0
	SEG	1

::*********************************************************************
::
::	TABLE:		KDKN:
::	FUNCTION:	LINK DESCRIPTORS INDEXED BY LINK NUMBER
::
::*********************************************************************
Q	EQ	KDSC
R	EQ	0
KDKN	WS	0			:LINK POINTERS BY DIFFERENTIAL SIZE
	RE	NLINKS
	WC	Q
	IF	\K.S|$A R|		:IF THIS LINK IS STARLINK
Q	EQ	Q+SKDSZ			:STRLNK DESCRIPTOR SIZE
	ELSE	\T.OH|$A R|
Q	EQ	Q+TNKDSZ		:ELSE TUNNEL LINK SIZE
	ELSE
Q	EQ	Q+KDSZ			:ELSE TII LINK SIZE
	EI
R	EQ	R+1
	ER
	SYAD(KDKN  )

::*********************************************************************
::
::	TABLE:		HMSK:
::	FUNCTION:	HALFWORD MASK ARRAY
::			YIELDS HC 8000,4000,2000,ETC...
::
::*********************************************************************

HMSK	HS	0
Q	EQ	8000
	RE	10
	HC	Q
Q	EQ	Q^-1
	ER

::*********************************************************************
::
::	TABLE:		WMSK:
::	FUNCTION:	WORD MASK BIT ARRAY
::
::*********************************************************************

WMSK	WS	0			:WORD MASK BIT ARRAY
	NOLIST
	RE	20
	WC	1^(1F-(.-WMSK)/4)
	ER				:80000000,40000000,20000000, ETC.
	LIST

	SUBTTL	SWTCH2 (IZSWIT - Switch initialization)

::*********************************************************************
::
::	SUBROUTINE:	IZSWIT:
::	FUNCTION:	Initializes SWITCH
::	CALLING SEQ:	JAL	R10,IZSWIT
::
::*********************************************************************

DEAD	EQ	0DEAD			:for BF entry, etc.	###jhl

IZSWIT	HS	0
:	Init CHNMAP.  CHNMAP is a FW array used by the TRACE logic to
:	figure out where circuits are headed.  The HO HW is the absolute
:	channel of relative channel 0 for the channel range.  The LO HW
:	is an index into CHNMPD (if positive, otherwise it is a flag for
:	terminating circuits).

:	Init CHNMAP for internal control (ILC, BPM) channels (CHNMPD index=-6)
	LI	R0,LNKLFL^10+0FFFA
	ST	R0,CHNMAP		:ILC, BPM CIRCUITS (INT CONTROL CIRCS)

:	Init CHNMAP for link channels (CHNMPD index=2*link#)
	LI	R0,LNKLFL^10+2*(NLINKS-1)
	LIS	R1,4
IZSWA	ST	R0,CHNMAP,R1		:LEFT HALF CHANNEL 0 #,
					: RIGHT HALF CHNMPD INDEX
	SIS	R0,2
	AIS	R1,4
	CLHI	R1,4*NLINKS		:DONE ALL LINKS?
	JLEBS	IZSWA			:NO - CONTINUE

:	Init CHNMAP for dispatcher ports (CHNMPD index=-3)
	LI	R0,DISZFL^10+0FFFD	:DISPATCHER PORTS (-3)
	ST	R0,CHNMAP,R1
	AIS	R1,4

:	Init CHNMAP for sup ports (CHNMPD index=-2)
	IF	SUPER
	LI	R0,SUPZFL^10+0FFFE	:SUP PORTS (-2)
	ST	R0,CHNMAP,R1
	AIS	R1,4
	EI	:SUPER

:	Init CHNMAP for kernel ports (CHNMPD index=HST0)
	LI	R0,KERZFL^10+8000+HST0
	ST	R0,CHNMAP,R1
	AIS	R1,4

:	Init CHNMAP for internal host ports (CHNMPD index=-4),
:	LEP ports  (CHNMPD index=-5), transient	state ports (CHNMPD index=-7)
	LI	R13,INTZFL^10+0FFFC	:INT PORTS (-4)
	LI	R14,LEPZFL^10+0FFFB	:COMMAND CIRCUIT (-5)
	LI	R15,0FFF9		:TRANSIENT STATE (-7)
	STM	R13,CHNMAP,R1

:	Init downline load cells (DWTEST, DWLDSP)
	LIS	R0,1
	STH	R0,DWTEST		:INITIALIZE DWLIN SEMAPHORE
	LIS	R0,0
	ST	R0,DWLDSP		:CLEAR DWL DISPATCH ARRAY
	ST	R0,DWLDSP+4

:	Init various bit arrays and pointers, link by link
	LHI	R0,LNKZFL		:FIRST CHANNEL NUMBER FOR NETWORK LINKS
	LIS	R1,0
        lis     r2,0
	LHI	R4,LNKFLG-2,		:LAST HW BEFORE 'ATTN' ARRAY
	LHI	R5,CHSRVD-2,		:LAST HW BEFORE 'SERVICE' ARRAY
	LHI	R6,LNKBPV-2,		:LAST HW BEFORE BACKPRESSURE ARRAY
	LHI	R7,LNKACP-2,		:LAST HW BEFORE ACP ARRAY
	LHI	R8,LNKCHS-2,		:LAST HW BEFORE CHS ARRAY
	LHI	R3,-2*NLINKS		:LINK FIELD INDEX
IZSWB	HS	0
	STH	R0,LKZFKN+2*NLINKS,R3,	:ABSOLUTE CHANNEL FOR RELATIVE CHAN 0
	STH	R2,TBDPKN+2*NLINKS,R3,	:START OF TABLES..
	STH	R2,EBDPKN+2*NLINKS,R3,	:..END OF TABLES
	STH	R1,FLDPKN+2*NLINKS,R3,	:START OF FLAGS FOR THIS LINK
	STH	R4,LKFGND+2*NLINKS,R3,	:LAST HW IN 'ATTN' ARRAY
	STH	R5,LKSVND+2*NLINKS,R3,	:LAST HW IN 'SERVICE' (CHSRVD) ARRAY
	STH	R6,LKBPND+2*NLINKS,R3,	:LAST HW IN BACKPRESSURE ARRAY
	STH	R7,LKAPND+2*NLINKS,R3,	:LAST HW IN ACP ARRAY
	STH	R8,LKCSND+2*NLINKS,R3,	:LAST HW IN CHS ARRAY
        gl      lnkngr
        srls    r0,3
        ah      r0,lnkngr+2*nlinks,r3   :offset to next link's start
        slls    r0,3
        ah      r1,lnkngr+2*nlinks,r3   :flags offset
        srls    r2,4
        ah      r2,lnkngr+2*nlinks,r3
        slls    r2,4
        ah      r4,lnkngr+2*nlinks,r3   :attn offset
        ah      r5,lnkngr+2*nlinks,r3   :service
        ah      r6,lnkngr+2*nlinks,r3   :bp
        ah      r7,lnkngr+2*nlinks,r3   :acp
        ah      r8,lnkngr+2*nlinks,r3   :chs
	AIS	R3,2			:DO FOR ALL LINKS
	JL	IZSWB

	LHI	R3,-ACPSZP*4		:1/2 ARRAY SIZE, FULLWORD INDEX
	LCS	R1,1

:	Init ACP and CHS (to 1's to indicate channels available).
:	Note ACP and CHS must be contiguously allocated.
IZSWC	HS	0
	ST	R1,ACPBSE+ACPSZP*4,R3,	:SET ACP, CHS TO -1
	AIS	R3,4
	JLBS	IZSWC

:	Init table space
	LHI	R0,TCHANS*2		:END OF TABLE SPACE
	STH	R0,TBDPKN+2*NLINKS,,
	LHI	R0,TCHANS/80
	STH	R0,NUMPAG,,		:NUMBER OF FREE PAGES

	LHI	R1,DEAD			:LINK AVAILABLE BUFFER PAIRS
	LHI	R2,CIRZBF
	STH	R2,FREELB		:HEAD OF FREE PAIR LIST

:	Init buffer linkages (using BB), BF's to "DEAD",
:	free buffer pair list (FREELB).
IZSW1	HS	0
	AIS	R2,8
	STH	R2,BB-8,R2,		:BB USED FOR CHAINING
	STH	R1,BF-8,R2,		:ATTENTION FLAGS SET TO 'DEAD'
	STH	R1,BF-4,R2,
	LR	R3,R2
	SRHLS	R3,1
	IF	REBILD
	STH	R1,BF+HBUFN-4,R3,
	EI	:REBILD
	CI	R2,8*NCIRCS
	JN	IZSW1

	LIS	R0,0			:LAST PAIR GETS A ZERO
	STH	R0,BB-8,R2,
	STH	R1,BF-8,R2,


        li      r0,(chrbuf+cbsz-cbptsz)/(1^cbszl)
	LA	R1,CHRBUF,,		:ADDRESS OF ZEROETH BUFFERLET
	LI	R2,NBFLET-1		:USE FW FOR A BIG POOL##AL
	GL	NBFLET
	STH	R0,FREELT		:HEAD OF THE FREE LIST

:	Init bufferlet chain and free bufferlet list (FREELT).
:	Bufferlets are 16d bytes long (CBSZ)--the first HW links to the next
:	bufferlet, the next 14 are for data.  Linking is done via bufferlet
:	number, from 0 to NBFLET-1.  The actual address of a bufferlet is
:	computed by multiplying its number by 10x and adding the base bufferlet
:	address (CHRBUF).  Since FW arithmetic is used,	bufferlet storage can
:	span segment boundaries.
IZSW2	HS	0
	STH	R0,CBSZ-cbptsz,R1	:STORE # OF FOLLOWING BFLET
	AHI	R1,CBSZ
	AHI	R0,cbsz/(1^cbszl)
	SIS	R2,1
	JGBS	IZSW2

	LIS	R0,0			:LAST BUFFERLET LINK GETS A 0
	STH	R0,CBSZ-cbptsz,R1

:	Schedule CKZB to fill reserve tank first thing
	LHI	R0,1F-PCKZB
	SBT	R0,SQUEUE		:FILL RESERVE TANK

:	Init CRQ buffer flag (BB=0)
	LHI	R0,CRQZFL		:INIT CRQ BUFFER FLAG
	STH	R0,BB,,

:	Build sup circuit to LEP
	IF	SUPER
	JAL	R9,SUPCRQ,,		:BUILD CIRCUIT FROM SUP TO LEP
	GL	SUPCRQ		:##AL
	EI	:SUPER

:	Init downlin load channels (DWLNUM)
	LCS	R0,1			:INIT DOWN-LINE LOAD 
	LIS	R1,TINTCH-1
IZSDWL	HS	0
	STH	R0,DWLNUM,R1,R1
	SIS	R1,1
	JGEBS	IZSDWL

:	Init SIO lines downline load command blocks and	output buffers
	IF	SILINS
	LHI	R1,SILINS*10		:INIT SIO LINES DWL COMMAND BLOCKS
	LHI	LN,NLINES
IZSSIO	HS	0
	SIS	LN,1
	SHI	R1,10			:AND OUTPUT BUFFERS
	JL	IZSSI2
	LR	R2,R1
	SLLS	R2,3			:FOR INDEXING CONVENIENCE
	LA	R0,SIDWBF,R2,		:QUAD ADDRESS OF EACH SIO LINE'S OUTPUT
	GL	SIDWBF
	SRLS	R0,4
	STH	R0,SIDWCM+2,R1,		:BUFFER MUST BE STORED IN ITS CCW AREA
	GL	SIDWCM
	LIS	R0,0
	STH	R0,SIDWCM+4,R1,		:AS MUST A STOP COMMAND 
	LHI	R0,42
IZSSIB	STH	R0,SIDWBF,R2,		:FINALLY STORE BYTE COUNT IN IST HW
	J	IZSSIO
IZSSI2	LCS	R0,1
	EI	:SILINS

:	Init PLI message count (-1=nada)
	STH	R0,PLICNT		:INIT PLI MESSAGE

:	Init (-1) the sup NOP flag to idle
	STH	R0,LEPNPF		:INIT SUP NOP FLAG TO IDLE STATE

:	Init (-1) SUPIBF to indicate no diagnostic node	reports formatted
	STH	R0,SUPIBF		:NO DIAGNOSTIC NODE REPORTS FORMATTED

:	EXPANDED HOST TABLES FOR PROPER HOST INFORMATION MAINTENANCE
	LHI	R0,HST0			:STORE KERNEL HOST NO.		###OAS
	STH	R0,HOSTN		:INTO FIRST ENTRY IN HOST # TABLE##OAS
       IF      MXPNM
        LHI     R0,MXPNM                :NSR 1094 report kernel host with
        STH     R0,HSTKEY,,             :it's host key
       EI       :MXPNM
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE	###OAS
	ST	R0,HSTTIM		:STORE IN FIRST ENTRY OF HOST TIME#OAS
	LHI	R0,NKU			:ANY KERNEL PORTS?		###OAS
	JNFS	IZSSI3			:YES, INDICATE HOW MANY PORTS	###OAS
	LIS	R0,2			:NO, INDICATE 2 PORTS		###OAS
IZSSI3	STH	R0,HSTPTA		:IN PORTS AVAILABLE ARRAY	###OAS


	LHI	R0,TIITYP		:ASSUME TII PID			###OAS
       if       1-swtchr                :switcher's pid should be node code
	LHI	R0,I2ISTP		:ISIS PID			###OAS
       ei
	IF	SUPER
	LHI	R0,SUPTYP		:SUPERVISOR PID			###OAS
	EI	:SUPER
	IF	SIORNG	
	LHI	R0,SKERTY		:SPLIT SUPERVISOR PID	###OAS	###wjl
	EI	:SIORNG
	STB	R0,HSTYPE		:STORE KERNEL HOST TYPE

:	Clear accounting flags (ACT7, ACTLST)
	LCS	R0,1			:CLEAR ACCOUNTING FLAGS
	ST	R0,ACT7+0
	ST	R0,ACT7+4
	ST	R0,ACT7+8
	LIS	R0,8			:SET INDEX TO INVALID
	STB	R0,ACTLST

:       initialize the xray user names to uppercase
        gl      xgglen,xsg1wp,xsg1wa,xraygg
        li      r0,xsg1wa               :need to write to seg 1
        svc     sys,11
        lis     r1,0                    :index into tables
izxrgg  lis     r2,0                    :index to char
izxrg2  lb      r0,xraygg+xggnam,r1,r2  :get char
        ohi     r0,80
        clhi    r0,0e1                  :lower case?
        jlfs    izxrg1
        clhi    r0,0fa                  :lc z?
        jgfs    izxrg1
        nhi     r0,0df                  :make uppercase
        stb     r0,xraygg+xggnam,r1,r2
izxrg1  ais     r2,1                    :next char
        clhi    r2,0c                   :upto 12 (D) chars
        jle     izxrg2                  :next char
        ahi     r1,xggsiz               :next entry
        clhi    r1,xgglen               :all entries done?
        jl      izxrgg
        li      r0,xsg1wp
        svc     sys,11                  :restore protect to seg 1

:	Set threshhold for reporting circuit errors.
	LHI	R0,RPTHCE
	STH	R0,NC.THS		:SET REPORT THRESHOLD FOR CIRC ERRORS

:	Return when done
	JR	R10			:RETURN

	SUBTTL	SWTCH2 (SWITCH - Switch exec)

::*********************************************************************
::
::	PROCESS:	SWITCH:
::	FUNCTION:	Switch exec loop dispatches to various sub-processes
::		based on their attention flags:
::		LEP    - process data on a command channel
::		CRQ    - complete second half of circuit building process
::		LOGGER - process ports currently in login mode
::		INTHST - process data for internal hosts
::		DETCIR - detached circuit processing
::
::*********************************************************************

:	DUMMY DEBUG PROCESS NUMBERS FOR SWITCH SUBPROCESSES		###wjl
:	FORM PROCESS NUMBER * 4 FOR FW INDEX INTO PROTIM, PACTIM,	###wjl
:	PROHWM, PSVTIM ARRAYS ALLOWING USE OF CPRHWM AND MPRTIM ROUTINES###wjl
	IF	SWITIM			:SWITCH MAX PROCESS TIME debug	###wjl
PLAST	EQ	(1F-PGMSRK)^2		:last Process number * 4	###wjl
PLEP	EQ	PLAST+4			:dummy debug Process # for LEP	###wjl
PCRQ	EQ	PLEP+4			:CRQ				###wjl
PLOGGR	EQ	PCRQ+4			:LOGGER				###wjl
PINTHS	EQ	PLOGGR+4		:INTHST				###wjl
PASYLO	EQ	PINTHS+4		:ASYLOU				###wjl
PLGGO	EQ	PASYLO+4		:LGGO				###wjl
PDETCR	EQ	PLGGO+4			:DETCIR				###wjl
	EI	:SWITIM			:				###wjl

SWITCH	HS	0

:	See if foreground formatted a diagnostic node report (SUPIBF>=0).
:	If so call NETDGN to send node report and cryptogram.
:	Else skip to SWINOP.
	IF	(1-T2GATE)		:###EV
	TS	SUPIBF			:ANY WORK TO DO?
	JLFS	SWINOP			:NO
	L	R8,SUPIBF+2		:GET MESSAGE AND MOVE TO
	ST	R8,SUPMBF+2		:PROPER BUFFER
	SRL	R8,18			:SET UP DIAGNOSTIC SUB-TYPE
	JAL	R9,NETDGN,,		:SEND CRYPTOGRAM, NODE REPORT
	GL	NETDGN			:##AL
	EI	:(1-T2GATE)		:###EV

:	If supe NOP command is throttle (LEPNPF>=0), then go see if output has
:	been drained enough to continue	artificial load to supe (LEPNP4).
:	Else continue.
SWINOP	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PLEP			:load LEP dummy debug process id (*4)
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	TS	LEPNPF			:IS SUP NOP COMMAND THROTTLED?
	JGE	LEPNP4,,			:YES - SEE IF OUTPUT DRAINED ENOUGH TO
	GL	LEPNP4			:CONTINUE ARTIFICIAL LOAD TO SUP

:	If any supe command data for LEP, go there (via	BIDDY) and process it.
:	Else continue at SWICRQ.
SWILEP	HS	0
	LB	R1,LEPFLG,,		:PROCESS SUP COMMANDS
	JEFS	SWICRQ			:NO DATA FROM SUPERVISOR
	STB	R1,SWIVSV		:SAVE ATTENTION FLAGS

:	ENTRY POINT - EXEC LOOP RETURNS HERE DUE TO QEXEC ADDR STORED BY BIDDRT
:	(ALLOWS HIGHER-PRIORIY PROCESS TO RUN)
:	standard set up and JAL to BIDDY - CALL LEP			###wjl
	GBIDDY(4,SWIVSV,JLEP)		:R4<=count, R3<=addr, R9=JAL	###wjl
					:JLEP added to avoid RX3 skip return
					:                               ###sdw

:	If any needles have come in through LEP or RTD into CRQBUF,
:	go to CRQ to handle them.  Else continue at SWILOG.
SWICRQ	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PLEP			:load LEP dummy debug process id (*4)
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	LHL	R0,BCT,,		:HERE IF SWIVSV = 0. PROCESS NEEDLES
	JE	SWILOG			:NO CIRCUITS TO BUILD		###wjl

	IF	SWITIM			:				###wjl
	LHI	R2,PCRQ			:load CRQ dummy debug process id (*4)
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	CRQ,,			:HANDLE NEEDLES FOR HALF-BUILT CIRCUITS
	GL	CRQ

:	Yield after CRQ is done
CRQRET	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PCRQ			:load CRQ dummy debug process id (*4)
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	JAL	R0,EXYLD		:ALLOW HIGHER-PRIORITY PROCESS TO RUN

:	If any login input data waiting to be processed	(LOGBUF), go to LOGGER.
:	Else continue at SWIINT.
SWILOG	HS	0
       if       1-NCSLOT
	LHL	R0,BCT+4,,		:PROCESS PORTS IN LOGIN MODE
	JE	SWIINT			:NO PORTS CURRENTLY IN LOGIN MODE##wjl


	IF	SWITIM			:				###wjl
	LHI	R2,PLOGGR		:load LOGGER dummy debug process id *4
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	LOGGER,,		:LOOK FOR LOGIN STRING FROM LOCAL PORT
	GL	LOGGER

:	Yield after LOGGER runs
LOGRET	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PLOGGR		:load LOGGER dummy debug process id *4
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	JAL	R0,EXYLD		:ALLOW HIGHER-PRIORITY PROCESS TO RUN

       EI       :1-NCSLOT

:	If any data for internal hosts, go to INTHST to process it.
:	Else continue at SWIALO.
SWIINT	HS	0
	LHL	R2,INTFLG,,		:PROCESS DATA FOR INTERNAL HOST
	JE	SWIALO			:NO INTERNAL HOST ACTIVITY	###wjl


	IF	SWITIM			:				###wjl
	LHI	R2,PINTHS		:load INTHST dummy debug process id *4
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	INTHST,,		:LOOK FOR DATA FOR AN INTERNAL HOST
	GL	INTHST

:	Yield after INTHST runs
INTRET	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PINTHS		:load INTHST dummy debug process id *4
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

	JAL	R0,EXYLD		:ALLOW HIGHER-PRIORITY PROCESS TO RUN

SWIALO	HS	0
:	If any data for detached ports, go to DETCIR to	handle.
:	Else return to EXEC via SWIRET.
	L	R2,DETFLG,,		:DATA FROM A DETACHING PORT?
	JE	SWIRET		:NO - RETURN TO EXEC


	IF	SWITIM			:				###wjl
	LHI	R2,PDETCR		:load DETCIR dummy debug process id *4
	L	R0,FASTC,,		:save execution begin time	###wjl
	ST	R0,PROTIM,R2		:for subprocess			###wjl
	EI	:SWITIM			:				###wjl

	J	DETCIR,,		:YES - EXAMINE AND PROCESS
	GL	DETCIR

:	Yield after DETCIR runs.  Then return to EXEC via SWIRET.
DETRET	HS	0
	IF	SWITIM			:				###wjl
	LHI	R2,PDETCR		:load DETCIR dummy debug process id *4
	JAL	R8,CPRHWM,,		:test for new process high-water mark
	EI	:SWITIM			:				###wjl

                                        :no EXYLD since doing return anyway#sdw


	J	SWIRET

::*********************************************************************
::
::	JLEP   	Allows RX2 jumps to LEP.  Can't have RX3 after a JAL
::	from which we may get a skip+4 return.
::
::*********************************************************************

JLEP    J       LEP,,
        GL      LEP
			:JUMP FOLLOWS SUBROUTINE WHICH DOES SKIP RETURN.

	ENDMO.(SWTCH2)

	EI	:1-KILLIT

	KILMSG(SWTCH2)

:	***NOTHING PAST THIS POINT***

	SUBTTL	LINKER

:		*     ***** *   * *   * ***** ****
:		*       *   **  * *  *  *     *   *
:		*       *   * * * ***   ***   ****
:		*	*   *  ** *  *  *     *  *
:		***** ***** *   * *   * ***** *   *

::#####################################################################
::
::	MODULE:	 LINKER
::
::	FUNCTION:  Creates, monitors, maintains, and tears down links
::		to neighbor nodes.	###OSF 5/77
::
::	REGISTER CONVENTIONS:
::		CD  = R13	:pointer to record Descriptor
::		KD  = R15	:pointer to linK Descriptor
::		KN  = R11	:linK Number
::		LN  = R14	:Line Number
::		SD  = R12	:pointer to reset Data buffer
::
::	ROUTINES:
::		IZLNKR - LINKER segment initializer
::		SIOIZ  - Initiialize SIO lines
::		SIQURY - Query SIO status			###LSH
::		LKVOLT - Test for network links overloaded or saturated
::		LINKER - Detach, attach scheduler
::		LNCHCK - 4 sec test for records received on lines
::		LDRPRT - Diagnostics and reporting
::		KB56DB - Monitor SIO lines
::		LNXDUM - Forces transmission of dummy records
::		ATTLIN - Line attach logic
::		DETLIN - Line detach logic
::		SYLVER - Dispatcher for input on sync lines
::			 SIO input processor
::			 SIO output processor
::			 Sync input processor
::
::#####################################################################

:	SYNC LINE FORMATS
:
:	TYMNET-II:
:
:	HEADER:		00TTSSSSAAAAAAAANNNNNNNN
:	NEW LINK RESET:	001100001010PPPP + NODE #
:	NEW LINE RESET:	001100001011PPPP + NODE # OR KEY
:	NULL:		0011000001101001 + 78AB + CHECKSUMS
:	DOWNLINE LOAD:	0011001000110010
:
:	T-II Expanded Reset Packet:###wjl
:
:	New Link Reset: 001100111010PPPP + NODE # +VERSION+NETID+SUBNET+
:			WSIZ+LN+HST0+RSRSN+KSPD+KATTR+DIALUP + CHECKSUMS
:	New Line Reset: 001100111011PPPP + NODE # OR KEY +(same as new link)
:
:	WHERE:	X=1 IF FROM SLAVE
:		S=HW COUNT OR LENGTH FACTOR
:		N=RECORD #
:		A=ACKNOWLEDGEMENT
:		P=PING-PONG COUNT
:		TT=10 IF FROM MASTER, 01 FROM SLAVE

	IF	1-KILLIT		:TO ASSEMBLE OR NOT TO ASSEMBLE
	BEGMO.

	SUBTTL	LINKER (Read-only data)

	SEG	1
	SETRAD(0A)			:set decimal radix


Q	EQ	0
NEIKN	HS	0
	SYAD(NEIKN )
	RE	NLINKS			:NEIGHBORS ON LINKS
	IF	\NEI|Q|
	HC	NEI|Q|
	ELSE
	HC	0
	EI
Q	EQ	Q+1
	ER


:	Normal nodes only get window size - special get other parameters ###ev
Q	EQ	0
WSZKN	HS	0
	RE	NLINKS
	HC	WSIZ|Q|
Q	EQ	Q+1
	ER


:	space link tables at startup so bubbles don't have to move other
:	link tables about.
q       eq      0
qq      eq      0       	:make sure have enough table space
lnkngr  hs      0
	re      nlinks
	if      \kngr|q|
	hc      2*kngr|q| 	:2*to make 8 groups into 16 bytes for 128 bits
qq      eq      qq+2*kngr|q|
	else    :not defined
	hc      $0 10   	:give default spacing
qq      eq      qq+$010
	ei
q       eq      q+1
	er	:nlinks
syad(LNKNGR)

	if      8*qq-tchans+1
	Remark%%TIILNKs define more groups than available channels.
	remark%%Fatalistic error.  Assembly aborted.
	quit
	ei

:	the desired retransmisstion delay for this link (needed for that
:	darn atc to act like a 2.4's retran logic and maybe testing will
:	reveal other values work better for other lines as well).

q	eq	0
lnkrtr	hs	0
	re	nlinks
	if	\rdel|q|
	hc	rdel|q|
	else
	hc	0		:for xlinks
	ei
q	eq	q+1
	er
syad(LNKRTR)


:	save assembly time windowsize since xray WZ cmd can change the
:	windowsize in WSZKN.  prevents XRAY user from setting windowsize
:	larger than number of available record descriptors.

       IF	 WSZTST
XWSZKN	HS	0
Q       EQ      0
	RE      NLINKS
	HC      WSIZ|Q|
Q       EQ      Q+1
	ER
       EI 	:WSZTST


:	TYM FILE DECLARATION MAY INCLUDE LINK SPEEDS FOR SELECTED
:	LINKS.  THIS OPTION IS PROVIDED DUE TO THE NODE'S DIFFICULTY
:	COMPUTING LINE SPEEDS ON FAST SIO LINES.  A CONFIGURATION LINK
:	SPEED IS PRESENT IF THE SYMBOL 'KNSP|#|' IS DEFINED FOR LINK
:	NUMBER #.

Q	EQ	0		:LINK NUMBER
QQ	EQ	$0 80000000	:FOR SETTING BITS BASED ON LINK NUMBER
QQQ	EQ	0		:WORKING BIT ARRAY FOR LINKS WITH KNSP DEFINED
QQQQQ	EQ	0		:WORKING BIT ARRAY FOR LINKS WITH SAT SET
qqq1    eq      0       	:just in case links 32-63 exist (KNSP)
qqqqq1  eq      0       	:links 32-63 with SAT set

	RE	NLINKS
	IF	\KNSP|Q|		:THIS INDICATES HIGH SPEED CONFIGURED
QQQ	EQ	QQQ!QQ			:SET BIT FOR THIS LINK
	IF	\KSAT|Q|		:dedicated tunnel didn't define KSAT|Q|
KSAT|Q|	EQ	KSAT|Q|+(KNSP|Q|&$01F)	:ADD SPEED TO LINK SPEED FIELD
	EI	:\KSAT|Q|
	EI	:\KNSP|Q|
	IF	\KSAT|Q|		:###jhl
	IF	KSAT|Q|&$020		:IF SAT BIT SET IN KSAT BYTE
QQQQQ	EQ	QQQQQ!QQ		:SET SAT BIT FOR THIS LINK
	EI	:KSAT|Q|&$040
	EI	:\KSAT|Q|		:###jhl
Q	EQ	Q+1			:CHECK ALL LINKS
QQ	EQ	QQ^-1
	ER

       if	nlinks-$a32    	:if more than 32 links
q       eq      $0 20

QQ	EQ	$0 80000000	:FOR SETTING BITS BASED ON LINK NUMBER
	RE	NLINKS-$a32
	IF	\KNSP|Q|		:THIS INDICATES HIGH SPEED CONFIGURED
QQQ1	EQ	QQQ1!QQ			:SET BIT FOR THIS LINK
	IF	\KSAT|Q|		:dedicated tunnel didn't define KSAT|Q|
KSAT|Q|	EQ	KSAT|Q|!(KNSP|Q|&$01F)	:ADD SPEED TO LINK SPEED FIELD
	EI	:\KSAT|Q|
	EI	:\KNSP|Q|
	IF	\KSAT|Q|		:###jhl
	IF	KSAT|Q|&$020		:IF SAT BIT SET IN KSAT BYTE
QQQQQ1	EQ	QQQQQ1!QQ		:SET SAT BIT FOR THIS LINK
	EI	:KSAT|Q|&$040
	EI	:\KSAT|Q|		:###jhl
Q	EQ	Q+1			:CHECK ALL LINKS
QQ	EQ	QQ^-1
	ER
	ei	:more than 32 links


KNCNSP	WC	QQQ		:BIT SET IF LINK SPD DEFINED BY CONFIG
       if   nlinks-$a32  ; wc qqq1  ; ei
KNCNST	WC	QQQQQ		:BIT SET IF SAT SET BY CONFIG	###jhl
       if   nlinks-$a32  ; wc qqqqq1  ; ei

KNSAT	HS	0
Q	EQ	0
	RE	NLINKS
	DEFAULT(KSAT|Q|,$0 80)
	BC	KSAT|Q|
Q       EQ      Q+1
	ER

	RA	0			:RESTORE HEX RADIX

	HS	0

:	following is to remove a MH ccdsz and make it a table lookup.
:	for sio lines it is about 3% of cpu.
	ra      0a
q       eq      0
qq      eq      0
	re      nlinks
	if      wsiz|qq|-q
q       eq      wsiz|qq|
	ei
qq      eq      qq+1
	er			:largest of the windows is q
CCDSZ	hs      0
qq      eq      0
	re      q
	hc      qq*cdsz
qq      eq      qq+1
	er

	ra      0
TTRSET	WS	0			:TYMNET-II INITIAL RESET PATTERN
	HC	TTRSHD			:HEADER
	HC	MACHNM			:NODE NUMBER
	HC	TTRSHD%MACHNM		:VERT CHKSM
	HC	TTRSHD^2%MACHNM^1%TTRSHD%MACHNM	:DIAG. CKSUM

VERCOM	EQ	((VERSION&0FFF)^10)!((@(VERSION&0FFF))&0FFFF)		:###wjl

Q	EQ	0			:DISPLACEMENT OF INPUT BUFFERS
SVBDIS	RE	NLINES
	HC	Q;Q EQ Q+2+SVNBSZ
	ER

Q	EQ	SDSC			:RESET BUFFER PTRS BY LINE #
	WS	0
SDLN	RE	NLINES
	WC	Q;Q EQ Q+SDBSZ
	ER
	SYAD(SDLN  )			:frequently needed      	###sdw
:	SET UP ARRAYS AND COUNTERS FOR SIO LINES

	IF	SILINS

Q	EQ	(NLINES-SILINS)*2	:FIRST SIO LINE NUMBER
SIBUFP	EQ	.-Q			:BASE ADDRESS FOR
	SYAD(SIBUFP)			:	SIO AREAS
R	EQ	0
Q	EQ	Q/2			:SINGLE SIO LINE NO. ##AL
	RE	SILINS
	HC	R
	IF	\NSTR|$A Q|	
R	EQ	R+SIBFSZ
	ELSE
R	EQ	R+SIBFSZ
	EI
Q	EQ	Q+1
	ER

Q	EQ	(NLINES-SILINS)*2	:FIRST SIO LINE NUMBER


:	SIO BUFFERS ARE RELOCATED TO SEG 2, SO FULLWORDS ARE NEEDED
:	TO STORE ADDRESSES		:###LSH
	WS	0			:force to FW boundary!		###wjl
SIOIN	EQ	.-Q*2			:INPUT CCW BLOCK ADDRESSES
R	EQ	0
	RE	SILINS
	WC	SIOBLI+R
R	EQ	R+10
	ER

SIORSP	EQ	.-Q*2			:RESET BUFFER POINTERS
R	EQ	0
	RE	SILINS
	WC	SIOBLR+R
R	EQ	R+30			:larger SIO reset buffer needed
	ER

	SYAD(SIOIN )
	SYAD(SIORSP)			:pair of useful symbols
      EI	:SILINS

SIOBLA	WS	0			:address where output rotor/CCW
					:set/pair starts
      IF	NLINES-SILINS		:do sync lines first
Q	EQ	0
	RE	(NLINES-SILINS)
	WC	OROTOR+Q*20		:rotor is 32d bytes per line
Q	EQ	Q+1
	ER
      EI	:NLINES-SILINS
      IF	SILINS			:address of first CCW for each line
Q       EQ      0
	RE      SILINS
	WC      SIOD|Q|
	GL      SIOD|Q| 	:if 1-SIBFLl then defined in FIN
Q       EQ      Q+1
	ER
      EI	:SILINS
	SYAD(SIOBLA)		:useful address

SIONCB  HS      0
       IF	 NLINES-SILINS   :sync is limited to 2 rotors per line
	RE      NLINES-SILINS
	HC      2*10		:sync has two per line
	ER
       EI
       IF	 SILINS  	:SIO tymfiles specifies number of CCWs
	RE      SILINS
	HC      NCHAIN*10		:size of rotors/CCW for a line
	ER
       EI 	:SILINS


      IF	SILINS
	WS      0
SIOIPG  EQ      .-((NLINES-SILINS)*4)   :access by line # (not sio relative)
Q       EQ      0
	RE      SILINS
	WC      SOPG|Q|
	GL      SOPG|Q| 	:if 1-sibfrl then defined in FIN
Q       EQ      Q+1
	ER

	EI	:SILINS

STRTYP	EQ	0C			:STARLINK LINK TYPE
DWICNT	EQ	1F0		:Count of halfwords for DWL input transfer
	SUBTTL	LINKER (IZLNKR - LINKER segment initializer)

::*********************************************************************
::
::	SUBROUTINE:	IZLNKR:
::	FUNCTION:	LINKER segment initializer
::	CALLING SEQ:	JAL	R10,IZLNKR	Called from NSTART. 
::	CALLS:		JAL	R9,GFRCHN
::			JAL	R8,HCSET
::			JAL	R9,RSTSTR
::			JAL	R8,HCLEAR
::
::*********************************************************************

IZLNKR	HS	0
	ST	R10,IZLNLR		:SAVE LINK REGISTER

        lcs     r0,1
qq      eq      0
        re      lksize/4
        st      r0,borzap+qq            :init borzap so links can talk  ###sdw
qq      eq      qq+4
        er

::Now link the Record Descriptors together for each link
	LI	CD,CDSC			:LINK THE RECORD DESCRIPTOR CHAIN
	STH	CD,FREELR
	LI	R1,CDSZ+CDSC
	La	R2,recbuf+2,,		:last digit 2 so sio no copy on send
	LHI	R3,nrecd0		:those before sio dma
IZLN1	STH	R1,RLNK,CD		:RLNK POINTS TO NEXT REC DESCR IN CHAIN
	ST	R2,BREC,CD		:BREC POINTS TO RECORD DATA BUFFER
	LR	CD,R1			:ADVANCE TO NEXT RECORD DESCRIPTOR
	AHI	R1,CDSZ
	AHI	R2,RECBSZ		:ADVANCE TO NEXT DATA BUFFER
	SIS	R3,1			:REPEAT IF MORE RECORDS LEFT
	JG	IZLN1

       if	bigcon
	LI	R2,RECBU1+2		:last digit 2 so sio no copy on send
	LHI	R3,nrecd1		:those before sio dma
IZLN10	STH	R1,RLNK,CD		:RLNK POINTS TO NEXT REC DESCR IN CHAIN
	ST	R2,BREC,CD		:BREC POINTS TO RECORD DATA BUFFER
	LR	CD,R1			:ADVANCE TO NEXT RECORD DESCRIPTOR
	AHI	R1,CDSZ
	AHI	R2,RECBSZ		:ADVANCE TO NEXT DATA BUFFER
	SIS	R3,1			:REPEAT IF MORE RECORDS LEFT
	JG	IZLN10
       ei 	:bigcon

	LCS	R0,1			:LAST RECORD GETS A -1 IN RLNK
	SHI	CD,CDSZ
	STH	R0,RLNK,CD
       IF	 LNKDBG  		:				###sdw
	STH	R0,PSLNUM		:PAKET SAVE FLAG INIT TO 0FFFF ###AL
       EI 	:LNKDBG

:	THE RECORD DESCRIPTORS ARE ALL CHAINED. NEXT, ASSIGN 'WSIZE'
:	RECORD DESCRIPTORS TO EACH LINK FOR INPUT AND OUTPUT. THE 'RLNK'
:	FIELD OF THE LAST RECORD DESCRIPTOR ASSIGNED ON A LINK IS SET
:	TO POINT BACK TO THE FIRST RECORD DESCRIPTOR, FORMING A CLOSED
:	RING OF 'WSIZE' RECORD DESCRIPTORS.
::	LHI	KD,KDLST		:INIT LINK DESCRIPTORS

:	start to initialize every KD


	LHI	R8,2*(NLINKS-1)		:2*LAST LINK #
IZLN2	L	KD,KDKN,R8,R8		:GET LINK DESCRIPTOR POINTER
       IF	 WSZTST  		:flexible windowsize logic
	LHL	R1,XWSZKN,R8		:can't be changed by xray WZ cmd
       ELSE     :not WSZTST		:prior to xray WZ cmd
	LHL	R1,WSZKN,R8		:WINDOW SIZE FOR THIS LINK
       EI 	:WSZTST
	NHI	R1,0FF  		:other byte has tunnel stuff
	JE	IZLN4			:no windows, skip
:	do all output windows first since they have to be within 2 segs of
:	the end of the sio DMA region.  the input windows (when bigcon)
:	can safely continue beyond the SIO DMA region.
	JAL	R9,GFRCHN		:GET ANOTHER STRING
	STH	R2,OSEC,KD
	STH	R2,RLNK,R3
IZLN4	STB	R1,WSIZ,KD
	LHL	R1,NEIKN,R8		:GET THE NODE #
	STH	R1,NDID,KD		:SAVE IT
	STH	R1,ONDID,KD
	LR	R1,R8			:GET LINK NUMBER TO R1
	SRLS	R1,1
	STB	R1,LKNM,KD		:STORE LINK # FOR CONVENIENCE
	LB	R0,KNSAT,R1
	STB	R0,KSPD,KD		:INIT KSPD, INCLUDES SATELLITE BIT IF 


SIZL50	SIS	R8,2			:Decrement HW index
	JGE	IZLN2

	LHI	R8,2*(NLINKS-1)		:2*LAST LINK #
IZLN41	L	KD,KDKN,R8,R8		:GET LINK DESCRIPTOR POINTER
       IF	 WSZTST  		:flexible windowsize logic
	LHL	R1,XWSZKN,R8		:can't be changed by xray WZ cmd
       ELSE     :not WSZTST		:prior to xray WZ cmd
	LHL	R1,WSZKN,R8		:WINDOW SIZE FOR THIS LINK
       EI 	:WSZTST
	NHI	R1,0FF  		:other byte has tunnel stuff
	JE	IZLN42			:no windows, skip
	JAL	R9,GFRCHN		:GET STRING OF RECORDS FROM FREE LIST
	STH	R2,ISEC,KD		:ISEC PTS TO START OF CHAIN
	STH	R2,RLNK,R3		:LAST LINK NOW PTS TO FIRST REC
izln42  sis	r8,2
	jge     izln41


::Continue with sync line and SIO initialization
	LHI	R0,SYLMRK-SEG1		:INIT SYLVER P-COUNTERS
	LA	R1,QSYLVR
	LHI	R2,NLINES
	JAL	R8,HCSET

	LHI	R11,NETID
	LHI	LN,(NLINES-1)*2		:reset all lines
IZLN3	STH	R11,LNETID,LN		:init NETID for all lines

	JAL	R9,RSTSTR
IZLNA1
	LHL	R1,SVBDIS,LN		:IGNORE ANY DATA IN INPUT BUFF
	LCS	R0,4
	NH	R0,SVNTIP,R1,
	STH	R0,SVNTOP,LN
	SIS	LN,2
	JGE	IZLN3			:##AL

	LA	R1,BGLIST		:CLEAR OUT BAD GUY LIST
	LHI	R2,BGLSIZ+MRESTZ	: AND RESET LIST
	JAL	R8,HCLEAR
	L	R10,IZLNLR		:RESTORE LINK REGISTER
	JR	R10

	SUBTTL	LINKER (SIOIZ - Initialize SIO lines)

	IF	SILINS

::*********************************************************************
::
::	SUBROUTINE:	SIOIZ:
::	FUNCTION:	Initialize SIO lines
::	CALLING SEQ:	JAL	R10,SIOIZ	Called from G02SEC.
::	CALLS:		JAL	R10,SIOIZ0
::
::*********************************************************************

:	SIOIZ IS CALLED FROM THE TWO-SECOND ROUTINE AND POLLS ALL SIO
:	LINES LOOKING FOR LINES WHICH HAVE HAD AN INTERRUPT AND NEED TO
:	BE RESTARTED.  THE INDICATION THAT AN SIO LINE NEEDS
:	RE-INITIALIZATION IS BASED ON A NON-ZERO VALUE IN SIOSTT+8.  IF
:	AN SIO INTERRUPT HAS OCCURRED, THE SIOSTT+8 VALUE IS THE STATUS
:	SENSED IN THE INTERRUPT ROUTINE.

SIOIZ	HS	0
	LHI	LN,SBASE		:CHECK ALL SIO LINES
	ST	R10,SIOIZL		:SAVE RETURN
SIOIZZ	JAL	R10,SIOIZ0		:ATTEMPT TO INITIALIZE LINE
	AIS	LN,2			:ADVANCE TO NEXT LINE
	CLHI	LN,NLINES*2		:ALL DONE?
	JLBS	SIOIZZ			:NO, LOOP ON
	L	R10,SIOIZL		:YES, RECOVER LINK
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SIOIZ0:
::	FUNCTION:	Initialize SIO lines
::	CALLING SEQ:	JAL	R10,SIOIZ0
::	INPUT:		LN = 2*Line Number
::	CALLS:		JAL	R8,CRYPTO
::			HC	xxxx
::
::*********************************************************************

:	SIOIZ0 WILL INITIALIZE THE SIO LINE INDICATED BY LN IF THE
:	STATUS HW AT SIOSTT+8 IS NON-ZERO. THE INITIALIZATION CONSISTS
:	OF ISSUING CONNECT, START OUTPUT,AND START INPUT SVC'S.
:
:	SIOIZ0 IS FIRST INVOKED AT NODE STARTUP TIME (NSTART CALLS IZLINKR
:	CALLS RSTSTR CALLS SIOIZ0). RSTSTR WRITES A -3 INTO SIOSTT TO
:	CAUSE INITIALIZATION WITHOUT GENERATING CRYPTO MESSAGES

:	SIOIZT - SIO INITIALIZATION TIME EQUATE				###wjl
:	USED BELOW AS TIME TO WAIT FOR INITIALIZATION TO COMPLETE	###wjl
:	>>NOTE THAT SIOIZT MAY BE SET IN THE TYMFILE<<			###wjl
::
	IF	TSI
	DEFAULT(SIOIZT,$A 20)   :20ms for TSI
	ELSE    HMICRO
	DEFAULT(SIOIZT,$A 20)   :20 ms for HMICRO
	ELSE    :engine
	DEFAULT(SIOIZT,$A 9)    :9 ms for engine
	EI	:TSI/HMICRO/ENGINE
SIOIZT  EQ      SIOIZT*RATE/($A1000)+1 :number of fastc ticks +1 for rounding


SIOIZ0	HS	0
	LHI	R6,MSBASE,LN	:SET R6 TO 2*(RELATIVE SIO LINE NUMBER)
	SLLS	R6,3		:AND MULTIPLY BY 8
	LR	R3,R6		:R3 = 16*(RELATIVE SIO LINE NUMBER)
	LI	R2,SIOEND	:POINT TO END OF SIO DMA AREA
	GL	SIOEND
	AI	R3,SIOSTT	:POINTER TO CURRENT STATUS AREA

:	THE HALFWORD AT SIOSTT+8 IS NON-ZERO IF SIO INITIALIZATION IS
:	REQUIRED.  IF AN SIO INTERRUPT IS TAKEN, THE INTERRUPT ROUTINE
:	STORES THE POSITIVE STATUS WORD IN SIOSTT+8, SINCE
:	RE-INITIALIZATION IS NECESSARY AFTER AN SIO INTERRUPT.  IF THE
:	SOFTWARE DECIDES TO INITIALIZE, IT STORES A NEGATIVE VALUE INTO
:	SIOSTT+8.

SIOIZ2	LH	R1,8,R3		:SEE IF INITIALIZATION REQUIRED
	JER	R10		:NO, RETURN TO CALLER

	CLHI	R1,0FFFF	:BAD SIO RECORD LENGTH?			###OAS
	JE	SIOIZ8		:YES - SIOSTT+8 SET TO -1 IN SIORIN	###OAS
				:SEND CRYPTO MSG 53 AND INIT		###OAS
	CLHI	R1,0FFFE	:NO RECS RECEIVED FOR 4 SECS?		###OAS
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -2 IN LNCHCK	###OAS
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
	CLHI	R1,0FFFD	:LINE GONE TO RESET STATE?		###OAS
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -3 IN RSTSTR	###OAS
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
	CLHI	R1,0FFFC	:DMA TIME OUT?				###OAS
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -4 IN G01SEC	###OAS
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
	CLHI	R1,0FFFB	:RE-INIT DUE TO PORT SWITCH?
	JE	SIOIZ4		:YES - SIOSTT+8 SET TO -5 IN SIOIZ0
				:INIT, BUT NO CRYPTO MESSAGE		###OAS
       if	bigcon
	clhi    r1,0fff0	:do init for dma window resetting
	je      siozd1  	:of course no crypto msg
       ei 	:bigcon
	IF	HMICRO		:HDLC micro only			###wjl
	CLHI	R1,0FFFA	:re-init due to software init timeout?	###wjl
	JE	SIOIZC		:yes - SIOSTT+8 set to -6 in SIOIZ0	###wjl
	EI	:HMICRO		:					###wjl

:	NOT A SOFTWARE "INTERRUPT" BUT A REAL ONE, SIOSTT+8 CONTAINS
:	4 NIBBLES OF - INTERRUPT STATUS, PORT #, 0, CONDITION CODE.

SIOIZ3
	LHL	R8,NGSVLN,LN	:REAL INTERRUPT...GET LAST NEIGHBOR ON LINE
SIOIZY	LR	R0,R1		:R0 = INT. STAT, PORT#, 0, MBOARD STAT.	###OAS
	LR	R1,LN		:GET LINE#*2
	SLLS	R1,0F		:SHIFT TO HO HW
	OR	R1,R8		:COMBINE LINE# AND LAST NEIGHBOR
	ST	R1,CRYSBF	:FOR HW3&4 OF CRYPTO REPORT		###OAS
	LR	R1,R0		:R1 = STAT - PORT - 0 - CC		###OAS
	NI	R1,0000F000	:R1 = STAT - 0 - 0 - 0			###OAS
	SLLS	R1,4		:MOVE STATUS TO HO HW			###OAS
	NHI	R0,000F		:R0 = CC				###OAS
	OR	R0,R1		:AND COMBINE FOR CRYPTO HW1 & 2		###OAS
	JAL	R8,CRYPTO	:SEND CRYPTOGRAM
	HC	CRYE1D		:INDICATE SIO LINE INITIALIZATION

:	JUMP BACK HERE FROM SIOIZ8 or SIOIZC
:	SOFTWARE-INDUCED SINGLE LINE INITIALIZATION
SIOIZ4
       if	bigcon
	l	r0,kdln,ln,ln   :is this line connected?
	jg      siozd0  	:yes, make sure dma is correct
       ei 	:bigcon
	LIS	R0,0		:CLEAR OUT INITIALIZATION CONDITION
	STH	R0,8,R3
	LR	R0,LN		:SIO LINE NUMBER * 2
	LA	R1,RECBUF,,     :start of sio dma region
:	entry for siozd1 (reseting sio dma region)
sioiz5	SRLS	R0,1		:LINE NUMBER
	SVC	IO,90		:CONNECT SIO LINE. R0,R1,R2,R3 = PARAMETERS
	JAL	R12,SVCE39	:ERROR, CRASH
	LH	R8,0,R3		:SEE IF PORT AVAILABLE			###OAS
	CLHI	R8,0FFFF	:IF FFFF PORT NOT AVAILABLE
	JN	SIOPT1		:PORT AVAILABLE
	LCS	R8,5		:FLAG -5 IN SIOSTT+8 TO CAUSE
	STH	R8,8,R3		:RE-INIT TO OCCUR
	SBT	R0,SIOPTA	:FLAG PORT AS UNAVAILABLE
	JNFS	SIOPT2		:PREVIOUSLY FLAGGED, NO CRYPTO MESSAGE
	JAL	R8,CRYPTO	:REPORT SIO PORT UNAVAILABLE, R0 = LINE#
	HC	CRYE72
	JFS	SIOPT2		:AND CONTINUE
SIOPT1	RBT	R0,SIOPTA	:FLAG PORT AS AVAILABLE
	L	R1,SIOIPG,LN,LN :initialize the line driver
	SVC	IO,0B0		:START OUTPUT - R1 CONTAINS CCW ADDRESS
	JAL	R12,SVCE3B	:ERROR, CRASH
SIOPT2	HS	0		:SKIP OUT SVC DUE TO PORT UNAVAILABLE	###OAS
SIOIZ6	HS	0
:	instead of have the machine loop for a period of time, just put
:	sio status of a line which still has to completed initialization###sdw
	sbt     ln,sionog
	LHI	R8,SIORWT-SEG1  :the wait for connect output to complete state
	CH	R8,SIOTST,LN    :are we already in wait state?
	JEFS    SIOIZG  	:don't let saved state be wait state
	LHL	R4,SIOTST,LN    :get current state
	STH	R4,SIOTSV,LN    :save it
	STH	R8,SIOTST,LN    :new state is wait
SIOIZG  L	R4,FASTC,,	:set how long to wait
	AHI	R4,SIOIZT 	:fastc ticks to wait
	ST	R4,SIOTIM,LN,LN :when initializtion will be finished    ###sdw
	LCS	R8,1
	LHL	R4,SIBUFP,LN	:GET RELATIVE INPUT BUFFER ADDRESS
	STH	R8,SIBUF,R4,	:	AND STORE A -1 IN FIRST HALFWORD (MEANS
	LIS	R4,0
	STH	R4,SIBUFN,LN	:SET INDEX TO BEGINNING

	L	R6,SIOBLA,LN,LN :address of CCW block   		###sdw
Q       EQ      0
	LHI	R7,200
	RE      NCHAIN
	STH	R7,Q*10,R6	:store not busy in all CCWs
Q       EQ      Q+1
	ER
	LIS	R7,0
	STB	R7,SIOTB,LN     :no active CCWs yet
	STB	R7,SIOFB,LN

::	under siofxi, the connect input is done when the wait state is clear
::	so do not do the following.	as in 39:linker.vx6		###cwc
	JR	R10		:RETURN

:	REPORT SIO BAD RECORD LENGTH TO XRAY
SIOIZ8	LR	R0,LN
	SLLS	R0,0F			:ALIGN LINE NUMBER IN UPPER HW,
	LHL	R8,NGSVLN,LN		:	NEIGHBOR NUMBER IN LOWER HW
SIOIZB	OR	R0,R8
	ST	R0,CRYSBF		:STORE FOR CRYPTOGRAM
	JAL	R8,CRYPTO,,		:BAD SIO RECORD LENGTH
	HC	CRYE53
	J	SIOIZ4

:	REPORT SIO INITIALIZATION SOFTWARE TIMEOUT TO XRAY		###wjl
	IF	HMICRO		:HDLC micro only			###wjl
SIOIZC	HS	0		:					###wjl
	LR	R0,LN		:get line#*2				###wjl
	SRLS	R0,1		:line#					###wjl
	SBT	R0,SIOIGN	:flag for no crypto next time		###wjl
	JN	SIOIZ4		:previously flagged?			###wjl
	JAL	R8,CRYPTO	:report SIO init software timeout	###wjl
	HC	CRYE7B		: R0=line#				###wjl
	J	SIOIZ4		:continue...				###wjl

	EI	:HMICRO		:					###wjl

:	if bigcon then the location of the output sectors for this link
:	have to be within 2 segments of the other end of the SIO dma region.
       if	bigcon
siozd0  l       kd,kdln,ln,ln   :get link descriptor
siozd1  lis	r0,0
	sth	r0,8,r3 	:clear sio reinit
	lhl	r1,osec,kd	:kd set up since called from attlin
	lb	r2,wsiz,kd
	sis	r2,1
siozd2  lhl	r1,rlnk,r1
	sis	r2,1
	jgbs    siozd2
	l	r2,brec,r1
	ci	r2,sioend		:does it end before SIO stuff
	jgfs    siozd3
	li	r2,sioend		:nope, use sioend
	jfs     siozd4
siozd3  ahi	r2,100
	nhi	r2,-10  		:sio likes quadword
siozd4  lhl	r1,osec,kd		:do start of output record
	l	r1,brec,r1
	ci	r1,sopg0		:start of SIO area
	jgfs    siozd5
	nhi	r1,-10
	jfs     siozd6
siozd5  li	r1,sopg0
siozd6  lr	r0,ln
	j       sioiz5
       ei 	:bigcon

::*********************************************************************
::
::	ABNORMAL RETURN FROM SIO SVC'S FOR CONNECT, OUTPUT AND INPUT
::
::	RETURN CODES IN HO HW OF R0
::
::	ISIS -- CONNECT MBOARD	SVC IO,090
::		IMPROPER REGISTER USAGE		RC=0001
::		LU RANGE CHECK			RC=0002
::		NULL LU POINTER			RC=0002
::		BAD DEVICE TYPE			RC=0002
::		MBOARD RC=8, 35MS TIMEOUT	RC=0003
::		MBOARD RC=4, MBOARD ERROR	RC=0004
::		CCW NOT ON BND10		RC=0005
::		INVALID RETURN ADDRESS		RC=0005
::
::	ISIS -- OUTPUT, INPUT SIO  SVC IO,0B0	SVC IO,0A0
::		SAME RETURN CODES AS ABOVE, BUT IN ADDITION
::		SVC IO,090 NOT ISSUED YET	RC=0002
::*********************************************************************

SVCE39	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE IN HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZC			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV39C)			:ALL OTHER RETURN CODES, CRASH	###OAS
SVCE3B	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE FROM HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZO			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV3BC)			:ALL OTHER RETURN CODES, CRASH	###OAS
SVCE3A	LR	R2,R0			:SAVE R0 (CONTAINS LN #)	###OAS
	NHI	R0,7FFF			:CLEAR ERROR CODE IN HO HW	###OAS
	EXHR	R2,R2			:GET SVC RETCODE IN LO HW	###OAS
	NHI	R2,000F			:MASK OUT HO HW			###OAS
	CLHI	R2,0003			:CHECK FOR TIMEOUT		###OAS
	JE	SIOBZI			:YES, MAKE REPORT		###OAS
	CLHI	R2,0004			:CHECK FOR MBOARD ERROR		###OAS
	JE	SIOXXX			:YES, MAKE CRYPTO REPORT	###OAS
	CRASH.(.SV3AC)			:ALL OTHER RETURN CODES, CRASH	###OAS

	EI	:SILINS


	SUBTTL	LINKER (LKVOLT - Test for links overloaded)

::*********************************************************************
::
::	SUBROUTINE:	LKVOLT:
::	FUNCTION:	Test for network links overloaded or saturated
::	CALLING SEQ:	JAL	R10,LKVOLT	Called from G01SEC.
::	CALLS:		JAL	R10,SUP14,,	:to make overload reports
::			JAL	R8,CRYPTO
::			HC	xxxx
::
::*********************************************************************

:	TEST FOR NETWORK LINKS OVERLOADED (ALL ACTIVE CHANNELS NOT
:	BEING SERVICED FREQUENTLY ENOUGH) OR LINK SATURATED
:	(OUT OF BANDWIDTH). REPORT TO SUP IF THRESHOLD EXCEEDED.
:
:	COMPARE LINK LOAD COUNTS TO REPORTING THRESHOLDS, AND MAKE
:	REPORT IF THRESHOLDS EXCEEDED.  OVERLOAD COUNTS ARE MAINTAINED
:	IN LKOVLD, AND LINK SATURATED COUNTS IN LKSTCT.  BOTH LKOVLD AND
:	LKSTCT ARE UPDATED BY THE 'CKOVLD' ROUTINE WHICH RUNS EVERY 1/2
:	SECOND.
:
:	LINK NUMBER IN KN, LINK DESCRIPTOR IN KD.

:	PATCHABLE THRESHOLD REFERENCE VALUES
LKOVCT	HC	LKOVTH
	SYAD(LKOVCT)			:OVERLOAD THRESHOLD
LKSATC	HC	LKSTTH
	SYAD(LKSATC)			:SATURATED THRESHOLD

LKVOLT	HS	0
	ST	R10,LNKRET		:SAVE RETURN LINK
	LHI	KN,NLINKS		:LINK NUMBER - SCAN ALL LINKS
	LIS	R12,0			:FOR REFRESHING COUNTERS
	LHI	R7,8000			:R7 FOR OR'ING HI-ORDER BIT OF HALFWORD

LKOV02	SIS	KN,1			:TEST ALL LINKS
	JL	LKOVXT			:DONE

	TBT	KN,ALINKS		:ACTIVE LINK?
	JEBS	LKOV02			:NO
	SLLS	KN,1
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR ADDRESS
	SRLS	KN,1
	LB	R0,NLAT,KD		:ANY LINES ATTACHED?
	JEBS	LKOV02			:NO - LINK NOT UP
	LHL	R1,LKSTCT,KN,KN		:GET LAST MINUTE'S SATURATED COUNT
	STH	R1,KS.SAT,KD		:	AND SAVE IN LINK DESCRIPTOR
	LHL	R1,LKOVLD,KN,KN		:GET LAST MINUTE'S OVERLOAD COUNT
	STH	R1,KS.OVL,KD		:	AND SAVE IN LINK DESCRIPTOR
	STH	R12,LKOVLD,KN,KN	:CLEAR COUNTER FOR NEXT MINUTE
	CLH	R1,LKOVCT		:OVERLOAD THRESHOLD EXCEEDED?
	JLE	LKOV06			:NO -  CHECK LINK SATURATED COUNT

:	REPORT LINK OVERLOAD TO SUP...
	LHI	R5,LKOVMS		:TYPE 14, SUBTYPE LKOVMS
LKOV04	HS	0
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER FOR REPORT
	JE	LKOV02			:(IF ZERO, LINK NOT UP)
	STH	R0,CRYSBF+2		:STORE NEIGHBOR # FOR CRYPTO	###OAS
	OR	R0,R7
	STH	R0,SUPMBF		:STORE NEIGHBOR NUMBER FOR REPORT
	OR	R1,R7
	STH	R1,SUPMBF+2		:AND NUMBER OF OCCURRENCES
	LIS	R6,2			:INDICATE 2 HALFWORDS
	JAL	R10,SUP14,,		:REPORT LINK CONDITION TO SUPERVISOR
	GL	SUP14
	LR	R0,R1			:SAVE COUNT FOR CRYPTO		###OAS
	NHI	R0,7FFF			:STRIP OFF HO BIT		###OAS
	CLHI	R5,LKOVMS		:CHECK WHICH CRYPTO TO SEND	###OAS
	JNFS	LKOV08			:SEND SATURATED			###OAS
	JAL	R8,CRYPTO		:LINK OVERLOAD			###OAS
	HC	CRYE36			:				###OAS
	LIS	R12,0			:RECOVER R12 IN CASE MESSED UP	###OAS
	JFS	LKOV06			:				###OAS
LKOV08	HS	0			:				###OAS
	JAL	R8,CRYPTO		:LINK SATURATED			###OAS
	HC	CRYE37			:				###OAS

LKOV06	LHL	R1,LKSTCT,KN,KN		:NUMBER OF LINK SATURATED OCCURRENCES
	STH	R12,LKSTCT,KN,KN	:CLEAR COUNTER
	CLH	R1,LKSATC		:SATURATED THRESHOLD EXCEEDED?
	JLE	LKOV02			:NO

:	REPORT LINK SATURATED TO SUP
	LHI	R5,LKSTMS		:TYPE 14, SUBTYPE LKSTMS
	J	LKOV04
LKOVXT	L	R10,LNKRET
	JR	R10			:RETURN

	SUBTTL	LINKER (Trace-sync set-up subroutines)

	IF	TSTSZE

::*********************************************************************
::
::	SUBROUTINE:	TSFUAL:
::	FUNCTION:	Check if tracing desired on unassigned line...
::	CALLING SEQ:	JAL	R2,TSFUAL
::	INPUT:		R4  = Header HW
::	PRESERVED:	R15
::	CALLS:		JAL	R0,TSFMRK
::
::*********************************************************************

:	COMMON FOR SYNC AND SIO LINES.
TSFUAL	HS	0
	CLH	LN,TSLINE		:TRACING ON THIS LINE DESIRED?
	JNR	R2			:NO, RETURN
	ST	R15,TSRSVE		:SAVE LINK REGISTER
	JAL	R0,TSFMRK		:SET UP ENTRY
	STH	R4,TSFTBL+2,R15		:STORE THE ENTRY (HEADER HALFWORD)
	LIS	R0,0
	STB	R0,TSFTBL+4,R15		:CLEAR RECN FIELD		###OAS
	LIS	R0,TS.UAL		:ENTRY - UNASSIGNED LINE
	STB	R0,TSFTBL,R15
	L	R15,TSRSVE
	JR	R2

:	TSFMRK (FOR FOREGROUND) AND TSBMRK (FOR BACKGROUND) SET UP EVENT
:	ENTRIES FOR CALLING PROCESS.  FASTC AND THE LINE NUMBER ARE
:	STORED, AND THE ENTRY INDEX REGISTER IS RETURNED (R15 FOR
:	FOREGROUND, R7 FOR BACKGROUND).

::*********************************************************************
::
::	SUBROUTINE:	TSFMRK:
::	FUNCTION:	Set up foreground event entry
::	CALLING SEQ:	JAL	R0,TSFMRK
::	INPUT:		LN  = Line Number*2
::	OUTPUT:		R15 = New entry index
::	PRESERVED:	LN  = Line Number*2
::
::*********************************************************************

TSFMRK	HS	0
	ST	R0,TSRSVE+4		:SAVE RETURN ADDRESS
	LHL	R15,TSFPTR
	AIS	R15,TSESZE		:COMPUTE NEW ENTRY ADDRESS
	NHI	R15,TSTSZE-1		:	(ALLOW FOR WRAP)
	STH	R15,TSFPTR
	L	R0,FASTC,,
	ST	R0,TSFTBL+4,R15		:STORE FASTC TIME
	SRLS	LN,1			:FORM TRUE LINE NUMBER
	STB	LN,TSFTBL+1,R15		:STORE LINE NUMBER
	AR	LN,LN			:RECOVER 2*LINE NUMBER
	L	R0,TSRSVE+4
	JR	R0			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TSBMRK:
::	FUNCTION:	Set up background event entry
::	CALLING SEQ:	JAL	R8,TSBMRK
::	INPUT:		LN  = Line Number*2
::	OUTPUT:		R7  = New entry index
::	PRESERVED:	LN  = Line Number*2
::
::*********************************************************************

TSBMRK	HS	0
	LHL	R7,TSBPTR
	AIS	R7,TSESZE		:COMPUTE NEW ENTRY ADDRESS
	NHI	R7,TSTSZE-1		:	(ALLOW FOR WRAP)
	STH	R7,TSBPTR
	L	R9,FASTC,,
	ST	R9,TSBTBL+4,R7		:STORE FASTC TIME
	SRLS	LN,1			:FORM TRUE LINE NUMBER		###OAS
	STB	LN,TSBTBL+1,R7		:STORE TRUE LINE NUMBER		###OAS
	AR	LN,LN			:RECOVER 2*LINE NUMBER		###OAS
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TSNSPK:
::	FUNCTION:	Save most recent packets when link goes out.
::	CALLING SEQ:	JAL	R8,TSNSPK
::	INPUT:		KD  = linK Descriptor
::	DESTROYED:	All Preserved
::
::*********************************************************************

TSNSPK
       IF	 LNKDBG
	STM	R0,REGST		:save regs for LINK/line debugger
	JAL	R14,TSIDB1,,		:save input packets
	JAL	R14,TSODB1,,		:save output packets
	GL      TSODB1,TSIDB1
	LM	R0,REGST		:				###sdw
       EI 	:LNKDBG
	JR	R8

	EI	:TSTSZE

	SUBTTL	LINKER (LINKER - Detach, attach scheduler)

::*********************************************************************
::
::      SUBROUTINE:     OSRLIN 
::      FUNCTION:	send Old Style Resets on idle LINes for a sec
::      CALLING SEG:    on R10 from 4 minute logic
::      Solve problem with 5.10 neighbors.  They will   		###sdw
::      stop sending resets and we will send them only new style resets and
::      thus the line never comes up.  So every four minutes we will simply
::      send an old style reset and then next time to 1sec we go back to
::      expanded reset.  We set bits for the 1 sec logic to find and retunr
::      to expanded reset packet if we don't start ping/ponging on old style
::	reset.
::*********************************************************************

OSRLIN  ST	R10,OSRLSV		:save link reg
	LHI     LN,NLINES*2-2		:for each line 
OSRLI2  L	SD,SDLN,LN,LN		:get reset descriptor
	L       KD,KDLN,LN,LN		:see if link up
	JG      OSRLI1  		:is up (no send it reset)
	lhl	r0,intacp,,		:maybe a dline load going on
	xhi	r0,-1
	sth	r0,osrtmp
osrl03  lhl	r0,osrtmp
	jffoh   r0,osrl05
	j       osrl07  		:have to check out active ports
osrl05  sth	r0,osrtmp
	rbt	r1,osrtmp		:only do port once
	CLH     LN,DWLNUM,R1,r1 	:get number of line being loaded
	JE      OSRLI1  		:in progress, skip this line
	jbs     osrl03
osrl07  LHL	R0,RSTIM,SD		:see if reset sequence in progress
	JEFS    OSRLI3  		:not in progress
	SH	R0,SLOWC+2,,		:see if should have timed out
	LHR	R0,R0			:worry about high bit
	JG      OSRLI1  		:timer still going
	JFS     OSRLI5  		:and send old style reset
OSRLI3  LR	R1,LN			:get a real line number
	SRLS	R1,1
	TBT	R1,LNSUSC		:is line suspended?
	JN      OSRLI1  		:suspended is okay, next line

OSRLI5  L	SD,SDLN,LN,LN		:get reset descriptor
	JAL	R9,RSTSTR		:restart reset process
	LHI	R4,TTRSHD		:existing instructions
	STH	R4,XRSTP,SD		:old reset header stored
	LHI	R0,MACHNM		:new logic: construct old reset packet
	STH	R0,XRSTP+2,SD
	L	R0,TTRSET+4		:write old reset packet data
	ST	R0,XRSTP+4,SD
	LI	R0,VERCOM
	ST	R0,XRSTP+8,SD
	LHI	R3,XSDSZ-10
	LCS	R2,1			:overwrite old data
OSRLI7  ST	R2,XRSTP+0C,SD,R3
	SIS	R3,4
	JGEBS   OSRLI7
       IF	 SILINS
	CLHI    LN,(NLINES-SILINS-1)*2  :sio lines have another reset xmit buf
	JLE     OSRLI9
	L	R6,SIORSP,LN,LN
	L	R0,XRSTP,SD		:copy reset packet
	ST	R0,2,R6 		:first HW is count for SIO packet
	LI	R0,VERCOM
	ST	R0,6,R6
       EI 	:SILINS
:	now will send old style resets.  Must make sure we only do it for
:	a second.  So set a bit for this line for 1sec logic to find!
OSRLI9  LR	R1,LN
	SRLS	R1,1			:make it a line number
	SBT	R1,OSRLIR		:tell 1sec about this
	RBT	R1,OSRLIH		:extra careful on history
	LHI	R1,TXRSHD		:if don't receive a response
	STH	R1,VRSTP,SD		:then last received is this

:	next line or exit.
OSRLI1  SIS     LN,2			:next line
	JGE     OSRLI2
	L	R10,OSRLSV		:restore link
	JR	R10


::**********************************************************************
::
::      SUBROUTINE:     ESRLIN
::      FUNCTION:	to resume sending Expanded Reset packets after OSRLIN
::			sent a few old style reset packets.
::      CALLING SEQ:    on R10 from 1 sec logic.
::      or so of old style resets is sent.  Note that ESR is expanded reset.
::      This routine is completely dependent on OSRLIN.  Notice that when we
::      sent the OSR we put a ESR header in received reset buffer.  So if
::      1sec logic finds an OSR header then we have received an OSR packet
::      from neighbor and we don't interfere.  If no packet received we
::      store an ESR header since we want to return to sending ESR packets
::      and RESET XSRTBT since that will be detected in ATTLIN as an abort
::      and then setting LINATT is needed to run ATTLIN for this line.
::      and OSR is old style resets.
::************************************************************************

ESRLIN  LHI	R2,LNSIZE-4		:do each line
ESRLI1  L	R0,OSRLIH,R2,		:port ready to go to back to ESRs?
	JN      ESRLI4
	SIS	R2,4
	JGEBS   ESRLI1
	LHI	R2,LNSIZE-4		:update history before exiting
	LIS	R1,0			:and clear current
ESRLI3  L	R0,OSRLIR,R2
	ST	R0,OSRLIH,R2
	ST	R1,OSRLIR,R2		:clear current
	SIS	R2,4
	JGEBS   ESRLI3  		:for all lines
	JR	R10			:and done

:	idle line which we sent an old style reset
ESRLI4  JFFO	R0,ESRLI5
ESRLI5  SLLS	R2,3
	LR      LN,R1
	AR      LN,R2			:make real line number
	RBT     LN,OSRLIH		:done for this line
	AR      LN,LN			:make 2*line number
	L	SD,SDLN,LN,LN		:get reset descriptor
	LHL	R4,VRSTP,SD		:see if received OSR
	NHI	R4,0FFE0		:remove any sequence or second line
	CLHI	R4,TTRSHD		:we had put an ESR header there
	JE      ESRLIN  		:so we must have received a good reset
	LR	R1,LN
	SRLS	R1,1
	SBT	R1,LINATT		:make it think it got a reset packet
	LHI	R1,TXRSHD		:but different than last send
	STH	R1,VRSTP,SD
	RBT     LN,XRSTBT		:make it find a switch from OSR to ESR
	LHI	R0,1F-PLINKR
	SBT	R0,TLINKR
	J       ESRLIN  		:next line


::*********************************************************************
::
::	PROCESS:	LINKER:
::	FUNCTION:	Detach, attach scheduler & Tymtunnel building	###AL
::	CALLING SEQ:	LINKER is scheduled every 125 ms as a result of
::	a request for services (ie, when a reset is detected on any line)
::	and hara-kiri's when all its processing is done.
::	SUB-PROCESSES:	DETLIN, ATTLIN, TNBULD if TUNL switched.
::	RETURNS:	J	EXDIS
::
::*********************************************************************

:	ATTACHES NEWLY IDENTIFIED LINES TO EXISTING LINKS, OR, IF NO
:	LINKS EXIST TO THAT NEIGHBOR, CREATES ONE.  DETACHES FROM LINKS
:	LINES THAT HAVE GONE RESET, TEARING DOWN LINK IF NO ATTACHED LINES
:	REMAIN.

LINKER	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(LINKER)			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU

:	standard set up and JAL to BIDDY - CALL DETLIN			###wjl	
	GBIDDY(LNSIZE,LINDET,DETLIN)	:R4<=count, R3<=addr, R9=JAL	###wjl

	LIS	R2,0
LINKR2	L	R3,LINATT,R2		:COPY LINATT TO LINKAS
	ST	R3,LINKAS,R2
	AIS	R2,4
	CI	R2,LNSIZE
	JL	LINKR2

:	standard set up and JAL to BIDDY - CALL ATTLIN			###wjl
	GBIDDY(LNSIZE,LINKAS,ATTLIN)	:R4<=count, R3<=addr, R9=JAL	###wjl

:	Tymtunnel building scheduled for origination node to send needle ##AL

	IF	DB.CPU
	JALMAC(CPUTIZ)			:START CPUTIL FOR LINKER RETURN	###OAS
	CPUTNM(LNKRET)			:CREATE CPUTIL ENTRY FOR LNKRET	###OAS
	EI	:DB.CPU

	LIS	R2,0
	LIS	R3,0
LNKD2	O	R3,LINATT,R2		:CHECK ARRAY
	O	R3,LINDET,R2
	AIS	R2,4
	CI	R2,LNSIZE
	JL	LNKD2
	LR	R3,R3			:ANY BITS SET ?
	JNFS	LNKDIS
	LHI	R0,1F-PLINKR
	RBT	R0,TLINKR
LNKDIS	LA	R0,LINKER
	J	EXDIS

	SUBTTL	LINKER (Periodic processes)

::*********************************************************************
::
::	SUBROUTINE:	G02SLK:
::	FUNCTION:	Two-second logic for the LINKER segment
::	CALLING SEQ:	JAL	R10,G02SLK	Called from G02SEC.
::
::*********************************************************************

G02SLK	HS	0
	LIS	R2,0
G02SL2	L	R0,INHRLS,R2		:CLEAR RESET INHIBIT (EVERY 2 SECS)
	N	R0,INHRST,R2
	X	R0,INHRST,R2
	ST	R0,INHRST,R2
	ST	R0,INHRLS,R2
	AIS	R2,4
	CI	R2,LNSIZE
	JL	G02SL2
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	G01MLS:
::	FUNCTION:	1-minute logic to examine lines suspended and
::			reinstate if appropriate.
::	CALLING SEQ:	JAL	R10,G01MLS	Called from G01MIN.
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R8,GMTLIN,,
::
::*********************************************************************

G01MLS	HS	0
	LIS	R5,0			:R5 = INDEX INTO ARRAY
G01ML1	L	R0,LNSUSO,R5
	JFFO	R0,G01ML2		:BIT SET
	AIS	R5,4			:NEXT WORD
	CLI	R5,LNSIZE		:DONE ?
	JLBS	G01ML1
	J	G01ML4			:NO MORE
G01ML2	RBT	R1,LNSUSO,R5		:FIRST BIT FOUND
	SLLS	R5,3			:FORM LINE NO.
	OR	R1,R5
	SRLS	R5,3			:RESTORE ###SHM
	SLLS	R1,1
	L	R0,KDLN,R1,R1		:LINK DESCRIPTOR INDEX FOR THIS LINE
	SRLS	R1,1
	AIS	R0,1			:IF -1, LINE IS SUSPENDED
	JN	G01ML1			:LINE NOT SUSPENDED
	LCS	R0,2
	SLLS	R1,1
	ST	R0,KDLN,R1,R1		:LINE WILL NOW LISTEN FOR RESETS
	SRLS	R1,1
	LR	LN,R1			:LINE NO. FOR GMTLIN
	AR	LN,LN			:*DOUBLED
	JAL	R8,GMTLIN,,		:*GET TIME
	J	G01ML1
G01ML4	LIS	R2,0
G01ML5	L	R0,LNSUSC,R2		:COPY LNSUSC TO LNSUSO
	ST	R0,LNSUSO,R2
	LIS	R0,0
	ST	R0,LNSUSC,R2		:CLEAR LNSUSC
	AIS	R2,4
	CI	R2,LNSIZE
	JL	G01ML5
	JR	R10			:RETURN

	SUBTTL	LINKER (LNCHCK - 4 sec test for records received on line)

::*********************************************************************
::
::	SUBROUTINE:	LNCHCK:
::	FUNCTION:	Tests for records received on all lines.
::	CALLING SEQ:	JAL	R10,LNCHCK	Called from G04SEC.
::	CALLS:		JAL	R8,TSBMRK
::			JAL	R8,TSNSPK
::			JAL	R10,KSPEED
::			JAL	R10,SUP13,,
::			JAL	R10,SUP12,,
::			JAL	R8,CRYPTO
::			HC	CRYE1E
::			JAL	R10,SIOIZ0
::
::*********************************************************************

:	********RUNS EVERY 4 SECONDS********

:	FOR ACTIVE CHANNELS IN ADDITION TO ZERO AND ONE (ILC).
LNCHCK	HS	0

:	FOR T-II LINK WITH MULTIPLE LINES, ALL LINES BUT ONE MAY BE
:	DETACHED EACH TIME THROUGH LNCHCK.  FOR SINGLE-LINE LINK, LINK
:	OUT REPORT IS MADE TO SUPERVISOR FIRST FOUR-SECOND INTERVAL WITH
:	NO RECORDS RECEIVED.  FOUR-SECOND GAPS ARE REPORTED TO XRAY, AND
:	CIRCUITS ARE ACTUALLY ZAPPED (AND RESETS EMITTED) ONLY AFTER
:	MULTIPLE FOUR-SECOND GAPS.
	ST	R10,LNCHLR		:SAVE LINK REG
	LHI	KN,NLINKS-1
LNCH04	SLLS	KN,1
	L	KD,KDKN,KN,KN		:LINK DESCRIPTOR

:: Tymtunnel only checks on link, all codes are put together		###AL

	SRLS	KN,1
	LB	R0,NLAT,KD		:NUMBER OF LINES ATTACHED TO THIS LINK
	SIS	R0,1
	JEFS	LNCH06			:SINGLE-LINE LINK - SET KNNLAT TO -1
	STH	R0,KNNLAT,KN,KN		:MAX NUMBER OF LINES TO BE DETACHED
					:	THIS EXECUTION OF LNCHCK
	JFS	LNCH08
LNCH06	TS	KNNLAT,KN,KN		:MAKE LINK OUT REPORT TO SUP IF NO
					:	RECORDS RECEIVED
LNCH08	SIS	KN,1
	JGE	LNCH04			:DO FOR ALL LINKS

	LHI	LN,NLINES-1		:TEST ALL LINES FOR GOOD RECS RECEIVED
LNCH1	SLLS	LN,1
	L	KD,KDLN,LN,LN		:IS THIS LINE ATTACHED?
	SRLS	LN,1			:RESTORE HALF WORD INDEX       ###SHM
	LR	KD,KD			:RESTORE CONDITION CODES       ###SHM
	JL	LNCH4			:NO			       ###SHM
LCH111
LNCH1A	LB	KN,LKNM,KD		:GET LINK NUMBER


	LIS	R0,1			:NO RECS ON LINE?
	RBT	LN,LNGREC
	JE	LNCH6			:NO RECORD RECEIVED ON LINE
LNCH1B	LIS	R0,4			:BORI ZAP?
	TBT	KN,BORZAP
	Je	LNCH3			:'BORI ZAP', DETACH  inverted by sdw
	LIS	R0,2
	TBT	KN,LKGREC		:GOOD RECORD RECEIVED ON LINK?
	JN	LNCH2			:YES, LINE OK.			###TZ
	TBT	KN,OLDKGR		:ANY GOOD RECORDS ON LINK LAST
					:	TIME THRU?		###TZ
	JE	LNCH6			:NO, DETACH THIS LINE		###TZ
	J	LNCH2			:OTHERWISE, LET IT LIVE		###TZ
LNCH3	STB	R0,DREASN,LN		:SAVE REASON FOR OUTAGE
	LH	R1,KNNLAT,KN,KN
	SIS	R1,1			:DECREMENT NUMBER OF LINES DETACHED
	STH	R1,KNNLAT,KN,KN		:	THIS EXECUTION OF LNCHCK...
	LB	R1,NLAT,KD		:IS THIS SINGLE-LINE LINK?
	SIS	R1,1
	JNFS	LNCH22			:MULTIPLE LINES, LINK NOT GOING OUT,YET
	STH	R1,KFROZN,KD		:LINK IS GOING OUT...NO LONGER FROZEN
	IF	NGRDTM-1
	LB	R8,LTYP,LN,LN		:NON-4SEC REPORT, ZERO THE COUNT
	JEFS	LNCH31			:SPECIFIC LINE ONLY		###AL
	STB	R1,LCRPCT,LN,
LNCH31	EI	:NGRDTM-1
LNCH22	SBT	LN,LINDET		:DETACH THIS LINE

	IF	TSTSZE
	LHL	R8,NDID,KD
	CLH	R8,TSLINK		:IS THIS LINK OF INTEREST?
	JN	LNCHTX			:NO - NO TRACING
	SLLS	LN,1			:YES - SET UP LINE NUMBER*2 FOR
	JAL	R8,TSBMRK		:	CONSISTENCY AND MAKE NEW ENTRY
	SRLS	LN,1
	STB	R0,TSBTBL+4,R7		:STORE DETACH REASON
	LHL	R8,LRT,KD
	STH	R8,TSBTBL+2,R7		:STORE 'LAST RECORD TORN'
	LHI	R8,TS.DET
	STB	R8,TSBTBL,R7		:STORE ENTRY TYPE
	LIS	R8,0
	STH	R8,TSLINK		:INHIBIT FURTHER TRACING OF THIS LINK
	AIS	R7,TSESZE
	NHI	R7,TSTSZE-1		:ADVANCE INDEX TO NEXT ENTRY AND
	ST	R8,TSBTBL,R7		:	CLEAR FOR EASE IN FINDING
	ST	R8,TSBTBL+4,R7		:	END OF TRACE
	JAL	R8,TSNSPK		:SAVE MOST RECENT PACKETS IN AND OUT
LNCHTX	EI	:TSTSZE
	LCS	R0,1			:PUT LINE IN LIMBO FIRST
	SLLS	LN,1
	ST	R0,KDLN,LN,LN
	SRLS	LN,1

:	IDLE THE LINE
	LHI	R0,SIOIDL-SEG1
	STH	R0,SIOTST,LN,LN		:INITIALIZE OUTPUT STATE

	LHI	R0,SYLMRK-SEG1		:SO SYLVER DOESN'T GET CONFUSED
	STH	R0,QSYLVR,LN,LN
	LHI	R0,1F-PLINKR		:SCHEDULE LINKER
	SBT	R0,TLINKR
LNCH2	LHI	R0,LNCKTM	:INITIALIZE CONFSG, SO WE CAN DETECT
				:WHEN A LINK GOES LNCKTM TIMES OF
				:4-SECONDS WITH NO RECORDS RECEIVED.	###LH
	STH	R0,CONFSG,LN,LN	
LNCH2B	IF	NGRDTM-1
	LB	R0,LTYP,LN,LN		:NON-4SEC REPORT, ZERO THE COUNT
	JEFS	LNCH2C			: WHENEVER RECVED A GOOD DATA	###AL
	LIS	R0,0
	STB	R0,LCRPCT,LN
LNCH2C	EI	:NGRDTM-1
	LH	R0,KFROZN,KD		:IS LINK CURRENTLY FROZEN?
	JE	LNCH4			:NO
:	GOOD RECORD RECEIVED FOR LINK WHICH HAS BEEN REPORTED FROZEN TO
:	SUPERVISOR. REPORT LINE ATTACH WITH PROPER LINK SPEED.
	JAL	R10,KSPEED		:RE-COMPUTE LINK SPEED
	LB	R4,KSPD,KD
	NHI	R4,1F			:ISOLATE LINK SPEED
	AHI	R4,13C0			:T-II NEIGHBOR, REPORT NEW LINE ATTACH
LNCH34	AR	LN,LN			:SUP13 EXPECTS LN TO BE LINE NUMBER * 2
	JAL	R10,SUP13,,		:SEND NEW LINE/LINK REPORT TO SUP
	GL	SUP13
LNCH35	SRLS	LN,1
	LIS	R0,0
	STH	R0,KFROZN,KD		:THAW LINK
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER FOR NODE REPORT
	LHL	R0,ANCHN,KD
	OHI	R0,8000			:INCLUDE NUMBER OF CIRCUITS SAVED
	STH	R0,SUPMBF+4
	LHI	R0,NR.LTH
	STH	R0,SUPMBF		:INDICATE LINK THAW NODE REPORT
	JAL	R10,SUP12,,		:SEND NODE REPORT
LNCH4
	SIS	LN,1
	JGE	LNCH1
	LIS	R2,0
LNCH42	L	R0,LKGREC,R2		:UPDATE OLD LKGREC
	ST	R0,OLDKGR,R2
	LIS	R0,0
	ST	R0,LKGREC,R2		:CLEAR LKGREC
	AIS	R2,4
	CI	R2,LKSIZE
	JL	LNCH42
	L	R10,LNCHLR		:RESTORE LINK REG AND
	JR	R10			:	RETURN

:	NO RECORDS RECEIVED ON LINE THIS PAST 4-SECOND INTERVAL.
:	INCREMENT NUMBER OF CONSECUTIVE 4-SECOND GAPS, AND TEST FOR
:	DETACH/REPORTING ACTION TO BE TAKEN.
LNCH6	HS	0
	LH	R1,KNNLAT,KN,KN		:IF MULTI-LINE LINK, DECREMENT
	JLFS	LNCH62			:SINGLE-LINE LINK
	SIS	R1,1
	JL	LNCH4		:ALREADY DETACHED MAX NUMBER OF LINES THIS LINK
	J	LNCH3		:GO DETACH THIS LINE
LNCH62
:	REPORT LINK FROZEN TO SUPERVISOR, BUT DO NOT ZAP CIRCUITS OR
:	DETACH LINE.  THIS PREVENTS SUP FROM BUILDING NEW CIRCUITS OVER
:	LINK WHILE WE GIVE IT MORE TIME TO RECOVER.

	IF	NGRDTM-1
	LB	R4,LTYP,LN,LN		:NON-4SEC REPORT, CHECK CT=NGRDTM-1
	JE	LNCH63			:SPECIFIC LINE ONLY		###AL
	LB	R4,LCRPCT,LN
	LHI	R8,NGRDTM
	SIS	R8,1
	CLR	R4,R8
	JN	LNCH70
LNCH63	EI	:NGRDTM-1
	TS	KFROZN,KD	:HAVE WE REPORTED LINK OUT TO SUPERVISOR?
	JL	LNCH70		:YES - LINK FROZEN
	LHI	R4,80		:SET LINK SPEED TO 0 FOR REPORT TO SUPERVISOR
	STB	R4,KSPD,KD	:	(INDICATES FROZEN LINK)
	LHI	R4,13A1		:INDICATE LINE DETACHED DUE TO NO
				:	RECORDS RECEIVED
	AR	LN,LN		:SUP13 EXPECTS LN TO BE LINE NUMBER * 2
	JAL	R10,SUP13,,	:SEND REPORT TO SUP (WITH LINK SPEED = 0)
LNCH64	SRLS	LN,1

:	NOW SEND NODE REPORT INDICATING LINK FROZEN

	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER
	OHI	R0,8000
	STH	R0,SUPMBF+2
	LHI	R0,10+8000
	STH	R0,SUPMBF+4		:NUMBER OF SECONDS BEFORE DETACH
	LHI	R0,NR.LFR
	STH	R0,SUPMBF		:INDICATE LINK FROZEN NODE REPORT
	JAL	R10,SUP12,,		:SHIP NODE REPORT TO SUPER

LNCH70	HS	0
:	4-SECOND INTERVAL WITH NO GOOD RECORDS. SEE IF LNCKTM 
:	CONSECUTIVE OCCURRENCES OF FOUR SECONDS WITH NO RECORDS RECEIVED
:	(4 * LNCKTM SECONDS) 
	LIS	R0,1		:R0 CONTAINS REASON FOR LINE DETACHMENT	###LH
				:REASON 1 ==> NO RECORDS RECEIVED.	###LH
	LCS	R8,1		:					###LH
	AHM	R8,CONFSG,LN,LN :CHECK IF HAS REACHED CONSECUTIVE 	###LH
				:4-SECONDS GAPS LIMIT.			###LH
	JLE	LNCH3		: YES, --- DETACH LINE			###LH
:: The remote station receives the dummy packet every 8 secs to keep the
:: starlink up when no other data rcved. This is done by both hub and remote
:: to reduce the starlink traffic. Only remote's starline may have 4 sec gap
:: count which is not really an error. 12sec with no data rcved will add 3 to
:: FOURSG for remote's starline to elimilate the dummy error report.
:: This also requires that NGRDTM reporting time is set greater then 12sec##AL
	AHM	R0,FOURSG,LN,LN	: NO, KEEP COUNT OF CONSECUTIVE		###LH
LCH70B				: 4-SECONDS GAPS.			###LH
	LHL	R8,NDID,KD		:GET NEIGHBOR NUMBER
	LR	R0,LN			:LINE NUMBER
	EXHR	R0,R0			:	ALIGNED IN UPPER HW
	OR	R0,R8			:*COMBINE W NEIGHBOR NUMBER
	ST	R0,CRYSBF		:*SAVE FOR CRYPTO
	IF	NGRDTM-1		:REPORT THE 4-SEC MSG BY NGRDTM
	LB	R9,LTYP,LN,LN		: FOR SPECIFIC LINE ONLY	###AL
	JE	LCH70C
	LB	R9,LCRPCT,LN		:CHECK COUNT IF MEET NGRDTM
	AIS	R9,1			:INCREASE COUNT BY 1
	STB	R9,LCRPCT,LN
	LHI	R0,NGRDTM		:DISPLAY FORMAT IN BYTE DECIMAL
	CLR	R9,R0
	JN	LCH70D
	SLLS	R0,2			:DISPLAY THE REAL NO. OF SECS
	LIS	R4,0			:ZERO OUT THE COUNT
	STB	R4,LCRPCT,LN
	JAL	R8,CRYPTO	
	HC	CRYE7D
	JFS	LCH70D
LCH70C	EI	:NGRDTM-1
	LIS	R0,0			:*NO DATA
	JAL	R8,CRYPTO	
	HC	CRYE1E
LCH70D
:	IF SIO LINE HAS GONE FOUR SECONDS WITH NO RECORDS RECEIVED,
:	MAYBE IT NEEDS TO BE RE-INITIALIZED...

	IF	SILINS
	LR	R9,LN
	SHI	R9,(NLINES-SILINS)	:COMPUTE RELATIVE SIO LINE NUMBER
	JL	LNCH4			:NOT AN SIO LINE
	SLLS	R9,4			:SIO LINE * 10
	LCS	R0,2
	STH	R0,SIOSTT+8,R9,		:INDICATE INITIALIZATION DUE TO NO RECS
	AR	LN,LN
	JAL	R10,SIOIZ0		:RE-INITIALIZE SIO LINE
	SRLS	LN,1
	EI	:SILINS

	J	LNCH4

	SUBTTL	LINKER (LDRPRT - Diagnostics and reporting)

::*********************************************************************
::
::	TABLE:		LDERTB:
::	FUNCTION:	Line Diagnostic Event/Reporting Table.
::
::*********************************************************************

:	EACH ELEMENT HAS FIVE FIELDS, AS FOLLOWS:
:	EVENT,TOTAL(TRANSMIT OR RECEIVE),MSG TYPE,SHIFT FACTOR,REPORT TIME
:	FOLLOWED BY A JAL TO CRYPTO, A HW OF CRYPTO FLAGS/TYPE, AND A
:	RETURN VIA R11 TO THE CALLER.
::
::	TABLE:		LDTIME:
::	FUNCTION:	USED TO CONTROL THE FREQUENCY OF LINE
::		DIAGNOSTIC REPORTING TO THE SUPERVISOR.  EACH ARRAY LDTIMx
::		RECORDS THE TIME (IN TIK4MN UNITS) THAT THE LAST REPORT WAS
::		MADE.  IF 2 CONSECUTIVE REPORTS ARE MADE, THEN SKIP 3
::		OCCURRENCES OF LDRPRT BEFORE REPORTING AGAIN.  WHEN A EVENT
::		THRESHOLD HAS BEEN EXCEEDED, TEST THE LDTIMx FIELD:
::
::	1. IF TIME OF LAST REPORT = CURRENT TIME MINUS 1, SET LDTIMx TO
::	    CURRENT TIME + 3.
::	2. IF LDTIMx IS LESS THAN CURRENT TIME MINUS 1, SET LDTIMx TO CURRENT
::	    TIME.
::	3. IF LDTIMx IS GREATER THAN OR EQUAL TO CURRENT TIME, MAKE NO REPORT.
::

LDERTB	HS	0
	HC	LINERR,RCRCVD,NR.BRI+06,LDTIM0-LDTIME :BAD BORI
	JAL	R8,CRYPTO
	HC	CRYE41
	JR	R11
LDTESZ	EQ	.-LDERTB		:LDERTB ELEMENT SIZE
	HC	BADACK,RCRCVD,NR.ACK+10,LDTIM1-LDTIME :BAD ACKS
	JAL	R8,CRYPTO
	HC	CRYE42
	JR	R11
	HC	BADRCN,RCRCVD,NR.RCN+10,LDTIM2-LDTIME :BAD RECORD NUMBERS
	JAL	R8,CRYPTO
	HC	CRYE43
	JR	R11
	HC	BADCSM,RCRCVD,NR.CHS+06,LDTIM3-LDTIME :BAD CHECKSUMS
	JAL	R8,CRYPTO		 	: (PACKET W/ GOOD BORI)
	HC	CRYE44
	JR	R11
	HC	RCRXMT,RCRCVD,NR.RTR+03,LDTIM4-LDTIME :RETRANSMISSIONS RECEIVED
	JAL	R8,CRYPTO
	HC	CRYE45
	JR	R11
	HC	TRRXMT,RCTRNS,NR.RTS+03,LDTIM5-LDTIME :RETRANSMISSIONS SENT
	JAL	R8,CRYPTO
	HC	CRYE46
	JR	R11
	HC	FOURSG,RCRCVD,NR.4SG+10,LDTIM6-LDTIME :FOUR SECOND GAP W/ NO RECORDS
	JAL	R8,CRYPTO
	HC	CRYE47
	JR	R11
	HC	LCROSS,RCRCVD,NR.CRS+10,LDTIM7-LDTIME :LINE CROSS-TALK
	JAL	R8,CRYPTO
	HC	CRYE48
	JR	R11
	HC	SPACNG,RCRCVD,NR.SPC+10,LDTIM8-LDTIME :SPACING ON INPUT
	JAL	R8,CRYPTO
	HC	CRYE49
	JR	R11
:LDNEVT	EQ	(.-LDERTB)/LDTESZ 	:NUMBER OF TABLE ELEMENTS
:	number of table entries is now maintained in DATA       	###sdw
	HC	0			:END OF TABLE INDICATION


::*********************************************************************
::
::	SUBROUTINE:	LDRPRT:
::	FUNCTION:	Line diagnostic detection and reporting routine.
::	CALLING SEQ:	JAL	R10,LDRPRT	Called from G01SEC.
::	DESTROYED:	R4, R5, R6, R12, R13, R15
::	CALLS:		JAL	R0,SVCE38	:IF ISIS
::			JAL	R10,SUP12,,
::			JAL	R11,LDERTB+8,R6	:JAL R8,CRYPTO for line/event
::			JAL	R12,SVCE0F	:solo
::			JAL	R10,SIOSUR
::
::*********************************************************************

:	LINE EVENTS ARE COMPARED TO A THRESHOLD BASED ON NUMBER OF PACKETS
:	TRANSMITTED OR RECEIVED, AND REPORTED IF THRESHOLD EXCEEDED.  IN
:	ADDITION, REPORTS ARE THROTTLED FROM EXCESSIVE IDENTICAL
:	CONDITION REPORTING.
:
:	R10 = LINK
:	LN = 2*LINE #
:	R15 = 4-MINUTE TICKER (INCREMENTS EACH TIME THRU)
:	R6 = EVENT INDEX
:	R5 = POINTER TO EVENT ARRAY
:	R4 = POINTER TO TOTAL ARRAY (PACKETS SENT/RECEIVED)
:	R13 = SHIFT FACTOR FOR DETERMINING EVENT THRESHOLD
:	R12 = MSG TYPE FOR REPORT TO SUP
:
:	DIAGNOSTIC REPORTS ARE GENERAL 'REPORT TO LOG' FORMAT, WITH
:	3 HALFWORDS OF INFORMATION, AS FOLLOWS:
:
:	EVENT REPORT:
:	*HW1* TTLL
:	*HW2* NNNN+8000 IF LINE ATTACHED, ELSE NNNN FOR LAST NEIGHBOR ON
:		LINE (0 IF LINE NEVER ATTACHED)
:	*HW3* EEEE
:	WHERE TT IS MESSAGE TYPE, LL IS LINE NUMBER, NNNN IS NEIGHBOR NUMBER,
:		AND EEEE IS NUMBER OF EVENT OCCURRENCES.
:
:	IF AN EVENT REPORT IS MADE, IT IS USEFUL FOR ANALYSIS PURPOSES
:	TO KNOW THE TOTAL NUMBER OF PACKETS SENT/RECEIVED OVER REPORTING
:	PERIOD.  AFTER EVENT REPORTS (IF ANY) HAVE BEEN SENT, TOTAL
:	REPORTS ARE SENT FOR THOSE LINES WHICH REPORTED EVENTS.

:	TOTAL REPORT:
:	*HW1* 80LL
:	*HW2* RRRR
:	*HW3* TTTT
:
:	WHERE 80 IS THE MESSAGE TYPE, LL IS LINE NUMBER, RRRR IS TOTAL
:	NUMBER OF PACKETS RECEIVED OVER REPORTING PERIOD, AND TTTT IS
:	NUMBER OF PACKETS TRANSMITTED.

SVCE38	CRASH.(.SV38C,R5)

LDRPRT	HS	0

	LHI	LN,NLINES-SILINS-1
	ST	R10,LDRGSV		:SAVE LINK REGISTER
	L	R15,TIK4MN
	AIS	R15,1			:INCREMENT TICKER
	ST	R15,TIK4MN

:	LDARLN IS AN ARRAY OF 16-BIT ARRAYS, ONE HW FOR EACH LINE. EVERY 4
:	MINUTES WHEN WE COME HERE WE RESET THE 'NEXT' BIT IN EACH ARRAY. THEN
:	BELOW, IF THERE ARE ANY ERRORS TO REPORT TO THE SUP, THIS BIT GETS SET
:	AGAIN. THUS, FOR EACH LINE THE CORRESPONDING BIT-ARRAY HAS A 1-BIT FOR
:	EACH OF THE PRECEDING 4-MINUTE INTERVALS DURING WHICH ERRORS OCCURED.
:	THIS IS USED IN THE ND DISPLAY TO GIVE A ROUGH SENSE OF ERRORS ON
:	EACH LINE DURING THE PREVIOUS HOUR.
	LHI	R4,(((NLINES+1)/2)*4)-4	:POINT TO THE LAST FW IN LDARLN
					: SO WE CAN FIGURE WHEN WE'RE THRU
LDRP04	L	R6,LDARLN,R4		:GET 2 HW BIT ARRAYS
	SRHLS	R6,1			:RESET OLDEST BIT FOR 1 LINE
	EXHR	R6,R6			:SET UP SECOND LINE
	SRHLS	R6,1			:RESET OLDEST BIT FOR 2ND LINE
	EXHR	R6,R6			:SWITCH THEM BACK
	ST	R6,LDARLN,R4		:STORE THEM AWAY
	SIS	R4,4			:REPEAT TILL DONE
	JGEBS	LDRP04
	LIS	R6,0
LDRP10	LHL	R5,LDERTB,R6		:POINTER TO ERROR COUNT ARRAY
	JE	LDRP50			:END OF TABLE
:	INITIALIZE REGISTERS WITH POINTERS, SHIFT VALUE & MSG TYPE BEFORE
:	ENTERING INNER LOOP
	LHL	R4,LDERTB+2,R6		:# PACKETS TRANSMIT/RECEIVED ARRAY
	LB	R13,LDERTB+5,R6		:SHIFT FACTOR. NOTE THAT A SHIFT
					:FACTOR OF 10 INDICATES THRESHOLD OF 0
	LB	R12,LDERTB+4,R6		:MESSAGE TYPE FOR SUP REPORT
	EXBR	R12,R12			:ALIGN FOR REPORT
	LHI	LN,(NLINES-1)*2		:LINE NUMBER * 2 INDEX
LDRP20	LHL	R0,0,R5,LN		:GET NUMBER OF EVENTS
	LHL	R1,0,R4,LN		:	AND TOTAL NUMBER OF PACKETS
	SRL	R1,0,R13		:COMPUTE REPORTING THRESHOLD
	CR	R0,R1			:# EVENTS > THRESHOLD?
	JLE	LDRP40			:NO
	CLHI	R0,1
	JLE	LDRP40			:DON'T REPORT SINGLE EVENT

	LIS	R3,0			:POINTER TO HO BIT IN LD ARRAY
	SBT	R3,LDARLN,LN		:SET BIT INDICATING LD REPORT WOULD
					: HAVE BEEN SENT TO SUPE
:	SEE IF WE SHOULD THROTTLE REPORTING
	LHL	R11,LDERTB+6,R6 	:get address of LDTIMx
	AI	R11,LDTIME		:make actual address    	###sdw
	AR	LN,LN			:FW INDEX
	L	R3,0,R11,LN		:GET TIME OF LAST REPORT
	SR	R3,R15			:IF TIME OF LAST REPORT .GE. CURRENT
	JGE	LDRP38			: TIME, WE'RE THROTTLED FOR THIS EVENT
					: ON THIS LINE			###wjl
	LR	R10,R15			:R10 IS NEW REPORT TIME
	AIS	R3,1			:TEST FOR CONSECUTIVE REPORTS
	JLFS	LDRP30			:NO
	AIS	R10,3			:THROTTLE REPORTS FOR 3 REPORT PERIODS
LDRP30	ST	R10,0,R11,LN		:SET NEW 'TIME OF LAST REPORT'
	SRLS	LN,1			:RESTORE HW INDEX
	LHL	R7,NGSVLN,LN
LDRP32	STH	R7,SUPMBF+2		:NEIGHBOR NUMBER
	STH	R7,CRYSBF+2		:DITTO FOR CRYPTO BUFFER
	STH	R0,SUPMBF+4		:NUMBER OF EVENTS
	LR	R0,LN
	SRLS	R0,1			:LINE NUMBER
	SBT	R0,LDTARY		:INDICATE REPORT SENT FOR THIS LINE
	STH	R0,CRYSBF		:LINE# FOR CRYPTO
	OR	R0,R12
	STH	R0,SUPMBF		:MSG TYPE, LINE NUMBER
	JAL	R10,SUP12,,		:REPORT LINE DIAGNOSTIC TO SUP
	LHL	R0,0,R5,LN		:NO. EVENTS (AGAIN) FOR CRYPTO
	JAL	R11,LDERTB+8,R6		:JAL R8,CRYPTO FOR THIS LINE AND EVENT
	AR	LN,LN
LDRP38	SRLS	LN,1			:###wjl
LDRP40	CI	R5,TRRXMT		:this one has a history to worry about	
	JN      LDRP41  		:others to be simply cleared
	LHL	R0,TRRXMT,LN		:this value is about to be cleared
	LHL	R1,KL.TRF,LN		:keep same distance between old and new
	SR	R1,R0			:if new=>0 then hist=>hist-new
	STH	R1,KL.TRF,LN		:and done   ###sdw
LDRP41	LIS	R0,0
	STH	R0,0,R5,LN		:CLEAR EVENT COUNTER
	SIS	LN,2
	JGE	LDRP20			:MORE LINES TO CHECK FOR THIS EVENT
	AHI	R6,LDTESZ		:ADVANCE TO NEXT EVENT ARRAY
	J	LDRP10

:	THE FOLLOWING LOGIC QUERIES THE SIO CARD TO SEE IF ANY INTERNAL
:	ERRORS HAVE BEEN DETECTED. WE MUST MAINTAIN COUNTS FROM THE LAST
:	SIO CARD QUERY SINCE MOTHER BOARD'S COUNTS ARE CUMULATIVE.
:	R6 = SIO LINE NUMBER*2
:	R7 = SIOQRY POINTER (ADDRESS TO STORE SIO STATUS IN)

LDRP50	HS	0
	IF	SILINS
	LHI	LN,(NLINES-SILINS)*2	:NODE CODE LINE NUMBER
	LIS	R6,0			:SIO LINE NUMBER
	LA	R7,SIOSTT,,		:POINT TO SIO STATUS BLOCKS	###wjl
	GL	SIOSTT			:			###LSH###wjl
LDRP52	HS	0
	LB	R0,SS.CRC,R7		:GET COUNT OF HDLC CHECKSUM ERRORS#wjl
	LR	R1,R0
	SH	R0,SIOHCK,R6		:GET DIFFERENCE FROM LAST STATUS PERIOD
	NHI	R0,0FF			:only low-order byte is meaningful#wjl
	JE	LDRP54			:NO CHECKSUM ERRORS THIS LINE	###wjl
	STH	R1,SIOHCK,R6		:SAVE NEW COUNT
	lhl	r8,rcrcvd,ln		:see if breaks threshhold
	srls    r8,7			:over 128
	cr	r0,r8			:hdlc cksum error>= packets/128 ?
	jl      ldrp54  		:nope, not bad enough to log
	JAL	R10,SIOSUR		:SET UP NODE REPORT
	JAL	R8,CRYPTO,,		:REPORT TO CRYPTO-COUNT IN R0, LINE,
	HC	CRYE4A			: NEIGHBOR WERE SET UP IN SIOSUR
	LHI	R0,NR.HCK,R1
	STH	R0,SUPMBF		:INDICATE ERROR TYPE, LINE #
	JAL	R10,SUP12,,		:LINE DIAGNOSTIC NODE REPORT TO SUP
LDRP54	LHL	R0,SS.ABR,R7		:only positive values meaningful###wjl
	SRLS	R0,4			:ISOLATE SIO HDLC ABORT COUNTER
	LR	R1,R0
	SH	R0,SIOHAB,R6		:DIFFERENT THAN LAST TIME?
	NHI	R0,0FFF			:only 3 nibbles are meaningful	###wjl
	JE	LDRP58			:NO INCREASE			###wjl
	STH	R1,SIOHAB,R6		:SAVE NEW COUNT
	JAL	R10,SIOSUR		:SET UP NODE REPORT
	JAL	R8,CRYPTO,,		:CRYPTO REPORT-R0 IS COUNT, LINE &
	HC	CRYE4B			: NEIGHBOR WERE SET UP IN SIOSUR
	LHI	R0,NR.HAB,R1
	STH	R0,SUPMBF		:INDICATE ERROR TYPE, LINE #
	JAL	R10,SUP12,,		:SEND NODE REPORT TO SUP
LDRP58	AHI	R7,10
	AIS	R6,2			:BUMP INDEX REGS
	AIS	LN,2
	CLHI	LN,NLINES*2		:DONE ALL SIO LINES?
	JL	LDRP52			:NO - CONTINUE
	J	LDRP60			:YES - REPORT PACKET TOTALS

::*********************************************************************
::
::	SUBROUTINE:	SIOSUR:
::	FUNCTION:	SET UP NODE REPORT FOR SIO LINE ERROR
::	CALLING SEQ:	JAL	R10,SIOSUR
::	DESTROYED:	R1
::
::*********************************************************************

SIOSUR	HS	0
	OHI	R0,8000			:###wjl
	STH	R0,SUPMBF+4		:SAVE COUNT 
	LHL	R1,NGSVLN,LN
	STH	R1,SUPMBF+2		:REPORT NEIGHBOR ON LINE
	STH	R1,CRYSBF+2		: AND SAVE FOR CRYPTO
	LR	R1,LN
	SRLS	R1,1			:LINE NUMBER
	SBT	R1,LDTARY		:REPORT PACKET TOTALS FOR THIS LINE
	STH	R1,CRYSBF		:LINE# FOR CRYPTO
	XI	R0,8000			:COUNT FOR CRYPTO, NO HOB	###wjl
	JR	R10			:RETURN
	EI	:SILINS

:	Clear PACKET TOTAL FIELDS AND REPORT TOTALS FOR LINES WHICH
:	REPORTED EVENTS.
LDRP60	LHI	R4,NLINES-1
	LHI	LN,(NLINES-1)*2
LDRP62	RBT	R4,LDTARY		:CLEAR AND TEST BIT...
	JE	LDRP70			:...NO REPORTS MADE FOR THIS LINE

:	REPORT PACKET TOTALS FOR INTERESTED OBSERVER
	STH	R4,CRYSBF		:LINE# FOR CRYPTO
	LHL	R0,NGSVLN,LN		:NEIG# FOR CRYPTO
	STH	R0,CRYSBF+2
	LHI	R0,NR.SRT		:MSG TYPE FOR REPORTING TOTAL SENT&RCVD
	OR	R0,R4			:COMBINE LINE NUMBER WITH MESSAGE TYPE
	STH	R0,SUPMBF
	LH	R0,RCRCVD,LN		:TOT # PACKETS RECEIVED
	STH	R0,SUPMBF+2
	STH	R0,CRYSBF+4		:FOR CRYPTO
	LR	R10,R0			:(SAVE NUMBER OF PACKETS RECEIVED)
	LH	R0,RCTRNS,LN		:TOT # PACKETS TRANSMITTED
	STH	R0,SUPMBF+4
	STH	R0,CRYSBF+6		:FOR CRYPTO
	AR	R10,R0			:IF TOTAL PACKETS RECEIVED AND SENT
	JEFS	LDRP70			: =0, DO NOT MAKE TRIVIAL NODE REPORT
	JAL	R10,SUP12,,		:REPORT TOTALS TO SUP
	JAL	R8,CRYPT0,,
	HC	CRYE40
LDRP70	STH	R5,RCRCVD,LN		:CLEAR # PACKETS RECEIVED
	STH	R5,RCTRNS,LN		: AND NUMBER PACKETS TRANSMITTED
	STH	R5,KL.RRF,LN		: AND REF CNTR FOR MTRFIC STATS	###JHL
	SIS	R4,1
	SIS	LN,2
	JGE	LDRP62			:CONTINUE
	L	R10,LDRGSV		:RESTORE LINK REG
	JR	R10			:RETURN

	SUBTTL	LINKER (LNXDUM - Transmit dummy record)

::*********************************************************************
::
::	SUBROUTINE:	LNXDUM:
::	FUNCTION:	Forces transmission of dummy records
::	CALLING SEQ:	JAL	R10,LNXDUM	Called from G500MS.
::
::*********************************************************************

:	RUNS EVERY SEC, FORCES TRANSMISSIONS OF DUMMY RECORDS
:	ON LINES WHICH HAVE SEEN NO ACTIVITY SINCE LAST SEC.

LNXDUM	L	R0,SSENT		:if they didn't send a packet
	ST	R0,SDUMM		:then time to send a dummy
	L	R0,SSENT+4		:
	ST	R0,SDUMM+4
	LCS	R0,1			:AND RESET THE SSENT ARRAY
	ST	R0,SSENT		:clear packet sent field
	ST	R0,SSENT+4


	JR	R10

	SUBTTL	LINKER (ATTLIN - Line attach logic)

::*********************************************************************
::
::	SUB-PROCESS:	ATTLIN:
::	FUNCTION:	Identifies and Attaches Lines.  Scheduled by LINKER
::	CALLING SEQ:	LA	R3,LINKAS
::			JAL	R9,BIDDY
::			J	ATTLIN
::	CALLS:		JAL	R9,FNDLNK
::			JAL	R8,WCI
::			JAL	R9,RSTSTR
::			JAL	R8,ATTMCL
::			JAL	R10,SUP12
::			JAL	R8,CRYPTO
::			JAL	R8,GMTLIN
::			JAL	R10,KSPEED
::			JAL	R10,SUP13
::			JAL	R8,TSBMRK
::			JAL	R11,LNKCON
::			JAL	R9,CLRCHN
::	RETURNS:	J	BIDDRT
::
::*********************************************************************

ATTLIN	HS	0
	LR	LN,2			:COMPUTE LINE NUMBER
	AR	LN,LN
	L	SD,SDLN,LN,LN		:RESET BUFF PTR
:	Problem of putting wrong reset in front of a reset packet.  Problem
:	is that logic assumes that any subsequent resets are of same type as
:	original reset.  Solution is to consider different type of reset an
:	error and go back to sending sending initial resets of same type
:	we just received.

	LH	R4,VRSTP,SD
	NHI	R4,0FFE0		:reset type (expanded or old is left)
	LH	R3,XRSTP,SD		:make sure sending same type that
	NHI	R3,0FFE0		: is being received
	CR	R3,R4			:same type
	JN	ATTLD4			:no, start over
	CLHI	R4,TXRSHD		:new reset?
	JNFS    ATT100
	SBT     LN,XRSTBT		:indicate new reset received
	JE      ATTLD4  		:***previous wasn't
	JFS     ATT101  		:check timout
ATT100  RBT     LN,XRSTBT		:got an old reset
	JN      ATTLD4  		:
ATT101	LHL	R3,RSTIM,SD		:IF FIRST TIME, SET TIMEOUT
	JN	ATTLI1			:NOT FIRST TIME
	LH	R4,VRSTP,SD		:get Received Reset Header 
	NHI	R4,0FFE0		:mask off 'subsequent & count' bits
	CLHI	R4,TXRSHD		:compare with Expanded Reset Header
	JNFS	ATT001			:no, must be old version
	SBT	LN,XRSTBT		:yes, set bit indexed by LN*2
	L	R1,VNDID,SD		:get FW Machine Number from Reset
	JFS	ATT002
ATT001	RBT	LN,XRSTBT		:reset bit for old version
	LR	R1,LN
	AIS	R1,1			:bit indexed by (LN*2)+1
	RBT	R1,XRSTBT		:reset bit for first time 
	LH	R1,VRSTP+2,SD		:1st RESET, GET MACHINE # FROM RESET
ATT002	JLE	ATTLD4			:NOT A VALID NODE NUMBER
	CLHI	R1,MACHNM		:ARE WE TALKING TO OURSELVES?
	JN	ATPT00			:no				###wjl

:	CROSS-TALK ERROR - CARELESS CONFIGURATION OR HARDWARE PROBLEM
:	INCREMENT COUNTER AND TIME-OUT LINE

	LIS	R0,1
	AHM	R0,LCROSS,LN		:NOTE CROSS-TALK ON THIS LINE
	J	ATTLD4

:	VERIFY THAT LINK PERMUTER TABLE SPACE IS AVAILABLE BEFORE
:	ENTERING ATTACH PROCESS.  NOTE THAT ADDITIONAL P.T.  SPACE IS
:	NOT REQUIRED FOR MULTI-LINE ATTACH.
ATPT00	LHI	R8,(NLINES-1)*2
ATPT10	LH	R0,NGSVLN,R8	:SEE IF NEIGHBOR NUMBER IN RESET MATCHES
				:	ONE THAT IS ALREADY ATTACHED
	JLFS	ATPT30		:NEGATIVE IF LINE ATTACHED TO SOME LINK
ATPT20	SIS	R8,2
	JGEBS	ATPT10		:SCAN ALL LINES
:	RESET IS FOR NEW LINK - SEE IF AT LEAST 2 PAGES OF PERMUTER TABLES
:	ARE AVAILABLE FOR LINK INITIALIZATION
	LH	R0,NUMPAG,,	:NUMBER OF AVAILABLE PAGES
	SIS	R0,2
	JGEFS	ATPTND		:ENOUGH TO COMPLETE INITIALIZATION
	LIS	R0,NR.NPT	:indicate not enough permuter table space##wjl
	JAL	R7,ATTNR	:report to sup log			###wjl
	J	ATTDIE		:SUSPEND LINE				###wjl
ATPT30	NHI	R0,7FFF		:FOUND ATTACHED LINE. SEE IF RESET'S NEIGHBOR
	CR	R0,R1		:	MATCHES FOR POTENTIAL MULTI-LINE LINK
	JNBS	ATPT20		:NO

ATPTND	STH	R1,NGSVLN,LN	:SAVE MACHINE NUMBER FROM RESET
	LH	R4,VRSTP,SD	:RESET HEADER
	CLHI	R4,TTRSHD		:Original T-II Reset Header?
	JN	ATTL00			:jump if Expanded Header received
	L	R0,TTRSET+4
	ST	R0,XRSTP+4,SD		:store CKSUM
	LI	R0,VERCOM		:VERSION and Complement
	ST	R0,XRSTP+8,SD		:for backwards compatability!
	LCS	R2,1			:store FFFFs over remainder...	###wjl
	LHI	R3,XSDSZ-10		:byte count-4			###wjl
ATTLI3	ST	R2,XRSTP+0C,SD,R3	:store one word at a time	###wjl
	SIS	R3,4			:back up a FW at a time		###wjl
	JGEBS	ATTLI3			:loop till done			###wjl

	IF	SILINS
	CLHI	LN,(NLINES-SILINS-1)*2
	JLEFS	ATTL00			:skip if not SIO line
	L	R2,SIORSP,LN,LN		:get SIO Reset Buffer Pointer
	ST	R0,6,R2			:store VERSION and Complement
	EI	:SILINS			:for backwards compatibility!

ATTL00	HS	0
	CLHI	R1,MACHNM	:TEST FOR NEIGHBOR WITH HIGHER MACHINE NUMBER
	JG	ATTA4		:YES - THAT MAKES US THE SLAVE FOR THIS LINK

	JAL	R8,ATTADD	:NO - WE'RE MASTER, add neighbor to MRESET##wjl

:	TEST FOR SUBSEQUENT LINE ON EXISTING LINK.  IF LINK UNDEFINED OR
:	IF NUMBER OF LINES ON LINK=0, THEN THIS IS THE FIRST LINE ON
:	THAT LINK.
:					First Line	Subsequent Line
:	Original T-II Reset Header	30A0 (TTRSHD)	30B0 (TSRSHD)
:	Expanded Reset Header		33A0 (TXRSHD)	33B0 (TYRSHD)

	CLHI	R4,TTRSHD		:Original T-II Reset Header?
	JEFS	ATTA4			:yes
	LHI	R4,TXRSHD		:No, assume Expanded Reset for New Link

ATTA4	JAL	R9,FNDLNK,,		:SEE IF LINK EXISTS
	GL	FNDLNK
	SKIPAD(ATTA5)			:immediate return, LINK UNDEFINED###wjl
	CLHI	R4,TTRSHD		:+4 return, Original T-II Reset Header?
	JE	ATTL01			:yes, skip WSIZ and KSPD
	LB	R7,WSIZ,KD		:get Window Size
	STB	R7,XWSIZ,SD		:store it in xmit reset pattern
	LB	R9,KSPD,KD		:get Link Speed for Sat Bit
	STB	R9,XKSPD,SD		:store Link Capability for xmit

	IF	SILINS
	CLHI	LN,(NLINES-SILINS-1)*2
	JLE	ATTL01			:skip if not SIO line
	L	R1,SIORSP,LN,LN		:get SIO Reset buffer Pointer
	STB	R7,(XWSIZ-VSDSZ)+2,R1	:-offset for Received Pattern Size,
	STB	R9,(XKSPD-VSDSZ)+2,R1	:+HW storage for SIO Reset Buffer Size
	EI	:SILINS

ATTL01	LB	R7,NLAT,KD		:GET NUMBER OF LINES ATTACHED TO LINK
	JE	ATTA5			:ZERO - NEW LINK
	LHL	R2,TBDPKN,KN,KN		:GET CHANNEL ZERO
	LHL	R2,NIOTAB,R2,		:	BUFFER NUMBER AND
	NHI	R2,-4			:	MASK OFF SPEED BITS
	XHI	R2,4			:SET UP OUTBOUND BUFFER INDEX
:	LINK'S CHANNEL ZERO EXISTS FOR INTER-LINK CONTROL. SEND NEIGHBOR
:	'FASTC' AS SECURITY KEY FOR BRINGING UP SUBSEQUENT LINE ON LINK.
	LIS	R1,6			:CHARACTER COUNT
	JAL	R8,WCI,,
	GL	WCI
	LIS	R1,1			:MESSAGE TYPE FOR SENDING KEY
	JAL	R8,WCI,,
	LH	R1,FASTC,,		:FIRST 2 BYTES OF KEY
	STH	R1,RESETE,LN		:SAVE HERE FOR STEP 'E'
	EXBR	R1,R1
	JAL	R8,WCI,,		:DEPOSIT KEY 1 BYTE AT A TIME
	EXBR	R1,R1
	JAL	R8,WCI,,
	LH	R1,FASTC+2,,		:NEXT 2 BYTES OF KEY
	STH	R1,RESETF,LN		:SAVE HERE FOR STEP 'F'
	EXBR	R1,R1
	JAL	R8,WCI,,
	EXBR	R1,R1
	JAL	R8,WCI,,
	LR	R2,LN			:RESTORE R2 TO ACTUAL LINE NUMBER
	SRLS	R2,1

	CLHI	R4,TTRSHD		:check for original T-II Reset Header
	JNFS	ATTL02			:no, must be Expanded Reset header

	LHI	R4,TSRSHD		:RESET HEADER FOR SUBSEQUENT LINE
	JFS	ATTA5
ATTL02	LHI	R4,TYRSHD		:Expanded Reset Header for Subseq Line

ATTA5	TBT	LN,XRSTBT		:Expanded Reset received?
	JEFS	ATT004			:no
	STH	R4,XRSTP,SD		:yes, store header only
	JFS	ATTA6
ATT004	HS	0
	EXHR	R4,R4
	OHI	R4,MACHNM		:INCLUDE MACHINE NUMBER
	ST	R4,XRSTP,SD		:FIRST 32 BITS OF RESET

ATTA6	LH	R3,SLOWC+2,,		:START TIMER FOR RESET SEQUENCE
	AHI	R3,$A40			:must complete within 40 seconds
:	(INCREASED FROM 20 SECONDS TO ALLOW 2.4 LINES TO ATTACH)
	JNFS	ATTA7
	AIS	R3,1			:FORCE NON-ZERO SO WON'T BE INTERPRETED
					: AS FIRST RESET
ATTA7	STH	R3,RSTIM,SD

:	HERE IF NOT FIRST TIME - CHECK TIMEOUT 
ATTLI1	LH	R1,SLOWC+2,,		:CHECK TIMEOUT
	SR	R1,R3
	LHR	R1,R1
	JL	ATTLI4

ATTLD4	JAL	R9,RSTSTR		:TIMEOUT OR OTHER ERROR, ABORT
:	Nodes with 'old' reset code may 'suspend' line during multi-line###wjl
:	reset or if out of link descriptors.  After suspension they will###wjl
:	remain in 'single-reset' state.  As they will not recognize 33A0###wjl
:	as a reset they will never send another reset!!  To avoid this,	###wjl
:	store a 30A0.  It is not necessary to store the entire pattern	###wjl
:	as even an abort will cause the node to begin 'streaming' resets,##wjl
:	which will allow recovery. Note that R6 is required and is set up##wjl
:	in RSTORE (called by RSTSTR).					###wjl
	LH	R4,VRSTP,SD		:test for old type reset received##wjl
	NHI	R4,0FFE0		:mask off 'subsequent'&count bits##wjl
	CLHI	R4,TXRSHD		:compare with 'expanded' reset	###wjl
	JE	ATTL05			:new version reset...		###wjl

:	Make data in reset packet always match the reset header.	###sdw
:	Before if an error was found then the old style reset header would
:	be put in front of a new style reset packet.  Possible for both nodes
:	to be in this error condition and never exit since neighbor is sending
:	bad packet, which is error so send bad packet, and get it back and so
:	on.
:	Previous patch used R6 instead of SD to change it in SIO buffer if
:	SIO port, but both reset buffers should match.
:	For SIO buffer the remaining is not set to FFFF since only used for
:	sync to prevent false indication of new data.
	LHI	R4,TTRSHD		:existing instructions
	STH	R4,XRSTP,SD		:old reset header stored
	LHI	R0,MACHNM		:new logic: construct old reset packet
	STH	R0,XRSTP+2,SD
	L	R0,TTRSET+4,,		:write old reset packet data
	ST	R0,XRSTP+4,SD
	LI	R0,VERCOM
	ST	R0,XRSTP+8,SD
	LHI	R3,XSDSZ-10
	LCS	R2,1			:overwrite old data
ATT090  ST	R2,XRSTP+0C,SD,R3
	SIS	R3,4
	JGEBS   ATT090
       IF	 SILINS
	CLHI    LN,(NLINES-SILINS-1)*2  :sio lines have another reset xmit buf
	JLE     ATTL05,,
	L	R6,SIORSP,LN,LN
	L	R0,XRSTP,SD		:copy reset packet
	ST	R0,2,R6 		:first HW is count for SIO packet
	LI	R0,VERCOM
	ST	R0,6,R6
       EI 	:SILINS
ATTL05	LHL	R1,NGSVLN,LN		:REMOVE NEIGHBOR NUMBER FROM MRESET
	NHI	R1,7FFF
	JAL	R8,ATTMCL
	J	BIDDRT

::	Here, if reset is not timed out
ATTLI4	LHL	R0,RSCNT,SD		:NEEDED BELOW
	LHL	R1,VRSTP,SD		:NEEDED BELOW
	LR	R2,LN			:get line #
	SRLS	R2,1			:line number * 1		###sdw
	RBT	R2,VRSTDL		:TYMNET-II - DID WE GET A RESET?
	JE	ATTLD6			:WE DONT HAVE A RESET

	TBT	LN,XRSTBT		:Expanded Reset Header?
	JEFS	ATTL03			:no
	CLHI	R1,TYRSHD+0E		:Expanded Reset for Subseq Line +0E?
	JL	ATTLW2			:still working or not Subsequent Line
	JE	ATTLW1			:Subsequent Line - Step 0E
	JFS	ATTL04			:Subsequent Line - Step 0F
ATTL03	HS	0
	CLHI	R1,TSRSHD+0E	:HAS PING-PONG COUNT FOR SUBSEQUENT LINE
				:	ADVANCED TO STEP 'E'?
	JL	ATTLW2		:STILL WORKING OR NOT SUBSEQUENT LINE...
	JE	ATTLW1		:YES - RESET STEP 'E'
ATTL04	HS	0		:SUBSEQUENT LINE, RESET STEP 'F'
	LH	R1,VRSTP+2,SD	:GET 2ND 2 BYTES OF KEY RECEIVED OVER NEW LINE
	CLH	R1,RESETF,LN	:AND COMPARE TO KEY WE SENT OVER EXISTING LINK
	JN	ATTDIE		:MISMATCH - SECURITY VIOLATION OR DUMB NEIGHBOR
	LIS	R1,0F		:SET UP FOR PING-PONG COUNT OF 0F
	J	ATTLW3
ATTLW1	HS	0		:STEP 'E' - RESET SHOULD CONTAIN FIRST 2 BYTES
				:OF KEY SENT OVER LINK--SAVED IN RESETE
	LH	R1,VRSTP+2,SD	:GET FIRST 2 BYTES OF KEY RCV'D OVER LINE AND
	CLH	R1,RESETE,LN	:COMPARE TO KEY WE SENT OVER EXISTING LINK
	JN	ATTDIE		:MISMATCH - MAYBE SLOW LINK RESPONSE OR 
				:	SECURITY VIOLATION
	LIS	R1,0E		:SET UP FOR PING-PONG COUNT OF 0E
	J	ATTLW3
ATTLW2	LHL	R2,NGSVLN,LN	:GET NEIGHBOR NUMBER			###cwc

	TBT	LN,XRSTBT		:Expanded Reset received?
	JEFS	ATT006			:no
	CL	R2,VNDID,SD		:yes, compare to FW from reset
	JFS	ATT008
ATT006	CLHI	R0,1			:expecting first reset?
	JLEFS	ATT010			:yes
	LCS	R3,1			:no
	ST	R3,XRSTP+4,SD		:store marks over checksum
ATT010	HS	0
	CLH	R2,VRSTP+2,SD		:COMPARE TO WHAT WE GOT FROM RESET
ATT008	JN	ATTLD4			:INCONSISTENT - MAYBE LINE NOISE
	NHI	R1,0F			:MASK OUT PING-PONG COUNT
ATTLW3	LHL	R2,NGSVLN,LN		:GET NEIGHBOR NUMBER
	CLHI	R2,MACHNM		:DISPATCH ON MASTER/SLAVE
	JL	ATMAST			:WE'RE MASTER
	LR	R0,R0			:SLAVE, IF IN STATE 0...
	JNFS	ATNEXT
	LR	R1,R1			:ACCEPT A 0 OR A 1
	JE	ATTLD3			:Check number of initial resets
	LIS	R0,1			:TRY FOR A 1
ATNEXT	CR	R0,R1			:DID WE GET WHAT WE EXPECTED
	JN	ATTLD4			:NO, RESTART
	AIS	R0,1			:INCREMENT EXPECTED RESPONSE
	STH	R0,RSCNT,SD
	CLHI	R0,3			:TIME TO REQUEST SPEED CALCULATION?
	JNFS	ATNX01
	LR	R1,LN
	SRLS	R1,1			:GET LINE NO.
	SBT	R1,LINSPT		:REQUEST LINE SPEED CALC (SEE G01SEC)
ATNX01	LHL	R0,XRSTP,SD		:				###cwc
	AIS	R0,1			:INCREMENT PING-PONG COUNT
	STH	R0,XRSTP,SD
	CLHI	R0,TSRSHD+0E	:HAVE WE ADVANCED TO STEP 'E' OF RESET SEQUENCE
				: FOR SUBSEQUENT LINE ON LINK?
	JL	ATTLD3		:NO - NEW LINK OR STILL INCREMENTING PING-PONG

	NHI	R0,0F0FF		:mask out expanded vs. t-ii bits
	CLHI	R0,TSRSHD+0E		:Step 0E, Subsequent Line?
	JL	ATTLD3			:no, Expanded new Link or incrementing

	LHL	R1,NGSVLN,LN		:GET NEIGHBOR NUMBER AND	###cwc
	JAL	R9,FNDLNK,,		:	SET UP LINK DESCRIPTOR
	SKIPAD(ATTLD4)			:NOT FOUND - LINK WENT DOWN OR...?##wjl
	LH	R2,RKEY,KD		:+4 return, ASSUME STEP 'E'

	CLHI	R0,TSRSHD+0E		:step 0E?

	JEFS	ATNX02			:YES - STEP 'E'
	LH	R2,RKEY+2,KD		:NO - STEP 'F'
ATNX02	STH	R2,XRSTP+2,SD		:STORE 2 BYTES OF KEY IN RESET XMIT BUF
	J	ATTLD3			:GO TRANSMIT RESET

ATMAST	LR	R0,R0			:MASTER, IF IN STATE 0...
	JE	ATTNXT			:RETURN A 0
	CLHI	R0,2			:IF IN STATE 2, IGNORE 0'S
	JNFS	ATMAS1
	LR	R1,R1
	JE	BIDDRT
ATMAS1	AIS	R1,1			:ELSE EXPECT WHAT WE SENT LAST
					:REDUCE PING-PONG COUNT TO 4

	CLHI	R1,10			:IF WE GOT FINAL COUNT...
	JE	ATTLN8			:ATTACH
	J	ATNEXT

ATTNXT	HS	0
	TBT	LN,XRSTBT		:Expanded Reset received?
	JNFS	ATT012			:Yes
	LR	R0,LN			:No, we want to send two 30A0's.
	AIS	R0,1			:(LN*2)+1
	TBT	R0,XRSTBT		:Have we already sent a 30A0?
	JEFS	ATT014			:No, don't bump count yet.
ATT012	HS	0
	LIS	R0,1
	STH	R0,RSCNT,SD		:SET RESET COUNT TO 1
	JFS	ATTLD3			:				###wjl

ATT014	SBT	R0,XRSTBT		:Remember to bump count next time

::
:	PREPARE RESET FOR TRANSMISSION
ATTLD3	HS	0			:PREPARE RESET FOR XMIT
	LHI	R0,SIORS-SEG1		:SET SINGLE RESET STATE
      IF	SILINS
	LHL	R6,SIOTST,LN		:get current state
	CLHI	R6,SIORWT-SEG1  	:is still initing?
	JNFS    ATT016  		:no
	STH	R0,SIOTSV,LN		:after init go to single reset
	JFS     ATT017
      EI	:SILINS
ATT016	STH	R0,SIOTST,LN
ATT017					:don't overwrite wait state

	IF	SILINS			:SIO LINE ??
	CLHI	LN,(NLINES-SILINS-1)*2
	JLE	ATTL3A			:SKIP IF NOT SIO LINE
	L	R0,XRSTP,SD		:MOVE RESET PATTERN to SIO Reset Buffer
	L	R6,SIORSP,LN,LN		:get SIO Reset Buffer Pointer

	SHI	R6,VSDSZ-2		:-offset for Received Pattern Size
	ST	R0,XRSTP,R6		:+HW storage for SIO Reset Buffer Size
	JAL	R5,CCKSUM		:calculate and store checksum for xmit
	J	BIDDRT
	EI	:SILINS

:	SEND SYNC LINE RESET
ATTL3A	TBT	LN,XRSTBT		:expanded reset?		###wjl
	JEFS	ATT005			:no				###wjl
	LR	R6,SD			:CCKSUM needs Reset Buffer Ptr in R6
	JAL	R5,CCKSUM		:calculate and store checksum for xmit
ATT005
	J	BIDDRT

:	HERE TO SUSPEND LINE AND IGNORE FOR 'KDIGTM' SECONDS
ATTDIE	HS	0
	LHL	R2,NGSVLN,LN		:get neighbor number		###wjl
	CLHI	R2,MACHNM		:dispatch on master/slave	###wjl
	JLFS	ATTD00			:we're master			###wjl
	LIS	R1,0			:slave should clear		###wjl
	STH	R1,RSTIM,SD		: reset timeout			###wjl
	JFS	ATTDIT			:				###wjl
ATTD00	LHI	R1,KDIGTM
	AHM	R1,RSTIM,SD
ATTDIT	LIS	R1,0
	STH	R1,RSCNT,SD		:CLEAR RESET COUNT
	LHL	R1,XRSTP,SD		:clear count from reset pattern	###wjl
	NHI	R1,3FB0			:so we start from zero		###wjl
	STH	R1,XRSTP,SD		:				###wjl
	LCS	R1,1			:CAUSE 'SYLUAL'
	ST	R1,KDLN,LN,LN		: TO IGNORE ANY RECEIVE DATA
	LR	R0,LN
	SLLS	R0,0F			:GET LINE NUMBER IN UPPER HALFWORD AND
	LHL	R8,NGSVLN,LN		: GET NEIGHBOR NUMBER
	OR	R0,R8			: COMBINE AND
	ST	R0,CRYSBF		: SAVE FOR CRYPTO
	LHI	R0,KDIGTM		:NO. SEC'S SUSPENDED
	JAL	R8,CRYPTO		:REPORT TO XRAY
	HC	CRYE20			:	(LINE SUSPENDED)
	LR	R0,LN
	SRLS	R0,1			:LINE NUMBER
	SBT	R0,LNSUSC		:INDICATE LINE SUSPENDED AND
	RBT	R0,LINATT		:	END LINE ATTACH PROCESS...
	JAL	R8,GMTLIN		:SET TIME
	J	BIDDRT

:	HERE IF WE DID'T GET A RESET
ATTLD6	LHL	R2,NGSVLN,LN		:IF WE'RE SLAVE AND HAVE SENT
	CLHI	R2,MACHNM		:...FINAL RESET, ATTACH
	JL	BIDDRT

	CLHI	R0,10
	JN	BIDDRT

	LHL	R0,SIOTST,LN		:GET CURRENT STATE	###cwc
	CLHI	R0,SIOIDL-SEG1		:IDLING?
	JN	BIDDRT			:NO, DONE

:	LINE HAS GONE THRU RESET PROCEDURE, NOW LOCATE CORRESPONDING
:	LINK AND COMPLETE ATTACHMENT.
ATTLN8	LHI	R5,(BGLSIZ-1)*2
	LHL	R1,NGSVLN,LN		:GET NEIGHBOR NUMBER
ATTL06	CLH	R1,BGLIST,R5		:check bad guy list 
	JE	ATTLD4
	SIS	R5,2
	JGEBS	ATTL06

	TBT	LN,XRSTBT		:Expanded Reset Header?
	JEFS	ATTL17			:no
	LHL	R0,VNETID,SD		:get received NETID
	CLH	R0,XNETID,SD		:compare with xmitted NETID
	JE	ATTL07	
	JAL	R10,ATTNID		:not equal!			###AL
	J	ATTLD4

attl17  lh	r0,vrstp+4,sd		:any version present?
	je      attl07  		:nope, something old
	lh	r9,vrstp+6,sd		:get 1s complement
	xr	r9,r0			:verify version
	ais	r9,1
	jn      attl07  		:some garbage, not a version
	clhi    r0,$8 520		:this neighbor 5.20 or later?
:	the link is suspendetoforce it out of old style resets.
	jl      attl07  		:neighbor only knows old style
        lhi     r0,txrshd
        sth     r0,vrstp,sd             :make sure send out expanded
	jal	r9,rststr
        lh      r1,ngsvln,ln
        nhi     r1,7fff
        jal     r8,attmcl
	j       attdie  		:next time on expanded resets

ATTL07	HS	0
	JAL	R9,FNDLNK,,		:neighbor number (preserved) in R1
	SKIPAD(ATLN8A)			:immed return, nonexistent link	###wjl
	LB	R7,NLAT,KD		:+4 return, R7 used in ATTCLR	###wjl
	JE	ATLN8D			:SKIP IF NEW LINK COMING UP

:	SUBSEQUENT LINE ON LINK...CHECK IT OUT
	LH	R0,VRSTP,SD		:GET RESET HEADER BACK
	CLHI	R0,TTRSHD+0F		:TYMNET-II HEADER FOR NEW LINK?
	JE	ATTLD4		:YES, MUST USE TSRSHD HEADER FOR SUBSEQ LINE

	CLHI	R0,TXRSHD+0F	:T-II Expanded Reset Header for new link?
	JE	ATTLD4		:yes, must use TYRSHD for subsequent line
	J	ATTL08		:no KD update or WSIZ match down needed

:	FIND AN AVAILABLE LINK DESCRIPTOR
ATLN8A	LR	R0,R1			:save neighbor number		###wjl
	JAL	R9,FNDLNZ,,		:find free link descriptor	###wjl
	GL	FNDLNZ			:				###wjl
	SKIPAD(ATLN8B)			:immed return, no link descriptor##wjl
	LR	R1,R0			:+4 return, restore neighbor #	###wjl
	STH	R1,NDID,KD		:found a link descriptor 
	LIS	R7,0			:R7 used below for call to ATTCLR##wjl
	JFS	ATLN8D

:	NO LINK DESCRIPTOR AVAILABLE - MAKE NODE REPORT TO SUP AND SUSPEND
ATLN8B	LR	R1,R0			:restore neighbor number	###wjl
	LIS	R0,NR.NKD		:indicate no link descriptor	###wjl
	JAL	R7,ATTNR		:report to sup log		###wjl
	J	ATTDIE			:SUSPEND LINE

:	WE HAVE THE LINK DESCRIPTOR
ATLN8D	HS	0
	TBT	LN,XRSTBT		:check for Expanded Reset Header
	JE	ATTL08			:no KD update or WSIZ matchdown
	L	R0,VVERNO,SD
	ST	R0,KVERNO,KD		:store VERNO and NETID
	L	R0,VHOST0,SD
	ST	R0,KHOST0,KD		:store neighbor's HOST0
	LB	R0,VLINE,SD
	STB	R0,KLINE,KD		:store neighbor's LINE
	JAL	R8,ATTWSZ		:check for WSIZ matchdown	###wjl
ATTL08	HS	0

:	CLEAR LINE STATISTICS - R7 REQUIRED FOR SETUP
	JAL	R8,ATTCLR		:R7 required for setup		###wjl

	TBT	LN,XRSTBT		:Expanded reset Header?	
	JNFS	ATTL09			:neighbor version entered above
	TS	KVERNO,KD	:ASSUME NEIGHBOR VERSION NUMBER NOT KNOWN
ATTL09	HS	0
	ST	KD,KDLN,LN,LN		:SET LINK PTR FOR LINE
	ST	KD,KDSVLN,LN,LN		:SAVE IT IN CASE IT RESETS
	LHL	R1,NGSVLN,LN		:get neighbor number
	JAL	R8,ATTMCL		:REMOVE NEIGHBOR NUMBER FROM MRESET
	LHI	R1,8000,R1		:SAVE THE CURRENT NEIGHBOR NUMBER
	STH	R1,NGSVLN,LN

	STM	R0,SIOREG		:save registers 		###sdw
	JAL	R7,BSIOST		:setup line rotation for each line##sdw
	LM	R0,SIOREG		:restore registers      	###sdw
:	INITIALIZE CONFSG SO WE CAN DETECT WHEN A LINE GOES LNCKTM TIMES
:	OF 4-SECONDS GAPS WITH NO GOOD RECORD.		###LH
	LHI	R1,LNCKTM
	STH	R1,CONFSG,LN	

	JAL	R8,ATTACT		:mark line as active		###wjl
	JAL	R10,KSPEED		:DETERMINE THE SPEED OF THIS LINK
:	the following allows tymfile setting of retrans delay if set or
:	uses the line speed if not specified
	lb	r10,lknm,kd
	lhl	r10,lnkrtr,r10,r10	:pick off desired line tracing
	jnfs	attl30			:use line speed (the default)
	lhl	r10,baudrt,ln
attl30	lhl	r10,rtrwat,r10,r10	:pacing according to line speed
	sth	r10,rtrdel,ln		:and save for use in ccwrtr

:	NOTIFY SUPERVISOR OF NEW LINE/LINK
	SIS	R7,1			:IS THIS A NEW LINK?
	JGFS	ATLNR1			:NO, MORE THAN 1 LINE, SUBSEQ LN ATTACH
	LHI	R4,13E0			:MESSAGE TYPE FOR NEW LINK REPORT
	LB	R0,KSPD,KD		:INCLUDE LINK SPEED IN REPORT	###OAS
	NHI	R0,001F			:MASK OFF SATELLITE BITS	###OAS
	AR	R4,R0			:				###OAS
	J	ATLNR2

:	report new link to supe
ATLNR1	LHI	R4,13C0			:MESSAGE TYPE FOR NEW LINE REPORT
	LHL	R0,BAUDRT,LN		:CHECK IF LINE IS HIGH SPEED	###OAS
	TBT	KN,KNCNSP		:IS SPEED SPECIFIED IN TYMFILE?
	JEFS	ATLNR9			:NO, REPORT CALCULATED SPEED
	LB	R0,KSPD,KD		:HIGH SPD AND SPECIFIED, USE LINK SPEED
	NHI	R0,1F			:ISOLATE SPEED BITS
ATLNR9	AR	R4,R0			:INCLUDE IN REPORT
ATLNR2	JAL	R10,SUP13,,		:NOTIFY SUPERVISOR OF NEW LINE/LINK

:	THE 5TH AND 6TH HALFWORDS IN A RESET FROM THE NEIGHBOR MAY HAVE
:	THE NEIGHBOR'S VERSION NUMBER AND THE VERSION NUMBER COMPLEMENT.
:	THE COMPLEMENT IS TESTED. If -1, the Version is stored in the KVERNO
:	field of the Link Descriptor. If not, FFFF was stored above. THIS MAY
:	OCCUR BECAUSE VERSIONS OF NODE CODE PRIOR TO 5.00 DID NOT
:	PROVIDE THEIR VERSION NUMBER.
	LH	R0,VRSTP+4,SD	:GET POTENTIAL VERSION NUMBER FROM RESET
	JEFS	ATLN9A		:0 NOT LEGAL VERSION, DON'T LET SPACING FOOL US
	LH	R1,VRSTP+6,SD	:VERSION NUMBER COMPLEMENT
	XR	R1,R0		:VERIFY THAT VERSION WAS PRESENT IN RESET
	AIS	R1,1
	JNFS	ATLN9A		:NOPE - OLD VERSION IN NEIGHBOR
	STH	R0,KVERNO,KD	:YES - SAVE VERSION NUMBER IN LINK DESCRIPTOR
ATLN9A

:	SET ACTIVE OUTPUT STATE 
	LHI	R0,SIOTT-SEG1
	STH	R0,SIOTST,LN

	IF	TSTSZE
	JAL	R10,ATTTST		:see if we're tracing this link	###wjl
	EI	:TSTSZE
	LR	R0,LN			:GET LINE NUMBER * 2
	SLLS	R0,0F			:HI-ORDER HW NOW HAS LINE NUMBER
	AH	R0,NDID,KD		:INCLUDE NEIGHBOR NUMBER
	ST	R0,CRYSBF		:SAVE FOR CRYPTO
	LB	R0,NLAT,KD		:NO. OF LINES ON LINK
	JAL	R8,CRYPTO		:SEND CRYPTOGRAM FOR
	HC	CRYE16			:	NEW LINE ATTACHED
	JAL	R8,GMTLIN		:STORE TIME

       if	bigcon
	stm	r0,sioreg
	clhi    ln,sbase
	jlfs    atlnr7
	lhi	r6,msbase,ln
	slls    r6,3
	ai	r6,siostt
	lhi	r0,-10  		:tell sioiz0  that this is dma init
	sth	r0,8,r6
	jal	r10,sioiz0
atlnr7
	lm	r0,sioreg
       ei 	:bigcon


:	TEST FOR SUBSEQUENT LINE ATTACH OR NEW LINK
	LB	R7,NLAT,KD		:GET NUMBER OF LINES ON LINK
	SIS	R7,1			:IF ONE LINE, THIS IS A NEW LINK
	JEFS	ATTLNK			:NEW LINK - SET IT UP

	IF	DB.TSN
	JAL	R11,LNKCON		:PERFORM LINE/LINK CONSISTENCY CHECK
	EI	:DB.TSN
	J	BIDDRT

:	NEW LINK HAS BEEN CREATED, INITIALIZE IT
ATTLNK	LH	R0,NDID,KD
	LR	R6,R0
	STH	R0,CHNMPD,KN,KN		:SET UP CHANNEL MAP FOR TRACE LOGIC
	LHI	R0,WBORIM		:TYM-II - SET EXPECTED BORI
	CHI	R6,MACHNM
	JGFS	ATTL20			:.+6
	LHI	R0,WBORIS
ATTL20	STB	R0,BORI,KD
	LHI	R0,0FF			:SET ACK MASK
	STH	R0,AMSK,KD

:	SET LINK TYPE (KTYP).(*0 FOR T-I, 4 FOR T-1.5,*) 8 FOR T-II.
	LIS	R0,8			:ASSUME T-II
	STB	R0,KTYP,KD
	LCS	R0,1			:INIT OTHER VARIABLES
	ST	R0,LRT,KD		:SET LRT,LAS,LRM,LAR TO -1
	ST	R0,LRM,KD
	LHL	R2,OSEC,KD		:SET NRXM=OSEC
	STH	R2,NRXM,KD		:NEXT REC XMITTED WILL BE THE FIRST
	STH	R2,NRMK,KD		:SO WILL NEXT REC MADE
	LB	R1,WSIZ,KD		:SET REC #'S TO -WSIZ TO -1
	JAL	R9,CLRCHN
	LHL	R2,ISEC,KD
	STH	R2,NRTR,KD
	JAL	R9,CLRCHN
	JAL	R8,GMTLIN		:SET TIME

	JAL	R10,NEWLNK		:SPIDER WILL COMPLETE INITIALIZING
	GL	NEWLNK
	LR	R2,LN			:LN MAY BE USED BY LNKCON##AL
	IF	DB.TSN
	JAL	R11,LNKCON		:PERFORM LINE/LINK CONSISTENCY CHECK
	EI	:DB.TSN
	LR	LN,R2			:GET LN BACK##AL

	J	BIDDRT

:	Reset received for potential new link, but neighbor
:	has different NETID.  Add neighbor (in R1) to list of neighbors,
:	report to SUP Log, make CRYPTO Log entry, and remove neighbor number
:	from list of neighbors	currently engaged in reset sequence (MRESET).

ATTNID	HS	0
	CLH	R1,BNETID,LN		:same as before?
	JER	R10			:yes, make no report
	STH	R1,BNETID,LN		:save neighbor with error
	OHI	R0,8000			:avoid escapes
	STH	R0,SUPMBF+4		:include neighbor's NETID in HW2
	LR	R1,LN			:line number*2
	SRHLS	R1,1			:line number
	OHI	R1,8000
	STH	R1,SUPMBF+2		:include line number in HW1
	LHI	R0,NR.NID
	STH	R0,SUPMBF		:indicate NETID mismatch in HW0
:	R10 is our link register and we are letting supe12 return for us#sdw
	J	SUP12,, 		:send message to Sup and CRYPTO Logs

::*********************************************************************
::
::	SUBROUTINE:	ATTADD:
::	FUNCTION:	ADD NEIGHBOR NUMBER TO MRESET, (LIST OF NEIGHBORS
::			CURRENTLY ENGAGED IN RESET SEQUENCE)
::	CALLING SEQ:	JAL	R8,ATTADD
::	INPUT:		R1 = NEIGHBOR NUMBER
::
::*********************************************************************

:	WE'RE MASTER. SEE IF ANOTHER RESET TO THIS NEIGHBOR IS IN PROGRESS
ATTADD	LHI	R5,-MRESTZ*2		:MRESET INDEX
ATTA1	CLH	R1,MRESET+MRESTZ*2,R5	:
	JE	BIDDRT			:YES, DONT BEGIN ANOTHER RESET SEQUENCE
	AIS	R5,2			:
	JLBS	ATTA1			:SCAN ALL ENTRIES IN MRESET

:	NO RESET SEQUENCE CURRENTLY IN PROGRESS.  STORE NEIGHBOR NUMBER
:	IN MRESET TO PREVENT MULTIPLE SIMULTANEOUS RESET SEQUENCES TO
:	SAME NEIGHBOR.
	LHI	R5,-MRESTZ*2		:MRESET INDEX
ATTA2	LH	R6,MRESET+MRESTZ*2,R5	:SEARCH FOR ZERO ENTRY
	JEFS	ATTA3			:GOT ONE
	AIS	R5,2			:
	JLBS	ATTA2			:SCAN ALL ENTRIES IN MRESET
	J	BIDDRT			:MRESET TABLE FULL. TRY AGAIN LATER...

ATTA3	STH	R1,MRESET+MRESTZ*2,R5	:STORE NEIGHBOR NUMBER IN MRESET
	JR	R8			:return				###wjl

::*********************************************************************
::
::	SUBROUTINE:	ATTMCL:
::	FUNCTION:	REMOVE NEIGHBOR NUMBER FROM MRESET, (LIST OF
::			NEIGHBORS CURRENTLY ENGAGED IN RESET SEQUENCE)
::	CALLING SEQ:	JAL	R8,ATTMCL
::	INPUT:		R1  = NEIGHBOR NUMBER
::
::*********************************************************************

ATTMCL	HS	0
	LHI	R5,-MRESTZ*2		:MRESET INDEX
ATTMC1	CLH	R1,MRESET+MRESTZ*2,R5
	JEFS	ATTMC2			:NEIGHBOR NUMBER MATCH
	AIS	R5,2
	JLBS	ATTMC1			:SCAN ALL ENTRIES IN MRESET
	JR	R8			:NEIGHBOR NUMBER NOT IN LIST
ATTMC2	LIS	R0,0
	STH	R0,MRESET+MRESTZ*2,R5	:ZERO ENTRY
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	ATTNR:
::	FUNCTION:	MAKE NODE REPORT TO SUPERVISOR LOG
::	CALLING SEQ:	JAL	R7,ATTNR
::
::*********************************************************************

ATTNR	STH	R0,SUPMBF		:INDICATE TYPE OF NODE REPORT
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER FROM RESET IN HW2
	LR	R0,LN
	SRLS	R0,1
	OHI	R0,8080			:OR'ING 80'S MEANS NO ESCAPES NECESSARY
	STH	R0,SUPMBF+4		:LINE NUMBER IN HW3
	JAL	R10,SUP12,,		:SEND MESSAGE TO SUPERVISOR LOG
	JR	R7			:				###wjl


::*********************************************************************
::
::	SUBROUTINE:	ATTWSZ:
::	FUNCTION:	DETERMINE IF WINDOW SIZE MATCHDOWN IS REQUIRED
::			if it is, call MCHDWN
::	CALLING SEQ:	JAL	R8,ATTWSZ
::	DESTROYED:	R1 - R4 and R9  If TUNL, R0 and R6 as well	###cwc
::*********************************************************************

ATTWSZ	LB	R1,VWSIZ,SD		:get received window size
	CLB	R1,XWSIZ,SD		:compare with transmitted window size
	JGER	R8			:VWSIZ is > or = XWSIZ, no problem

	JAL	R9,MCHDWN		:R2 stored in RLNK of last buffer
	STB	R1,WSIZ,KD		:set window size for this link
	LHI	R0,NR.WSZ		:send Node Report to Sup log
	STH	R0,SUPMBF		:indicate WSIZ match down in HW0
	LR	R0,LN			:line number * 2
	SRLS	R0,1			:line number
	OHI	R0,8000			:avoid escapes
	STH	R0,SUPMBF+2		:include line number in HW1
	OHI	R1,8000			:
	STH	R1,SUPMBF+4		:include neighbor's WSIZ in HW2
	ST	R8,ATTSAV		:save return
	JAL	R10,SUP12,,		:send message to Sup and CRYPTO Logs
	L	R8,ATTSAV		:restore return
	JR	R8			:

::*********************************************************************
::
::	SUBROUTINE:	ATTCLR:
::	FUNCTION:	CLEAR LINE STATISTCS, INCREMENT NUMBER OF LINES
::			ATTACHED TO LINK, INDICATE LINK NOT FROZEN
::	CALLING SEQ:	JAL	R8,ATTCLR
::	INPUT:		R7 = NUMBER OF LINES ATTACHED
::			LN = LINE NUMBER * 2
::			KD = LINK DESCRIPTOR
::
::*********************************************************************

ATTCLR	LIS	R0,0			:CLEAR LINE STATISTICS
	STH	R0,LINERR,LN
	STH	R0,BADACK,LN
	STH	R0,BADRCN,LN
	STH	R0,BADCSM,LN
	STH	R0,RCRXMT,LN
	STH	R0,RCRCVD,LN
	STH	R0,LCROSS,LN
	STH	R0,RCTRNS,LN
	STH	R0,TRRXMT,LN
	STH	R0,KL.TRF,LN
	AIS	R7,1			:INCREMENT
	STB	R7,NLAT,KD		:NUMBER OF ATTACHED LINES THIS LINK
	STH	R0,KFROZN,KD		:INDICATE LINK NOT FROZEN
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	ATTACT:
::	FUNCTION:	MARK LINE AS ACTIVE
::	CALLING SEQ:	JAL	R8,ATTACT
::
::***********************************************************************

ATTACT	LR	R1,LN
	SRLS	R1,1			:GET ACTUAL LINE NUMBER
	LIS	R0,0
	STB 	R0,DREASN,R1
	SBT	R1,ALINES		:LINE ACTIVE NOW
	RBT	R1,LINATT
	SBT	R1,INHRST		:PREVENT DETACHMENT BY STRAY RESETS
	SBT	R1,LNGREC		:PREVENT IMMEDIATE DETACH BY LNCHCK
	SBT	KN,LKGREC
	JR	R8

::*********************************************************************
::	SUBROUTINE:	ATTTST:
::	FUNCTION:	DETERMINE IF TRACING ON LINK
::	CALLING SEQ:	JAL	R10,ATTTST
::
::*********************************************************************
ATTTST	
      IF	TSTSZE
	LHL	R8,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R8,TSLINK		:	SEE IF WE'RE TRACING THIS LINK
	JNR	R10			:NO - CONTINUE
	JAL	R8,TSBMRK		:YES - SET UP NEW EVENT ENTRY
	LHI	R8,TS.ATT
	STB	R8,TSBTBL,R7		:STORE ENTRY TYPE
	LB	R8,NLAT,KD
	STH	R8,TSBTBL+2,R7		:SAVE NUMBER OF LINES CURRENTLY ON LINK
      EI	:TSTSZE
	JR	R10

	SUBTTL	LINKER (DETLIN - Line detach logic)

::*********************************************************************
::
::	SUB-PROCESS:	DETLIN:
::	FUNCTION:	Detaches lines placed in limbo after a valid
::	reset is detected.  Scheduled by LINKER.
::	CALLING SEQ:	LA	R3,LINDET
::			JAL	R9,BIDDY
::			J	DETLIN
::	CALLS:		JAL	R9,RSTSTR
::			JAL	R10,KSPEED
::			JAL	R8,CRYPTO
::			JAL	R8,GMTLIN
::			JAL	R10,TRLINK
::			JAL	R11,LNKCON
::	RETURNS:	J	BIDDRT
::
::*********************************************************************

DETLIN	HS	0
	LR	LN,R2			:GET 2*LINE NUMBER
	AR	LN,LN

	JAL	R9,RSTSTR		:PUT LINE IN RESET MODE
	L	KD,KDSVLN,LN,LN		:RETRIEVE PTR TO FORMER LINK
	LIS	R0,0			:RESET HI-ORDER BIT OF THIS FOR PROBE
	RBT	R0,NGSVLN,LN
	JAL	R7,BSIOST		:setup line rotation for each line##sdw

	LB	R7,NLAT,KD		:DECREMENT ATTACHED-LINE COUNT
	SIS	R7,1			:R7=0 IF LINK MUST BE TORN
	STB	R7,NLAT,KD
	JAL	R10,KSPEED		:RECOMPUTE LINK SPEED
	LR	R4,LN
	SRLS	R4,1			:GET ACTUAL LINE NUMBER IN R4
	LB	R4,DREASN,R4		:GET REASON FOR OUTAGE IN R4
	LR	R7,R7			:ANY LINES LEFT FOR THIS LINK?
	JNFS	DETLN2			:YES - LINK NOT OUT, REPORT LINE DETACH
	AHI	R4,1380			:REPORT LINK OUT TO SUPERVISOR
	LIS	R0,0			:	AND INSURE LINK NOT MARKED AS
	STH	R0,KFROZN,KD		:	FROZEN
	JFS	DETLN3
DETLN2	AHI	R4,13A0			:REPORT LINE DETACH TO SUPERVISOR
DETLN3	JAL	R10,SUP13,,		:SEND MSG TO SUP
	LR	R1,LN
	SRLS	R1,1			:GET ACTUAL LINE NUMBER IN R1
	LB	R0,DREASN,R1		:TELL XRAY, REASON ON LEFT
	EXHR	R1,R1			:LINE NUMBER IN HO HW
	LHL	R8,NGSVLN,LN		:NEIGHBOR NUMBER
	OR	R1,R8			:COMBINE AND
	ST	R1,CRYSBF		: SAVE FOR CRYPTO
	JAL	R8,CRYPTO
	HC	CRYE04			:LINE DETACHED
	JAL	R8,GMTLIN		:SET TIME
	LR	R7,R7
	JN	DETLN5			:NLAT > 0, LINK NOT GOING DOWN
	JAL	R10,TRLINK		:NON STR LINE TEAR LINK ##AL
	GL	TRLINK
	J	DETLN5

DETLN5	IF	DB.TSN
	JAL	R11,LNKCON		:PERFORM LINE/LINK CONSISTENCY CHECK
	EI	:DB.TSN
	J	BIDDRT

	SUBTTL	LINKER (Attach/Detach subroutines)

::*********************************************************************
::
::	SUBROUTINE: BSIOST
::	FUNCTION: setup SIOROR/SIOROT for multiline sio links
::      CALLING SEQ: link on R4
::	INPUT: KD of link gaining/losing line, uses NGSVLN
::	OUTPUT: SIOROR/SIOROT for multiline links
::								###sdw
::*********************************************************************

:	setup list of lines
:	search all lines and those that have the same neighor as this link
:	are put in the list.  The list pointer is set to 0 to prevent a
:	list shrinkage from leaving the pointer out of range.
BSIOST	LIS	R4,0			:check all lines
	LCS	R3,1			:found no other lines yet
	LIS	R2,0			:pointer within line list
BSIOS0  LH	R1,NGSVLN,R4,
	JGFS    BSIOS2  		:high bit set if link up
	NHI	R1,7FFF 		:make it into neighbor #
	CLH	R1,NDID,KD		:on our link?
	JEFS    BSIOS3  		:yes
BSIOS2  AIS	R4,2
	CLHI	R4,NLINES*2		:all lines
	JLBS    BSIOS0
	JR	R7			:checked all lines

BSIOS3  LR	R3,R3			:first line for link?
	JGEFS   BSIOS4  		:jump if not
	LR	R3,KD			:get link descriptor
	STB	R2,SIOROR,KD		:point to first line in list
BSIOS4  STB	R4,SIOROT,KD,R2 	:put into list
	AIS	R2,1
	J       BSIOS2


::*********************************************************************
::
::	SUBROUTINE:	GMTLIN:
::	FUNCTION:	Set time of line attach or detach
::	CALLING SEQ:	JAL	R8,GMTLIN
::	INPUT:		LN  =Line number*2
::	CALLS:		JAL	R9,GMTCAL
::
::*********************************************************************

GMTLIN	HS	0			:SET TIME OF LINE ATT/DET
	JAL	R9,GMTCAL,,		:GET CURRENT TIME
	L	R0,GMTNOW		:AND
	ST	R0,LINTIM,LN,LN		:STORE IT
	JR	R8			:RETURN TO THE SOURCE



::*********************************************************************
::
::	SUBROUTINE:	RSTSTR:/RSSCLP:
::	FUNCTION:	Forces line to transmit stream of resets with ping-pong
::	count set to 0.  This is the normal state of lines that have been
::	detached but are not yet in process of identification.
::	Entry point RSTSTR is used for T-II reset initiation.  Entry point
::	RSSCLP is used for SCLP reset initiation.
::	CALLING SEQ:	JAL	R9,RSTSTR
::	PRESERVED:	R11= NETID (preserved for IZLNKR)
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R6,R7,R8,R10
::	CALLS:		JAL	R7,RSTORE
::			JAL	R10,SIOIZ0
::			JAL	R0,SVCE32
::			JAL	R0,SVCE30
::
::*********************************************************************
:	ENTRY POINT FOR T-II RESET INITIATION
RSTSTR 
	LHI	R0,TXRSHD		:get T-II initial reset header	###wjl
	STH	R0,RSRSHD		:store it for RSTORE		###wjl
RSTS02	L	SD,SDLN,LN,LN		:PTR TO RESET BUFF
	LCS	R0,2			:SET RESET MODE FLAG
	ST	R0,KDLN,LN,LN
RSTSA2	LR	R6,SD			:RSTORE needs Reset Buff Ptr in R6
	JAL	R7,RSTORE		:store Xmit Reset Pattern

	IF	SILINS
	LR	R1,LN
	SRLS	R1,1			:actual Line Number 
	CLHI	R1,NLINES-SILINS-1	:SIO Line?
	JG	RSTSIO			:yes - jump
	EI	:SILINS

:	SET UP FOR SYNC SVCs
	LR	R1,LN			:set R1=Line Number
	SRLS	R1,1

:	CONNECT SYNC LINE I/O, AND RAISE DTR AND RTS SIGNALS.
					:GET LINE NUMBER * 2
	L	R2,SIOBLA,LN,LN		:R2 NOW POINTS TO ENTRY FOR THIS LINE
	LIS	R8,4			:COMMAND TO RAISE RTS
	STH	R8,0,R2
	LIS	R8,9			:COMMAND TO RAISE DTR
	STH	R8,8,R2
	LIS	R8,0			:COMMAND TO STOP OUTPUTTING
	STH	R8,10,R2
:		(POINTED TO BY R2).  R1 = LOGICAL UNIT NUMBER (LINE NUMBER).
	SVC	IO,20+R1		:PROCESS COMMANDS IN ROTOR
	JAL	R0,SVCE32		:ERROR, CRASH 

:	while the sync raise signals svcs are supposed to complete
:	immediately, give them a moment (until foreground runs)
	LHI	R0,SIORR-SEG1		:go t continous reset state
	STH	R0,SIOTSV,LN		:after initialization completes
	LHI	R0,SYNRWT-SEG1  	:setup sync wait state
	STH	R0,SIOTST,LN

	LHL	R2,SVBDIS,LN	:GET THIS LINE'S DISPLACEMENT INTO SYNC INPUT
	LA	R2,SVNTIP,R2,	: BUFFERS AND ADD TO BUFFER POOL START ADDRESS
	LHI	R3,SVNBSZ		:SYNC INPUT BUFFER SIZE
	SVC	IO,01			:CONNECT SYNC INPUT
	JAL	R0,SVCE30		:ERROR, CRASH

:	PROCESS SIO LINE
	IF	SILINS
	J	RSTST2			:SKIP FOR SYNC LINE
RSTSIO

	LHI	R0,SIORR-SEG1
	STH	R0,SIOTST,LN		:for SIOIZ0 to save while it waits
	LR	R2,LN
	SHI	R2,(NLINES-SILINS)*2
	SLLS	R2,3			:COMPUTE RELATIVE SIO LINE NUMBER * 10
	LCS	R0,3			:INDICATE SIO LINE BEING RE-INITIALIZED
	STH	R0,SIOSTT+8,R2,		: DUE TO LINE GOING TO RESET STATE
	JAL	R10,SIOIZ0		:INITIALIZE SIO LINE
	L	SD,SDLN,LN,LN		:RESTORE POINTER TO RESET BUFFER
	LIS	R0,0
	STH	R0,BAUDRT,LN		:CLEAR LINESPEED FOR DETECTING
				:CALCULATED MAXIMUM VALUE OVER 16d RESETS###OAS

RSTSDD	L	R6,SIORSP,LN,LN		:SIO RESET POINTER
	SHI	R6,VSDSZ-2		:-offset for received Pattern Size
RSTS12	JAL	R7,RSTORE		:+HW storage for SIO Reset Buffer Size
	LR	R1,LN
	SRLS	R1,1			:restore R1 = actual Line Number
	EI	:SILINS

RSTST2	RBT	R1,ALINES		:MARK THE LINE AS NO LONGER ACTIVE
	RBT	R1,INHRST		:MAKE SURE RESETS SEEN
	RBT	R1,LINATT		:END ATTACHING PROCESS
	LIS	R0,0			:RESET THE RESET COUNT
	STH	R0,RSCNT,SD
	STH	R0,RSTIM,SD
	JR	R9

SVCE32	CRASH.(.SV32C,R5)
SVCE30	CRASH.(.SV30C,R5)

::*********************************************************************
::
::	SUBROUTINE:	RSTORE:
::	FUNCTION:	Stores Reset Pattern for Transmit
::	CALLING SEQ:	JAL	R7,RSTORE
::	INPUT:		R6 =Pointer to reset buffer
::			RSRSHD must be setup with either T-II or SCLP
::			reset header prior to call
::	DESTROYED:	R0, R1, R2, R3
::	CALLS:		JAL	R5,CCKSUM
::
::*********************************************************************

RSTORE	HS	0
	LHL	R0,RSRSHD		:set the initial pattern	###wjl
	STH	R0,XRSTP,R6		:store Expanded Reset Header
	LI	R0,MACHNM
	ST	R0,XNDID,R6		:store Machine Number
	LHI	R0,(VERSION&0FFF)
	STH	R0,XVERNO,R6		:store VERSION
	LHL	R0,LNETID,LN
	STH	R0,XNETID,R6		:store NETID
	LHI	R0,SUBNET
	STH	R0,XSUBNT,R6		:store SUBNET
	LIS	R0,8			:ATTLIN will fill in WSIZ
	STB	R0,XWSIZ,R6		:for TIILNK during ping-pong
	LR	R2,LN			:Line Number*2
	SRLS	R2,1			:actual Line Number
	STB	R2,XLINE,R6		:store Line Number
	LI	R0,HST0
	ST	R0,XHOST0,R6		:store Kernel Host Number
	LB	R0,RREASN,R2		:**Reason for Reset to be
	STB	R0,XRSRSN,R6		:implemented later**
	LIS	R0,0			:ATTLIN will fill in TIILNK
	STB	R0,XKSPD,R6		:Capabilities during ping-pong
	ST	R0,XKATTR,R6		:implemented later**
	LI	R0,DIALUP		:**Dial-up Number to be
	ST	R0,XDIAL,R6		:implemented later**
	JAL	R5,CCKSUM		:calculate and store checksum
	JR	R7


::*********************************************************************
::
::	SUBROUTINE:	CCKSUM:
::	FUNCTION:	Calculate and store checksum for reset pattern
::	CALLING SEQ:	JAL	R5,CCKSUM
::	INPUT:		R6 = Pointer to reset buffer
::	DESTROYED:	R0, R1, R2, R3
::
::*********************************************************************


CCKSUM	HS	0			:SET UP FOR CKSUM
	LI	R0,-VSDSZ		:negative byte count in R0
	LA	R1,XRSTP,R6		: starting address
	LIS	R2,0			: clear accumulators
	LIS	R3,0			: for CKSUM instruction
	CKSUM	R2,R1			:calculate checksum
	STH	R2,XCKSUM,R6		:store vertical checksum
	STH	R3,XCKSUM+2,R6		:store diagonal checksum
	JR	R5

::*********************************************************************
::
::	SUBROUTINE:	KSPEED:
::	FUNCTION:	Computes the speed of a given link from the
::			speed of its attached lines.
::	CALLING SEQ:	JAL	R10,KSPEED
::
::*********************************************************************

:	THIS ROUTINE REWRITTEN TO CORRECT A BUG FROM VERSION 4.	###jhl 4/83
:	LOGIC CHANGED TO AVOID MISCONFIGURATION  		###OAS 2/83

KSPEED	HS	0
KSPEE0	LIS	R0,0			:INITIALIZE CUMULATIVE SPEED COUNTER
:	LHI	R1,2*NLINES-2		:COUNT BACKWARDS THROUGH THE LINES
	LI	R1,2*NLINES-2		:COUNT BACKWARDS THROUGH THE LINES
KSPEE1	L	R3,KDLN,R1,R1		:IS THE LINE ATTACHED TO THIS LINK?
	CR	R3,KD
	JNFS	KSPEE3			:IF NOT, GET PREVIOUS LINE
	AH	R0,BAUDRT,R1		:ELSE ADD IN THE LINE SPEED
KSPEE3	SIS	R1,2			:STEP BACK TO PREVIOUS LINE
	JGEBS	KSPEE1			:LOOP AS LONG AS THERE ARE LINES
KSPE33
	CLHI	R0,1F			:HAS ACCUMULATED SPEED OVERFLOWED?
	JLFS	KSPEE4			:NO--IT'S OK
	LHI	R0,1F			:ELSE SET IT TO MAX
KSPEE4	LB	R1,LKNM,KD		:GET THE LINK NUMBER SET UP

:	IF LINK SPEED ADDS UP TO BE HIGH SPEED (>19.2KB)
:	CHECK TYMFILE TO SEE IF CONFIGURED LINK SPEED SPECIFIED.
:	IF SO USE SPEC, IF NOT USE CALCULATED VALUE.

	TBT	R1,KNCNSP,,		:WAS LINK SPD SPEC IN TYMFILE?
	JEFS	KSPEE5			:NO.  USE CALCULATED SPEED.
	LB	R3,KNSAT,R1		:GET BYTE SET UP AT ASSEMBLY TIME
	STB	R3,KSPD,KD		:AND USE THAT FOR OUR KSPD BYTE
	JR	R10			:RETURN TO CALLER

:	SPEED NOT SPECIFIED IN TYMFILE.  USE THE CALCULATED LINK SPEED.
:	RESTORE PROPER BITS WITH RESPECT TO SAT AND TI WS 8.

KSPEE5	LB	R3,KNSAT,R1		:GET KSAT<LINK #>
	NHI	R3,0E0			:STRIP SPEED BITS
	OR	R0,R3			:MIX FLAGS AND SPEED
	STB	R0,KSPD,KD		:STORE IN LINK DESCRIPTOR
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	LSPEEZ:
::	FUNCTION:	Initializes input pointers for line speed calculations
::	CALLING SEQ:	JAL	R8,LSPEEZ
::	INPUT:		R13 = Bit array for sync lines requesting line
::				speed computation
::
::*********************************************************************

LSPEEZ	HS	0
	JFFO	R13,LSPEZ1		:YIELDS LINE NO. IN R14 (LN)
	JR	R8			:ALL DONE
LSPEZ1	HS	0
	SLLS	LN,1			:2 * LINE NO.
	LHL	R3,SVBDIS,LN		:COMPUTE <POSITION>
	LH	R3,SVNTIP,R3,
	STH	R3,LNRPOS,LN		:UPDATE POSITION
	X	R13,WMSK,LN,LN		:TURN OFF THAT BIT
	GL	WMSK
	J	LSPEEZ			:DO NEXT ONE

::*********************************************************************
::
::	SUBROUTINE:	LSPEED:
::	FUNCTION:	Computes speed of line from the rate at which
::			data is being received at the interrupt buffers.
::	CALLING SEQ:	JAL	R8,LSPEED
::	INPUT:		R13 = bit array of lines requesting speed calculation
::			R4  =  FASTC interval to measure over
::
::*********************************************************************

LSPEED	HS	0
	JFFO	R13,LSPEE1		:YIELDS LINE NO. IN R14 (LN)
	ST	R13,LINSPD		:RESET LINE SPEED REQUEST BITS
	JR	R8			:ALL DONE
LSPEE1	HS	0
	SLLS	LN,1			:2 * LINE NO.
	LHL	R3,SVBDIS,LN		:COMPUTE <DELTA POSITION>
	LH	R2,SVNTIP,R3,
	LH	R3,LNRPOS,LN
	STH	R2,LNRPOS,LN		:UPDATE POSITION
	SR	R2,R3
	JGFS	LSPEE3
	AHI	R2,SVNBSZ
LSPEE3	SLLS	R2,2			:TIMES 4
	DHR	R2,R4
	CLHI	R3,0F			:DON'T LET IT OVERFLOW
	JLEFS	LSPEE2			:O.K.
	LIS	R3,0F			:MAX VALUE...
LSPEE2	LB	R3,LSPEET,R3
	STH	R3,BAUDRT,LN
	X	R13,WMSK,LN,LN		:RESET THAT BIT
	J	LSPEED			:DO NEXT ONE

LSPEET	BC	1,1,1,2,2,2,3,4,4,4,6,6,6,8,8,8	:ADD 14.4 		###OAS

::*********************************************************************
::
::	SUBROUTINE:	LNKCON:
::	FUNCTION:	Consistency check for line and link fields.
::	CALLING SEQ:	JAL	R11,LNKCON
::	INPUT:		KD = Expects valid linK Descriptor
::	DESTROYED:	R12, R13, R14 (LN)
::
::*********************************************************************

:	ALL LINE FIELDS ARE EXAMINED FOR INDICATIONS OF BEING ATTACHED
:	TO THE LINK LAST OPERATED ON (THE CALLING ROUTINE PASSES A
:	VALID LINK DESCRIPTOR INDEX).  THE LINK DESCRIPTOR VALUES ARE
:	COMPARED TO THE	CUMULATIVE LINE FIELD VALUES, AND THE NODE IS
:	CRASHED IF AN INCONSISTENCY IS DISCOVERED.

	IF	DB.TSN

LNKCON	HS	0
	LIS	R12,0		:R12 COUNTS THE NUMBER OF LINES ASSOCIATED
				:	WITH THIS LINK.
	LHI	LN,(NLINES-1)*2		:SCAN ALL LINES
LNKC10	LH	R13,NGSVLN,LN		:GET NEIGHBOR NUMBER FOR LINE
	JGE	LNKC20			:HI-ORDER BIT SHOULD BE SET FOR
	NHI	R13,7FFF		: ATTACHED LINE
	CLH	R13,NDID,KD		:LINE NEIGHBOR # = LINK NEIGHBOR #?
	JN	LNKC20			:NO - THIS LINE ATTACHED TO DIFFERENT
					:  LINK
	LR	R13,LN
	SRLS	R13,1			:GET ACTUAL LINE NUMBER
	TBT	R13,ALINES		:IS LINE MARKED AS ACTIVE?
	JE	OP1663			:NO - IT SHOULD BE ACTIVE

	SLLS	LN,1
	L	R13,KDSVLN,LN		:COMPARE KD TO THIS LINE'S KDSVLN
	SRLS	LN,1
	CLR	R13,KD			:EQUAL?
	JN	OP1463			:NO - CRASH...

	AIS	R12,1			:INCREMENT COUNT OF LINES ATTACHED TO
					: LINK
LNKC20	SIS	LN,2			:CHECK ALL LINES
	JGE	LNKC10

:	ALL LINES SCANNED. NOW VERIFY THAT TOTAL NUMBER OF LINES
:	DISCOVERED EQUALS 'NLAT' LINK COUNT, AND THAT LINK IS ACTIVE IF
:	NLAT > 0.  
	LB	R13,NLAT,KD		:LINK FIELD FOR # OF LINES ATTACHED
	CLR	R13,R12			:COMPARE TO SUM OF LINE FIELDS FOR LINK
	JN	OP1863			:NOT EQUAL - CRASH

	LB	R13,LKNM,KD		:GET LINK NUMBER
	TBT	R13,ALINKS		:IS LINK ACTIVE?
	JN	LNKC30			:YES
	LR	R12,R12			:NO - NUMBER OF LINES SHOULD EQUAL 0
	JER	R11			:O.K.
	TBT	R13,BORZAP		:DON'T CRASH IF LINK BORI-ZAPPED...
	JeR	R11             :inverted borzap by sdw
	CRASH.(.LKER0,R0)
LNKC30	LR	R12,R12			:ACTIVE LINK SHOULD HAVE # OF LINES > 0
	JNR	R11			:O.K.

OP1263	CRASH.(.O1263,R0)
OP1463	CRASH.(.O1463,R0)
OP1663	CRASH.(.O1663,R0)
OP1863	CRASH.(.O1863,R0)

	EI	:DB.TSN

::*********************************************************************
::
::	SUBROUTINE:	SIPKSV:			###AL
::	FUNCTION:	Save SIO line bad packets received 
::	CALLING SEQ:	JAL	R9,SIPKSV
::	INPUT:		R11,R13 are pointers for SIBUF, LN(R14) is line#
::	DESTROYED:	R0,R8
::
::*********************************************************************

       IF	 SILINS
SIPKSV  			:save packets into debugger     	###sdw
       IF	 LNKDBG  	:for link/line debugger
	STM	R0,RGST 	:save regs into foreground save area
	GL      SIPDB1
	JAL	R14,SIPDB1,,    :the debugger routine
	LM	R0,RGST 	:restore regs
       EI 	:LNKDBG

	JR	R9		:that's it      			###sdw
       EI	:SILINS

	SUBTTL	LINKER (SYLVER - Dispatcher for input on sync lines)

::*********************************************************************
::
::	PROCESS:	SYLVER:
::	FUNCTION:	Sync and SIO data handlers
::	CALLING SEQ:	SYLVER IS SCHEDULED TO BE RUN EACH 16 MILLISECONDS
::	OR EACH TIME THROUGH THE EXEC LOOP -- WHICHEVER IS MORE FREQUENT.
::
::		A SET OF ROUTINES PROCESS THE DATA RECEIVED ON THE NETWORK
::	SYNC LINES, MOVE THE DATA FROM THE INPUT RINGS TO SECTOR BUFFERS,
::	ALIGN THE DATA, PERFORM CHECKSUMMING, AND HANDLE SEQUENCING AND
::	ACKNOWLEDGING PACKETS.  EACH LINE 'CONTROL BLOCK' CONTAINS THE ADDRESS
::	OF THE CURRENTLY ACTIVE 'ROUTINE' AT QSYLVER.
::	THERE ARE THREE POSSIBLE ENTRY POINTS:
::	SYLMRK -- SEARCH FOR START BIT (BORI)
::	SYWAIT -- WAITING FOR RECEPTION OF COMPLETE DATA RECORD
::	SYLDWT -- WAITING FOR RECEPTION OF COMPLETE DOWNLINE LOAD RECORD
::
::		Then fall through to process I/O on SIO lines (if any).
::	
::	REGISTER USAGE:
::	R0  -- WORK REGISTER
::	R1  -- WORK REGISTER
::	R11 -- INPUT DATA LEAD POINTER
::	R12 -- INPUT DATA TRAILING POINTER
::	R13 -- INPUT RING ADDRESS
::	R14 -- LINE NUMBER X 2
::	R15 -- LINK DESCRIPTOR ADDRESS
::
::	CALLS:	JAL	R8,LSPEEZ
::
::*********************************************************************

SYLVER	HS	0			:IF ISIS, THIS IS FOREGROUND
       if	tii.fg
	svc     fast,0
       else     :if run from BG then sylver is a routine
	ST	R10,dssvrt
       ei 	:tii.fg
	LIS	R0,0
	STH	R0,GOVSWI


:	RECORD INTERVAL BETWEEN SYLVER EXECUTIONS IN HISTOGRAM AND TEST
:	FOR NEW SYLVER INTERVAL HIGH-WATER MARK.
	LIS	R0,1
	AHM	R0,SYLXEC		:INCREMENT COUNT OF SYLVER ECECUTIONS
	L	R2,FASTC,,
       if	1-tii.fg		:only if no fg
	lr	r1,r2
	ahi	r1,rate/32		:give it 50d shots a second
	st	r1,syvsch		:when to run again
       ei 	:tii.fg
	LR	R1,R2
	S	R2,SYLTIM		:COMPUTE TIME SINCE SYLVER LAST RAN
	ST	R1,SYLTIM		: AND SAVE CURRENT FASTC FOR NEXT TIME
	JL	SYLV00			:IF FASTC WRAP, SKIP, DON'T CRASH!
	LR	R4,R2			:SAVE SYLVER INTERVAL:*Z
	CLH	R2,SYLHWM		:DOES SYLVER INTERVAL EXCEED PREVIOUS
					:	HIGH-WATER MARK?
	JLEFS	SYLS00			:NO
	STH	R2,SYLHWM		:YES - SAVE

SYLS00	HS	0		:COMPUTE LINE SPEED FOR ANY LINES REQUESTED
	L	R13,LINSPD	:BIT SET IN LINSPD EVERY SEC FOR EACH SYNC LINE
				: WHICH HAS RECEIVED 2 GOOD RESETS
	JE	SYLV00			:NONE
	LH	R3,SYLINT		:HAVE WE GOT A GOOD INTERVAL,15-100 MS?
	JL	SYLS03			:NOPE, HAVEN'T EVEN STARTED YET.
	AH	R4,SYLINT		:SEE IF WE'VE GOT A GOOD INTERVAL
	CLHI	R4,9			:MUST BE < 15 MS
	JLFS	SYLS02
	CLHI	R4,3C			:MUST BE < 100 MS
	JGEFS	SYLS03
	JAL	R8,LSPEED		:OK, GO MEASURE
	TS	SYLINT			:INDICATE NO MEASUREMENT IN PROGRESS
	JFS	SYLV00

SYLS02	HS	0			:NOT ENOUGH YET
	STH	R4,SYLINT		:TRY AGAIN NEXT TIME
	JFS	SYLV00

SYLS03	HS	0			:TOO MUCH OR JUST STARTING
	LIS	R4,0			:START OVER
	STH	R4,SYLINT
	JAL	R8,LSPEEZ		:INITIALIZE INPUT POINTER POSITIONS

SYLV00	HS	0
	if      nlines-silins		:if sync lines
	LHI	LN,(NLINES-SILINS-1)*2	:PROCESS ALL SYNC LINES
	ELSE	SILINS			:CHECK IF NO LINES AT ALL	###OAS
	j       sylrtx  		:no sync lines
	EI	:SILINS

SYLV01	HS	0
	LHL	R13,SVBDIS,LN		:RELATIVE START OF INPUT RING
	LHL	R11,SVNTIP,R13,		:RAW DATA LEAD POINTER
	LA	R13,SVNTBF,R13,		:INPUT RING FULL ADDRESS
	LHL	R12,SVNTOP,LN		:INPUT DATA TRAIL POINTER
	LHL	R1,QSYLVR,LN		:GET ROUTINE ADDRESS
	J	SEG1,R1,,		:GO TO IT

:	GENERAL EXIT POINT FOR SYNC LINE INPUT PROCESSOR. LOOP
:	BACK IF THERE ARE MORE SYNC LINES, OR ELSE FALL THROUGH
:	TO PROCESS I/O ON SIO LINES (IF ANY)

SYLRET	STH	R12,SVNTOP,LN		:SAVE TRAIL POINTER
	SIS	LN,2			:TRY NEXT LINE
	JGE	SYLV01			:LOOP BACK IF THERE IS A NEXT LINE
       IF	 1-SILINS		:IF NO SIO
	J       SDSMISS 		:QUIT
       EI 	:

	SUBTTL	LINKER (SYLVER - SIO input processor)

::*********************************************************************
::
::	ROUTINE:	SYLRTX:
::	FUNCTION:	SCAN FOR INPUT AND OUTPUT TASKS TO BE PERFORMED
::			ON ALL SIO LINES.
::	CALLING SEQ:	Fall through from SYLVER loop above.  DO ALL INPUT
::	FOR A GIVEN LINE (UNTIL BYTE COUNT IS NEGATIVE), THEN DISPATCH TO
::	OUTPUT STATE (SIOUT) TO SEE WHAT THERE IS TO DO.
::	SYNC lines:  input has already been done, so only do output.  The
::		change is to start from line 0 instead of the first SIO
::		line.
::	CALLS:		JAL	R9,NETDGN
::			JAL	R0,TSFMRK
::			JAL	R8,TSNSPK
::			JAL	R2,TSFUAL
::	RETURNS:	JL	SIOUT
::
::*********************************************************************

	IF	SILINS
SYLRTX	HS	0
	lis	r0,0
	sth	r0,rtdgov
	LHI	LN,(NLINES-SILINS)*2	:PROCESS ALL SIO LINES, FROM TOP DOWN
SIO1	LHL	R13,SIBUFP,LN		:GET POINTER TO INPUT BUFFER
	LH	R11,SIBUFN,LN		:OFFSET OF NEXT EXPECTED RECORD
	l       r0,fastc,,
	s       r0,rtdgvt       	:time to govern rtd from sio input?
	jlefs   SIOI1
	ts      rtdgov  		:in some danger of sio input wrap

SIOI1
	LH	R10,SIBUF,R13,R11	:GET THE BYTE COUNT
	JGEFS   SIOI01  		:something arrived
	AIS     LN,2
	CLHI    LN,NLINES*2
	JL    SIO1			:service next line
	l       r0,fastc,,
	ahi     r0,siothr       	:time to danger of sio input wrap
	st      r0,rtdgvt
	J       SDSMIS  		:else dismiss
SIOI01	JE	SIOBER			:ERROR IF ZERO
	LH	R10,SIBUF,R13,R11	:GET THE BYTE COUNT
					:REGULAR SIO LINE
	CLHI	R10,84			:GREATER THAN MAX RECORD SIZE?
	JG	SIOBER			:YES - ERROR
	LB	R0,SIBUF+2,R11,R13	:IF FIRST BYTE OF DATA IS ZERO
	JE	SIOI2			:GARBAGE RECEIVED

:	COMPLETE RECORD RECEIVED
:	FIRST SEE IF THIS SIO LINE IS BEING USED FOR A DOWNLINE LOAD

SII12	TBT	LN,DWLDSP		:IS LN ON DWL LIST?
	JN	SIODWL			:YES, BRANCH AWAY TO SERVICE
:					:###LSH
	LR	R0,R10			:R0= BYTE COUNT	###LSH
					:REGULAR LINE
SIIX1	LIS	R1,7			:FIND RECORD SIZE MOD 8
	NR	R1,R0			:ZERO MOD8 MEANS SOFTWARE ###LSH
	JE	SIOI3			:CHECKSUMS RECEIVED
	SIS	R1,4			:FOUR MOD8 MEANS NO SOFTWARE
	JE	SIOI4			:CHECKSUMS

SII16	
	LIS	R0,1			:BAD RECORD SIZE -- NOTE IT
	AHM	R0,SIOBRS
	JAL	R9,SIPKSV		:SAVE 28 BYTES OF THIS BAK PACKET

:	RE-INITIALIZE SIO INTERFACE IF BAD RECORD SIZE...
:	SETTING SIOSTT+8 TO NON-ZERO VALUE CAUSES SIOIZ TO INITIALIZE.
:	NOTE--SIOIZ IS CALLED FROM THE TWO SECOND LOGIC.

SIORIN	HS	0
	LR	R9,LN
	SHI	R9,(NLINES-SILINS)*2	:GET RELATIVE (SIO LINE NUMBER)*10
	SLLS	R9,3
	TS	SIOSTT+8,R9,		:-1 INDICATES SOFTWARE INITIALIZATION

:	ADVANCE TO NEXT RECORD

SIOI2	LCS	R0,1			:CLEAR COUNT IN CASE FIRST 1/2
	STH	R0,SIBUF,R13,R11	:	WORD IN BUFFER
	AR	R11,R10			:ADVANCE INPUT INDEX
	AIS	R11,3			
	NHI	R11,7FFE		:ALIGN TO HALFWORD BOUNDARY
	CLHI	R11,SIBFSZ-84		:ROOM FOR ANOTHER RECORD?
SII23	JLFS	SIOI25			:YES, SKIP
	LIS	R11,0			:NO, GO BACK TO BEGINNING
SIOI25	STH	R11,SIBUFN,LN
	J	SIOI1

:	ERROR DETECTED IN FIRST HALFWORD OF SIO BUFFER - COUNT TOO LARGE
:	OR ZERO. INCREMENT ERROR COUNT, SAVE SOME REGISTERS.

SIOBER	HS	0
	LIS	R7,1			:INCREMENT COUNT OF BUFFER ERRORS
	AHM	R7,SIOECT

       IF	 LNKDBG  		:link debugger may save some stuff
	STM	R0,RGST
	JAL	R14,SIBDB1,,
	GL      SIBDB1
	LM	R0,RGST
       EI	:LNKDBG						###sdw
:	FORMAT DIAGNOSTIC NODE REPORT AND CRYPTOGRAM
:	DON'T CALL NETDGN FROM HERE SINCE WE ARE IN FOREGROUND. FORMAT
:	MESSAGE IN SUPIBF, WITH FIRST HALFWORD USED AS SEMAPHORE FOR
:	SWITCH.  
	STB	LN,SUPIBF+3		:SAVE LINE NUMBER*2
	OHI	R10,8000
	STH	R10,SUPIBF+4		:REPORT BAD COUNT IN BUFFER###sn###wjl
	LIS	R8,DR.SIO
	STB	R8,SUPIBF+2		:DIAGNOSTIC SUB-TYPE FOR SIO ERROR
	STH	R8,SUPIBF		:ALERT SWITCH THAT NODE REPORT WAITING
	J	SIOI2			:GO RE-INITIALIZE SIO HARDWARE

:	COME HERE TO CHECK SOFTWARE CHECKSUMS

SIOI3	LIS	R2,0			:CLEAR ACCUMULATORS	###LSH
	LIS	R3,0
	LIS	R0,4			:NEGATIVE BYTE COUNT IN R0
	SR	R0,R10
	LA	R9,SIBUF+2,R13,R11	:POINT TO BEGINNING OF DATA
	LR	R1,R9			:VERS 18 MICROCODE SMASHES R2 OF CKSUM
	CKSUM	R2,R1			:CKSUM PACKET, STARTING AT R1 ADDRESS
	XH	R2,-4,R10,R9		:COMPARE CALCULATED AND RECEIVED
	XH	R3,-2,R10,R9		:CHECKSUMS

SIIX3	OR	R3,R2
	LHR	R3,R3			:###LSH
	JE	SIOI4			:GOOD CHECKSUM...
	LIS	R0,1			:SIO CARD SLIPPED US A BAD ONE
	AHM	R0,SIOBCS
	AHM	R0,BADCSM,LN		:RECORD BAD CHECKSUM

	IF	TSTSZE			:IF SYNC TRACING ENABLED
	L	KD,KDLN,LN,LN		:LINK DESCRIPTOR ADDRESS
	JL	TSLB15			:UNASSIGNED LINE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB15			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	LHL	R4,SIBUF+2,R11,R13	:GET RECORD HEADER IN R4
	LB	R0,SIBUF+4,R11,R13	:GET RECORD NUMBER
SIIX5	LH	R2,LAS,KD
	SHI	R2,07F
	SR	R0,R2			:GET CURRENT 1/2 WORD
	LBR	R0,R0			:	RECORD NUMBER TO R2
	AR	R2,R0
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.CSE
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (CHECKSUM ERROR)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB15	EI	:TSTSZE

	J	SIOI2			:###LSH

:	RECORD RECEIVED WITH GOOD CHECKSUM -- SEE WHAT IT CONTAINS

SIOI4	
	LHL	R4,SIBUF+2,R11,R13	:GET RECORD HEADER IN R4
	L	KD,KDLN,LN,LN		:LINK DESCRIPTOR ADDRESS
	JL	SILUAL			:HANDLE RECORD ON UNASSIGNED LINE

SI41	EXBR	R0,R4			:ISOLATE BORI
	NHI	R0,0F0
	CLB	R0,BORI,KD		:GOOD BORI?
	JN	SIOI7			:NO

	EXBR	R1,R4			:GET BYTE COUNT
	NHI	R1,0F			:	VIA TABLE LOOKUP
	LB	R1,SYTWCN,R1
	LR	R0,R10			:COMPARE RECEIVED RECORD SIZE
	SR	R0,R1			:	AGAINST EXPECTED SIZE
	JEFS	SIOI41
					:REGULAR LINE
	SIS	R0,4			:ALLOW FOR SOFTWARE CHECKSUMS
	JEFS	SIOI41			:SKIP IF VALID COUNTT

					
SI422					:				###cwc
	LIS	R0,1			:INC BAD SIZE COUNTER
	AHM	R0,SIOMIS
	J	SIOI2

SIOI41
	LB	R0,SIBUF+4,R11,R13	:GET RECORD NUMBER
SI42	LH	R2,LAS,KD
	SHI	R2,07F
	SR	R0,R2			:GET CURRENT 1/2 WORD 
	LBR	R0,R0			:	RECORD NUMBER TO R2
	AR	R2,R0
	LB	R5,WSIZ,KD		:GET NUMBER OF SECTORS
	LHL	R6,ISEC,KD		:SECTOR 0 DESCRIPTOR ADDRESS
	LR	R0,R2
	SH	R0,RECN,R6		:DISTANCE TO SECTOR 0
	LHR	R0,R0
	JGEFS	SIOI45			:AHEAD OF SECTOR 0
	AR	R0,R5			:ADJUST FOR WRAP AROUND
SIOI45	CR	R0,R5			:TOO FAR AHEAD?
	JLFS	SIOI46			:NO
	SR	R0,R5			:YES, BACK UP

SIOI46
	lr	r9,r0
	lhl	r0,ccdsz,r9,r9  	:get rel sector address
:	MH	R0,CCDSZ		:GET RELATIVE SECTOR ADDRESS
	AR	R6,R0			:CORRECT SECTOR DESC ADDR TO R6
	LR	R0,R2			:MOVE REC # TO R0
	SH	R0,LRT,KD		:IS THIS REC # .LE. LAST REC TORN?
	LHR	R0,R0
	JLE	SIOI6			:YES, THIS REC IS A RETRANSMISSION

	CR	R0,R5			:IS REC # .LE. LRT + WSIZ?
	JLE	SIOI5			:YES, OK

:	BAD RECORD NUMBER RECEIVED

SRXB00	LB	R0,NLAT,KD		:IF MULTIPLE-LINE LINK, DON'T COUNT
	CLHI	R0,1			:	BAD RECORD NUMBER...
	JNFS	SIOI48
	AHM	R0,BADRCN,LN		:INC BAD RECORD COUNTER
	JAL	R9,SIPKSV		:SAVE THIS BAD PACKET ##AL
SIOI48	IF	TSTSZE			:IF SYNC EVENT TRACING ENABLED
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB14			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BRN
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD RECORD NUMBER)
	STH	R4,TSFTBL+2,R15		:STORE RECORD HEADER
	STB	R2,TSFTBL+4,R15		:	AND PACKET RECORD NUMBER
	LIS	R0,0			:PROVIDE OPPORTUNITY TO PATCH
	LHL	R0,TSLINK		:THIS 'LHL' TO A 'STH' TO TERMINATE
					:TRACING AND EXAMINE HISTORY
					:PRIOR TO BAD RECORD OCCURRENCE.
	L	R15,TSRSVE
TSLB14	EI	:TSTSZE

	J	SIOI2

:	COPY THE DATA TO THE INPUT SECTOR (IF NOT RETRANSMISSION)

SIOI5	CLH	R2,RECN,R6		:WAS RECORD RECEIVED?
	JE	SIOI6			:YES, NOTE RETRANSMISSION
	if      1-tii.fg		:can only do if no foreground
	clh	r6,nrtr,kd		:this the next record to tear?
	jn      sioi52  		:no, copy it
	lh      r0,RTDGOV
	je      siortd  		:prevent oursevles from getting
	 				:overwhelmed and not servicing
	 				:everything else.
       ei 	:tii.fg

:	NOW COPY THE DATA
:	Changed to copy before setting okay to tear since if interupted before
:	copy completed then tear does not get a valid packet    	###sdw

sioi52	LA	R7,SIBUF,R11,R13	:SET R7 TO ADDRESS OF LAST
	AR	R7,R1			:	HALFWORD OF SOURCE
	L	R8,BREC,R6		:SET R8 TO ADDRESS OF LAST
	ahi	R8,-2,R1	:	HALFWORD IN DESTINATION BUFFER
	SLLS	R1,3			:NUMBER OF HALFWORDS * 8
	SIS	R1,1			:	MINUS 1
	COPY	R7,R1			:COPY THE DATAF			 ###%cc
	LR	R0,LN			:GET LINE NUMBER
	SRHLS	R0,1
	SBT	R0,LNGREC		:NOTE GOOD REC REC'D ON LINE
	
SIOI55	LB	R3,LKNM,KD		:GET LINK NUMBER
	STH	R2,RECN,R6		:GIVE RECORD TO SECTOR
	SBT	R3,LKTEAR		:"SCHEDULE RTD
	SBT	R3,LKGREC		:NOTE GOOD REC ON LINK
SQIO66	LIS	R0,1			:BUMP COUNT OF GOOD
	AHM	R0,RCRCVD,LN		:	RECS RECEIVED ON THIS LINE

SIOI15	NHI	R2,PKTMSZ		:MASK REC NUMBER WITH BUFFER SIZE
	AR	R2,R2			:FORM HW INDEX
	LHL	R0,FASTC+2,,		:GET CURRENT TIME
	STH	R0,INTIME,KD,R2		:RECORD TIME OF PACKET ARRIVAL
	LH	R2,SIBUF+2,R11,R13	:UPDATE LAST ACK RECEIVED
SI152	LHL	R1,LAR,KD		:GET LAST ACKNOWLEDGEMENT
	SR	R2,R1			:IS NEW ACKNOLWEDGMENT
	LBR	R2,R2			:	WITHIN THE ALLOWABLE
	CLB	R2,WSIZ,KD		:	WINDOW SIZE?
	JG	SIOI5A			:NO, INC ERROR COUNTER
	AHM	R2,LAR,KD		:YES UPDATE LAR

SIOI16	HS	0
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB16			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	LHL	R2,RECN,R6		:GET RECORD NUMBER
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LHI	R0,TS.REC
	STB	R0,TSFTBL,R15		:STORE EVENT (GOOD RECORD RECEIVED )
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB16	EI	:TSTSZE

	J	SIOI2

SIOI5A	LB	R0,NLAT,KD		:TEST FOR MULTI-LINE LINK -- BAD ACKS
	CLHI	R0,1			: CAN OCCUR DUE TO SHORTER PACKET
	JNFS	SIOI5B			: OVERTAKING PRIOR TRANSMISSION
					: - DON'T COUNT IT...
	AHM	R0,BADACK,LN

SIOI5B	IF	TSTSZE			:IF SYNC EVENT TRACE ENABLED
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:TEST FOR LINK OF INTEREST
	JN	TSLB20			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BAK
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD ACK)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER 
	LR	R1,R15			:SAVE INDEX REGISTER AND
	L	R15,TSRSVE		:	RESTORE R15 (KD)
	LH	R0,LAR,KD		:GET LAST ACK RECEIVED AND
	STB	R0,TSFTBL+4,R1		:	STORE IN EVENT ENTRY	###OAS
	LIS	R0,0			:PROVIDE OPPORTUNITY TO PATCH
	LHL	R0,TSLINK		:THIS 'LHL' TO A 'STH' TO TERMINATE
					: TRACING AND EXAMINE HISTORY
					: PRIOR TO BAD ACK OCCURRENCE.  
TSLB20	EI	:TSTSZE
	J	SIOI2

:	this is sort of RTEAR.  All that is done is to call RTD for
:	a packet but the packet is torn from the sio input buffer instead
:	of copying it somewhere else and making rtear figure out there is
:	a packet waiting.  besides cutting down delays it requires less
:	cpu.

siortd  hs      0			:move it straight from SIO input
	LR	R0,LN			:GET LINE NUMBER
	SRLS	R0,1
	SBT	R0,LNGREC		:NOTE GOOD REC REC'D ON LINE
	
	STH	R2,RECN,R6		:GIVE RECORD TO SECTOR
	LIS	R0,1			:BUMP COUNT OF GOOD
	AHM	R0,RCRCVD,LN		:	RECS RECEIVED ON THIS LINE

	LH	R2,SIBUF+2,R11,R13	:UPDATE LAST ACK RECEIVED
	LHL	R3,LAR,KD		:GET LAST ACKNOWLEDGEMENT
	SR	R2,R3			:IS NEW ACKNOLWEDGMENT
	LBR	R2,R2			:	WITHIN THE ALLOWABLE
	CLB	R2,WSIZ,KD		:	WINDOW SIZE?
	JG	SIOI5A			:NO, INC ERROR COUNTER
	AHM	R2,LAR,KD		:YES UPDATE LAR

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	srtd10			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	LHL	R2,RECN,R6		:GET RECORD NUMBER
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LHI	R0,TS.REC
	STB	R0,TSFTBL,R15		:STORE EVENT (GOOD RECORD RECEIVED )
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
srtd10	EI	:TSTSZE

	stm	r10,srtdsv
	la      prd,sibuf+5,r11,r13     :address within siobuffer of data
	lb      kn,lknm,kd
	TBT	KN,BORZAP		:IS LINK AWAITING BORI ZAP?
:       borzap inverted by sdw
	Je	srtdex			:don't tear packets for this link
	SBT	kn,LKGREC		:NOTE GOOD REC ON LINK
	st      prd,srtdsp		:save start of data for trace cmd
	lr      prc,r1  		:make regs what they should be
	lr      cd,r6
	AIS	PRC,4			:INCLUDE CHECKSUM AND COUNT
	AM	PRC,KS.PCI,KD		:COUNT PACKET CHARACTERS INPUT
	SIS	PRC,7			:DON'T INCLUDE CHECKSUM, HEADER FOR RTD

:	> > > > > > > > > > > > > > > > >
	JAL	R9,RTD			: go tear down
	GL	RTD
:	< < < < < < < < < < < < < < < < <

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND 
	CLH	R0,TSLINK		: TEST FOR LINK OF INTEREST
	JN	srtdRT			:NO - CONTINUE
	JAL	R8,TSBMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RTD		:GET EVENT TYPE (RECORD TORN)
	STB	R0,TSBTBL,R7		: AND STORE IN ENTRY
	l	r8,srtdsp		: get back prd (+3) of start
	sis	r8,3
	LHL	R0,0,R8		:GET HEADER HALFWORD
	STH	R0,TSBTBL+2,R7		: AND STORE
	LB	R0,2,R8
	STB	R0,TSBTBL+4,R7		:THIRD BYTE RECORD NUMBER
	LHL	R0,LAS,KD
	STB	R0,TSBTBL+1,R7		:STORE LAST ACK SENT
srtdRT	EI	:TSTSZE
	LHL	R1,RLNK,CD		:INDEX NRTR
	STH	R1,NRTR,KD
	lh	r0,lrt,kd		:inc record count
	ais	r0,1
	sth	r0,lrt,kd
	lhr	r0,r0			:see if next record already there
	clh	r0,recn,r1		:next there?
	jnfs    srtd20  		:nope
	sbt     kn,lktear		:yes
srtd20

	LHL	R0,SQUEUE
	THI	R0,1F-PCKZB		:buffer zap pending?
	JEfs    srtdex
	JAL	R0,EXYLD		:go do bufzap
srtdex  lm	r10,srtdsv		:restore registers
	j       sioi2			:and continue


:	NOTE RETRANSMISSION

SIOI6	LR	R0,LN
	SRHLS	R0,1			:GET TRUE LINE NUMBER
	SBT	R0,LNGREC		:NOTE GOOD REC RECVD ON LINE
					:ADDED 10/30/83 OMAR
	LIS	R0,1			:INC RETRANSMISSION COUNTER
	AHM	R0,RCRXMT,LN
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB13			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RXC
	STB	R0,TSFTBL,R15		:STORE ENTRY TYPE
	STH	R4,TSFTBL+2,R15		:STORE FIRST 2 BYTES OF HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB13	EI	:TSTSZE


	J	SIOI15			:GO UPDATE LAR

:	RECORD WITH BAD BORI RECEIVED ON ASSIGNED LINE
:	CHECK IT OUT

SIOI7	HS	0
	NHI	R4,0F0EF		:mask out 'count code', 'subseq' bit
SIOI73	CLHI	R4,TTRSHD		:IS THIS ANY KIND OF TYMNET-II RESET?
	JE	SILRAL			:YES, GO TREAT IT
::Get full word header preserved in R4
SIOI74	L	R4,SIBUF+2,R11,R13	:GET FULL WORD
	CLI	R4,TWDMHD		:DUMMY RECORD?
	JN	SIOI8			:NO, ERROR
:	DUMMY RECEIVED ON ATTACHED LINE	
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR TRACING DESIRED
	JNFS	TSLB12			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:MAKE NEW EVENT ENTRY
	LIS	R0,TS.DUM
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE
	LIS	R0,0
	STH	R0,TSFTBL+2,R15		:NO DATA FOR HEADER FIELD
	L	R15,TSRSVE		:RESTORE R15
TSLB12	EI	:TSTSZE
	LR	R0,LN			:GET LINE NUMBER
	SRHLS	R0,1			:NOTE GOOD REC REC'D ON LINE
	SBT	R0,LNGREC
	J	SIOI2			:DONE

:	GARBAGE RECEIVED ON ATTACHED LINE -- NOTE LINE ERROR

SIOI8	LIS	R0,1			:INC CONTER
	AHM	R0,LINERR,LN
	J	SIOI2

:	RESET RECEIVED ON ATTACHED LINE -- HANDLE IT

SILRAL	HS	0
:	FOR TYMSTAR, STAR LINE AND FIRST STAR LINK IS UP ALREADY, RECEIVED
:	RESET PATTERN FOR OTHER STAR LINKS.

	LR	R1,LN
	SRHLS	R1,1			:GET LINE NUMBER
	TBT	R1,INHRST		:RESET INHIBITED?
	JN	SIOI2			:YES, IGNORE IT

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB19			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RST
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (RESET RECEIVED)
	L	R0,SIBUF+2,R11,R13	: GET 4 BYTES OF RESET AND
SILRA2	ST	R0,TSFTBL+2,R15		: STORE (CLOBBER HI-ORDER HW OF FASTC)
	AIS	R15,TSESZE
	NHI	R15,TSTSZE-1		:ADVANCE TO NEXT ENTRY AND CLEAR
	LIS	R0,0			:	IT TO EASE FINDING END OF
	ST	R0,TSFTBL,R15		:	TRACE HISTORY
	ST	R0,TSFTBL+4,R15
	STH	R0,TSLINK		:INHIBIT FURTHER TRACING
	L	R15,TSRSVE

	JAL	R8,TSNSPK		:SAVE MOST RECENT PACKETS IN AND OUT

TSLB19	EI	:TSTSZE

	LCS	R0,1		
	ST	R0,KDLN,LN,LN		:PUT LINE IN LIMBO
	LHI	R0,SIOIDL-SEG1		:TURN OFF OUTPUT
	STH	R0,SIOTST,LN
SIRS4
	SBT	R1,LINDET		:TELL LINKER TO DETACH
	LIS	R0,3
	STB	R0,DREASN,R1		:SET DETACH REASON
	LHI	R0,1F-PLINKR		:AND 'SCHEDULE' LINKER
	SBT	R0,TLINKR
	J	SIOI2			:DONE

:	DATA RECEIVED ON UNASSIGNED LINE -- CHECK FOR RESET
SILUAL	HS	0


	IF	TSTSZE
	JAL	R2,TSFUAL		:IS THIS LINE OF INTEREST?
	EI	:TSTSZE
	AIS	KD,1			:IF LINK ADDRESS = -1, FORGET
	JE	SIOI2			:	IT. LINK STILL IN DETACH
	LR	R2,LN			:GET LINE NUMBER
	SRHLS	R2,1
	TBT	R2,INHRST		:RESET INHIBITED?
	JN	SIOI2			:YES, IGNORE THIS
CPRSBF	L	R5,SDLN,LN,LN		:GET RESET BUFFER ADDRESS
	NHI	R4,0FFE0		:MASK OUT 'subseq' bit and count###wjl
	CLHI	R4,TXRSHD		:Is it an Expanded reset?
	JN	SILU02			:no, check for old T-II Reset
SILU01	AHI	R5,VSDSZ-2		:address of last destination HW to R1+1
	LA	R4,(SIBUF+2)+(VSDSZ-2),R11,R13 :address of last source HW to R1
SILU2	LHI	R1,10*((VSDSZ/2)-1)	:10*(number of HW'S -1)
	COPY	R4,R1			:copy Reset from temporary storage
	J	SILU04

SILU02	CLHI	R4,TTRSHD		:IS IT A T-II RESET?		###wjl
	JN	SIOI2			:NO, FORGET IT
	L	R4,SIBUF+2,R11,R13	:GET FIRST FULLWORD OF RECORD
	ST	R4,VRSTP,R5		:SAVE FOR LINKER
	L	R0,SIBUF+6,R11,R13	:NEXT FULLWORD MAY CONTAIN 
SILU22	ST	R0,VRSTP+4,R5		:	NEIGHBOR VERSION NUMBER

SILU04	SBT	R2,VRSTDL		:TELL LINKER TO LOOK AT IT
	SBT	R2,LINATT
	LHI	R0,1F-PLINKR		:SCHEDULE LINKER
	SBT	R0,TLINKR
	J	SIOI2			:DONE

:	DOWNLINE LOAD ON SIO LINE

SIODWL
	LHL	R0,SIBUF+2,R11,R13	:FIRST HALFWORD OF DATA
	LIS	R6,1
	AHM	R6,DWLCLI
	CLHI	R0,DWNLHD		:DWL HEADER?
	JN	SIOI2			:NO, IGNORE THE RECORD (GARBAGE?)
SIDCM2	LHI	R5,42
SIDCMP	CR	R10,R5			:CORRECT BYTE COUNT?
	JN	SIOI2			:NO, IGNORE THE RECORD (GARBAGE?)
	LH	R6,DWTEST		:TEST DWLIN SEMAPHORE
	JL	SIOI2			:<0 MEANS DWLIN IS USING SQUEUE
	LIS	R1,0
SIODW1	CLH	LN,DWLNUM,R1		:FIND THE INTERNAL HOST CHANNEL INDEX
	JEFS	SIODW2
	AIS	R1,2
	CLHI	R1,TINTCH*2
	JLBS	SIODW1
SIODW2	LH	R6,DWBUSY,R1		:TEST BUFFER BUSY FLAG
	JL	SIOI2			:<0 MEANS DWLIN IS USING DWIBUF
	LR	R5,R1			:NONE OF ABOVE, SO ALL CLEAR. FORM
	SLLS	R5,5			:DWIBUF OFFSET (64 x R1)
	LA	R2,SIBUF+42,R11,R13	:LAST SOURCE HALFWORD
SIDW22	LA	R3,DWIBUF+40-2,R5,	:LAST DESTINATION HALFWORD
	LHI	R4,1F0			:HALFWORD COUNT=(20 - 1) x 10
	COPY	R2,R4			:				###%cc
	LHI	R0,-1000		:MARK DWIBUF FULL
	STH	R0,DWBUSY,R1		:BY SETTING DWBUSY NEGATIVE
	SRLS	R1,1
	SBT	R1,DWQUEU		:TELL DWLIN THERE IS A RECORD HERE
	LHI	R0,01F-PDWLIN
	SBT	R0,SQUEUE		:SCHEDULE DWLIN
	J	SIOI2			:AND RETURN




	SUBTTL	LINKER (SIO M-board report routines)


::*********************************************************************
::
::	SUBROUTINE:	SIOBZY:
::	FUNCTION:	M-BOARD TIMEOUT. GENERATE A SUP REPORT AND CRYPTO
::			MESSAGE AND RETURN.
::	CALLING SEQ:	JAL	R12,SVCExx
::	INPUT:		DIFFERENT SVC'S ARE DISTINGUISHED BY THE VALUE IN R8
::	PRESERVED:	All registers
::	CALLS:		JAL	R9,NETDGN
::
::*********************************************************************

SIOBZS	LIS	R8,DR.SZS		:GET MESSAGE TYPE - INDICATE SVC STATUS
	JFS	SIOBZY
SIOBZO	LIS	R8,DR.SZO		:...OUTPUT
	JFS	SIOBZY
SIOBZI	LIS	R8,DR.SZI		:...INPUT
	JFS	SIOBZY
SIOBZC	LIS	R8,DR.SZC		:...CONNECT

SIOBZY	STM	R0,SBZSAV		:SAVE OFF REGISTERS (ESPECIALLY R9)
	LHL	R2,NGSVLN,LN		:NEIGHBOR LAST ATTACHED TO THIS LINE
	STH	R2,SUPMBF+4
	SRLS	R14,1			:TRUE LINE NUMBER
	STB	R14,SUPMBF+3
	JAL	R9,NETDGN,,		:MAKE REPORT TO SUP AND XRAY
	GL	NETDGN
	LM	R0,SBZSAV		:RECOVER REGISTERS
	JR	R12			:RETURN TO CALLER

::*********************************************************************
::
::	SUBROUTINE:	SIOXXX:
::	FUNCTION:	MBOARD RC=4, ERROR. MAKE CRYPTO REPORT TO XRAY.
::	CALLING SEQ:	JAL	R12,SVCExx
::	INPUT:		LN  = R14
::	CALLS:		JAL	R8,CRYPTO
::			HC	CRYE70
::	###OAS 3/83
::*********************************************************************

SIOXXX	LR	R2,LN			:LINE NUMBER			###OAS
	SLLS	R2,0F			:IN HO HW			###OAS
	LHL	R8,NGSVLN,LN		:NEIGHBOR NUMBER		###OAS
SIOX2	OR	R2,R8			:IN LO HW			###OAS
	ST	R2,CRYSBF		:STORE FOR CRYPTOGRAM		###OAS
	JAL	R8,CRYPTO		:SIO ERROR			###OAS
	HC	CRYE70			:				###OAS
	JR	R12			:RETURN TO SVC CALLER		###OAS

      EI	:SILINS			:SIO input

	SUBTTL	LINKER (SYLVER - SIO output processor)

::*********************************************************************
::
::	Jump here from INTSIO routine when get interrupt 0A.
::	THIS CODE IS NOT USED, PART OF NEW SIO I/O COMPLETE INTERRUPT.
::	INTERRUPT-LEVEL SIO OUTPUT ROUTINES.
::
::	**Note: if ,AD68 is on, LPSW is not applicable, so for the time 
::		being, I assume this routine will not be called,
::		since in fact in normal engine no caller exists.
::		--cwc 2/14/88
::
::*********************************************************************
	if	1-NAD68
	IF	SILINS

SINTPC	WC	0,0			:SAVE AREA FOR INTERRUPT PC AND PSW

SRESET	LH	R1,FASTC+2,,		:READ LOW ORDER HW OF CURRENT TIME
	SH	R1,LNRTIM,LN		:CALCULATE TIME SINCE OUTPUT STARTED
	LHR	R1,R1			:EXTEND SIGN BIT THROUGH FULL WORD
	LIS	R2,1			:PREPARE FOR SLOWEST POSSIBLE LINE
	CLHI	R1,0C4			:IF OVER C4 TICKS, 2.4KB
	JGEFS	SRESE4
	LB	R2,SIOSPD,R1		:LOOK UP LINE SPEED
SRESE4	STH	R2,BAUDRT,LN		:AND SAVE IT IN BAUDRT
	LPSW	SINTPC			:RETURN TO INTERRUPT ROUTINE

	EI	:SILINS
	EI	:not nad68		:addr at SINTPC			###%cc

::*********************************************************************
::
::	ROUTINE:	SIOUT:
::	FUNCTION:	OUTPUT HANDLER ROUTINES FOR ALL SIO LINES
::	CALLING SEQ:	JUMP HERE FROM SYLRTX (PART OF SYLVER LOOP)
::			WHEN BYTE COUNT NEGATIVE.
::	CALLS:		DISPATCH TO APPROPRIATE OUTPUT ROUTINE.
::			EACH SIO LINE'S OUTPUT STATE IS DEFINED BY THE
::			ROUTINE WHOSE ADDRESS IS STORED AT 'SIOTST'.
::
::	THE POSSIBLE OUTPUT STATES ARE:
::
::	SIOIDL	-- IDLE (GO IMMEDIATELY TO NEXT LINE)
::	SIOTT	-- LOOKING FOR A RECORD TO SEND
::	SION	-- SENDING ONE RECORD -- LOOKING FOR ANOTHER TO CHAIN IN
::	SIOC	-- WAITING FOR SUCCESS OR FAILURE OF CHAINING
::	SIORR	-- SEND REPEATED RESETS TO MAKE NEIGHBOR AWARE OF PRESENCE
::	SIORS	-- SEND SINGLE RESET FOR RESET SEQ AND SPEED CLOCKING	
::	SIORT	-- CLOCK IN THE LINE SPEED PATTERN AND GO TO SIOIDL	
::
::	RETURNS:	DISMISS SYLVER TO ISIS OR SOLO EXEC LOOP
::
::*********************************************************************
SIOUT	HS	0			:			###GT  ###LSH
	ST	R10,DSSVRT		:save caller
SIOO01  la	r0,2*((nlines-1)/8)+linsvd
	lr	r1,r0
	lhi     ln,(((nlines*2-2)/10)*10)!0f
	arand   r0,ln			:find an unservied line
	jfs     sioo02
	l	r10,dssvrt
	jr	r10
sioo02  rbt     ln,linsvd
	TS      SIOROS  		:handle if first sio line is dead

:	REGULAR SIO LINE OUTPUT, OR STARLINE OUTPUT TO SERVE AN STARLINK
:	EACH TIME.
:	SIOTST IS OUTPUT STATE FOR REGULAR LINE, OR FOR STARLINE BEFORE
:	LINE IS ATTACHED
:
SO22	TS      SIOROL  		:init as not switching multiline###sdw
	LR	R0,LN			:test if SIO line is alive
	SRLS	R0,1
	TBT	R0,SIOPTA		:if set then no can issue output svcs
	JN      SIOIDL  		:				###sdw
	LHL	R1,SIOTST,LN		:GET ROUTINE ADDRESS	###LSH
	J	SEG1,R1,,		:GO TO IT

::*********************************************************************
::
::	OUTPUT STATE:	SIOTT -	LOOKING FOR INITIAL RECORD TO SEND
::
::*********************************************************************

SIOTT	lis	r8,0			:only do this line
	lr	r5,ln			:set up for ccwe.a
	l	kd,kdln,ln,ln
	jal	r9,ccwe.a		:return CCWs (non link entry)
	j       sioidl  		:no free ccws
	la	r9,sioidl		:exit for this entry
:	ccwdum is alternate entry to sent dummy, return on R9
	lr	r4,kd			:get link desc
	ts      idle,r4
	rbt     ln,ssent		:check if need to sent dummy
	jer	r9			:nope, exit
ccwdum  st	r9,ccwdsv		:save return
	lb	r1,siofb,ln
	clb	r1,siotb,ln		:if any still sending
	jnr	r9			:then don't send
	a	r1,siobla,ln,ln 	:get address
	sth     ln,lnidle,r4		:link has a line sending
       if	silins
	clhi    ln,(nlines-silins)*2
	jl      siot14
	LHI	R5,SIODUM/10		:MAKE CCW POINT TO DUMMY
	GL	SIODUM
	STH	R5,2,R1			:###LSH
	J	SIOT4			:START OUTPUT
      EI	:SILINS

:	dummy record on a sync line, put address of dummy record (copied
:	to same block of contigious memory as sync rotor) into the rotor and
:	then jump to the sync SVC stuff.				###sdw

SIOT14	LA	R5,SYNDUM,,		:get address of sync dummy record
	ST	R5,4,R1			:write it to rotor
	LHI	R5,SYDUMZ		:size of dummy record
	STH	R5,2,R1
:	Do Sync Line Output

SIOT3S	LIS	R0,0			:put stop after command
	STH	R0,8,R1			:clear the jump rotor
	LIS	R0,1			:make an output command
	STH	R0,0,R1			:store it into rotor
siot34	LR	R0,LN
	SRLS	R0,1			:do force output SVC
	SVC	IO,20+R0
	JAL	R0,SVCE32		:error handler
	J	SIOPT4			:rejoin mutual code	

:	WRITE OUTPUT PROGRAM INTO LINE'S CCW BLOCK 
:	(SEE DEVICE.DOC SEC 1.3.3 FOR DESCRIPTION OF CHANNEL PROGRAMS)

SIOT4
      IF	SILINS			:only for SIO lines
	LIS	R0,0			:MAKE A STOP COMMAND
	STH	R0,4,R1			:PUT IT AFTER OUTPUT COMMAND
	LIS	R0,1			:MAKE AN OUTPUT COMMAND
	STH	R0,0,R1			:AND STORE IT

:	START OUTPUT CCW PROGRAM
siot38	LR	R0,LN			:LINE NUMBER * 2
	SRLS	R0,1			:LINE NUMBER
	SVC	IO,0B0			:START OUTPUT
	JAL	R12,SVCE3B		:ERROR, CRSH
      EI	:SILINS

:	common logic for both sync and SIO lines.  For multline links
:	update the queue of next line to service.  For all lines update
:	the output status, and update the pointer to the next free
:	rotor/CCW.							###asq

SIOPT4	HS	0
       if	multln
	JAL	R10,BSIOTR		:update pointer to next line    ###sdw
       ei 	:multln

	LB	R5,SIOFB,LN		:bump up free port
	AHI	R5,10			:point to next CCW
	CLH	R5,SIONCB,LN		:wrap?
	JLFS    SIOT60
	LIS	R5,0
SIOT60  STB	R5,SIOFB,LN		:and fall through to try to send more
	l	r9,ccwdsv
	jr	r9			:done, return

:	ccwsnd  send packet (called from rmake)

ccwsnd
	lhl	r5,rmlnsv		:get line number
	sth	r5,lnidle,kd		:link has a line sending stuff
	lb	r1,siofb,r5
	a	r1,siobla,r5,r5 	:get output ccw address
	l	r2,brec,cd
	L	R7,EREC,CD		:GET RECORD BYTE COUNT BY SUBTRACTING
	SR	R7,R2			:length (end-beg)

      IF	SILINS			:check is to do SIO lines
	CLHI	R5,(NLINES-SILINS)*2	:sio line?
	JGE	ccws10			:yes
      EI	:SILINS

:	sync line, first put ack into record then do checksum, the put
:	address and length of record into rotor, then jump to common 
:	statistics area.

	LHL	R3,LRT,kd		:put ack into packet
	STH	R3,LAS,kd		:remember that we sent it
	STB	R3,1,R2			:second byte is ack

:	sync line, write length and address to rotor
	ST	R2,4,R1			:save address of data
	AIS	R7,4			:include size of checksum
	STH	R7,2,R1			:store length including cksum
	SIS	R7,4			:back to length of packet

:	sync line, do checksum
	LR	R6,R2			:make copy of start of packet
	LIS	R2,0			:clear accumulators
	LIS	R3,0			:clear accumulators
	LIS	R0,0
	SR	R0,R7			:negative count for microcode

:	the checksum instruction updates the source register every 32
:	halfwords or so. (if current address ANDed with 3E is 0 then
:	address register is updated). so save start address in R6.
	LR	R8,R6			:make copy of start for checksum
	CKSUM	R2,R8			:calculate checksum
	STH	R2,0,R7,R6		:save vertical checksum
	STH	R3,2,R7,R6		:save horizontal checksum

:	Do Sync Line Output

	LIS	R0,0			:put stop after command
	STH	R0,8,R1			:clear the jump rotor
	LIS	R0,1			:make an output command
	STH	R0,0,R1			:store it into rotor
	lb	r3,siofb,r5
	clb	r3,siotb,r5
	jefs    ccws34
	shi	r3,10
	jgefs   ccws35
	ah	r3,sioncb,r5
ccws35  lis	r0,2
	a	r3,siobla,r5,r5
	sth	r0,8,r3 		:do a jump command to previous ccw
	j       ccws60
ccws34	LR	R0,r5
	SRLS	R0,1			:do force output SVC
	SVC	IO,20+R0
	JAL	R0,SVCE32		:error handler
	J	ccws60			:common statistics area

      IF	SILINS

ccws10  sis	r2,2			:SOURCE ADDRESS
	LR	R3,R2
	SRLS	R3,4			:SHIFT 4 BITS RIGHT FOR SIO CCW
	STH	R3,2,R1 		:put address/10 into the CCW

	STH	R7,0,R2 		:STORE BYTE COUNT       ###LSH

	LH	R3,LRT,kd		:UPDATE LAS
	STH	R3,LAS,kd
	STB	R3,3,R2 		:PUT ACK IN OUTPUT RECORD

:	WRITE OUTPUT PROGRAM INTO LINE'S CCW BLOCK 
:	(SEE DEVICE.DOC SEC 1.3.3 FOR DESCRIPTION OF CHANNEL PROGRAMS)

	LIS	R0,0			:MAKE A STOP COMMAND
	STH	R0,4,R1			:PUT IT AFTER OUTPUT COMMAND
	LIS	R0,1			:MAKE AN OUTPUT COMMAND
	STH	R0,0,R1			:AND STORE IT
	lb	r3,siofb,r5
	clb	r3,siotb,r5
	jefs    ccws45  	:not a chain
	shi	r3,10
	jgefs   ccws43
	ah	r3,sioncb,r5
ccws43  lis	r0,2
	a	r3,siobla,r5,r5
	sth	r0,4,r3 		:do a jump command to previous ccw
	jfs     ccws60

:	START OUTPUT CCW PROGRAM
ccws45	LR	R0,r5			:LINE NUMBER * 2
	SRLS	R0,1			:LINE NUMBER
	SVC	IO,0B0			:START OUTPUT
	JAL	R12,SVCE3B		:ERROR, CRSH

      EI	:SILINS

:	sync and SIO common statistics and bookkeeping
:	common logic for both sync and SIO lines.  For multline links
ccws60  lb	r3,siofb,r5
	ahi	r3,10			:update pointerto free ccw
	clh	r3,sioncb,r5
	jlfs    ccws62
	lis	r3,0
ccws62  stb	r3,siofb,r5
       if	multln  		:multi line code
	lb	r3,sioror,kd    
	ais	r3,1
	clb	r3,nlat,kd
	jlfs    ccws64
	lis	r3,0
ccws64  stb	r3,sioror,kd		:line rotation
       ei 	:multln
	lis	r3,1
	ahm	r3,rctrns,r5		:another packet sent
	stb	r3,llxm,cd		:mark packet as sent
	rbt	r5,ssent		:don't have to send dummy
	rbt	r5,sdumm
	jr	r9


:	have wrapped around to start of window and have to retransmit

ccwrtr  lr      ln,r5
	tbt	r5,sionog
	jnr	r9			:line not free
	lb      r5,siofb,ln
	clb     r5,siotb,ln     	:line already transmitting?
	jnr     r9
	st	r9,ccwdsv
	LHL	R5,NRmk,KD		:DESCRIPTOR ADDR OF NEXT REC TO XMIT

:	frequently we sent a retransmissio due to closing the window and
:	having a neighbor which is slow to ack so give slight pause between
:	closing the window and resending the packet since takes real time
:	to send a packet so make sure it has to be done before doing it.###sdw
	SBT     KN,SIOBTR		:set retransmission bit 	###sdw
	JEFS    ccwrt1  		:previous wasn't retransmission ###sdw
	L	R10,SIOBTT,kd		:get time to send next retr     ###sdw
	s	r10,fastc,,		:get current time       	###sdw
	jgr	r9			:no, wait until time    	###sdw

ccwrt1  L	R10,FASTC,,		:get current time       	###sdw
	ah      r10,rtrdel,ln		:make sure other line finished outtput
					:before sending another rxmission
					:and just a good pacing rate
	ST	R10,SIOBTT,kd		:save time to do retransmission ###sdw
	LIS	R7,1			:YES - COUNT RETRANSMISSIONS
	AHM	R7,TRRXMT,LN		:	BY LINE

	lb	r1,siofb,ln		:get address of CCW
	a	r1,siobla,ln,ln
	sth     ln,lnidle,kd		:link has a line sending stuff
	lr	r4,kd			:for usage
	JAL	R10,SIOSND		:START OUTPUTTING THE RECORD
	clhi    ln,(nlines-silins)*2
	jl      siot3s  		:send it on the sync line
	j       siot4			:sent it to the sio line

	DEFAULT(RTRPAC,RATE/$A13) 	:wait 13th between retransmissions#sdw
rtrwat  hc      0       		:line speed 0 is of a down neighbor
q       eq      0
	re      1f      		:number of line speeds
q       eq      q+1     		:avoid the 0 case
       if	(12c/q)-rtrpac  	:use time to send if bigger than defaul
	hc      (12c/q)
       else
	hc      rtrpac
       ei
      er
	syad(RTRWAT)

::*********************************************************************
::
::	SUBROUTINE:	SIOSND:
::	FUNCTION: SIO lines:	ROUTINE TO SET UP TO TRANSMIT A DATA RECORD.
::			MOVES IT FROM THE SECTOR TO AN OUTPUT BUFFER.
::			SETS UP THE APPROPRIATE HEADER, CALCULATES CHECKSUMS,
::			AND UPDATES LAS IN THE LINK DESCRIPTOR.
::		  SYNC lines:	Routine to set up to transmit a data record.
::			Put ack into packet, do checksum, write len and
:			address into rotor do mutual link/line statistics.
::	CALLING SEQ:	JAL	R10,SIOSND
::	INPUT:		R1 = POINTER TO rotor/CCW BLOCK TO OUTPUT NEXT RECORD
::			R5 = POINTER TO RECORD DESCRIPTOR
::
::*********************************************************************

SIOSND	HS	0
	L	R7,EREC,R5		:GET RECORD BYTE COUNT BY SUBTRACTING
	L	R2,BREC,R5		:BEGINNING POINTER 
	SR	R7,R2			:length (end-beg)

      IF	SILINS			:check is to do SIO lines
	CLHI	LN,(NLINES-SILINS)*2	:sio line?
	JGE	SIOSN1			:yes
      EI	:SILINS

:	sync line, first put ack into record then do checksum, the put
:	address and length of record into rotor, then jump to common 
:	statistics area.

	LHL	R3,LRT,kd		:put ack into packet
	STH	R3,LAS,kd		:remember that we sent it
	STB	R3,1,R2			:second byte is ack

:	sync line, write length and address to rotor
	ST	R2,4,R1			:save address of data
	AIS	R7,4			:include size of checksum
	STH	R7,2,R1			:store length including cksum
	SIS	R7,4			:back to length of packet

:	sync line, do checksum
	LR	R6,R2			:make copy of start of packet
	LIS	R2,0			:clear accumulators
	LIS	R3,0			:clear accumulators
	LIS	R0,0
	SR	R0,R7			:negative count for microcode

:	the checksum instruction updates the source register every 32
:	halfwords or so. (if current address ANDed with 3E is 0 then
:	address register is updated). so save start address in R6.
	LR	R8,R6			:make copy of start for checksum
	CKSUM	R2,R8			:calculate checksum
	STH	R2,0,R7,R6		:save vertical checksum
	STH	R3,2,R7,R6		:save horizontal checksum
	J	SIOHS2			:common statistics area

      IF	SILINS

SIOSN1  sis	r2,2			:SOURCE ADDRESS
	LR	R3,R2
	SRLS	R3,4			:SHIFT 4 BITS RIGHT FOR SIO CCW
	STH	R3,2,R1 		:put address/10 into the CCW

	STH	R7,0,R2 		:STORE BYTE COUNT       ###LSH

	LH	R9,LRT,kd		:UPDATE LAS
	STH	R9,LAS,kd
	STB	R9,3,R2 		:PUT ACK IN OUTPUT RECORD
      EI	:SILINS

:	sync and SIO common statistics and bookkeeping

SIOHS2	RBT	LN,SSENT		:NOTE A RECORD IS SENT
	LIS	R0,1			:MARK RECORD AS BEING SENT
	STB	R0,LLXM,R5		
	AHM	R0,RCTRNS,LN		:UPDATE NUMBER OF RECORDS SENT
:	R3 gets record number, R4 has link descriptor pointer		###jhl
	LHL	R3,RECN,R5		:get record # from frame to be sent
	NHI	R3,PKTMSZ		:FORM INDEX INTO PACKET TIME TABLE
	AR	R3,R3			:AND FORM HW OFFSET
	LH	R7,FASTC+2,,		:GET CURRENT TIME
	LH	R8,PKTTIM,R3,kd		:GET TIME PACKET WAS MADE OR RE-XMITTED
	STH	R7,PKTTIM,R3,kd		:STORE BACK CURRENT TIME
	SR	R7,R8			:COMPUTE TIME IN QUEUE
	JGEFS	SIOS10			:NO WRAP
	AI	R7,10000
SIOS10	AM	R7,KS.PQC,kd		:ADD CURRENT DELAY INTO RUNNING COUNT
					: -- end --			###jhl
	JR	R10			:RETURN TO CALLER


::*********************************************************************
::
::	SUBROUTINE: BSIOTR
::	FUNCTION: updates pointer to next to service on multiline line
::	CALLING SEQ:   R10
::	INPUT: R4 (link descriptor), SIOROR, NLAT
::	OUTPUT: SIOROR points to next line
::
::*********************************************************************

:	BSIOTR - links on r10 and is called from SIOT4 and SION5
BSIOTR	LB	R9,NLAT,R4		:multi line link
	SIS	R9,1
	JER	R10
	LB	R7,SIOROR,R4		:current line #
	AIS	R7,1
	CR	R7,R9			:don't past end of list
	JLEFS   BSIOT2  		:still within list
	LIS	R7,0
BSIOT2  STB	R7,SIOROR,R4		:save pointer
	JR	R10


::*********************************************************************
::
::	SUBROUTINE: BSIOSW
::	FUNCTION: services the next line on the multiline's  rotation
::	CALLING SEQ: R10
::	INPUT: LN, SIOROR, SIOROT, R4 (link descriptor)
::	OUTPUT: returns if not switching line, else goes to state (SIOTST)
::	       of the other line on the multiline sio link.
::								###sdw
::*********************************************************************

BSIOSW	LB	R6,NLAT,R4		:number of attached lines
	SIS	R6,1
	JER	R10			:not multiline
	LB	R5,SIOROR,R4		:pointer within list
	LB	R6,SIOROT,R4,R5 	:next line to send a packet on
	CR	R6,LN			:different line than current?
	JER	R10			:no, nothing special to do

:	section for switch line
	LH	R0,SIOROL		:line already saved?
	JGEFS   BSIOW3  		:yes, don't overwrite
	STH     LN,SIOROL		:save original line
BSIOW3  LR      LN,R6			:other line gets the data
	LHL	R6,SIOTST,LN
	J       SEG1,R6,		:do other line

:	this checks to see if the link has has a line with a free
:	ccw/rotor after returning any ccws/rotors that have completed to
:	the free state
       if	multln  		:this is multi line logic
CCWCHK  LB	R8,NLAT,KD		:get number of attached lines
ccwe.0  LB	R5,SIOROR,KD
	LB	R5,SIOROT,R5,KD 	:get line number
       else     :not supporting multi
CCWCHK  HS      0
CCWE.0  LB      R5,SIOROT,KD    	:just get line number
       ei 	:multln
:	entry with line already in r5 (must enter with r10<1)
ccwe.a  tbt	r5,sionog		:line not being initialized?
	jnr	r9
	rbt	r5,linsvd		:this line was serviced
	lh	r7,lnidle,kd		:was link's line idle?
	jl      4,r9			:yes, so nothing to check
	L	R7,SIOBLA,R5,R5		:start of ccw block
	LB	R6,SIOTB,R5		:transmitting CCW
	CLB	R6,SIOFB,R5		:all full or all empty
	JE	CCWE.F			:check out which of the two
:	here to check a ccw
CCWCH0	LH	R0,0,R6,R7		:status of oldest sending CCW
:	status of 200 (completed) or 100 (completed and jumped) for SIO
:	and status of 0000 (completed) for sync.  Status of 1 if still
:	sending (both SIO and Sync).  Thus, check low byte to see if 
:	this ccw is done.
	LBR	R1,R0			:completed?
	JEFS	CCWCH1			:yes
CCWCHX	STB	R6,SIOTB,R5		:store oldest transmitting CCW
	J	4,r9			:some CCWs are free
:	here to return a CCW which mean we must also check for a chain
CCWCH1  CLHI    R5,(NLINES-SILINS)*2    :is it a sync line
	JGEFS	CCWCH2			:no, an SIO line
	LH	R0,8,R6,R7		:get status of the chain
CCWCH2	AHI	R6,10
	CLH	R6,SIONCB,R5		:rotate back to first CCW?
	JLFS	CCWCH3
	LIS	R6,0
CCWCH3	CLB	R6,SIOFB,R5		:A single or a chain?
	JE	CCWCHX			:single, so done
:	here to check the status of the chain
       if	silins
	CLHI	R5,(NLINES-SILINS)*2
	JL	CCWCSY			:do sync there
	SHI	R0,100			:jump succeeded?
	JE	CCWCH0			:yes, check next ccw
	STB	R6,SIOTB,R5		:did return upto this point
	SRLS	R5,1			:make line# *1
	AR	R6,R7			:address of CCW in r6
	LIS	R0,1
	STH	R0,0,R6			:store jump command
	SVC	IO,0B0+R5		:do output
	JAL	R12,SVCE3B		:crash if bad
	ar	r5,r5			:restore r5
	J	4,R9			:and no more ccws tocheck
       ei 	:silins

:	here to see if a sync chain succeeded
CCWCSY	LR	R0,R0			:see if chain completed
	JE	CCWCH0			:0 is completed
	STB	R6,SIOTB,R5		:did free upto here
	SRLS	R5,1
	AR	R6,R7			:make address
	LIS	R0,1
	STH	R0,0,R6
	SVC	IO,20+R5		:sync output svc
	JAL	R12,SVCE32
	slls    r5,1			:restore r5
	J	4,R9			:and no more ccws to check

:	here if CCW is either full or empty.  Check CCW before current
:	pointer, if it is transmitting then we have a transmitting chain.
:	If it isn't transmitting then either previously we had no output
:	or a complete chain completely unwound.  Either way we have no
:	active CCWs.
CCWE.F	LR	R1,R6
	SHI	R1,10			:get CCW prior to current
	JGEFS	CCWE.1
	AH	R1,SIONCB,R5		:did a negative wrap
CCWE.1	LB	R0,1,R1,R7		:get it's status
	Jnfs	ccwe.4			:not sending, so all idle
       if	multln  		:some more multi line code
	lb	r0,nlat,kd
	sis	r0,1
	jnfs    ccwe.3
       ei 	:multln
	ts      lnidle,kd		:link has no lines sending data
ccwe.3  j       4,r9
ccwe.4	LHL	R0,0,R6,R7		:get status of oldest sending
	LBR	R1,R0			:is it still sending?
	JE	CCWCH1			:unwind the chain
       if	multln  		:code for multi line
	sis	r8,1			:check all lines for this link
	jler    r9
	lb	r5,sioror,kd
	ais	r5,1
	clb	r5,nlat,kd
	jlfs    ccwe.2
	lis	r5,0
ccwe.2  stb	r5,sioror,kd		:try another line
	j       ccwe.0
       else     :only single line links
	jr      r9
       ei 	:multln



::*********************************************************************
::
::	OUTPUT STATE:	SIORT -- WAIT FOR RESET TO FINISH BEING SENT.
::	EACH TIME A PING-PONG RESET IS SENT, IT'S OUTPUT TIME IS
::	IS CLOCKED FOR LINE SPEED CALCULATION.  DUE TO THE POLLING
::	OF SIO FOR OUTPUT COMPLETE (WITHIN THE SYLVER LOOP), THERE
::	ARE ALWAYS OCCURENCES OF LATE OBSERVENCE OF OUTPUT COMPLETE.
::	FOR THE 16d RESETS CLOCKED DURING THE RESET SEQUENCE, THE
::	FASTEST CLOCKED SAMPLE IS USED FOR THE LINE SPEED CALCULATION
::	IN AN ATTEMPT TO SOMEWHAT ALLEVIATE THE INACCURACIES IN
::	CALCULATING LINE SPEEDS OF 28.8 AND GREATER.  NOTE -
::	THIS PROBLEM BECOMES MORE APPARENT ON HEAVILY LOADED NODES.
::	FOR ISIS NODES A FUDGE FACTOR IS INTRODUCED TO ATTEMPT TO OFFSET
::	THE EFFECT OF THE LONG TIME BETWEEN SYLVER (FOREGROUND) EXECUTIONS.
::	ISIS SIO SPEED CLOCKING SHOULD NOT BE SUBJECT TO VARIANCES WITH NODE
::	LOAD DUE TO GUARANTEED FOREGROUND FREQUENCY OF EXECUTION.  THE VALUE
::	OF THE FUDGE FACTOR WAS CHOSEN EMPIRICALLY.
::	Note:  The line attach logic sets this state for both SIO and sync
::	lines.  Sync lines calculate line speed by checking the rate of
::	sync input so sync lines skip over the line speed calculation
::	once previous output of reset packet has completed.  It has to
::	wait for previous output to complete since Line Attach logic
::	checks current state.
::
::*********************************************************************

SIORT	HS	0			:###LSH
      IF	SILINS
	CLHI	LN,(NLINES-SILINS)*2	:sync line speed is done on input
	JGE	SIOR17			:sync line, so skip line speed stuff
      EI	:SILINS
	L	R1,SIOBLA,LN,LN		:see if reset completed trasmitted
	LHL	R0,0,R1
	JN	SIOIDL			:0 is command completed
	J	SIOR19			:done, but skip over line speed stuff
      IF	SILINS
SIOR17	L	R1,SIOBLA,LN,LN 	:CCW address
	LB	R0,0,R1			:STATUS 2 MEANS "FINISHED"
	SIS	R0,2			:IF IT'S NOT A 2 THEN RETURN 
	JN	SIOIDL			:	TO SERVICE NEXT LINE
	LH	R1,FASTC+2,,		:CALCULATE TIME SINCE OUTPUT
	SH	R1,LNRTIM,LN		:WAS STARTED
	LHR	R1,R1			:ADJUST TO HALFWORD VALUE

	JGEFS	SIOR18			:CHECK FOR NEGATIVE INDEX
	LIS	R1,0			:DON'T LET IT GO BELOW 0
SIOR18	HS	0
	LIS	R2,1			:ASSUME SLOWEST SPEED
	CLHI	R1,0C4			:IF RESET TOOK OVER C4 CLOCK TICKS,
	JGEFS	SIOR1C			:IT'S 2.4KB, REPORT VALUE 01
	LB	R2,SIOSPD,R1,		:GET SIO LINE SPEED FROM TABLE
SIOR1C	LHL	R1,BAUDRT,LN		:GET PREVIOUS SPEED CALCULATION
	CLR	R2,R1			:IF NEW CALC IS FASTER, USE IT
	JLEFS	SIOR19			:OTHERWISE LEAVE PREVIOUS CALC
	STH	R2,BAUDRT,LN		:SAVE THE LINE SPEED
      EI	:SILINS
SIOR19	LHI	R0,SIOIDL-SEG1		:GO TO THE IDLE STATE
	STH	R0,SIOTST,LN
	J	SIOIDL

::*********************************************************************
::
::	TABLE:	 SIOSPD - INDEXED BY THE NUMBER OF FASTC CLOCK TICKS
::	TO TRANSMIT A 1000d-BIT RESET PACKET. THE TABLE VALUE IS SAVED
::	IN 'BAUDRT', THE LINE SPEED ARRAY.
::
::		600d/FASTCTICKS = KBS/SEC	
::
::	!! THIS TABLE ASSUMES RATE = $A 600 !!
::
::*********************************************************************

SIOSPD	HS	0
	NOLIST
	RE	0A-00; BC 1F; ER	:00 - 09, MS	 (UP     - 66.6 KB)
	RE	0D-0A; BC 17; ER	:0A - 0C, 56  KB (60  KB - 50   KB)
	RE	10-0D; BC 14; ER	:0D - 0F, 48  KB (46  KB - 40   KB)
	RE	15-10; BC 10; ER	:10 - 14, 38.4KB (37.5KB - 30   KB)
	RE	1C-15; BC 0C; ER	:15 - 1B, 28.8KB (28.5KB - 22.2 KB)
	RE	27-1C; BC 08; ER	:1C - 26, 19.2KB (21.4KB - 15.78KB)
	RE	36-27; BC 06; ER	:27 - 35, 14.4KB (15.0KB - 11.3 KB)
	RE	48-36; BC 04; ER	:36 - 47,  9.6KB (11.1KB - 8.4  KB)
	RE	63-48; BC 03; ER	:48 - 62,  7.2KB ( 8.3KB - 6.1  KB)
	RE	0C4-63; BC 02; ER	:63 - C3,  4.8KB (6.06KB - 3.07 KB)
	RE	0C5-0C4; BC 01; ER	:0C4 - UP, 2.4KB (3.06KB -    DOWN)
	HS	0
	LIST

::**********************************************************************
::
::      OUTPUT STATE:   SIORWT -  waiting for SIO connect input to complete
::      SIORWT  wait give SIO connect output enough time to initialize
::	       After time is up then connect output and restore prior
::		sio state.						###sdw
::**********************************************************************

SIORWT
      IF	SILINS
	L	R0,SIOTIM,LN,LN 	:get time when wait is over
	C	R0,FASTC,,		:to current time		###sdw
	JGE     SIOIDL  		:not yet
       IF	 HMICRO  		:only on HDLC mic can we notice timout
	L	R8,SIOIPG,LN,LN		:address of init prog for this line
	LHL	R4,18,R8		:address of last CCW
	LHI	R0,6			:restore command in init program###sdw
	STH	R0,18,R8
	CLHI	R4,0200			:finish output? 		###sdw
	JE	SIORW2			:connect output successful      ###sdw
	LCS	R8,6			:didn't complete, flag as timout##sdw
	LHI	R3,MSBASE,LN		:back to SIO line number	###sdw
	SLLS	R3,3			:times 8 (now 16*sio line #)    ###sdw
	STH	R8,8,R3			:will be retried in 2 secs      ###sdw
	LR	R0,LN			:get real line #		###sdw
	SRLS	R0,1
	SBT	R0,SIOPTA		:flag port unavailable		###sdw
	JFS	SIORW3			:don't quit since want to restore state
SIORW2	LR	R0,LN			:real line #    		###sdw
	SRLS	R0,1			:from line # * 2 to line #
	RBT	R0,SIOIGN		:let crpypto report reinits     ###sdw
SIORW3
	EI	:HMICRO
	L	R1,SIOIN,LN,LN	:POINT TO INPUT CCW BLOCK ADDRESS
	LR	R0,LN			:have 2*line #  		###sdw
	SRLS	R0,1			:make it real line number       ###sdw
	TBT	R0,SIOPTA	:IS SIO PORT AVAILABLE ?		###OAS
	JNFS	SIORW5		:NO, SKIP SVC
	SVC	IO,0A0		:START INPUT
	JAL	R12,SVCE3A	:ERROR CRASH
SIORW5	HS	0
	LHL	R1,SIOTSV,LN		:restore former state   	###sdw
	STH	R1,SIOTST,LN		:to current state       	###sdw
	rbt     ln,sionog		:line nowusable
      EI	:SILINS
	J       SIOIDL

::**********************************************************************
::
::      OUTPUT STATE:   SYNRWT -  let sync signals DTR and RTS stabilize
::	       before going on with other SVCs.  Restore saved output
::	       state and clear rotor commands.  Note that ISIS does not
::		write 0 indicating that is completed a command if the
::		sync line does not support DTR and DSR so we must clear it.
::									###sdw
::**********************************************************************

SYNRWT  LH	R0,SIOTSV,LN		:get previous state
	STH	R0,SIOTST,LN		:set it as current state
	L	R1,SIOBLA,LN,LN 	:clear any remnants of command
	LIS	R0,0
	STH	R0,0,R1 		:clear command fields
	STH	R0,8,R1
	STH	R0,10,R1
	STH	R0,18,R1		:no leftover garbage to confuse
	rbt     ln,sionog
	J       SIOIDL

::*********************************************************************
::
::	OUTPUT STATE:	SIORS - SEND SINGLE RESET FOR PING-PONG SEQ AND
::				 SPEED CLOCKING
::
::*********************************************************************

SIORS	LHI	R9,SIORT-SEG1		:CHANGE TO SIORT TO CLOCK SPEED
	J	SIOR1			:FINISH PREV OUTPUT, SEND RESET

::*********************************************************************
::
::	OUTPUT STATE:	SIORR - SEND CONTINUOUS STREAM OF RESETS
::
::*********************************************************************

SIORR   LR	R9,LN
	SRLS	R9,R1			:make R9 into line number
	RBT	R9,SIORPC		:bits set every 1 second by G01SEC
	JE      SIOIDL  		:already send reset for this second
	LHI	R9,SIORR-SEG1		:MAINTAIN SAME STATE

::*********************************************************************
::
::	COMMON SIO OUTPUT:
::	WAIT FOR PREVIOUS OUTPUT TO COMPLETE BY DISMISSING TO SIOIDL.
::	WHEN COMPLETE, CHANGE SIO OUTPUT STATE AS INDICATED BY R9 AND
::	START NEW OUTPUT.  ALSO MARK RESET OUTPUT START TIME.
::
::*********************************************************************

SIOR1	HS	0			:###LSH
	L	R1,SIOBLA,LN,LN
	CLHI	LN,(NLINES-SILINS)*2	:SIO or sync line?
	JGE	SIOR4			:SIO line

:	for sync line, make sure previous output has completed before
:	trying to send reset.  Must check the first jump rotor (+8) since
:	line initialization uses it to bring up DSR.			###sdw

	LHL	R0,0,R1			:current output command
	JN	SIOIDL			:not 0, still transmitting
	LHL	R0,8,R1			:for all rotors that might be sending
	JN	SIOIDL
	LHL	R0,10,R1		:and other main ouput rotor
	JN	SIOIDL

:	save caller's desired state and send the reset packet.
	STH	R9,SIOTST,LN		:maybe changing state
	L	R2,SDLN,LN,LN		:get address of reset descriptor
	AHI	R2,XRSTP		:now start of transmitted reset packet
	ST	R2,4,R1			:write address of data to rotor
	LHI	R3,XSDSZ		:how much to transmit
	STH	R3,2,R1			:write length of reset to rotor
	LIS	R3,1			:output command
	STH	R3,0,R1
	LR	R0,LN
	SRLS	R0,1			:got line number * 1
	SVC	IO,20+R0		:force output
	JAL	R0,SVCE32		:error
	J	SIOIDL			:done for now

:	send reset on SIO line if transmitter idle
SIOR4
      IF	SILINS
	LB	R0,0,R1			:CHECK STATUS OF OUTPUT
	JE	SIOIDL			:CURRENT BLOCK IS BUSY
	SIS	R0,1
	JE	SIOIDL			:###wjl
	STH	R9,SIOTST,LN		:MAYBE CHANGE STATE
	L	R2,SIORSP,LN,LN		:QUADWORD PNTR TO RESET PATTERN
	SRLS	R2,4
	EXHR	R2,R2			:STORE BOTH ADDRESS AND
	ST	R2,2,R1			:FOLLOWING STOP COMMAND
SIR12	LIS	R0,1			:SET OUTPUT COMMAND
	STH	R0,0,R1
	LR	R0,LN			:LINE NUMBER * 2
	SRLS	R0,1			:LINE NUMBER
	TBT	R0,SIOPTA		:IS PORT AVAILABLE?		###OAS
	JNFS	SIOPT6			:NO, SKIP SVC
	SVC	IO,0B0			:START OUTPUT
	JAL	R12,SVCE3B		:ERROR, CRASH
SIOPT6	HS	0
	LH	R0,FASTC+2,,		:SAVE TIME FOR SPEED CALCULATION
	STH	R0,LNRTIM,LN
      EI	:SILINS
	JFS	SIOIDL


:	LOOP TIL ALL SIO LINES CHECKED


SIOIDS	LIS	R0,0			:ENTRY POINT IF KS.SEM IS TO BE CLEARED
	STH	R0,KS.SEM,R4		:CLEAR SEMAPHORE WITH SYLVEX

SIOIDL	
	J	SIOO01			:CONTINUE

:	DISMISS SYLVER TO ISIS OR SOLO EXEC LOOP

SDSMIS	HS	0
	if      tii.fg  	:if foreground
	j       sylver  	:goto back and do it again (after a dismiss)
       else     :sylver called from BG
	l	r10,dssvrt
	jr	r10
       ei 	:tii.fg

	SUBTTL	LINKER (SYLVER - Sync input processor)

::*********************************************************************
::
::	ENTRY POINT:	SYLMRK:
::	FUNCTION:	COME HERE TO SEARCH FOR BEGINNING OF FRAME
::	CALLING SEQ:	LHL	R1,QSYLVR,LN
::			J	SEG1,R1,,
::	INPUT:		R11 = INPUT DATA LEAD POINTER
::			R12 = INPUT DATA TRAILING POINTER
::			R13 = INPUT RING ADDRESS
::			R14 = LN = LINE NUMBER * 2
::			R15 = KD = LINK DESCRIPTOR ADDRESS
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R9,NETDGN
::			JAL	R0,TSFMRK
::			JAL	R2,SYALGN
::	RETURNS:	J	SYLRET
::
::*********************************************************************
SYLMRK	
      IF	1-NAD68		:					###%cc
	SCAN	R11,R13		:for normal engine			###%cc
      ELSE	:nad68		:					###%cc
	SCAN 	R11,R12,R13		:				###%cc
      EI	:nad68		:					###%cc

	JFS	SYLHIT			:FOUND 'START BIT'
	J	SYLRET			:NOT YET, TRY NEXT LINE

:	FOUND START OF RECORD -- GUARANTEED AT LEAST 16 BYTES OF
:	DATA IN THE INPUT RING

SYLHIT	HS	0
	LHL	R3,0,R13,R12		:GET FIRST HALFWORD OF RAW DATA
	LCS	R1,1			:SET UP MASK
	XR	R1,R3			:SET MARK BITS TO ZERO

	JFFOH	R1,SYMK10		:GET LEFT SHIFT COUNT TO R2
	IF	DB.DEB
	DBOOPS
	ELSE	:NOT DB.DEB
:	SYNC RING SCAN INSTRUCTION INDICATES ZERO BIT FOUND, BUT LOAD
:	HALF-WORD YIELDS ALL ONES...FORMAT DIAGNOSTIC NODE REPORT.
:	WE CAN'T CALL REPORTING ROUTINE SINCE WE ARE IN FOREGROUND. SET
:	UP RELEVANT DATA IN WORK AREA - SWITCH WILL TEST SEMAPHORE (SUPIBF).
	STB	LN,SUPIBF+3		:SAVE LINE NUMBER AND
	STH	R13,SUPIBF+4		:	ROUGH POINTER TO PROBLEM AREA
	LIS	R8,DR.SYM
	STB	R8,SUPIBF+2		:DIAGNOSTIC SUB-TYPE FOR SYNC SCAN ERR
	STH	R8,SUPIBF		:POSITIVE VALUE MEANS MSG READY TO SHIP
	EI	:DB.DEB

SYMK10	AIS	R12,2			:INC TRAILING POINTER
	NHI	R12,SVNBSZ-2		:CORRECT FOR WRAP AROUND
	LHL	R4,0,R13,R12		:PICK UP NEXT 16 BITS
	LR	R5,R3			:COPY OF FIRST 16 BITS
	SLL	R5,0,R2			:LEFT ALIGN THE BITS
	LIS	R10,0F			:GET COMPLEMENT OF LEFT
	SR	R10,R2			:	SHIFT COUNT TO R10
	SRL	R4,1,R10		:ALIGN REST OF BITS
	OR	R4,R5			:R4 CONTAINS HEADER
	NI	R4,0FFFF		:	HALFWORD -- RIGHT ALIGNED
	JNFS	SYMK12
	LIS	R0,1			:GOT 16 BITS OF ZEROES - INDICATE
	AHM	R0,SPACNG,LN		:	SPACING DETECTED ON INPUT
	J	SYNEXT

SYMK12	L	KD,KDLN,LN,LN		:GET LINK DESCRIPTOR ADDRESS
	JL	SYLUAL			:GO TREAT RECORD ON UNASSIGNED LINE
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR TRACING DESIRED
	JNFS	TSLB01			:NO
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	STH	R4,TSFTBL+2,R15		:STORE POTENTIAL HEADER
	LIS	R0,TS.HDR
	STB	R0,TSFTBL,R15		:STORE ENTRY TYPE
	L	R15,TSRSVE		:RESTORE R15
TSLB01	EI	:TSTSZE

:	RECORD RECEIVED ON ATTACHED TYMNET-II LINK.
:	REGISTER 4 CONTAINS FIRST HALFWORD OF HEADER -- RIGHT ALIGNED.

SYBT2	EXBR	R0,R4			:ISOLATE BORI
	NHI	R0,0F0			:
	CLB	R0,BORI,KD		:IS IT BORI?
	JN	SYBT22			:NO, SKIP

:	TYMNET II RECORD RECEIVED. NOT RESET OR NULL.
:	MAKE SURE ALL THE DATA IS IN INPUT RING.

	EXBR	R1,R4			:EXTRACT BYTE COUNT INDEX
	NHI	R1,0F
	LB	R1,SYTWCN,R1		:GET ACTUAL COUNT FROM TABLE

:	SEE IF COMPLETE RECORD HAS BEEN RECEIVED

SYLCHK	LR	R0,R11			:COPY OF LEAD POINTER
	SR	R0,R12			:RECEIVED COUNT=LEAD-TRAIL
	JGEFS	SYCH10			:SKIP IF NO WRAP AROUND
	AHI	R0,SVNBSZ		:CORRECT FOR WRAP AROUND

SYCH10	SIS	R0,8			:NEED TWO WORDS BEYOND EOR
	CR	R0,R1			:GOT THEM?
	JG	SYWT20			:YES
					:NO, DONE FOR NOW

:	SAVE COUNT, SHIFT, HEADER, AND SET TO WAIT FOR RECEPTION
:	OF COMPLETE RECORD

SYLSAV	STH	R1,SYBCNT,LN		:SAVE BYTE COUNT
	STH	R10,SYLSHF,LN		:SAVE LEFT SHIFT -- COMPLEMENTED
	STH	R4,SYHEDR,LN,LN		:SAVE ALIGNED HEADER
	STH	R3,SYHEDR+2,LN,LN	:SAVE FIRST 16 BITS RAW DATA
	LHI	R0,SYWAIT-SEG1		:SET 'STATE'
	STH	R0,QSYLVR,LN
	J	SYLRET			:DONE

:	CHECK FOR EXPANDED RESET 
SYBT22	HS	0
	CLHI	R4,TXRSHD		:Expanded Reset header?
	JN	SYBT25			:no
	JAL	R9,SYLXRS		:yes, store Reset in SYSTOR
	L	KD,KDLN,LN,LN		:restore link descriptor address
	LHL	R0,NDID,KD		:get neighbor # from link descriptor
	CL	R0,SYSTOR+2		:compare to FW following Reset header
	JE	SYLRAL			:equal-reset received on attached line 
	J	SYLERR			:no - line error

::*********************************************************************
::
::	SUBROUTINE:	SYLXRS:
::	FUNCTION:	Check to see if complete Expanded Reset has been
::			received and move to temporary storage.
::	CALLING SEQ:	JAL	R9,SYLXRS  Called from SYBT22 for reset
::			on assigned line and from SYLUAL for reset on
::			unassigned line.
::	INPUT:		R3, R4, R10, R11, R12, LN
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R2,SYALGN
::
::*********************************************************************

:	CHECK TO SEE IF COMPLETE EXPANDED RESET HAS BEEN RECEIVED
SYLXRS	HS	0
	EXBR	R1,R4			:extract byte count index
	NHI	R1,0F
	LB	R1,SYTWCN,R1		:get actual count from table
	LR	R0,R11			:make copy of lead pointer
	SR	R0,R12			:received count = lead-trail
	JGEFS	SYLX02			:skip if no wrap around
	AHI	R0,SVNBSZ		:correct for wrap around
SYLX02	SIS	R0,8			:need 2 words beyond EOR
	CR	R0,R1			:got them?
	JG	SYLX04			:yes

:	NO, SAVE RETURN, SHIFT, HEADER, AND SET TO WAIT FOR COMPLETION.
	ST	R9,SYLLNK,LN,LN		:save return
	STH	R1,SYBCNT,LN		:save byte count
	STH	R10,SYLSHF,LN		:save left shift -- complemented
	STH	R4,SYHEDR,LN,LN		:save aligned header
	STH	R3,SYHEDR+2,LN,LN	:save 1st 16 bits raw data
	LHI	R0,SRWAIT-SEG1		:set 'state'
	STH	R0,QSYLVR,LN
	J	SYLRET			:done for now

::*********************************************************************
::
::	ENTRY POINT:	SRWAIT:
::	FUNCTION:	Check to see if complete Expanded Reset has been
::			received
::	CALLING SEQ:	LHL	R1,QSYLVER,LN
::			J	SEG1,R1,,
::	INPUT:		R11, R12, LN
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R2,SYALGN
::	RETURNS:	JLE	SYLRET
::
::*********************************************************************

SRWAIT	HS	0
	LR	R0,R11			:make copy of lead pointer
	SR	R0,R12			:received count = lead-trail
	JGEFS	SRWA02			:skip if no wrap around
	AHI	R0,SVNBSZ		:correct for wrap around
SRWA02	SIS	R0,8			:need 2 words beyond EOR
	CH	R0,SYBCNT,LN		:got them?
	JLE	SYLRET			:not yet

	LHI	R0,SYLMRK-SEG1		:yes, next time look for start
	STH	R0,QSYLVR,LN		: of new record
	LHL	R4,SYHEDR,LN,LN		:get aligned HW of header
	LHL	R3,SYHEDR+2,LN,LN	:get 1st HW of raw data
	LHL	R10,SYLSHF,LN		:get left shift count (complemented)
	L	R9,SYLLNK,LN,LN		:get return
	LHL	R1,SYBCNT,LN

:	MOVE EXPANDED RESET INTO TEMPORARY STORAGE
SYLX04	SRHLS	R1,1			:convert to halfword count
	AIS	R1,1			:move VRC also
	CLHI	R1,SYSTSZ		:compare with sync storage size
	JG	SYLERR			:future reset may be too large for us
	LA	R8,SYSTOR		:put data in temp storage
	JAL	R2,SYALGN		:move the data
	JN	SYLERR			:CC<>0 => bad checksum
	JR	R9			:return

:	MUST BE SHORT RECORD -- ALIGN IT AND LOOK FOR POSSIBLE RECORD TYPES

SYBT25	LIS	R1,3			:MOVE 4 HALFWORDS
	LA	R8,SYSTOR		:STORE IN TEMPORARY AREA

	JAL	R2,SYALGN		:MOVE THE DATA

	JN	SYLERR			:BAD CHECKSUM

:	GOOD CHECKSUMS -- R4 STILL HAS FIRST HALFWORD

SYBT27	LHL	R0,NDID,KD		:GET NEIGHBOR # FROM LINK DESCRIPTOR
	CLH	R0,SYSTOR+2		:COMPARE TO HW FOLLOWING RESET HEADER
	JE	SYLRAL			:RESET RECEIVED ON ATTACHED LINE
SYBT28	L	R4,SYSTOR		:GET FIRST 32 BITS OF DATA
	CLI	R4,TWDMHD		:DUMMY RECORD?
	JN	SYLERR			:NO - LINE ERROR

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR TRACING DESIRED
	JNFS	TSLB02			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:MAKE NEW EVENT ENTRY
	LIS	R0,TS.DUM
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE
	LIS	R0,0
	STH	R0,TSFTBL+2,R15		:NO DATA FOR HEADER FIELD
	L	R15,TSRSVE		:RESTORE R15
TSLB02	EI	:TSTSZE
	LR	R0,LN			:GET LINE NUMBER
	SRHLS	R0,1
	SBT	R0,LNGREC		:SET GOOD REC REC'D FLAG
	J	SYNEXT			:CHECK FOR MORE TO DO

::*********************************************************************
::
::	ENTRY POINT:	SYWAIT:
::	FUNCTION:	COME HERE TO SEE IF ENTIRE PHYSICAL RECORD
::			IS IN THE RING YET
::	CALLING SEQ:	LHL	R1,QSYLVR,LN
::			J	SEG1,R1,,
::	INPUT:		R11 = INPUT DATA LEAD POINTER
::			R12 = INPUT DATA TRAILING POINTER
::			R13 = INPUT RING ADDRESS
::			R14 = LN = LINE NUMBER * 2
::			R15 = KD = LINK DESCRIPTOR ADDRESS
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R9,SYFORM
::			JAL	R0,TSFMRK
::			JAL	R8,TSNSPK
::	RETURNS:	J	SYLRET
::
::*********************************************************************

SYWAIT	LR	R0,R11			:COPY LEAD POINTER
	SR	R0,R12			:BYTE COUNT=LEAD-TRAIL
	JGEFS	SYWT10			:ADJUST FOR WRAP AROUND
	AHI	R0,SVNBSZ

SYWT10	SIS	R0,8			:NEED TWO FULL WORDS AFTER EOR
	CH	R0,SYBCNT,LN		:GOT ENOUGH DATA?
	JLE	SYLRET			:NOT YET

	LHI	R0,SYLMRK-SEG1		:YES, NEXT TIME LOOK FOR
	STH	R0,QSYLVR,LN		:	START OF NEW RECORD

	LHL	R4,SYHEDR,LN,LN		:GET ALIGNED HALFWORD
	LHL	R3,SYHEDR+2,LN,LN	:FIRST HALFWORD OF RAW DATA
	L	KD,KDLN,LN,LN		:LINK DESCRIPTOR ADDRESS
	JL	SYNEXT			:LINK WENT OUT WHILE WE WERE WAITING...
	LHL	R1,SYBCNT,LN		:GET BYTE COUNT
	LHL	R10,SYLSHF,LN		:LEFT SHIFT COUNT (COMPLEMENTED)

SYWT20	SRHLS	R1,1			:CONVERT TO HALFWORD COUNT
	AIS	R1,1			:MOVE VRC ALSO

:	ALL DATA RECEIVED FOR RECORD ON TYMNET II LINK

SYFOT2	LHL	R0,0,R13,R12		:RECORD NUMBER IS THE BYTE
	LR	R2,R12			:FOLLOWING THE HALFWORD WE'VE ALREADY
	AIS	R2,2			:ALIGNED. EXTRACT ANOTHER HALFWORD
	NHI	R2,SVNBSZ-2		:HERE -- BUT DON'T MODIFY NORMAL
	LHL	R2,0,R13,R2		:POINTERS.
	EXHR	R0,R0
	OR	R0,R2
	SRL	R0,9,R10
	LBR	R0,R0			:R0=REC # -- RIGHT ALIGNED

	LH	R2,LAS,KD		:GET LAST ACK SENT
	SHI	R2,07F
	SR	R0,R2
	LBR	R0,R0
	AR	R2,R0			:R2= REC # -- SIGN EXTENDED

	JAL	R9,SYFORM

	IF	TSTSZE
	LR	R1,R4			:PRESERVE HEADER
	EI	:TSTSZE
	LH	R2,LAR,KD		:LAST ACK RECEIVED
	SR	R4,R2			:ACK OK IF
	LBR	R4,R4			:	LAR<=ACK<=LAR+WSIZ
	CLB	R4,WSIZ,KD		:IS ACK OK?
	JGFS	SYLBAK			:NO

:	GOOD ACK RECEIVED -- UPDATE 'NEXT REC TO XMIT'

SYLGDK	AR	R2,R4			:GET MOST RECENT ACK
	STH	R2,LAR,KD		:AND UPDATE LAR FIELD
	J	SYNEXT			:CONTINUE WITH NEXT PACKET OR LINK

:	BAD ACK REC'D -- RECORD AND FINISH UP

SYLBAK	HS	0
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB10			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BAK
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD ACK)
	STH	R1,TSFTBL+2,R15		:STORE PACKET HEADER (SAVED IN R1)
	LR	R1,R15			:SAVE INDEX REGISTER AND
	L	R15,TSRSVE		:	RESTORE R15 (KD)
	LH	R0,LAR,KD		:GET LAST ACK RECEIVED AND
	STB	R0,TSFTBL+4,R1		:	STORE IN EVENT ENTRY	###OAS
	LIS	R0,0		:PROVIDE OPPORTUNITY TO PATCH THIS 'LHL' TO A
	LHL	R0,TSLINK	: 'STH' TO TERMINATE TRACING AND EXAMINE
				: HISTORY PRIOR TO BAD ACK OCCURRENCE.
TSLB10	EI	:TSTSZE
	LB	R0,NLAT,KD		:BAD ACKS CAN OCCUR LEGITIMATELY ON
	SIS	R0,1			: MULTI-LINE LINKS IF SUBSEQUENT SHORT
	JG	SYNEXT			: PACKET OVERTAKES PRIOR PACKET W/ OLD
					: ACK. DON'T COUNT...
	LIS	R0,1
	AHM	R0,BADACK,LN		:RECORD OCCURRENCE OF BAD ACK
	J	SYNEXT			:GO LOOK FOR NEXT RECORD

:	RESET RECEIVED ON EITHER T-II OR T-I ATTACHED LINE.
:	PUT LINE IN LIMBO AND TELL LINKER TO DETACH IT.

SYLRAL	HS	0
	LR	R1,LN			:GET LINE NUMBER
	SRHLS	R1,1
	TBT	R1,INHRST		:RESET INHIBITED?
	JN	SYNEXT			:YES

	LCS	R0,1			:NO, PUT LINE IN LIMBO
	ST	R0,KDLN,LN,LN
	LHI	R0,SIOIDL-SEG1		:set idle transmit state
	STH	R0,SIOTST,LN
	SBT	R1,LINDET		:TELL LINKER TO DETACH
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB09			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RST
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (RESET RECEIVED)
:	DETERMINE(* WHETHER TYMNET-I OR*) TYMNET-II LINK.(*T-I*)RESET
:	HEADER(*IS IN R4,*) T-II IS IN 'SYSTOR'.
	L	R0,SYSTOR		:NO, TYMNET-II - GET 4 BYTES OF RESET 
	ST	R0,TSFTBL+2,R15		:AND STORE (CLOBBER HI-ORDER
					:HALFWORD OF FASTC) 
TSLB08	AIS	R15,TSESZE
	NHI	R15,TSTSZE-1		:ADVANCE TO NEXT ENTRY AND CLEAR
	LIS	R0,0			:	IT TO EASE FINDING END OF
	ST	R0,TSFTBL,R15		:	TRACE HISTORY
	ST	R0,TSFTBL+4,R15
	STH	R0,TSLINK		:INHIBIT FURTHER TRACING
	L	R15,TSRSVE

	JAL	R8,TSNSPK		:SAVE MOST RECENT PACKETS IN AND OUT

TSLB09	EI	:TSTSZE
	LIS	R0,3			:SET DETACH REASON
	STB	R0,DREASN,R1
	LHI	R0,1F-PLINKR		:SCHEDULE LINKER
	SBT	R0,TLINKR
	JFS	SYNEXT

:	COME HERE WHEN 'NOISE' SEEN ON LINE

SYLERR	HS	0
	LIS	R0,1			:INC COUNTER
	AHM	R0,LINERR,LN		:INC ERROR COUNTER

:	COME HERE TO LOOK AT NEXT HALFWORD
:	R3 CONTAINS LAST HALFWORD OF RAW DATA
:	R10 CONTAINS LEFT SHIFT FACTOR -- COMPLEMENTED

SYNEXT	LCS	R1,1			:SET TO MASK BITS ALREADY USED
	SLL	R1,1,R10		
	LHL	R3,0,R13,R12		:GET LAST 1/2 WD LOOKED AT
	OR	R3,R1			:SET THEM TO MARKS
	STH	R3,0,R13,R12		:AND STORE FOR POSTERITY
	J	SYLMRK			:GO LOOK FOR NEW RECORD

:	DATA RECEIVED ON UNASSIGNED LINE -- SEE IF IT IS RESET,
:	DOWNLINE LOAD DATA, OR GARBAGE.  R4 contains first HW of Header.

SYLUAL	HS	0
	IF	TSTSZE
	JAL	R2,TSFUAL		:TEST IF THIS LINE IS OF INTEREST
	EI	:TSTSZE
	AIS	KD,1			:IF LINE IN LIMBO
	JE	SYNEXT			:	JUST IGNORE

	TBT	LN,DWLDSP		:IS THIS A DWL LINE?
	JN	SYLDLL			:YES, SKIP

	LR	R0,R4			:copy header halfword
	NHI	R0,0FFE0		:mask out 'subseq' bit, ping pong count
	CLHI	R0,TXRSHD		:'new link' Expanded reset?
	JN	SYLRES			:no
SYLU02	JAL	R9,SYLXRS		:store Reset in SYSTOR
	LR	R2,LN			:Line Number*2
	SRHLS	R2,1
	TBT	R2,INHRST		:reset inhibited?
	JN	SYNEXT			:yes
	L	R5,SDLN,LN,LN		:ok, get Reset descriptor address
	AHI	R5,VSDSZ-2		:address of last destination HW to R1+1
	LA	R4,SYSTOR+(VSDSZ-2)	:address of last source HW to R1
	LHI	R1,10*((VSDSZ/2)-1)	:10*(numberof HW's -1)
	COPY	R4,R1			:copy Reset from temporary storage
	J	SYLR02
SYLRES
SYLUA5	LIS	R1,6			:MOVE 6 HALFWORDS OF RESET INTO SYSTOR
	LA	R8,SYSTOR		:PUT DATA IN TEMP STORAGE
	JAL	R2,SYALGN		:MOVE THE DATA
	LR	R0,R4			:COPY HEADER HALFWORD
	NHI	R0,0FFF0		:MASK OUT PING PONG COUNT
	CLHI	R0,TTRSHD		:TYMNET-II NEW LINK RESET?
	JE	SYLRDL			:YES
	CLHI	R0,TSRSHD		:TYMNET-II SUBSEQUENT LINE RESET?
	JEFS	SYLRDL			:YES
	L	R4,SYSTOR		:NO TRY T-II NULL RECORD
	CLI	R4,TWDMHD		:MIGHT RECEIVE WHILE WAITING ON LINKER
	JN	SYLERR			:NO, MUST BE NOISE
	J	SYNEXT			:YES, IGNORE IT

:	RESET RECEIVED

SYLRDL	LR	R2,LN			:LINE NUMBER
	SRHLS	R2,1
	TBT	R2,INHRST		:RESET INHIBITED?
	JN	SYNEXT			:YES
	L	R5,SDLN,LN,LN		:NO, RESET DESCRIPTOR ADDRESS
	L	R4,SYSTOR		:SAVE FIRST WORD OF RESET FOR LINKER
	ST	R4,VRSTP,R5		:SAVE FOR USE BY LINKER
	L	R0,SYSTOR+8		:NEIGHBOR VERSION NUMBER FROM RESET,
	ST	R0,VRSTP+4,R5		:	IF PRESENT

SYLR02	SBT	R2,VRSTDL		:TELL LINKER TO LOOK AT IT
	SBT	R2,LINATT		:AND TO ATTACH THE LINE
	LHI	R0,01F-PLINKR		:AND SCHEDULE THE LINKER
	SBT	R0,TLINKR
	J	SYNEXT

:	DATA RECEIVED ON LINE BEING DOWNLINE LOADED

SYLDLL	CLHI	R4,DWNLHD		:DOWNLINE LOAD HEADER?
	JN	SYNEXT			:NO, IGNORE IT

	STH	R10,SYLSHF,LN
	LHI	R0,SYLDWT-SEG1		:AND SET TO WAIT FOR DATA
	STH	R0,QSYLVR,LN

::*********************************************************************
::
::	ENTRY POINT:	SYLDWT:
::	FUNCTION:	COME HERE WHEN WE ARE WAITING FOR THE TARGET MACHINE
::			TO COMPLETE TRANSMISSION OF A DWL RECORD.
::	CALLING SEQ:	LHL	R1,QSYLVR,LN
::			J	SEG1,R1,,
::	INPUT:		R11 = INPUT DATA LEAD POINTER
::			R12 = INPUT DATA TRAILING POINTER
::			R13 = INPUT RING ADDRESS
::			R14 = LN = LINE NUMBER * 2
::			R15 = KD = LINK DESCRIPTOR ADDRESS
::	DESTROYED:	R0, R1
::	CALLS:		JAL	R2,SYALGN
::	RETURNS:	J	SYLRET
::
::*********************************************************************

SYLDWT	LR	R0,R11			:COPY OF LEAD POINTER
	SR	R0,R12			:WAIT FOR 42+8 BYTES
	JGEFS	SYLDW5			:SKIP IF NO WRAP
	AHI	R0,SVNBSZ
SYLDW5	SIS	R0,8
	CHI	R0,42			:GOT ALL THE DATA?
	JLE	SYLRET			:NO

	LHI	R0,SYLMRK-SEG1		:YES, NEXT TIME LOOK FOR NEW PACKET
	STH	R0,QSYLVR,LN
	LHL	R10,SYLSHF,LN		:GET SHIFT COUNT
	LIS	R8,1
	AHM	R8,DWLCLI
	LH	R8,DWTEST		:GET THE DWLIN SEMAPHORE
	JL	SYLDW7			:<0 MEANS DWLIN IS USING DWQUEQ..
					:...SO DON'T STORE
	LIS	R4,TINTCH-1
SYLDW6	CLH	LN,DWLNUM,R4,R4		:GET DWL LINE INDEX
	JEFS	SYLDW8			:FOUND IT
	SIS	R4,1
	JGEBS	SYLDW6			:HAVEN'T FOUND IT, KEEP LOOKING
	J	SYNEXT			:DLL LINE NOT THERE, PRESUMED ZAPPED

SYLDW8	LH	R8,DWBUSY,R4,R4		:R8<0 MEANS DONT STORE
	JL	SYLDW7			:-1000 MEANS BUFFER IS BUSY
	SLLS	R4,6			:FORM DWIBUF OFFSET (64 X R4)
	LA	R8,DWIBUF,R4,		:SET BUFFER ADDRES
	SRLS	R4,6			:RESTORE R4

	LHL	R3,0,R13,R12		:SKIP OVER SYNCS
	AIS	R12,2			:BY RESETTING R3 AND
	NHI	R12,SVNBSZ-2		:INCREMENTING TRAIL POINTER

	LHI	R1,20			:MOVE 32 HALFWORDS
	JAL	R2,SYALGN

	LHI	R0,-1000		:MARK BUFFER BUSY
	STH	R0,DWBUSY,R4,R4
	LHI	R0,01F-PDWLIN		:AND SCHEDULE TEAR DOWN OF
	SBT	R0,SQUEUE		:DOWNLINE RECORD BY DWLIN
	SBT	R4,DWQUEU		:SET BIT IN DWL JOB QUEUE FOR DWLIN
	J	SYNEXT

SYLDW7	LHL	R3,0,R13,R12		:SKIP OVER SYNCS
	AIS	R12,2			:	BY RESETTING R3 AND
	NHI	R12,SVNBSZ-2		:INCREMENTING TRAIL POINTER
	LHI	R1,20			:MOVE 32 HALFWORDS
	JAL	R2,SYALGN
	J	SYNEXT

::*********************************************************************
::
::	SUBROUTINE:	SYFORM:
::	FUNCTION:	PERFORMS CHARACTER FRAMING AND RECORD CHECKSUMMING
::			FOR SYLVER.
::	REGISTERS ON ENTRY:
::		R2  -- RECORD SEQUENCE NUMBER
::		R3  -- RAW DATA POINTED TO BY R12
::		R9  --*RETURN ADDRESS
::		R10 --*ALIGNMENT SHIFT FACTOR (COMPLEMENT)
::		R11 --*RELATIVE INPUT DATA LEAD POINTER
::		R12 --*RELATIVE INPUT DATA TRAIL POINTER
::		R13 --*START OF INPUT RING 
::		R14 --*LINE NUMBER X 2
::		R15 --*LINK DESCRIPTOR ADDRESS
::	* MUST BE PRESERVED ON RETURN (NOTE--R5 AND R11 RETURNED
::		IN UPDATED FORM)
::	REGISTER USAGE:
::		R0  -- WORK REGISTER
::		R1  -- NUMBER OF HALFWORDS TO MOVE
::		R2  -- RECORD SEQUENCE NUMBER
::		R3  -- FIRST 16 BITS OF RAW DATA
::		R5  -- VERTICAL CHECKSUM ACCUMULATOR
::		R6  -- SECTOR RECORD DESCRIPTOR ADDRESS
::		R7  -- DIAGONAL CHECKSUM ACCUMULATOR
::		R8  -- TARGET SECTOR ADDRESS (PHYSICAL RECORD BUFFER)
::		R9  -- RETURN ADDRESS
::		R10 -- ALIGNMENT SHIFT FACTOR (COMPLEMENTED)
::		R11 -- RELATIVE LEAD POINTER
::		R12 -- RELATIVE TRAIL POINTER
::		R13 -- START OF INPUT RING
::		R14 -- LINE NUMBER X 2
::		R15 -- LINK DESCRIPTOR ADDRESS
::	CALLS:	JAL	R0,TSFMRK
::		JAL	R2,SYALGN
::
::*********************************************************************

SYFORM	HS	0
	LB	R5,WSIZ,KD		:GET # SECTORS AVAILABLE
	LHL	R6,ISEC,KD		:SECTOR 0 PHYS REC DESCRIPTOR ADDR
	LR	R0,R2			:COPY OF RECORD NUMBER
	SH	R0,RECN,R6		:WE ARE THIS MANY AHEAD OR
	LHR	R0,R0			:	BEHIND SECTOR 0
	JGEFS	SYFR10			:AHEAD OF SECT 0 -- SKIP

	AR	R0,R5			:CORRECT FOR WRAP AROUND
SYFR10	CR	R0,R5			:TOO FAR AHEAD
	JLFS	SYFR12			:NO, SKIP
	SR	R0,R5			:YES, BACK UP

SYFR12
	lr	r8,r0
	lhl	r0,ccdsz,r8,r8  	:get rel sector address
:	MH	R0,CCDSZ		:GET RELATIVE SECTOR ADDRESS
	AR	R6,R0			:SECTOR ADDRESS TO R6

:	CHECK RECORD NUMBER FOR VALIDITY AND FOR RETRANSMISSION

	Lcs	R8,1			:ASSUME BAD REC -- SET 'DON'T STORE'
	LR	R0,R2			:COPY RECORD #
	SH	R0,LRT,KD		:LRT < REC # ?
	LHR	R0,R0			:	(NOTE--LRT = LAST REC TORN)
	JG	SYFR20			:YES, SKIP

:	RECEIVED RETRANSMISSION -- NOTE IT

SYFR15	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB03			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RXC
	STB	R0,TSFTBL,R15		:STORE ENTRY TYPE
	STH	R4,TSFTBL+2,R15		:STORE FIRST 2 BYTES OF HEADER
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB03	EI	:TSTSZE
	LIS	R0,1
	AHM	R0,RCRXMT,LN		:INC RETRANSMISSION REC'D COUNT
	J	SYFR30			:AND GO 'MOVE' THE DATA

SYFR20	CR	R0,R5			:REC # <= LRT+WSIZ ?
	IF	TSTSZE
	JLE	SYFR25			:YES, GOOD RECORD NUMBER
	ELSE	:NOT TSTSZE
	JLEFS	SYFR25			:RECORD NUMBER O.K.
	EI	:TSTSZE

:	BAD RECORD NUMBER (TOO HIGH) -- NOTE IT

	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB04			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.BRN
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (BAD RECORD NUMBER)
	STH	R4,TSFTBL+2,R15		:STORE RECORD HEADER
	STB	R2,TSFTBL+4,R15		:	AND PACKET RECORD NUMBER
	LIS	R0,0			:PROVIDE OPPORTUNITY TO PATCH
	LHL	R0,TSLINK		:	THIS 'LHL' TO A 'STH' TO
					:	TERMINATE TRACING AND
					:	EXAMINE HISTORY PRIOR TO
					:	BAD RECORD OCCURRENCE.  
	L	R15,TSRSVE
TSLB04	EI	:TSTSZE
	LB	R0,NLAT,KD		:BAD RECORD # CAN OCCUR ON MULTI-LINE 
	SIS	R0,1			:LNKS IF SUBSEQUENT SHORT PKT OVERTAKES
	JGFS	SYFR30			:PRIOR PKT. DON'T COUNT THIS ONE

	LIS	R0,1
	AHM	R0,BADRCN,LN		:INC BAD RECORD COUNTER
	JFS	SYFR30			:AND GO 'MOVE' THE DATA

SYFR25	CLH	R2,RECN,R6		:SEE IF REC ALREADY REC'D
	JE	SYFR15			:YES, GO NOTE IT
	L	R8,BREC,R6		:GET PHYSICAL REC BUFFER ADDRESS

:	SET UP TO ALIGN DATA AND DO BLOCK CHECKS
	
SYFR30	ST	R2,SYSTOR		:SAVE REC # ACROSS CALL
	IF	SYNFCS
	ST	R8,ISECAD		:SAVE INPUT BUF. ADDR. FOR LATER USAGE
	EI	:SYNFCS

	JAL	R2,SYALGN		:MOVE THE DATA AND CHECKSUM IT

:	AFTER DATA ALIGNMENT, CHECK SOFTWARE FCS ERR HERE		###AL
	IF	SYNFCS
	LHL	R1,KVERNO,KD	:USE OLD 32BIT CKSM TO TALK TO OLD NODE
	CHI	R1,VERSION
	JL	SYFR35		:SKIP IF OLD VERSION ##AL
	L	R8,ISECAD	:GET INPUT BUF. ADDR.
	JLR	R9		:IF DATA ARR. NEG. NO STORE RETURN
	LB	R2,0,R8,	:IF BYTE COUNT IS NOT ZERO, DO FCS
	NHI	R2,000F		:GET BYTE CNT NIBBLE
	CLHI	R2,0
	JE	SYFR35		:ONLY DATA PACKET WITH NON-0 BYTE CT.
				:USE FCS CHECKING
	LB	R2,SYTWCN,R2	:EXACT BYTE CT. FROM TABLE
	AHI	R8,3		:WITHOUT 3 HEADER BYTES
	SIS	R2,3		:LESS 3 BYTE CT.
 	JAL	R0,FCSCA0	:CHECK SOFTWARE FCS ERR 
				:R7 LO HW HAS FCS
	NI	R7,0FFFF	:LO HW
	LHL	R0,0,R8,R2	:LET R0 HAS DATA PACK. FCS 
	CR	R7,R0		:COMPARE WITH THE FCS REVED AT EREC
				:R8 IS ISEC ADDR, R2 IS BYTE CT
	JN	SYFR37		:BAD FCS
	LIS	R2,3		:CHECK 3 BYTE HEADER FCS
	SIS	R8,3		:BACK TO THE 1ST BYTE
	JAL	R0,FCSCA0	:CALCULATE 3 BYTE FCS
	NI	R7,0FFFF	:LO HW
	LHL	R0,FCSGOT+2	:LET R0 HAS 3 BYTE HEADER FCS
	CR	R7,R0
	JE	SYFR40		:GOOD FCS CKSM
	J	SYFR37		:BAD FCS, SAME HANDLING			###AL
SYFR35	HS	0
	LHR	R7,R7		:CKSM GOOD IF LO HW OF R7 STILL ZERO
	EI	:SYNFCS

	IF	1-TSTSZE
	JEFS	SYFR40			:SKIP IF GOOD CHECKSUM
	ELSE	:TSTSZE
	JE	SYFR40			:O.K. CHECKSUM CONDITION CODE RETURNED
SYFR37	HS	0
:	PACKET RECEIVED WITH BAD CHECKSUM
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JN	TSLB05			:NO - CONTINUE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.CSE
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (CHECKSUM ERROR)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	LHL	R2,SYSTOR+2
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	LIS	R0,0
	NOP	R0,TSLINK		:PATCH TO 'STH' TO TERMINATE TRACE HERE
	L	R15,TSRSVE
TSLB05	EI	:1-TSTSZE
	LIS	R0,1
	AHM	R0,BADCSM,LN		:INC BAD CHECKSUM COUNTER
	J	SYNEXT			:AND SKIP TO NEXT LINE

:	GOOD CHECKSUM	-- RELEASE DATA TO RTD

SYFR40	LR	R8,R8			:SEE IF RECORD STORED
	JLR	R9			:NO, SIMPLY RETURN
	LR	R0,LN
	SRHLS	R0,1			:SET BIT INDICATING GOOD
	SBT	R0,LNGREC		:	REC RECEIVED ON LINE

	L	R2,SYSTOR		:RETRIEVE SAVED RECORD NUMBER
	STH	R2,RECN,R6		:REC # TO RECORD DESCRIPTOR
	LR	R1,R2			:COPY RECORD NUMBER OVER
	NHI	R1,PKTMSZ		:MASK WITH BUFFER SIZE
	AR	R1,R1			:FORM HW INDEX
	LHL	R0,FASTC+2,,		:GET CURRENT TIME
	STH	R0,INTIME,KD,R1		:AND RECORD TIME OF PACKET ARRIVAL

	LB	R1,LKNM,KD		:GET LINK NUMBER
	SBT	R1,LKGREC		:NOTE GOOD REC REC'D ON LINK
	SBT	R1,LKTEAR		:'SCHEDULE' RTD

	LIS	R0,1			:INC COUNT OF GOOD
	AHM	R0,RCRCVD,LN		:	RECORDS REC'D ON THIS LINE
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R0,TSLINK		:	TEST FOR LINK OF INTEREST
	JNR	R9			:NO - DONE
	ST	R15,TSRSVE		:YES - SAVE R15
	JAL	R0,TSFMRK		:SET UP NEW EVENT ENTRY
	LHI	R0,TS.REC
	STB	R0,TSFTBL,R15		:STORE EVENT TYPE (GOOD REC RECEIVED)
	STH	R4,TSFTBL+2,R15		:STORE PACKET HEADER
	LHL	R2,RECN,R6
	STB	R2,TSFTBL+4,R15		:STORE PACKET RECORD NUMBER
	L	R15,TSRSVE
TSLB06	EI	:TSTSZE
	JR	R9			:DONE

	IF	SYNFCS
FCSTBL	HS	0
	XC	0000891112239B322446AD573665BF74
	XC	488CC19D5AAFD3BE6CCAE5DB7EE9F7F8
	XC	8110080193331A22A5562C47B7753E64
	XC	C99C408DDBBF52AEEDDA64CBFFF976E8
	XC	02218B30100299132667AF763444BD55
	XC	4AADC3BC588ED19F6EEBE7FA7CC8F5D9
	XC	83310A2091121803A7772E66B5543C45
	XC	CBBD42ACD99E508FEFFB66EAFDD874C9
	XC	04428D5316619F702004A9153227BB36
	XC	4CCEC5DF5EEDD7FC6888E1997AABF3BA
	XC	85520C4397711E60A1142805B3373A26
	XC	CDDE44CFDFFD56ECE9986089FBBB72AA
	XC	06638F7214409D512225AB343006B917
	XC	4EEFC7FE5CCCD5DD6AA9E3B8788AF19B
	XC	87730E6295501C41A3352A24B1163807
	XC	CFFF46EEDDDC54CDEBB962A8F99A708B
	XC	088481951AA793B62CC2A5D33EE1B7F0
	XC	4008C919522BDB3A644EED5F766DFF7C
	XC	899400859BB712A6ADD224C3BFF136E0
	XC	C1184809D33B5A2AE55E6C4FF77D7E6C
	XC	0AA583B4188691972EE3A7F23CC0B5D1
	XC	4229CB38500AD91B666FEF7E744CFD5D
	XC	8BB502A499961087AFF326E2BDD034C1
	XC	C3394A28D11A580BE77F6E6EF55C7C4D
	XC	0CC685D71EE597F42880A1913AA3B3B2
	XC	444ACD5B5669DF78600CE91D722FFB3E
	XC	8DD604C79FF516E4A9902081BBB332A2
	XC	C55A4C4BD7795E68E11C680DF33F7A2E
	XC	0EE787F61CC495D52AA1A3B03882B193
	XC	466BCF7A5448DD59622DEB3C700EF91F
	XC	8FF706E69DD414C5ABB122A0B9923083
	XC	C77B4E6AD5585C49E33D6A2CF11E780F
	EI	:SYNFCS	###AL

::*********************************************************************
::
::	SUBROUTINE:	FCSCA0 WITH R2 AS BYTE CT. INPUT
::	FUNCTION:	SOFTWARE FCS CALCULATION
::	CALLING SEQ:	JAL	R0,FCSCA0
::	INPUT:		R8 = INPUT SECTOR ADDRESS
::	OUTPUT: 	R7 = 16-BIT FCS IN LO HW
::	DESTROYED:	R0,R1,R2,R3,R5,R7
::
::*********************************************************************

	IF	SYNFCS		:###AL
FCSCA0	HS	0
	FCSINI(R7)		:GET FCS INIT VALUE
	XR	R1,R1		:ZERO R1
FCSCA1	LB	R3,0,R8,R1	:GET THE CHAR.
	FCSACC(R7,R3,R5)	:ACCUMULATE THE FCS
	AIS	R1,1		:INC CNT. TO NEXT CHAR.
	CR	R1,R2		:CMP. WITH THE LENGTH
	JL	FCSCA1		:CONTINUE IF NOT END
	FCSEND(R7)		:1'S COMPLEMENT THE FINAL VALUE
				:LO HW OF R7 HAS 16BIT FCS
	JR	R0
	EI	:SYNFCS

::*********************************************************************
::
::	SUBROUTINE:	SYALGN:
::	FUNCTION:	ACTUALLY PERFORMS THE CHARACTER ALIGNMENT,
::			MOVING, AND CHECKSUMMING.
::	CALLING SEQ:	JAL	R2,SYALGN
::	INPUT:		R1  -- NUMBER OF HALFWORDS TO MOVE
::			R2  -- RETURN ADDRESS
::			R3  -- FIRST 16 BITS OF RAW DATA
::			R8  -- WHERE TO STORE DATA (IF NEG -- NO STORE)
::			R10 -- ALIGNMENT SHIFT FACTOR
::			R11 -- INPUT LEAD POINTER
::			R12 -- INPUT TRAIL POINTER
::			R13 -- INPUT RING ADDRESS
::	OUTPUT:		R12 -- NEW TRAIL POINTER
::	DESTROYED:	R0,R1,R3,R5,R7,R8
::	ALSO:		CC=0 => GOOD CHECKSUMS
::			CC<>0 => BAD CHECKSUMS
::
::*********************************************************************

SYALGN	HS	0
	LIS	R5,0			:SET VRC AND DRC ACCUMULATORS
	LIS	R7,0
	ALIGN 	R13,R12			:				###%cc
	EXHR	R0,R3			:BUILD DRC
	LHL	R3,0,R13,R12
	OR	R0,R3			:	
	SRL	R0,1,R10		:GOT CALCULATADED DRC IN R0
	IF	SYNFCS
	STH	R0,FCSGOT+2		:STORE THE REV'ED HEADER FCS##AL
	EI	:SYNFCS
	XR	R7,R0			:XOR IT WITH RX'ED DRC IN LO HW R7
	OR	R7,R5			:INCLUDE VRC
	LHR	R7,R7			:CHECKSUMS GOOD IF RIGHT HALF OF R7
	JR	R2			:	IS ZERO.  SET CONDITION CODE

	SUBTTL	LINKER (Miscellaneous subroutines...)

::*********************************************************************
::
::	TABLE:		SYTWCN:
::	FUNCTION:	TYMNET II BYTE COUNT TRANSLATION TABLE -
::			COUNT VALUE RECEIVED IN TYMNET-II PACKET HEADER IS
::			INDEX INTO THIS TABLE.  THE VALUE IN THE TABLE
::			IS THE NUMBER OF BYTES IN THE PACKET, INCLUDING
::			THE HEADER BUT NOT THE CHECKSUMS.
::
::*********************************************************************

SYTWCN	BC	04,0C,14,1C,24,2C,34,3C,44,4C,54,5C,64,6C,74,7C

::*********************************************************************
::
::	SUBROUTINE:	GFRCHN:
::	FUNCTION:	RETURNS CHAIN OF N FREE RECORD BUFFERS.
::	CALLING SEQ:	JAL	R9,GFRCHN
::	INPUT:		R1 = # BUFFS
::	OUTPUT:		R2 = RETURNS PTR TO FIRST BUFFER
::			R3 = RETURNS PTR TO LAST
::	PRESERVED:	R1
::	DESTROYED:	R4
::
::*********************************************************************

GFRCHN	HS	0
	LR	R4,R1
	LHL	R2,FREELR
	JLFS	GFRERR			:FREE LIST EMPTY		###wjl
	LR	R3,R2
	JFS	GFRC2
GFRC1	LHL	R3,RLNK,R3
	JLFS	GFRERR			:				###wjl
GFRC2	SIS	R4,1
	JGBS	GFRC1

	LHL	R4,RLNK,R3		:NEW TOP OF FREE LIST
	STH	R4,FREELR
	JR	R9			:				###wjl

GFRERR	HC	0	:this should have been prevented at assembly	###wjl

::*********************************************************************
::
::	SUBROUTINE:	MCHDWN
::	FUNCTION:	Matches down window size
::	CALLING SEQ:	JAL	R9,MCHDWN
::	INPUT:		R1 = number of buffers, i.e. window size
::			R2 = pointer to first buffer
::			if tunl, R6= ptr of ISECSV/OSECSV,KD		###cwc
::	OUTPUT:		R3 = returns pointer to last buffer
::			if tunl, ISECSV/OSECSV,KD is updated		###cwc
::	PRESERVED:	R1 (wsz)
::	DESTROYED:	R4, if tunl, R0 as well				###cwc
::
::*********************************************************************

MCHDWN	HS	0
       IF	 WSZTST!TUNL		:reconnect any broken chains
	LHL	R3,ISECSV,KD		:a broken ISEC chain?
	JEFS    MCHD00
	LHL	R4,ISECS1,KD		:get address of broken chain
	STH	R4,RLNK,R3
	LIS	R3,0			:no broken chains
	STH	R3,ISECSV,KD		:chain fixed
MCHD00  LHL	R3,OSECSV,KD		:broken output sector chain
	JEFS    MCHD01  		:no break
	LHL	R4,OSECS1,KD
	STH	R4,RLNK,R3		:restored OSEC chain
	LIS	R3,0			:chain no longer broken
	STH	R3,OSECSV,KD
MCHD01
       EI 	:WSZTST!TUNL

	LHL	R2,ISEC,KD		:match down input window first  ###sdw
	LR	R4,R1			:preserve number of buffers (WSIZ)
	LR	R3,R2			:preserve pointer to first buffer
	JFS	MCHD04
MCHD02	LHL	R3,RLNK,R3		:get pointer to next buffer
MCHD04	SIS	R4,1			:decrement count
	JGBS	MCHD02			:done?
       IF	 WSZTST!TUNL		:save break so can restore chain
	LHL	R4,RLNK,R3		:address of the broken piece
	CR	R4,R2			:loop back to start?
	JE      MCHD10  		:nothing to break
	STH	R3,ISECSV,KD		:where it was broken
	STH	R4,ISECS1,KD
       EI 	:WSZTST!TUNL
	STH	R2,RLNK,R3		:yes, store pointer to first buffer

:	now do output sector side
MCHD10  LHL	R2,OSEC,KD		:match down output window       ###sdw
	LR	R4,R1			:preserve number of buffers (WSIZ)
	LR	R3,R2			:preserve pointer to first buffer
	JFS	MCHD14
MCHD12	LHL	R3,RLNK,R3		:get pointer to next buffer
MCHD14	SIS	R4,1			:decrement count
	JGBS	MCHD12			:done?
       IF	 WSZTST!TUNL		:save break so can restore chain
	LHL	R4,RLNK,R3		:address of the broken piece
	CR	R4,R2			:end point to start?
	JE      MCHD20  		:yes, no break to make
	STH	R3,OSECSV,KD		:where output chain was broken
	STH	R4,OSECS1,KD		:
       EI 	:WSZTST!TUNL
	STH	R2,RLNK,R3		:and shorten chain (the match down)
MCHD20					:done with outpt sector
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	CLRCHN:
::	FUNCTION:	INITIALIZES CHAIN OF RECORD BUFFERS.
::	CALLING SEQ:	JAL	R9,CLRCHN
::	INPUT:		R1 = # BUFFS
::			R2 = PTR TO FIRST BUFFER
::	PRESERVED:	R1
::	DESTROYED:	R0, R3
::
::*********************************************************************

CLRCHN	HS	0
	LIS	R0,0
	SR	R0,R1			:R0 = - # OF SECTORS
	LIS	R3,0
CLRC1	STH	R0,RECN,R2
	STB	R3,LLXM,R2		:CLEAR LLXM
	LHL	R2,RLNK,R2
	AIS	R0,1
	JLBS	CLRC1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	BFRUPD:
::	FUNCTION:	Routine to copy ACP array to BFDARY (buffer
::			delay array) for the purpose of scheduling the
::			sending of buffer delay timing pairs (COMETS--0314).
::			Scheduled from the 30 second logic in EXEC, if
::			BFLTMR assembly switch is non-zero.
::	CALLING SEQ:	JAL	R10,BFRUPD
::
::*********************************************************************

	IF	BFLTMR

BFRUPD	HS	0		:###jhl
	LA	R0,ILCACP-2,,	:pointer to last halfword of source
	LA	R1,BFDEND-2,,	:pointer to last halfword of destination
	LI	R2,10*(((ILCACP-LNKACP)/2)-1)	:number of hw's, etc
	COPY	R0,R2		:copy the bit array of active channels
	JR	R10

	EI	:BFLTMR

::*********************************************************************
::
::	SUBROUTINE:	TEMPRP:
::	FUNCTION:	CHECK REPORTED TEMPERATURE AND REPORT IF IT IS NOT IN
::			THE ACCEPTABLE RANGE.  CALLED FROM G04MIN.
::	CALLING SEQ:	JAL	R11,TEMPRP
::	DESTROYED:	R1
::
::*********************************************************************

      IF	1-NAD68		:not in 68K environment			###wjl
TEMPRP	HS	0		:###JHL
	LH	R1,TMCHFG	:CHECK FLAG TO DISABLE TEMP CHECK
	JNR	R11		:IF SET NON-ZERO (BY USER) DON'T BOTHER
	LB	R1,TEMPER,,	:READ TEMPERATURE
	CHI	R1,TOOHOT	:IS TEMP TOO HIGH?
	JGFS	TMPRPT		:TRY TO SEND REPORT

:	NO REPORT NECESSARY, BUT CHECK INHIBIT FLAG IN CASE IT'S 
:	TIME TO CLEAR IT.
	LH	R1,INHTMP	:READ INHIBIT FLAG
	JGER	R11		:NEGATIVE VALUE INHIBITS
TMPR10	AHI	R1,1		:IF SET, THEN MARK ANOTHER PASS
	STH	R1,INHTMP	:UPDATE INHIBIT FLAG
	JR	R11

:	TEMPERATURE OUT OF RANGE.  SEE IF WE SHOULD REPORT IT.
TMPRPT	HS	0
	LH	R1,INHTMP	:READ INHIBIT FLAG
	JN	TMPR10		:IF NEG, THEN WE'RE INHIBITED
:	IF NOT INHIBITED, SET INHIBIT DELAY AND SEND THE REPORT
	LCS	R1,DLYTMP	:DELAY 14 MORE CALLS--ONE HOUR.	
	STH	R1,INHTMP	:THIS IS INC'ED EACH CALL
:	SEND THE REPORT TO SUP'S LOG
	LHI	R1,NR.TMP	:NODE REPORT #2E 
	STH	R1,SUPMBF	:STORE FOR SUP12 TO FIND
	LB	R1,TEMPER,,	:READ BYTE CONTAINING TEMPERATURE
	ST	R1,SUPMBF+2	:STORE IN REST OF 48 BITS OF MSG BUFFER
	JAL	R10,SUP12,,	:CALL ROUTINE TO SEND TO SUP LOG
EXIT	JR	R11		:RETURN TO G04MIN			###JHL	
      EI	:NAD68

	ENDMO.(LINKER)
	EI	:1-KILLIT
	KILMSG(LINKER)

:	***NOTHING PAST THIS POINT***
		

	SUBTTL  YAKYAK

:		*   *   *   *   * *   *   *   *   *
:		 * *   * *  *  *   * *   * *  *  *
:		  *   ***** ***     *   ***** ***
:		  *   *   * *  *    *   *   * *  *
:		  *   *   * *   *   *   *   * *   *

::#####################################################################
::
::	MODULE:	   Y A K   Y A K
::
::	FUNCTION:  Process data destined for or arriving from neighbor nodes
::
::	REGISTER CONVENTIONS:
::		R0,R1		=  Work Registers
::		R2	=  Buffer number * 4  (Buffer Index)
::		R3	=  "In" pointer for buffer (BE)
::		R4	=  Work Register
::		R5	=  Channel Index (2* Channel Number)  (CHN)
::		R6	=  Relative start of 1/2 wd tables for this link 
::			   (IOTAB  Pointer)
::		R7	=  Relative start of bit arrays for this link
::			   (FLAGS Pointer)
::		R8,R9	=  Link and Work registers
::		R10	=  Physical Record Byte Count (PRC)
::		R11	=  Link Number (KN)
::		R12	=  Index into Physical Record (PRD)
::		R13	=  Record Descriptor Address (CD), also working LRC
::		R14	=  Logical Record Byte count (LRC)
::		R15	=  Link Descriptor address (KD)
::
::	SUBPROCESSES:	RTEAR  RMAKE
::	SUBROUTINES:	RTD RMK  ILC  BPMX
::
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.

	SEG	1

	SUBTTL	YAKYAK (BPMX - Send backpressure)

::*********************************************************************
::
::	SUBPROCESS:	BPMX:/BPMXPR:
::	LOGICALLY PART OF BPM, THIS ROUTINE IS ENTERED FROM THE
::	HALF-SECOND LOGIC AND UPDATES THE BACKPRESSURE BITS ON ALL EXISTING
::	LINKS.  HANDLES T-I LINKS.
::
::*********************************************************************

BPMX	HS	0
	ST	R10,BPMXSR		:SAVE RETURN (IN CASE WE YIELD)
	LHI	R2,LKSIZE-4
BPMX2	L	R3,ALINKS,R2		:COPY ALINKS TO BPMTII 
	ST	R3,BPMTII,R2		:tell RMK time for packet of BP relief
	SIS	R2,4
	JGEBS	BPMX2

	LHI	R4,NKU-1		:UPDATE KERNEL BPS BITS
BPMXK1	LHL	R2,KIOTAB,R4,R4		:BUFF #
	LIS	R1,3			:LOAD BP INDEX
	NR	R1,R2
	NHI	R2,-4
	JE	BPMXK2			:NO CIRCUIT, OK TO RELIEVE BP
	LHL	R3,BCT,R2,		:SET BIT IF CNT<BP CONSTANT
	CLH	R3,CIRSPK,R1,R1
	JGFS	BPMXGT
BPMXK2	SBT	R4,KERBPX
BPMXGT	SIS	R4,1
	JGE	BPMXK1

	L	R10,BPMXSR
	JR	R10			:ALL DONE, RETURN TO G500MS


	SUBTTL	YAKYAK (NEWLNK)

::*********************************************************************
::
::	SUBROUTINE:	NEWLNK
::	FUNCTION:	Determine if we are master or slave for new link.
::	If we are master, adjust LKAPND, LKCSND for channel scan to point to
::	link area in negative ACP, CHS arrays. That causes the FNDKNC routine
::	to find a new channel starting from the highest and working down.
::
::	CALLING SEQ:	JAL  R10,NEWLNK  (called from  ATTLN6 (LINKER))
::	INPUT:		KD
::	CALLS:		JAL  R8,BUBBLE,,
::			JAL  R8,HCLEAR,,
::			JAL  R9,CRQFCR,,
::			JAL  R8,CRYPTO,,
::			JAL  R10,SUP12,,
::	RETURNS:	JR   R10
::
::*********************************************************************

NEWLNK	HS	0
	ST	R10,NEWLNR		:SAVE RETURN
	LB	KN,LKNM,KD		:GET LINK NUMBER
        sbt     kn,borzap,,             :remove any pending outage
	LIS	R0,1
	STB	R0,MASTKN,KN,		:ASSUME WE ARE THE MASTER
	LHL	R0,NDID,KD
	CLHI	R0,MACHNM		:HIGHER MACHINE # IS MASTER FOR T-II
	JL	NLMS10			:OURS IS HIGHER
	LIS	R0,0			:NEIGHBOR'S NUMBER IS HIGHER - SET
	STB	R0,MASTKN,KN,		:MASTKN TO 0, INDICATE WE ARE THE SLAVE
:	IF THIS LINK USED TO BE UP WITH US AS MASTER, THEN WE MUST REVERSE THE
:	POLARITY OF LKAPND, LKCSND.
	LHI	R0,ACP
	SH	R0,LKAPND,KN,KN		:SEE IF POINTER IN POSITIVE ACP
	JL	NLMS20			:YES - NO ADJUSTMENT NECESSARY
	SLLS	R0,1			:ADD (DISTANCE*2) TO CURRENT NEGATIVE
	SIS	R0,4			: POINTER, MINUS 4 TO GET PROPER
	AHM	R0,LKAPND,KN,KN		: POSITIVE ACP, CHS POINTERS
	AHM	R0,LKCSND,KN,KN
	J	NLMS20
NLMS10	LHL	R0,LKAPND,KN,KN
	SHI	R0,ACP			:DETERMINE DISTANCE FROM ACP
	JLFS	NLMS20			:POINTER ALREADY WEST OF ACP
	SLLS	R0,1			:DIFFERENCE TIMES 2
	LCS	R1,4			: MINUS 4
	SR	R1,R0			:REVERSE POLARITY AND
	AHM	R1,LKAPND,KN,KN		: ADJUST
	AHM	R1,LKCSND,KN,KN

NLMS20	JAL	R8,BUBBLE,,		:GET NEW HALF-PAGE OF PERMUTER TABLE
	SKIPAD(NEWLN7)			:COULDN'T ALLOCATE P.T., TAKE LINK DOWN
NEWLN0	LIS	R0,0			:+4 RETURN, CLEAR PAGE #
	STH	R0,RTPAGE,KN,KN
	STH	R0,RMPAGE,KN,KN
	STH	R0,LKSTCT,KN,KN		:CLEAR LINK SATURATED COUNTER
	STH	R0,LKOVLD,KN,KN		:CLEAR OVERLOAD COUNTER
	STH	R0,SNPTYP,KN,KN		:CLEAR LINK SNIP TYPE FIELD
					: (0 IF NO LINK SNIP)
	STH	R0,SHSTAT,KD		:CLEAR SHRINK STATE (SHSTAT, NEDSUS)
	STH	R0,NEDOUT,KD		:CLEAR NUMBER OF NEEDLES OUTSTANDING
	LHI	R2,KSSZ^-1		:HW SIZE OF LINK STATISTICS AREA###OAS
	LA	R1,KS.PCO,KD		:START ZEROING AT KS.PCO OF KD	###OAS
	JAL	R8,HCLEAR,,		:CLEAR LINK STATISTICS		###OAS
	LHI	R0,0C000		:SET BP FLAGS FOR CHN 0 & CHN 1
	LHL	R6,FLDPKN,KN,KN		:START OF ARRAYS FOR THIS LINK
	STH	R0,LNKBPV,R6,
	STH	R0,BPSVCP,R6,

NEWLN1	LR	R2,KN			:COMPUTE # OF CORRESPONDING ILC BUFF
	SLLS	R2,3			:IT'S ILCZBF+8*KN
	LHI	R2,ILCZBF,2
	LIS	R3,3			:BUILD CIRCUIT TO ILC - R3=SPEED
	LHI	CHN,ILCZFL,KN		:R4, CHN ARE ABSOLUTE PORT #'S
	LHL	R4,LKZFKN,KN,KN
	JAL	R9,CRQFCR,,		:BUILD CIRC
	GL	CRQFCR
	AIS	R4,1			:YES, INCREMENT TO CHAN 1 OF THIS LINK
	RBT	R4,ACP,,		:PREVENT CHANNEL FROM BEING USED DUE
:	TO SPECIAL LOGIC IN RMAKE, RTD FOR CHANNELS 0 & 1.
	LCS	R0,1
	SR	R0,R4			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		: FLAG THAT ALSO
NEWLN4	SBT	KN,ALINKS		:LINK NOW ACTIVE
	LHL	R0,NALINK		:UPDATE ACTIVE LINK COUNT
	AIS	R0,1
	CLH	R0,MXLINK		:A NEW HIGH FOR # OF ACTIVE LINKS?
	JLEFS	NEWMXL			:NO
	STH	R0,MXLINK		:YES, STORE NEW PEAK VALUE
NEWMXL	STH	R0,NALINK		:STORE NUMBER OF ACTIVE LINKS
	LIS	R0,2
	STH	R0,ANCHN,KD		:CHANNELS 0 & 1 IN USE, MARK AS ACTIVE

	LR	R0,KN
	EXHR	R0,R0			:LINK # TO UPPER HW
	OH	R0,NDID,KD		: NEIGHBOR NUMBER IN LOWER HALF
	ST	R0,CRYSBF
	LIS	R0,0
	JAL	R8,CRYPTO,,		:REPORT TO XRAY
	HC	CRYE01
	L	R10,NEWLNR		:ALL DONE
	JR	R10

NEWLN7	HS	0			:NO PERMUTER TABLES FOR NEW LINK
	LR	R0,KN
	EXHR	R0,R0			:LINK NUMBER IN UPPER HALF,
	OH	R0,NDID,KD		: NEIGHBOR NUMBER IN LOWER HALF
	ST	R0,CRYSBF
	LIS	R0,0
	JAL	R8,CRYPTO,,		:REPORT TO XRAY
	HC	CRYE03

:	REPORT 'NO PERMUTER TABLES' TO SUPERVISOR LOG
NEWLN8	LR	R0,LN			:##TZ
	SRLS	R0,1
	OHI	R0,8080
	STH	R0,SUPMBF+4		:REPORT INCLUDES 'ESCAPED' LINE NUMBER
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER IN HW2
	LIS	R0,NR.NPT
	STH	R0,SUPMBF		:INDICATE TYPE OF NODE REPORT
	JAL	R10,SUP12,,		:REPORT NO P.T. TO SUP LOG
:	FORCE LINK TO GO OUT SINCE NO CIRCUITS CAN BE BUILT
:       borzap inverted by sdw
	rBT	KN,BORZAP		:TAKE LINK OUT
	L	R10,NEWLNR		:GET RETURN ADDRESS		##TZ
	JR	R10			:AND RETURN			##TZ

	SUBTTL	YAKYAK (TRLINK)

::*********************************************************************
::
::	SUBROUTINE:	TRLINK:
::	FUNCTION:	Link tear down logic.  Link neighbor number and
::	machine number are placed in Fat Zapper message.  Buffers are 
::	cleared and replaced with a Fat Zapper for each circuit on the link.
::	The type of circuit is counted.  If a Link Snip has occurred, the 
::	reason is recorded and diagnostics are sent.  Link Permuter Table
::	space is returned to the Permuter Table Free Pool.
::
::	CALLING SEQ:	JAL  R10,TRLINK  (from DETLIN (LINKER))
::					&(from LEPRKD (LEP0F))
::	INPUT:		KD
::	CALLS:		JAL  R8,CBCLR
::			JAL  R10,TRCR02
::			JAL  R9,W2CI
::			JAL  R10,SUP12
::			JAL  R8,CRYPTO
::	RETURNS:	JR  R10
::
::*********************************************************************
TRLINK	HS	0
	ST	R10,NEWLNR		:SAVE RETURN
	LB	KN,LKNM,KD		:GET LINK NUMBER
	sBT	KN,BORZAP               :inverted (let link come up again #sdw
	TBT	KN,ALINKS		:TEST FOR ACTIVE LINK 		###GT
	JEFS	TRLIN0			:IF LINK NOT ACTIVE, DON'T UPDATE COUNT
	LCS	R0,1			:UPDATE LINK COUNT
	AHM	R0,NALINK
TRLIN0	LIS	R0,0
	STH	R0,ZAPCNT		:INIT COUNT OF CIRCUITS ZAPPED DUE TO
	STH	R0,CMDZCT		: LINK OUT AND COMMAND CIRCUITS ZAPPED
	LHL	R6,TBDPKN,KN,KN
	LHL	R7,FLDPKN,KN,KN		:BEGINNING OF LINK'S BIT ARRAYS
	LHL	CHN,NCHN,KD		:NUMBER OF CHANNELS ALLOCATED TO LINK
	AR	CHN,CHN			: * 2...


	LHL	R0,NDID,KD
	EXHR	R0,R0
	OHI	R0,MACHNM		:NODE PAIR CAUSING CRQ'S TO BE ZAPPED
	ST	R0,RFAT			:(PASSED WITH FAT ZAPPERS)
TRLIN1	LHL	R2,NIOTAB-2,R6,CHN 	:GET CIRCUIT'S BUFFER INDEX
	NHI	R2,-4
	JE	TRLIN3			:NO CIRCUIT THIS CHANN
	CLHI	R2,CIRZBF		:IF AN INTERNODE CIRCUIT...
	JGEFS	TRLIN2			:JUST CLEAR IT
	JAL	R8,CBCLR,,
	XHI	R2,4
	JAL	R8,CBCLR,,
	LIS	R0,0
	STH	R0,NIOTAB-2,R6,CHN
	J	TRLIN3

TRLIN2	LHI	R1,ZAPPF
       if       t2gate!acct
	lis	r0,aalr03
	sth	r0,aareas
       ei       :
	JAL	R10,TRCR02,,		:INITIATE FAT ZAPPER
	GL	TRCR02			: UNLESS WE'RE TERMINATION
       if       t2gate!acct
	lis	r0,0
	sth	r0,aareas
       ei 
	LH	R0,TRCSV2		:FAT ZAPPER?
	JLFS	TRLINF			:NO
	LH	R0,BF,R2,		:BUFFER RETURNED?
	JLFS	TRLINF			:YES - CAN'T WRITE INTO IT...
	LHL	R1,RFAT
	JAL	R9,W2CI,,		:PASS OFFENDING NODE PAIR
					: BEHIND FAT ZAPPER
	LHL	R1,RFAT+2
	JAL	R9,W2CI,,

TRLINF	HS	0
	LIS	R0,1
	AHM	R0,ZAPCNT		:ANOTHER CIRCUIT ZAPPED
	LR	R1,CHN
	SIS	R1,2
	SRLS	R1,1			:RELATIVE CHANNEL THIS LINK
	TBT	R1,CMDCTS,R7,		:IS THIS A COMMAND CIRCUIT?
	JEFS	TRLIN3			:NO
	AHM	R0,CMDZCT		:YES - COUNT IT FOR REPORT
TRLIN3	SIS	CHN,2			:DECREMENT TO NEXT CHANNEL
	JG	TRLIN1

:	DONE ZAPPING LINK'S CIRCUITS...NOW DO LINK-OUT BOOKKEEPING
	LHL	R0,SNPTYP,KN,KN		:WAS THIS LINK BORI-ZAPPED?
	JE	TRLIN4			:NO
	STH	R0,SUPMBF+4		:YES - SAVE REASON FOR REPORT
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER,
	OI	R0,(NR.SNP^10)+8000	: COMBINE WITH REPORT TYPE
	ST	R0,SUPMBF
	JAL	R10,SUP12,,		:SEND LINK SNIP NODE REPORT AND CRYPTO
	LIS	R0,1
	AHM	R0,LSNIPS		:COUNT LINK SNIPS

TRLIN4	LR	R0,KN
	EXHR	R0,R0			:GET LINK NUMBER IN HI-ORDER HW
	OH	R0,NDID,KD		: AND COMBINE WITH NEIGHBOR NUMBER
	ST	R0,CRYSBF
	JAL	R8,CRYPTO,,
	HC	CRYE02			:REPORT LINK OUT TO XRAY
	LHL	R10,ZAPCNT		:DID WE ZAP ANY USER CIRCUITS?
	JE	TRLINZ			:NO - DON'T MAKE TRIVIAL REPORT TO LOG
	OHI	R10,8000
	STH	R10,SUPMBF+4
	OHI	R0,8000
	STH	R0,SUPMBF+2		:REPORT NEIGHBOR # FOR ZAPPED CIRCUITS
	STH	KN,SUPMBF+6		:SAVE LINK NUMBER FOR CRYPTOGRAM
	LIS	R0,NR.PLI
	STH	R0,SUPMBF		:SIMILAR TO TYMNET-I NPLI PROBE REPORT
	JAL	R10,SUP12,,		:MAKE NODE REPORT TO SUP LOG
	LHL	R0,CMDZCT		:COUNT OF COMMAND CIRCUITS ZAPPED
	JEFS	TRLINZ			:NONE
	OHI	R0,8000
	STH	R0,SUPMBF+4
	LHI	R0,NR.CCZ		:COMMAND CIRCUIT ZAP COUNT NODE REPORT
	STH	R0,SUPMBF
	JAL	R10,SUP12,,
TRLINZ
	LH	R0,ONDID,KD		:ONDID IS ZERO IF THIS IS AN XLINK,
	STH	R0,NDID,KD		: US TO RELEASE XLINK LINK DESCRIPTOR
TRLNZ1
:	GIVE UP PERMUTER TABLE SPACE. PERMUTER TABLE SPACE IS ALLOCATED
:	IN HALF-PAGES. T-I AND T-1.5 LINKS MAY HAVE ADJUSTED NCHN DOWN DUE
:	TO RECEIPT OF BACKPRESSURE RECORD FROM NEIGHBOR (SEE BPMV).
:	DETERMINE THE NUMBER OF HALF-PAGES ALLOCATED FOR T-I OR T-1.5 LINK,
:	SO THAT THE SAME NUMBER MAY BE FREED UP.

	LHL	R10,NCHN,KD
	JEFS	TRLIN5			:# OF CHANNELS NOT YET DETERMINED
	THI	R10,7F			:NUMBER CHANNELS MULTIPLE OF 80?
	JEFS	TRLIN7			:YES
TRLIN5	TBT	KN,ALINKS		:IS LINK ACTIVE, IF NCHN = 0?	###GT
	JEFS	TRLIN7			:IF NCHN=0 & LINK NOT ACTIVE, THERE ARE
					:NO HALF-PAGES TO FREE UP 	###GT
::	LHL	R10,NCHKN,KN,KN		:NO - DETERMINE NUMBER OF HALF-PAGES
					:This T-I stuff not used 	###ev
	CLHI	R10,80			:	ALLOCATED BY NEWLNK
	JGFS	TRLIN6			:2 HALF-PAGES ALLOCATED IF NCHKN > 80
	LHI	R10,80			:1 HALF-PAGE ALLOCATED - SET # CHANS=80
	JFS	TRLIN7
TRLIN6	LHI	R10,100			:SET # CHANS TO 100 SINCE 2 HALF-PAGES
					:ALLOCATED TO LINK WITH >8 GROUPS
TRLIN7	LIS	R0,0
	SR	R0,R10			:GET NEGATIVE NUMBER OF CHANNELS IN R0
	LR	R3,R0
	SRA	R3,3			:# OF CHANS/8 = BYTE DISPLACEMENT FOR
					:LINK BIT ARRAYS
	AR	R0,R0			:FOR HALFWORD POINTER FIELD
	AHM	R0,EBDPKN,KN,KN		:DECREMENT END OF PERMUTER TBLE POINTER
	AHM	R3,LKFGND,KN,KN		:DECREMENT 'LAST HALFWORD IN ARRAY'
	AHM	R3,LKSVND,KN,KN		: FIELDS 
	AHM	R3,LKBPND,KN,KN
	LB	R0,MASTKN,KN,		:ARE WE MASTER ON THIS LINK?
	JNFS	TRLIN8			:YES, END PTR STAYS THE SAME
					: FOR NEG. ACP, CHS
	AHM	R3,LKAPND,KN,KN		:DECREMENT ACP END AND
	AHM	R3,LKCSND,KN,KN		: CHS END
TRLIN8	LR	R0,R10			:NUMBER OF CHANNELS DIVIDED BY 128
	SRLS	R0,7			: YIELDS # OF HALF PAGES BEING RETURNED
	AHM	R0,NUMPAG,,		: TO PERMUTER TABLE FREE POOL
	LIS	R0,0
	STH	R0,NCHN,KD		:NO CHANNELS FOR OUT LINK
	RBT	KN,ALINKS		:NOW WE CAN DECLARE LINK OUT	###GT
:       here to restore windowsize.  Could be reduced from original by
:       matchdown or xray WZ cmd.  XRAY WZ cmd size could be reduced
:       further by a matchdown.					###sdw
       IF       WSZTST			:restore wsiz from matchdown
	LHL	R1,WSZKN,KN,KN		:get original window size
	CLB	R1,WSIZ,KD		:is current okay?
	JE      TRLINW			:yes, nothing to do
	STB	R1,WSIZ,KD		:is link's window size
	JAL	R9,MCHDWN		:specified may be less than original
TRLINW
	 				:and restore if matchdown occurred
       EI       :WSZTST
	L	R10,NEWLNR
	JR	R10

	SUBTTL	YAKYAK (CHRTRC - Character Trace)

::*********************************************************************
::
::	SUBROUTINE:	CHRTRC:
::	FUNCTION:	CHARACTER TRACE ROUTINE.
::	CALLED BY RTD OR RMAKE TO RECORD DATA
::	TRAVELING ON A CHANNEL WITH A SET BIT IN 'TRCHAN' BIT ARRAY. THE
:: 	CALLING ROUTINE PASSES THE I/O INDICATOR IN R0 (-2 IF
::	RTD, -1 IF RMAKE), THE ABSOLUTE CHANNEL NUMBER IN R1, THE POINTER
::	TO THE LOGICAL RECORD IN R9, AND THE LOGICAL RECORD COUNT IN LRC.
::
::	RTD AND RMAKE CALL CHRTRC FOR EACH LOGICAL RECORD DETECTED FOR CHANNELS
:: 	BEING TRACED. THE CHRTRC ENTRY CONSISTS OF A FIXED LENGTH HEADER AND
:: 	VARIABLE LENGTH DATA (BASED ON LRC). THE HEADER FORMAT IS AS FOLLOWS:
::		HW1 - I/O INDICATOR
::		HW2 - ABSOLUTE CHANNEL NUMBER
::		HW3 - FASTC
::		HW4 - LOGICAL RECORD LENGTH (LRC)
:: 	AND IS FOLLOWED BY THE DATA. EACH ENTRY BEGINS ON A DOUBLEWORD BOUNDARY
:: 	IN 'TRRING', WHICH IS A CIRCULAR RING INDEXED BY 'TRRIX'.
::
::	CALLING SEQ:	JAL  R10,CHRTRC
::	INPUT:		R0,R1,R9,LRC
::	PRESERVED:	R1,R9,LRC
::	DESTROYED:	R0
::	RETURNS:	JR  R8
::
::*********************************************************************

CHRTRC	HS	0
	SYAD(CHRTRC)
	NOPR	0,R8			:PATCH TO '0308' TO TURN OFF TRACE
	STM	PRD,TRREGS		:SAVE SOME REGS
	LHI	TC,TRRSIZ-1		:POWER OF 2 RING WRAP MASK
	LHL	PRD,TRRIX		:GET CURRENT RING INDEX
	STH	R0,TRRING,PRD,		:STORE I/O INDICATOR AND
	STH	R1,TRRING+2,PRD,	: ABSOLUTE CHANNEL NUMBER
	LH	R0,FASTC+2,,
	STH	R0,TRRING+4,PRD,	:STORE CURRENT TIME
	STH	LRC,TRRING+6,PRD,	:STORE LOGICAL RECORD LENGTH
	AIS	PRD,8
	NR	PRD,TC

:	NOW MOVE LOGICAL RECORD TO TRRING. MUST MOVE A BYTE AT A TIME
:	SINCE HALFWORD ALIGNMENT NOT GUARANTEED.

CHRT10	LB	R0,0,R9			:GET BYTE FROM LOGICAL RECORD AND
	STB	R0,TRRING,PRD,		: MOVE IT TO RING
	AIS	R9,1
	AIS	PRD,1			:INCREMENT POINTERS
	NR	PRD,TC
	SIS	LRC,1			:DECREMENT COUNT
	JGBS	CHRT10			:MORE TO DO...

	AIS	PRD,7			:ROUND INDEX UP TO NEXT DOUBLEWORD BND
	NHI	PRD,TRRSIZ-8
	STH	PRD,TRRIX		:SAVE TRRING INDEX
	lhl	r0,xtdato		:any ports doing auto display
	jefs    chrt98
	lhi	r0,1f-pxray
	sbt	r0,squeue		:msg arrived, sched xray to disp it
	lhl	r0,xusiua
	sth	r0,xquem,,
chrt98
	LM	PRD,TRREGS		:RESTORE REGS AND
	JR	R8			: RETURN

	SUBTTL	YAKYAK (Dispatch Tables/Common Crashh locations)

::*********************************************************************
::
::	PFMRTD:	DISPATCH TABLE FOR PERFORMANCE MONITORING CONTROL CHARACTERS
::		MOVING ON PASSTHROUGHS, DETECTED IN RTEAR
::
::*********************************************************************

PFMRTD	WC	RTDXLA		:XLAX	   03-20
	WC	RTDXAK		:XLAX ACK  03-21
	WC	RTDALL		:TIMER	   03-22
	WC	RTDALL		:TIMER ACK 03-23
	WC	RTDALL		:REJECT	   03-24
	WC	RTDALL		:WILD CARD 03-25
	WC	RTDALL		:WILD CARD 03-26
	WC	RTDALL		:WILD CARD 03-27
	WC	RTDALL		:WILD CARD 03-28
	WC	RTDREJ		:LOG II (illegal for perf to receive) 0329
	WC	RTDREJ		:LOG II (illegal for perf to receive) 032A
	WC	RTDREJ		:LOG II (illegal for perf to receive) 032B
PFMRTZ	EQ	(.-PFMRTD)/4	:NUMBER OF DEFINED PERFORMANCE MONITORING CHARS

::*********************************************************************
::
::	PFMTRM:	DISPATCH TABLE FOR PERFORMANCE MONITORING CHARACTER PAIRS
::		ARRIVING AT THE TERMINATING END OF A CIRCUIT
::		(INTERNAL OR TO A T-1 NODE)
::
::*********************************************************************

PFMTRM	WC	RTDXL1		:XLAX		03-20
	WC	RTDSNK		:XLACK ACK      03-21
	WC	RTDTM1		:TIMER		03-22
	WC	RTDSNK		:TIMER ACK      03-23
	WC	RTDSNK		:REJECT		03-24
	WC	RTDREJ		:WILD CARD      03-25
	WC	RTDREJ		:WILD CARD      03-26
	WC	RTDREJ		:WILD CARD      03-27
	WC	RTDREJ		:WILD CARD      03-28
	WC	RTDREJ		:LOG II NEEDLE  03-29
	WC	RTDREJ		:Log 2 body     03-2A
	WC	RTDREJ		:Log 2 tail     03-2B
PFMMAX	EQ	PFMRTZ+1F	:UPPER LIMIT OF VALID PERF MONITORING CHARS
PFMRTB	EQ	PFMRTD-80	:PFMRTD ADDRESS WITH PERF. MONITOR BIAS REMOVED
PFMTRB	EQ	PFMTRM-80	:SAME FOR TERMINATION DISPATCH TABLE

::*********************************************************************
::
::	NEGBCR:	COMMON CRASH LOCATION FOR BFLTSV (BUFFERLET CHARS IN USE COUNT)
::	DETECTED NEGATIVE. ROUTINE IS CALLED BY JAL R7, SO R7 CONTAINS
::	THE LOCATION OF THE CRASH CAUSE. ###OAS
::
::*********************************************************************

NEGBCR	HS	0
	CRASH.(.NEGBF)

::*********************************************************************
::
::	NEGHCR:	COMMON CRASH LOCATION FOR HBFTSV
::	(HIST BUFFERLET CHARS IN USE COUNT) DETECTED NEGATIVE.
::	ROUTINE IS CALLED BY JAL R7, SO R7 CONTAINS
::	THE LOCATION OF THE CRASH CAUSE. ###OAS
::
::*********************************************************************

NEGHCR	HS	0
	CRASH.(.NEGHB)

	SUBTTL	YAKYAK (RTEAR - Record TEARdown)

::*********************************************************************
::
::	SUBPROCESS:	RTEAR:
::	FUNCTION:	RTEAR checks to see if a link is awaiting a BORI
::	Zap.  If not, it looks up the length of the packet based on PRD.
::	Then it points to the first logical record and calls RTD.
::	It returns to update LRT and make entries in the Sync Line Trace
::	Table.  A check is made to provide equal link service.  
::	CALLING SEQ:	J RTEAR  (called directly from SPIDER)
::	INPUT:		R2 contains link number
::	CALLS:		JAL  R9,RTD
::			JAL  R8,TSBMRK
::	RETURNS:	J  BIDDRT
::
::*********************************************************************

xicrtd  hc      ticrtd                  :rtd time limit
        syad(xicrtd)

rtears	lhi	r0,2*((nlinks-1)/10)+lktear
	lhi	r1,2*((nlinks-1)/10)+borzap     :dont consider links going down
	lhi     kn,(((nlinks-1)/10)*10)!0f
	sth     kn,didall		:have serviced each link once
	arand   r0,kn			:find an unserviced link
	jfs	rtearj			:link serviced, but can do it again 
        j       spdrmk,,


RTEAR	HS	0
	LIS	R0,0			:check all links before checking time
	STH	R0,DIDALL		:to ensure equal minimum service
	L	R0,FASTC,,		:get time
	AH	R0,XICRTD		:number of ticks for RTEAR	###sdw
	ST	R0,DIDTIM
RTEARJ  HS      0			:tear more than 1 packet per link if
	 				:time permits
Q       EQ      0			:set to service all links
	 RE     LKSIZE/4
	L	R0,LKTEAR+4*Q		:links with data
	ST	R0,LKSRVD+4*Q		:just a few STs, not worth a loop
Q       EQ      Q+1
	 ER
rtear5	L	R0,FASTC,,
	S	R0,DIDTIM		:time for us to dismiss
	jle	rtear0			:continue making packets
	lh	r1,didall		:everyone get serviced?
	jg	spdrmk,,	:yes, return to spider
	jal	r0,exyld,,		:no, come on back after doing whatever
        ts      didall                  :negative, took timout
        lh      r0,xicrtd
        a       r0,fastc,,              :next timeout expiring
        st      r0,didtim
:       do each link before doing any link again, thus it the service array is
:       0 then check original to see if any serviced have more data.
:       using arands is a whole lot faster than searching for a nonzero
:       word to then jump to a jffo.

:       note links requires LNKSVRD and BORZAP to be both true.
:       that is why borzap has been inverted elsewhere
rtear0  lhi	r0,2*((nlinks-1)/10)+lksrvd
	lhi	r1,2*((nlinks-1)/10)+borzap
	lhi     kn,(((nlinks-1)/10)*10)!0f
	arand   r0,kn			:find an unservied link
	jfs	rtearw
        lh      r0,didall
        jge     rtears                  :didn't take a timout
        j       spdrmk,,
rtearw  rbt     kn,lksrvd
	lR	r1,KN
        ar      r1,r1
	L	KD,KDKN,r1,r1		:GET DESCRIPTOR POINTER
	LHL	CD,NRTR,KD		:PTR TO NEXT RECORD TO TEAR
	LH	R1,LRT,KD		:IF REC # = LRT+1, WE HAVE A RECORD
	AIS	R1,1
	CHVR	R1,R1
	CLH	R1,RECN,CD
	JEFS	RTEAR1
RTEARZ	RBT	KN,LKTEAR		:NO MORE, MARK THIS LINK AS SERVICED
	J	RTEARE			:see if we are done

RTEAR1	LHL	R2,RECN,CD		:GET RECORD NUMBER TO TEAR
	NHI	R2,PKTMSZ		:MASK WITH BUFFER SIZE
	AR	R2,R2			:FORM HW INDEX
	LH	R0,FASTC+2,,		:CURRENT TIME
	SH	R0,INTIME,KD,R2		:GET INTERVAL BETWEEN SYLVER AND NOW
	JGEFS	RPERF1			:NO WRAP
	AI	R0,10000
RPERF1	AM	R0,KS.SRC,KD		:AND ADD INTO RUNNING SUM
	L	PRD,BREC,CD		:TYMNET-II - PTR TO RECORD
	Lb	PRC,0,PRD		:SET PRC=PHYS BYTE CNT
	NHI	PRC,0F
	LB	PRC,SYTWCN,PRC
	AIS	PRC,4			:INCLUDE CHECKSUM AND COUNT
	AM	PRC,KS.PCI,KD		:COUNT PACKET CHARACTERS INPUT
	SIS	PRC,7			:DON'T INCLUDE CHECKSUM, HEADER FOR RTD
	AIS	PRD,3			:INDEX PRD TO FIRST LOG REC

:	> > > > > > > > > > > > > > > > >
	JAL	R9,RTD			: go tear down
:	< < < < < < < < < < < < < < < < <

	LIS	R0,1			:RECORD TORN, UPDATE LRT
	AHM	R0,LRT,KD
	IF	TSTSZE
	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER AND 
	CLH	R0,TSLINK		: TEST FOR LINK OF INTEREST
	JN	RTEART			:NO - CONTINUE
	JAL	R8,TSBMRK		:SET UP NEW EVENT ENTRY
	LIS	R0,TS.RTD		:GET EVENT TYPE (RECORD TORN)
	STB	R0,TSBTBL,R7		: AND STORE IN ENTRY
	L	R8,BREC,CD
	LHL	R0,0,R8		:GET HEADER HALFWORD
	STH	R0,TSBTBL+2,R7		: AND STORE
	LB	R0,2,R8
	STB	R0,TSBTBL+4,R7		:THIRD BYTE RECORD NUMBER
	LHL	R0,LAS,KD
	STB	R0,TSBTBL+1,R7		:STORE LAST ACK SENT
RTEART	EI	:TSTSZE
	LHL	R0,RLNK,CD		:INDEX NRTR
	STH	R0,NRTR,KD

	LR	CD,R0			:PTR TO NEXT RECORD TO TEAR	##TZ
	LH	R1,LRT,KD		:IF REC # = LRT+1, WE HAVE A RECORD##TZ
	AIS	R1,1			:##TZ
	CHVR	R1,R1			:##TZ
	CLH	R1,RECN,CD		:DO WE HAVE ANOTHER RECORD?	##TZ
	JEFS	RTEARE			:YES, CONTINUE			##TZ
	RBT	KN,LKTEAR		:MARK THIS LINK COMPLETED	##TZ
RTEARE  LHL	R0,SQUEUE
	THI	R0,1^(pckzb-10) 	:buffer zap pending?
	JE	RTEAR5
	JAL	R0,EXYLD,,		:go do bufzap
	J	RTEAR5			:back to another link

	SUBTTL	YAKYAK  (RTD)

::*********************************************************************
::
::	SUBROUTINE:	RTD
::	FUNCTION:	Tears down all logical records in a physical 
::	record.  If logical records exist in a packet, RTD does a range
::	check on the channel number.  If chan # in range then checks 
::	throughput level and updates counter and does trace if necessary.
::	Then RTD copies from logical record to buffer, detects special
::	characters and link control messages, and acts accordingly.  
::	Shrinks the link if necessary.  Processes incoming  needles.
::	Bubbles if necessary.  If serious errors occur, the link
::	will be snipped.
::	CALLING SEQ:	JAL  R9,RTD
::	INPUT:		R2(KN) = Link Number
::			R10(PRC) = Physical Record byte count
::			R12(PRD) = Pointer to Physical Record
::		
::	CALLS:		JAL  R8,CHRTRC	: Make trace entry in TRRING
::			JAL  R9,W2CI	: Write 2 chars into buffer
::			JAL  R8,WCFRST	: Chain first bufferlet into buffer
::			JAL  R7,NEGBCR	: Crash
::			JAL  R0,BUFZAP	: Zap buffer specified by R2
::			JAL  R0,WRE	: Link reserve tank to freelist
::			JAL  R9,RSTRIP	: Return bufferlets to free pool
::			JAL  R9,GOBBLN	: Eat buffer, put Gobbler in
::			JAL  R8,WCI	: Write character into bufffer
::			JAL  R8,WCD	: Prefix character into buffer
::			JAL  R10,SUP12L	: Node report Bubble or Shrink
::			JAL  R9,CRYPTO	: Generate Xray diagnostic
::			JAL  R9,ZAPXNG	: Nongobbling Zapper detected
::			JAL  R9,ZAPHRD	: Force hard zap of circuit
::			JAL  R9,GFCBUF	: Get buffer index from FREELB
::			JAL  R9,CRQHCR	: Create half a circuit
::			JAL  R10,TRCIRC	: Tear circuit & reqest rebuild
::			JAL  R10,SUP08	: T-I Zapper sent or received
::			JAL  R8,PCIS	: Peak at first character
::			JAL  R8,PCI	: Peak at next character
::			JAL  R8,CBCLR	: Clear a buffer
::			JAL  R8,SPEED	: Expedite Zappers and Gobblers
::			JAL  R8,CHKTRM	: Test for terminating circuit
::			JAL  R8,RBFLTS	: 
::			JAL  R8,RETBLT	: Return first bbflt to free list
::			JAL  R9,RBCOUT	:
::			JAL  R7,NEGHCR	: Crash
::			JAL  R10,TRCRFT	: Tear circuit and request rebuild
::			JAL  R9,CRQALT	: Signal CRQ of Needle
::			JAL  R9,PHWI	: Peek at next halfword
::			JAL  R8,WCNXT	: Chain another bufferlet
::			JAL  R8,BUBBLE	: Link Bubble
::
::	RETURNS:	JR  R9
::
::*********************************************************************

	DEFAULT(TRKLVA,1)		:TPC-A ALWAYS GUSHING
	DEFAULT(TRKLVB,2)
	DEFAULT(TRKLVC,3)
	DEFAULT(TRKLVD,4)
TRKLVL	HC	TRKLVA,TRKLVB,TRKLVC,TRKLVD


RTD	HS	0
	ST	R9,RTMXSV		:SAVE RETURN
	LHL	R6,TBDPKN,KN,KN		:PTR TO IOTAB FOR THIS LINK
	LHL	R7,FLDPKN,KN,KN		:POINT TO HALFWORD WHERE THIS LINK'S
					: FLAGS BEGIN
        lis     r0,1
        am      r0,rtdpkr               :packets torn

RTD1	CLHi	PRC,1		:IS PACKET RECORD COUNT DEPLETED?
	JL	RTDXIT			:YES, NO MORE LOGICAL RECS IN PACKET
:	PROCESS THIS RECORD 
	LB	LRC,0,PRD		:GET LOGICAL REC COUNT
	JE	RTDXIT			:END-OF-PACKET INDICATION
	LB	CHN,1,PRD		:GET CHANNEL NUMBER FROM PACKET
	AIS	PRD,2			:BUMP PTR PAST CHAN # AND COUNT.
	THI	LRC,80			:IF LRC>7F, IT'S A PRIORITY MESSAGE
	JN	RTDPRI			:YES
        lis     r0,1
        am      r0,rtdlrr               :logical records torn

	SHI	PRC,2,LRC		:NEW PRC = OLD PRC-LRC-2
	AH	CHN,RTPAGE,KN,KN	:ADD CHANNEL PAGE #

:	CONSISTENCY CHECK - RANGE CHECK CHANNEL NUMBER
	LHL	R0,EBDPKN,KN,KN		:GET END OF TABLES POINTER AND
	SR	R0,R6			: SUBTRACT BEGINNING OF TABLE ADDRESS
	SRLS	R0,1			:NUMBER OF CHANNELS THIS LINK
	CR	CHN,R0
	JGE	RTDBIG			:CHANNEL NUMBER TOO LARGE,
					: INVESTIGATE FURTHER

:	GOT A LOGICAL RECORD WITH A REASONABLE CHANNEL NUMBER. PROCEED
:	WITH LOGICAL RECORD TEARDOWN

:	SEE IF DATA 'GUSHING' OR 'TRICKLING' IN FOR THIS CHANNEL...
RTD01	HS	0		:SEE IF DATA GUSHING OR TRICKLING BASED ON TPC
        lr      r2,chn
	AR	CHN,CHN			:make halfword channel index	###wjl
       if       1-notrik                :if trickle allowed
	LHL	R1,NIOTAB,R6,CHN	:GET DESTINATION BUFFER #
	NHI	R1,3			:SPEED BITS ONLY
	CLH	LRC,TRKLVL,R1,R1	:COMPARE TO APPROPRIATE TRICKLE VALUE
	JLFS	RTD02
	SBT	r2,GUSH,R7,		:DATA GUSHING IN ON THIS CHANNEL
	JFS	RTD04
RTD02	SBT	r2,TRIKLE,R7,		:DATA MERELY TRICKLING IN
       else     :always gushing
        sbt     r2,gush,r7,
       ei       :1-notrik
RTD04	AM	LRC,KS.LCI,KD		:COUNT LOGICAL CHARACTERS INPUT
RTD15	LHL	R2,NIOTAB,R6,CHN	:DESTINATION BUFFER # FOR THIS CHANNEL
	NHI	R2,-4			:STRIP OUT THE CIRCUIT SPEED BITS
	JE	RTDUAC			:UNASSIGNED CHANNEL
					: - EITHER NEEDLE OR BAD DATA
RTD6	HS	0			:				###GT
	IF	REBILD
	AM	LRC,VSEQN,R2,		:UPDATE THE RECEIVE SEQUENCE NUMBER
RTD6A	HS	0			: - NOTE THAT NEEDLES ARE NOT COUNTED
	EI	:REBILD

:	TEST FOR CHARACTER TRACING FOR THIS CHANNEL
	LHL	R1,BF,R2,		:DESTINATION ABSOLUTE CHANNEL NUMBER
	TBT	R1,TRCHAN,,		:TRACING DESIRED?
	JEFS	RTD610			:NO
:	TRACING FOR THIS CHANNEL. R9 SHOULD POINT TO BEGINNING OF LOGICAL
:	RECORD, R0=-2 INDICATES RECORDING DATA INTO NODE...
	LR	R9,PRD			:POINT TO FIRST BYTE OF DATA
	LCS	R0,2			: -2 =>INPUT
	JAL	R8,CHRTRC		:MAKE TRACE ENTRY FOR THIS LOGICAL REC

RTD610	HS	0
	IF	BFLTMR			:check for sending of buff timing pairs
	LHL	R1,BF,R2,		:scheduled by dest chan #
	SHI	R1,LNKZFL		:schedule array is for link chans only
	JLE	RTD620			:don't do it if bound for internal chn
	SBT	R1,BFDARY,,		:set and test scheduling bit
	JN	RTD620			:set (inactive) already,no pair for now
	TBT	R1,CMDCTS,,		:don't send pair on a cmd channel
	JNFS	RTD620
:	send a buffer delay timimg pair (COMET)
	LHI	R1,COMET
	JAL	R9,W2CI,,		:put pair in buffer (no escapes)
	GL	W2CI
	LHL	R1,FASTC+2,,
	JAL	R9,W2CI,,		:followed by halfword of FASTC
RTD620	HS	0	
	EI	:BFLTMR
	L	R3,BE,R2,		:LOAD THE BUFFER IN POINTER
	JNFS	RTD2			:BUFFERLET ALREADY ALLOCATED
	JAL	R8,WCFRST,,		:EMPTY BUFFER, GET FIRST BUFFERLET
	GL	WCFRST
	SIS	R3,1			:SET UP R3 (BE) FOR MICROCODE

:	HERE TO PROCESS A LOGICAL RECORD
:
:	RTD COPY MICROINSTRUCTION:
:		R1  = scratch
:		R14 = LRC = byte count of characters to move
:		R12 = PRD = address of the logical record
:		R3  = BE (address of the last character input)
:	NOTE THAT THE RTD COPY INSTRUCTION WAITS UNTIL IT HAS 2 BYTES
:	TO MOVE BEFORE IT ACTUALLY WRITES INTO THE BUFFERLET. THIS
:	MEANS THAT IF A SPECIAL CHARACTER IS ALSO THE LAST CHAR IN A
:	LOGICAL RECORD, IT MUST BE EXPLICITLY STORED WITH A STB INSTRUCTION
:	SINCE THE MICROCODE MAY NOT HAVE DONE SO.
:
:START	LB	RA,0,PRD	:GET NEXT BYTE 
:	INC	PRD	:ADVANCE PRD TO NEXT BYTE IN RAW PACKET (PRD=R12)
:	INC	BE		:ADVANCE BE TO SLOT WHERE BYTE WILL GO
:	END OF BUFFERLET?
:	YES => GET NEXT ONE, PROCEED AT 'NEXT'
:NEXT	'STORE' RA,0,BE		:STORE ONLY ON EVEN BE, USING HW WRITE
:	SPECIAL CHAR? (0-3)
:	IF YES, BRANCH OUT
:	DEC	LRC		:DECREMENT COUNT OF RAW BYTES REMAINING
:	LRC=0?
:	IF NOT, GOTO START
:	ELSE DONE

       IF	1-NAD68		:NAD or Nada				###wjl

RTD2	LHL	R0,0,R3			:SET UP SCRATCH REGISTER
	EXHR	R0,R0			: FOR THE MICROCODE
	LHL	R1,0,PRD
	OR	R1,R0

RTD2A	HC	3B1E			:RTD Copy 1 - SCRATCH REG, BYTE COUNT 
RTD2B	HC	3C1E			:RTD Copy 2 - RESUME PROCESSING HERE
	HC	RTDNXT-RTD2B		:TO GET NEXT BUFFERLET
	HC	RTDC00-RTD2B		:TO HANDLE CHARACTER PAIRS
	HC	RTDC01-RTD2B		:TO HANDLE PREFIX CODES
	HC	RTDC2-RTD2B		:TO HANDLE GOBBLERS
	HC	RTDC3-RTD2B		:TO HANDLE ZAPPERS

       ELSE	:NAD68		:NAD to 68020 assembler			###wjl
RTD2					:no set up required		###wjl
RTD2A	LB	R1,0,PRD		:move a single byte of data	###wjl
	AIS	PRD,1			:increment PRD			###wjl
	AIS	R3,1			:increment BE (the IN pointer)	###wjl
	THI	R3,CBSZ-1		:end of bufferlet?		###wjl
	JNFS	RTD22			:no				###wjl
	JAL	R8,NXTBLT		:yes, get next bufferlet	###wjl
RTD22	CLHI	R1,3			:test for TYMNET control chars	###wjl
	JGFS	RTD4			:data				###wjl
	J	RTDTYM			:control char			###wjl
RTD4	STB	R1,0,R3			:deposit the char		###wjl
	SIS	LRC,1			:decrement LRC (the byte count) ###wjl
	JG	RTD2			:LRC=0?				###wjl

       EI	:1-NAD68		:				###wjl

:	WE'VE TORN DOWN A LOGICAL RECORD
RTD3 	HS	0
	ST	R3,BE,R2,		:COME HERE WHEN DONE -- SAVE END ADDR
	IF	DB.DEB
	LR	R2,R2			:VERIFY BUFFER INDEX INTEGRITY
	JN	RTD1			:NON-ZERO - MUST BE GOOD...
	DBOOPS
	ELSE	:NOT DB.DEB
	J	RTD1			:DONE WITH THIS LOGICAL RECORD
	EI	:DB.DEB

       IF	NAD68		:NAD to 68020 assembler			###wjl

RTDTYM	CLHI	R1,2			:TYMNET control characters	###wjl
	JG	RTDC3			:03-type character pair		###wjl
	JE	RTDC2			:02 - T-I gobbler		###wjl
	CLHI	R1,1			:				###wjl
	JE	RTDC01			:01 - Virtual Terminal Signal Code#wjl
	J	RTDC00			:00 - escape char for data	###wjl

       ELSE	:not NAD68	:NAD or Nada only			###wjl

:	HERE TO SET UP A NEW BUFFERLET
RTDNXT	HS	0
	JAL	R8,NXTBLT
	IF	DB.DEB
	J	RTD2B
	ELSE	:
	JBS	RTD2B
	EI	:DB.DEB
       EI	:NAD68

::*********************************************************************
::
::	SUBROUTINE:	NXTBLT:
::	FUNCTION:	ALSO USED BY HISTORY-MAKER IN RMAKE
::	CALLING SEQ:	JAL	R8,NXTBLT
::
::*********************************************************************

NXTBLT	HS	0
	THI	R3,CBSZ-1		:REALLY END OF BLFET?
	JNR	R8			:nope, return
	LHI	R0,CBSZ-cbptsz		:COUNT OF BYTES IN BUFFERLET

	IF	REBILD
	CI	R2,HBUFN		:IS R2 A HISTORY BUFFER INDEX	###OAS
	JLFS	RTDNX0			:NO				###OAS
	AM	R0,HBFTSV		:YES, UPDATE HISTORY BUFFER COUNT##OAS
	JGEFS	RTDNX0			:CHECK FOR HBFTSV GOING <0	###OAS
	JAL	R7,NEGHCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RTDNX0	HS	0
	EI	:REBILD
	AM	R0,BFLTSV		:UPDATE COUNT OF BUFFERLETS IN USE
	JGEFS	RTDNX9			:CHECK FOR BFLTSV GOING <0	###OAS
	JAL	R7,NEGBCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RTDNX9	AHM	R0,BCT,R2,		: AND COUNT FOR THIS BUFFER
	JG	RTDNX2			:BCT < 32K
	LHL	R0,BCT,R2,
	CI	R0,0FFF0		:ARE WE IN DANGER OF OVERFLOW?
	JL	RTDNX2			:NO
	STM	R0,REGST		:STORE REGS 			###LSH
	JAL	R14,BFZDB2,,		:SAVE SOME DATA FOR DEBUGGING   ###LSH
	GL	BFZDB2			:BEFORE WE ZAP THE BUFFER 	###LSH 
	LM	R0,REGST		:RESTORE REGS			###sdw
	JAL	R0,BUFZAP,,		:YES - ZAP BUFFER
	GL	BUFZAP
	L	R3,BE,R2,		:SET UP R3 FOR RE-ENTRY OF RTD INSTRUCT
	JR	R8			:GO CONTINUE PROCESSING

RTDNX2  LHL	R0,FREELT		:NEXT FREE BUFFERLET, PLEASE
	JNFS	RTDNX4			:SKIP IF SOMETHING THERE
	JAL	R0,WRE,,		:GET RESERVE TANK
	GL	WRE
	JBS	RTDNX2
RTDNX4	HS	0
	STH	R0,0,R3			:LAST 1/2 WD OF BUFFERLET IS LINK
	LR	R3,R0			:CURRENT BUFFERLET ADDRESS
	SLLS	R3,CBSZL		:SHIFT APPROPRIATELY
	ais	R3,CBPTSZ		:ADD IN START OF BUFFERLET AREA
	LHL	R0,CBSZ-cbptsz,R3	:NEXT BFLET FROM FREE LIST
	STH	R0,FREELT		:IS NOW FIRST IN QUEUE
	JR	R8			:GO CONTINUE PROCESSING
::
::
::***********************************************************************

:	HERE ON 02 CHARACTER DETECTION  ( TYMNET-I GOBBLER)

RTDC2	HS	0
	LIS	R0,2			:SET UP R0 FOR RTDIG
	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RTDIG			: CHANNELS 0 AND 1

	JAL	R9,RSTRIP,,		:TAKE CARE OF NEW BUFFLT ASSIGNED###GT
	SIS	LRC,1			:DECREMENT LOGICAL RECORD COUNT AND
	JAL	R9,GOBBLN,,		: GOBBLE DATA IN THE BUFFER
	GL	GOBBLN
	J	RTDTY1			:GO SKIP BY 2ND CHAR

:	HERE ON 00 CHARACTER

RTDC00	HS	0
	LIS	R0,0			:SET UP R0 IN CASE WE GO TO RTDIG
	JFS	RTDC0X

:	COME HERE FOR 01 CHARACTER

RTDC01	HS	0
	LIS	R0,1			:IN CASE WE GO TO RTDIG

RTDC0X	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RTDIG			: CHANNELS 0 AND 1.

	ST	R3,BE,R2,		:SAVE END POINTER
	STB	R0,0,R3			:STORE 1ST CHAR OF PAIR
:	NOTE:  R3 WAS ALREADY INC'D BY MICROCODE

	LB	R1,0,PRD		:GET NEXT CHAR (MICROCODE INC'D PRD)
	AIS	PRD,1
	JAL	R8,WCI,,		:STORE THE CHAR
	SIS	LRC,2			:DECREMENT COUNT FOR BOTH CHARACTERS

RTDTY1  L	R3,BE,R2,		:RESTORE BE POINTER
	LR	LRC,LRC			:DONE WITH LOGICAL RECORD?
	JG	RTD2			:MORE TO DO FOR THIS CHANNEL
	JE	RTD3			:DONE WITH THIS CHANNEL
:	NEIGHBOR SPLIT CHARACTER PAIR...SNIP THE LINK
:	IF NOT IN DEBUG MODE (DB.DEB SET)
	IF	DB.DEB
	DBOOPS
	ELSE	:NOT DB.DEB
	LIS	R0,LS.SCP		:INDICATE SPLIT CHARACTER PAIR RECEIVED
	EI	:DB.DEB
	J	RTDSNP			:GO SNIP THE LINK

:	HERE TO CONTINUE AS IF SPEC CHARACTER HADN'T BEEN DETECTED

RTDIG	SIS	LRC,1			:DECR LRC SINCE MICROCODE DIDN'T
	JG	RTD2A			:MORE FOR THIS CHANNEL, GO DO IT

	STB	R0,0,R3
	J	RTD3			:GO FINISH UP


:	HERE ON 03 CHAR DETECTION (T-1 ZAPPERS, T-2 NETWORK CONTROL CHARACTERS)
:	R3	POINTS TO SLOT FOR '03' CHARACTER (BE)
:	LRC	HAS NOT BEEN DECREMENTED TO REFLECT '03'
:	PRD	POINTS TO SECOND CHARACTER IN 03-XX PAIR

RTDC3	HS	0
	LIS	R0,3			:SET UP R0 FOR RTDIG
	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RTDIG			: CHANNELS 0 AND 1
	SIS	LRC,1			:DECREMENT LRC TO ACCOUNT FOR 03 CHAR
	LB	R4,0,PRD		:TYM-II, CHECK SECOND CHAR
	AIS	PRD,1			:PRD ==> 1ST CHAR BEYOND 03-XX PAIR
	SIS	LRC,1			:DEC LRC, ACCNT FOR 2ND CHAR IN 03 PAIR
	CLHI	R4,01F			:IS CHAR A ZAPPER? ( 0301 TO 031F )
	JLE	RTDZPR			:YES
       IF       LOGII			:LOG II needle is in perf range
	CLHI    R4,NEEDBD&0FF		:r3 still has buf adr that we must save
	JE	RTDNBD			:needle body char
	CLHI    R4,NEEDTL&0FF
	JE	RTDNTL			:we have a needle tail
       EI       :LOGII
	CLHI	R4,03F			:IS CHAR A PERF MONITOR? (0320 TO 033F)
	JLE	RTDPFM			:YES

:	HERE IF INVALID 03 CHARACTER PAIR...

BADCTL	HS	0
	JAL	R9,GOBBLN,,		:CLEAR BUFFER OF SUSPICIOUS DATA
	LIS	R0,LS.I3P		:INDICATE LINK SNIP REASON
	J	RTDSNP			:INVALID 03 CHARACTER PAIR - SNIP LINK

:	HERE FOR TYMNET-II ZAPPER-LIKE CHARACTER PAIRS (03-01 TO 03-1F)

RTDZPR	HS	0
	SLLS	R4,2			:FW indexing			###wjl
	L	R1,RTDZTB,R4,		:GET DISPATCH ADDRESS		###wjl
	SRLS	R4,2			:restore character		###wjl
	AHI	R4,300			:ROUTINES EXPECT WHOLE 03-CHAR PAIR
	JR	R1			:GO HANDLE NETWORK 03-CHAR PAIR	###wjl

::	HERE FOR PERFORMANCE MONITORING CHARACTER PAIRS (03-20 TO 03-3F)
::	THESE CHARACTER PAIRS !! MUST !! BE THE FIRST IN THE LOGICAL
::	RECORD. THIS PROPERTY IS GUARANTEED BY RMAKE.
::
::	THE PERFORMANCE-MONITORING LOGIC FIRST UNCONDITIONALLY STRIPS OUT
::	THE 03-XX CHARACTER PAIR, AND RETURNS TO THE FREE-LIST ANY BUFFERLET
::	THAT MAY HAVE BEEN ALLOCATED TO STORE THE PAIR. SUBSEQUENTLY,
::	ANOTHER 03-XX CHARACTER PAIR MAY BE WRITTEN INTO THE BUFFER BY
::	A SPECIFIC ROUTINE (IE, RTDXAK).

RTDPFM	CLHI	R4,PFMMAX		:MAKE SURE THE CHAR PAIR IS IN RANGE
	JG	BADCTL			:NO, BAD CONTROL CHARACTER
	JAL	R9,RSTRIP		:POSSIBLY DEALLOCATE A BUFFERLET
	LHL	R0,BF,R2,		:GET OTHER CHANNEL NUMBER
	LR	R1,R2
	SRLS	R1,3			:TEST FOR TERMINATION
	TBT	R1,CRQEND		:IF TERMINATION, THE BIT WILL BE SET
	JNFS	RTDPF3			:TERMINATION - T-I OR INTERNAL
	SLLS	R4,2			:FW indexing			###wjl
	L	R1,PFMRTB,R4,	 	:PASSTHROUGH, GET DISPATCH ADDR	###wjl
	SRLS	R4,2			:restore character		###wjl
	JR	R1			:AND JUMP			###wjl

RTDPF3	HS	0
	IF	REBILD
	LCS	R1,2			:TERMINATION, BACK UP SEQUENCE NUMBER
	AM	R1,VSEQN,R2,
	EI	:REBILD
	SLLS	R4,2			:FW indexing			###wjl
	L	R1,PFMTRB,R4,		:GET DISPATCH ADDRESS		###wjl
	SRLS	R4,2			:restore character		###wjl
	JR	R1			:AND JUMP			###wjl

:	XLAX CHARACTER PAIR - PASSTHROUGH 

RTDXLA	SBT	R0,BPSVCP-LNKZFL/8,,	:OVERRIDE BACKPRESSURE
	LHI	R1,XLAX			:PASS ON XLAX CHARACTER PAIR
	JAL	R8,WCD,,
	GL	WCD
	LIS	R1,3
	JAL	R8,WCD,,
	J	PFMOUT			:CONTINUE WITH TEARDOWN OF LOGICAL REC

:	XLAX CHARACTER PAIR - TERMINATION OR T-1 NEIGHBOR

RTDXL1	XHI	R2,4			:TERMINATION, GET OTHER BUFFER
	LHI	R1,XLACK		:REFLECT XLAX ACK CHAR PAIR
	JAL	R8,WCD,,		:PREFIX INTO BUFFER
	LIS	R1,3
	JAL	R8,WCD,,
	SRLS	CHN,1			:GET TRUE CHANNEL NUMBER
	SBT	CHN,BPSVCP,,		:OVERRIDE BACKPRESSURE
	SLLS	CHN,1			:RESTORE CHN
	XHI	R2,4			:AND BUFFER NUMBER
	J	PFMOUT			:AND CONTINUE WITH TEARDOWN

:	XLACK CHARACTER PAIR - PASSTHROUGH

RTDXAK	SBT	R0,BPSVCP-LNKZFL/8,,	:OVERRIDE BACKPRESSURE
	LHI	R1,XLACK		:PASS ON XLACK CHARACTER PAIR
	JAL	R8,WCD,,		:PREFIX INTO BUFFER
	LIS	R1,3
	JAL	R8,WCD,,
	J	PFMOUT			:AND CONTINUE WITH TEARDOWN

:	GENERAL TERMINATION POINT NOTES TIME OF ARRIVAL OF CHAR PAIR
RTDSNK	L	R0,FASTC,,		:GET CURRENT TIME
	STH	R4,PFMTYP		:STORE THE PERFORMANCE MONITORING CHAR
	CLHI	R4,XLACK&0FF		:XLAX ACK?			##TZ
	JNFS	RTDSNT
	ST	R0,ARRIVX		:XLAX ACK TIME
	J	PFMOUT			:DONE
RTDSNT	HS	0			:MUST BE TIMER ACK
	ST	R0,ARRIVT		:RECORD TIME OF ARRIVAL TIMER ACK
	J	PFMOUT			:DONE				##TZ

:	GENERAL ALL-PASS ROUTINE SIMPLY PASSES ALL 03-XX PAIRS ALONG

RTDALL	LHI	R1,300,R4		:FORM 03-XX CHAR PAIR (2ND CHAR IN R4)
	JAL	R9,W2CI,,		:DEPOSIT INTO BUFFER
	GL	W2CI
	J	PFMOUT			:CONTINUE WITH TEARDOWN OF LOGICAL REC

:	TIMER CHARACTER PAIR - TERMINATION

RTDTM1	XHI	R2,4			:HERE IF TERMINATION,FLIP TO OTHER CHAN
	LIS	R1,3
	JAL	R8,WCI,,		:DEPOSIT 03
	LHI	R1,TIMACK
	JAL	R8,WCI,,		:AND TIMER ACK CHARACTER
	XHI	R2,4			:FLIP BACK TO ORIGINAL BUFFER
	J	PFMOUT			:CONTINUE WITH TEARDOWN OF LOGICAL REC

:	REJECT - HERE WHEN AN UNRECOGNIZED PERFORMANCE MONITORING PAIR
:	IS RECEIVED ON A CRQ THAT TERMINATES AT THE NODE (EITHER INTERNALLY
:	OR TO A T-1 NEIGHBOR). A REJECT CHARACTER PAIR IS SENT BACK TO THE
:	ORIGINATING END
RTDREJ	LIS	R1,3			:FORM 03
	XHI	R2,4			:FLIP TO OTHER BUFFER
	JAL	R8,WCI,,		:DEPOSIT 03
	LHI	R1,REJECT
	JAL	R8,WCI,,		:AND REJECT
	XHI	R2,4			:BACK TO ORIGINAL BUFFER
	J	PFMOUT			:CONTINUE TEARDOWN

:	CONTINUE WITH TEARDOWN OF LOGICAL RECORD AFTER PROCESSING
:	A PERFORMANCE-MONITORING CHARACTER PAIR, SQFIX QUAD OR SQACK QUAD

PFMOUT	LR	LRC,LRC			:MORE DATA IN LOGICAL RECORD?
	JE	RTD1			:NO, 03-XX CHAR PAIR (OR QUAD) WAS LAST
	JG	RTD610			:CONTIN WITH RTD COPY INSTRUCT FOR CHAN
	LIS	R0,LS.S3P		:LRC NEGATIVE, SPLIT 03-CHAR PAIR
	J	RTDSNP			:SNIP THE LINK...

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDIGN:  IGNORE
::
::*********************************************************************

RTDIGN	AR	PRD,LRC			:IGNORE REST OF RECORD
	J	RTD1			:BACK TO TOP OF RTD
					:--IS THERE ANOTHER RECORD?

::*********************************************************************
::
::	HANDLE LINK CONTROL MESSAGE:
::	WE COME HERE IF HIGH ORDER BIT SET IN LOGICAL RECORD COUNT.
::	LINK CONTROL MSG FORMATS ARE:
::	40	PAGE CHANGE
::	20	BACKPRESSURE RELEASE(LOW 5 BITS HAVE COUNT OF NUMBER
::		OF CHANNELS TO BE RELIEVED.  REL CHNL #'S FOLLOW IN 
::		BYTES.)
::	00	SHRINK CMD, IF WE'RE SLAVE. REQUEST, IF WE'RE MASTER.
::	01	SHRINK ACK (OUR SLAVE HAS SHRUNK, SO WE FOLLOW)
::	NOTE--SLAVE DOES THE SHRINK BEFORE THE MASTER.
::	OTHER MSG'S UNKNOWN--SNIP THE LINK.
::
::*********************************************************************

RTDPRI	HS	0
	SIS	PRC,1			:DECREMENT PHYSICAL RECORD COUNT
	SIS	PRD,1			:BACK UP PRD SINCE 'RTD1' ASSUMED
					: LOGICAL RECORD HEADER LENGTH 2
	THI	LRC,40			:LRC CONTAINS CMD BYTE,
					: TEST FOR PAGE CHANGE
	JNFS	RTDP1			:NO
	NHI	LRC,3F			:PAGE CHANGE - ISOLATE NEW PAGE (BANK)
	STB	LRC,RTPAGE,KN,KN	: AND SAVE
	J	RTD1
RTDP1	THI	LRC,20			:TEST FOR BACKPRESSURE RELEASE
	JN	RTDP3			:NO
	NHI	LRC,1F			:BACKPRESSURE REC, ISOLATE LOGICAL REC
:	COUNT AND ADJUST PHYSICAL RECORD COUNT ACCORDINGLY
	SR	PRC,LRC
	LH	R0,RTPAGE,KN,KN		:GET CURRENT PAGE NUMBER. NOTE THAT
:	PAGE NUMBER IS LOADED INTO HI-ORDER BYTE OF HALFWORD.

:	COMPUTE MAXIMUM CHANNEL NUMBER FOR THIS LINK
	LHL	R8,EBDPKN,KN,KN		:GET END OF TABLES ADDRESS AND
	SR	R8,R6			: SUBTRACT BEGIN ADDRESS
	SRLS	R8,1			:NUMBER OF CHANNELS THIS LINK
RTDP2	SIS	LRC,1			:COUNTER OF # CHNLS TO RELIEVE
	JL	RTD1			:DONE WITH BACKPRESSURE LOGICAL RECORD
	LB	R1,0,PRD		:GET NEXT BYTE FROM RECORD
	AIS	PRD,1			:INC TO READ NEXT CHANNEL # NEXT PASS
	STBR	R1,R0			:COMBINE PAGE NUMBER WITH RELATIVE
:	CHANNEL TO GET LINK'S ABSOLUTE CHANNEL NUMBER
	CR	R0,R8			:RANGE CHECK CHANNEL NUMBER
	JLFS	RTDP2A			:CHN # OK--SET BITS IN BIT ARRAYS
:	BACKPRESSURE RELIEVED FOR CHANNEL OUT OF OUR RANGE.
	IF	DB.DEB
	DBOOPS
	ELSE	:NOT DB.DEB
	LIS	R0,LS.BPC
	J	RTDSNP			:CHANNEL NUMBER OUT OF RANGE, SNIP LINK
	EI	:DB.DEB

RTDP2A
	SBT	R0,LNKBPV,R7,		:INDICATE BACKPRESSURE RECEIVED...
	LIS	R1,3			:YES , GET CIRCUIT SPEED BITS
	LR	R3,R0
	AR	R3,R3			:get 2* chn #
	NH	R1,NIOTAB,R6,R3	: FROM PERMUTER TABLE ENTRY
	LHL	R1,CIRSPK,R1,R1		:GET APPROPRIATE COUNT
	STH	R1,BPSCNT,R6,R3	:AND UPDATE COUNT FOR THIS CHANNEL
	J	RTDP2			:LOOP TO SERVICE REST OF CHANNELS

RTDP3	NHI	LRC,1F			:LINK MESSAGE
	JE	RTDP4			:SHRINK COMMAND OR REQUEST
	SIS	LRC,1			:TEST FOR SHRINK ACKNOWLEDGE
	JEFS	RTDP3A			:YES
	LIS	R0,LS.UCR		:NO - UNKNOWN CONTROL RECORD RECEIVED
	J	RTDSNP			:SNIP LINK
RTDP3A	LIS	R0,0			:SLAVE ACKED SHRINK, NOW OUR TURN
	STB	R0,SHSTAT,KD		:THAW RMAKE

	SUBTTL	YAKYAK (SHRINK - Link shrink logic)

::*********************************************************************
::
::	SUBROUTINE:	SHRINK
::	FUNCTION:	Gives up half-page of permuter table space.  
::	Starting from highest channel on link, move permuter table entry
::	to lowest available channel.  Adjust necessary pointers, and 
::	report to Xray and Supervisor logs.
::	CALLING SEQ:	J SHRINK  (called from RTDP4A  shrink cmd or req)
::	INPUT:		KD,KN
::	PRESERVED:	R10
::	DESTROYED:	R-0,1,2,3,4,5,14,15.
::	CALLS:		JAL  R10,SUP12L
::	RETURNS:	J RTDXIT
::
::*********************************************************************

SHRINK	HS	0
	LHL	R0,NCHN,KD		:GET # OF CHANNELS ALLOCATED THIS LINK
	CLHI	R0,80			:DO WE HAVE MORE THAN 1 HALF-PAGE?
	JGFS	SHRK0			:YES - O.K.
	LIS	R0,LS.SNC		:NO - NOTHING TO SHRINK
	J	RTDSNP			:SNIP THE LINK
SHRK0	LHL	R1,TBDPKN,KN,KN		:R1 ==> BOTTOM OF LINK'S TABLE SPACE
	AIS	R1,2			:SKIP CHANNELS 0 AND 1
	LHL	R3,EBDPKN,KN,KN		:END OF IOTAB FOR THIS LINK
	J	SHRK2
SHRK1	THI	R3,0FF			:HALF PAGE BOUNDARY?
	JN	SHRK2			:NO - CONTINUE
	STH	R3,EBDPKN,KN,KN		:YES - DONE WITH SHRINK
	LHI	R0,-80
	AHM	R0,NCHN,KD		:DECREMENT # OF AVAILABLE CHANS ON LINK
	LHI	R0,-10			:# OF BYTES IN BIT ARRAY FOR 1/2 PAGE
	AHM	R0,LKFGND,KN,KN		:ADJUST 'PTR TO LAST HW' FIELDS FOR
	AHM	R0,LKSVND,KN,KN		: THIS LINK
	AHM	R0,LKBPND,KN,KN
	LB	R3,MASTKN,KN,		:ARE WE MASTER ON THIS LINK?
	JNFS	SHRK1A			:YES,NO NEED TO ADJUST ACP,CHS POINTERS
	AHM	R0,LKAPND,KN,KN
	AHM	R0,LKCSND,KN,KN
SHRK1A	LIS	R0,1
	AHM	R0,NUMPAG,,		:INCREMENT NUMBER OF PAGES AVAILABLE
	ST	R10,RTMT2		:SAVE PRC
	LIS	R0,NR.SHK		:INDICATE TYPE OF REPORT
	JAL	R10,SUP12L,,		:MAKE LINK SHRINK REPORT TO SUP LOG
	GL	SUP12L
:	When a link has lots of suspended chns then it bubbles
:       since no chns are free and not suspended, and then it will shrink
:       immediately since the link only has a few active chns.  This can
:       continue to happen until the suspension ends (60seconds).  
:       Solution:  Since the chn is suspended to prevent the classic outgoing
:       zap, outgoing needle and incoming zap which would then clear the
:       needle when the other end was clearing the same circuit we zapped
:       but the shrink logic suspends the link so we know that this timing
:       problem cannot happen, so the shrink logic might as well take advantage
:       and clear the suspended arrays for that link.
	lhl	r4,lkzfkn,kn,kn 	:chn 0
	lhl	r5,nchn,kd		:last chn
	srls    r4,3			:byte offset
	srls    r5,3			:byte count
	lr	r0,r4
	lis	r3,0			:for negative chs
	sr	r3,r0			:have high end of neg
	sr	r3,r5			:have lower end of neg
	lis	r0,0			:for clearing CHS1, CHS2
	lcs	r1,1			:for clearing CHS
shrk19  st	r1,chs-4,r4,r5
	st	r1,chs,r3,r5
	st	r0,chs1-4,r4,r5
	st	r0,chs2-4,r4,r5
	st	r0,chs1,r3,r5
	st	r0,chs2,r3,r5		:all of them, pos and neg
	sis	r5,4
	jg      shrk19			:clear for all words
	L	R10,RTMT2
	J	RTDXIT			:NOTHING ELSE IN THIS PACKET
SHRK2	SIS	R3,2			:DECREMENT TO NEXT CHANNEL
	LHL	R2,NIOTAB,R3,		:GET NEXT CHANNEL
	JE	SHRK1			:NULL ENTRY, NO MAPPING REQUIRED
SHRK3	AIS	R1,2			:WORKING FROM BOTTOM UP,
					: LOOK FOR NEW HOLE TO FILL
	LH	R0,NIOTAB,R1,
	JNBS	SHRK3			:ENTRY IN USE

:	FOUND AVAILABLE IOTAB ENTRY. MOVE BUFFER NUMBER AND SPEED BITS
:	TO NEW ENTRY, AND ADJUST BPSCNT, BF, AND ALL ATTENDANT BIT ARRAYS
:	FOR THIS CHANNEL.

	STH	R2,NIOTAB,R1,		:MOVE ENTRY FROM RETIRING HALF PAGE
	LIS	R0,0
	STH	R0,NIOTAB,R3,		:CLEAN UP BEHIND OURSELVES
	LH	R0,BPSCNT,R3,
	STH	R0,BPSCNT,R1,
	NHI	R2,-4			:ISOLATE BUFFER NUMBER
	XHI	R2,4			:GET BUFFER INDEX
	LH	R0,BF,R2,		: WHICH POINTS TO THIS IOTAB ENTRY
	JEFS	SHRK4			:DO NOT CHANGE IF 0
	LR	R4,R3			:COMPUTE GAP BETWEEN RETIRING IOTAB
	SR	R4,R1			: ENTRY AND NEW ENTRY
	SRLS	R4,1
	SR	R0,R4			:ADJUST BF BY CHANNEL DISPLACEMENT
	STH	R0,BF,R2,
	
:	THE FOLLOWING CODE RESETS THE BIT IN THE OLD POSITION, AND
:	SETS OR RESETS THE NEW CHANNEL BIT ARRAY AS NEEDED.

SHRK4	LR	R4,R1
	SRLS	R4,1			:NEW CHANNEL NUMBER
	LR	R5,R3
	SRLS	R5,1			:OLD CHANNEL NUMBER
	RBT	R5,GUSH,,			:RESET OLD GUSH
       if       1-notrik        :kill dumb trickle logic
	JNFS	SHRK41			:IF SET, SET NEW TRIKLE
	RBT	R5,TRIKLE,,
	JEFS	SHRK42

:	SET NEW TRIKLE IF OLD GUSH OR TRIKLE SET
:	ALL OTHER BIT ARRAYS GET STRAIGHT COPY FROM OLD TO NEW
	
SHRK41	SBT	R4,TRIKLE,,	
       else     :no trickle
        jefs    shrk42
        sbt     r4,gush,,
       ei       :1-notrik
SHRK42	RBT	R5,LNKFLG,,
	JEFS	SHRK43
	SBT	R4,LNKFLG,,
	JFS	SHRK44
SHRK43	RBT	R4,LNKFLG,,

SHRK44
	RBT	R5,LNKBPV,,
	JEFS	SHRK45
	SBT	R4,LNKBPV,,
	JFS	SHRK46
SHRK45	RBT	R4,LNKBPV,,

SHRK46	RBT	R5,CHSRVD,,
	JEFS	SHRK47
	SBT	R4,CHSRVD,,
	JFS	SHRK48
SHRK47	RBT	R4,CHSRVD,,

SHRK48	RBT	R5,BPSVCP,,
	JEFS	SHRK49
	SBT	R4,BPSVCP,,
	JFS	SHRK50
SHRK49	RBT	R4,BPSVCP,,

SHRK50	RBT	R5,PRIRTY,,
	JEFS	SHRK51
	SBT	R4,PRIRTY,,
	JFS	SHRK52
SHRK51	RBT	R4,PRIRTY,,

SHRK52	RBT	R5,CMDCTS,,
	JEFS	SHRK53
	SBT	R4,CMDCTS,,
	JFS	SHRK54
SHRK53	RBT	R4,CMDCTS,,

SHRK54	RBT	R5,NEEDLE,,		:I THINK THIS FIXES A BUG	###TZ
	JEFS	SHRK55
	SBT	R4,NEEDLE,,
	JFS	SHRK56
SHRK55	RBT	R4,NEEDLE,,

SHRK56	SBT	R5,LNKACP,,
	JEFS	SHRK57
	SBT	R4,LNKACP,,
	JFS	SHRK58
SHRK57	RBT	R4,LNKACP,,

SHRK58	SBT	R5,LNKCHS,,
	JEFS	SHRK59
	SBT	R4,LNKCHS,,
	JFS	SHRK60
SHRK59	RBT	R4,LNKCHS,,

:	DETERMINE MAGNITUDE FROM BEGINNING OF ARRAY AND ADJUST ACP, CHS
:	IN NEGATIVE DIRECTION.

SHRK60	STM	R14,LNKRGS		:USE R14, R15 AS WORK REGS
	LCS	R14,1
	SR	R14,R4			:NEGATIVE NEW CHANNEL NUMBER
	LCS	R15,1
	SR	R15,R5			:NEGATIVE OLD CHANNEL NUMBER
	SBT	R15,EKNACP,,
	JEFS	SHRK61
	SBT	R14,EKNACP,,
	JFS	SHRK62
SHRK61	RBT	R14,EKNACP,,

SHRK62	SBT	R15,EKNCHS,,
	JEFS	SHRK63
	SBT	R14,EKNCHS,,
	JFS	SHRK64
SHRK63	RBT	R14,EKNCHS,,

SHRK64	LM	R14,LNKRGS
	J	SHRK1

:	GOT SHRINK COMMAND (OR REQUEST, IF NEIGHBOR IS SLAVE)
RTDP4	HS	0
	LHL	R0,NCHN,KD		:SHOULD WE EVEN CONSIDER SHRINK?
	CLHI	R0,80			:NEED MORE THAN 1/2 PAGE TO SHRINK
	JGFS	RTDP4A			:GOT IT
	LIS	R0,LS.SNC		:UNREASONABLE SHRINK REQUEST IF ONLY
	J	RTDSNP			: 80 CHANS ALLOCATED - SNIP THE LINK
RTDP4A	LH	R0,NEDOUT,KD		:ANY NEEDLES OUTSTANDING FOR THIS LINK?
	JN	RTDP6			:YES, DEFER SHRINK
					: UNTIL NEEDLES PROCESSED BY RMAKE
	STB	R0,NEDSUS,KD		:CLEAR SHRINK SUSPENDED INDICATION

	LH	R0,NDID,KD		:TEST FOR WHETHER WE'RE MASTER
	CLHI	R0,MACHNM		: OR SLAVE ON THIS LINK
	JLFS	RTDP5			:MASTER
	LIS	R0,1			:WE'RE THE SLAVE...
	STB	R0,SHSTAT,KD		:TELL RMAKE TO ACKNOWLEDGE SHRINK
	J	SHRINK			: AND GO DO IT
RTDP5	LB	R0,SHSTAT,KD		:WE'RE THE MASTER...
	JN	RTDXIT			:IGNORE IF SOMETHING IN PROGRESS
	LIS	R0,2			:TELL RMAKE
	STB	R0,SHSTAT,KD		: TO SEND SHRINK COMMAND TO NEIGHBOR
	J	RTDXIT			:NOTHING MORE IN THIS PACKET

::	WE RECEIVED SHRINK COMMAND/REQUEST FROM NEIGHBOR, BUT NEEDLES
:: FROM CRQ HAVE NOT YET BEEN PROCESSED BY RMAKE. WE MUST WAIT UNTIL
:: RMAKE PROCESSES ALL NEEDLES OUTSTANDING BEFORE SHRINKING LINK SO
:: THAT NEIGHBOR'S PERMUTER TABLES WILL MATCH OURS. WE STORE A NON-ZERO
:: VALUE IN 'NEDSUS' TO INDICATE SHRINK SUSPENDED UNTIL OUTSTANDING
:: NEEDLES PROCESSED BY RMAKE, AND EXIT RTD WITHOUT INCREMENTING 'LRT'
:: SO THAT WHEN RMAKE DRAINS OUTSTANDING NEEDLES AND RE-SCHEDULES RTD
:: WE WILL PROCESS SAME PACKET WHICH CONTAINS SHRINK COMMAND.

RTDP6	STB	R0,NEDSUS,KD	:NON-ZERO VALUE INDICATES SHRINK SUSPENDED
	J	RTEARZ		:RESET LKTEAR, DON'T INCREMENT LRT...

	SUBTTL	YAKYAK (RTD - ZAPPERS, GOBBLERS, NEEDLES, T-I SUP RECS)

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDNGZ:  NON-GOBBLING ZAPPER (0303)
::	FUNCTION:		TEAR DOWN CIRCUIT BUT DON'T CLEAR BUFFER
::
::*********************************************************************

:	MICROCODE HAS INCREMENTED 'BE' (R3) SO THAT NEXT BYTE SHOULD
: BE STORED WHERE R3 CURRENTLY POINTS. THIS ONLY MATTERS FOR NON-GOBBLING
: ZAPPERS SINCE OTHERS WILL CLEAR BUFFER BEFORE DEPOSITING ZAPPER CHARACTER
: PAIR.

RTDNGZ	HS	0
	ST	R3,BE,R2,		:SAVE CURRENT BE, POINTS TO SLOT FOR 03
	LIS	R1,3			:STORE 1ST BYTE OF NON-GOBBLING ZAPPER
	STB	R1,0,R3			: R3 ALREADY INCREMENTED
     if		acct&t2gate
	lis	r0,aalr03
	sth	r0,aareas
     ei
	JAL	R9,ZAPXNG,,		:ZAP WITHOUT CLEARING BUFFER
	GL	ZAPXNG			: AHEAD OF IT
	J	RTDZP2

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDZPH:  HARD ZAPPER (0301)
::	FUNCTION: TEAR DOWN CIRCUIT, CLEAR BUFFER, DON'T ATTEMPT REBUILD
::		IF A HARD ZAPPER IS RECEIVED, THE CIRCUIT IS NOT REBUILDABLE.
::		THEREFORE IT IS QUITE PERMISSIBLE TO CLEAR OUT THE NEEDLE
::		TO AVOID THE OVERHEAD OF REQUESTING REBUILD FOR THESE CIRCUITS.
::
::*********************************************************************

	GL	PCIS
	GL	PCI
	
RTDZPH	HS	0
	IF	T2GATE
	LHL	R0,BF,R2,		:find destination chan numb
	CLHI	R0,DISZFL
	JL	GTZ006
	CLHI	R0,DISZFL+NDP		:If dispatcher, then account reason
	JGE	GTZ006
	AHI	R0,-DISZFL		:Get relativie port
	TBT	R0,GDSTPT		:and if we are a destination
	JEFS	GTZ002			:we will do accounting
	LHI	R0,AALR03
	JFS	GTZ004
GTZ002	LIS	R0,0
GTZ004	STH	R0,AAREAS		:Otherwise no accounting
GTZ006	HS	0
	EI	:T2GATE
	JAL	R9,ZAPHRD,,		:HARD-ZAP THE CIRCUIT
	GL	ZAPHRD
RTDZP2	LCS	R0,1
	AHM	R0,ANCHN,KD		:DECREMENT NUMBER OF ACTIVE CHANNELS
	LHL	R0,SLOWC+2,,
	STH	R0,BPSCNT,R6,CHN	:SAVE TIME THAT ZAPPER PASSED
	J	RTDIGN

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDNAC:  NEEDLE POINT ON ASSIGNED CHANNEL
::	FUNCTION:	HARD-ZAP IN BOTH DIRECTIONS
::
::*********************************************************************

RTDNAC	JAL	R9,ZAPHRD,,		:NEEDLE ON ASSIGNED CHANNEL
	JAL	R8,GFCBUF,,		:ZAP CIRCUIT IN BOTH DIRECTIONS
	GL	GFCBUF
	SKIPAD(RTDOOB)			:immed. return - out of buffers!###wjl
	SRHLS	CHN,1			:+4 return - got a buffer	###wjl
	AH	CHN,LKZFKN,KN,KN
	JAL	R9,CRQHCR,,
	GL	CRQHCR
	XHI	R2,4
	LHI	R1,ZAPPH
	EXBR	R1,R1
	JAL	R8,WCI
	EXBR	R1,R1
	JAL	R8,WCI
	LCS	R0,1
	AHM	R0,ANCHN,KD		:DECREMENT NUMBER OF ACTIVE CHANNELS
	LR	R0,CHN
	SH	R0,LKZFKN,KN,KN		:GET BACK RELATIVE CHAN FOR THIS LINK
	LHL	R8,NDID,KD		:NEIGHBOR#
	STH	R8,CRYSBF+2		:SAVE FOR CRYPTO
	JAL	R8,CRYPTO,,		:SEND CRYPTOGRAM FOR NEEDLE ON
	HC	CRYE29			: ASSIGNED CHANNEL
	J	RTDIGN

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDZPS:  SOFT ZAPPER (0302)
::	FUNCTION:		HANDLE SOFT ZAPPER ON TYMNET-II CHANNEL
::
::*********************************************************************

RTDZPS	ST	R10,RTMT1		:SOFT ZAPPER
	ST	R3,BE,R2,		:SAVE CURRENT BE, POINTS TO SLOT FOR 03
	IF	REBILD
	LCS	R0,2			:BACK UP RECEIVE SEQUENCE NUMBER
	AM	R0,VSEQN,R2,		: - ZAPPERS ARE NOT COUNTED
	EI	:REBILD
	LR	R1,R4
       if       t2gate&acct
	lis	r0,aalr03
	sth	r0,aareas
       ei
	JAL	R10,TRCIRC,,		:TEAR DOWN CIRCUIT,
       if       acct&t2gate
	lis	r0,0
	sth	r0,aareas
       ei
	GL	TRCIRC			: POSSIBLY REQUEST REBUILD
	L	R10,RTMT1
	J	RTDZP2			:GO DECREMENT ACTIVE CHANS, SAVE TIME

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDGOB:  GOBBLER (0308)
::	FUNCTION:		CLEAR BUFFER AND PASS GOBBLER ALONG
::
::*********************************************************************

RTDGOB	JAL	R9,GOBBLN,,		:GOBBLER
	J	RTDTY1

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDFGB:  FAT GOBBLER (0309)
::	FUNCTION:  6-WORD NETWORK CONTROL, THE FULLWORD FOLLOWING
::	THE 03-XX CONTAINS THE NEW SEQUENCE NUMBER.
::	CLEAR BUFFER EXCEPT FOR NEEDLES AND SEQUENCE FIXES.
::	IF PASSTHRU, PASS FAT GOBBLER ON.
::	IF TERMINATION, SHRINK FAT GOBBLER INTO SKINNY ONE AND ADJUST THE
::	VSEQN ACCORDING TO THE FW OF DATA.
::
::*********************************************************************

RTDFGB	JAL	R9,RSTRIP		:UNCONDITIONALLY STRIP OUT NEW BUFFERLT
	LHL	R8,BCT,R2,		:IS BUFFER EMPTY?		###GT
	JEFS	RTFGB1			:YES, DON'T CHECK FOR NEEDLES/SQFIX#GT
	JAL	R8,PCIS		:CHECK BUFFER FOR NEEDLES & SQFIX###GT
	SIS	R1,3			:03-CHARACTER PAIR?		###GT
	JNFS	RTFGB1			:NO				###GT	
	JAL	R8,PCI		:YES - CHECK NEXT BYTE		###GT
	CLHI	R1,NEEDP&0FF		:NEEDLE POINT?			###GT
	JEFS	RTFGB2			:YES - DON'T GOBBLE		###GT
	CLHI	R1,SQFIX&0FF		:SEQUENCE FIX?			###GT
	JEFS	RTFGB2			:YES - DON'T GOBBLE		###GT
RTFGB1	JAL	R8,CBCLR,,		:UNCONDITIONALLY CLEAR OUT THE BUFFER
	GL	CBCLR
RTFGB2	LHL	R3,BF,R2,		:GET THE ONGOING CHANNEL NUMBER
	JAL	R8,SPEED,,		:SPEED THINGS UP, CLEAR BACKPRESSURE
	GL	SPEED
	JAL	R9,CHKTRM		:CHECK FOR TERMINATION
	SKIPAD(RTPFGB)			:IMMED, PASSTHRU, PASS GOBBLER ALONG
	JAL	R9,GOBBLN,,		:+4, TERMINATION - WRITE IN A GOBBLER
	IF	REBILD
	AHI	R4,2,LRC		:FORM THE NEW SEQUENCE NUMBER	###GT
	ST	R4,VSEQN,R2,		:(R4 SET UP IN CHKTRM)		###GT
	EI	:REBILD
	J	PFMOUT			:AND PROCEED WITH RECORD TEARDOWN

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDSQK:  SEQUENCE NUMBER ACK (030C)
::	FUNCTION:	SENT BY FAR END IN RESPONSE TO A
::	SQFIX CHARACTER PAIR. SIMPLY PASSES ALONG QUAD IF A PASSTHRU, ELSE
::	PRUNES HISTORY BUFFER ON BASIS OF HW SEQUENCE NUMBER FOLLOWING
::	THE CHARACTER PAIR.
::	EXPECTS R2 = BUFFER NUMBER, R3 = SLOT FOR '03' CHARACTER
::
::*********************************************************************

RTDSQK	JAL	R9,RSTRIP		:POSSIBLY DE-ALLOCATE
					: A NEWLY-ACQUIRED B'LET
	JAL	R9,CHKTRM		:DECIDE - TERMINATION OR PASSTHRU?
	SKIPAD(RTKSQP)			:IMMED, PASSTHRU - JUST PASS QUAD ALONG
	IF	REBILD
	TBT	R1,CRQBSY		:IS REBUILD ENABLED FOR THIS CHANNEL?
	JE	PFMOUT			:NO, MUST HAVE BEEN TURNED OFF IN RMAKE
	SBT	R1,SQFIXV		:NOTE REBUILD QUAD RECEIVED
					: (R1 SETU IN CHKTRM)
	LCS	R0,6			:BACK UP VSEQN BY 6, SQACKS DON'T COUNT
	AM	R0,VSEQN,R2,		:VSEQN WAS ADVANCED BY 'LRC' AT RDT15
	SLLS	R1,2			:GET HISTORY BUFFER NUMBER
	LHL	R0,REBDIS,,		:DISPLAY THIS ACTIVITY?
	JE	RTDSQY			:NO
	L	R0,HBSEQN,R1,		:GET CURRENT HISTORY BUFFER SEQ#
	ST	R0,CRYSBF
	LR	R3,R4			:PRESERVE R4
	NHI	R3,0FFFF		:MASK OUT HO HW
	LHL	R0,BF,R2,		:GET DESTINATION CHANNEL
	EXHR	R0,R0
	OR	R0,R3			:COMBINE WITH DATA
	JAL	R8,CRYPTO,,		:AND REPORT
	HC	CRYE66
RTDSQY	HS	0
	S	R4,HBSEQN,R1,		:GET NUMBER OF CHARACTERS OUTSTANDING
	JLE	PFMOUT			:NO PRUNING POSSIBLE HERE
					: - CONTINUE TEARDOWN
      IF 1-REBTST	:much more efficient routine by sdw
	SRLS	R4,4			:AND DIVIDE BY 16
	JE	PFMOUT			:IF LESS THAN A BF'LET'S WORTH, DON'T
	STH	R2,BUFSAV		:SAVE ORIGINAL BUFFER INDEX
	LI	R2,HBUFN,R1		:FORM THE ASSOCIATED HISTORY BUFFER #
BFDUMP	JAL	R8,RETBLT,,		:DISCARD ONE BUFFERLET
	GL	RETBLT
	LIS	R0,0E			:EACH B'LET HAS THIS MANY BYTES
	AM	R0,HSEQN,R2,		:UPDATE SEQ# OF OLDEST CHAR IN H-BUFFER
	SIS	R4,1			:CAN MORE BUFFERLETS BE DISCARDED?
	JGBS	BFDUMP			:YES, KEEP DUMPING THEM
       ELSE  :REBTST
	STH	R2,BUFSAV		:save original buffer index
	LI	R2,HBUFN,R1		:form the associated history buffer #
	LR	R0,R4			:tell routine how many to remove
	JAL	R8,RTBFTS,,		:return all R4 number of chars
	GL RTBFTS
	AM	R0,HSEQN,R2,		:R0 gets number of chars returned
     EI :REBTST
	LHL	R2,BUFSAV		:RESTORE ORIGINAL BUFFER INDEX
	EI	:REBILD
	J	PFMOUT			:CONTIUE TEARDOWN

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDSQF:  SEQUENCE NUMBER FIX (030B)
::	FUNCTION:	IF NOT TERMINATION, JUST PASS ON
::	6-WORD NETWORK CONTROL. OTHERWISE TEST FOR SEQUENCE NUMBERS EQUAL.
::	EXPECTS R4 TO CONTAIN THE SQFIX DATA WORD.
::
::*********************************************************************

RTDSQF	HS	0
	JAL	R9,RSTRIP		:POSSIBLY DE-ALLOCATE
					: NEWLY-ACQUIRED B'LET
	JAL	R9,CHKTRM		:SEE IF PASSTHRU OR TERMINATION
	SKIPAD(RTDSQP)			:IMMED, PASSTHRU		###wjl
					: - SIMPLY MOVE THE NETWORK QUAD ALONG
	IF	REBILD
	LR	R4,R4			:SEQ NO. RETURNED IN R4		###GT
	JGEFS	RTDSQ1			:NOT -1				###GT
	JAL	R9,RBCOUT,,		:SEQN=-1 IS A NAK, DISABLE REBUILD#GT
	GL	RBCOUT
	J 	PFMOUT			:CONTINUE WITH RECORD TEARDOWN
RTDSQ1	SBT	R1,SQFIXV		:NOTE SQF QUAD RECEIVED
					: (R1 SET UP IN CHKTRM)
	LR	R4,R4			:CHECK SEQN NO. AGAIN		###GT
	JNFS	RTDSQ3			:CONTINUE IF NE 0		###GT
	J 	RTDSQ2			:SQFIX 0 IS A SPECIAL CASE - DON'T
					:FIX UP SEQUENCE NUMBERS
RTDSQ3	LHL	R9,BF,R2,
	CLHI	R9,CRQZFL		:STUB, INTERCEPT, NEW CIRCUIT?
	JLE	RTDSQ2			:YES, IGNORE SQF, CRQ NOT FINISHED###CY
	LR	R9,R1			:SAVE REBUILD BUFFER BIT ARRAY INDEX
	LHI	R1,SQACK		:BOUNCE BACK SEQUENCE # WITH A SQACK
	XHI	R2,4			:THE OTHER BUFFER
	JAL	R9,W2CI
	LR	R1,R4			:SEQUENCE NUMBER (R4 SET UP IN CHKTRM)
	EXHR	R1,R1			:UPPER HW OF SEQUENCE NUMBER	###GT
	JAL	R9,W2CI		: (UPPER HW)
	EXHR	R1,R1			:LOWER HW OF SEQUENCE NUMBER	###GT
	JAL	R9,W2CI		:				###GT
	XHI	R2,4			:BACK TO THIS BUFFER
	LR	R0,R4			:VERIFY VSEQN INTEGRITY, R4 CONTAINS
	S	R0,VSEQN,R2,		:OLD VSEQN,PRIOR TO RTD15 UPDATE BY LRC
	AI	R0,6,LRC		:LRC HAS ALREADY BEEN REDUCED BY 6###GT
	JE	RTDSQ2			:OK, REBUILD STILL IN SYNC FOR THIS CRQ

	AM	R0,VSEQN,R2,		:ERROR,
					: PRESUME MOST RECENT SQFIX IS CORRECT
	NI	R0,0FFFF		:STRIP POSSIBLE SIGN EXTENSION
	STH	R0,SUPMBF+4		:STORE AWAY THE ERROR COUNT
	STH	R2,SUPMBF+2		:AND THE BUFFER NUMBER
	LHI	R1,NR.SQF		:MESSAGE TYPE - SQFIX ERROR
	STH	R1,SUPMBF
	STM	R0,TRREGS		:PRESERVE REGISTERS THROUGH SUP12 CALL
	JAL	R10,SUP12,,
	LM	R0,TRREGS
	LHL	R1,BF,R2,		:GET DESTINATION CHANNEL,
	EXHR	R0,R0			: ALIGN SQF DIFFERENCE IN UPPER R0,
	OR	R0,R1			: AND COMBINE
	JAL	R8,CRYPTO,,		:ADVISE XRAY - SQF ERROR
	HC	CRYE63

RTDSQ2	LCS	R0,6			:REDUCE VSEQN BY 6
					: SINCE SQFIX'S DON'T COUNT
	AM	R0,VSEQN,R2,
	LHL	R0,REBDIS,,		:DISPLAY SQF ACTIVITY?
	JE	PFMOUT			:NO, CONTINUE WITH LOGICAL REC TEARDOWN
	ST	R4,CRYSBF		:SAVE FOR XRAY (DISPLAY SQF # RECVD)
	LHL	R0,BF,R2,
	EXHR	R0,R0			:NOW GET CHANNELS FOR DISPLAY
	XHI	R2,4
	OH	R0,BF,R2,
	XHI	R2,4
	JAL	R8,CRYPTO,,
	HC	CRYE65
	EI	:REBILD
	J	PFMOUT			:CONTINUE WITH LOGICAL RECORD TEARDOWN

:	RTDSQP:
:	RTPFGB:
:	RTKSQP:
:	PASS SQACK, FAT GOBBLER OR SQFIX ALONG.  R4 = HW OF DATA

RTPFGB	LHI	R1,GOBBF		:ENTRY POINT FROM RTDFGB
	JFS	RTDSQZ
RTKSQP	LHI	R1,SQACK		:ENTRY POINT FROM RTDSQK - SET UP R1
	JFS	RTDSQZ
RTDSQP	LHI	R1,SQFIX		:ENTRY POINT FROM RTDSQF - SET UP R1
RTDSQZ	JAL	R9,W2CI		:SQF OR SQFIX PASS-THROUGH	###LH
	LR	R1,R4			:SQACK OR SQFIX DATA
	EXHR	R1,R1			:UPPER HW			###GT
	JAL	R9,W2CI		:				###LH
	EXHR	R1,R1			:LOWER HW			###GT
	JAL	R9,W2CI		:			###LH	###GT
	J	PFMOUT

::*********************************************************************
::
::	SUBROUTINE:	CHKTRM
::	FUNCTION:	Pre-processor for SQFIX and SQACK network quads.
::	read network quad from buffer, adjust LRC and PRD, test for
::	terminating circuit.  Skip return if termination, immediate return
::	if pass-thru.
::	CALLING SEQ:	JAL  R9,CHKTRM
::	INPUT:		PRD
::	OUTPUT:		R4 = FW following network character pair
::	DESTROYED:	R1
::	RETURNS:	JN   4,R9	: Termination
::			SKIP(0,R9)	: Passthrough
::
::*********************************************************************

CHKTRM	HS	0
	LB	R1,0,PRD		:COLLECT NEXT TWO BYTES FROM PACKET
	LB	R4,1,PRD
	EXBR	R1,R1
	OR	R4,R1			:ASSEMBLE HW DATA INTO R4
	EXHR	R4,R4			:SHIFT INTO UPPER HW		###GT
	LB	R1,2,PRD		:NOW THE LOWER HW		###GT
	EXBR	R1,R1			:				###GT
	OR	R4,R1			:				###GT
	LB	R1,3,PRD		:				###GT
	OR	R4,R1			:				###GT
	AIS	PRD,4			:ADVANCE PRD BEYOND THE CHARACTER QUAD
	SIS	LRC,4			:ADJUST COUNT,BYTES LEFT IN LOGICAL REC
	LR	R1,R2			:MOVE BUFFER NUMBER OVER TO R1
	SRLS	R1,3			:DIVIDE BUFF # BY 8 FOR CRQ ARRAY INDEX
	TBT	R1,CRQEND		:TEST FOR ENDPOINT ON THIS NODE
	JN	4,R9			:A TERMINATION - SKIP RETURN	###wjl
	SKIP(0,R9)			:A PASSTHRU - IMMEDIATE RETURN	###wjl

::*********************************************************************
::
::	SUBROUTINE:	RSTRIP:
::	FUNCTION:	RSTRIP returns to free pool bufferlets that may
::	have been allocated by the RTD microcode in response to some 03
::	character pair that is	not to be written into the circuit buffer
::	(i.e. seq number acks).
::
::	This routine is necessary because the RTD microcode instruction
::	exits to allocate a new bufferlet before it exits for an 03-XX
::	character pair. Thus, an 03-XX char pair may trigger a bufferlet
::	allocation even though it may not actually be written into the 
::	bufferlet.
::
::	CALLING SEQ:	JAL  R9,RSTRIP
::	INPUT:		R2 = Buffer Number
::			R3 = Working 'BE'
::	DESTROYED:	R0,R3,R8
::	CALLS:		JAL  R8,CBCLR,,
::			JAL  R7,NEGBCR
::			JAL  R7,NEGHCR
::	RETURNS:	JR  R9
::
::*********************************************************************

RSTRIP	HS	0
	CL	R3,BB,R2,		:HAS 1ST BUFFERLET JUST BEEN ALLOCATED?
	JNFS	RSTRI1			:NOT FIRST BUFFERLET
	JAL	R8,CBCLR,,		:WE'RE NOT GOING TO USE BUFFRLT,DISCARD
	JR	R9			:RETURN
RSTRI1	LR	R0,R3			:IF RUNNING 'BE' IS
	NHI	R0,CBSZ-1		: EQUAL TO pointer size MOD 10,
	SIS	R0,cbptsz		: THEN WE'VE JUST ACQUIRED NEW BUFFERLT
	JGR	R9			:NO, GO AWAY
:	SPLICE NEW BUFFERLET BACK INTO FREE LIST, AND DECREMENT
:	BUFFER COUNTS
	LHL	R0,FREELT
	STH	R0,CBSZ-cbptsz,R3	:THIS BUFFERLET NOW 1ST IN LINKED LIST
	SRLS	R3,CBSZL		:BUFFERLET INDEX
	STH	R3,FREELT		:FREE LIST ==> BUFFRLT WE'RE DISCARDING
	LHI	R0,cbptsz-CBSZ		:less bufferlets in use
	AHM	R0,BCT,R2,		:DON'T COUNT THIS BUFFERLET
	AM	R0,BFLTSV
	JGEFS	RSTRI9			:CHECK FOR BFLTSV GOING <0	###OAS
	JAL	R7,NEGBCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RSTRI9	HS	0
	IF	REBILD
	CI	R2,HBUFN		:IS R2 A HISTORY BUFFER INDEX	###OAS
	JLFS	RSTRI2			:				###OAS
	AM	R0,HBFTSV		:YES, UPDATE HISTORY BUFFER COUNT##OAS
	JGEFS	RSTRI2			:CHECK FOR HBFTSV GOING <0	###OAS
	JAL	R7,NEGHCR		:ERROR, CRASH (R7=CRASH LOC)	###OAS

RSTRI2	HS	0
	EI	:REBILD

	JR	R9			:DONE

::*********************************************************************
::
::	DISPATCH ADDRESS:	RTDZPF:	 FAT ZAPPER (0304)
::	FUNCTION:	6-BYTE NETWORK CONTROL, SOFT ZAPPER FOLLOWED BY
::	OFFENDING NODE PAIR WHOSE LINK FAILED AND CAUSED ALL THIS...
::
::*********************************************************************

RTDZPF	HS	0
	ST	R10,RTMT1		:PRESERVE R10 (PRC)
	JAL	R9,RSTRIP		:FREE UP ANY NEWLY-ACQUIRED BUFFERLET
	IF	REBILD
	LCS	R0,6
	AM	R0,VSEQN,R2,		:BACK UP SEQUENCE #, DON'T COUNT ZAPPER
	EI	:REBILD			:###GT
	LR	R1,R4			:TRCIRC EXPECTS RELEVANT ZAPPER IN R1
       if       t2gate&acct
	lis	r0,aalr03
	sth	r0,aareas
       ei
	JAL	R10,TRCRFT,,		:TEAR DOWN CIRC, CHECK FOR TERMINATION
	GL	TRCRFT
       if       t2gate&acct
	lis	r0,0
	sth	r0,aareas
       ei
	L	R10,RTMT1
	LCS	R0,1
	AHM	R0,ANCHN,KD		:ONE LESS CHANNEL THIS LINK
	LHL	R0,SLOWC+2,,
	STH	R0,BPSCNT,R6,CHN	:SAVE TIME THAT ZAPPER PASSED
	LH	R0,TRCSV2		:DEPOSIT 'FAT' IN BUFFER?
	JL	RTFZ10			:NO, REBUILD REQUEST MADE
	LH	R0,BF,R2,		:WAS BUFFER RETURNED		###CY
	JL	RTFZ10			:DON'T WRITE INTO IT IF SO	###CY
	LB	R4,0,PRD
	LB	R1,1,PRD		:GET NEXT TWO BYTES
	EXBR	R4,R4
	OR	R1,R4			:FIRST NODE NUMBER FOLLOWING FAT ZAPPER
	JAL	R9,W2CI
	LB	R4,2,PRD
	LB	R1,3,PRD
	EXBR	R4,R4
	OR	R1,R4			:SECOND NODE # FOLLOWING FAT ZAPPER
	JAL	R9,W2CI
RTFZ10	AIS	PRD,4			:ADJUST RECORD POINTER PAST 'FAT'
	J	RTD1

:	HERE FOR DATA ON AN UNASSIGNED CHANNEL
RTDUAC	HS	0
	LB	R0,0,PRD		:T-II - IS IT A NEEDLE?
	EXBR	R0,R0
	LB	R1,1,PRD
	AR	R1,R0
       IF       LOGII			:handle LOG II needles		###sdw
	CLHI    R1,NEEDHD		:LOG 2 Needle Head		###sdw
	JE	RTDNHD
       EI       :LOGII
	CLHI	R1,NEEDP
	JN	RTDUA2			:NOT A NEEDLE - REPORT AND TOSS

:	HERE WHEN A NEEDLE ARRIVES ON AN UNASSIGNED CHANNEL
RTDUAN	LIS	R0,1
	AHM	R0,ANCHN,KD		:INCREMENT NUMBER OF ACTIVE CHANNELS
RTDUA1	JAL	R8,GFCBUF,,		:SAVE DATA FOR CRQ
	SKIPAD(RTDOOB)			:immed. return - out of buffers!###wjl
	SRHLS	CHN,1			:+4 return, ok - COMPUTE ABSOLUTE CHN #
	AH	CHN,LKZFKN,KN,KN
	JAL	R9,CRQHCR,,		:BUILD 'HALF CIRCUIT'
	SH	CHN,LKZFKN,KN,KN
	SLHLS	CHN,1
	LHI	R0,CIRSP0		:GIVE IT SOME TRANSMIT CAPACITY
	STH	R0,BPSCNT,R6,CHN

	LR	R1,R2
	SRLS	R1,1			:SET UP BUFTIM INDEX
	L	R0,FASTC,,
	ST	R0,BUFTIM,R1,		:TIME THAT NEEDLE ORIGINATES IN NODE

	JAL	R9,CRQALT,,		:ALERT CRQ OF NEEDLE AND...
	GL	CRQALT
	LHI	R1,NEEDP		:INSERT NEEDLE POINT INTO BUFFER
	JAL	R9,W2CI
	AIS	PRD,2			:ADVANCE PRD PAST THE NEEDLE POINT
	LB	R0,0,PRD		:GET LENGTH ESCAPE		###GT
	EXBR	R0,R0			:				###GT
	LB	R1,1,PRD		:LENGTH OF NEEDLE		###GT
	LR	R4,R1			:SAVE TEMPORARILY		###GT
	AR	R1,R0			:				###GT
	JAL	R9,W2CI			:INSERT INTO BUFFER		###GT
	AIS	PRD,2			:ADVANCE PRD PAST 2 BYTES	###GT
	SIS	R4,4			:NEEDLE LENGTH - 4		###GT
	SIS	LRC,4			:DECR LRC TO ACCOUNT FOR NEEDLE+COUNT
RTDU10	LB	R1,0,PRD		:GET A BYTE			###GT
	JAL	R8,WCI		:WRITE INTO BUFFER		###GT
	AIS	PRD,1			:ADVANCE PRD PAST THIS BYTE	###GT
	SIS	LRC,1			:DECREMENT LRC TO ACCOUNT FOR BYTE#GT
	SIS	R4,1			:COPY OVER THE WHOLE NEEDLE	###GT
	JGBS	RTDU10
	
	JAL	R8,PCIS		:SKIP OVER NEEDLE POINT		###GT
	JAL	R8,PCI
	JAL	R8,PCI		:JUMP OVER ESCAPED LENGTH	###GT
	JAL	R8,PCI
	JAL	R8,PCI		:SKIP OVER LINK COUNT		###GT
	JAL	R8,PCI
	LIS	R5,5			:5 HALF-WORDS TO SKIP OVER	###GT
RTDU11	JAL	R9,PHWI			:SKIP OVER INVOICE #,FLAGS	###GT
	GL	PHWI
	SIS	R5,1			:REQUESTING NODE AND PORT#	###GT
	JGBS	RTDU11
RTDU12	JAL	R9,PHWI			:SKIP OVER 'CREAMED' NODE #'S	###GT
	CI	R1,0FFFF		:= -1?				###GT
	JEBS	RTDU12
	TI	R1,8000			:ARE WE THE TERMINATION NODE?	###GT
	JEFS	RTDU13			:NO - CARRY ON			###GT
	LR	R4,R2			:YES - SET BIT FOR TERMINATION	###GT
	SRHLS	R4,3
	SBT	R4,CRQEND
RTDU13	LR	LRC,LRC			:ANY DATA LEFT TO COPY?		###GT
	JE	RTD1			:NO, DONE WITH THIS LOGICAL RECORD#GT
	J	RTD6			:YES, REPEAT PASS THRU RTD TO COPY DATA

::      LOG II needle received.  Do normal needle stuff, but write NEEDBD
::      instead of NEEDHD so CRQ won't process needle until all there.  Also
::      allows CRQ to timout needles which never receive the end.

       IF       LOGII			:only for LOG 2
RTDNHD  JAL	R8,GFCBUF		:get a buffer to put it
	SKIPAD(RTDOOB)			:die if no buffers
	LIS	R0,1
	AHM	R0,ANCHN,KD		:another chn is use on this link
	SRHLS   CHN,1			:get real CHN number
	AH      CHN,LKZFKN,KN,KN
	JAL	R9,CRQHCR,,		:build half circuit
	LHL	R0,IOTAB,CHN,CHN	:make sure relieve backpressure
	OHI	R0,3			:to get entire needle
	STH	R0,IOTAB,CHN,CHN
	SH      CHN,LKZFKN,KN,KN
	SLHLS   CHN,1			:get back link CHN #
	LHI	R0,CIRSP0		:allow us to send zap if goes wrong
	STH	R0,BPSCNT,R6,CHN
	LR	R1,R2			:save time needle arrived
	SRLS    R1,1			:FW index
	L	R0,FASTC,,
	ST	R0,BUFTIM,R1,
	JAL	R9,CRQALT,,		:tell CRQ to look for Needle
	LHI	R1,NEEDBD		:write body (not head) so CRQ knows
	JAL	R9,W2CI 		:to check for timout
	SIS     LRC,2			:two chars is needhd size
	AIS     PRD,2			:and point past needle point
	J	RTDTY1			:exit for char pairs

:       Needle body arrives on assigned chn.  If not termination then CRQ
:       has enough to process it.  If termination then CRQ must wait for tail.

RTDNBD  LIS	R0,03			:first half of needle
	STB	R0,0,R3 		:setup by the microcode
	ST	R3,BE,R2,		:save pointer
	LHI	R1,NEEDBD&0FF		:finish putting needle body
	JAL	R8,WCI
	L	R3,BB,R2,		:set up for look for termination node
	JAL	R9,PHWI,,		:get past needle point
	LHI	R4,ID.NNL		:any needle node list
	JAL	R7,X4PARS,,
	GL      X4PARS
	SKIPAD(RTDPB1)			:not there- termination
	LR	R0,R0			:any entries in list?
	JNFS    RTDPB2
RTDPB1  LR	R4,R2			:skip if not termination
	SRLS    R4,3			:make bit array
	SBT	R4,CRQEND
	J	RTDPB4			:for terms let needle tail write HEAD
RTDPB2  JAL	R9,G2CI,,		:remove needbd (it tells crq to wait)
	LHI	R1,NEEDHD		:and needhd tells crq to process it
	JAL	R8,WCD
	EXBR    R1,R1			:write NEEDHD (tell CRQ to process
	JAL	R8,WCD
RTDPB4  LHL	R6,TBDPKN,KN,KN 	:restore clobbered regs
	LHL	R7,FLDPKN,KN,KN 	:restore clobbered regs
	J	RTDTY1			:standard reentry for char pairs

:	RTDNTL  got needle tail on a termination.  Thus, needle is sitting
:		in buffer waiting for CRQ if we are termination.  If
:		passthrough then needle tail just passes through.

RTDNTL  LIS	R0,03			:write needle tail
	STB	R0,0,R3
	ST	R3,BE,R2,		:save pointer
	LHI	R1,NEEDTL&0FF
	JAL	R8,WCI
	LR	R1,R2			:if we are termination
	SRLS    R1,3
	TBT	R1,CRQEND		:termination?
	JE	RTDTY1			:nope done
	JAL	R9,G2CI 		:tell CRQ whole needle has arrived
	LHI	R1,NEEDHD
	JAL	R9,WCD
	EXBR    R1,R1
	JAL	R8,WCD			:write CRQ go (needle head)
	J	RTDTY1

       ELSE     :not LOG II
RTDNBD  EQ	RTDALL
RTDNTL  EQ	RTDREJ		:reject unless LOG II

       EI       :LOGII


::	DATA RECEIVED ON UNASSIGNED CHANNEL FROM NETWORK NEIGHBOR.
::	REPORT TYPE 2 MESSAGE TO SUP LOG, WITH HIGH-ORDER BIT OF THIRD
::	HALFWORD SET IF DATA IS A ZAPPER. REPORT TO XRAY WITH NEIGHBOR
::	AND CHANNEL NUMBER. DISCARD DATA RECEIVED.

RTDUA2	HS	0
	LR	R0,CHN
	SRLS	R0,1			:SET UP TYPE 2 NODE REPORT
	RBT	R0,LNKCHS,R7,		:DON'T REPORT
					: IF ZAPPER RECENTLY TRAVELLED
	JE	RTDIGN			:CHANNEL SUSPENDED
	STH	R0,SUPMBF+4		:CHANNEL NUMBER IN HW 3
	LIS	R1,NR.UAC
	STH	R1,SUPMBF		:INDICATE TYPE 2
	LHL	R1,NDID,KD
	STH	R1,CRYSBF+2
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER IN HW 2
	LB	R1,0,PRD		:GET DATA RECEIVED AND
	SIS	R1,3			: TEST FOR ZAPPER
	JNFS	RTDUA4			:NO
	SBT	R1,SUPMBF+4		:YES - SET HI-ORDER BIT IN HW 3
	JAL	R8,CRYPTO,,		:REPORT ZAPPER ON UNASSIGNED CHANNEL
	HC	CRYE09
	JFS	RTDUA6
RTDUA4	JAL	R8,CRYPTO,,		:REPORT DATA ON UNASSIGNED CHANNEL
	HC	CRYE28
RTDUA6	ST	R10,RTMT1
	JAL	R10,SUP12,,		:SEND REPORT TO SUP LOG
	LIS	R0,NR.CTM		:NOW REPORT TIME SINCE CHAN WAS ZAPPED
	STH	R0,SUPMBF		:NODE REPORT TYPE
	LH	R0,SLOWC+2,,		:CURRENT TIME MINUS
	SH	R0,BPSCNT,R6,CHN	: TIME THAT ZAPPER PASSED YIELDS # OF
	STH	R0,SUPMBF+2		: SECONDS THAT CHAN HAS BEEN UNASSIGNED
	JAL	R10,SUP12,,		:REPORT IT TO SUP LOG
	L	R10,RTMT1
	IF	DB.DEB
	LHL	R0,NDID,KD
	CLHI	R0,$82000		:TYMNET-II NEIGHBOR?
	JL	RTDIGN			:NO, IGNORE T-I DATA ON UNASSIGNED CHAN
	LB	R0,0,PRD		:WAS DATA A ZAPPER?
	SIS	R0,3			:(IF SO, IT COULD HAVE GOBBLED NEEDLE)
	JE	RTDIGN			:O.K.
	DBOOPS				:CAN'T EXPLAIN IT FROM T-II NEIGHBOR...
	EI	:DB.DEB
	J	RTDIGN			:IGNORE DATA ON UNASSIGNED CHANNEL

::	RTDSNP
::	ERROR DETECTED IN PACKET FROM NEIGHBOR - SNIP THE LINK. SET 'BORI ZAP'
::	BIT TO CAUSE LINK TO GO OUT NEXT EXECUTION OF LNCHCK. SAVE LINK SNIP
::	REASON IN SNPTYP FOR NODE REPORT IN TRLINK, AND DON'T TEAR ANY MORE
::	PACKETS FOR THIS LINK.

:	entry for error return from GFCBUF when out of buffers		###wjl
RTDOOB	LHI	R0,LS.OOB		:out of buffers			###wjl

RTDSNP	HS	0
RTDSN0	STH	R0,SNPTYP,KN,KN		:SAVE REASON FOR LINK SNIP
:       borzap inverted by sdw
	rBT	KN,BORZAP		:AND TAKE LINK OUT

:	SAVE SOME USEFUL DATA
	LHL	CD,NRTR,KD		:RECORD DESCRIPTOR INDEX
	LHL	R9,RECN,CD		: AND RECORD NUMBER
       IF       LNKDBG			:save regs for link snip	###sdw
	STM	R0,REGST		:save regs debugger
	JAL	R14,RTSDB1,,		:RTD snip debugger #1
	LM	R0,REGST
	JAL	R14,RTSDB2,,		:save offending packedt debugger
	GL	RTSDB1,RTSDB2
	LM	R0,REGST		:				###sdw
       EI       :LNKDBG

	J	RTEARZ			:DONE WITH THIS LINK...

:	GOT CHANNEL NUMBER GREATER THAN MAX NUMBER ALLOCATED. IF CHN IS
:	GROSSLY HIGHER THAN CURRENT MAX, SOMETHING WRONG. OTHERWISE, T-II
:	NEIGHBOR MUST WANT US TO BUBBLE THE LINK.

RTDBIG	STH	CHN,RTMT3
	SR	CHN,R0
	CLHI	CHN,80			:HOW MUCH OVER IS IT?
	JLFS	RTD1C			:A LITTLE
	IF	DB.DEB
	DBOOPS				:	...ALOT
	ELSE	:NOT DB.DEB
RTD1B	LIS	R0,LS.COR		:CHANNEL OUT OF RANGE
	J	RTDSNP			:ERROR IN PACKET FROM NEIGHBOR
					: - SNIP THE LINK
	EI	:DB.DEB

:	CHN PROBABLY CARRIES NEEDLE FROM NEIGHBOR WHO JUST BUBBLED.
:	INCREASE CHANNEL ALLOCATION FOR THIS LINK.
RTD1C
:	ONLY BUBBLE FOR NEEDLES
	LB	R0,0,PRD
	EXBR	R0,R0
	LB	R1,1,PRD		:GET FIRST 2 BYTES OF LOGICAL RECORD TO
	AR	R1,R0			: CHECK FOR NEEDLE POINT
	CLHI	R1,NEEDP
	JEFS	RTD1D			:NEEDLE POINT - WE'LL BUBBLE LINK...
	IF	DB.DEB
	DBOOPS				:BAD CHANNEL NUMBER FROM NEIGHBOR
	ELSE	:NOT DB.DEB
	J	RTD1B			:BAD CHANNEL NUMBER, SNIP LINK
	EI	:DB.DEB

RTD1D	STH	PRC,RTMT3+2		:SAVE PHYS RECORD COUNT (R10)
	JAL	R8,BUBBLE,,		:FIND P.T. BUBBLE, ALLOCATE MORE CHANS
	GL	BUBBLE
	SKIPAD(RTD1E)			:immed, NO P.T. SPACE, TAKE LINK DWN
	LHL	R6,TBDPKN,KN,KN		:+4 ret, POSSIBLY NEW TABLES POINTERS
	LHL	R7,FLDPKN,KN,KN
	LHL	PRC,RTMT3+2		:RESTORE REGS
	LHL	CHN,RTMT3
	AR	CHN,CHN			:2*CHANNEL USEFUL INDEX
	J	RTDUAN			:GO HANDLE NEEDLE

:	OUT OF PERMUTER TABLE SPACE
RTD1E	RBT	KN,LKTEAR		:DO NO MORE FOR THIS LINK
	L	R10,RTMXSV		:CAUSE TRLINK TO EXIT RTD
	ST	R10,NEWLNR
	J	NEWLN8			:REPORT NO P.T. TO SUP LOG,
					: TEAR DOWN LINK

::*********************************************************************
::
::	RTDZTB:
::	DISPATCH TABLE FOR TEARING NETWORK 03-CHARACTER PAIRS
::
::*********************************************************************

RTDZTB	WC	RTDIGN		:0300 RESERVED - IGNORE
	WC	RTDZPH		:0301 ZAPPH - HARD ZAPPER
	WC	RTDZPS		:0302 ZAPPS - SOFT ZAPPER
	WC	RTDNGZ		:0303 ZAPPN - NON-GOBBLING ZAPPER
	WC	RTDZPF		:0304 ZAPPF - FAT ZAPPER
	WC	RTDZPS		:0305 RESERVED - SOFT ZAPPER
	WC	RTDZPH		:0306 RESERVED - HARD ZAPPER
	WC	RTDZPH		:0307 RESERVED - HARD ZAPPER
	WC	RTDGOB		:0308 GOBBL - GOBBLER
	WC	RTDFGB		:0309 GOBBF - FAT GOBBLER
	WC	BADCTL		:030A UNUSED, RESERVED
	WC	RTDSQF		:030B SQFIX - REBUILD SEQUENCE NUMBER FIX
	WC	RTDSQK		:030C SQACK - REBUILD SEQUENCE NUMBER ACK
	WC	RTDGOB		:030D RESERVED - GOBBLER
	WC	RTDGOB		:030E RESERVED - GOBBLER
	WC	RTDGOB		:030F RESERVED - GOBBLER
	WC	RTDNAC		:0310 NEEDP - NEEDLE
	WC	BADCTL		:0311 NEEDE - NEEDLE EYE
	WC	BADCTL		:0312 TILIM - MESSAGE FOR PORT IN LOGIN MODE
	WC	BADCTL		:0313 LOGRR - LOGON ERROR
	WC	RTDNAC		:0314 RESERVED - NEEDLE
	WC	RTDNAC		:0315 RESERVED - NEEDLE
	WC	RTDNAC		:0316 RESERVED - NEEDLE
	WC	RTDNAC		:0317 RESERVED - NEEDLE
	WC	RTDNAC		:0318 RESERVED - NEEDLE
	WC	RTDNAC		:0319 RESERVED - NEEDLE
	WC	RTDNAC		:031A RESERVED - NEEDLE
	WC	RTDNAC		:031B RESERVED - NEEDLE
	WC	RTDNAC		:031C RESERVED - NEEDLE
	WC	RTDNAC		:031D RESERVED - NEEDLE
	WC	RTDNAC		:031E RESERVED - NEEDLE
	WC	RTDNAC		:031F RESERVED - NEEDLE

	SUBTTL	YAKYAK (RMAKE - Record assembly)

::*********************************************************************
::
::	SUBPROCESS:	RMAKE:
::	FUNCTION:	RMAKE checks to see if a Bori Zap is pending.  If
::	not, it checks WSIZE to see if its ok to make a record.  If so it 
::	finds the Next Record to Make descriptor (NRMK), and dispatches
::	based on link type.  It loads the address of the record data buffer
::	to fill and calls RMK.  After logical data is assembled into the 
::	record buffer, RMAKE puts on the header and fills the frame to a
::	doubleword boundry.  The count field is filled in, and the  end of 
::	record pointer is updated.  Total characters is recorded and the 
::	BORI is inserted.  LRM is incremented and the trace tables are 
::	updated.  NAS is updated and the RECN is inserted, releasing the 
::	frame to the Sync transmitter.  If a serious error occurs, the
::	link will be snipped.
::	CALLING SEQ:	J RMAKE  (called directly from SPIDER)
::	INPUT:		R2 contains link number
::	CALLS:		JAL  R9,RMK
::			JAL  R8,TSBMRK
::	RETURNS:	J    BIDDRT
::
::*********************************************************************

xicrmk  hc      ticrmk                  :rmake time limit
        syad(xicrmk)
:       cheap little organizational optimization
rmkas5	la	r0,2*((nlinks-1)/10)+lkmake
	lr	r1,r0
	lhi	r2,(((nlinks*2-2)/10)*10)!0f
	sth	r2,didall		:serviced each link once
	arand   r0,r2			:find an unserviced link
	jfs	rmaks2			:link serviced, but can do it again 
	j       spide1,,

:       RMAKE - the real thing - redone to include output when doing packet
:       and not making if no free ccw/rotor to send and a fair bit of
:       careful coding to work wonderfully under great load and take
:       minimal cpu time.
RMAKE	HS	0
:	run RMAKE for all links and don't consantly be checking EXEC (EXYLD).
:       (Only higher job is bufzap and RMAKE removes data from buffers)
	L	R0,FASTC,,		:calculate time to dismiss
	AH	R0,XICRMK
	ST	R0,DIDTIM		:and when we expire
	LIS	R0,0			:make sure service all links this time
	STH	R0,DIDALL		:service all links equally
RMAKS2  HS      0			:here to do do links wanting to be
	 				:serviced again
Q       EQ      0
	 RE     LKSIZE/4
	L	R0,LKMAKE+4*Q		:links wanting service
	ST	R0,LKSRVD+4*Q
Q       EQ      Q+1			:just a couple of ST (32 links per ST)
	 ER

	IF	DB.DEB
:	DETERMINE HIGH-WATER MARK FOR INTERVAL BETWEEN RMAKE EXECUTIONS
	L	R0,FASTC,,
	LR	R3,R0			:GET CURRENT TIME AND COMPUTE
	S	R0,RMKTIM		:INTERVAL SINCE LAST RMAKE EXECUTION
	ST	R3,RMKTIM		:SAVE CURRENT TIME
	CLH	R0,RMKHWM		:IS THIS A NEW HIGH-WATER MARK?
	JLEFS	RMAKT1			:NO
	STH	R0,RMKHWM		:YES - SAVE
RMAKT1	EI	:DB.DEB

:       exec optimization comes here to service next link or maybe same link
:       gets another packet.  but first check and see if we've expired  ###sdw
RMAKS0	L	R0,FASTC,,		:time up?
	S	R0,DIDTIM		:any time left
	jle	rmaks4			:time to still make packets
	lh	r1,didall		:everyone get serviced?
	jg	spide1,,		:yes, return to spider
	jal	r0,exyld,,		:no, come on back after doing whatever
        ts      didall                  :negative, took timout
        lh      r0,xicrmk
        a       r0,fastc,,              :next timeout expiring
        st      r0,didtim
:       do each link before doing any link again, thus it the service array is
:       0 then check original to see if any serviced have more data.

rmaks4  lhi	r0,2*((nlinks-1)/10)+lksrvd
	lhi	r1,2*((nlinks-1)/10)+borzap
	lhi	r2,(((nlinks-1)/10)*10)!0f
	arand   r0,r2			:find an unserviced link
	jfs	rmaks3
        lh      r0,didall               :get timed out on first pass?
        jge     rmkas5                  :no, try for more packets
        j       spide1,,                :yes, let something else run

rmaks3  rbt	r2,lksrvd

	LR	KN,R2			:LINK NUMBER TO MAKE LINK DESCRIPTOR
	AR	R2,r2
	L	KD,KDKN,R2,R2

	JAL	R9,CCWCHK		:see if any free CCWs
	J	RMAKEB			:nope backloged
	STH	R5,RMLNSV		:save line to output on

	LB	R1,WSIZ,KD		:IF LRM<LAR+WSIZ, MAKE RECORD
	AH	R1,LAR,KD
	SH	R1,LRM,KD
	CHVR	R1,R1
	JGFS	RMAKE2			:GO MAKE RECORD
	jal	r9,ccwrtr		:send retransmission
RMAKEB	LIS	R0,1			:backlogged
	AHM	R0,KS.BAK,KD		:INC COUNT OF BACKLOG EVENTS
RMAKE1	RBT	KN,LKMAKE		:CAN'T HACK IT, MARK LINK AS SERVICED
	J	rmaks4			:look for next link

:	THERE IS A RECORD TO MAKE.  MAKE THE RECORD
RMAKE2  LHL	CD,NRMK,KD		:POINT TO RECORD DESCRIPTOR

:	HERE TO MAKE A FRAME FOR A T-II LINK
	L	PRD,BREC,CD		:T-II - GET POINTER TO SEG2 DATA BUFFER
:	Begin Scope of PRD containing POINTER to next char in buffer ##JOK
	ais	PRD,3			:where to put logical records
					: RESERVE 3 BYTES FOR HDR
	LHI	PRC,$A121		:MAKE UP TO 121 DATA BYTES FRAME
					: - LEAVE 3 BYTES FOR HEADER
					: AND 4 BYTES FOR CHECKSUM

:	> > > > > > > > > > > > > > > > > 
	JAL	R9,RMK			:GO MAKE A FRAME
:	< < < < < < < < < < < < < < < < < 

:       histogram of packetsize 
       IF       XRYRMK			:monitor packetsize		###sdw
	LHL	R0,NDID,KD		:for this neighbor?
	CLH	R0,XRMKNE,,		:the desired neighbor
	JNFS    XRMK01
	LR	R1,PRC
	NHI	R1,-2			:nearest even packetsize
	LIS	R0,1			:another event
	AM	R0,XRMKHS,R1,R1 	:another histogram entry
XRMK01
      EI	:XRYRMK

	CLHI	PRC,$A121		:DID RMK MAKE A FRAME?
	jefs	RMAK2A			:no, check if need null record
	j	rmakw3			:this type of jumps is faster

RMAK2A	LHL	R0,LRT,KD		:MAKE NULL REC
	SH	R0,NAS,KD		: IF UNACKED FRAMES OUTSTANDING
	lhr	r0,r0
	SIS	R0,TH.ACK		:MORE THAN THRESHOLD FRAMES UN-ACKED?
	jgfs	rmaknl			:time for a null packet

RMAKNO	LIS	R0,1			:NO RECORD MADE,
	AM	R0,RMKNRW		: COUNT OCCURRENCES OF WHEEL SPINNING
	AM	R0,KS.NPC,KD		:LINK-BY-LINK COUNT OF NO RECORDS MADE
	RBT	KN,LKMAKE		:MARK LINK AS SERVICED
        ts      idle,kd                 :line is idle right now
	J	RMAKS0

:       MAKE NULL RECORD
RMAKNL	LIS	R0,0			:YES, NULL REC, LRC=0, CHN=0

	STB	R0,0,PRD
	STB	R0,1,PRD
	AIS	PRD,2
	SIS	PRC,2			: null record now 5-bytes long

RMAKW3	LIS	R0,0			:FILL OUT FRAME TO MULTIPLE OF 8 BYTES
	STB	R0,0,PRD		:3 ZERO BYTES TO INDICATE END OF FRAME
	STH	R0,1,PRD
	STB	R0,LLXM,CD		:CLEAR RETRANSMISSION FLAG
	LIS	R1,7
	NR	R1,PRC			:ISOLATE LO 3 BITS OF FRAME BYTE COUNT
	ar	PRD,r1			:add in length
:	End Scope of PRD containing POINTER to next char in buffer ##JOK
	IF	DB.DEB
	THI	PRD,3			:LENGTH MUST BE MULTIPLE OF 4
	JEFS	RMAKW4			:IT IS
	DBOOPS				:IT ISN'T...
RMAKW4	EI	:DB.DEB
	SR	PRC,R1
	ST	PRD,EREC,CD
	LHI	R1,80			:NUMBER OF BYTES IN PACKET JUST MADE
	SR	R1,PRC			:INCLUDE CHECKSUM AND
	AM	R1,KS.PCO,KD		: COUNT PACKET CHARACTERS OUTPUT

	SIS	R1,4			: excluding cksum
	SRLS	R1,3			:DISCARD LAST 3 BITS (SHOULD ALL BE 0)
	LB	R0,BORI,KD		:GET EXPECTED BORI
	XHI	R0,30,r1		:COMPLEMENT MASTER/SLAVE FIELD
	EXBR	R0,R0
	LH	R1,LRM,KD		:(DIGRESS TO INDEX LRM)
	AIS	R1,1
	STH	R1,LRM,KD
	L	R9,BREC,CD		:PUT AWAY HEADER
	STH	R0,0,R9		: put away header
	STB	R1,2,R9		:INSERT TRUNCATED REC #

	IF	TSTSZE
	LHL	R8,NDID,KD		:GET NEIGHBOR NUMBER AND
	CLH	R8,TSLINK		: TEST FOR LINK OF INTEREST
	JN	RMAKET			:NO - CONTINUE
	JAL	R8,TSBMRK		:SET UP NEW EVENT ENTRY
	LIS	R8,TS.MAK		:GET EVENT TYPE,
	STB	R8,TSBTBL,R7		: AND STORE IN EVENT ENTRY
	STH	R0,TSBTBL+2,R7		:STORE RECORD HEADER
	STB	R1,TSBTBL+4,R7		:STORE PACKET RECORD NUMBER
	LHL	R8,LAS,KD
	STB	R8,TSBTBL+1,R7		:STORE LAST ACK SENT
	LHL	R8,LRT,KD
	STB	R8,TSBTBL+3,R7		:STORE 'LRT' SINCE ACK FIELD LEFT BLANK
					:FOR INTERRUPT ROUTINE TO FILL IN...
RMAKET  EI	:TSTSZE
	LHL	R0,LRT,KD		:WE'LL BE ACKING THIS
	STH	R0,NAS,KD
	LHL	R0,LRM,KD		:GET RECORD NUMBER
	LR	R2,R0			:MEASURE QUEUE DELAY
	NHI	R2,PKTMSZ		:MASK WITH TABLE SIZE
	AR	R2,R2			:FORM HW INDEX
	LHL	R1,FASTC+2,,		:GET CURRENT TIME
	STH	R1,PKTTIM,KD,R2 	:AND STORE AWAY FOR INTERRUPT ROUTINE

::	A RECORD BUFFER NEED NOT BE MARKED BUSY WHILE BEING FILLED. IT BEARS A 
::	RECD # THAT IS LESS THAN LAR AND THEREFORE WILL NOT BE XMITTED.
	
	STH	R0,RECN,CD		:RELEASE RECORD TO SYNC XMITTER
	LHL	R2,RLNK,CD		:INDEX NRMK TO NEXT REC
	STH	R2,NRMK,KD

:       must have KD,KN,CD.  Also r9 as BREC
	jal	r9,ccwsnd

	rbt     kn,siobtr		:last packet sent was not retransmiss
	SIS     PRC,0A			:did packet have more room?
	JL	RMAKS0			:link still has data waiting	###sdw
	RBT     KN,LKMAKE		:did all data->link serviced	###sdw
	J	RMAKS0			:look for next free link

::	RMKSNP:
::	SOMETHING WENT WRONG. SNIPPING THE LINK IS LESS PAIN THAN CRASHING
::	NODE, AND PROBABLY ELIMINATES EXPOSURE TO POTENTIAL CROSSED CIRCUITS
::	EVEN IF WE DON'T REALLY KNOW WHAT'S GOING ON...
::
::	THE LINK SNIP REASON IS PASSED ON R0. SET THE BIT FOR THIS LINK
::	IN THE BORI ZAP ARRAY. TRLINK WILL MAKE REPORTS TO SUP LOG AND XRAY
::	AFTER ZAPPING ALL CIRCUITS ON LINK.

RMKSNP	HS	0
:       borzap inverted by sdw
	rBT	KN,BORZAP		:LNCHCK WILL TAKE LINK OUT
        rbt     kn,lkmake
	STH	R0,SNPTYP,KN,KN		: AND TRLINK WILL KNOW WHY
       IF       LNKDBG			:save REGS for debugger
	STM	R0,REGST
	JAL	R14,RMSDB1,,		:RMK SNIP DEBUGGER #1		###sdw
	GL	RMSDB1
	LM	R0,REGST
       EI       :LNKDBG
	J	RMAKS0			:THAT'S ALL FOR THIS LINK

	SUBTTL	YAKYAK (RMK)

::*********************************************************************
::
::	SUBROUTINE:	RMK:
::	FUNCTION:	RMK assembles data from buffers which have been
::	flagged as needing attention.  If link undergoing shrink process,
::	RMAKE is frozen, return.  Otherwise, see if backpressure need be 
::	relieved.  Find next channel to service, range check channel number
::	and see if page change need be sent.  Get outbound buffer pointer
::	and dispatch based on link type.  See if # of chars in buffer will 
::	fit into frame, and if so copy from buffer to output record.  Count
::	logical characters output and update BPSCNT. Insert channel  number
::	and logical count into packet.  Trace channel if desired.  Make 
::	more packets if at least ten bytes remain in the frame.  Restore
::	record pointer and return to RMAKE.  If serious errors occur,
::	snip the link.
::	CALLING SEQ:	JAL  R9,RMK
::	INPUT:		KD   -- Link Descriptor address
::			KN   -- Link Number
::			PRD  -- Pointer to Physical Record
::			PRC  -- Physical Record byte count
::
::*********************************************************************
::
::	THIS ROUTINE ASSEMBLES DATA FROM BUFFERS WHICH HAVE BEEN
::	FLAGGED AS NEEDING ATTENTION.  THE DATA FROM THE BUFFER
::	IS BUILT INTO A LOGICAL RECORD WITHIN A PHYSICAL RECORD
::	WHICH IS TO BE TRANSMITTED ACROSS A LINK.  EACH TIME
::	THROUGH RMK, IT TRIES TO BUILD ONE PHYSICAL RECORD.
::
::	LNKFLG  -- IS THE ARRAY OF FLAGS INDICATING WHICH BUFFERS
::			NEED ATTENTION.
::
::	LNKBPV  -- IS THE ARRAY OF FLAGS INDICATING WHICH CHANNELS
::			RECEIVED BACKPRESSURE RELIEF.
::
::	CHSRVD  -- IS A WORKING COPY OF THE BACKPRESSURE ARRAY.
::			IT IS USED TO INSURE THAT CHANNELS ARE SERVICED
::			IN A ROUND ROBIN FASHION.
::
::	BPSVCP  -- IS AN ARRAY WHICH INDICATES WHETHER OR NOT THE
::			BACKPRESSURE COUNT FOR A CHANNEL SHOULD BE
::			RESET. 
::
::	PRIRTY  -- ARRAY WHICH INDICATES PRIORITY CHANNELS
::
::	GUSH	-- ARRAY INDICATING MUCH TRAFFIC (AT LEAST 8 CHARACTERS)
::			RECEIVED SINCE LAST BACKPRESSURE RELIEF
::
::	TRIKLE  -- ARRAY INDICATING A LITTLE TRAFFIC RECEIVED SINCE
::			LAST BACKPRESSURE RELIEF
::
::**********************************************************************

RMK	HS	0
	ST	R9,RTMXSV		:SAVE RETURN ADDRESS
	LIS	R0,1
	AM	R0,RMKRMW		:COUNT TOTAL RMK ITERATIONS

	LHL	R2,NCHN,KD		:MAX # OF CHANNELS (DYNAMIC FOR T-II)
	SIS	R2,1			:MINUS 1
	STH	R2,RMTSR4		:where to start searching for chns
	STH	R2,RMRFLG		:a positive value so KS.RRC is correct
	LHL	R6,TBDPKN,KN,KN		:START OF 1/2 WD TABLES FOR LINK
	LHL	R7,FLDPKN,KN,KN		:START OF FLAGS FOR LINK
	LHI	R0,0C000		:ALWAYS LOOK AT CHANNELS 0 AND 1
	OH	R0,CHSRVD,R7,
	STH	R0,CHSRVD,R7,
	LB	R0,SHSTAT,KD		:TEST SHRINK STATE
	JEfs	RMKB0			:NO SHRINK ACTIVITY
	j	rmkshk

RMKB0	RBT	KN,BPMTII		:TIME TO SEND BACKPRESSURE RELIEF REC?
	JEFS	RMKNCH			:NO
	J	RMKBP			:yes, send bp relief record

:	FIND NEXT CHANNEL TO SERVICE. SCAN FOR CHANNEL WITH BUFFER FLAG
:	SET AND 'CHSRVD' SET.
RMKNCH	HS	0
	LHL	R2,RMTSR4		:last chn serviced for this link
	OHI	R2,0F			:search from this HW
	LR	R1,R2
	SRLS    R1,3			:make into # HWs -1
	LA	R0,LNKFLG-1,R1,R7       :data present flags
	LA	R1,CHSRVD-1,R1,R7       :chns not yet serviced or BPed flags
	ARAND	R0,R2			:ARRAYAND RETURNS HIGHEST NONZERO
					: BIT NUMBER IN R2
	JFS	RMKHIT			:ARRAYAND RESULT WAS NONZERO
	J	RMK3			:ARRAYAND RESULT WAS ZERO,
					: DONE WITH THIS LINK

:	FOUND CHANNEL WHICH NEEDS AND IS ALLOWED SERVICE

RMKHIT  STH	R2,RMTSR4		:last chn checked
	RBT	R2,CHSRVD,R7,		:chn is now serviced
	LR	CHN,R2			:SET UP LINK RELATIVE  CHANNEL NUMBER
	AR	CHN,CHN			:CHANNEL NUMBER*2

:	SEE IF PAGE CHANGE NEEDED

	EXBR	R1,R2			:GET PAGE NUMBER
	LBR	R1,R1
	CLB	R1,RMPAGE,KN,KN		:NEED PAGE CHANGE?
	JEFS	RMHIT3			:NO, CHANNEL IN RANGE OF CURRENT PAGE
	STB	R1,RMPAGE,KN,KN		:YES - SAVE NEW PAGE NUMBER
	AHI	R1,80			:INSERT PAGE CHANGE RECORD
	STB	R1,0,PRD		: INTO PACKET

	AIS	PRD,1			:INCREMENT PHYSICAL RECORD POINTER
	SIS	PRC,1			:DECREMENT PHYSICAL RECORD BYTE COUNT

:	SEE IF BACKPRESSURE COUNT SHOULD BE RESET

RMHIT3  LHL	R2,NIOTAB,R6,CHN	:NOW GET PERMUTER TABLE ENTRY
	NHI	R2,-4			:MASK OUT SPEED BITS
	JNFS	RMHIT8			:MUST BE NONZERO
	IF	DB.DEB
	DBOOPS				:ERROR - ZERO ENTRY IN PERMUTER TABLE
	ELSE	:NOT DB.DEB
	LHI	R0,LS.ZPT		:DON'T KNOW HOW, BUT WE GOT A NULL
	J	RMKSNP			: PERMUTER TABLE ENTRY - SNIP THE LINK
	EI	:DB.DEB

RMHIT8  XHI	R2,4			:FLIP TO OUTBOUND BUFFER #

	SUBTTL	YAKYAK (RMK - Tymnet-II link)


::	HERE TO PROCESS LOGICAL RECORDS TO TRANSMIT
::	ON A TYMNET II LINK
::
::	DETERMINE LRC, THE NUMBER OF BYTES TO BE PUT INTO THE RECORD.
::	THIS WILL BE THE MINIMUM OF:
::	1.	CBCCT(BUFFER)	# OF CHARACTERS IN BUFFER
::	2.	BPSCNT(CHAN)	# OF CHARS ALLOWED BY BACKPRESSURE. THIS
::				VALUE IS NEVER LESS THAN 8 - SEE RMK12
::	3.	PRC-2		SPACE LEFT IN PACKET - AT LEAST 10 (RMK17)

RMKTW	LHL	LRC,BPSCNT,R6,CHN
	thi     lrc,-8
	JE	RMKBRZ
RMKTW1	JAL	R8,CBCCT		:CBCT - Compute BCT (GET BUFFER COUNT)
	CR	R1,LRC			:WHICH IS SMALLER?
	JGEFS	RMK10			:BPSCNT,LRC LIMITED BY BACKPRESSURE
	LR	LRC,R1			:CHRCNT,LRC LIMITED BY CHARS AVAILABLE
RMK10	CLHI	LRC,-2,PRC		:WILL ALL BYTES FIT IN PHYSICAL PACKET?
	JLE	RMKP3			:YES
	LHI	LRC,-2,PRC		:NO,LRC LIMITED BY SPACE LEFT IN PACKET
	LR	R0,CHN			:SO RMAKE WILL BUILD A MAXIMUM PACKET
	SRLS	R0,1			:GET ACTUAL CHAN NO. INTO R0

::	LOGICAL RECORD SIZE IS RESTRICTED BY SPACE LEFT IN PACKET. IF
:: 	LRC LESS THAN THRESHOLD, GIVE THIS CHANNEL ANOTHER TURN.

	CLHI	LRC,T2SRVS
	JLEFS	RMKP1			:THIS CHAN GETS 1ST TRY AT NEXT PACKET

	TBT	R0,PRIRTY,R7,		:IS THIS A PRIORITY CIRCUIT
	JEFS	RMKP3			:NO, JUST COUNT IT
	LH	R1,PRICNT,KD		:COUNT PRIORITY RECORD
	AIS	R1,1
	STH	R1,PRICNT,KD
	SIS	R1,3			:EQUAL TO 0 MOD 4?
	JEFS	RMKP3
RMKP1	HS	0
	SBT	R0,CHSRVD,R7,		:NEXT TURN WILL GO TO PRIORITY CHANNEL

::	IF BACKPRESSURE RESTRICTION COUNT (BPSCNT) DECREMENTS TO 8 OR LESS,
::	CHSRVD BIT WILL BE RESET IN RMK12.

RMKP3	LR	CD,LRC			:CD (R13) USED AS A WORKING COPY OF LRC
	JNFS	RMK16A
	IF	DB.DEB
	DBOOPS				:NO ZERO LENGTH RECORDS
	ELSE	:NOT DB.DEB
	LHI	R0,LS.EBF		:INDICATE EMPTY BUFFER FOR ACTIVE CHAN
	J	RMKSNP			: AND GO SNIP THE LINK
	EI	:DB.DEB

RMK16A	AIS	PRD,2			:INDEX TO START OF DATA
	L	R3,BB,R2,		:GET CHARACTER OUT PTR
	JNFS	RMK5
	CRASH.(.RMEB0)

	IF	1-NAD68		:NAD or Nada				###wjl

RMK5	SIS	PRD,1			:BACK UP TO LAST BYTE STORED
RMK5C	LHL	R0,0,PRD		:SET UP R1 AS SCRATCH
	EXHR	R0,R0			: REGISTER FOR THE
	LHL	R1,0,R3			: MICROCODE
	OR	R1,R0

::	RMAKE MICROCODE INSTRUCTION
::	R1 = scratch
::	CD = WORKING COPY OF LRC, # OF BYTES TO COPY
::	R12 = PRD  => POINTER TO OUTPUT RECORD
::	R3 = BB (address of next character to be output)
RMK5A	HC	0E1D			:RMAKE Copy 1 - SCRATCH REG, COUNT
RMK5B	HC	0F1D			:RMAKE Copy 2 - CONTINUATION ADDRESS
	HC	RMKNXT-RMK5B		:TO RELEASE EMPTY BUFFERLET
	HC	RMKC00-RMK5B		:TO HANDLE CHARACTER PAIR
	HC	RMKC01-RMK5B		:TO HANDLE PREFIX CHARACTER
	HC	RMKC02-RMK5B		:TO HANDLE GOBBLERS
	HC	RMKC03-RMK5B		:TO HANDLE GOBBLERS/ZAPPERS

	ELSE	:NAD68		:NAD to 68020 assembler			###wjl

:	NO RMAKE MICROCODE INSTRUCTION AVAILABLE			###wjl
RMK5
RMK5A	LB	R1,0,R3			:move a byte of data		###wjl
	CL	R3,BE,R2,		:end of this buffer?		###wjl
	JNFS	RMK6			:no				###wjl
	JAL	R8,GCLAST		:yes				###wjl
	L	R3,BB,R2,		:				###wjl
	JFS	RMK7			:				###wjl
RMK6	AIS	R3,1			:increment BB			###wjl
	THI	R3,CBSZ-1		:end of bufferlet?		###wjl
	JNFS	RMK7			:no				###wjl
	JAL	R8,GCRET		:yes, return it			###wjl
	GL	GCRET			:				###wjl
	L	R3,BB,R2,		:				###wjl
RMK7	STB	R1,0,PRD		:store the byte			###wjl
	SIS	R1,3			:test for special chars		###wjl
	JGFS	RMK14			:data				###wjl
	J	RMKTYM			:control char			###wjl
RMK14	AIS	PRD,1			:increment PRD			###wjl
	SIS	CD,1			:decrement CD (LRC)		###wjl
	JG	RMK5A			:LRC=0?				###wjl
	SIS	PRD,1			:conform to microcode set-up	###wjl

	EI	:NAD68

	IF	DB.DEB	
	JFS	RMK5XT			:IN CASE UPSW TRACE ENABLED
	EI	:DB.DEB

:	DONE WITH RMAKE COPY FOR THIS CHANNEL
RMK5XT	HS	0
	AIS	PRD,1			:INCREMENT PRD TO NEXT LOGICAL RECORD
					: LOCATION (OR END OF PACKET)
	IF	DB.DEB
	LR	R2,R2			:VERIFY BUFFER INDEX STILL O.K.
	JNFS	RMK5OK			:NON-ZERO - MUST BE O.K....
	DBOOPS				:DEFINITELY NOT O.K.
	EI	:DB.DEB
RMK5OK  LHI	R0,-1,R3		:BACK UP BB POINTER
	CL	R0,BE,R2,		:BUFFER EMPTY?
	JNfs	RMKIG5			:NO, SKIP
	JAL	R8,GCLAST		:YES, RETURN LAST BUFFERLET
	GL	GCLAST
	J	RMK12			:RETURN TO MAINLINE

:RMKIG3  AIS	PRD,1			:FIX UP R12 (PRD) FOR MAINLINE CODE
RMKIG5  ST	R3,BB,R2,
	J	RMK12


	IF	NAD68		:NAD to 68020 assembler			###wjl

:	TYMNET CONTROL CHARACTERS	:				###wjl
RMKTYM	AIS	R1,3			:restore character		###wjl
	LR	R0,R1			:conform to microcode set-up	###wjl
	CLHI	R0,3			:03 ??				###wjl
	JE	RMKC03			:test for various pairs		###wjl
	J	RMKC0X			:00, 01, or 02 char pairs	###wjl

	ELSE	:not NAD68	:NAD or Nada				###wjl

:	HERE TO RELEASE EMPTY BUFFERLET AND GET NEXT ONE
RMKNXT  LHI	R4,-1,R3		:MICROCODE INC'D POINTER
	CL	R4,BE,R2,		:BUFFER EMPTY?
	JNFS	RMKNX5			:NO, JUST BUFFERLET
	JAL	R8,GCLAST		:YES
	LIS	R3,0			:FLAG R3
	J	RMK5B

RMKNX5	THI	R3,CBSZ-1		:really end of bflet?
	JN	RMK5B			:nope, put the char
RMKNX7	JAL	R8,GCRET		:FREE ONE BUFFERLET
	GL	GCRET
	L	R3,BB,R2,
	J	RMK5B			:CONTINUE

	EI	:NAD68

:	COME HERE ON 00,01 AND 02 CHARACTER PAIRS
RMKC00  LIS	R0,0			:CREATE THE '00'
	JFS	RMKC0X

RMKC01  LIS	R0,1			:CREATE THE '01'
	JFS	RMKC0X

RMKC02	LIS	R0,2			:CREATE THE '02'

RMKC0X  CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RMKIG			: CHANNELS 0 AND 1

	SIS	CD,1			:ROOM IN LOGICAL RECORD FOR BOTH BYTES?
	JG	RMKC0Z			:YES, GO STORE THEM

:	NO ROOM FOR CHARACTER PAIR IN LOGICAL RECORD. DECREMENT
:	LRC, AND PUT CHARACTER BACK IN BUFFER.

	SIS	LRC,1			:LOGICAL RECORD SHORTER THAN EXPECTED
	JGFS	RMKC0Y
	CRASH.(.RMZLR)
RMKC0Y  LR	R1,R0			:GET THE CHAR TO R1
	ST	R3,BB,R2,		:SET UP BB FOR CALL TO WCD
	JAL	R8,WCD			:PUT CHAR BACK IN BUFFER
	J	RMK12			:DONE WITH LOGICAL RECORD

RMKC0Z	STB	R0,0,PRD		:STORE THE FIRST CHARACTER
	ST	R3,BB,R2,		:SET UP FOR CALL TO GCI
	JAL	R8,GCI			:GET THE SECOND CHARACTER
	GL	GCI
	L	R3,BB,R2,		:GET THE NEW POINTER
	AIS	PRD,1			:INCREMENT PACKET POINTER
	STB	R1,0,PRD		: AND STORE SECOND CHARACTER
	AIS	PRD,1
	SIS	CD,1			:ADJUST COUNT FOR SECOND CHARACTER
RMKCZZ	LR	CD,CD			:ENTRY POINT FROM RMK3TB, CHECK AGAIN
	JN	RMK5			:MORE DATA TO MAKE - GO DO IT
					: (R3 ALREADY SET UP)
	J	RMK12			:DONE WITH THIS LOGICAL RECORD

:	COME HERE TO IGNORE SPECIAL CHARACTERS -- ALSO EXIT AREA

RMKIG	SIS	CD,1			:DECREMENT COUNT SINCE MICROCODE DIDN'T
	JG	RMK5A			:MORE TO DO
	STB	R0,0,PRD		:IN CASE MICROCODE DIDN'T STORE IT
	J	RMK5XT			:GO FIX R12, (PRD), TEST FOR EMPTY BUFF

::	COME HERE ON '03' CHARACTER PAIRS -- TYMNET II
::	R3 = POINTER TO SECOND CHAR IN 03-XX PAIR
::	R12 (PRD)  = POINTER TO BYTE IN PHYSICAL RECORD JUST 'FILLED' WITH 03
::	CD HAS NOT BEEN DECREMENTED TO REFLECT THE 03 CHARACTER
::	03 CHAR HAS BEEN WRITTEN TO PHYSICAL RECORD ONLY IF R12 (PRD) IS EVEN

RMKC03  LIS	R0,3			:CREATE A '03' 
	CLHI	CHN,2			:IGNORE SPECIAL CHARACTERS ON
	JLE	RMKIG			: CHANNELS 0 AND 1
	SIS	CD,1			:ROOM FOR 03-XX CHAR PAIR
					: IN LOGICAL RECORD?
	JGFS	RMKC3A			:YES - HANDLE 03-CHARACTER PAIR
	SIS	LRC,1			:NO, LOGICAL REC WILL BE SHORTER
					: THAN EXPECTED
	JG	RMKC0Y			:RETURN 03 TO BUFFER,
					: FINISH LOGICAL RECORD
	l	r0,be,r2,		:helpful in debugging
	CRASH.(.RMZL3)
RMKC3A  LB	R1,0,R3			:LOOK AT 2ND CHARACTER
	CLHI	R1,20			:PERFORMANCE MONITORING OR HIGHER?
	JGEFS	RMKC3B			:YES, STUDY FURTHER
	CLHI	R1,NEEDP&0FF		:IS IT A NEEDLE?
	JE	RMKNEE			:YES, GO PROCESS NEEDLE
	IF	BFLTMR			:possibility of a bfr timer? ###jhl
	CLHI	R1,COMET&0FF
	JE	RMKBFD			:if so, jump to COMET-handler
	EI	:BFLTMR
	JL	RMK03N			:0300-030F, NETWORK CHARACTER PAIR
	J	RMKC0Z			:NONE OF ABOVE, JUST PASS CHAR ON

RMKC3B  CLHI    R1,3F			:pass all above 3f
	JG	RMKC0Z			:not a perfomance monitor
       IF       LOGII
	CLHI    R1,NEEDHD&0FF		:needle head
	JL	RMKPFM			:not a needle, must be perf mon car
	JE	RMKNHD			:LOG II needle
	CLHI    R1,NEEDTL&0FF		:(032b) needle tail
	JG	RMKPFM			:a perfomance monitor char
	J	RMKC0Z			:put needle char in logical record
       ELSE     :not logII
	J	RMKPFM			:20-3F are perfomance monitoring
       EI       :LOGII

       IF       LOGII
:       do needle housekeeping for LOG II needle
RMKNHD  ST	R3,BB,R2,		:char was read from buffer
	LH	R8,NEDOUT,KD		:one fewer outstanding needle
	JGFS    RMKNH1			:must be positive
	CRASH.(.RMNER)
RMKNH1  SIS	R8,1
	STH	R8,NEDOUT,KD
	JNFS    RMKNH2			:now at no outstanding needles?
	SBT     KN,LKTEAR		:unsuspend shrink
RMKNH2  LIS	R0,1			:more active channels on the link
	AHM	R0,ANCHN,KD
	LR	R0,CHN
	SRLS    R0,1			:chn # (from times 2)
	RBT	R0,NEEDLE,R7,
	JNFS    RMKNH4			:was a needle for this chn
	LR	R9,R0
	CRASH.(.RMKNE)
RMKNH4  JAL	R8,NEDTIM,,		:save needle travel time
	L	R3,BB,R2,		:restore the destroyed
	LIS	R0,3
	LHI	R1,NEEDHD&0FF
	J	RMKC0Z			:continue processing

       EI       :LOGII

::	RMKNEE
::	PROCESS NEEDLE

RMKNEE  ST	R3,BB,R2,		:SAVE BB
	JAL	R8,NCI			:SKIP A CHAR
	GL	NCI
	JAL	R8,NCI			:SKIP ANOTHER
	JAL	R8,PCI			:PEEK AT THIS ONE -- BYTE COUNT IN R1
	CLHI	R1,-2,PRC		:WILL IT FIT IN THIS RECORD?
	JG	RMKNE5			:NO, BACK UP

::	DECREMENT NUMBER OF NEEDLES OUTSTANDING BETWEEN CRQ AND RMAKE.
:: 	IF NEDOUT=0 AND NEDSUS<>0, THEN A LINK SHRINK HAS BEEN SUSPENDED
::	AND SHOULD BE RE-SCHEDULED.

	LH	R8,NEDOUT,KD		:NUMBER OF NEEDLES OUTSTANDING
	JGFS	RMKNE2			:SHOULD BE POSITIVE
	CRASH.(.RMNER)
RMKNE2	SIS	R8,1
	STH	R8,NEDOUT,KD		:NEW COUNT OF NEEDLES OUTSTANDING
	JNFS	RMKNE3			:OTHERS STILL TO PROCESS
	LB	R0,NEDSUS,KD		:IS THERE A SHRINK SUSPENDED?
	JEFS	RMKNE3			:NO

::	THERE WAS A SHRINK SUSPENDED AND NO NEEDLES ARE NOW OUTSTANDING.
::	RTD WILL RE-EXAMINE PACKET WITH SHRINK COMMAND/REQUEST.

	SBT	KN,LKTEAR		:SCHEDULE RTD TO PERFORM SHRINK

RMKNE3	LIS	R0,1
	AHM	R0,ANCHN,KD		:INCREMENT NUMBER OF ACTIVE CHANNELS
	LR	R0,CHN
	SRLS	R0,1			:RELATIVE CHANNEL NUMBER
	RBT	R0,NEEDLE,R7,		:INDICATE NEEDLE HANDLED
	JNFS	RMKNE4
	LR	R9,R0			:PRESERVE ABSOLUTE CHANNEL NUMBER 
	CRASH.(.RMKNE)
RMKNE4	LR	LRC,R1			:INSURE LOGICAL RECORD COUNT
					: INCLUDES ENTIRE NEEDLE
	LHI	CD,-1,LRC		:SUBTRACT 1 FOR '03' CHARACTER
	JAL	R8,NEDTIM,,		:COMPUTE NEEDLE TIME, SET CIRCUIT TIME
	GL	NEDTIM
	L	R3,BB,R2,		:RESTORE BB
	LIS	R0,3			:CREATE FIRST CHARACTER AGAIN
	J	RMKC0Z

RMKNE5  LIS	R1,3			:NEEDLE WON'T FIT -- BACK UP
	JAL	R8,WCD			:PUT '03' BACK IN BUFFER

::	ARTIFICIALLY EXTEND LENGTH OF PACKET BY STORING A COUPLE OF EXTRA
::	NULLS. IF LAST THING IN PACKET WAS PAGE CHANGE COMMAND TO HANDLE NEEDLE
::	CHANNEL, NEIGHBOR'S RTD WILL NOT NOTICE IT DUE TO TEST IN RTD1 ASSUMING
::	3 OR MORE CHARACTERS IN LOGICAL RECORD.

	LIS	R1,0
	STB	R1,-2,PRD,		:NGHBR INTERPRETS NULLS AS END-OF-PACKT
	STB	R1,-1,PRD,
	SIS	PRC,2			:MAKE PACKET COUNT CONSISTENT

	SRLS	CHN,1			:GET CHANNEL NUMBER
	SBT	CHN,CHSRVD,R7,		:NEEDLE WILL BE 1ST REC IN NEXT PACKET
	J	RMKXIT

	IF	BFLTMR			:if buffer timer pairs enabled?
:	This is the COMET (0314) handler.	
RMKBFD	HS	0
	ST	R3,BB,R2,
	JAL	R8,GCI			:read out the 14 (03 already out)
	JAL	R8,GCI			: followed by two consecutive
	LR	R4,R1			: bytes of FASTC
	EXBR	R4,R4			:they're unescaped, so we write our
	JAL	R8,GCI			: own retriever
	AR	R1,R4			:put the result in R1
	LHL	R0,FASTC+2,,		:what time is it now?
	SR	R0,R1			:difference into R0
	AHM	R0,BDLACC,KD		:add into halfword accumulator
	LHL	R0,BDLCNT,KD
	AIS	R0,1			:and bump the frequency counter
	STH	R0,BDLCNT,KD
:	adjust the buffer pointers and counters?
	L	R3,BB,R2,		:restore BB to R3
	SIS	CD,3			:adjust char out count for these 3 char
	SIS	LRC,4			:adjust LRC to ignore four timing chars
	LR	CD,CD			:TEST CODE
	JE	RMK12			:TEST CODE
	J	RMK5			:restart the RMKCOPY instructions
	EI	:BFLTMR

::	RMK12:
::	RECORD TRAFFIC STATISTICS AND UPDATE BACKPRESSURE FOR CHANNEL.
::	INSERT LOGICAL RECORD COUNT FIELD AND HEADER.
::	IF REBUILD IS ENABLED AND THE CIRCUIT IS A TERMINATION COPY
::	USER DATA INTO THE CIRCUIT'S HISTORY BUFFER.
::	EXPECTS PRD TO POINT BEYOND LAST DATA BYTE IN RECORD, LRC=BYTE COUNT

RMK12	LR	LRC,LRC			:NO ZERO LENGTH RECORDS
	JNFS	RMK122
	IF	DB.DEB
	DBOOPS
	ELSE	:NOT DB.DEB
	LHI	R0,LS.ZLR		:INDICATE ATTEMPT TO MAKE ZERO-LENGTH
	J	RMKSNP			: RECORD AND GO SNIP THE LINK
	EI	:DB.DEB

RMK122	AM	LRC,KS.LCO,KD		:COUNT LOGICAL CHARACTERS OUTPUT
	LIS	R3,1			:TO INCREMENT LOGICAL RECD FIELD###jhl
	AHM	R3,KS.LRM,KD		:ADD IT INTO LAST MINUTE'S COUNT###jhl

	SHI	PRC,2,LRC		:NOW UPDATE PRC
	LHL	R3,BPSCNT,R6,CHN	:UPDATE CHAN BACKPRESSURE COUNT LIMIT
	SR	R3,LRC			:SUBTRACT OUT CURRENT LOGICAL REC SIZE
	sth	r3,bpscnt,r6,chn
	SRLS	CHN,1			:GET ACTUAL CHANNEL NUMBER

	sis	R3,8			:NEW BACKPRESSURE LIMIT >8 BYTES?
	JGFS	RMK13			:OK. ELSE MARK BACKPRSR LIMIT EXHAUSTED
	RBT	CHN,LNKBPV,R7,		:BY CLEARING CHAN'S BACKPRESSURE FLAG
	RBT	CHN,CHSRVD,R7,		:ENSURE CHAN NOT SERVICED AGAIN UNTIL 
					:NGHBR REFRESHES BACKPRESSURE RESTRICTN
RMK13	LR	R9,PRD			:FORM THE LOGICAL RECORD HEADER
	SR	R9,LRC			:COMPUTE POINTR TO BEGIN OF LOGICAL REC
	STB	CHN,-1,9,		:INSERT CHANNEL NUMBER AND
	STB	LRC,-2,9,		: LOGICAL REC COUNT (DATA BYTES ONLY)

	XHI	R2,4			:FLIP TO OTHER BUFFER
	LH	R1,BF,R2,		:GET SOURCE ABSOLUTE CHANNEL NUMBER
	JLFS	RMK132			:BUFFER RETURNED
					: DUE TO ZAPPER BEING PROCESSED
	TBT	R1,TRCHAN,,		:TRACING DESIRED FOR THIS CHANNEL?
	JEFS	RMK132			:NO
	LCS	R0,1			:YES, INDICATE TRACING OUTBOUND DATA
	JAL	R8,CHRTRC		:MAKE ENTRY IN TRACE TABLE

	IF	REBILD
	LR	R9,PRD
	SR	R9,LRC			:RESTORE R9
	EI	:REBILD

RMK132	HS	0
	XHI	R2,4			:RESTORE BUFFER INDEX

::	CREATE HISTORY USING RTD MICROINSTRUCTION FOR TERMINATING 
::	CHANNELS WITH REBUILD ENABLED.
::
::	THE HISTORY BUFFER RULES ARE: ONLY DATA THAT THE USER WILL
::	RECEIVE GOES INTO THE BUFFER. SQACKS, SQFIXS AND NEEDLES
::	DON'T MAKE HISTORY. FAT GOBBLERS ARE CONVERTED TO NORMAL
::	GOBBLERS AND SAVED.
::
::	NOTE!!! THAT R4 PRESERVES THE BUFFER NUMBER FOR RMHFIN!!!

	IF	REBILD
	LR	R4,R2			:SAVE THE OUTBOUND BUFFER NUMBER IN R4
	SRLS	R2,3			:FORM REBUILD BIT ARRAY INDEX
	TBT	R2,CRQBSY		:IS REBUILD ENABLED HERE?
	JE	RMK17			:NO, SKIP ALL THIS STUFF
	AR	R2,R2			:YES, FORM THE HISTORY BUFFER NUMBER
	AI	R2,HBUFN,R2		:BY ADDING IN THE BASE HISTORY BUFFER #
	SR	PRD,LRC			:BACK UP PRD TO 1ST BYTE OF DATA IN REC
	LR	CD,LRC			:MICROCODE USES CD FOR WORKING BYTE CNT
	
::	RMHIST
::	INITIAL ENTRY POINT TO PERFORM RTD MICROCOPY, AND ALSO CONTINUATION
::	POINT AFTER PROCESSING SPECIAL CHARACTER PAIRS

RMHIST	L	R3,BE,R2,		:CURRENT HISTORY BUFFER 'IN' POINTER
	JNFS	RMHIS1			:BUFFERLET ALREADY ALLOCATED
	JAL	R8,WCFRST		:GET A BUFFERLET
	SIS	R3,1			:INITIALIZE R3 (BE) FOR MICROCODE

       IF	1-NAD68		:NAD or Nada				###wjl

RMHIS1	LHL	R0,0,R3			:SET UP SCRATCH REGISTER
	EXHR	R0,R0
	LHL	R1,0,PRD
	OR	R1,R0

RMKHSA	HC	3B1D		:RTD Copy 1 - USING R1=SCRATCH, CD=COUNT
RMKHSB	HC	3C1D		:RTD Copy 2 - HERE AFTER GETTING NEW BUFFERLET
	HC	RMKHSN-RMKHSB		:TO GRAB ANOTHER BUFFERLET
	HC	RMKHS0-RMKHSB		:TO HANDLE ESCAPED CHARACTERS
	HC	RMKHS1-RMKHSB		:PREFIX CODES
	HC	RMKHS2-RMKHSB		:T-I GOBBLERS?
	HC	RMKHS3-RMKHSB		:T-II 03-XX CHAR PAIRS AND QUADS

       ELSE	:NAD68		:NAD to 68020 assembler			###wjl

RMHIS1					:no set up required		###wjl
RMKHSA	LB	R1,0,PRD		:move a single byte of data	###wjl
	AIS	PRD,1			:increment PRD			###wjl
	AIS	R3,1			:increment BE (the IN pointer)	###wjl
	THI	R3,CBSZ-1		:end of bufferlet?		###wjl
	JNFS	RMKH22			:no				###wjl
	JAL	R8,NXTBLT		:yes, get next bufferlet	###wjl
RMKH22	CLHI	R1,3			:test for TYMNET control chars	###wjl
	JGFS	RMKH44			:data				###wjl
	J	RMHTYM			:control char			###wjl
RMKH44	STB	R1,0,R3			:deposit the char		###wjl
	SIS	CD,1			:decrement LRC (the byte count) ###wjl
	JG	RMHIS1			:LRC=0?				###wjl

       EI	:1-NAD68		:				###wjl

:	DONE WITH RTD
	ST	R3,BE,R2,		:DONE - STORE BUFFERLET END POINTER
	J	RMHFIN			:GO HANDLE XSEQN UPDATES, SQFIXS, ETC.

       IF	NAD68		:NAD to 68020 assembler			###wjl

RMHTYM	CLHI	R1,2			:TYMNET control characters	###wjl
	JG	RMKHS3			:03-type character pair		###wjl
	JE	RMKHS2			:02 - T-I gobbler?		###wjl
	CLHI	R1,1			:				###wjl
	JE	RMKHS1			:01 - Virtual Terminal Signal Code#wjl
	J	RMKHS0			:00 - escape char for data	###wjl

       ELSE	:not NAD68	:NAD or Nada only			###wjl

:	HERE TO GET A NEW BUFFERLET
RMKHSN	JAL	R8,NXTBLT		:GET ANOTHER BUFFERLET
	JBS	RMKHSB			:RESUME PROCESSING

       EI	:NAD68

::	HERE TO HANDLE 00 AND 01 CHARACTER PAIRS. SET A BIT IN BSPLIT
::	IF THE CHARACTER PAIR WILL BE SPLIT ACROSS A BUFFERLET. PASS
::	THE CHARACTER PAIR ALONG.
::
::	THE 03-XX CHARACTER PAIR CODE TRANSFERS TO 'RMHSPA' IF IT DETERMINES
::	THAT THE CHARACTER PAIR IN QUESTION CAN BE HANDLED AS A PPREFIX CODE.

RMKHS0	LIS	R1,0			:PASS ON THE 00
	JFS	RMHSPA
RMKHS1	LIS	R1,1			:PASS ON THE 01
RMHSPA	ST	R3,BE,R2,		:STORE 'BE' - NEEDED FOR 'WCI' CALL
	STB	R1,0,R3			:STORE AWAY THE 00, 01, OR 03
	LB	R1,0,PRD		:NEXT BYTE (MICROCODE INCREMENTED PRD)
	JAL	R8,WCI			:WRITE IT INTO THE HISTORY BUFFER
	AIS	PRD,1			:ADVANCE PRD TO DATA BEYOND CHAR PAIR
	SIS	CD,2			:REDUCE REMAINING BYTE COUNT BY 2
	JG	RMHIST			:MORE DATA IN LOGICAL RECORD - CONTINUE
	JE	RMHFIN			:NO MORE DATA IN LOGICAL REC, FINISH UP
	CRASH.(.RMKHS)			:NEGATIVE LOGICAL RECORD COUNT

RMKHS2	HS	0			:###TZ
	CRASH.(.RMHS2)			:ILLEGAL 02 FOR HISTORY BUFFER	###TZ

::	RMKHS3:
::	HERE TO HANDLE 03-XX CHAR PAIRS BOUND FOR THE HISTORY BUFFER.
::	REBUILD CONTROL QUADS (SQFIX, SQACK) AND NEEDLES DO
::	NOT GO INTO THE HISTORY BUFFER AND DO NOT ADVANCE XSEQN.
::	FAT GOBBLERS ARE SHRUNK AND STORED AS NORMAL GOBBLERS. OTHER
::	03 PAIRS ARE TREATED AS DATA.

RMKHS3	HS	0
	LB	R0,0,PRD		:SEE WHAT THE NEXT CHARACTER MIGHT BE
	CLHI	R0,SQFIX&0FF		:IS IT A SQFIX?
	JE	RMHS3A			:YES
	CLHI	R0,SQACK&0FF		:OR A SQACK
	JE	RMHS3A			:YES
	CLHI	R0,20			:A PERFORMANCE MONITORING CHARACTER?
	JGE	RMHSPM			:YES, EXTRACT IT
	CLHI	R0,NEEDP&0FF		:OR A NEEDLE?
	JEFS	RMHSNE			:YES, A NEEDLE
	CLHI	R0,GOBBF&0FF		:A FAT GOBBLER?
	JEFS	RMHSFG			:YES, SHRINK IT
RMHS3B	LIS	R1,3			:NONE OF ABOVE - SOME HARMLESS 03-XX
	J	RMHSPA			: PAIR OR SHRUNKEN FAT GOBBLER.
					: PASS IT ON INTO BUFFER
RMHSNE	AHI	PRD,-1,LRC		:NEEDLE, RESTORE PRD TO POINT BEYOND
	JAL	R9,RSTRIP		:FREE UP POSSIBLY ALLOCATED BUFFERLET
	J	RMK17			:AND GO ON TO NEXT LOGICAL RECORD

RMHSFG	LIS	R1,3			:FAT GOBBLER - SHRINK IT. FORM THE '03'
	STB	R1,0,R3			:AND STUFF IT INTO BUFFERLET
	LIS	R1,8			:DO THE SAME FOR THE '08''
	ST	R3,BE,R2,		:SET UP 'BE' FOR WCI CALL
	JAL	R8,WCI			:WRITE THE 08 INTO HISTORY BUFFER
	AIS	PRD,5			:ADVANCE PRD BEYOND THE LAST 'FAT' BYTE
	SIS	LRC,4			:ADJUST LRC - ADVANCE XSEQN ONLY BY 2
	SIS	CD,6			:ALSO REDUCE THE WORKING BYTE COUNT
RMHSP1	JG	RMHIST			:MORE DATA
	JE	RMHFIN			:ALL DONE
	CRASH.(.RMHS4)
RMHSPM	AIS	PRD,1			:ADVANCE PRD BEYOND PERF. MONITOR
	SIS	LRC,2
	SIS	CD,2
	JBS	RMHSP1

RMHS3A	JAL	R9,RSTRIP		:SOME 03-XX QUAD THAT WON'T MAKE HSTORY
	SIS	LRC,6			:SO QUAD DOESN'T ADVANCE XSEQN
	AIS	PRD,5			:ADVANCE PRD BEYOND THE CHARACTER QUAD
	SIS	CD,6			:REDUCE REMAINING BYTE COUNT BY 4
	JG	RMHIST			:MORE DATA IN LOGICAL RECORD - CONTINUE
	JEFS	RMHFIN			:NO MORE DATA IN LOGICAL RECORD
					: - FINISH UP
	CRASH.(.RMHS3)

:	FINISH UP. R4=ORIGINAL OUTBOUND BUFFER, LRC=LOGICAL REC COUNT
:	ADJUSTED FOR 03-XX CHARACTER QUADS. PRD POINTS BEYOND THE LAST BYTE
:	IN THE LOGICAL RECORD JUST MADE. PRUNE BACK THE HISTORY
:	BUFFER IF NEEDED, AND ADD THE MODIFIED LRC INTO XSEQN.

RMHFIN	HS	0
	LHI	CD,CBSZ-cbptsz		:HIST BUFFER EXCEED ALLOCATED MAXIMUM?
	LH	R1,BCT,R2,		:CURRENT APPROXIMATE BUFFER SIZE
	LHL	R0,RHBSZ,R2,		:MAXIMUM ALLOWED SIZE (FROM LEP OR CRQ)
	SR	R1,R0			:FORM THE DIFFERENCE BETWEEN THEM
     IF  REBTST
	SR	R1,CD			:could have 2 bflets for 2 chars
	JLEFS   RMKFI1			:none to remove
	LR	R0,R1			:count to remove
	JAL	R9,RTBFTA,,		:approximate since not split char pair
	GL	RTBFTA
	AM	R0,SEQN,R2,		:r0 gets actual number returned
     ELSE
RMKFI2	SR	R1,CD			:ALLOW FOR EXTRA BUFFERLET
	JLEFS	RMKFI1			:HISTORY BUFFER NOT TOO BIG, CONTINUE
	JAL	R8,RETBLT,,		:TOO BIG, RELEASE LEADING BUFFERLET
	AM	CD,SEQN,R2,		:UPDATE SEQN OF LEAD CHAR IN HIST BUFF
	JBS	RMKFI2			:AND REPEAT HISTORY BUFFER SIZE TEST
      EI  :REBTST

::	SEND A SQFIX TO THE OTHER END IF AT LEAST 'SQNUMB' CHARS HAVE
::	BEEN SENT SINCE LAST SQFIX

RMKFI1	L	R0,XSEQN,R4,		:GET THE LATEST SEQUENCE NUMBER
	AM	LRC,XSEQN,R4,		:AND UPDATE IT BY OUTGOING COUNT
	X	R0,XSEQN,R4,		:TEST IF TIME FOR A SQFIX	###GT
	THI	R0,SQNUMB		:IF WE'VE PASSED SQNUMB HEX BYTES
	JE	RMK17			:NO, NOT TIME YET

	LR	R2,R4			:SET R2=BUFFER NUMBER FOR WCD CALL
	SRLS	R4,3			:TIME. CHECK IF ANY SQACKS HAVE COME IN
	TBT	R4,CRQBSY
	JN	RMKFI3			:YES, AT LEAST ONE HAS. SEND A SQFIX
	J	RMK17			:DISABLE REBUILD, CARRY ON WITH RMAKE

RMKFI3	L	R1,XSEQN,R2,		:GET LATEST XMIT SEQUENCE NUMBER
	LHL	R0,REBDIS,,		:DISPLAY SQF ACTIVITY?
	JEFS	RMKFI5			:NO
	ST	R1,CRYSBF		:DISPLAY SEQN SENT
	LHL	R0,BF,R2,		:CHANNEL #
	JAL	R8,CRYPTO,,		:LOG THIS###OAS(MAKE RX3)
	HC	CRYE6F
RMKFI5	JAL	R8,WCD			:PREFIX IT IN A BYTE AT A TIME
	EXBR	R1,R1			:LOW ORDER HW FIRST		###GT
	JAL	R8,WCD
	EXHR	R1,R1			:THEN HIGH ORDER HW		###GT
	JAL	R8,WCD
	EXBR	R1,R1
	JAL	R8,WCD
	LHI	R1,SQFIX
	JAL	R8,WCD
	EXBR	R1,R1
	JAL	R8,WCD

	EI	:REBILD

RMK17	CLHI	PRC,0A			:AT LEAST 10 BYTES LEFT IN FRAME?
	JGE	RMKNCH			:YES, LOOK FOR MORE PACKETS TO MAKE
	J	RMKXIT			:NO, EXIT RMK

::	RMK03N:
::	PROCESS NETWORK 03-XX CHARACTER PAIR.
::	STORE THE '03'CHARACTER INTO THE LOGICAL RECORD. EXTRACT THE
::	SECOND BYTE OF THE PAIR WITH A GCI CALL AND STORE IT TOO.
::	ADVANCE 'PRD' TO POINT BEYOND THE PAIR. ADJUST 'CD'. FINALLY,
::	DISPATCH ON CHAR PAIR TYPE TO SEE IF YOU'VE DONE THE RIGHT THING.

RMK03N	STB	R0,0,PRD		:MAKE SURE THE '03' WAS STORED
	AIS	PRD,1			:ADVANCE PRD TO CHAR FOLLOWING THE '03'
	ST	R3,BB,R2,		:NOW REMOVE THE SECOND CHARACTER...
	JAL	R8,GCI			:...USING A GCI CALL
	SIS	CD,1			:DEC WORKING LRC TO ACCNT FOR CHAR PAIR
	STB	R1,0,PRD		:COPY SECOND CHAR INTO OUTPUT RECORD
	AIS	PRD,1			:ADVANCE PRD BEYOND CHAR PAIR
	SLLS	R1,2			:FW indexing			###wjl
	L	R8,RMK3TB,R1,		:GET DISPATCH ADDR BASED ON 2ND ###wjl
	SRLS	R1,2			:				###wjl
	JR	R8			: BYTE OF 03-PAIR		###wjl


::	RMKGOB:
::	GOBBLER. IF THIS END IS A TERMINATION AND THE NEIGHBOR CAN HANDLE IT
::	AND REBUILD IS ENABLED CHANGE THE GOBBLER TO A FAT GOBBLER BY FORCING
::	LRC TO 6, AND STUFF THE CURRENT XSEQN BEHIND THE FAT GOBBLER.
::	NOTE THAT THIS XSEQN GOES UP TO, BUT DOES NOT INCLUDE, THE
::	FAT GOBBLER ITSELF.
::	ALSO NOTE THAT FAT GOBBLERS LEAVE THEIR ORIGINATING NODE
::	IN THEIR OWN LOGICAL RECORD, WITH NO ACCOMPANYING DATA.
::	IF THE FAT WON'T DO, PASS THE SKINNY GOBBLER ON UNMOLESTED.

RMKGOB	HS	0
	IF	REBILD
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE REBUILD STUFF?
	JLE	RMKCZZ			:NO, PASS ON THE GOBBLER
	JAL	R9,RMKFCH		:MAKE SURE GOBBLER IS FIRST CHARACTER
					:if not J RMK12, GET IT NEXT TIME###wjl
	LR	R0,R2
	SRLS	R0,3			:IS THIS A TERMINATING CHANNEL?
	TBT	R0,CRQEND
	JE	RMKCZZ			:NO, NOT A TERMINATION
	LIS	LRC,6			:YES - FORCE LRC TO 6
	L	R0,XSEQN,R2,		:GET THE LATEST XMIT SEQUENCE NUMBER
	STB	R0,3,PRD		:STORE AWAY THE LOWER BYTE
	EXBR	R0,R0
	STB	R0,2,PRD		:AND THEN THE UPPER BYTE
	EXHR	R0,R0			:NOW THE HIGH ORDER HW		###GT
	STB	R0,1,PRD		:				###GT
	EXBR	R0,R0
	STB	R0,0,PRD
	LIS	R0,9			:GOBBF&0FF BUT NAD WOULD CHOKE
	STB	R0,-1,PRD,		:CHANGE NORMAL GOBBLER TO FAT GOBBLER
	AIS	PRD,4			:ADVANCE PRD BEYOND THE 4 XSEQN BYTES
	J	RMK12			:TERMINATE LOGICAL RECORD BUILDING HERE
	ELSE	
	J	RMKCZZ			:NO REBUILD - PASS GOBBLER ON
	EI	:REBILD

:	RMKFGB:
:	FAT GOBBLER. STORE NEXT 4 BYTES (XSEQN) BEHIND FAT GOBBLER.

RMKFGB	JAL	R9,RMKFCH		:TEST FOR 1ST CHARACTER IN LOGICAL REC
					:if not J RMK12, GET IT NEXT TIME##GT
	JAL	R9,G2CI			:GET COUNT FROM BUFFER
	GL	G2CI
	STH	R1,SQNSAV		:SAVE HO HALFWORD		###GT
	JAL	R9,G2CI
	LHL	R0,SQNSAV		:RESTORE HO OF SEQN
	EXHR	R0,R0
	OR	R1,R0			:AND SAVE IN R1				
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE FAT GOBBLERS?
	JGFS	RMKRBC			:YES				###wjl
RMKFG0	HS	0			:				###TZ
	SIS	LRC,4			:NO, OLD VERSION
					: - LRC IS 4 LESS WITHOUT FAT
	LHI	R0,GOBBL		:CHANGE FAT GOBBLER TO NORMAL
	STB	R0,-1,PRD,		: GOBBLER IN PACKET
	JFS	RMKRC2
:	COMMON ENTRY POINT FOR CHARACTER-QUADS
RMKRBC	STB	R1,3,PRD		:STORE BUFFER DATA INTO PACKET
	EXBR	R1,R1
	STB	R1,2,PRD
	EXHR	R1,R1			:UPPER HW			###GT
	STB	R1,1,PRD
	EXBR	R1,R1
	STB	R1,0,PRD
	AIS	PRD,4			:INCREMENT RECORD POINTER AND
RMKRC2	SIS	CD,4			: DECREMENT LOGICAL RECORD WORKING CNT
	JE	RMK12			:DONE WITH NETWORK QUAD
	L	R3,BB,R2,		:MORE DATA - LOAD UP BB
	J	RMK5			: AND GO FINISH LOGICAL RECORD

:	RMKSQF:
:	SQF QUAD. JUST PASS IT ON IF NEIGHBOR CAN HANDLE IT

RMKSQF	JAL	R9,RMKFCH		:TEST FOR 1ST CHARACTER IN LOGICAL REC
					:if not J RMK12, GET IT NEXT TIME##wjl
	JAL	R9,G2CI			:GET SQF SEQUENCE NUMBER
	STH	R1,SQNSAV		:SAVE HO HALFWORD		###GT
	JAL	R9,G2CI			:LOWER HW OF SEQUENCE NUMBER
	LHL	R0,SQNSAV		:RESTORE
	EXHR	R0,R0			:PUT IN HIGH ORDER HW
	OR	R1,R0
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE SQF CHARACTERS?
	JG	RMKRBC			:YES - JUST PASS SQF QUAD ON...	###wjl

::	OLD VERSION NEIGHBOR - DON'T PASS ON THE SQF
::	SEND BACK A NAK USING SEQN=-1 SO WE DISABLE REBUILD
::	IMMEDIATELY INSTEAD OF WAITING FOR THE TIMEOUT

RMKOVR	LR	R4,R2			:SAVE R2			###GT
	SRHLS	R4,3
	TBT	R4,CRQEND		:IS THIS A TERMINATION?
	JN	RMKOV3			:DON'T SEND A NAK TO OURSELVES!
	XHI	R2,4			:FLIP TO OTHER BUFFER		###GT
	LHI	R1,SQFIX		:SEND BACK A SQFIX		###GT
	JAL	R9,W2CI
	LCS	R1,1			:SEND OUT A FULL-WORD OF -1
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	XHI	R2,4			:RESTORE BUFFER INDEX
RMKOV3	SIS	PRD,2			:DECREMENT PRD PAST 03-PAIR
	SIS	CD,4			:MORE DATA IN LOGICAL RECORD?	###GT
	JEFS	RMKOV2			:NO - CANCEL LOGICAL RECORD
	SIS	LRC,6			:ADJUST LRC SINCE IGNORING SQF QUAD
	JGFS	RMKOV1
	CRASH.(.RMZL0)
RMKOV1	L	R3,BB,R2,		:RESTORE BB AND
	J	RMK5			: GO FINISH LOGICAL RECORD
RMKOV2	SIS	PRD,2			:BACK UP TO LOGICAL RECORD BEGINNING
	J	RMKNCH			:GO FIND NEW CHANNEL WITH WORK

::*********************************************************************
::
::	SUBROUTINE:	RMKFCH:
::	FUNCTION:	TEST FOR 03-XX PAIR FIRST CHARS IN LOGICAL RECORD.
::	CALLING SEQ:	JAL	R9,RMKFCH
::	INPUT:		R1 = SECOND CHARACTER IN 03-XX PAIR.
::	CALLS:		JAL	R8,WCD
::	RETURNS:	RETURN IF TRUE, ELSE PUT 03-XX PAIR BACK
::			IN BUFFER AND J RMK12
::
::*********************************************************************

RMKFCH	HS	0
	CLHI	LRC,2,CD		:IS THIS FIRST DATA IN LOGICAL RECORD?
	JER	R9			:YES - RETURN			###wjl

	SHI	LRC,2,CD		:LRC NOW COUNT OF ALL CHARS BEFORE SQF
	JAL	R8,WCD			:REPLACE 2ND BYTE (IN R1) OF SQF PAIR
	LIS	R1,3
	JAL	R8,WCD			:REPLACE FIRST BYTE OF PAIR
	SIS	PRD,2			:UNDO INCREMENTS OF PRD
	J	RMK12			: AND J RMK12			###wjl

::
::*********************************************************************

::	RMKFZP
::	FAT ZAPPER. STORE NEXT FOUR BYTES (NODE PAIR) INTO PACKET 
::	PRIOR TO ZAPPING LAST HALF OF CIRCUIT.

RMKFZP	JAL	R9,RMKFCH		:TEST FOR FIRST CHAR IN LOGICAL REC
					:if not J RMK12, GET IT NEXT TIME###GT
	JAL	R9,G2CI			:GET FIRST TWO BYTES
	STB	R1,1,PRD		: AND STORE IN PACKET
	EXBR	R1,R1
	STB	R1,0,PRD
	JAL	R9,G2CI			:AND SECOND PAIR...
	STB	R1,3,PRD
	EXBR	R1,R1
	STB	R1,2,PRD
	LH	R0,KVERNO,KD		:CAN NEIGHBOR HANDLE FAT ZAPPERS?
	JGFS	RMKFZ2			:YES				###wjl
RMKFZ9	HS	0
	LHI	R0,ZAPPH		:NO, OLD VERSION - MAKE ZAPPER HARD
	STB	R0,-1,PRD,		: IN PACKET TO NEIGHBOR
	SIS	LRC,4			:NO NODE PAIR FOLLOWING ZAPPER...
	JFS	RMKFZ4
RMKFZ2	AIS	PRD,4			:INCREMENT RECORD POINTER
RMKFZ4	SIS	CD,4			: AND DECREMENT COUNT

::	RMKZAP
::	PROCESS ZAPPER ON TYMNET-II CHANNEL. ZAP 2ND HALF OF CIRCUIT,
::	DECREMENT NUMBER OF ACTIVE CHANNELS THIS LINK, AND TEST FOR ZAPPING
::	CIRCUIT IN THE PROCESS OF BEING BUILT.

RMKZAP	SR	LRC,CD
	JAL	R9,ZAPV,,		:NOW ZAP CIRC
	GL	ZAPV
	LCS	R0,1
	AHM	R0,ANCHN,KD		:DECREMENT NUMBER OF ACTIVE CHANNELS
	LHL	R0,SLOWC+2,,
	STH	R0,BPSCNT,R6,CHN	:SAVE TIME THAT CHANNEL ZAPPED
	LR	R0,CHN
	SRLS	R0,1			:RELATIVE CHANNEL NUMBER
	RBT	R0,NEEDLE,R7,		:DID WE ZAP A NEEDLE?
	JE	RMK12			:NO - CONTINUE
::	WE ZAPPED A BUFFER WHICH CONTAINED A NEEDLE NOT YET PROCESSED
::	BY RMAKE. DECREMENT 'NEDOUT' TO MAINTAIN CONSISTENCY.
	LH	R8,NEDOUT,KD
	JGFS	RMKZP2			:IT'D BETTER BE POSITIVE
	CRASH.(.RMNE0)
RMKZP2	LCS	R9,1
	AHM	R9,NEDOUT,KD		:DON'T HOLD UP SHRINK DUE TO NEEDLE...
	LIS	R9,1
	AHM	R9,LKNEDS,KN,KN		:INDICATE NEEDLE GOBBLED
	LR	R0,CHN			:CHAN#*2
	SRLS	R0,1
	LHL	R8,NDID,KD
	STH	R8,CRYSBF+2
	JAL	R8,CRYPTO,,		:SEND CRYPTOGRAM TO XRAY
	HC	CRYE0E			:(NEEDLE GOBBLED)
	J	RMK12

::	RMKPFM
::	PROCESS PERFORMANCE MONITORING CHARACTERS  ( 03 20 TO 03 3F )
::	THESE CHARS MUST BE THE FIRST CHARS IN THE OUTBOUND LOGICAL RECORD.
::	THE XLAX AND XLAX-ACK CHARS ARE PREFIXED INTO THE CHANNEL
::	BUFFER IN RTEAR, SO WILL ALWAYS BE AT THE TOP OF THE BUFFER,
::	BUT THE TIMER AND TIMER ACK CHARS MAY OCCUR ANYWHERE IN THE
::	BUFFER
::	ON ENTRY:
::	LRC	=	FINAL BYTE COUNT OF LOGICAL RECORD BEING MADE
::	CD	=	WORKING COPY OF LRC, DECREMENTED TO REFLECT '03' CHAR
::	R3	=	POINTS TO SECOND CHAR IN 03-XX CHAR PAIR
::	R1	=	SECOND CHAR IN 03-XX CHAR PAIR
::	R0	=	'03' CHAR IN CASE BRANCH TO RMKC0Z IS TAKEN

RMKPFM	CLHI	R1,PFMMAX		:VALID CHARACTER?
	JLEFS	RMKPF1			:YES
	CRASH.(.RMPER)
RMKPF1	LHI	R1,1,CD			:IS THIS FIRST BYTE IN LOGICAL RECORD?
	CR	LRC,R1			:IF CD+1 = LRC, THIS IS FIRST BYTE
	JE	RMKC0Z			:YES, PASS THE CONTROL CHAR ALONG
	SR	LRC,R1			:ELSE STOP BUILDING LOGICAL RECORD.
					: GET NEW LRC
	LIS	R1,3			:CREATE '03' FOR 03-XX PAIR
	ST	R3,BB,R2,		:SET UP BB FOR CALL TO WCD
	JAL	R8,WCD			:RESTORE 03 CHARACTER INTO BUFFER
	J	RMK12			:DONE WITH THIS LOGICAL RECORD

::*********************************************************************
::
::	TABLE:		RMK3TB:
::	FUNCTION:	DISPATCH TABLE FOR RMK 03-XX CHARACTER PAIRS
::
::*********************************************************************

RMK3TB	WC	RMKCZZ		:0300 RESERVED				###GT
	WC	RMKZAP		:0301 ZAPPH - HARD ZAPPER
	WC	RMKZAP		:0302 ZAPPS - SOFT ZAPPER
	WC	RMKZAP		:0303 ZAPPN - NON-GOBBLING ZAPPER
	WC	RMKFZP		:0304 ZAPPF - FAT ZAPPER
	WC	RMKCZZ		:0305 RESERVED				###GT
	WC	RMKCZZ		:0306 RESERVED				###GT
	WC	RMKCZZ		:0307 
	WC	RMKGOB		:0308 GOBBL - GOBBLER
	WC	RMKFGB		:0309 GOBBF - FAT GOBBLER
	WC	RMKCZZ		:030A UNUSED - PASS IT ON
	WC	RMKSQF		:030B SQFIF - REBUILD SEQ NUMBER FIX
	WC	RMKSQF		:030C SQACK - REBUILD SEQYENCE NUMBER ACK
	WC	RMKCZZ		:030D RESERVED
	WC	RMKCZZ		:030E RESERVED
	WC	RMKCZZ		:030F RESERVED

	SUBTTL  YAKYAK (RMKBRZ - rmake give transmit capability)

:	RMKBRZ  called directly from rmk and returns to RMKTW
:	HERE WHEN BPSCNT=0 FOR CHANNEL WE'RE ABOUT TO BUILD
:	LOGICAL RECORD FOR. LEGITIMATE ONLY FOR CHANNELS 0 & 1.
RMKBRZ	HS	0
	CLHI	CHN,2
	JLEFS	RMKBR0			:chn 0,1 have no limit
	SRLS    CHN,1			:make CHN*1
	RBT     CHN,BPSVCP,R7,		:if this node wanted to give output cap
	jnfs    RMKBR1			:nope, snip link
:       if count 0 then something illegal so snip
	IF	DB.DEB
	DBOOPS				:NOT O.K. - RMK12 SHOULD RESET
	ELSE	:NOT DB.DEB		:CHRSVD WHEN BPSCNT DECREMENTS TO .LE.6
	LHI	R0,LS.BPZ		:INDICATE BPSCNT = 0
	J	RMKSNP			: AND SNIP THE LINK
	EI	:DB.DEB
RMKBR1  AR      CHN,CHN 		:back to chn*2
RMKBR0  LIS	R3,3
	NH	R3,NIOTAB,R6,CHN	:get speed bits
	LHL	R3,CIRSPK,R3,R3
	STH	R3,BPSCNT,R6,CHN
	J	RMKTW

	subttl  YAKYAK (RMK3 - rmk found no chn needing service)

:	RMK3    called directly from RMK and either exits or returns

::	RMK3
::	ALL CHANNELS ON THIS LINK HAVE BEEN SCANNED. COPY THE CURRENT
::	BACKPRESSURE FLAGS INTO THE CHANNEL SERVICE ARRAY FOR THE NEXT
::	EXECUTION OF RMAKE ON THE LINK

RMK3
	LHL	R0,LKBPND,KN,KN		:PTR TO LAST HW IN BACKPRESSURE ARRAY
					: (LNKBPV)
	LHL	R1,LKSVND,KN,KN		:MOVE BP ARRAY TO SERVICE ARRAY
					: (CHSRVD)
	LHL	R2,NCHN,KD		:NUMBER OF BITS
	SHI	R2,10			:(NUMBER OF 1/2 WDS -1)*10

	COPY	R0,R2			:MOVE THE ARRAY
					: (R0=SOURCE, R1=DEST., R2=LEN.)
	TS	RMRFLG			:only count 1 round robin per RMK call
	JLFS    RMK301			:already counted RR
	RBT	KN,LKRR			:NOTE ROUND ROBIN COMPLETED FOR LINK
	LIS	R1,1
	AHM	R1,KS.RRC,KD		:INCREMENT ROUND-ROBIN COUNT FOR LINK
RMK301  TS	RMKFLG,KD		:if didn't look at every chn
	JE	RMKNCH			:GO LOOK FOR NEXT CHANNEL
	JFS	RMKEX1			:serviced all chns (this and last time)

:	GENERAL EXIT POINT

RMKXIT	LIS	R0,0
	STH	R0,RMKFLG,KD		:didn't service all chns this pass
RMKEX1	LHL	CD,NRMK,KD		:RESTORE CD (RECORD DESCRIPTOR ADDRESS)
	L	R9,RTMXSV		:	AND GET RETURN ADDRESS
	JR	R9			:RETURN TO CALLER

	subttl  YAKYAK (RMKSHK - rmake part of link shrinks)

:	rmkshk  called directly from rmake and returns directly
:		handles rmake waiting on shrink activity
:
rmkshk
	SIS	R0,2			:RMAKE FROZEN?
	JGR	R9			:YES,WAITING FOR NEIGHBOR TO ACK SHRINK
	JE	RMKSH2			:SEND SHRINK COMMAND OR REQUEST,
					: DEPENDING ON WHETHER WE ARE MASTER
					: OR SLAVE
	LHI	R1,0E1			:SHSTAT=1, SEND SHRINK ACKNOWLEDGE
RMKSH1	LIS	R0,0
	STB	R0,SHSTAT,KD		:THAW RMAKE
	STB	R1,0,PRD		:SEND SHRINK REQUEST/ACKNOWLEDGE
	STB	R0,1,PRD		:PACKET < 2 BYTES WON'T GET NOTICED
	AIS	PRD,2
	SIS	PRC,2			:INCR CURRENT POINTER, DECR PACKET CNT
	JR	R9			:SHRINK COMMANDS TRAVEL BY THEMSELVES
RMKSH2	LHI	R1,0E0			:SHRINK REQUEST/COMMAND
	LH	R0,NDID,KD
	CLHI	R0,MACHNM		:ARE WE SLAVE ON THIS LINK?
	JG	RMKSH1			:YES - SEND SHRINK REQUEST TO MASTER
	STB	R1,0,PRD		:NO - SEND SHRINK COMMAND TO SLAVE
	LIS	R0,0
	STB	R0,1,PRD		:MAKE 2-BYTE RECORD
	AIS	PRD,2
	SIS	PRC,2
	LIS	R0,3			:FREEZE RMAKE UNTIL SLAVE RESPONDS WITH
	STB	R0,SHSTAT,KD		: SHRINK ACKNOWLEDGE
	JR	R9

	SUBTTL  YAKYAK (RMKBP - RMAKE backpressure relief records)

:	RMKBP   makes the logical records for backpressure relief
:		called directly from rmake and returns directly.
:

RMKBP	LIS	R3,0			:INDEX INTO GUSH
	LR	R4,PRD			:POINTER TO BACKPRESSURE HEADER
	LHI	R0,0C0			:L.R. HEADER FOR BACKPRESSURE RECORD
	STB	R0,0,PRD		:L.R. COUNT=0 IS O.K., FORCES TRAFFIC
					: ON LIGHTLY LOADED LINK
	AIS	PRD,1
	SIS	PRC,1
	LHL	LRC,NCHN,KD		:MAX # OF CHANNELS ON LINK DIVIDED BY 8
	SRLS	LRC,3			: = # OF BYTES IN LINK ARRAYS (ie GUSH)
RMKB1	L	R0,GUSH,R3,R7		:EXAMINE GUSH ARRAY 1 WORD AT A TIME
RMKB2	JFFO	R0,RMKB3		:ONE FOR GUSHING CHANNEL - SEE WHETHER
					:BACKPRESSURE CAN BE RELIEVED
	AIS	R3,4
	CLR	R3,LRC			:DONE WITH THIS LINK?
	JLBS	RMKB1			:NO - CONTINUE
	J	RMK17			:ALL DONE WITH BACKPRESSURE RECORD

RMKB3	ST	R0,RTMT1		:TEMPORARY STORAGE (WORKING GUSH)
	RBT	R1,RTMT1		:THIS CHANNEL SERVICED
	LR	CHN,R3
	SLLS	CHN,3			:FORM CHANNEL NUMBER
	OR	CHN,R1
	AR	CHN,CHN			:2 * CHANNEL NUMBER
	LH	R2,NIOTAB,R6,CHN	:PERMUTER TABLE ENTRY
	LIS	R1,3
	NR	R1,R2			:ISOLATE SPEED BITS IN R1
	NHI	R2,-4			:BUFFER INDEX IN R2
	LHL	R0,BCT,R2,		:GET BUFFER BYTE COUNT
RMKBS2	CLH	R0,CIRSPK,R1,R1		: AND COMPARE TO CHANNEL CIRCUIT SPEED
	GL	CIRSPK
RMKBS3	JG	RMKB6			:BCT GREATER, DON'T RELIEVE BACKPRESSUR
	SRLS	CHN,1
	RBT	CHN,GUSH,R7,		:O.K. TO RELIEVE BACKPRESSURE
       if       1-notrik                :kill trickle logic
	RBT	CHN,TRIKLE,R7,
       ei       :1-notrik
RMKBS4	EXBR	R1,CHN
	CLB	R1,RMPAGE,KN,KN		:ARE WE CHANGING PAGES?
	JE	RMKB5			:NOPE - STILL ON SAME ONE
	STB	R1,RMPAGE,KN,KN		:YES - SAVE NEW PAGE NUMBER
	OHI	R1,80
	STB	R1,0,PRD		:INSERT PAGE CHANGE COMMAND
	AIS	PRD,1
	SIS	PRC,1
RMKB4	LHI	R1,0C1			:BACKPRESSURE HEADER, LENGTH 1
	STB	R1,0,PRD
	STB	CHN,1,PRD		:CURRENT CHANNEL RELIEVING BACKPRESSURE
	SIS	PRC,2
	LR	R4,PRD			:R4 POINTS TO NEW B.P. RECORD HEADER
	AIS	PRD,2
	J	RMKB6
RMKB5	LB	R0,0,R4			:GET BACKPRESSURE HEADER
	AIS	R0,1			:INCREMENT SIZE FIELD
	THI	R0,20			:IF IS MAX SIZE - TEST FOR OVERFLOW
	JN	RMKB4			:YES, CLOSE OFF RECORD, START NEW ONE
	STB	R0,0,R4			:STORE HEADER BACK WITH UPDATED COUNT
	STB	CHN,0,PRD		:CURRENT CHANNEL RELIVING BACKPRESSURE
	AIS	PRD,1
	SIS	PRC,1
RMKB6	L	R0,RTMT1		:GET WORKING GUSH BACK
	CLHI	PRC,3			:ROOM FOR PAGE CHANGE, HEADER, CHANNEL?
	JGE	RMKB2			:YES - CONTINUE
	SBT	KN,BPMTII		:NO - FILLED PACKET.
					: SCHEDULE BACKPRESSURE AGAIN.
	J	RMKXIT




	SUBTTL	YAKYAK (ILC - Inter-Link Control)

::*********************************************************************
::
::	SUBROUTINE:	ILC
::	FUNCTION:	Process Channel 0 messages received from neighbor.
::	CALLING SEQ:	J  ILC  (called directly from RTDXIT as part of
::				 RTD end processing.)
::	INPUT:		KD,R6
::	DESTROYED:	R1,R2,R3,R5,R8,R9,R10
::	CALLS:		JAL  R8,PCI
::			JAL  R8,CBCCT
::			JAL  R9,ZAPV
::			JAL  R10,TRACE
::	RETURNS:	JL   ILCRET  (returns from ILC process and goes
::					directly via  J  BPMV to process
::					backpressure received from neighbor.)
::
::*********************************************************************

ILC
RTDXIT  EQ	ILC			:PROCESS ANY ILC MESSAGE RECEIVED

	LHL	R2,NIOTAB,R6,		:ILC BUFFER
	NHI	R2,-4
	JNFS	ILC02			:GOT BUFFER NUMBER

	IF	DB.DEB
	DBOOPS				:PERMUTER TABLE ENTRY 0
	ELSE	:NOT DB.DEB
	LIS	R0,LS.ILC
	J	RTDSNP			:SNIP LINK, INDICATE CHN 0 PROBLEM
	EI	:DB.DEB
ILC02	LHL	R0,BCT,R2,
	JNFS	ILC03			:BUFFER IS EMPTY
ILCRET	HS	0			:RETURN FROM ILC PROCESS
        L	R9,RTMXSV		:EXIT
	JR	R9
ILC03	L	R3,BB,R2,		:SEE IF THERE IS A FULL MESS
	JAL	R8,PCI			:BYTE COUNT
	LR	LRC,R1
	JAL	R8,CBCCT		:CHARS IN BUFF
	GL	CBCCT
	CR	R1,LRC
	JL	ILCRET
	SIS	R1,2			:MUST BE AT LEAST 2 BYTES IN BUFFER
	JL	ILCRET

	JAL	R8,GCI			:DISCARD BYTE COUNT
	JAL	R8,GCI			:GET MESS TYPE
	CLHI	R1,ILCDMX
	JGEFS	ILCSKP			:UNKNOWN TYPE, SKIP
	SLLS	R1,2			:FW indexing			###wjl
	L	R1,ILCDIS,R1,		:DISPATCH			###wjl
	JR	R1			:				###wjl

ILCSKP	LHI	R5,-2,LRC		:DISCARD MESSAGE
ILCSK1	LH	R0,BCT,R2,		:FOR GARBAGE MESSAGE,
					: DON'T TRUST BYTE COUNT
	JE	ILCRET			:AVOID GCI CRASH...
	JAL	R8,GCI
	SIS	R5,1
	JGBS	ILCSK1
	J	ILC

ILCZAK	JAL	R8,GCI			:ZAPPER ACKNOWLEDGE
	EXBR	CHN,R1			:FOLL HW IS PORT #
	JAL	R8,GCI
	AR	CHN,R1
	AR	CHN,CHN
	LHL	R2,NIOTAB,R6,CHN
	NHI	R2,-4
	JE	ILC			:NO CIRCUIT THERE
	XHI	R2,4
	JAL	R9,ZAPV,,
	J	ILC

ILCTRC	CLHI	LRC,40			:TRACE
	JGE	ILCSKP			:TRACE TOO BIG, IGNORE
	SIS	LRC,1
	LIS	R1,03
	LIS	PRD,0
	JFS	ILCTRL			:COPY TRACE TO LEPMES BUFFER
ILCTR1	JAL	R8,GCI
ILCTRL	STB	R1,LEPMES,PRD
	AIS	PRD,1
	SIS	LRC,1
	JGBS	ILCTR1
	SIS	PRD,2
	LHL	CHN,LKZFKN,KN,KN	:COMPUTE ABS CHANN #
	AH	CHN,LEPMES,PRD
	NHI	CHN,7FFF
	STM	KN,TRREGS		:SAVE IMPORTANT REGS
	JAL	R10,TRACE,,		:DO CIRCUIT TRACE
	GL	TRACE
	LM	KN,TRREGS
	J	ILC

:	GET 32-BIT KEY USED IN MULTI-LINE RESET
ILCKEY	HS	0
	SIS	LRC,6			:EXPECT LENGTH OF 6
	JN	ILCSKP			:INVALID LENGTH - NEIGHBOR FAULT?

	LCS	R9,4
ILCKY1	JAL	R8,GCI			:GET NEXT KEY BYTE AND
	STB	R1,RKEY+4,KD,R9		: AND STORE IN LINK DESCRIPTOR
	AIS	R9,1
	JLBS	ILCKY1			:GET ALL 4 BYTES
	J	ILC			:DONE

::********************************************************************
::
::	TABLE:		ILCDIS:
::	FUNCTION:	DISPATCH TABLE FOR ILC MESSAGES RECEIVED FROM NEIGHBOR
::
::********************************************************************

ILCDIS	WC	ILCSKP,ILCKEY,ILCZAK,ILCTRC
ILCDMX	EQ	(.-ILCDIS)/4

RMKEND	HS	0			:DEFINE END OF RMAKE FOR MACERR OPTION

	ENDMO.(YAKYAK)
	EI	:1-KILLIT
	KILMSG(YAKYAK)

:	***NOTHING PAST THIS POINT***


	SUBTTL	XHOSTS

:		*   * *   *  ***   ***  *****  ***
:		 * *  *   * *   * *       *   *
:		  *   ***** *   *  ***    *    ***
:		 * *  *   * *   *     *   *       *
:		*   * *   *  ***  ****    *   ****

::#####################################################################
::
::	MODULE:	 XHOSTS
::
::	FUNCTION:  Interfaces to kernel and supervisor processes.
::
::	REGISTER CONVENTIONS:
::		CD  = R13	:pointer to reCord Descriptor
::		CHN = R5	:CHannel Number
::		KP  = R7	:Kernel Port buffer offset
::		LRC = R14	:Logical Record byte Count
::		PRC = R10	:Physical Record byte Count
::		PRD = R12	:Pointer to Record Data
::		TC  = R15	:for TrunCating ring pointers (power of 2 mask)
::		TYC = R11	:holds magic constant (03 or 07)
::
::	ROUTINES:
::		IZKNRG - Initialize rings used in SIO ring interface
::		IZSIRG - Initialize SIO ring
::		KERIPS - Moves data into kernel port buffers
::		KEROPS - Processes kernel data destined into network
::		KxROOM - Kernel utility routines
::		SIRxxx - SIORNG utility routines
::		SUPIN  - Moves characters to the sup input buffers
::		SUPOUT - Moves characters from the sup output buffer into net
::		SxROOM - Sup process utility routines
::
::	SWITCHES:
::		IKERNL - ISIS kernel (excludes RKERNL)
::		IKNRNG - ISIS kernel negative ring structure
::			 Code only runs in verion 6+ of ISIS.
::			 Switch is no longer used, but assumed true.    ###sdw
::		ISIS   - ISIS (implies IKERNL, KERNEL)
::		KERNEL - Any kind of kernel on node
::		KNRING - Kernel negative ring (non-ISIS)
::		RESHST - Restricted host (ISIS only)
::		RKERNL - Real kernel (excludes ISIS)
::		SIORNG - Split sup (SIO ring) configuration
::		SNRING - Sup negative ring
::		SUPER  - Supervisor node
::
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.
	IF	(1-T2GATE)	:Gateway does not use XHOSTS

::*********************************************************************
::
::	XHOSTS PARAMETERS:
::
::*********************************************************************

	IF	SIORNG
	REMARK	%SIO ring interface, device address
	NUMBER	SIORNG
	REMARK	x%
	EI	:SIORNG

:	>>SUPERVISOR TRACE AREA MOVED TO DATA MODULE<<	###wjl

::*********************************************************************
::
::	** COMMUNICATE WITH KERNEL, SUPERVISOR IN SEPARATE ENGINE **
::	**	USING SIO RING COPY MOTHER BOARD....		  **
::
::	DEFINE QUAD-WORD RING DESCRIPTORS. RING DESCRIPTOR IS OF THE FORMAT:
::	HC	ISIZE	:SIZE OF INPUT RING (TOWARDS NODE)
::	HC	OSIZE	:SIZE OF OUTPUT RING (FROM NODE)
::	WC	IRINGE	:REAL CORE ADDRESS OF INPUT RING
::	WC	ORINGE	:REAL CORE ADDRESS OF OUTPUT RING
::	WC	SIRDEN	:RING PAIR NUMBER
::	AND MUST RESIDE ON A QUAD-WORD BOUNDARY.
::
::*********************************************************************

	SEG	1

	IF	SIORNG

SIRDEN	EQ	0			:FIRST RING PAIR IS NUMBERED ZERO
	ORG	((.+0F)/10)*10		:ALIGN ON QUAD WORD BOUNDARY
SIRDES	HS	0
	SYAD(SIRDES)
	GL	SEG4,S4PH,SEG5,S5PH		:##AL
	QUADWD(KCNTLS,KCNTLS,KCNTLO,KCNTLI,4)
	QUADWD(KOFSIZ,NLOGSZ,KOF,NEWLOG,4)
KBNO	EQ	KBSZ+SIRGNF
	NOLIST
	RE	NKU
	QUADWD(KBSZ,KBSZ,KOB+KBNO,KIB+KBNO,4)
KBNO	EQ	KBNO+KBSZ+SIRGNF
	ER
	LIST
	QUADWD(SUPBSZ,SUPBSZ,NOSO+2,NOSI+2,5)
	QUADWD(SOBPSZ,SIBPSZ,NOSOBP+2,NOSIBP+2,5)
	QUADWD(SOCSZ,SICSZ,NOSOC+2,NOSIC+2,5)
SIRNRG	EQ	(.-SIRDES)/10
	SYAD(SIRNRG)			:NUMBER OF SIO RING DESCRIPTORS

	BND	10
SIRDRD	WS	0		:RING DESCRIPTOR FOR DOWN-LINE LOAD RING
	QUADWD(SIRDLS,SIRDLS,DWLKOB+4,DWLKIB+4,4)

KBNO	EQ	KBSZ+SIRGNF		:INIT TO SET UP TABLE FOR KIB & KOB
KBTBL	HS	0			:TABLE OF OFFSETS INTO KIB & KOB
	RE	NKU
	HC	KBNO
KBNO	EQ	KBNO+KBSZ+SIRGNF
	ER

	EI	:SIORNG

::*********************************************************************
::
::	NEGATIVE RING INDEXING REQUIRES ADDRESSING THE END OF THE RING
::	WITH A NEGATIVE INDEX REGISTER SPECIFIED. RE-DEFINE KIB, KOB TO
::	POINT TO END OF RING AREA.
::
::*********************************************************************

	IF	KNRING
KIB	EQ	KIB-SIRGNF		:END OF DATA AREA FOR RINGS
KOB	EQ	KOB-SIRGNF
	SYAD(KOB   )
	EI	:KNRING

	SUBTTL	XHOSTS (IZKNRG, IZSIRG - Initialization routines)

::*********************************************************************
::
::	SUBROUTINE:	IZKNRG:
::	FUNCTION:	Initializes rings used in SIO ring interface
::	CALLING SEQ:	JAL	R10,IZKNRG
::	DESTROYED:	R0, R1, R2, R3
::	CALLS:		JAL	R8,HCLEAR
::			JAL	R9,SIRCMD
::
::*********************************************************************

:	FIRST GIVE SIO CARD 'DIE' COMMAND (O.K. IF IT'S ALREADY DEAD).
:	INITIALIZE ALL RING POINTERS FOR EMPTY RINGS.

	IF	SIORNG

	GL	S4SIZE,SEG4		:##AL

IZKNRG	HS	0
	LHI	R0,SIRDIE		:COMMAND SIO RING CARD TO DIE
	JAL	R9,SIRCMD		:ISSUE SVC, HANDLE TIME-OUT
	SKIPAD(IZKN04)			:immed, NOP, TIME-OUT RETURN	###wjl
IZKN04	LA	R1,SEG4,,		:+4 return
	LHI	R2,S4SIZE/2
	JAL	R8,HCLEAR,,		:CLEAR RING AREAS

:	INITIALIZE POINTERS FOR ALL KIB, KOB RINGS...
	LHI	R2,(NKU-1)*2
	LHI	R1,-KBSZ		:INITIAL VALUE FOR RING POINTERS
IZKN10	LHL	R3,KBTBL,R2,		:GET RING PAIR OFFSET
	STH	R1,NII,R3,
	STH	R1,NOI,R3,		:INIT RING POINTERS FOR EMPTY RINGS
	STH	R1,NIO,R3,
	STH	R1,NOO,R3,
	SIS	R2,2
	JGE	IZKN10			:DO ALL RINGS

	LHI	R1,-KCNTLS
	STH	R1,KCNTLI-4,,		:INITIALIZE CONTROL INPUT RING
	STH	R1,KCNTLI-2,,

	STH	R1,KCNTLO-4,,		:INITIALIZE CONTROL OUTPUT RING
	STH	R1,KCNTLO-2,,

	LHI	R1,-NLOGSZ
	STH	R1,NEWLOG-4,,		:INITIALIZE NEWLOG RING
	STH	R1,NEWLOG-2,,

	LHI	R1,-KOFSIZ
	STH	R1,KOF-4,,		:INITIALIZE DATA READY ARRAY RING
	STH	R1,KOF-2,,

	LIS	R0,0
	ST	R0,KERNWL,,		:NO NEW LOGONS OR
	ST	R0,NLOGOK		: NEWLOG HANDSHAKES IN PROGRESS
	ST	R0,NLOGCT
	STH	R0,KERSTT		:KERNEL STATUS
	JR	R10			:RETURN

	EI	:SIORNG

::*********************************************************************
::
::	SUBROUTINE:	IZSIRG:
::	FUNCTION:	Initialize SIO ring. Kill SIO card, activate
::			ring pairs, and bring SIO card to life.
::	CALLING SEQ:	JAL	R10,IZSIRG
::	DESTROYED:	R0, R1, R2, R3, R6, R8, and R9
::	CALLS:		JAL	R9,SIRCMD
::
::*********************************************************************


	IF	SIORNG

IZSIRG	HS	0
	LHI	R0,SIRDIE		:COMMAND SIO RING CARD TO DIE
	JAL	R9,SIRCMD		:ISSUE SVC, HANDLE TIME-OUT
	SKIPAD(IZSR04)			:immed, NOP, TIME-OUT RETURN	###wjl
IZSR04	LIS	R0,0			:+4 return
	ST	R0,SIRI			:INITIALIZE SIRX RING POINTERS
	STH	R0,SIRFLG		:INDICATE SIO RING CARD DEAD

:	ACTIVATE RING PAIRS. CALL SIRCMD FOR EACH RING PAIR TO ACTIVATE.
: 	R0 HAS RING PAIR NUMBER IN BYTE 2, SIO RING CARD DEVICE ADDRESS IN
: 	BYTE 3. R1 HAS THE QUAD-WORD ADDRESS OF RING PAIRS' RING DESCRIPTORS.
	LHI	R6,SIRNRG		:NUMBER OF RING PAIRS TO INITIALIZE
	LA	R1,(SIRDES-SEG1+S1PH)/10 :QUAD-WORD ADDRESS OF RING DESCRIPTORS
	LHI	R0,SIORNG		:RING PAIR ZERO PLUS DEVICE ADDRESS
IZSR10	JAL	R9,SIRCMD		:ISSUE SVC, HANDLE TIME-OUT
	SKIPAD(IZSR20)			:immediate return		###wjl
IZSR14	AHI	R0,100			:+4 return, INCREMENT RING PAIR NUMBER
	AIS	R1,1			:NEXT QUAD-WORD
	SIS	R6,1
	JGBS	IZSR10			:DO FOR ALL RING PAIRS

	LHI	R0,SIRALV		:BRING SIO RING CARD TO LIFE
	JAL	R9,SIRCMD		:ISSUE SVC, HANDLE TIME-OUT
	SKIPAD(IZSR30)			:immediate return		###wjl
	JR	R10			:+4 return, RETURN

IZSR20	STH	R0,SIRFLG		:INDICATE TIMED-OUT		###wjl
	J	IZSR14			:continue			###wjl
IZSR30	STH	R0,SIRFLG		:INDICATE TIMED-OUT		###wjl
	JR	R10			:return				###wjl

	EI	:SIORNG

::*********************************************************************
::
::	KPRMAP:	 FW POINTERS TO PORTS' RING AREAS
::
::*********************************************************************

KPRMAP	WS	0			:FW POINTERS TO PORTS' RING AREAS
Q	EQ	0
	RE	NKU			:ONE FOR EACH PORT
	WC	KRINGS+((KBSZ+4)*2*Q)
Q	EQ	Q+1
	ER	:NKU

	SUBTTL	XHOSTS (KERIPS - Move network data into kernel)

::*********************************************************************
::
::	SUBROUTINE:	KERIPS:
::	FUNCTION:	Moves data into kernel port buffers.
::	CALLING SEQ:	JAL	R10,KERIPS
::	CALLS:		JAL	R9,SIRCIN
::			JAL	R10,IZKNRG
::			JAL	R10,IZSUP
::			JAL	R10,IZSIRG
::			JAL	R9,JBIDDY
::			JAL	R9,KLROOM
::
::*********************************************************************


KERIPS	HS	0

:	******;	IF	SIORNG		:AND IF KERNEL
	LH	R0,SIRDLD		:SIO RING LOAD IN PROGRESS?
	JLR	R10			:YES - WAIT FOR LOAD TO COMPLETE
:	******;	EI	:SIORNG

	ST	R10,XHSVRT		:SAVE RETURN ADDRESS


:	******;	IF	SIORNG		:AND IF KERNEL
	JAL	R9,SIRCIN		:GO CHECK FOR INTERRUPTS FROM SIO CARD
:	XRAY COMMAND MAY HAVE SPECIFIED FORCED INITIALIZATION OF SIO
: 	RING INTERFACE. IF SIRXIZ=0, NO FORCED INIT. IF SIRXIZ=1, INITIALIZE
: 	SIO RING, BUT DON'T MODIFY INTERFACE RING POINTERS. IF SIRXIZ=2,
: 	INITIALIZE INTERFACE RING POINTERS AND SIO RING.
	LH	R0,SIRXIZ		:FORCED INITIALIZATION?
	JEFS	KRSI20			:NO
	SIS	R0,1			:INITIALIZE INTERFACE RING POINTERS?
	JEFS	KRSI10			:NO - JUST SIO RING CARD
	JAL	R10,IZKNRG		:INITIALIZE INTERFACE RING POINTERS
	JAL	R10,IZSUP		:INITIALIZE SUP RINGS
KRSI10	JAL	R10,IZSIRG		:INITIALIZE SIO RING CARD
	LIS	R0,0
	STH	R0,SIRXIZ		:RESET INITIALIZATION FLAG
:	******;	EI	:SIORNG

KRSI20	HS	0
:	standard setup and JAL to BIDDY - CALL KERIN, kernel port in R2	###wjl
        LHI     R4,NKU/20*4             :number of bytes (mult of 4) for NKU
KRSI21  L       R0,KERFLG,R4            :copy words over for biddy
        ST      R0,KERSVD,R4
        SIS     R4,4
        JGEBS   KRSI21                  :handle whatever number of ports

	GBIDDY((NKU+7)/8,KERSVD,KERIN)	:R4<=count, R3<=addr, R9=JAL	###sdw

:	if none then skip to XHRET
XHRET	L	R10,XHSVRT		:RETURN TO SPIDER
	JR	R10

::*********************************************************************
::
::	SUB-PROCESS:	KERIN
::	FUNCTION:	MOVES DATA INTO ISIS OR SUP KERNEL FROM NETWORK
::	CALLING SEQ:	LA	R3,KERSVD	Dispatched based on
::			JAL	R9,JBIDDY	buffered data requesting
::			J	KERIN		output to the kernel.
::	CALLS:		JAL	R9,KIROOM
::			JAL	R8,PCIS
::			JAL	R8,PCI
::			JAL	R8,GCI
::			JAL	R8,CBCCT
::			JAL	R8,NEDTIM
::			JAL	R9,ZAPX
::			JAL	R9,CRQHCR
::			JAL	R8,WCI
::			JAL	R9,KCROOM
::			JAL	R8,WCD
::			JAL	R10,SUP12
::			JAL	R9,ZAPV
::
::*********************************************************************

KERIN	HS	0			:R2 CONTAINS PORT NUMBER WITH DATA
					: RELATIVE TO FW OF KERFLG
	IF	DB.CPU
	LR	R4,R2			:SAVE R2
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR KERIN		###OAS
	CPUTNM(KERIN )			:DEFINE CPUTIL ENTRY FOR KERIN	###OAS
	LR	R2,R4			:RECOVER R2
	EI	:DB.CPU

	LIS	TYC,3			:TO TEST FOR CONTROL CHAR
	LR	CHN,R2			:REL KERNEL PORT# SUPPLIED BY BIDDY

KERI12	HS	0
	LR	KP,CHN			:SAVE CHANNEL NUMBER

	LHL	R2,KIOTAB,CHN,CHN	:PERMUTER TABLE ENTRY, ISIS KERNEL

	NHI	R2,-4			:MASK OUT GOUGING BITS
	JNFS	KERI20
	CRASH.(.KERI0)
KERI20	XHI	R2,4			:FLIP TO INBOUND BUFFER INDEX
	JAL	R9,KIROOM		:COMPUTE SPACE AVAILABLE IN RING FOR
					: THIS PORT
	SIS	LRC,2			:ALLOW FOR CHARACTER PAIRS
	JG	KERI22			:ROOM AVAILABLE, SET UP TRANSFER
:	NO ROOM IN PORT'S RING, CHECK FOR ZAPPER OR GOBBLER
	JAL	R8,PCIS			:PEEK AT NEXT CHARACTER
	SIS	R1,3			:ZAPPER OR GOBBLER?
	JN	BIDDRT,,		:NO - WE'LL WAIT FOR ROOM IN RING
	JAL	R8,PCI			:PEEK AT SECOND CHAR OF 03-PAIR
	CLHI	R1,GOBBL&0FF		:GOBBLER?
	JE	BIDDRT,,		:YES, WAIT FOR ROOM IN RING
	J	KEIZAP			:NO, IT'S A ZAPPER, SO GO ZAP
KERI22	JAL	R8,CBCCT		:COMPUTE MINIMUM (BUFF CNT, RING SPACE)
	CR	R1,LRC
	JGEFS	KERI24
	LR	LRC,R1
KERI24	LR	CD,LRC			:NUMBER OF CHARACTERS TO MOVE

KERI30	JAL	R8,GCI			:GET CHAR
KERI40	STB	R1,KIB,KP,PRD		:PUT AWAY
	AIS	PRD,1			:ADVANCE RING POINTER
	JLFS	KERI42			:NEGATIVE INDEX
	SHI	PRD,KBSZ		:WRAP RING...

KERI42	CR	R1,TYC			:TYMNET CONTROL CHARACTER?
	JLE	KEITYM
	SIS	CD,1
	JGBS	KERI30

KERI5	HS	0
	STH	PRD,NII,KP,		:STORE AWAY POINTER
	AHM	LRC,KERICC		:CNT OF CHARS INTO KERNEL
	IF	INTACC		:###EV
	LHI	R3,KERZFL
	AR	R3,CHN			:Make port index into real chn #
	SHI	R3,MNACHN		:Make accounting port index
	LR	R0,LRC			:Set up character count
	JAL	R8,AARDIC,,		: and accumulate input characters
	GL	AARDIC
	EI	:INTACC		###EV
	RBT	CHN,KERNWL,,		:SET NEWLOG IF NEEDED
	JE	BIDDRT,,

:	GOT NEW LOGON INTO KERNEL
	JAL	R8,NEDTIM,,		:COMPUTE NEEDLE TIME, RECORD CIRC TIME
	LHL	R0,HNPORT		:BUMP NUMBER OF ACTIVE PORTS
	AIS	R0,1
	CLH	R0,MXPORT		:NEW PEAK?
	JLEFS	XHSMAX			:NO
	STH	R0,MXPORT		:YES, STORE THE NEW PEAK
XHSMAX	STH	R0,HNPORT

:	INFORM KERNEL OF NEW LOGIN
:	SET UP PARAMETERS FOR KERNEL LOGON SVC. 3 FW'S AT KPARMS, AS:
:	FW1 = ADDRESS OF PORT'S RING AREA
:	FW2 = PORT'S BIT INDEX (RELATIVE TO 0) INTO KOF ARRAY
:	FW3 = PORT'S BIT INDEX (RELATIVE TO 0) INTO KOFF ARRAY
	LA	R0,KOF,,		:GET ADDRESS OF DATA AVAILABLE ARRAY
	SLLS	R0,3			:8-BIT INDEX
	AR	R0,CHN			:PLUS KERNEL PORT NUMBER
	ST	R0,KPARMS+4,,		:SECOND PARAMTER FW
	LA	R0,KOFF,,		:GET ADDRESS OF RELIEVE B/P ARRAY
	SLLS	R0,3			:8-BIT INDEX
	AR	R0,CHN			:PLUS KERNEL PORT NUMBER
	ST	R0,KPARMS+8,,		:THIRD PARAMETER FW
	ST	KP,KPARMS,,		:RING AREA POINTER - FIRST PARAMETER FW
	LA	R0,KPARMS,,
	SVC	SYS,$A36		:DECLARE PORT TO KERNEL
	NOPR	0,0			:PADDING
	JFS	KLFAIL			:KERNEL REFUSED LOGON
					: DETACH PORT, SEND MSG
	J	BIDDRT,,		:DONE WITH THIS GUY
KLFAIL	HS	0
	L	R4,DETACP,,		:FIND A DETACH PROCESS PORT
	JFFO	R4,KLFAI1
	XHI	R2,4			:IF NOT AVAILABLE, JUST ZAP
	JAL	R9,ZAPX,,
	GL	ZAPX
	J	BIDDRT,,		:AND ALL DONE
KLFAI1	LIS	R4,3			:DETACH MESSAGE-OUT OF KERNEL PORTS
	STB	R4,DETMTY,CHN		:TELL DETACH PROCESS WHICH MESSAGE
	LHI	R1,0D0A			:FAKE ZAPPER - CRLF
	XHI	R2,4			:FLIP TO OUT BUFFER
	JAL	R9,ZAPX,,		:ZAP HALF CIRCUIT
	AHI	CHN,DETZFL		:DETACH PROCESS ABS CHANNEL #
	JAL	R9,CRQHCR,,		:CONNECT CRQ STUB TO DETACH PROCESS
	XHI	R2,4			:POINT TOWARD DETACH PROCESS
	LIS	R1,3			:WRITE NEEDLE POINT INTO BUFFER
	JAL	R8,WCI			:TO INFORM DETACH PROCESS
	LHI	R1,NEEDP
	JAL	R8,WCI
	J	BIDDRT,,		:ALL DONE WITH THIS PORT

KEITYM	JE	KEIT03			:03-TYPE PAIR?
	JAL	R8,GCI			:01,02 CHAR PAIR
KEITY1	OHI	R1,100			:PREVENT ESCAPING OF SECOND CHAR
	SIS	CD,1
	JN	KERI40			:second char exceeds KIROOM to move
	AIS	LRC,1			:bump up moved count
	J	KERI40

KEIT03	JAL	R8,GCI			:TEST FOR GOBBLER
	CLHI	R1,GOBBL&0FF
	JNFS	KEIZAP			:if not gobble then must be a zapper
	SIS 	PRD,1
	OHI	PRD,-KBSZ		:BACK UP POINTER
	LIS	R1,2			:T-I GOBBLER
	LIS	LRC,1			:MESSAGE IS SHORTER
	J	KEITY1
KEIZAP	HS	0
	LR	R0,KP			:PORT'S RING AREA POINTER IN R0 FOR SVC
	SVC	SYS,$A37		:ZAP KERNEL PORT
	NOPR	0			:PADDING
	JFS	KZFAIL			:KERNEL WOULDN'T ZAP PORT
	J	KPZAP			:GO ZAP IT
KZFAIL	HS	0			:SEND SUP AND CRYPTO MSGS
	JAL	R9,ZAPV,,		:ZAP IT
	LHI	R0,NR.KZF		:KERNEL ZAP FAILED NODE REPORT TO SUP
	STH	R0,SUPMBF
	LR	R0,CHN
	OHI	R0,8000			:MASK OUT HW2 AND SET HO BIT OF HW3
	ST	R0,SUPMBF+2		:KERNEL PORT #
	JAL	R10,SUP12,,
	J	KPZAP1

	SHI	LRC,-1,CD		:ZAPPER, END MESSAGE

KPZAP	JAL	R9,ZAPV,,
	IF	INTACC		:###EV
	LHI	R3,KERZFL
	AR	R3,CHN			:Make port index into real chan #
	SHI	R3,MNACHN		:Make accounting port index
	LI	R0,AALR03		:Normal disconnect from Network
	JAL	R8,AARLO,,		:Perform final accounting
	GL	AARLO
	EI	:INTACC		###EV
KPZAP1	HS	0
	RBT	CHN,NEWLOG,,		:IF WE'RE ZAPPING A NEW LOGIN,
	JN	BIDDRT,,		:DON'T BOTHER WITH THE REST
	LCS	R0,1			:ONE LESS LOGON
	AHM	R0,HNPORT
	J	BIDDRT,,		:ALL DONE

	SUBTTL	XHOSTS (KEROPS - Move KERNEL data out into network)

::*********************************************************************
::
::	SUBROUTINE:	KEROPS:
::	FUNCTION:	Process KERNEL data destined into network.
::	CALLING SEQ:	JAL	R10,KEROPS
::	CALLS:		JAL	R9,KFROOM
::			JAL	R9,KXROOM
::			JAL	R9,JBIDDY
::			J	KEROUT
::			JAL	R9,KXREC
::			JAL	R9,GOBBLN
::			JAL	R9,KCROOM
::			JAL	R9,ZAPHRD
::			JAL	R9,ZAPV
::
::*********************************************************************

KEROPS	HS	0
:	******;	IF	SIORNG
	LH	R0,SIRDLD		:SIO RING LOAD IN PROGRESS?
	JLR	R10			:YES - WAIT FOR LOAD TO COMPLETE
:	******;	EI	:SIORNG

	ST	R10,XHSVRT		:SAVE RETURN ADDRESS

:	******;	IF	SIORNG
	JAL	R9,SIRCIN		:GO CHECK FOR INTERRUPTS FROM SIO CARD
:	******;	EI	:SIORNG

	LHI	R4,NKU/20*4		:handle multiword bit arrays
KERO12	L	R0,KOF,R4,		:PORTS W/ CHARS FOR BUFFERS
	N	R0,KERBPX,R4		:MASK OUT BP'ED PORTS
	O	R0,KOFF,R4,		:UNLESS BP OVERRIDE
	ST	R0,KERSVD,R4
        SIS     R4,4                    :do all words for biddy
        JGEBS   KERO12

:	standard set up and JAL to BIDDY - CALL KEROUT			###wjl
	GBIDDY((NKU+7)/8,KERSVD,KEROUT)	:R4<=count, R3<=addr, R9=JAL	###wjl

	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR KRORET	###OAS
	CPUTNM(KRORET)			:DEFINE CPUTIL ENTRY FOR KRORET	###OAS
	EI	:DB.CPU

KEROXT	J	XHRET

::*********************************************************************
::
::	SUB-PROCESS:	KEROUT
::	FUNCTION:	HANDLE KOB OUTPUT DATA
::	CALLING SEQ:	LA	R3,KERSVD	Dispatched based on data
::			JAL	R9,JBIDDY	being received on kernel
::			J	KEROUT		ports.
::	INPUT:		R2 = CHANNEL NUMBER
::	CALLS:		JAL	R8,WCI
::			JAL	R9,GOBBLE
::
::*********************************************************************


KEROUT	HS	0
	IF	DB.CPU
	LR	R4,R2			:SAVE R2
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR KEROUT	###OAS
	CPUTNM(KEROUT)			:DEFINE CPUTIL ENTRY FOR KEROUT	###OAS
	LR	R2,R4			:RECOVER R2
	EI	:DB.CPU
	LIS	TYC,3

	RBT	R2,KOF,,		:THIS PORT SERVICED
	RBT	R2,KOFF,,
	LR	CHN,R2			:2*PORT #
	LR	KP,CHN
	JAL	R9,KOROOM		:COMPUTE # OF CHARACTERS IN RING BUFFER
	LR	LRC,LRC
	JE	BIDDRT,,		:NO DATA - RETURN

	LHL	R2,KIOTAB,CHN,CHN
	NHI	R2,-4
	JNFS	KERO3
	LHL	R0,NIO,KP,
	STH	R0,NOO,KP,

	J	BIDDRT,,
KERO3	LR	CD,LRC			:# CHARS TO MOVE


KERO2	LB	R1,KOB,KP,PRD		:GET CHAR
KERO4	AIS	PRD,1
	JLFS	KERO42
	SHI	PRD,KBSZ		:NEGATIVE RING WRAP

KERO42	JAL	R8,WCI			:PUT CHARACTER FROM KERNEL INTO BUFFER
	CR	R1,TYC
	JGFS	KERO6			:TYMNET CONTROL TEST
	J	KEOTYM
KERO6	SIS	CD,1
	JGBS	KERO2

KERO5	HS	0
	STH	PRD,NOO,KP,
	AHM	LRC,KEROCC		:CNT OF CHARS OUT OF KERNEL
	IF	INTACC		:###EV
	LHI	R3,KERZFL
	AR	R3,CHN			:make port index into real chn #
	SHI	R3,MNACHN		:Make accounting port index
	LR	R0,LRC			:Set up count
	JAL	R8,AARDOC,,		: and accumulate output characters
	GL	AARDOC
	EI	:INTACC		###EV
	LHL	R3,BCT,R2,		:SET BACKPRESSURE IF BUFFER FULL
	LIS	R1,3
	NH	R1,KIOTAB,CHN,CHN
	CLH	R3,CIRSPK,R1,R1
	JL	BIDDRT,,
	RBT	CHN,KERBPX
	J	BIDDRT,,

KEOTYM	JE	KEOZAP			:03 IS ZAPPER
	CLHI	R1,2
	JE	KEOGO1			:02 IS GOBBLER
	LB	R1,KOB,KP,PRD		:00,01,02 CHAR PAIR
KEOTY1	SIS	CD,1			:JUST PASS IT ON
	OHI	R1,100
	J	KERO4

KEOT03	LB	R1,KOB,KP,PRD		:03-TYPE PAIR
	AIS	PRD,1
	JLFS	KEOT3A
	AHI	PRD,-KBSZ

KEOT3A	CLHI	R1,GOBBL&0FF
	JE	KEOGOB
KEOZAP	JAL	R9,ZAPHRD,,		:ZAPPER
	IF	INTACC		:###EV
	LHI	R3,KERZFL
	AR	R3,CHN			:Make port index into real chan #
	SHI	R3,MNACHN		:Make accounting port index
	LI	R0,AALR02		:Normal disconnect from Kernel
	JAL	R8,AARLO,,		:Perform final accounting
	GL	AARLO
	EI	:INTACC		###EV
	SHI	LRC,-2,CD		:TERMINATE THE MESSAGE HERE
	LCS	R0,1			:ONE LESS LOGON
	AHM	R0,HNPORT
	LHL	R0,NII,KP,
	STH	R0,NOI,KP,
	J	KERO5

KEOGOB	SIS	CD,1			:GOBBLER
KEOGO1	JAL	R9,GOBBLE,,		:GOBBLER  -- ***NOTE!! GOBBLE IS CALLED
	GL	GOBBLE			: INSTEAD OF GOBBLN HERE BECAUSE IT
					: SEEMS UNLIKELY THAT NEEDLES OR SQFIXS
					: WILL BE GOBBLED BY THE KERNEL HOST.
	J	KERO6

	SUBTTL	XHOSTS (Kernel utility routines)

:	THE FOLLOWING SUBROUTINES ARE FOR HANDLING THE NEGATIVE INDEXED
: 	FORMAT FOR THE KERNEL INTERFACE RINGS. THERE ARE 6 RINGS:
:
:	KIB - DATA RING, NODE-->KERNEL
:		NII LEAD POINTER, NODE INDEXED
:		NOI TRAIL POINTER, KERNEL INDEXED
:
:	KOB - DATA RING, KERNEL-->NODE
:		NIO LEAD POINTER, KERNEL INDEXED
:		NOO TRAIL POINTER, NODE INDEXED
:
:	NEWLOG - PASS PORT NUMBERS OF NEW LOGINS, NODE-->KERNEL
:		NEWLOG-4 LEAD POINTER, NODE INDEXED
:		NEWLOG-2 TRAIL POINTER, KERNEL INDEXED
:
:	KOF - BIT ARRAY INDICATING DATA AVAILABLE, KERNEL-->NODE
:		KOF-4 LEAD POINTER, KERNEL INDEXED
:		KOF-2 TRAIL POINTER, NODE INDEXED
:
:	KCNTLI - CONTROL RING FOR GOBBLERS AND ZAPPERS, NODE-->KERNEL
:		KCNTLI-4 LEAD POINTER, NODE INDEXED
:		KCNTLI-2 TRAIL POINTER, KERNEL INDEXED
:
:	KCNTLO - CONTROL RING FOR GOBBLERS AND ZAPPERS, KERNEL-->NODE
:		KCNTLO-4 LEAD POINTER, KERNEL INDEXED
:		KCNTLO-2 TRAIL POINTER, NODE INDEXED
:

:	THE 'ROOM' SUBROUTINES DETERMINE THE SPACE AVAIABLE FOR INPUT
: 	RINGS (NODE-->KERNEL), OR COMPUTE THE AMOUNT OF DATA WAITING FOR
: 	OUTPUT RINGS (KERNEL-->NODE). ALL SUBS LINK ON R9, RETURN PRD AS THE
: 	NODE'S RING INDEX, AND LRC AS THE LENGTH. THE DATA RING ROUTINES LOAD
: 	R7 WITH THE RELATIVE DISPLACEMENT OF THE RING FOR THE CHAN OF INTEREST.

::*********************************************************************
::
::	SUBROUTINE:	KIROOM:
::	FUNCTION:	COMPUTE SPACE AVAILABLE IN INPUT RING.
::	CALLING SEQ:	JAL	R9,KIROOM
::	INPUT:		KP  = R7 = CHANNEL NUMBER
::			CHN = R5 = CHANNEL NUMBER TIMES 2 FOR SOLO.
::
::*********************************************************************

KIROOM	HS	0
	SLLS	KP,2			:FW INDEX
	L	KP,KPRMAP,KP		:PORT RING DISPLACEMENT

	LH	PRD,NII,KP,		:NODE INDEX
	LH	LRC,NOI,KP,		:KERNEL INDEX
	SHI	LRC,2,PRD		:COMPUTE SPACE LEFT IN RING
	JGER	R9
	AHI	LRC,KBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN


::*********************************************************************
::
::	SUBROUTINE:	KOROOM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA IN RING BOUND FOR NETWORK.
::	CALLING SEQ:	JAL	R9,KOROOM
::	INPUT:		R2  = CHANNEL NUMBER
::			CHN = R5 = CHANNEL NUMBER TIMES 2 FOR SOLO
::
::*********************************************************************

KOROOM  HS      0
	SLLS	KP,2
	L	KP,KPRMAP,KP,
	LH	PRD,NOO,KP,		:NODE INDEX
	LH	LRC,NIO,KP,		:KERNEL INDEX
	SR	LRC,PRD			:COMPUTE AMOUNT OF DATA IN RING
	JGER	R9
	AHI	LRC,KBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

:	******;	IF	KNRING
:*FOLLOWING ROUTINES APPLY ONLY TO NEGATIVE INDEX KERNEL INTERFACE RING FORMAT*

::*********************************************************************
::
::	SUBROUTINE:	KCROOM:
::	FUNCTION:	COMPUTE SPACE AVAILABLE IN KCNTLI RING.
::	CALLING SEQ:	JAL	R9,KCROOM
::
::*********************************************************************

KCROOM	HS	0
	LH	PRD,KCNTLI-4,,		:NODE INDEX
	NEGTST(NOP,,KCNTLI,0)
	LH	LRC,KCNTLI-2,,		:KERNEL INDEX
	NEGTST(NOP,,KCNTLI,0)
	SHI	LRC,2,PRD		:COMPUTE SPACE AVAILABLE
	JGER	R9
	AHI	LRC,KCNTLS		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	KLROOM:
::	FUNCTION:	COMPUTE SPACE AVAILABLE IN NEWLOG RING
::	CALLING SEQ:	JAL	R9,KLROOM
::
::*********************************************************************

KLROOM	HS	0
	LH	PRD,NEWLOG-4,,		:NODE INDEX
	NEGTST(NOP,,NEWLOG,0)
	LH	LRC,NEWLOG-2,,		:KERNEL INDEX
	NEGTST(NOP,,NEWLOG,0)
	SHI	LRC,2,PRD		:COMPUTE SPACE AVAILABLE
	JGER	R9
	AHI	LRC,NLOGSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	KFROOM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA IN KOF RING.
::	CALLING SEQ:	JAL	R9,KFROOM
::
::*********************************************************************

KFROOM	HS	0
	LH	PRD,KOF-2,,		:NODE INDEX
	NEGTST(NOP,,KOF,0)
	LH	LRC,KOF-4,,		:KERNEL INDEX
	NEGTST(NOP,,KOF,0)
	SR	LRC,PRD			:COMPUTE AMOUNT OF DATA WAITING
	JGER	R9
	AHI	LRC,KOFSIZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	KXROOM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA IN KCNTLO RING
::	CALLING SEQ:	JAL	R9,KXROOM
::
::*********************************************************************

KXROOM	HS	0
	LH	PRD,KCNTLO-2,,		:NODE INDEX
	NEGTST(NOP,,KCNTLO,0)
	LH	LRC,KCNTLO-4,,		:KERNEL INDEX
	NEGTST(NOP,,KCNTLO,0)
	SR	LRC,PRD			:COMPUTE AMOUNT OF DATA WAITING
	JGER	R9
	AHI	LRC,KCNTLS		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	KXREC:
::	FUNCTION:	GET NEXT RECORD FROM KERNEL CONTROL RING
::	CALLING SEQ:	JAL	R9,KXREC
::
::*********************************************************************

KXREC	HS	0
	SIS	LRC,2			:DECREMENT NUMBER OF BYTES IN RING
	LHL	R1,KCNTLO-4,PRD,	:GET NEXT HALFWORD FROM RING
	AIS	PRD,2			:INCREMENT RING POINTER
	JLFS	KXRC10
	LHI	PRD,-KCNTLS		:NEGATIVE RING WRAP
KXRC10	STH	PRD,KCNTLO-2,,		:UPDATE TRAIL POINTER
	JR	R9			:RETURN

	SUBTTL	XHOSTS (SIRCMD, SIRCIN, SIRSCK - SIORNG utility routines)

:			******SIORING******
	IF	SIORNG

::*********************************************************************
::
::	SUBROUTINE:	SIRCMD:
::	FUNCTION:	SEND COMMAND TO SIO CARD
::	CALLING SEQ:	JAL	R9,SIRCMD
::	INPUT:		R0 = COMMAND
::			R1 = QUADWORD ADDRESS (FOR ACTIVATE RING PAIR COMMANDS)
::	DESTROYED:	R2, R3, AND R8
::	CALLS:		ISSUE SVC TO SIO CARD - NORMAL RETURN IF
::			COMMAND PROCESSED, ELSE SKIP RETURN DUE TO SIO
::			CARD BUSY. IF WE GET CONSECUTIVE SKIP-RETURNS
::			FOR 100 FASTC TICKS, SEND CRYPTOGRAM.
::	RETURNS:	NORMAL RETURN IF SIO CARD TIMES OUT
::			SKIP RETURN FOR SVC O.K.
::
::*********************************************************************

SIRCMD	HS	0
	L	R2,FASTC,,		:GET TIME ENTERED
SIRC10	SVC	0F,SV.SIR		:ISSUE SVC TO SIO RING CARD
	J	4,R9			:O.K. - SKIP RETURN
	L	R3,FASTC,,
	SR	R3,R2			:TIME SINCE FIRST SVC ISSUED
	CLHI	R3,100			:SIO BUSY FOR 100 FASTC TICKS?
	JLBS	SIRC10			:NO - TRY AGAIN
	JAL	R8,CRYPTO,,		:SEND CRYPTOGRAM FOR SIO BOARD BUSY,
	HC	CRYE3A			: R0 HAS COMMAND...
	SKIP(0,R9)			:NORMAL RETURN			###wjl

::*********************************************************************
::
::	SUBROUTINE:	SIRCIN:
::	FUNCTION:	CHECK FOR ANY INTERRUPTS FROM SIO RING CARD
::	CALLING SEQ:	JAL	R9,SIRCIN
::	DESTROYED:	R0, R1, R3, R4, AND R8.
::	CALLS:		JAL	R8,CRYPTO
::
::*********************************************************************

:	INTERRUPT STATUS HALFWORDS ARE STORED IN SIRX, SO MULTIPLE
:	INTERRUPTS BETWEEN CHECKS CAN BE DETECTED. SEND CRYPTOGRAM FOR
:	EACH INTERRUPT, AND TEST FOR SPECIAL UP/DOWN CONDITIONS TO SET SIRFLG.

SIRCIN	HS	0
	LH	R3,SIRI			:INTERRUPT INDEXED IN POINTER
	LH	R4,SIRO			:OUT POINTER
	SR	R3,R4
	NHI	R3,SIRXSZ-1		:AMOUNT OF DATA IN RING
	JER	R9			:RING EMPTY
SIRCI2	LHL	R0,SIRX,R4		:GET INTERRUPT STATUS AND
	JAL	R8,CRYPTO,,		: SEND CRYPTOGRAM
	HC	CRYE3B			:(SIO RING CARD INTERRUPT)
:	IF STATUS IS 'UP' OR 'DOWN', SET SIRFLG APPROPRIATELY
	SRLS	R0,8			:ISOLATE STATUS
	LIS	R1,0
	CLHI	R0,SIRDWN		:SIO CARD DOWN?
	JEFS	SIRCI4			:YES
	LHI	R1,STSRM0
	CLHI	R0,SIRRM0		:RING PAIR MISMATCH FOR RING 0?
	JEFS	SIRCI4			:YES
	CLHI	R0,SIRUP		:SIO CARD UP?
	JNFS	SIRCI6			:NO - SOME OTHER INFORMATION
	LCS	R1,1
SIRCI4	STH	R1,SIRFLG		:INDICATE UP/DOWN - 0 = DOWN, -1 = UP
SIRCI6	AIS	R4,2
	NHI	R4,SIRXSZ-1		:ADVANCE BACKGROUND RING POINTER
	SIS	R3,2			:MORE DATA IN RING?
	JG	SIRCI2			:YES
	STH	R4,SIRO			:NO - STORE OUT POINTER AND
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SIRSCK:
::	FUNCTION:	STATUS CHECK OF SIO INTERFACE
::	CALLING SEQ:	JAL	R10,SIRSCK
::	CALLS:		JAL	R8,CRYPTO
::			JAL	R10,SUP11
::			JAL	R10,SCQZAP
::			JAL	R10,KCQDET
::			JAL	R10,IZKNRG
::			JAL	R10,IZSUP
::			JAL	R10,IZSIRG
::
::*********************************************************************

::	IF SIO RING INTERFACE NOT ALIVE, REPORT KERNEL HOST SHUT.
::	COMPARE TO LAST STATUS REPORTED TO PREVENT REDUNDANT HOST
::	STATUS REPORTS TO SUPERVISOR.

SIRSCK	HS	0
	LHL	R2,TVRBUF		:IS THERE A COMMAND CIRCUIT?
	JER	R10			:NO - RETURN
	LH	R1,SIRFLG		:GET SIO RING STATUS
	JNFS	SIRH10			:SIO RING UP OR AWAITING LOAD
	LIS	R0,2			:SIO RING DEAD, HOST SHUT STATUS IN R0
	JFS	SIRH20
SIRH10	LIS	R0,0			:HOST ANSWERED STATUS
SIRH20	CLB	R0,HSTAT		:SAME STATUS AS BEFORE?
	JER	R10			:YES - MAKE NO REPORT
	ST	R10,SIRCSV		:SAVE LINK
	STB	R0,HSTAT		:SAVE NEW STATUS

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)			###GT
	LR	R2,R0			:PRESERVE R0			###GT
	SLLS	R2,6			:SHIFT BITS 6,7 TO BITS 0,1	###GT
	LB	R1,HSTATN		:AND OR INTO HSTATN		###GT
	NHI	R1,003F			:STRIP OFF BITS 0 AND 1		###GT
	OR	R1,R2			:NOW ADD STATUS BITS		###GT
	STB	R1,HSTATN		:				###GT

	LHI	R8,HST0
	STH	R8,CRYSBF+2		:STORE HOST NUMBER FOR XRAY
	JAL	R8,CRYPTO,,		:HOST STATUS CRYPTOGRAM
	HC	CRYE15
	LIS	HN,0			:HOST ZERO IS KERNEL HOST
	JAL	R10,SUP11,,		:SEND HOST STATUS REPORT TO SUP
	LB	R0,HSTAT		:HOST STATUS CHANGED - ARE WE ANSWERED?
	JEFS	SIRH30			:YES
:	SIO RING JUST WENT DOWN. ZAP CIRCUITS TO SUP, KERNEL INTERFACE AND
: 	RE-INITIALIZE EVERYTHING.
	JAL	R10,SCQZAP		:ZAP SUP CIRCUITS
	JAL	R10,KCQDET		:DETACH KERNEL CIRCUITS
	JAL	R10,IZKNRG		:INITIALIZE KERNEL RINGS
	JAL	R10,IZSUP		:INITIALIZE SUP RINGS
	JAL	R10,IZSIRG		:ATTEMPT TO REVIVE SIO RING
SIRH30	L	R10,SIRCSV		:RESTORE LINK AND
	JR	R10			: RETURN

:		******END***
	EI	:SIORNG

:	******END***
	EI	:KNRING


	SUBTTL	XHOSTS (SUPIN - Moves network data into supervisor)

:	1 - Data ring data format (SIB/SOB)
:
:	  A - Sup port data of the form
:
:	    2 bytes Channel Number, 2 bytes Data Byte Count, N bytes Data
:
:	  B - Special case channel number zero
:
:	    Input to Supervisor
:	    2 bytes 0, 2 bytes 0002, 2 bytes Channel Number to be Zapped
:	    2 bytes 0, 2 bytes 0002, 2 bytes Sup # + 8000 - Sleeping Pill
:
:	    Output by Supervisor
:	    2 bytes 0, 2 bytes 0002, 2 bytes Chan # + 8000 to be Zapped
:	    2 bytes 0, 2 bytes 0002, 2 bytes w/o 8000 bit set - Going to Sleep
:
:	  C - Special case channel number one, to Sup only, indicating
:	    control character(s) other than zapper found going to Sup
:
:	    2 bytes 1,
:	    2 bytes of Byte Count,
:	    2 bytes Message Type + 0880 where Message Type
:	        0 = Black Ball
:	        1 = Gobbler
:	        2 = Other Invalid Pair or Unpaired Control Character,
:	    2 bytes Offending Channel Number,
:	    2 bytes Invalid Pair (if present)
:
:	2 - Control ring data format (SIC/SOC)
:
:	    Output by Supervisor
:	    2 bytes Status Code
:	    	FFFF - Sup Sleeping
:	    	0001 - Sup Awake
:
:	    Input to Supervisor
:	    2 bytes Sup Port Zero Offset to Node Code Absolute Channel 0,
:	    2 bytes Node Number + 8000
:
:	3 - Backpressure control ring data format (SIBP/SOBP)
:
:	    2 bytes Channel Number - Relieve Backpressure
:	    2 bytes Channel Number + 8000 - Apply Backpressure

::*********************************************************************
::
::	SUBROUTINE:	SUPIN:
::	FUNCTION:	Moves characters into the sup input data ring (SIB)
::	CALLING SEQ:	JAL	R10,SUPIN
::	CALLS:		JAL	R9,SIROOM
::			JAL	R8,CBCCT
::			JAL	R8,GCLAST
::			JAL	R8,GCRET
::			JAL	R0,EXYLD
::			JAL	R8,GCI
::			JAL	R8,CBCLR
::			JAL	R9,ZAPV
::
::*********************************************************************

	IF	SUPER

SUPIN	HS	0
	ST	R10,XHSVRT		:SAVE RETURN

	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR SUPIN
	CPUTNM(SUPIN )			:DEFINE CPUTIL ENTRY FOR SUPIN
	EI	:DB.CPU

SUPGRP	HS	0			:###wjl
	LIS	R7,0			:DISPLACEMENT OF SUP ATTN FLAGS
	LIS	R4,0			:BASE PORT # FOR THIS GROUP
SUINXT	L	R1,SUPFLG,R7,		:GET NEXT FLAG GROUP
	N	R1,SUPBPV,R7		:AND BACK PRESS FLAGS
	N	R1,SUPSVD,R7		:AND PORT SERVICED FLAGS
	JN	SUPI20
	AIS	R7,4			:NOTHING IN THIS GROUP
	AHI	R4,20
	CLHI	R4,NSP
	JL	SUINXT

	LIS	R2,0			:RESTORE SUPSVD AND GO ROUND AGAIN
	LIS	R7,0
	LCS	R0,1
SUPI10	ST	R0,SUPSVD,R7
	L	R1,SUPFLG,R7,
	N	R1,SUPBPV,R7
	OR	R2,R1
	AIS	R7,4
	CLHI	R7,NSP/8
	JL	SUPI10
	LR	R2,R2			:IF 0, NOTHING TO DO
	JN	SUPGRP
SUPINX	J	XHRET			:return

:	service this port
SUPI20	HS	0
	JAL	R9,SIROOM		:ANY ROOM IN SIB RING?
	CLHI	PRC,8			:NEED AT LEAST 8 BYTES
	JLE	SUPINX			:DISMISS FROM SUPIN
	JFFO	R1,SUPI22		:GET THE PORT #
SUPI22	LR	CHN,R2			:COMPUTE 2*PORT #
	AR	CHN,R4
	RBT	CHN,SUPSVD		:THIS PORT SERVICED
	LHL	R2,SIOTAB,CHN,CHN	:CORRESPONDING BUFFER #
	NHI	R2,-4			:STRIP SPEED BITS
	JNFS	SUPI30
	CRASH.(.SUPIC)
SUPI30	XHI	R2,4			:DATA IS IN COMP BUFFER
	JAL	R8,CBCCT		:# OF CHARS IN BUFFER
	LHI	LRC,-6,PRC		:# OF CHARS THAT MAY BE MOVED IN
	CR	R1,LRC			:COMPUTE LEAST OF ABOVE
	JGEFS	SUPI32
	LR	LRC,R1			:LRC HAS IT
SUPI32	LHI	R1,200			:MOVE ONLY THESE AT ONE TIME
	CR	R1,LRC
	JGEFS	SUPI34
	LR	LRC,R1
SUPI34	LR	CD,LRC			:# OF CHARS TO MOVE
	JNFS	SUPI36
	CRASH.(.SUPI0)
SUPI36	IF	SNRING
	LR	R11,PRD			:SAVE POINTER TO RECORD HEADER
	AIS	PRD,4			:INDEX PRD TO START OF DATA
	JLFS	SUPI38
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	AIS	PRD,4			:INDEX PRD TO START OF DATA
	NR	PRD,TC
	EI	:SNRING

:	why don't we use the GCI instruction???jhl
SUPI38	HS	0
	L	R3,BB,R2,		:SET UP BUFFER BEGIN ADDRESS
	JNFS	SUPI40
	CRASH.(.SUPI1)
SUPI40	LB	R1,0,R3			:MOVE CHARS
	CL	R3,BE,R2,
	JNFS	SUPI50
	JAL	R8,GCLAST
	LIS	R3,0
	JFS	SUPI60
SUPI50	AIS	R3,1
	THI	R3,CBSZ-1
	JNFS 	SUPI60
	JAL	R8,GCRET
	L	R3,BB,R2,
:	end of what would be GCI call.

SUPI60	CLHI	R1,3			:test for TYMNET control pairs
	JGFS	SUPI70			:greater than 3 is data
	J	SUITYM			:jump to control pair handler
SUPI70	STB	R1,SIB,PRD,		:here for data character handler
	AIS	PRD,1
	IF	SNRING
	JLFS	SUPI72
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC			:POWER OF 2 MASK
	EI	:SNRING
SUPI72	HS	0
	SIS	CD,1
	JG	SUPI40
	ST	R3,BB,R2,

SUPI80	IF	SNRING			:INSERT CHAN # AND ACTUAL BYTE COUNT
	LR	R1,R11			:RESTORE POINTER TO LOGICAL REC HEADER
	ELSE	:NOT SNRING
	LR	R1,PRD			:COMPUTE POINTER TO LOGICAL REC HEADER
	SHI	R1,4,LRC		:POINTS TO CHAN SLOT
	NR	R1,TC
	EI	:SNRING
	STH	CHN,SIB,R1,		:STORE CHANNEL NUMBER
	AIS	R1,2
	IF	SNRING
	JLFS	SUPI82
	SHI	R1,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	R1,TC
	EI	:SNRING
SUPI82	HS	0
	STH	LRC,SIB,R1,		:STORE LOGICAL RECORD COUNT
	AM	LRC,SUPICC		:COUNT OF CHARS INTO SUP

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	TBT	CHN,SRNTRE,,		:IS THIS CHANNEL ENABLED FOR TRACE ?
	JE	SRNA03			:NO

SRNA02	ST	R1,SRNSAV,,		:SAVE R1
	ST	R2,SRNSAV+4,,		:AND R2
	LR	R1,R11			:BEGINNING OF RECORD IN RING
	AIS	R1,6			:POINT TO MESSAGE TYPE BYTE
	JLFS	SRNA0B			:SUP NEG RING NOT WRAPPED
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNA0B	LB	R0,SIB,R1,		:GET MESSAGE TYPE
	TBT	R0,SRNICK,,		:CHECK IF THIS MESSAGE IS DESIRED
	JN	SRNA04			:MESSAGE NOT DESIRED
	LR	R1,R11			:POINT TO BEG OF RECORD DATA
	AIS	R1,4			:SKIP PAST CHAN AND COUNT
	JLFS	SRNA0C			:SUP NEG RING NOT WRAPPED
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNA0C	LHL	R2,SRNTRX,,		:NEXT ENTRY IN TRACE TABLE
SRNA05	LB	R0,SIB,R1,		:GET DATA FROM RING
	STB	R0,SRNTBL,R2,		:AND ENTER INTO TRACE TABLE
	AIS	R2,1			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNA06			:NO
	LIS	R2,0			:WRAP
SRNA06	AIS	R1,1			:BUMP RING INDEX
	JLFS	SRNA07			:NO NEGATIVE WRAP
	SHI	R1,SUPBSZ		:NEG RING WRAP
SRNA07	CR	R1,PRD			:END OF RECORD?
	JL	SRNA05			:NO
	THI	R2,0001			:ODD TRACE TABLE INDEX ?
	JEFS	SRNA08			:NO
	LIS	R0,0
	STB	R0,SRNTBL,R2,		:CLEAR PAD BYTE
	AIS	R2,1			:ENFORCE EVEN TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNA08			:NO
	LIS	R2,0			:WRAP
SRNA08	LR	R1,R11			:POINT TO BEGIN OF RECORD IN SUP RING
	AIS	R1,2			:POINT TO LRC
	JLFS	SRNA0D			:NO SUP NEG RING WRAP
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNA0D	LHL	R0,SIB,R1,		:GET LRC FROM RING
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNA09			:NO
	LIS	R2,0			:WRAP
SRNA09	LHL	R0,FASTC+2,,		:GET FASTC MARK
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNA0A			:NO
	LIS	R2,0			:WRAP
SRNA0A	LHL	R0,SIB,R11,		:GET CHAN # FROM RING
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNA10			:NO
	LIS	R2,0			:WRAP
SRNA10	STH	R2,SRNTRX,,		:UPDATE TRACE TABLE INDEX
SRNA04	L	R1,SRNSAV,,		:RECOVER R1
	L	R2,SRNSAV+4,,		:RECOVER R2

SRNA03	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	THI	LRC,1			:ADD ZERO PAD IF ODD LRC
	JEFS	SUPI90
	LIS	R1,0
	STB	R1,SIB,PRD,
	AIS	PRD,1
	IF	SNRING
	JLFS	SUPI84
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUPI84	HS	0
	AIS	LRC,1

SUPI90	AIS	LRC,4			:TOTAL # OF CHARS INSERTED
	IF	SNRING
	AH	LRC,NISI,,		:INCREMENT SIB LEAD POINTER
	JLFS	SUPI92
	SHI	LRC,SUPBSZ		:NEGATIVE RING WRAP
SUPI92	STH	LRC,NISI,,		:UPDATE POINTER, DONE WITH LOGICAL REC
	ELSE	:NOT SNRING
	AHM	LRC,NISI,,		:UPDATE THE LEAD POINTER FOR SIB
	EI	:SNRING

	JAL	R0,EXYLD,,		:ALL DONE, YIELD BETWEEN TRANSFERS
	J	SUPGRP

:	control pair handler
SUITYM	HS	0
	JE	SUICTL			:IF 03 DETECTED - TEST FOR ZAPPER
	LR	R1,R1			:NOT 03 - IS IT AN ESCAPE?
	JN	SUIINV			:NO - INVALID CHARACTER PAIR DETECTED

	LB	R1,0,R3			:ESCAPE, GET NEXT CHAR
	CL	R3,BE,R2,		:CHECK FOR LAST BUFFERLET
	JNFS	SUITY1			:NO--CONTINUE
	JAL	R8,GCLAST
	LIS	R3,0
	JFS	SUITY2
SUITY1	AIS	R3,R1
	THI	R3,CBSZ-1		:END OF BUFFERLET?
	JNFS	SUITY2			:NO--CONTINUE
	JAL	R8,GCRET		:YES--RETURN BUFFERLET
	L	R3,BB,R2,
SUITY2	SIS	CD,1
	JLE	SUPI70
	SIS	LRC,1			:escape affects message length
	J	SUPI70			:write char w/o escape into ring

:	DETECTED 03 CHARACTER ON COMMAND CIRCUIT. GET NEXT CHARACTER AND
:	TEST FOR A ZAPPER.
SUICTL	HS	0
	LR	R3,R3			:ANY MORE CHARACTERS IN BUFFER?
	JE	SUIINV			:NO, INVALID SINCE 03'S TRAVEL IN PAIRS
	ST	R3,BB,R2,
	JAL	R8,GCI			:GET NEXT BYTE
	LIS	R0,1			:SET R0 FOR GOBBLER DETECTED (SUICH1)
	CLHI	R1,GOBBL&0FF		:IS IT A GOBBLER?
	JL	SUIZAP			:NO, ITS A ZAPPER
	JE	SUICH1			:GOBBLER (R0 ALREADY SET UP)
	OHI	R1,300
	STH	R1,SUICHR		:INVALID 03 CHR PAIR - SAVE IT
	LIS	R0,2			:INDICATE INVALID CHARACTER PAIR AND
	J	SUICH1			: GO FORMAT CHANNEL 1 MESSAGE TO SUP

:	SOME KIND OF INVALID NETWORK CHARACTER DETECTED. DETERMINE WHAT
:	KIND, AND FORMAT CHANNEL 1 MESSAGE TO SUPERVISOR.
SUIINV	HS	0
	EXBR	R1,R1
	STH	R1,SUICHR		:SAVE FIRST CHARACTER OF PAIR
	LR	R3,R3			:ANY MORE CHARACTERS IN BUFFER?
	JE	SUIN10			:NO, SECOND CHAR OF PAIR NOT PRESENT
	ST	R3,BB,R2,
	JAL	R8,GCI
	STB	R1,SUICHR+1		:SAVE SECOND CHARACTER OF PAIR
	LHL	R1,SUICHR
	CLHI	R1,01FD			:WAS CHAR PAIR BLACK BALL (BUFFER ZAP)?
	JNFS	SUIN10			:NO
	LIS	R0,0			:YES - INDICATE BLACK BALL DETECTED
	STH	R0,SUICHR		: ON COMMAND CIRCUIT
	JFS	SUICH1			: AND GO FORMAT CHAN 1 MESSAGE TO SUP
SUIN10	LIS	R0,2			:SHOW UNKNOWN INVAL CHAR PAIR DETECTED

:	FORMAT CHANNEL 1 MESSAGE TO SUPERVISOR. ROUTINE ENTERED WITH MESSAGE
:	TYPE IN R0 - 0 FOR BLACK BALL, 1 FOR GOBBLER, 2 FOR OTHER INVALID
:	CHARACTER PAIR. FIRST HW IS 088x, WHERE x IS THE MESSAGE TYPE. SECOND
:	HW CONTAINS THE OFFENDING PORT NUMBER. THIRD HW (IF PRESENT) HAS THE
:	CHARACTER PAIR DETECTED. REGISTER PRD IS SET TO POINT BACK TO BEGINNING
:	OF CURRENT RECORD, WHICH IS WRITTEN OVER.
SUICH1	HS	0
	IF	SNRING
	LR	PRD,R11			:POINT BACK TO RECORD BEGINNING
	ELSE	:NOT SNRING
	SR	LRC,CD			:LRC HAS NUMBER OF BYTES ALREADY STORED
	SHI	PRD,4,LRC		:PRD NOW POINTS TO BEGIN OF CHAN 1 REC
	NR	PRD,TC
	EI	:SNRING
	LR	LRC,R0			:GET MESSAGE TYPE AND
	LB	LRC,SUIC1S,LRC		: COMPUTE LENGTH OF MESSAGE
	LIS	R1,1
	STH	R1,SIB,PRD,		:CHANNEL 1 MESSAGE
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIC10
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIC10	HS	0
	STH	LRC,SIB,PRD,		:LENGTH OF MESSAGE
	AM	LRC,SUPICC		:INCREMENT COUNT OF CHARACTERS TO SUP
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIC20
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIC20	HS	0
	OHI	R0,0880
       IF      CBZDBG                   :trace event which causes supe to zap
        STM     R0,REGST                :save all regs
        JAL     R14,SUIDB1,,            :log this msg
        GL      SUIDB1
        LM      R0,REGST                :restore all regs
       EI       :CBZDBG
	STH	R0,SIB,PRD,		:STORE MESSAGE TYPE
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIC30
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIC30	HS	0
	STH	CHN,SIB,PRD,		:STORE OFFENDING CHANNEL NUMBER
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIC40
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIC40	HS	0
	CLHI	LRC,4			:IS THERE MORE FOR THIS MESSAGE?
	JLEFS	SUIC90			:NO
	LHL	R1,SUICHR		:YES - GET NEXT 2 BYTES
	STH	R1,SIB,PRD,		: AND STORE
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIC90
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIC90	HS	0

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	LIS	R0,1
	TBT	R0,SRNTRE,,		:CHAN 1 TRACING ENABLED ?
	JE	SRNB03			:NO

	ST	R1,SRNSAV,,		:SAVE R1
	ST	R2,SRNSAV+4,,		:AND R2
	LHL	R2,SRNTRX,,		:NEXT ENTRY IN TRACE TABLE
	LR	R1,R11			:BEGINNING OF RECORD IN RING
	AIS	R1,4			:POINT TO RECORD DATA
	JLFS	SRNB05			:SUP NEG RING NOT WRAPPED
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNB05	LB	R0,SIB,R1,		:GET DATA FROM RING
	STB	R0,SRNTBL,R2,		:AND ENTER INTO TRACE TABLE
	AIS	R2,1			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNB06			:NO
	LIS	R2,0			:WRAP
SRNB06	AIS	R1,1			:BUMP RING INDEX
	JLFS	SRNB07			:NO NEGATIVE WRAP
	SHI	R1,SUPBSZ		:NEG RING WRAP
SRNB07	CR	R1,PRD			:END OF RECORD?
	JL	SRNB05			:NO
	THI	R2,0001			:ODD TRACE TABLE INDEX ?
	JEFS	SRNB08			:NO
	LIS	R0,0
	STB	R0,SRNTBL,R2,		:CLEAR DUMMY PAD BYTE
	AIS	R2,1			:ENFORCE EVEN TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNB08			:NO
	LIS	R2,0			:WRAP
SRNB08	LR	R1,R11			:POINT TO BEGIN OF RECORD IN SUP RING
	AIS	R1,2			:POINT TO LRC
	JLFS	SRNB0D			:SUP NEG RING NOT WRAPPED
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNB0D	LHL	R0,SIB,R1,		:GET LRC FROM RING
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNB09			:NO
	LIS	R2,0			:WRAP
SRNB09	LHL	R0,FASTC+2,,		:GET FASTC MARK
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNB0A			:NO
	LIS	R2,0			:WRAP
SRNB0A	LHL	R0,SIB,R11,		:GET CHAN # FROM RING
	STH	R0,SRNTBL,R2,		:AND STORE IN TRACE TABLE
	AIS	R2,2			:BUMP TRACE TABLE INDEX
	CLHI	R2,SRNTSZ		:WRAP ?
	JLFS	SRNB10			:NO
	LIS	R2,0			:WRAP
SRNB10	STH	R2,SRNTRX,,		:UPDATE TRACE TABLE INDEX
	L	R1,SRNSAV,,		:RECOVER R1
	L	R2,SRNSAV+4,,		:RECOVER R2

SRNB03	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	STH	CHN,SUERCH		:SAVE OFFENDING CHANNEL NUMBER
	STH	R0,SUERTP		: AND ERROR TYPE
	JAL	R8,CBCLR		:CLEAR BUFFER (index in R2)
	J	SUPI90			:DONE

:	zapper
SUIZAP	HS	0
	JAL	R9,ZAPV,,		:ZAPPER
	IF	SNRING
	LR	PRD,R11
	AIS	PRD,4			:POINT TO BEGINNING OF DATA AREA
	JLFS	SUIZ10
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	SR	LRC,CD			:DISCARD ANY PRECEDING CHARS
	SR	PRD,LRC
	NR	PRD,TC
	EI	:SNRING
SUIZ10	HS	0
	RBT	CHN,SUPBPX		:NO MORE DATA FLOW ON THIS CHANNEL
	STH	CHN,SIB,PRD,		:SEND ZAPPER MESSAGE ON CHANNNEL 0
	AIS	PRD,2
	IF	SNRING
	JLFS	SUIZ20
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUIZ20	HS	0
	LIS	CHN,0
	LIS	LRC,2			:MESSAGE LENGTH
	J	SUPI80

::*********************************************************************
::
::	TABLE:	   SUIC1S:
::	FUNCTION:  LENGTHS FOR CHANNEL 1 MESSAGES, ORDERED BY MESSAGE TYPE
::
::*********************************************************************

SUIC1S	BC	6,4,6,0

	EI	:SUPER

	SUBTTL	XHOSTS (SUPOUT - Moves sup data out into network)

::*********************************************************************
::
::	SUBROUTINE:	SUPOUT:
::	FUNCTION:	Moves data from sup output data ring (SOB) into network
::	CALLING SEQ:	JAL	R10,SUPOUT
::	CALLS:		JAL	R9,SOROOM
::			JAL	R8,WCI
::			JAL	R9,SIBPRM
::			JAL	R0,EXYLD
::			JAL	R9,ZAPHRD
::			JAL	R10,SCQZAP
::			JAL	R8,CRYPTO
::
::*********************************************************************

	IF	SUPER

SUPOUT	HS	0
	ST	R10,XHSVRT

SUONXT	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR SUPOUT
	CPUTNM(SUPOUT)			:DEFINE CPUTIL ENTRY FOR SUPOUT
	EI	:DB.CPU

	JAL	R9,SOROOM		:COMPUTE AMOUNT OF DATA IN SOB RING
	LR	PRC,PRC
	JE	SUPOUX			:NO DATA, EXIT

	LHL	CHN,SOB,PRD,		:GET THE PORT #
	JE	SUZERO			:PORT 0 MESSAGE
	AIS	PRD,2
	IF	SNRING
	JLFS	SUON10
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUON10	HS	0
	LHL	LRC,SOB,PRD,		:# OF DATA BYTES TO MOVE
	AM	LRC,SUPOCC		:COUNT OF CHARS FROM SUP
	AIS	PRD,2
	IF	SNRING
	JLFS	SUON20
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUON20	HS	0
:	FORCE SIZE TO HW BOUNDARY AND SAVE IN PRC. WILL UPDATE NOSO
: 	WHEN DONE EMPTYING THIS LOGICAL RECORD.
	LHI	PRC,5,LRC		:LRC + 4-BYTE HEADER,
	NHI	PRC,-2			: ROUNDED UP IF NECESSARY

	LHL	R2,SIOTAB,CHN,CHN	:GET BUFF #
	NHI	R2,-4
	JE	SUOER1			:UNASSIGNED CHANNEL - IGNORE
:       following len logic is to allow passing of large msgs.  If
:       msg len will end up (after escaping) under 100x bytes then it
:       has an escape byte and a byte of len.  If the len is between 100
:       and 600x after escaping then escape both bytes of len.  If len>600x
:       then don't escape 1st byte since if escaped it would look like a
:       msg of 6 bytes (which is the smallest legal msg).               ###sdw
	LIS	R1,0			:WRITE THE LEADING ESCAPE FOR BYTE CNT
	JAL	R8,WCI
        CLHI    LRC,400                 :very large msg?
        JLFS    SUON23                  :nope
        L       R11,BE,R2,              :1st byte not escaped
        J       SUON26
SUON23	JAL	R8,WCI			:SAVE SPACE FOR BYTE COUNT
	L	R11,BE,R2,		:POINTER TO BYTE COUNT
        CLHI    LRC,0C0                 :two byte len (with escapes)?
        JLFS    SUON27                  :nope just one byte len
SUON26  JAL     R8,WCI                  :escape low byte
        JAL     R8,WCI
        AI      R11,80000000            :and mark this as a HW of len
SUON27  HS      0

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	TBT	CHN,SRNTRE,,		:IS THIS CHANNEL TRACE ENABLED ?
	JE	SRNE01			:NO
	LR	R1,PRD			:GET POINTER TO START OF RECORD DATA
	AIS	R1,2			:POINT TO MESSAGE TYPE
	JLFS	SRNE02			:SUP NEG RING NOT WRAPPED
	SHI	R1,SUPBSZ		:SUP NEG RING WRAPPED
SRNE02	LB	R0,SOB,R1,		:GET MESSAGE TYPE BYTE
	LIS	R1,1			:ASSUME MESSAGE IS NOT TO BE TRACED
	TBT	R0,SRNOCK,,		:IS THIS MESSAGE DESIRED ?
	JNFS	SRNE03			:NO
	LIS	R1,0			:MESSAGE TO BE TRACED
SRNE03	STH	R1,SRNSAV+8,,		:FLAG MESSAGE STATE
	ST	LRC,SRNSAV+4,,		:SAVE CURRENT LRC(ACTUAL RING DATA LRC)
					:FOR TRACE TABLE AFTER DATA.
SRNE01	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	LR	CD,LRC
	AIS	LRC,2			:MESSAGE IS AT LEAST THIS LONG
SUPO10	HS	0
	LB	R1,SOB,PRD,		:GET BYTE

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	TBT	CHN,SRNTRE,,		:IS THIS CHANNEL TRACE ENABLED ?
	JE	SRNF01			:NO
	LH	R0,SRNSAV+8,,		:CHECK IF THIS MESSAGE IS DESIRED
	JN	SRNF01			:NO, BYPASS

	LR	R0,R1			:SAVE DATA BYTE
	LHL	R1,SRNTRX,,		:GET INDEX INTO TRACE TABLE
	STB	R0,SRNTBL,R1,		:STORE CHAN DATA (OUTPUT FROM SUP)
	AIS	R1,1			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNF02			:NO
	LIS	R1,0			:WRAP

SRNF02	STH	R1,SRNTRX,,		:UPDATE TRACE TABLE INDEX
	LR	R1,R0			:RECOVER DATA BYTE IN R1

SRNF01	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	AIS	PRD,1
	IF	SNRING
	JLFS	SUPO12
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC
	EI	:SNRING
SUPO12	HS	0
	CLHI	R1,4			:DOES IT NEED TO BE ESCAPED?
	JGEFS	SUPO20
	EXBR	R1,R1			:YES
	JAL	R8,WCI
	EXBR	R1,R1
	AIS	LRC,1			:BYTE COUNT IS AFFECTED
SUPO20	JAL	R8,WCI
	SIS	CD,1
	JG	SUPO10			:get another byte

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	TBT	CHN,SRNTRE,,		:IS THIS CHANNEL TRACE ENABLED ?
	JE	SRNF06			:NO
	LH	R0,SRNSAV+8,,		:IS THIS MESSAGE BEING TRACED
	JN	SRNF06			:NO

	LHL	R1,SRNTRX,,		:GET FINAL TRACE TABLE INDEX
	THI	R1,0001			:ODD TRACE TABLE INDEX ?
	JEFS	SRNF03			:NO
	LIS	R0,0
	STB	R0,SRNTBL,R1,		:CLEAR DUMMY PAD BYTE
	AIS	R1,1			:ENFORCE EVEN TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNF03			:NO
	LIS	R1,0			:WRAP
SRNF03	L	R0,SRNSAV+4,,		:GET RING LRC
	STH	R0,SRNTBL,R1,		:AND STORE IN TRACE TABLE
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNF04			:NO
	LIS	R1,0			:WRAP
SRNF04	LHL	R0,FASTC+2,,		:GET FASTC MARK
	STH	R0,SRNTBL,R1,		:AND STORE IN TRACE TABLE
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNF0A			:NO WRAP
	LIS	R1,0			:WRAP
SRNF0A	LR	R0,CHN			:GET CHANNEL #
	OHI	R0,8000			:SET HO BIT TO INDICATE OUT FROM SUP
	STH	R0,SRNTBL,R1,		:STORE IN TRACE TABLE
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNF05			:NO
	LIS	R1,0			:WRAP
SRNF05	STH	R1,SRNTRX,,		:UPDATE TRACE TABLE INDEX

SRNF06	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

:       following finishes the different types of len                   ###sdw
        LR      R3,R11
        TI      R11,80000000            :is this a long len?
        JE      SUPO29                  :nope
        NI      R3,7FFFFFFF             :make back into address
        EXBR    LRC,LRC
        STB     LRC,0,R3                :save hign byte of len
        EXBR    LRC,LRC
        JAL     R8,NCI                  :advance over escape byte
        JAL     R8,NCI                  :point to low byte of len
SUPO29	STB	LRC,0,R3		:SET THE FINAL BYTE COUNT
SUPO30	LHL	R0,BCT,R2,		:BACKPRESSURE SUP IF BUFF TOO FULL
	CLHI	R0,CIRSP3		:ARBITRARILY CIRCUIT SPEED 3
	JL	SUPO50			:DON'T BACKPRESSURE

:	backpressure sup (SIBP)
SUPO40	IF	SNRING
	LR	R0,PRC			:SAVE RECORD LENGTH,
	JAL	R9,SIBPRM		: SET UP SIBP POINTERS,
	LR	PRC,PRC			: AND TEST FOR ROOM IN SIBP RING
	JLEFS	SUPO44			:NO ROOM, DON'T APPLY BACKPRESSURE
	LR	R9,CHN
	OHI	R9,8000			:CHN+8000 TO TURN BACKPRESSURE ON
	STH	R9,SIBP,PRD,		:APPLY BACKPRESSURE FOR THIS CHANNEL
	AIS	PRD,2
	JLFS	SUPO42
	SHI	PRD,SIBPSZ		:NEGATIVE RING WRAP
SUPO42	STH	PRD,NISIBP,,		:UPDATE LEAD POINTER
SUPO44	LR	PRC,R0			:RESTORE PRC
	EI	:SNRING
	RBT	CHN,SUPBPX		:BACKPRESSURE APPLIED THIS CHANNEL

:	DONE WITH THIS RECORD - UPDATE NOSO...
SUPO50	HS	0
	IF	SNRING
	AH	PRC,NOSO,,		:SOB TRAIL POINTER
	JLFS	SUPO52
	SHI	PRC,SUPBSZ		:NEGATIVE RING WRAP
SUPO52	STH	PRC,NOSO,,
	ELSE	:NOT SNRING
	AHM	PRC,NOSO,,		:UPDATE SOB TRAIL POINTER
	EI	:SNRING

	JAL	R0,EXYLD,,		:YIELD AFTER TRANSFER
	J	SUONXT			:ALL DONE W/ THIS PORT

:	port 0 message
SUZERO	HS	0
	AIS	PRD,4			:PORT 0 MESSAGE
	IF	SNRING
	JLFS	SUZER1
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NR	PRD,TC			:SKIP LRC
	EI	:SNRING
SUZER1	HS	0
	LHL	CHN,SOB,PRD,		:THIS IS THE ZAPPED CHANNEL

:	supervisor trace logic
	IF	SIORNG
	IF	SNRING
	IF	SUPTRC
	LIS	R0,0
	TBT	R0,SRNTRE,,		:IS CHAN 0 TRACE ENABLED
	JE	SRNC01			:NO

	ST	R1,SRNSAV,,		:SAVE R1
	LHL	R1,SRNTRX,,		:GET INDEX INTO TRACE TABLE
	STH	CHN,SRNTBL,R1,		:STORE CHAN ZERO DATA (OUTPUT FROM SUP)
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNC02			:NO
	LIS	R1,0			:WRAP
SRNC02	LIS	R0,2			:LOG REC COUNT (ALWAYS 0002)
	STH	R0,SRNTBL,R1,		:STORE LRC
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP?
	JLFS	SRNC04			:NO
	LIS	R1,0			:WRAP
SRNC04	LHL	R0,FASTC+2,,		:GET FASTC MARK
	STH	R0,SRNTBL,R1,		:AND STORE IN TRACE TABLE
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNC0A			:NO
	LIS	R1,0			:WRAP
SRNC0A	LHI	R0,8000			:CHAN ZERO + OUTPUT INDICATOR BIT
	STH	R0,SRNTBL,R1,		:STORE CHAN ZERO (OUTPUT FROM SUP)
	AIS	R1,2			:BUMP TRACE TABLE INDEX
	CLHI	R1,SRNTSZ		:WRAP ?
	JLFS	SRNC05			:NO
	LIS	R1,0			:WRAP
SRNC05	STH	R1,SRNTRX,,		:UPDATE TRACE TABLE INDEX
	L	R1,SRNSAV,,		:RECOVER R1

SRNC01	HS	0			:TRACE BYPASS
	EI	:SUPTRC
	EI	:SNRING
	EI	:SIORNG

	LIS	PRC,6			:RECORD SIZE 6, UPDATE NOSO IN 'SUPO52'
	THI	CHN,8000		:TEST FOR SPECIAL MESSAGE
	JN	SUOSLP			:SLEEP MESSAGE

:	sup zap
SUOZAP	LHL	R2,SIOTAB,CHN,CHN	:ZAPPER
	NHI	R2,-4
	JE	SUOER2			:UNASSIGNED CHANNEL, IGNORE
	JAL	R9,ZAPHRD,,
	J	SUPO40			:AND BACKPRESSURE CHANNEL

:	sup has gone to sleep
SUOSLP	HS	0			:SUP HAS GONE TO SLEEP
	STH	PRC,XHPRCS		:SAVE PRC
	JAL	R10,SCQZAP		:ZAP ALL COMMAND CIRCS FROM SUP INTERF
	LHL	PRC,XHPRCS
	LIS	R0,4			:SET SUP STATE
	STH	R0,TVRSTT
	J	SUPO50			:ALL CIRCUITS ZAPPED, UPDATE NOSO

SUPOUX	J	XHRET			:RETURN TO SPIDER

:	CRYPTO 24: SUP DATA ON UNASSIGNED CHN
SUOER1	HS	0			:SUP SENT DATA ON UNASSIGNED PORT
	LR	R0,CHN
	JAL	R8,CRYPTO,,		:REPORT TO XRAY WITH CHANNEL NUM IN R0
	HC	CRYE24
	J	SUPO50			:GO UPDATE NOSO AND DISMISS

:	CRYPTO 25: SUP ZAP ON UNASSIGNED CHN
SUOER2	HS	0			:SUP SENT ZAPPER ON UNASSIGNED PORT
	LR	R0,CHN
	JAL	R8,CRYPTO,,		:REPORT TO XRAY WITH CHANNEL NUM IN R0
	HC	CRYE25
	J	SUPO50

	EI	:SUPER

	SUBTTL	XHOSTS (Sup process utility routines)

:	THE FOLLOWING SUBROUTINES ARE FOR HANDLING THE NEGATIVE
: 	INDEXED FORMAT FOR THE SUPERVISOR INTERFACE RINGS (ENABLED BY ASSEMBLY
: 	OPTION 'SNRING'). THERE ARE 6 RINGS:
:
:	SIB - DATA RING, NODE-->SUP
:		NISI LEAD POINTER, NODE INDEXED
:		NOSI TRAIL POINTER, SUP INDEXED
:
:	SOB - DATA RING, SUP-->NODE
:		NISO LEAD POINTER, SUP INDEXED
:		NOSO TRAIL POINTER, NODE INDEXED
:
:	SIBP - BACKPRESSURE RING, NODE-->SUP
:		NISIBP LEAD POINTER, NODE INDEXED
:		NOSIBP TRAIL POINTER, SUP INDEXED
:
:	SOBP - BACKPRESSURE RING, SUP-->NODE
:		NISOBP LEAD POINTER, SUP INDEXED
:		NOSOBP TRAIL POINTER, NODE INDEXED
:
:	SIC - CONTROL RING, NODE--SUP
:		NISIC LEAD POINTER, NODE INDEXED
:		NOSIC TRAIL POINTER, SUP INDEXED
:
:	SOC - CONTROL RING, SUP-->NODE
:		NISOC LEAD POINTER, SUP INDEXED
:		NOSOC TRAIL POINTER, NODE INDEXED
:
:	THE 'ROOM' SUBROUTINES DETERMINE THE SPACE AVAILABLE FOR INPUT
: 	RINGS (NODE-->SUP), OR COMPUTE THE AMOUNT OF DATA WAITING FOR
: 	OUTPUT RINGS (SUP-->NODE). ALL SUBS LINK ON R9, RETURN PRD AS THE
: 	NODE'S RING INDEX, AND PRC AS THE LENGTH.

	IF	SUPER

::*********************************************************************
::
::	SUBROUTINE:	SIROOM:
::	FUNCTION:	COMPUTE AMOUNT OF SPACE AVAILABLE IN SIB
::	CALLING SEQ:	JAL	R9,SIROOM
::
::*********************************************************************

SIROOM	HS	0
	IF	SNRING
	LH	PRD,NISI,,		:NODE INDEX
	NEGTST(NOP,,NISI,0)		:IF DB.DEB, INSURE NEG RING POINTERS
	LH	PRC,NOSI,,		:SUP INDEX
	NEGTST(NOP,,NOSI,0)
	IF	DB.DEB
	STH	PRD,SRNRPS		:SAVE USEFUL VALUES
	STH	PRC,SRNPRS
	EI	:DB.DEB
	SHI	PRC,2,PRD		:COMPUTE SPACE LEFT IN RING
	JGER	R9
	AHI	PRC,SUPBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

	ELSE	:NOT SNRING

	LH	PRD,NISI,,		:NODE INDEX
	LH	PRC,NOSI,,		:SUP INDEX
	SHI	PRC,SUPBSZ,PRD
	NHI	PRC,2*SUPBSZ-1		:TRUNCATE SPACE LEFT IN RING
	LHI	TC,SUPBSZ-1		:SET UP POWER OF 2 MASK FOR RING WRAP
	NR	PRD,TC
	JR	R9			:RETURN
	EI	:SNRING

::*********************************************************************
::
::	SUBROUTINE:	SOROOM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA AVAILABLE IN SOB
::	CALLING SEQ:	JAL	R9,SOROOM
::
::*********************************************************************

SOROOM	HS	0
	IF	SNRING
	LH	PRD,NOSO,,		:NODE INDEX
	NEGTST(NOP,,NOSO,0)		:IF DB.DEB, INSURE NEG RING POINTERS
	LH	PRC,NISO,,		:SUP INDEX
	NEGTST(NOP,,NISO,0)
	SR	PRC,PRD			:COMPUTE AMOUNT OF DATA IN RING
	JGER	R9
	AHI	PRC,SUPBSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

	ELSE	:NOT SNRING

	LH	PRD,NOSO,,		:NODE INDEX
	LH	PRC,NISO,,		:SUP INDEX
	SR	PRC,PRD
	NHI	PRC,2*SUPBSZ-1		:TRUNCATE SPACE LEFT IN RING
	LHI	TC,SUPBSZ-1		:SET UP POWER OF 2 MASK FOR RING WRAP
	NR	PRD,TC
	JR	R9			:RETURN
	EI	:SNRING

	IF	SNRING
:	THE FOLLOWING ROUTINES APPLY ONLY TO THE NEGATIVE INDEX SUPERVISOR
:	INTERFACE SINCE THE RINGS REFERENCED DO NOT EXIST OTHERWISE.

::*********************************************************************
::
::	SUBROUTINE:	SIBPRM:
::	FUNCTION:	COMPUTE SPACE AVAILABLE IN SIBP RING
::	CALLING SEQ:	JAL	R9,SIBPRM
::
::*********************************************************************

SIBPRM	HS	0
	LH	PRD,NISIBP,,		:NODE INDEX
	NEGTST(NOP,,NISIBP,0)
	LH	PRC,NOSIBP,,		:SUP INDEX
	NEGTST(NOP,,NOSIBP,0)
	SHI	PRC,2,PRD		:COMPUTE SPACE AVAILABLE
	JGER	R9
	AHI	PRC,SIBPSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SOBPRM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA IN SOBP RING
::	CALLING SEQ:	JAL	R9,SOBPRM
::
::*********************************************************************

SOBPRM	HS	0
	LH	PRD,NOSOBP,,		:NODE INDEX
	NEGTST(NOP,,NOSOBP,0)
	LH	PRC,NISOBP,,		:SUP INDEX
	NEGTST(NOP,,NISOBP,0)
	SR	PRC,PRD			:COMPUTE AMOUNT OF DATA WAITING
	JGER	R9
	AHI	PRC,SOBPSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SICROM:
::	FUNCTION:	COMPUTE AMOUNT OF SPACE AVAILABLE IN SIC RING
::	CALLING SEQ:	JAL	R9,SICROM
::
::*********************************************************************

SICROM	HS	0
	LH	PRD,NISIC,,		:NODE INDEX
	NEGTST(NOP,,NISIC,0)
	LH	PRC,NOSIC,,		:SUP INDEX
	NEGTST(NOP,,NOSIC,0)
	SHI	PRC,2,PRD		:COMPUTE SPACE AVAILABLE
	JGER	R9
	AHI	PRC,SICSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SOCROM:
::	FUNCTION:	COMPUTE AMOUNT OF DATA WAITING IN SOC RING
::	CALLING SEQ:	JAL	R9,SOCROM
::
::*********************************************************************

SOCROM	HS	0
	LH	PRD,NOSOC,,		:NODE INDEX
	NEGTST(NOP,,NOSOC,0)
	LH	PRC,NISOC,,		:SUP INDEX
	NEGTST(NOP,,NISOC,0)
	SR	PRC,PRD			:COMPUTE AMOUNT OF DATA WAITING
	JGER	R9
	AHI	PRC,SOCSZ		:ADJUST FOR RING WRAP
	JR	R9			:RETURN

	EI	:SNRING

::*********************************************************************
::
::	SUBROUTINE:	IZSUP:
::	FUNCTION:	INITIALIZE FIELDS FOR SUP INTERFACE
::	CALLING SEQ:	JAL	R10,IZSUP
::
::*********************************************************************

:	IF SNRING, INITIALIZE NEGATIVE RING POINTERS. IF NOT SNRING, SET SBUFS.

IZSUP	HS	0
	IF	SNRING
	LHI	R0,-SUPBSZ
	STH	R0,NISI,,		:INIT SIB POINTERS
	STH	R0,NOSI,,

	STH	R0,NISO,,		:INIT SOB POINTERS
	STH	R0,NOSO,,

	LHI	R0,-SIBPSZ
	STH	R0,NISIBP,,		:INIT SIBP POINTERS
	STH	R0,NOSIBP,,

	STH	R0,NISOBP,,		:INIT SOBP POINTERS
	STH	R0,NOSOBP,,

	LHI	R0,-SICSZ
	STH	R0,NISIC,,		:INIT SIC POINTERS
	STH	R0,NOSIC,,

	STH	R0,NISOC,,		:INIT SOC POINTERS
	STH	R0,NOSOC,,

	ELSE	:NOT SNRING

	LHI	R0,SUPZFL
	STH	R0,SBUFS,,		:ABSOLUTE CHANNEL 0 OF SUP INTERFACE

	EI	:SNRING

	JR	R10			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SUPBPS:
::	FUNCTION:	RELIEVE BACKPRESSURE ON SUP PORTS THAT HAVE
::			SUFFICIENTLY LOW CHARACTER COUNTS
::	CALLING SEQ:	JAL	R10,SUPBPS
::			JAL	R9,SIBPRM
::			JAL	R9,SOBPRM
::
::*********************************************************************

SUPBPS	HS	0
	ST	R10,XHSVRT		:SAVE RETURN ADDRESS
	LIS	R4,0			:UPDATE SUPBPS BITS, SIBP IF SNRING
	LIS	R7,0

SUPB10	L	R0,SUPBPX,R7		:PORTS/BITS ARE RESET IF BACKPRESSURED
	O	R0,SUPACP,R7,		:PORTS ACTIVE IF RESET
	LCS	R1,1
	XR	R1,R0			:SET IF ACTIVE .AND. BACKPRESSURED
	ST	R1,SBPTMP		:USED AS TEMP STORAGE
SUPB20	L	R1,SBPTMP
	JE	SUPB30			:NOBODY BP'ED
        JFFO    R1,SUPB21
SUPB21	RBT	R2,SBPTMP
	AR	R2,R4			:SUP CHANNEL #
	LHL	R3,SIOTAB,R2,R2
	LR	R6,R3			:SAVE CIRCUIT SPEED
	NHI	R3,-4			:R3=BUFF #
	JE	SUPB20			:IDLE CHANNELS REMAIN BP'ED
	NHI	R6,3			:SPEED BITS
	LHL	R6,CIRSPK,R6,R6		:SPEED
	CLH	R6,BCT,R3,
	JL	SUPB20			:PORT MUST REMAIN BP'ED
	IF	SNRING
:	SEND CHANNEL NUMBER OVER SIBP RING TO RELEASE BACKPRESSURE
	JAL	R9,SIBPRM		:IS THERE ROOM IN SIBP?
	LR	PRC,PRC
	JLE	SUPB40			:NO ROOM, PROCEED NO FURTHER
	STH	R2,SIBP,PRD,		:RELEASE BACKPRESSURE FOR THIS CHANNEL
	AIS	PRD,2
	JLFS	SUPB22
	SHI	PRD,SIBPSZ		:NEGATIVE RING WRAP
SUPB22	STH	PRD,NISIBP,,		:UPDATE SIBP LEAD POINTER
	EI	:SNRING
	SBT	R2,SUPBPX		:INDICATE THIS CHANNEL'S BP RELEASED
	J	SUPB20
SUPB30	AIS	R7,4			:TRY NEXT PORT GROUP
	AHI	R4,20
	CLHI	R4,NSP
	JL	SUPB10

SUPB40	HS	0
	IF	SNRING
:	GET SUP BACKPRESSURE DATA FROM SOBP RING. CHANNEL NUMBER
: 	RELEASES BACKPRESSURE, CHANNEL NUMBER + 8000 APPLIES BACKPRESSURE.
	JAL	R9,SOBPRM		:ANY DATA IN SOBP RING?
	LR	PRC,PRC
	JLE	XHRET			:NO - RETURN
	LH	CHN,SOBP,PRD,		:GET NEXT ENTRY FROM SOBP RING
	JLFS	SUPB50			:APPLY BACKPRESSURE
	IF	DB.DEB
	CLHI	CHN,NSP			:INSURE VALID CHANNEL NUMBER
	JLFS	SUPB42			:O.K.
	DBOOPS				:SUP PASSED US INVALID CHANNEL NUMBER
	EI	:DB.DEB
SUPB42	SBT	CHN,SUPBPV		:RELEASE BACKPRESSURE FOR THIS CHANNEL
	JFS	SUPB60
SUPB50	NHI	CHN,7FFF		:STRIP HI-ORDER BIT
	IF	DB.DEB
	CLHI	CHN,NSP			:INSURE VALID CHANNEL NUMBER
	JLFS	SUPB52			:O.K.
	DBOOPS				:SUP PASSED US INVALID CHANNEL NUMBER
	EI	:DB.DEB
SUPB52	RBT	CHN,SUPBPV		:APPLY BACKPRESSURE FOR THIS CHANNEL
SUPB60	AIS	PRD,2
	JLFS	SUPB70
	SHI	PRD,SOBPSZ		:NEGATIVE RING WRAP
SUPB70	STH	PRD,NOSOBP,,		:UPDATE SOBP TRAIL POINTER
	J	SUPB40			:LOOK FOR MORE SOBP WORK
	ELSE	:NOT SNRING
	J	XHRET			:RETURN
	EI	:SNRING

::*********************************************************************
::
::	SUBROUTINE:	G08SUP:
::	FUNCTION:	EIGHT-SECOND TEST OF SUPER STATUS
::	CALLING SEQ:	JAL	R10,G08SUP
::	CALLS:		JAL	R9,SOCROM
::			JAL	R10,SCQZAP
::			JAL	R10,SICROM
::
::*********************************************************************

:	SUPERVISOR SENDS STATUS THRU SOC CONTROL RING. HALFWORD ENTRIES
: 	ARE -1 FOR SUP SLEEPING, 1 FOR SUP AWAKE. IF NO NEW ENTRIES IN RING
: 	EACH 8 SECONDS, CONSIDER SUP FROZEN (OR SICK).

	IF	SNRING

G08SUP	HS	0
	ST	R10,XHSVRT		:SAVE RETURN ADDRESS
	JAL	R9,SOCROM		:ANY DATA IN SOC CONTROL RING?
	LR	PRC,PRC
	JLE	SUPC40			:NO DATA, SUP NOT UPDATING SOC RING
SUPC02	LH	R0,SOC,PRD,		:GET ENTRY FROM RING
	JLFS	SUPC20			:SLEEPING SUP
	IF	DB.DEB
	SIS	R0,1
	JEFS	SUPC10			:ENTRY = 1, SUP AWAKE
	DBOOPS				:INVALID CONTROL RING ENTRY FROM SUP
	EI	:DB.DEB
SUPC10	LIS	R0,5			:STATUS FOR AWAKE SUP...
	JFS	SUPC30
SUPC20	IF	DB.DEB
	AIS	R0,1			:INSURE VALID CONTROL RING ENTRY
	JEFS	SUPC22			:O.K.
	DBOOPS				:INVALID CONTROL RING ENTRY FROM SUP
	EI	:DB.DEB
SUPC22	LIS	R0,4			:STATUS FOR SLEEPING SUP...
SUPC30	STH	R0,TVRSTT		:SAVE SUP STATUS
	AIS	PRD,2
	JLFS	SUPC32
	SHI	PRD,SOCSZ		:NEGATIVE RING WRAP
SUPC32	STH	PRD,NOSOC,,		:UPDATE SOC TRAIL POINTER
	JAL	R9,SOCROM		:ANY MORE ENTRIES IN SOC RING?
	LR	PRC,PRC
	JLE	SUPCIN			:NO - GO UPDATE SIC CONTROL RING
	J	SUPC02			:YES - EMPTY SIC RING
SUPC40	LIS	R0,3			:NO ENTRIES FROM SUP
	CLH	R0,TVRSTT		:WAS IT ALREADY FROZEN?
	JEFS	SUPC42			:YES
	STH	R0,TVRSTT		:NO - SAVE SUP STATUS AND
	JAL	R10,SCQZAP		: ZAP ALL COMMAND CIRCUITS
SUPC42	HS	0
	IF	SIORNG			:ONLY IF SPLIT/SUP		###GT
	LIS	R0,1			:UPDATE KERNEL STATUS
	AHM	R0,KERSTT		:SUP GONE, CHECK IF KERNEL STILL UP
					:DURING LOGIN TO KERNEL		###GT
	EI	:SIORNG

:	PUT NODE NUMBER, ABSOLUTE CHANNEL NUMBER OF INTERFACE IN SIC RING
SUPCIN	HS	0
	JAL	R9,SICROM		:ANY ROOM IN SIC?
	CLHI	PRC,4
	JLE	XHRET			:NO
	LHI	R0,SUPZFL		:SUP CHANNEL 0 ABSOLUTE CHANNEL NUMBER
	STH	R0,SIC,PRD,
	AIS	PRD,2
	JLFS	SUPC60
	SHI	PRD,SICSZ		:NEGATIVE RING WRAP
SUPC60	LHI	R0,MACHNM+8000		:NODE NUMBER + 8000
	STH	R0,SIC,PRD,
	AIS	PRD,2
	JLFS	SUPC70
	SHI	PRD,SICSZ		:NEGATIVE RING WRAP
SUPC70	STH	PRD,NISIC,,		:UPDATE SIC LEAD POINTER
	J	XHRET			:DONE

	ELSE	:NOT SNRING

G08SUP	LHL	R1,TVRSTT		:PREVIOUS STATUS
	LIS	R0,5			:SET SUP STATUS WORD
	STH	R0,TVRSTT
	TS	NODINF,,		:IS SUP AWAKE
	JER	R10			:YES
	JGFS	.+4			:SUP IS DOWN

	SIS	R0,1
	SIS	R0,1
	STH	R0,TVRSTT
	SIS	R1,4			:HAS SUP BEEN DOWN
	JLER	R10			:YES

	EI	:SNRING

::*********************************************************************
::
::	SUBROUTINE:	SCQZAP:
::	FUNCTION:	ZAP ALL COMMAND CIRCUITS
::	CALLING SEQ:	JAL	R10,SCQZAP
::	CALLS:		JAL	R9,ZAPX
::			JAL	R8,CRYPTO
::
::*********************************************************************

SCQZAP	HS	0
	L	R0,FASTC,,		:SAVE FASTC
	ST	R0,FASSAV
	LHI	R6,NSP-1		:ZAP ALL CIRCUITS...
	LHI	R1,ZAPPH
G08SU1	LHL	R2,SIOTAB,6,6
	NHI	R2,-4
	JEFS	G08SU3
	JAL	R9,ZAPX,,		:SEND A ZAPPER OUT
	GL	ZAPX
	RBT	R6,SUPBPX
G08SU3	SIS	R6,1
	JGEBS	G08SU1

	LIS	R0,0
	JAL	R8,CRYPTO,,		:SUP STOP
	HC	CRYE06
	JR	R10

	EI	:SUPER

::*********************************************************************
::
::	SUBROUTINE:	KCQDET:
::	FUNCTION:	DETACH KERNEL PORTS DUE TO SIO RING LINE DOWN	
::	CALLING SEQ:	JAL	R10,KCQDET
::	CALLS:		JAL	R9,ZAPHRD
::			JAL	R9,ZAPX
::			JAL	R9,CRQHCR
::			JAL	R8,WCI
::			JAL	R9,ZAPV
::
::*********************************************************************

:	RE-ROUTE ALL CIRCUITS TO KERNEL TO GO TO DETACH PROCESS.
:	'DETCIR' WILL SEND MEANINGFUL TEXT TO KERNEL USER BEFORE ZAPPING...

	IF	SIORNG

KCQDET	HS	0
	LCS	R0,1
	L	R1,KERACP,,		:ACTIVE PORTS ZEROS
	O	R1,KRZAPI		:MASK OUT PORTS AWAITING ZAPPER ACK
	XR	R0,R1			:MAKE ACTIVE PORTS ONES
	ST	R0,KERSVD
KCQD10	L	R0,KERSVD
	JFFO	R0,KCQD20		:FIND NEXT ACTIVE KERNEL PORT TO DETACH
	J	KCQD40			:DONE, SEE IF ANY HALF-ZAPPED
KCQD20	RBT	R1,KERSVD
	LHL	R2,KIOTAB,R1,R1		:GET PERMUTER TABLE ENTRY AND
	NHI	R2,-4			: ISOLATE BUFFER INDEX
	LH	R0,BF,R2,		:ONLY GOT HALF A CIRCUIT?
	JGFS	KCQD25			:NO, DETACH COMPLETE CIRCUIT
	SBT	R1,KRZAPI		:HALF-ZAPPED IF NOT THROUGH NEWLOG SEQ
	J	KCQD10

KCQD25	LCS	R4,1			:DECREMENT NUMBER OF HOST PORTS IN USE
	AHM	R4,HNPORT

:	FIND AVAILABLE PORT TO DETACH PROCESS
	L	R4,DETACP,,		:DETACH PROCESS PORTS
	JFFO	R4,KCQD30
	JAL	R9,ZAPHRD,,		:NO DETACH PORTS, JUST ZAP CIRCUIT
	J	KCQD10
KCQD30	LIS	R0,4
	STB	R0,DETMTY,CHN		:STORE DETACH REASON
:	CALL ZAPX WITH CR/LF INSTEAD OF ZAPPER. THIS REMOVES THE CIRCUIT
:	ENTRY FROM THE KERNEL INTERFACE WITHOUT ACTUALLY ZAPPING THE CIRCUIT.
	LHI	R1,0D0A			:CARRIAGE-RETURN, LINE-FEED
	JAL	R9,ZAPX,,		:REMOVE KIOTAB ENTRY, SET ACP
	AHI	CHN,DETZFL		:DETACH PROCESS ABSOLUTE CHANNEL NUMBER
	JAL	R9,CRQHCR		:CONNECT CIRCUIT STUB TO DETACH PROCESS
	XHI	R2,4			:POINT TOWARDS DETACH PROCESS AND
	LIS	R1,3			: WRITE NEEDLE POINT INTO BUFFER
	JAL	R8,WCI			: TO ALERT DETCIR OF NEW PORT
	LHI	R1,NEEDP
	JAL	R8,WCI
	J	KCQD10			:GO FIND ANOTHER PORT TO DETACH

:	NOW ZAP SECOND HALF OF HALF-ZAPPED CIRCUITS. COULD HAVE BEEN
: 	AWAITING ZAPPER ACK FROM KERNEL WHEN SIO RING INTERFACE WENT DOWN,
: 	OR MAYBE GOT ZAPPER BEFORE NEWLOG HANDSHAKE COMPLETED.
KCQD40	L	R4,KRZAPI		:BITS SET FOR HALF-ZAPPED CIRCUIT
	JFFO	R4,KCQD50
	JR	R10			:DONE KERNEL PORT DETACH/CLEANUP
KCQD50	RBT	CHN,KRZAPI
	LHL	R2,KIOTAB,CHN,CHN
	NHI	R2,-4
	JEBS	KCQD40			:NO CIRCUIT
	XHI	R2,4			:FLIP BUFFER INDEX AND
	JAL	R9,ZAPV,,		: ZAP SECOND HALF OF CIRCUIT
	J	KCQD40

	EI	:SIORNG
	EI	:(1-T2GATE)		:Gateway doesn't use XHOSTS
	ENDMO.(XHOSTS)
	EI	:1-KILLIT
	KILMSG(XHOSTS)
:	***NOTHING PAST THIS POINT***

	SUBTTL	DISPI

       if       1-swtchr                :no dispatcher if switcher

:		****  *****  **** ****  *****
:		*   *   *   *     *   *   *
:		*   *   *    ***  ****    *
:		*   *   *       * *       *
:		****  ***** ****  *     *****

::#####################################################################
::
::	MODULE:		DISPI
::
::	FUNCTION:	INTERFACE TO THE ISIS DISPATCHER.
::
::	REGISTER CONVENTIONS:
::		TYC	= R11	:HOLDS MAGIC CONSTANT (03 OR 07)
::		TC	= R15	:FOR TRUNCATING RING POINTERS
::		PRD	= R12	:POINTER TO RECORD DATA
::		PRC	= R10	:PHYSICAL DITTO
::		CHN	= R5	:CHANNEL NUMBER
::		LRC	= R14	:LOGICAL RECORD BYTE COUNT
::		CD	= R13	:WORKING COUNT
::
::	SUBTTLS:
::	  	DISPI (TABLES)
::		DISPI (DISIN - MOVE DATA INTO DISPATCHER FROM NETWORK)
::		DISPI (DISOUT - MOVE DATA OUT OF DISPATCHER INTO NETWK)
::		DISPI (DSZERO - INTRA-ISIS COMUNICATIONS, RPORT = 0)
::		DISPI (UTILITY ROUTINES)
::		DISPI (CONSAT - LOGCHR)
::
::#####################################################################		

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE
	BEGMO.
	SEG 1
:	SUBTTL  DISPI (TABLES)

	IF	(1-T2GATE)	:Not used for Gateway configuration
::*********************************************************************
::
::	TABLE:		SLTLIC:
::	FUNCTION:	DEFINE SLOT LICENSE FOR EACH SLOT
::
::*********************************************************************

SLTLIC	WS	0
	SYAD(SLTLIC)		:SLOT LICENSE
Q	EQ	0
	RE	NUSLT+1		:ONCE FOR EACH SLOT
	IF	\S|Q|LIC	:IF LICENSE IS DEFINED
	WC	S|Q|LIC		:USE IT,
	ELSE
	WC	0		:USE THE DEFAULT
	EI	:\S|Q|LIC
Q	EQ	Q+1
	NOLIST
	ER
	LIST

::*********************************************************************
::
::	TABLE:		SCLTBL:
::	FUNCTION:	DEFINE LIMITS FOR NUMBER OF CIRCUITS/MINUTE 
::			AND NUMBER OF MESSAGES/MINUTE FOR EACH SLOT.
::
::*********************************************************************

:	CIRCUIT ACTIVITY LIMITS
SCLTBL	HS	0
	SYAD(SCLTBL)
Q	EQ	1
	RE	NUSLT
	HC	SCLT|$0Q|
Q	EQ	Q+1
	ER

::*********************************************************************
::
::	TABLE:		SMLTBL:
::	FUNCTION:	DEFINE SLOT REPORT LIMIT FOR EACH SLOT.
::
::*********************************************************************

SMLTBL	HS	0
	SYAD(SMLTBL)
Q	EQ	1
	RE	NUSLT
	HC	SMLT|$0Q|
Q	EQ	Q+1
	ER

::*********************************************************************
::
::	TABLES:		GHSTTB, GSHSTB, GCHSTB
::	FUNCTION:	IF RESTRICTED HOSTS HAVE BEEN DEFINED, SET UP
::			TABLES TO DEFINE HOST NUMBERS (GHSTTB),
::			HOST/SLOT RESTRICTIONS (GSHSTB),  AND
::			CIRCUITS PER MINUTE LIMITS (GCHSTB).
::
::*********************************************************************

	EI	:(1-T2GATE)	: end Gateway exclusion

:       define DSCALE for histogram shift facter

DSCALE  EQ      0
Q       EQ      32              :8 word entries in table
        RE      10              :biggest DRSZ is a HW
       IF       DRSZ-Q
Q       EQ      Q*2
DSCALE  EQ      DSCALE+1
       EI
        ER

	IF	RESHST

:	DEFINE ALL RESTRICTED HOSTS
GHSTTB	HS	0
	SYAD(GHSTTB)
Q	EQ	0
	RE	RESHST
	HC	GHST|$0Q|	:HOST NUMBER
Q	EQ	Q+1
	ER


:	DEFINE LEGAL SLOTS FOR EACH RESTRICTED HOST
GSHSTB	WS	0
	SYAD(GSHSTB)
Q	EQ	0
	RE	RESHST
	WC	GSHS|$0Q|	:BIT SET FOR LEGAL SLOT
Q	EQ	Q+1
	ER

:	DEFINE ACTIVITY LIMITS FOR EACH RESTRICTED HOST
GCHSTB	HS	0
	SYAD(GCHSTB)
Q	EQ	0
	RE	RESHST
	HC	GCHS|$0Q|	:CIRCUITS/MINUTE LIMIT FOR THIS HOST
Q	EQ	Q+1
	ER

	EI	:RESHST

:	bit assignments in psuedo needle request after local key
PSNIIX	EQ	8000		:pseudo needle request for IIX circuit
PSNELS	EQ	4000		:pseudo needle request for ext login status
PSNUUN	EQ	2000		:pseudo needle request for UUN

:	some local equates for immediate values
RDSPBP	EQ	0A100		:ring cmd to relieve backpressure
SDSPBP	EQ	0A000		:ring cmd to set backpressure
GRTLGN	EQ	0B600		:tell slot of successful logon
SUPRHNG	EQ	0B800		:super-(HDX) hang
XMTCAP	EQ	0B900		:ring cmd to set XMT capacity
UNUSNO	EQ	0C100		:universal user number (sup to slot)
DM.ISN  EQ      0C2             :LOG II needle
DM.RCR  EQ      0C3             :log II logon respone RCRI
DM.ICS  EQ      0C4             :subsequent log II logon data
DM.ASL  EQ      0C5             :assign log ii logon port
DM.LGS  EQ      0C6             :log II logon success
DM.ECR  EQ      12              :port 0 logII reject logon port

:       combine the globals which are always defined                    ###sdw
        GL      WCIE,LOGIN,GCIE,WHWI,GHWI,WCDE,PCIE,TRUNC


	SUBTTL	DISPI (DISIN - Move data into dispatcher from network)

::*********************************************************************
::
::	SUBPROCESS:	DISIN:
::	FUNCTION:	MOVES DATA FROM THE NETWORK INTO THE DISPATCHER
::			RING.
::	CALLING SEQ:	JAL	R10,DISIN  Called from SPIDER.
::		Dispatched based on buffered data requesting output to
::		the Dispatcher.  Yields after processing each requesting
::		port, passes control to next subprocess when no more
::		data is present or there is no room in the Dispatcher
::		bound data ring, or if neither of the two previous
::		events occur within 61 MS.
::
::*********************************************************************

DISIN	HS	0
	ST	R10,DSSVRT		:SAVE RETURN
:	PREVENT HOGGING CPU IN DISPATCHER PROCESS. DIDTIM WILL CONTAIN
:	FASTC TIME TO DISMISS BACK TO SPIDER EVEN IF WORK TO DO.
	L	R0,FASTC,,
	AHI	R0,TICDSI		:Run for only as long as assigned##sdw
XICDSI  EQ      .-2                     :able to change tics from xray symbol
        SYAD(XICDSI)                    :table
	ST	R0,DIDTIM
        lhi     r0,dis.hw*8-1           :number of chns to search
        sth     r0,ds.chn

:	RETURN HERE AFTER SERVICING EACH CHANNEL, AND YIELD EITHER IF
:	HIGHER PRIORITY TASK HAS BEEN SCHEDULED, OR IF OUR TIME SLICE IS UP.

DSINXT	HS	0
:       Don't yield to EXEC, this is a high priority process and the only
:       job which is important enough to interupt us is bufzap, but since
:       DISIN empties buffers of data then have nothing to yield to     ###sdw
	L	R0,DIDTIM		:GET TIME TO DISMISS
	S	R0,FASTC,,		:LATER THAN CURRENT TIME?
	JGFS	DSINX1			:YES - CONTINUE FILLING DISPATCHER RING
	LIS	R0,1			:NO - COUNT NUMBER OF FORCED DISMISSES
	AHM	R0,DIDISM
	J	DSIORT			:..RETURN

DSINX1
	LHI	TC,DRSZ-1
	LH	PRD,DRIF,,		:COMPUTE ROOM AVAILABLE
	LH	PRC,DRIE,,
	SR	PRC,PRD			:DRIE - DRIF
	JGFS	DISI05			:NO RING WRAP
	AI	PRC,DRSZ		:RING WRAP
:       minimum size is big enough so that don't have to worry about wrapping
:       ring when handling a port's signals and data.  Also, due to XICDSI if
:       the ring is nearly full then something else is broken and dispatcher
:       buffering is a real risk.
DISI05	CLHI	PRC,100			:MINIMUM ROOM CONSIDERED
	JLE	DSIORT			:PRC = no room available

:	LOCATE PORTS WITH INBOUND DATA

dis.hw  eq      (ndp+0f)/10*2           :number of HWs*2 for disp bit arrays

DISI10  lhl     r5,ds.chn               :get next chn to service
        ohi     r5,0f                   :round up to next hw
        lr      r1,r5
        srls    r1,3                    :make it into hw
        la      r3,dissvd-1,r1          :address to start searching
        la      r4,disflg-1,r1,         :ports with data
        arand   r3,r5                   :quickly search for both set
        kill    disi12
        jfs     disi12                  :got one
        la      r0,disbpv+dis.hw-2      :last HW of BPed arrays
        la      r1,dissvd+dis.hw-2      :last HW of service array
        lhi     r2,dis.hw*8-10          :number of bits - 10 to copy
        copy    r0,r2                   :move bits quickly
        jfs     dsiort                  :none, exit
disi12  j       disi42                  :service port
:	HERE TO RETURN MAIN
DSIORT  LHL     R3,DRIF,,               :gather some statistics
        SH      R3,DRIE,,               :how much in RING
        JGEFS   DSIOR1
        AI      R3,DRSZ
DSIOR1  CH      R3,DISICP               :new max amoung in ring
        JLEFS   DSIOR2
        STH     R3,DISICP               :
DSIOR2  SRHL    R3,DSCALE               :make histogram entry
        NHI     R3,3C                   :keep it in range
        LIS     R0,1
        AM      R0,DSIHGM,R3
        JGEFS   DSIOR5                  :zero all when use 32nd bit
        LIS     R0,0
        LHI     R1,3C                   :zero all entries
DSIOR3  ST      R0,DSIHGM,R1,
        SIS     R1,4                    :clear histogram
        JGEBS   DSIOR3
DSIOR5	L	R10,DSSVRT	
	JR	R10

:	THIS IS THE MAIN WORK LOOP-- MOVE DATA FROM BUFFERLETS INTO RING
:	FOR THE PORTS MARKED IN R1'S BIT ARRAY.
DISI42	RBT	CHN,DISSVD		:THIS PORT SERVICED
        sth     chn,ds.chn              :for a quck dsinxt logic
	LHL	R2,DIOTAB,CHN,CHN	:IOTAB ENTRY (OUTBOUND BUFF #)
	NHI	R2,-4			:STRIP GOUGING BITS FROM BUFFER NUMBER
	JNFS	DISI50
	CRASH.(.DISI0)			:DISPI FOUND NO DISPATCHER CIRCUIT
	J	DISI10			:GO TO SEE NEXT PORT

DISI50	XHI	R2,4			:SWITCH TO DISPI INBOUND BUFFER #
:       fix the bug of shortening records by 1 byte per escape.         ###sdw
:       And setup easier since don't have to calculate buffer size
	L	R3,BCT,R2,	 	:make sure data is in buffer
        JE      DISI10                  :gateway kludge 0264 crash fix
        LHL     LRC,DIXLIM,CHN,CHN     :transmit limit
        sth     lrc,dixlft              :for multiple messages
disi44                                  :for multiple messages entry
        lis     tyc,7                   :in case killed (like in accounting)
        STH     CHN,DIRNG,PRD,
        STH     PRD,RPSAV               :write chn and where it to put len
        AIS     PRD,3
        LA      R8,DISI61               :to return bufferlet
        JFS     DISI51

:       secondary jump, to make all jumps in work loop a short form jump
DISI53  J       DSITYM                  :handle escapes and such

:       continue final setup
DISI51  LR      CD,LRC

:       the main work loop
DISI60	HC	3812			:GCI R1,R2
        HC      BE-BB                   :size of BB
        HC      GCIERR-DISI60           :error
        GL      GCIERR
        HC      BB/4                    :address of BB
        HC      GCRET-DISI60            :to return a buffler
        HC      DISI64-DISI60           :last char
DISI61  CR      R1,TYC                  :escaped char?
        JLEBS   DISI53                  :yes handle signal & escapes
DISI70  STB     R1,DIRNG,PRD,           :put char into ring
        AIS     PRD,1
        NR      PRD,TC                  :bump up ring pointer
        SIS     CD,1
        JGBS    DISI60                  :get another char
        JFS     DISI66                  :done

:       emptied bufferlets of all data
DISI64  JAL     R8,GCLAST               :return last bufferlet
        CR      R1,TYC                  :control char?
        JLE     DSITYM
DISI67  STB     R1,DIRNG,PRD,           :store char (when last char)
        AIS     PRD,1                   :bump up ring (range check next)
        SIS     CD,1                    :did move a char

DISI66  SR      LRC,CD                  :for how many chars read
                                        :and done

disi79  la      r7,dsinxt               :for done data return to dsinxt
:       DISI80  is used to finish off any variable len msg with byte len


DISI80	LHL	R1,RPSAV		:GET POINTER TO BYTE CNT (TYPE)
	STB	LRC,DIRNG+2,R1,		:THE COUNT IS THE TYPE IF A DATA MSG
      IF        ACCT                    :do accounting
        TBT     CHN,GORGPT              :origination port?
        JN      DISI88                  :return to normal handling
        LR      R0,LRC                  :get count of chars moved
        LHI     R3,DISZFL-MNACHN,CHN    :get relative accounting port
        GL      AARDIC
        JAL     R8,AARDIC,,             :count the chars
       EI       :ACCT                   :and done
:       identical as disi90 (for closing off messages) but this is an end of
:       a data messages reached by either running out of data or transmit.
:       thus, no reason to check to see if can put another message or fiddle
:       with running transmit limit.                                    ###sdw
:       in other words, a whole lot more efficient than DMM.SW as proposed.
DISI88	AM	LRC,DISICC		:CHARS INTO DISPATCHER
	AIS	PRD,3			:ROUND OFF POINTER
	NHI	PRD,DRSZ-4
	STH	PRD,DRIF,,
        jr      r7                      :and exit

DISI90	AM	LRC,DISICC		:CHARS INTO DISPATCHER
	AIS	PRD,3			:ROUND OFF POINTER
	NHI	PRD,DRSZ-4
	STH	PRD,DRIF,,
:       here to see if another message to follow the signal
        lhl     r2,dsi.r2               :restore R2 (maybe clobbered)
        lhl     r0,bct,r2,              :anything to send?
        je      dsinxt                  :nope, try next port
        lh      lrc,dixlft
        sis     lrc,8                   :signals don't tell size so guess size
        jle     dsinxt
        sth     lrc,dixlft              :remaining xmit
        lh      r1,drie,,
        sr      r1,prd
        jgefs   disi97
        ai      r1,drsz
disi97
        shi     r1,100
        jge     disi44                  :put another message
        j       dsiort                  :and done with input for now

::*********************************************************************
::
::	SUBROUTINE:	DSITYM:
::	FUNCTION:	HANDLE NETWORK CONTROL CHAR PAIRS
::
::*********************************************************************

DSITYM	lr      r1,r1                   :escape char?
	JNFS	DSITY1			:BRANCH IF NOT
:	GOT ESCAPE CHAR.
	JAL	R8,GCI			:GET ESCAPED CHAR
        LA      R8,DISI61               :restore release bufferlets reg
        LHL     R0,BCT,R2,              :see if any chars left
        JN      DISI70                  :reenter in the loop
        J       DISI67                  :put char and finish

:	OTHER CONTROL CHAR.
DSITY1	sth     r2,dsi.r2               :save r2 for disi90
	SR	LRC,CD			:OTHER CONTROL -  END CURRENT RECORD
	JE	DSITY2			:NO RECORD HAS BEEN STARTED
        lh      r0,dixlft               :room for multiple messages
        sr      r0,lrc
        jgfs    dsity4                  :there is room
dsity3  jal     r8,wcd
        j       disi79                  :and exit
:       here for signal following a data message and have xmit license to
:       send it.
dsity4  sth     r0,dixlft               :and save remaining xmit
	lr      r6,r1                   :save signal for a moment
        jal     r7,disi80               :close off data message
        lr      r1,r6                   :restore signal
        sth     chn,dirng,prd,          :set up for signal message
        sth     prd,rpsav
        ais     prd,3

:	DISPATCH ON CONTROL  CHARACTER CODE
DSITY2	SLLS	R1,2			:FW indexing			###wjl
	L	R1,DSITAB,R1,		:				###wjl
	JR	R1			:				###wjl


::*********************************************************************
::
::	SUBROUTINE:	DSITII:
::	FUNCTION:	HANDLE 03 CONTROL PAIRS
::
::*********************************************************************

DSITII	JAL	R8,GCI			:T-II CONTROL, GET NEXT CHR
	CLHI	R1,DSPMAX		:check range
	JGE	DSINXT			:ignore if too high
	SLLS	R1,2			:FW indexing			###wjl
	L	R8,DSPTBL,R1,		:get dispatch value		###wjl
	JR	R8			:and jump to handler		###wjl

::*********************************************************************
::
::	DSPTBL:	DISPATCH TABLE FOR 03 PAIR	
::
::*********************************************************************

DSPTBL	WC	DSINXT		:0300 unknown 03-pair
	WC	DSIZAP		:0301 hard zapper
	WC	DSIZAP		:0302 soft zapper
	WC	DSINGZ		:0303 non-gobbling zapper 		###wjl
	WC	DSIZAP		:0304 fat zapper
	WC	DSINXT		:0305
	WC	DSINXT		:0306
	WC	DSINXT		:0307
	WC	DSIGOB		:0308 GOBBLER
	WC	DSINXT		:0309
	WC	DSINXT		:030A
	WC	DSINXT		:030B
	WC	DSINXT		:030C
	WC	DSINXT		:030D
	WC	DSINXT		:030E
	WC	DSINXT		:030F
      IF	T2GATE		:Gateway has several variations
	WC	DSINXT		:Gateway Needle handler	###EV
	WC	DSINXT		:Successful circuit request for Gateway
	WC	DSITIL		:0312 used for Gateway only  for B8 translation
	WC	DSINXT		:0313 Not used for Gateway
      ELSE	:NOT GATEWAY
	WC	DSINDP		:0310 NEEDLE POINT
	WC	DSINDY		:0311 NEEDLE EYE
	WC	DSITIL		:0312 message for terminal in login mode
	WC	DSILRR		:0313 error in circuit request
      EI	:T2GATE
      IF	LOGII		:several new routines
        WC      DSINXT		:0314 COMET (not used)
        WC      RCRI		:0315 SUPE generated RCRI
        WC      RCRINC		:0316 NC generated RCRI
        WC      LGSC		:0317 Logon Success (LOG II needle eye)
      IF	T2GATE          :gateway doesn't worry about converted needles
        WC      DSINXT		:0318
        GL      RCRINC,LGSC,RCRI :gateway has these in different module
      ELSE	:not T2GATE (node code)
        WC      ISNCVN		:0318 Log I to be delivered as LOG II needle
      EI	:T2GATE
        WC      DSINXT		:0319
        WC      DSINXT		:031A
        WC      DSINXT		:031B
        WC      DSINXT		:031C
        WC      DSINXT		:031D
        WC      DSINXT		:031E
        WC      DSINXT		:031F
        WC      DSINXT		:0320
        WC      DSINXT		:0321
        WC      DSINXT		:0322
        WC      DSINXT		:0323
        WC      DSINXT		:0324
        WC      DSINXT		:0325
        WC      DSINXT		:0326
        WC      DSINXT		:0327
        WC      DSINXT		:0328
      IF	T2GATE          :gateway only does needle bodies
        WC      DSINXT		:0329 LOG II needle head is ignored (gateway)
        WC      GDBODY		:032A LOGII needle body
        GL      GDBODY
      ELSE	:not T2GATE (node code)
        WC      ISN	        :0329 Log II needle
      EI	:T2GATE
      EI	:LOGII
DSPMAX	EQ	(.-DSPTBL)/4

::*********************************************************************
::
::	TABLE:		B4CODE:
::	FUNCTION:
::		TABLE TRANSLATES SUP CODES FOR TALKING TO TERMINAL
::		IN LOGIN MODE INTO ISIS CODES FOR B4 MESSAGE.  
::
::		SUP MSG 0D --> NODE CODE MSG 0312 --> ISIS MSG B4xx
::
::		SUP CODES START WITH 8. SUP CODES 11 AND 12 TRANSLATE
::		TO HANG (B8) AND SUPER-HANG (AF).  SUP CODES E, F, AND 10
::		ARE NOT USED (A 10 CODE IS CONVERTED TO 8 IN LEP).
::
::*********************************************************************
	IF	T2GATE
B4CODE	HC	0B400,0B401,0B402,0B403,0B404,0B405,0,0,0,09E00,0B800
	HC	0B408,0B409,0B40A,0B40B,0B40C,0B40D,0B40E,0B40F,0B410
	HC	0B411,0B412,0B413
	ELSE
B4CODE	HC	0B400,0B401,0B402,0B403,0B404,0B405,0,0,0,0AF00,0B800
	HC	0B408,0B409,0B40A,0B40B,0B40C,0B40D,0B40E,0B40F,0B410
	HC	0B411,0B412,0B413
	EI	:T2GATE

::*********************************************************************
::
::	SUBROUTINE:	DSITIL:
::	FUNCTION:	0312 - MESSAGE FOR TERMINAL IN LOGIN MODE.
::				---> ISIS MSG B4
::*********************************************************************

DSITIL	HS	0
	JAL	R8,GCI			:CODE BYTE
	LR	R7,R1			:SAVE IT
	NHI	R1,0E0			:ISOLATE SPECIAL BITS
	NHI	R7,1F			:ISOLATE CODE
	SIS	R7,8			:SUP CODES BEGIN WITH 8
	LHL	R7,B4CODE,R7,R7		:TRANSLATE FOR ISIS
	OR	R1,R7			:BLEND SPECIAL BITS BACK IN
	STH	R1,DIRNG-1,PRD,
	J	DISI90

	IF	1-T2GATE		:Gateway does not use the following
::*********************************************************************
::
::	SUBROUTINE:	DSINDP:
::	FUNCTION:	0310 - NEEDLE POINT
::
::*********************************************************************

DSINDP	HS	0
	LHL	R0,HNPORT		:INCREMENT NUMBER OF HOST PORTS IN USE
	AIS	R0,1
	CLH	R0,MXPORT		:IS THIS A NEW PEAK?
	JLEFS	DISNDX			:NO
	STH	R0,MXPORT		:YES, RECORD IT
DISNDX	STH	R0,HNPORT
	JAL	R8,NEDTIM,,		:COMPUTE NEEDLE TIME,
					: RECORD NEW CIRCUIT TIME
	LHI	R0,28
	JAL	R8,DIROOM		:SEE IF 28 BYTES AVAILABLE IN RING
	STH	CHN,DSICHN		:SAVE NEW NEEDLE CHN NUMBER
	LIS	R1,0			:SEND A TYPE '0'
	STB	R1,DIRNG-1,PRD,
	AIS	PRD,1			:SKIP ONE BYTE FOR LENGTH
	NR	PRD,TC			:WRAP RING POINTER IF NECESSARY
	JAL	R9,GCIE
	GL	GCIE
	JAL	R9,GCIE			:DISCARD BYTE AND LINK CNTS
	JAL	R9,GHWI
	STH	R1,DIRNG,PRD,		:INVOICE # (ONE WORD LONG)
	JAL	R9,GHWI
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	JAL	R9,GHWI			:SAVE NEEDLE FLAGS
	STH	R1,DSINFL
	JAL	R9,GHWI			:SAVE CICUIT ORIGINATING NODE
	STH	R1,DSINOD
	JAL	R9,GHWI			:AND ORIGINATING PORT #
	STH	R1,DSIPRT
DSIND5	JAL	R9,GHWI			:SLEW OVER 'CREAMED' STUFF
	CI	R1,0FFFF
	JEBS	DSIND5			:.-0A
	NHI	R1,7FFF
	STH	R1,DIRNG,PRD,		:THIS IS DESTINATION HOST #
:	SAVE DESTINATION HOST FOR THIS CIRCUIT (CHN)
	STH	R1,DHSTIX,CHN,CHN	:SAVE FOR TRACE
	JAL	R8,GCI			:TID
	LR	R5,R1			:MUST HOLD IT

	JAL	R9,GCIE			:GET FIRST BYTE AFTER TID AND
	LR	R6,R1			: SAVE IT
	JAL	R9,GHWI			:GET NEXT 2 BYTES
:       deleted code for old supe which is older than 1983 and is no more##sdw
	STH	R1,DSIHST		:SAVE ORIGINATING HOST NUMBER

	LHL	R1,DSINOD		:ORIGIN NODE
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	LHL	R0,DSIPRT		:ORIGIN PORT
	NHI	R0,7FFF			:STRIP HOB,JUST IN CASE,T-I FOR EXAMPLE
	CLHI	R1,MACHNM		:SET HI-ORD BIT IF INTERNAL CIRC
	JNFS	DSIND3
	CLHI	R0,DISZFL
	JLFS	DSIND3
	CLHI	R0,DISZFL+NDP
	JGEFS	DSIND3
	AHI	R0,8000-DISZFL		:IT IS INTERNAL CIRC, SET HI-ORD BIT
DSIND3	STH	R0,DIRNG+2,PRD, 	:ORIGINATING PORT NUMBER
	LHL	R0,DSIHST
	NHI	R0,7FFF			:STRIP HIGH-ORDER BIT		###GT
	STH	R0,DIRNG,PRD,		:CIRCUIT ORIGIN HOST NUMBER
	AIS	PRD,4
	NR	PRD,TC
	LIS	R0,0
	STH	R0,DIRNG,PRD,		:NEXT TWO BYTES UNUSED
	LHL	R1,DSINFL		:GET NEEDLE FLAGS AND
	NHI	R1,30			: ISOLATE GOUGING BITS
	SRLS	R1,4			:RIGHT-JUSTIFY GOUGING BITS AND
	OHI	R1,80			: OR WITH 80 TO INDICATE FIELD PRESENT
	STH	R1,DIRNG+2,PRD,		:STORE CIRCUIT GOUGING LEVEL
					: (THROUGHPUT CLASS)
	AIS	PRD,4
	NR	PRD,TC

:	TEST NEEDLE FLAGS TO SEE IF DESTINATION HOST IS 'SMART'. IF NF.SMC
:	BIT IN NEEDLE FLAGS IS SET, TURN ON HIGH-ORDER BIT OF DIALECT CODE FOR
:	SLOT.
	IF	MXPNM			:ISIS-MXP EXPECTS A NODE #IN THIS ###GT
	LHI	R0,MACHNM		:FIELD + 'I' BIT		###GT
	LHL	R1,DSINFL		:GET NEEDLE FLAGS		###GT
	THI	R1,NF.SMC		:SMART CIRCUIT?			###GT
	JEFS	DSND30			:NO, DUMB HOST OR NOT REQUESTED	###GT
	OHI	R0,8000			:INDICATE HIQ HOST		###GT
	ELSE				:NON-MXP			###GT
	LHL	R1,DSINFL		:GET NEEDLE FLAGS
	THI	R1,NF.SMC		:SMART CIRCUIT?
	JEFS	DSND30			:NO - DUMB HOST OR NOT REQUESTED...
	LHI	R0,8000			:INDICATE HIQ HOST
	EI	:MXPNM							###GT
DSND30	STH	R0,DIRNG,PRD,		:FORMERLY DIALECT CODE,
					: INDICATE HIQ HOST
	STB	R5,DIRNG+2,PRD,		:TID

	LR	R5,PRD			:SAVE THIS
	AIS	PRD,4
	NR	PRD,TC			:POINTS TO START OF USER NAME
	TS	DSITLG			:POSITIVE IF TRANSPARENT LOGIN
					: (ASSUME NOT)

	LIS	LRC,0			:COMPUTE LENGTH OF USER NAME
	JAL	R8,GCI			:GET 1ST CHAR (MIGHT BE "?" FOR
	CLHI	R1,0BF			: TRANSPARENT LOGIN)
	JN	DSIND4			:NOT A "?", SKIP IT
	STB	R1,DIRNG,PRD,		:SAVE THE "?"
	STH	R1,DSITLG		:FLAG AS TRANSPARENT LOGIN

	LHL	R1,DSINFL		:GET NEEDLE FLAGS AND
	SRLS	R1,4			: ISOLATE CIRCUIT SPEED BITS
	NHI	R1,3			: (ALSO KNOWN AS GOUGING BITS)
	AHI	R1,81			: CONVERT TO CTRL-A -> CTRL-D
	AIS	PRD,1			:BUMP RING POINTER
	NR	PRD,TC
	AIS	LRC,1			:INCLUDE GOUGING CHAR WE'RE INSERTING
	JFS	DSIND4
DSIND1	JAL	R8,GCI
DSIND4	AIS	LRC,1
	STB	R1,DIRNG,PRD,
	AIS	PRD,1
	NR	PRD,TC
	CLHI	R1,80!ASCSMC		:TERMINATOR? ASCII SEMI-COLON 0BB
	JEFS	DSIND2
	CLHI	R1,80!ASCCR		:TERMINATOR? ASCII CARRIAGE RETURN 8D
	JNBS	DSIND1
DSIND2	LR	R1,PRD
	SR	R1,R5			:LENGTH OF USER NAME
	SIS	R1,4
	NR 	R1,TC
	STB	R1,DIRNG+3,R5,		:SIZE OF USERNAME

:	IF THE SUPERVISOR SENDS AN ODD-LENGTH USER NAME, IT WILL PAD THE
:	USER NAME WITH AN ESCAPE CHARACTER FOR EVEN HALFWORD
:	ALIGNMENT. WE MUST STRIP THE ESCAPE CHARACTER FROM THE USER
:	NAME, IF PRESENT, BEFORE PASSING IT TO THE SLOT. IF THE LOGIN
:	IS TRANSPARENT, WE INSERTED A CHARACTER, AND MUST THEREFORE
:	TEST FOR AN EVEN LENGTH USER NAME INSTEAD OF ODD.
	TS	DSITLG			:IS THIS A TRANSPARENT LOGIN?
	JGFS	DIES10			:YES - EVEN LENGTH NEEDS ESCAPE REMOVED
	THI	R1,1			:NORMAL LOGIN - ODD LENGTH USER NAME?
	JE	DIESCX			:NO, EVEN LENGTH, NO ESCAPE REMOVAL
	JFS	DIES20			:YES - TOSS ESCAPE

DIES10	THI	R1,1			:TRANSPARENT LOGIN
					: - EVEN LENGTH USER NAME?
	JNFS	DIESCX			:NO - ESCAPE REMOVAL NOT REQUIRED

:	REMOVE ESCAPE FROM USER NAME
DIES20	LH	R0,BCT,R2,		:EXTRA CARE, NO
	JEFS	DIESCX			: GCI CRASH
	JAL	R8,GCI
	LR	R1,R1			:ESCAPED ESCAPE?
	JNFS	DIESCX			:NO
	JAL	R8,GCI

DIESCX	LHL	R5,RPSAV		:POINTS TO START OF MESSAGE
	LHI	LRC,-1,PRD
	NHI	LRC,DRSZ-4
	SR	LRC,R5
	NR	LRC,TC
	STB	LRC,DIRNG+3,R5,		:LENGTH
	AIS	PRD,3
	NHI	PRD,DRSZ-4
	LHL	CHN,DSICHN		:NEW NEEDLE CHN NUMBER
        RBT     CHN,DISBPX              :send BP relief to port
	JAL	R9,DIXCAP		:GIVE IT XMIT CAPACITY
	J	DISI90

::*********************************************************************
::
::	SUBROUTINE:	DSINDY:
::	FUNCTION:	0311  - NEEDLE EYE	---> ISIS MSG B6
::
::	NEEDLE EYE RECEIVED FROM LEP, INFORM REQUESTING SLOT THAT CIRCUIT
::	IS COMPLETE. SEND 0B6x0 MESSAGE IF NOT SMART CIRCUIT, ELSE 0B6x1. IF
::	THIS IS INTERNAL CIRCUIT, x IS 8 - OTHERWISE, x IS 0.
::
::*********************************************************************

DSINDY	HS	0
	JAL	R9,GHWI			:GET NEEDLE FLAGS
	LIS	R9,0
	LHR	R1,R1			:NEGATIVE IF NOT INTERNAL CIRCUIT
	JLFS	DSNY04
	AHI	R9,80			:INDICATE INTERNAL CIRC TO DISPATCHER
DSNY04	THI	R1,NF.SMC		:SMART CIRCUIT?
	JEFS	DSNY10			:NO
	AIS	R9,1			:YES - 0B6x1 BACK TO SLOT
DSNY10	LR	R6,R1			:SAVE NEEDLE FLAGS
	LHI	R1,0B600,R9
	STH	R1,DIRNG-1,PRD,		:'B6' + IIX, INTERNAL CIRC INDICATIONS
	IF	EXPNDL
	LI	R1,DIRNG-1,PRD		:save pointer in case IIX SNI in list
	ST	R1,SNFGSV,,
	EI	:EXPNDL
	AIS	PRD,1
	NR	PRD,TC			:FOLLOW W/ INVOICE #
	JAL	R9,GHWI
	STH	R1,DIRNG,PRD,
	JAL	R9,GHWI
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4			:advance ring ptr one word
	NR	PRD,TC
	LIS	R0,0
	ST	R0,DIRNG,PRD,		:ORIGIN HOST #
	AIS	PRD,4			:advance ring ptr another word
	NR	PRD,TC
	LR	R1,R6			:GET NEEDLE FLAGS BACK
	SRLS	R1,4			: AND ISOLATE SPEED BITS
	NHI	R1,3
	JAL	R9,DIXCAB		:GO TELL SLOT BACKPRESSURE LIMIT
					: (B9 msg)
	IF	EXPNDL
	THI	R6,NF.SNI		:does SNI list follow?
	JE	DSNY20
:	prepare to process SNI list
DSNY24	JAL	R8,GCI			:get SNI header
	LR	R8,R1			:get copy to destroy safely
	NHI	R8,0FF-SNITYP		:dispatch on high order six bits
	CLHI	R8,SNITRM		:end of list?
	JE	DSNY20			:yes--exit loop
	CLHI	R8,SNINOP
	JE	DSNY24			:NOP--get next list entry
	CLHI	R8,SNIMXS		:range check--too high?
	JGEFS	SNRSVD			:crash
:	list entry OK.  Go do it to it.
	L	R8,SNIDTB,R8		:dispatch entry
	JR	R8

SNRSVD	HS	0
	CRASH.(.SNICR)			:bad SNI received--crash

SNYUUN	HS	0			:send a 0C1 message to slot
	LR	R8,R1			:copy SNI header again
	NHI	R8,SNITYP		:R8 has message type (length indicator)
	CLHI	R8,SNTYP3		:UUN supports types 0,1,2 only
	JE	SNRSVD			:invalid type
	STH	CHN,DIRNG,PRD,		:insert port number in ring
	LHI	R1,UNUSNO		:message 0C100
	STH	R1,DIRNG+2,PRD,		:insert message indicator in ring
	AIS	PRD,4			:advance ring pointer one word
	NR	PRD,TC
:	this must be general enough to send slot a fullword
:	regardless of of length of UUN field from supervisor.
	LIS	R1,2			:number HW's of zeroes--2 HW's together
	SR	R1,R8			:for counting padding
	LR	R8,R1			:R8 now has (2 - type)
	JE	SYUU10			:type 2--read 2 HW's of UUN
	LIS	R1,0			:type 0 or 1 requires some 0-padding
	STH	R1,DIRNG,PRD,		:zero into slot
	SIS	R1,1			:was it type 0 or type 1?
	JEFS	SYUU20			:branch if type 1--have HW of UUN
	STH	R1,DIRNG+2,PRD,		:type 0--send UUN of zero
	AIS	PRD,4			:advance ring ptr one word
	NR	PRD,TC			:mask for wrap
	J	DSNY24			:and return for next SNI header
SYUU10	JAL	R9,GHWI			:type 2--get first HW of UUN
	STH	R1,DIRNG,PRD,		:and write to the slot
SYUU20	JAL	R9,GHWI			:get second HW of UUN
	STH	R1,DIRNG+2,PRD,		:and write to the slot
	AIS	PRD,4			:advance ptr one word
	NR	PRD,TC			:mask for wrap
	J	DSNY24			:return for next SNI header

SNYPRX	HS	0			:not supported yet
SNYLGC	HS	0			:to-sup only
SNYOHS	HS	0			:to-sup only
	J	SNRSVD			:crash

:	IIX indication could be sent either by means of this SNI
:	or in the old method of using the needle flags
SNYIIX	HS	0
	L	R1,SNFGSV,,		:points to B6-entry in ring
	LHL	R8,0,R1,
	OHI	R8,1			:set the IIX bit
	STH	R8,0,R1,
	J	DSNY24

::*********************************************************************
::
::	SNIDTB:	SNI Dispatch Table
::
::*********************************************************************

SNIDTB	WS	0		:###wjl
	WC	SNRSVD		:00--reserved
	WC	SNRSVD		:04--reserved
	WC	SNYUUN		:08--UUN
	WC	SNYPRX		:0C--proxy login token
	WC	SNYOHS		:10--origin host
	WC	SNYIIX		:14--IIX dialect
	WC	SNYLGC		:18--login characters
SNIMXS	EQ	.-SNIDTB	:maximum valid value

DSNY20	EI	:EXPNDL
	XHI	R2,4			:ENABLE NEEDLE TO TRAVEL
	JAL	R9,CRQALT,,		: BY ALERTING CRQ
	J	DISI90

::*********************************************************************
::
::	SUBROUTINE:	DSILRR
::	FUNCTION:	0313 - LOGIN ERROR
::			NODE CODE MSG 0313 ---> ISIS MSG   B5
::
::*********************************************************************

DSILRR	SIS	PRD,3			:LOGON FAILURE, SEND 'B5' MSG TO SLOT
	LHI	R1,0B500
	STH	R1,DIRNG+2,PRD,
	JAL	R8,GCI			:GET ERROR CODE
	NHI 	R1,ASC7BT		:STRIP OFF THE HOB (SET BY SUPERVISOR)
	STB	R1,DIRNG+3,PRD,		:AND MOVE INTO RING
	AIS	PRD,4
	NR	PRD,TC
	STH	CHN,DIRNG,PRD,		:FOLLOW WITH ZAPPER
	LHI	R1,09F00
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	SBT	CHN,DISZNK		:AWAITING ZAPPER ACK
	J	DISI90

        SUBTTL	DISPI (DISIN - RCRI Log II response to terminal in logon mode)

::*************************************************************
:
:       RCRI    writes logon response to dispatcher.  Have to remove
:       (0316)  our orig port, change ID and flagsID, and see if supe
:               sent MO saying this is end of logon session.
:
::*************************************************************

       IF       LOGII

RCRI    SIS     PRD,1                   :given PRD of odd byte
        LHI     R1,DM.RCR^8             :isis msg type C3 is RCRI
        STH     R1,DIRNG,PRD,
        AIS     PRD,2
        NR      PRD,TC
        JAL     R9,GHWI                 :get length of MOs
        LR      PRC,R1                  :save it so we know when to end
        STH     PRD,RPSAV               :save where to write len
        LIS     LRC,0                   :start off with none written
        AIS     PRD,2
        LR      R0,PRC
        JAL     R8,DIROOM               :make sure enough room

        JAL     R8,X4CRIZ,,             :init table
        GL      X4CRIZ,X4CCID
        LHI     R4,IDRCRI+MO.AC2
        JAL     R8,X4CCID,,
        LHI     R4,RMOID                :rmo
        JAL     R8,X4CCID,,
        L       R3,BB,R2,,              :start of RCRM
        LHI     R4,ID.RMF               :RCRM flags
        JAL     R7,X4PARS,,
        SKIPAD(RCRI10)
        LHI     R4,ID.RIF+MO.A2         :RCRI flags
        JAL     R8,X4CBID,,             :len in r0, data in buffer
        GL      X4CBID
RCRI10  JAL     R8,X4FXCN,,             :finished with RMO
        LHI     R4,ID.SRJ               :supe rejecting it?
        JAL     R7,X4PARC,,             :continue parsing
        GL      X4PARC
        SKIPAD(RCRI15)
        LIS     R0,1
        JFS     RCRI16
RCRI15  LIS     R0,0
RCRI16  STH     R0,ICRMS1               :save whether we are to zap
        LHI     R4,(MO.C^8)+(SMOID&IDBITS)  :the way the table stores a SMOID
        LA      R6,X4TBBG,,             :find SMO element
RCRI20  AHI     R6,X4TBSZ
        CH      R4,X4T.AP,R6
        JNBS    RCRI20
        L       R3,X4T.DB,R6            :address of beginning of data
        LHL     R0,X4T.LN,R6            :len of SMO
        LHI     R4,SMOID
        JAL     R8,X4CBID,,             :put entire smoset into table
        JAL     R8,X4FXCN,,             :finish RCRI constructor
        JAL     R8,X4CDWR,,             :write element to dispatcher
        GL      X4CDWR,X4FXCN
        JAL     R8,CBCLR                :and nothing in the buffer

        LHL     R1,RPSAV
        STH     LRC,DIRNG,R1,           :save len of written MO
        LH      R0,ICRMS1               :are we to zap this guy?
        JE      DISI90                  :no, we are done
        LR      R6,R2                   :this port is to be zapped
        XHI     R6,4
        JAL     R9,LOGCLR               :clear it from logsup buffer
        LHI     R1,ZAPPN                :no gobble zapper
        JAL     R9,ZAPX,,               :and this one is zapped
        GL      LOGCLR,ZAPX
        J       DISI90

       EI       :LOGII

        SUBTTL	DISPI (DISIN - LGSC Log II logon success message)

::****************************************************************
:
:       LGSC    logon successful.  Immediately following the char pair
:       (0317)  is a char to indicate whether this is an internal circuit.
:               After that touch of work, just copy however many bytes
:
::****************************************************************

       IF       LOGII

LGSC    SIS     PRD,1                   :back to the type byte
        LHI     R1,DM.LGS               :msg is a LGSC
        STB     R1,DIRNG,PRD,
        JAL     R9,GCIE                 :indication of LOG II intranode
        LR      R1,R1
        JEFS    LGSC04
        XHI     R2,4                    :internal alerts CRQ of needle after
        JAL     R9,CRQALT,,             :sending LGSC (ISIS dispatcher depends
        XHI     R2,4                    :on receiving LGSC then ISN if internal
        LIS     R1,1                    :only bit set is of internal
LGSC04  STB     R1,DIRNG+1,PRD,
        AIS     PRD,2
        NR      PRD,TC
        LIS     LRC,0                   :start with len of 0
        JAL     R9,GHWI                 :get len of LGSC
        LR      PRC,R1                  :workin copy of len
        STH     R1,DIRNG,PRD,
        AIS     PRD,2
        NR      PRD,TC

LGSC10  JAL     R9,GCIE                 :copy rest of MOs
        JAL     R8,X4DWCH
        SIS     PRC,1
        JGBS    LGSC10

        J       DISI90                  :and exit

       EI       :LOGII

        SUBTTL	DISPI (DISIN - ISN  Log II needles)

::*****************************************************************
::
::       ISNCVN  handle logII converted heads.  It is a LOGI needle body
::       (0318)  which may not all be there.  Make sure it is all there before
::               entering mainline ISN (before go mainline write that this
::               is not an internal needle.
::
::      First have to make sure that len is there, then since the length
::      does not count itself must GHWI len, then do CBCCT to find if all
::      of ISN is there.  Can't change that order!!!
::
::*****************************************************************

       IF       LOGII

ISNCVN  LR      R1,R2                   :have timout on ISN data arriving
        SRLS    R1,1                    :gobbler may prevent ISN from arriving
        L       R0,BUFTIM,R1,           :has slowc (NEDTIM in CRQ)
        AHI     R0,$A60                 :if can't make it in a minute 
        C       R0,SLOWC,,              :then never will
        JGE     ISNCV4                  :don't give up yet
        JAL     R8,CBCLR                :no data to dispatcher
        XHI     R2,4                    :zap back to orig
        JAL     R9,ZAPHRD,,             :clear circuit
        LCS     R0,1
        AHM     R0,HNPORT               :fewer ports in use
        STH     R0,DHSTIX,CHN,CHN       :clear host entry
        J       DSINXT                  :done with this port
ISNCV4  JAL     R8,CBCCT                :ISN arrive yets?
        CLHI    R1,4                    :length arrive?
        JL      ISNCV0                  :no, must wait for len to arrive
      IF        NDREAD&CBZDBG
        STM     R0,REGST
        JAL     R14,NEDDB1,,
        GL      NEDDB1
        LM      R0,REGST
      EI        :NDREAD&CBZDBG

        JAL     R9,GHWI                 :len of body (len not part of body)
        LR      R10,R1                  :save len of ISN
        JAL     R8,CBCCT                :note BCT is changed from above CBCCT
        CR      R1,R10                  :BCT contain whole needle?
        JGE     ISNCV1                  :ISN contents has arrived
:       complete ISN hasnot arrived
        LR      R1,R10                  :got it, now return it
        JAL     R9,WCDE                 :write back len
        EXBR    R1,R1
        JAL     R9,WCDE
        xhi     r2,4                    :flip to link chn's buffer
:       make sure that the reason that the needle didn't arrive was not due
:       backpressure limits.                                            ###sdw
        lhl     r1,bf,r2,               :receiving chn #
        xhi     r2,4                    :restore to Dport buffer
        lis     r0,3
        oh      r0,iotab,r1,r1          :class d
        sth     r0,iotab,r1,r1          :saved
ISNCV0  LHI     R1,NEEDCV
        JAL     R8,WCD                  :so we reenter same place next time
        EXBR    R1,R1
        JAL     R8,WCD
        J       DSINXT                  :nothing written
:       restore the circuit to original tclass.
ISNCV1  xhi     r2,4                    :to link chn buffer
        lhl     r1,bf,r2,
        xhi     r2,4                    :restore to dispi
        lis     r0,3                    :speed bits
        nh      r0,diotab,chn,chn       :the circuit's actual tclass
        or      r0,r2                   :receiving buffer is our buffer
        sth     r0,iotab,r1,r1          :saved
        sis     prd,1                   :existing
        LHI     R1,DM.ISN^8             :ISN and not internal
        STH     R1,DIRNG,PRD,
        AIS     PRD,2
        NR      PRD,TC
        J       ISN030                  :go mainline


::      ISN     takes LOG II needle head and body and sends ISN.  Must
::      (0329)  check needle head if internal to set a bit.  Then eat
::              upto body, get len of body and just copy to ring.

ISN     SIS     PRD,1                   :move back to type
        LHI     R1,DM.ISN^8             :ISN needle msg
        STH     R1,DIRNG,PRD,
        L       R3,BB,R2,               :init for PARSE
        LHI     R4,ID.NCF               :looking for flags
        JAL     R7,X4PARS,,
        SKIPAD(ISN008)
        JAL     R9,PCIE                 :number of unused bits
        JAL     R9,PCIE                 :bit flags
        THI     R1,L2F.IC               :internal?
        JEFS    ISN008
        LIS     R0,1                    :tell ISIS this is an internal
        STB     R0,DIRNG+1,PRD,
ISN008  AIS     PRD,2                   :move pointer to len pos
        NR      PRD,TC
ISN010  JAL     R8,GCI                  :eat needle head
        SIS     R1,3                    :char pair?
        JGBS    ISN010                  :just more of the needle head
        JEFS    ISN014                  :CRQ made sure it is a correct needle
        JAL     R8,GCI                  :get second half of escaped char
        JBS     ISN010                  :

ISN014  JAL     R8,GCI                  :eat 2nd byte of 032A signal
        JAL     R9,GHWI                 :get len
        LR      PRC,R1                  :setup like ISNCVN

:       the needle body logic is the some for natural and converted log ii
:       needles so ISN030 is where the converted needle logic enters
ISN030  STH     PRD,RPSAV               :save where to put len
        LIS     LRC,0                   :init len to 0
        ST      LRC,DIRNG,PRD,          :clear ISIS use HW (and len)
        AIS     PRD,4
        NR      PRD,TC
        AIS     LRC,2                   :the two len bytes don't count as len
        LR      R0,PRC
        JAL     R8,DIROOM               :make sure enough for ISN
ISN040  JAL     R8,GCI                  :PRC is phys len go must do phys get
        CLHI    R1,3                    :network control pair?
        JLEFS   ISN044
ISN042  JAL     R8,X4DWCH               :write char to dispatcher ring
        SIS     PRC,1                   :one fewer byte in buffer
        JGBS    ISN040
        J       ISNEXI

ISN044  LR      R1,R1                   :an escape?
        JNFS    ISN048
        JAL     R8,GCI
        SIS     PRC,1                   :escaped char took 2 bytes in buffer
        JBS     ISN042                  :get the escaped char

ISN048  CLHI    R1,3                    :did a zapper catch the needle?
        JN      ISN060                  :no, but something else did
        JAL     R8,GCI                  :what type of 03 char?
        CLHI    R1,ZAPPN%0FF            :zapper type?
        JG      ISN060                  :no, so zap
        JAL     R9,ZAPV,,               :zap 2nd half of circuit
        J       DSINXT                  :had nothing to put in dispatcher

ISN060  JAL     R8,CBCLR                :remove any data so nothing gets
                                        :written to dispatcher since no needle
        XHI     R2,4                    :and zap the circuit
        JAL     R9,ZAPHRD,,
        J       DSINXT                  :and no dispatcher message

ISNEXI  LHL     R1,RPSAV                :where to write len
        STH     LRC,DIRNG,R1,           :write len
        RBT     CHN,DISBPX              :cause DISBPS to send BP relief
        AIS     PRD,3
        NHI     PRD,DRSZ-4              :end of this message
        JAL     R9,DIXCAP               :give it transmit capability
        J       DISI90

       EI       :LOGII

        SUBTTL	(DISPI) -DISIN - RCRINC Node Code generated Log2 Logon Failures

::*****************************************************************
::
::      RCRINC  Node code generated rejects to Log2 logons
::              (0315)
::
::*****************************************************************

       IF       LOGII

RCRINC  JAL     R8,GCI                  :get reject reason
        LR      R6,R1
        LHI     R0,4+16                 :RCRI followed by zap
        JAL     R8,DIROOM               :make sure room for detach
        SIS     PRD,1                   :back to type byte
        LHI     R1,ISRCRI^8             :type C3 in high byte
        STH     R1,DIRNG,PRD,           :RCRI
        AIS     PRD,2
        NR      PRD,TC
        LIS     R1,0
        JFS     ICRSN2
ICRSN1  AIS     PRD,1
        NR      PRD,TC                  :copy RCRI to buff
ICRSN2  LB      R0,ICRSRM,R1
        STB     R0,DIRNG,PRD,           :copy canned RCRI
        AIS     R1,1
        CLHI    R1,ICRSRZ               :finished with canned part?
        JLEBS   ICRSN1
        STB     R6,DIRNG,PRD,           :last byte is for the reason
        AIS     PRD,3                   :now put detach
        NHI     PRD,DRSZ-4              :put on proper boundary
        STH     CHN,DIRNG,PRD,          :write zap
        LHI     R1,ISDTCH^8             :and detach circuit
        STH     R1,DIRNG+2,PRD,
        AIS     PRD,4
        LHI     LRC,ICRSRZ+4            :how many chars moved
        JAL     R8,CBCLR                :nothing else to Dispi
        RBT     CHN,DISBPV
        XHI     R2,4
        JAL     R8,CBCLR
        LIS     R1,3                    :write zap towards logger
        JAL     R8,WCI
        LIS     R1,1
        JAL     R8,WCI
        SBT     CHN,DISZNK              :and expect zap ack
        J       DISI90                  :completed reject

ICRSRM  BC      00,10,7F,32,0D,30,05,5F :RCRI ID, len, RMO id, len
        BC      3E,02,07,00,31,04,5F,24,01 :RCRI flags, SMOseq id,len
                                        :and reject value will follow
ICRSRZ  EQ      .-ICRSRM                :size of msg

       EI       :LOGII

	EI	:1-T2GATE		:End of Gateway non-use section

	SUBTTL	DISPI (DISIN - Move data into Dispatcher form Network)

::*********************************************************************
::
::	SUBROUTINE:	DSINGZ:
::	FUNCTION:	0303 - NON-GOBBLING ZAPPER
::
::*********************************************************************

DSINGZ	HS	0
	IF	IDTACH				:ISIS Detach		###wjl
	SBT	CHN,DISZNK		:Indicates waiting for Zap Ack
	LHI	R1,ISDTCH		:Put Detach (9E) into ring
	J	DSIMES
	EI	:IDTACH			:else fall thru to Zap		###wjl

::*********************************************************************
::
::	SUBROUTINE:	DSIZAP
::	FUNCTION:	0301 - HARD ZAPPER
::			0302 - SOFT ZAPPER
::			0304 - FAT ZAPPER
::
::*********************************************************************

DSIZAP	SBT	CHN,DISZNK		:INDICATES WE'RE AWAITING ZAP ACK
	IF	T2GATE
	RBT	CHN,DISFLG		:Kludge fix for 3E63 crash (testing)
	EI	:T2GATE
	LHI	R1,ISZAPR		:PUT ZAPPER (09F) IN RING
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIGOB:
::	FUNCTION:	0308 - GOBBLER
::			NODE CODE MSG 0308 ---> ISIS MSG  0A2
::
::*********************************************************************

DSIGOB	LHI	R1,ISGBLR		:GOBBLER 0A2
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIRBL:
::	FUNCTION:	06 - RED BALL
::			NODE CODE MSG 06 ---> ISIS MSG 0AA
::
::*********************************************************************

DSIRBL	LHI	R1,ISRDBL		:RED BALL 0AB
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIGBL:
::	FUNCTION:	05 - GREEN BALL
::			NODE CODE MSG 05 ---> ISIS MSG 0AA
::
::*********************************************************************

DSIGBL	LHI	R1,ISGRBL		:GREEN BALL 0AA
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSIEDM:
::	FUNCTION:	07 - ENTER DEM
::			NODE CODE MSG 07 --->  ISIS MSG 0A6
::
::*********************************************************************

DSIEDM	LHI	R1,ISEDEM		:EDEM 0A6
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSILDM:
::	FUNCTION:	04 - LEAVE DEM
::			NODE CODE MSG 04 --->  ISIS MSG 0A7
::
::*********************************************************************

DSILDM	LHI	R1,ISLDEM		:LDEM 0A7
	J	DSIMES

::*********************************************************************
::
::	SUBROUTINE:	DSITMC:
::	FUNCTION:	HANDLE 01 CONTROL PAIRS
::
::*********************************************************************

DSITMC	JAL	R8,GCI			:01 PAIR, GET SECOND CHAR
	LR	R4,R1			:SAVE SECOND BYTE
	SRHLS	R1,4			:DISPATCH ON HI-ORDER 4 BITS
	SLLS	R1,2			:FW indexing			###wjl
	L	R3,DSITMP,R1,		:				###wjl
	SRLS	R1,2			:restore index, used below	###wjl
	SIS	PRD,3			:BACK UP POINTER
	JR	R3			:				###wjl

::*********************************************************************
::
::	TABLE:		DSITMP:
::	FUNCTION:	01 CONTROL PAIRS DISPATCH TABLE
::
::*********************************************************************

DSITMP	WC	DSIT08,DSIT08,DSIT08,DSIT08
	WC	DSIT08,DSIT08,DSIT08,DSIT08
	WC	DSIT08,DSIT09,DSIT0A,DSIT0A
	WC	DSIT0C,DSIT0C,DSINXT,DSIT0F

::*********************************************************************
::
::	SUBROUTINE:	DSIT08
::	FUNCTION:	HANDLE 010x, 011x, 012x, 013x, 014x, 015x, 016x,
::			017x, AND 018x CONTROL PAIRS
::
::*********************************************************************

DSIT08	LB	R3,DTM08,R1		:HERE FOR TYPES 0 - 8
DSIT8A	LB	R0,DTM80,R3		:R3 IS PTR TO SECOND TABLE
	THI	R0,80			:IF 80, WERE DONE
	JN	DISI90
	NR	R0,R4			:R0 IS TRUNCATED VALUE
	LB	R1,DTM80+1,R3		:R1 IS SHIFT COUNT FOR R4
	SRHL	R4,0,R1
	LB	R1,DTM80+2,R3		:R1 IS ISIS CODE # (N)
	EXBR	R0,R0
	AR	R0,R1
	JAL	R10,DSITSM		:SEND B1 MESSAGE
	AIS	R3,3
	J	DSIT8A			:AND REPEAT

:	IN THE FOLLOWING TABLE EACH ENTRY CONSISTS OF 3 1-BYTE ELEMENTS:
:	BYTE 1 - MASK FOR INCOMING DATA
:	BYTE 2 - NUMBER OF BITS TO SHIFT
:	BYTE 3 - THE ISIS-II MESSAGE NUMBER

:	EACH ARRAY IS COMPOSED OF AN INTEGRAL NUMBER OF 3-BYTE ENTRIES,
:	AND IS TERMINATED WITH AN '80'.
:	Each triple in the array describes how to process the
:	corresponding subfield, described by the "mask" entry, of the
:	"x" listed below.
:	See CIRCUIT PROTOCOL document, App. I, for description of these
:	messages.

DTM80	BC	1,1,3,1,1,2,1,1,1,1,1,0,80	:for 010x pairs
DTM81	BC	7,3,5,1,1,4,80			:for 011x pairs
DTM82	BC	1,1,7,7,3,6,80			:for 012x pairs
DTM83	BC	7,3,5,80			:for 013x pairs
DTM84	BC	1,1,0A,7,3,0A,80		:for 014x pairs
DTM85	BC	0F,4,0B,80			:for 015x pairs
DTM86	BC	0F,4,0A,80			:for 016x pairs
DTM87	BC	0F,4,9,80			:for 017x pairs
DTM88	BC	0F,4,6,80			:for 018x pairs
Q	EQ	DTM80
DTM08	BC	DTM80-Q,DTM81-Q,DTM82-Q,DTM83-Q
	BC	DTM84-Q,DTM85-Q,DTM86-Q,DTM87-Q,DTM88-Q

::*********************************************************************
::
::	SUBROUTINE:	DSIT09:
::	FUNCTION:	HANDLE 019x CONTROL PAIRS
::
::*********************************************************************

DSIT09	LIS	R1,0F			:TYPE 9 - RANDOM BULLSHIT
	NR	R1,4
	LB	R3,DTM09,R1		:POINTS TO LIST OF CODES
DSIT9A	LB	R0,DTM90,R3		:POINTS TO CODE BYTE
	THI	R0,80
	JN	DISI90
	JAL	R10,DSITQM		:SEND MESSAGE
	AIS	R3,1
	J	DSIT9A

DTM90	BC	3,2,1,0,80
DTM91	BC	4,5,80
DTM92	BC	6,7,80
DTM93	BC	9,8,80
DTM94	BC	0A,80
DTM95	BC	0B,80
DTM96	BC	0A,80
DTM97	BC	9,80
DTM98	BC	6,80

Q	EQ	DTM90
DTM09	BC	DTM90-Q,DTM91-Q,DTM92-Q,DTM93-Q
	BC	DTM94-Q,DTM95-Q,DTM96-Q,DTM97-Q,DTM98-Q

::*********************************************************************
::
::	SUBROUTINE:	DSIT0A:
::	FUNCTION:	HANDLE 01Ax, 01Bx CONTROL PAIRS.
::	
::*********************************************************************

DSIT0A	SRHLS	R4,1			:TYPE A - QUERY BITS
	NHI	R4,0F
	LB	R0,DTM0A,R4		:GET CODE
	JAL	R10,DSITQM
	J	DISI90

:	THIS TABLE IS ARRANGED IN 'NETWORK MESSAGE' ORDER TO CONVERT TO ISIS
DTM0A	BC	0,1,3,2,8,7,0C,4,0D,0E,10,11,12,13,0,0

::*********************************************************************
::
::	SUBROUTINE:	DSIT0C:
::	FUNCTION:	HANDLE 01Cx, 01Dx CONTROL PAIRS.
::
::*********************************************************************

DSIT0C	LIS	R1,1			:TYPE C - SET/RESET BIT PARAMETER
	NR	R1,R4			:BIT VALUE (0/1) IN R1
	SRHLS	R4,1
	NHI	R4,0F
	LB	R0,DTM0A,R4		:CODE ('N') IN RIGHT BYTE
	EXBR	R1,R1
	AR	R0,R1
	JAL	R10,DSITSM		:send a B1 message
	J	DISI90

::*********************************************************************
::
::	SUBROUTINE:	DSIT0F:
::	FUNCTION:	HANDLE 01Fx CONTROL PAIRS
::
::*********************************************************************

DSIT0F	NHI	R4,0F			:TYPE F - BALLS
	LB	R1,DTM0F,R4
	AIS	PRD,3
	CLHI	R4,01			:IS IT HANG OR HDX HANG?
	JG	DSIMES			:NO
	SBT	CHN,DISHNG		:YES - REMEMBER WE SENT IT (INFO ONLY)
	J	DSIMES

::*********************************************************************
::
::	TABLE:		DTM0F:
::	FUNCTION:	TRANSLATE NODE CODE 01Fx PAIRS TO ISIS MSG
::
::*********************************************************************

DTM0F	BC	0AF	:F0 - HANG UP
	BC	0B8	:F1 - HDUX HANG
	BC	0A8	:F2 - ENTER TRANSPARENCY
	BC	0A9	:F3 - LEAVE DITTO
	BC	0BC	:F4 - ENTER ALTERNATE DEVICE MODE
	BC	0BD	:F5 - LEAVE ALTERNATE DEVICE MODE
	BC	0BF	:F6 - ENTER IIX EXCHANGE
	BC	0C0	:F7 - LEAVE IIX EXCHANGE
	BC	0,0,0	:F8 - FA - ZIP
	BC	0AE	:FB - BREAK
	BC	0A5	:FC - GREY BALL
	BC	0A4	:FD - BLACK "
	BC	0AD	:FE - ORANGE "
	BC	0AC	:FF - YELLOW

::*********************************************************************
::
::	SUBROUTINE:	DSIMES:
::	FUNCTION:	PUTS UP TO 3 CHARS IN RING.
::
::*********************************************************************

DSIMES	SIS	PRD,1			:PUTS UP TO 3 CHARS IN RING...
	NR	PRD,TC			:FIRST ONE IS TYPE
	LIS	LRC,0
	LR	R1,R1
DSIME1	JE	DISI90
	STB	R1,DIRNG,PRD,
	AIS	PRD,1
	NR	PRD,TC
	AIS	LRC,1
	SRHLS	R1,8
	JNBS	DSIME1
	J	DISI90

::*********************************************************************
::
::	SUBROUTINE:	DSITSM:
::	FUNCTION:	SEND SET PARAMETER MESSAGE
::
::*********************************************************************

:	sends:  chn, count, /B1/N/, /value/, where "/"'s enclose bytes
DSITSM	STH	CHN,DIRNG,PRD,		:SEND SET PARAM MESSAGE
	LHI	R1,ISSPRM		:SEND ISIS SET PARAMETER (0B1)
	STB	R1,DIRNG+2,PRD,		:PUT IT IN THE RING
	STB	R0,DIRNG+3,PRD,		:VALUE/'N' IN R0
	AIS	PRD,4			:advance the ring pointer a Wordsworth
	NR	PRD,TC			:check for ring wrap
	EXBR	R0,0			:get the second byte
	STB	R0,DIRNG,PRD,		:put it in the ring
	AIS	PRD,4			:advance another Wordsworth
	NR	PRD,TC			:check for another wrap
	JR	R10			:and blow this scene

::*********************************************************************
::
::	SUBROUTINE:	DSITQM:
::	FUNCTION:	SEND QUERY PARAMETER MESSAGE
::
::*********************************************************************

DSITQM	STH	CHN,DIRNG,PRD,		:SEND QUERY PARAM MESSAGE
	LHI	R1,ISQPRM		:ISIS QUERY PARAMETER (0B0)
	STB	R1,DIRNG+2,PRD,
	STB	R0,DIRNG+3,PRD,		:'N' IN R0
	AIS	PRD,4
	NR	PRD,TC
	JR	R10

::*********************************************************************
::
::	TABLE:		DSITAB:
::	FUNCTION:	NETWORK CONTROL CODES DISPATCH TABLE
::
::*********************************************************************

DSITAB	WC	DSINXT,DSITMC,DSINXT,DSITII
	WC	DSILDM,DSIGBL,DSIRBL,DSIEDM

	SUBTTL	DISPI (DISOUT - Move data out of dispatcher into network)

:	THE FOLLOWING SYMBOL IS USED AS A BASE ADDRESS TO ALLOW ROUTINE
:	ADDRESSES TO BE STORED AS HALF-WORDS IN TABLE DSOMTB
SEG1.1	HS	0

::*********************************************************************
::
::	SUBPROCESS:	DISOUT:
::	FUNCTION:	MOVES DATA FROM DISPATCHER INTO NETWORK
::	CALLING SEQ:	JAL	R10,DISOUT
::
::*********************************************************************

DISOUT	ST	R10,DSSVRT		:SAVE RETURN
:	DON'T SPEND FOREVER EMPTYING DISPATCHER RING. DIDTIM WILL CONTAIN
:	FASTC TIME TO RETURN BACK TO SPIDER EVEN IF WORK IS LEFT OVER.
	L	R0,FASTC,,
	AHI	R0,TICDSO		:assigned max time (7d ticks)   ###sdw
XICDSO  EQ      .-2                     :able to change from xray symbol table
        SYAD(XICDSO)
	ST	R0,DIDTIM
        LHL     R3,DROF,,               :gather some statistics
        SH      R3,DROE,,               :how much in RING
        JGEFS   DISOU1
        AI      R3,DRSZ
DISOU1  CH      R3,DISOCP               :new max amoung in ring
        JLEFS   DISOU2
        STH     R3,DISOCP               :
DISOU2
        CLHI    R3,DRSZ-9D              :to be buffering so do something
        JLFS    DISOU4                  :special to stop dispatcher buffering
        JAL     R10,DSODBF              :                               ###sdw
DISOU4
        SRHL    R3,DSCALE               :now make histogram entry
        NHI     R3,3C                   :keep in in range
        LIS     R0,1
        AM      R0,DSOHGM,R3
        JGEFS   DSONXT                  :zero all when use 32nd bit
        LIS     R0,0
        LHI     R1,3C                   :zero all entries
DISOU3  ST      R0,DSOHGM,R1,
        SIS     R1,4                    :clear histogram
        JGEBS   DISOU3

:	RETURN HERE AFTER SERVICING EACH CHANNEL, AND YIELD EITHER IF
:	HIGHER PRIORITY TASK HAS BEEN SCHEDULED, OR IF OUR TIME SLICE UP.
DSONXT	HS	0
       IF       EFFEXC                   :don't got through whole exec loop
        LIS     R0,1F-PCKZB             :only worry is buffer zap
        TBT     R0,SQUEUE
        JEFS    DSONX0                  :not a pending buffer zap
        JAL     R0,EXYLD,,              :yield to buff zap
DSONX0  HS      0
       ELSE     :inefficient old code
	JAL	R0,EXYLD,,
       EI       :EFFEXC
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR DISOUT	###OAS
	CPUTNM(DISOUT)			:DEFINE CPUTIL ENTRY FOR DISOUT	###OAS
	EI	:DB.CPU
	L	R0,DIDTIM		:GET TIME TO DISMISS
	S	R0,FASTC,,		:LATER THAN CURRENT TIME?
	JGFS	DSONX1			:YES, CONTINUE EMPTYING DISPATCHER RING
	LIS	R0,1			:NO - COUNT NUMBER OF FORCED DISMISSES
	AHM	R0,DODISM
DSOORT  L       R10,DSSVRT              :exit for DISOUT
        JR      R10                     :return to SPIDER

DSONX1	LIS	TYC,7			:SET CONSTANTS
	LHI	TC,DRSZ-1
	LHL	PRD,DROE,,		:COMPUTE # CHARS TO MOVE OUT OF DISPI
	LHL	PRC,DROF,,
	SR	PRC,PRD			:DROF - DROE
	NR	PRC,TC
	JEBS	DSOORT			:ALL DONE, DORNG  IS EMPTY

	LHL	CHN,DORNG,PRD,		:CHANNEL #  (RPORT)

:	INTRA-ISIS COMUNICATIONS, IF RPORT IS ZERO.
	JE	DSZERO			:SPECIAL CONTROL CHANNEL

:	FOR ALL RPORT IS NOT ZERO
	CLHI	CHN,NDP			:CHN = REL DISPI CHN #
	JLFS	DISO02			:VALID DISPATCHER PORTS ONLY
	CRASH.(.DISO0)
DISO02	IF	1-TUNL							###AL
	LHL	R2,DIOTAB,CHN,CHN	:GET DISPI OUTBOUND BUFFER #
	ELSE	:TUNL
	LH	R2,DIOTAB,CHN,CHN	:GET DISPI OUTBOUND BUFFER #
	JL	TNIN			:HO BIT SET, TUNNEL INPUT ROUTINE
	GL	TNIN
	EI	:1-TUNL
	NHI	R2,-4			:STRIP GOUGING BITS FROM BUFFER #
	JNFS	DISO04			:GO AHEAD, THE CIRCUIT IS THERE

	JAL	R8,DISKIP		:SKIP OVER DATA
					: ON UNASSIGNED DISPATCHER PORT
	J	DSONXT			:PROCESS NEXT CHANNEL

DISO04	LB	LRC,DORNG+2,PRD,	:CHARACTER COUNT (TYPE)
	AIS	PRD,3
	NR	PRD,TC			:POINTS TO LAST BYTE OF WORD
	LHI	R1,-9E,LRC		:IS IT DATA

:	IT IS CONTROL MESSAGE, IF TYPE >= 9E
	JGE	DSOCTL			:NO, CONTROL MESSAGE

:	IT IS DATA ONLY, IF TYPE <= 9D
	LR	CD,LRC			:MOVE THESE MANY

	IF	T2GATE
	IF	ACCT
::                              Accounting here so we get only data characters
	TBT	CHN,GORGPT		:Should we count these ? 
	JN	GLCH02			:This is an origin port - no count
	LR	R0,LRC			:Get count
	LR	R3,CHN			:Move Channel # to work reg
	AHI	R3,DISZFL		:Get absolute channel number
	SHI	R3,MNACHN		:Make an accounting index
	JAL	R8,AARDOC,,		:Now add to accumulator
	GL	AARDOC
	LIS	TYC,07			:This reg was getting clobbered	###ev
GLCH02
	EI	:ACCT
	EI	:T2GATE

:	LOOP TO MOVE DATA FROM DORING TO BUFFER

 
:       new dispatcher logic which takes fewer instructions
:       per character than using the WCI instruction
:       The efficiency is gained by saving the buffer position in R3
:       while the WCI call loads and saves R3 for each char
:       Also, code is ordered to make use of fact that jumps not taken
:       are quicker than taking a jump
:       For engine the inline WCI microcode is slightly faster than the code.
:       For turbo the code is much faster than any existing code.       ###SDW


:	LOOP TO MOVE DATA FROM DORING TO BUFFER

:       most efficient method on the engine

        LA      R8,DISO3                :SET UP RETURN ADDRESS FOR EXCEPTIONS
        JFS     DISO1

DISO4   AIS     LRC,1                   :ADJUST INPUT CHARA COUNT
        EXBR    R1,R1
        JAL     R8,WCI                  :WRITE '00' ESCAPE
        EXBR    R1,R1                   :RESTORE ORIGINAL CHARACTER
        LA      R8,DISO3                :RETORE RETURN ADDRESS FOR EXCEPTIONS
        JFS     DISO2

        GL      WCIERR,WCNXT,WCFRST
DISO1	LB	R1,DORNG,PRD,		:MOVE DATA FROM DORING
	AIS	PRD,1
	NR	PRD,TC			:INCREMENT RING POINTER
	CR	R1,TYC			:DO WE NEED TO ESCAPE?
        JLEBS   DISO4                   :YES - PRECEDE WITH ESCAPE CHAR (00)
DISO2   HC      3912                    :WCI R1=CHAR, R2=BUFFER INDEX
        HC      BE-BB                   :SIZE OF BB STORAGE
        HC      WCIERR-DISO2            :HERE ON INVALID BUFFER NUMBER
        HC      BE/4                    :ADDRESS OF BE STORAGE/4
        HC      WCNXT-DISO2             :HERE TO CHAIN IN ANOTHER BUFFERLET
        HC      WCFRST-DISO2            :HERE TO GET FIRST BUFFERLET
DISO3   EQ      .                       :EXCEPTION RETURN POINT
	SIS	CD,1			:DONE?
	JGBS	DISO1			:NO - CONTINUE

	LHL	R1,DIOTAB,CHN,CHN	:SET BACKPRESSURE IF NEEDED
	NHI	R1,3			:READ GOUGING LEVEL BITS FROM IOTAB
	LHL	R0,BCT,R2,		:READ BCT FOR THE BUFFER
	CLH	R0,CIRSPK,R1,R1		:COMPARE BCT WITH GOUGING LEVEL MAX
	JLFS	DSOTBP			:IF BCT LESS THEN NO BP MSG TO ISIS

:	WE'VE MOVED MORE THAN BP MAX
       IF       T2GATE                  :don't BP chars in logger buffer##sdw
        TBT     CHN,LOGING              :if set then logon chars
        JNFS    DSOTBP
       EI       :T2GATE
	RBT	CHN,DISBPX		:ELSE WE'VE MOVED MORE THAN BP MAX
	LIS	R0,4			:WAIT FOR ROOM IN ISIS INPUT RING
	JAL	R8,DIROOM
	LHI	R1,SDSPBP		:SEND ONE WORD MSG TO ISIS--SET BP
	JAL	R8,DIRMES

DSOTBP	AM	LRC,DISOCC		:INC CHAR COUNT
DSOIRP	AIS	PRD,3			:TRUNCATE POINTER
	NHI	PRD,DRSZ-4
	STH	PRD,DROE,,
	J	DSONXT			:REPEAT

::*********************************************************************
::
::	SUBROUTINE:	DSOCTL:
::	FUNCTION:	HANDLE ISIS CONTROL MESSAGES  ( >= 9E )
::
::*********************************************************************

DSOCTL	LIS	LRC,0
	CLHI	R1,DSODMX		:IF TYPE > MAX...
	JLFS	DSOCT2
DSOCRH	HS	0
	CRASH.(.DSOC0)
DSOCT2	TBT	R1,DSOMBA		:1=EASY, 0=HARD TO CONVERT
	JE	DSOCT1			:HARD, FANOUT BY TYPE##AL

:	EASY TO CONVERT
	LHL	R1,DSOMTB,R1,R1		:TRANSLATE THE REST

	IF	T2GATE
	TBT	CHN,LOGING		:For Gateway, login  handler
	JE	DSOMS1			:Not log-in - just proceed
	CLHI	R1,05			:Is a green ball
	JE	GDCM01			:Yes
	CLHI	R1,06			:Is a red ball
	JE	GDCM01			:Yes
	CI	R1,0FF01		:Or a yellow ball	###jk
	JE	GDCM02
DSOMS1	LR	R1,R1
	EI	:(T2GATE)

DSOMES	JE	DSOTBP			:ALL DONE
	JAL	R8,WCI
	SRHLS	R1,8
	JBS	DSOMES

	IF	T2GATE
GDCM01	XHI	R2,4			:Flip to terminal bound buffer
	JAL	R8,WCI			:And bounce it
	XHI	R2,4			:Return to net bound buffer
	J	DSOTBP
GDCM02	XHI	R2,4			:Flip again
	LHI	R1,01
	JAL	R8,WCI
	LHI	R1,0FE
	JAL	R8,WCI			:bounce orange ball
	XHI	R2,4			:Flip back
	J	DSOTBP
	EI	:(T2GATE)

:	DISPATCH ON TYPE
DSOCT1	LHL	R1,DSOMTB,R1,R1	
	J	SEG1.1,R1,

::*********************************************************************
::
::	SUBROUTINE:	DSODET:
::	FUNCTION:	9E  -  DETACH
::
::*********************************************************************

DSODET	HS	0
	IF	IDTACH			:ISIS Detach			###wjl
	IF	T2GATE
	JAL	R8,GBYHOM,,
        GL      GBYHOM
	EI	:T2GATE
	LHL	R0,BF,R2,		:ZAPPER
	JE	DSOIRP			:IGNORE IF WAITING FOR ZAK
	RBT	CHN,DISHNG		:IF WE SENT HANG, ZAPPER CLEARS
	LHI	R1,ZAPPN		:Non-Gobbling Zapper (0303)
       if       t2gate
       if       acct
        lis     r0,aalr02
        sth     r0,aareas
       ei
       ei
	JAL	R9,ZAPXN,,		:ZAP circuit, do not CBCLR
	GL	ZAPXN
	J	DSOZ10			:GO CLEAR HOST ENTRY,
					: DECREMENT PORT COUNT
	ELSE	:not IDTACH
        J       DSOZAP                  :handle like a zapper           ###sdw
	EI	:IDTACH	###wjl

::*********************************************************************
::
::	SUBROUTINE:	DSOZAP:
::	FUNCTION:	9F - ZAPPER
::
::*********************************************************************

DSOZAP	LHL	R0,BF,R2,		:ZAPPER
	JE	DSOIRP			:IGNORE IF WAITING FOR ZAK
	RBT	CHN,DISHNG		:IF WE SENT HANG, ZAPPER CLEARS

	IF	T2GATE
	TBT	CHN,GDSTPT
	JE	GSOZA4
	LHI	R1,AALR02		:Log out by host
	STH	R1,AAREAS		:Store reason for accounting	
	JAL	R8,GBYHOM,,		:Send "inter-link cleared" if appr.

	LR	R4,CHN
	JAL	R10,GSOZW7,,
        GL      GSOZW7
	SKIPAD(GSOZA6)			:IMMED, PORT DETACHED		###wjl
GSOZA4	LIS	R1,0			:+4
	STH	R1,AAREAS		:Zap not counted if origin port
GSOZA5	JAL	R9,ZAPHRD,,		:NOT DETACHED, MUST HARD ZAP
GSOZA6	HS	0
	ELSE	:NOT T2GATE
	JAL	R9,ZAPHRD,,		:ZAP
	EI	:T2GATE
	J	DSOZ10			:GO CLEAR HOST ENTRY,
					: DECREMENT PORT COUNT

::*********************************************************************
::
::	SUBROUTINE:	DSOZAK:
::	FUNCTION:	BB - ZAP ACK
::
::*********************************************************************

DSOZAK	HS	0
	IF	T2GATE
	TBT	CHN,DISZNK		:Should be zero if log-in mode
	JN	DSOZ05
	JAL	R9,GLZPV,,
	GL	GLZPV
	JFS	DSOZ10
	EI	:T2GATE


DSOZ05	XHI	R2,4			:FLIP TO INBOUND BUFFER INDEX AND
	JAL	R9,ZAPV,,		: ZAP SECOND HALF OF CIRCUIT
	RBT	CHN,DISZNK		:NO LONGER AWAITING ZAPPER ACK

DSOZ10	HS	0
	IF	T2GATE
	RBT	CHN,LOGING		:Disable possible login service
	RBT	CHN,DISFLG		:Kludge fix for 3E63 crash
	EI	:T2GATE			:###ev
	LCS	R0,1
	AHM	R0,HNPORT		:DECREMENT HOST PORT COUNT
	STH	R0,DHSTIX,CHN,CHN	:CLEAR HOST ENTRY (-1 INDICATES ITS
					:BEEN USED BEFORE, 0 FOR NEVER USED)
	J	DSOIRP			:DONE

::*********************************************************************
::
::	SUBROUTINE:	DSOGOB:
::	FUNCTION:	A2 - GOBBLER
::
::*********************************************************************

DSOGOB	JAL	R9,GOBBLN,,		:GOBBLER, DON'T GOBBLE NEEDLE
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOSXL:
::	FUNCTION:	B9 - SET XMT LIMIT
::
::*********************************************************************

DSOSXL	LB	R1,DORNG,PRD,		:SET XMIT LIMIT
	STH	R1,DIXLIM,CHN,CHN
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOQPR:
::	FUNCTION:	B0 - QUERY FIELD PARAMETER
::
::*********************************************************************

DSOQPR	LB	R1,DORNG,PRD,		:QUERY FIELD PARAMETER
	NHI	R1,1F
	LB	R1,TQPR,R1		:GET SECOND BYTE OF CORRESPONDING...
	JE	DSOTBP			:DON'T SEND OUT 01-00 PAIRS	###GT
DSOQP1	EXBR	R1,R1			:...01 PAIR
	AIS	R1,1
	J	DSOMES			:SEND PAIR

::*********************************************************************
::
::	SUBROUTINE:	DSOSPR:
::	FUNCTION:	B1 - SET FIELD PARAMETER
::
::*********************************************************************

DSOSPR	LB	R1,DORNG,PRD,		:SET FIELD PARAMETER
	AIS	PRD,1
	NR	PRD,TC
	LB	R0,DORNG,PRD,		:FIELD VALUE
	AIS	PRD,4
	NR	PRD,TC
	NHI	R1,1F			:RESTRICT INDEX (0-31d)
	CLHI	R1,5			:TEST FOR B1/05 MSG
					: (SET INPUT BAUD RATE) AND BYPASS DUE
	JE	DSOTBP			: TO AMBIGUOUS TREATMENT BY TYMSATS
	LB	R4,TSPRM,R1		:GET THE VALUE MASK
	NR	R0,R4			:PREVENTS FIELD OVERFLOW
	LB	R1,TSPR,R1		:SECOND BYTE OF 01 PAIR
	JE	DSOTBP			:DON'T SEND OUT 01-00 PAIRS	###GT
	OR	R1,R0			:INSERT VALUE
	J	DSOQP1			:SEND PAIR

::*********************************************************************
::
::	SUBROUTINE:	DSORBP:
::	FUNCTION:	A1 - RELEASE BACKPRESSURE
::
::*********************************************************************

DSORBP	SBT	CHN,DISBPV		:RELEASE BACKPRESSURE
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOSBP:
::	FUNCTION:	A0 - SET BACKPRESSURE
::
::*********************************************************************

DSOSBP	RBT	CHN,DISBPV		:SET BACKPRESSURE
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSOHNG:
::	FUNCTION:	B8 - SUPER HANG CHAR PAIR
::
::*********************************************************************
DSOHNG	LI	R1,0F101		:SUPERHANG CHAR PAIR
	IF	T2GATE
	JAL	R9,GDOMES,,		:Forward it
        GL      GDOMES
	LHI	R1,09F00
	JAL	R8,DIRMES		:but Zap circuit backwards
	RBT	CHN,DISZNK
	RBT	CHN,LOGING
	RBT	CHN,DISFLG
	LA	R4,EXMG1,,
	JAL	R9,BUFCAN		:Send "pls see yr rep"
        GL      BUFCAN
	TBT	CHN,GTTRNS
	JN	GDSOH4
	LA	R4,GNGONE,,		:if not Xparent, "inter link cleared"
        GL      GNGONE
	JAL	R9,BUFCAN
	ROUTE(HOMEN,ISISN)
	LA	R4,CRLF
        GL      CRLF
	JAL	R9,BUFCAN
GDSOH4
       IF       ACCT
	LHI     R1,AALR02               :accounting reason
        STH     R1,AAREAS,,             :do accounting for logon zaps   ###sdw
       EI       :ACCT
        LHI	R1,ZAPPN		:then Non Gobbling Zapper forward
	JAL	R9,ZAPX,,
	J	DSOTBP			:next port
	ELSE	:NOT T2GATE
	J	DSOMES			:otherwise send it and continue
	EI	:T2GATE

	IF	1-T2GATE		:Gateway does not get B3 chars
::*********************************************************************
::
::	SUBROUTINE:	DSOLGC:
::	FUNCTION:	B3 - LOGON CHAR
::
::*********************************************************************

DSOLGC	HS	0			:PROCESS LOGON CHARACTER
	LB	R1,DORNG,PRD,		:GET LOGON CHARACTER FOR LOGCHR
	JAL	R11,LOGCHR		:JUMP TO LOGIN CHAR PROCESSING ROUTINE
	SKIPAD(DSOLG1)			:RETURNS HERE IF PORT NOT IN LOGIN MODE
	SKIPAD(DSOLG3)			:RETURNS HERE IF LOGIN BUFFER FULL
	J	DSOTBP			:RETURNS HERE IF ALL IS WELL

:	GOT LOGIN CHARACTER FROM DISPATCHER PORT NOT IN LOGIN MODE.
:	COUNT OCCURRENCE, AND UPDATE RING POINTER PAST ILLEGAL MESSAGE.
DSOLG1	LIS	R0,1
	AHM	R0,DOILLG		:NUMBER OF ILLEGAL LOGIN CHARACTERS
	J	DSOIRP			:BYPASS THIS MESSAGE

:	LOGIN BUFFER FULL. SEND USER 'TOO MANY CHARS' MSG AND 'PLS  SEE REP'
:	MESSAGE AND HANG PORT
DSOLG3	HS	0
	LIS	R0,4			:SEND 'SUPER HANG' (FOR HDX TERMS)
	JAL	R8,DIROOM
	LHL	R10,DRIF,,
	STH	CHN,DIRNG,R10,
	LHI	R0,0B800		:PORT # + SUPER HANG
	STH	R0,DIRNG+2,R10,
	AIS	R10,4
	NR	R10,TC
	STH	R10,DRIF,,
	LA	R1,FULMSG		:BUFFER FILLED MESSAGE
	JAL	R8,DIMMES		:TELL USER
	LA	R1,EXMG1,,		:SEND PLS SEE REPRES... MSG
	JAL	R8,DIMMES		: TO USER
	LIS	R0,4			:SEND HANG
	JAL	R8,DIROOM
	LHL	R10,DRIF,,
	STH	CHN,DIRNG,R10,
	LHI	R0,0AF00		:PORT # + HANG
	STH	R0,DIRNG+2,R10,
	AIS	R10,4
	NR	R10,TC
	STH	R10,DRIF,,
	J	DSOTBP			:CONTINUE
	EI	:1-T2GATE

::*********************************************************************
::
::	SUBROUTINE:	DSOZWR:
::	FUNCTION:	BE - ZAP WITH REASON
::
::	REASON 0 = HOST OUT OF PORTS
::	INPUT MESSAGE FORMAT:
::		|PORT...! BE :REASON|{0000! 05 : -- |7MG,VALUE..|}
::
::	FOR THE NEW ISIS, CHECK THAT REASON IS REALLY 0, AND DO
:: 	NOT ASSUME THAT ACCOUNTING MESSAGE FOLLOWS IMMEDIATELY,
::	CHECK HOST RELATED ERRORS, SEND MESSAGE TO ERROR LOGGER
::	BUT DO NOT SEND ACCOUNTING MESSAGES.
::
::*********************************************************************

DSOZWR	HS	0			:ZAP WITH REASON
	LR	R4,CHN			:SAVE 'OLD' CHAN #
	LB	R0,DORNG,PRD,		:GET THE REASON FOR THIS ZAP
	JE	DSOZW2			:ZERO IS OK

:	DISPLAY ERROR IN CRYPTO LOG

	JAL	R8,CRYPTO,,		:LOG THIS REASON AS AN ERROR
	HC	CRYE73
	J	DSOIRP			:AND IGNORE THE MESSAGE

DSOZW2	HS	0	:FIND HOST NUMBER TO CHECK FOR REALLY OUT OF PORTS
	LHL	R1,DHSTIX,R4,R4		:GET HOST NUMBER
	JAL	R9,FNDHST,,		:FIND HOST INDEX (HN)
	GL	FNDHST
	SKIPAD(DSOZW7)			:NO HOST, ASSUME PORTS REPORTED 'FULL'
	LHL	R0,HSTPTA,HN,HN		:+4 return - PORTS REPORTED AS FULL?
	JE	DSOZW7			:YES
:	NO--SEND NODE REPORT
	STH	R0,SUPMBF+2		:# OF PORTS REPORTED AVAIL LAST
	LIS	R0,0			:SET PORT ARRAY TO 0
	STH	R0,HSTPTA,HN,HN		: (THAT'S WHAT WE'RE TELLING SUP)

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R0,EHHOPT		:set host out of ports bit
	STB	R0,HSTATN,HN		:TO INDICATE OUT OF PORTS	###OAS

	LHI	R0,NR.NRJ		:NEEDLE REJECT (HOST OUT OF PORTS)
	STH	R0,SUPMBF
	LHL	R0,HOSTN,HN,HN		:HOST #
	OHI	R0,8000
	STH	R0,SUPMBF+4
	JAL	R10,SUP12,,		:REPORT TO SUP LOG

	LHL	R0,HOSTN,HN,HN		:GET HOST #
	OHI	R0,8000
	STH	R0,SUPMBF
	LHI	R5,8F			:OUT OF PORTS
	LIS	R6,1			:1 HALFWORD TO BE SENT
	LIS	R2,1
	JAL	R10,SUP14,,		:SEND OUT OF PORTS MSG TO SUP

:	DETACH CIRCUIT. REMOVE DISPATCHER PERMUTER TABLE ENTRY FROM DIOTAB,
:	FIND AVAILABLE CHANNEL TO DISPATCH PROCESS IN CIOTAB (STARTING WITH
:	DETZFL). CONNECT NETWORK HALF-CIRCUIT TO DETACH PROCESS FOR SENDING
:	APPROPRIATE TEXT TO USER, BOUNCING YELLOW BALL, AND TIMING OUT CIRCUIT
:	IF NO ORANGE BALL RETURNED. TEXT TO USER IS DETERMINED BY VALUE STORED
:	IN DETMTY BYTE ARRAY.

DSOZW7	HS	0			:DONE WITH ACCT. DETACH PORT
	LHL	R2,DIOTAB,R4,R4		:GET EXISTING PERMUTER TABLE ENTRY TO
	NHI	R2,-4			: MOVE TO CIOTAB.
        je      dsoirp                  :all clear no needto detach
:	FIND NEXT AVAILABLE CHANNEL TO DETACH PROCESS...
	L	R4,DETACP,,		:DETACH PORT AVAILABLE ?
	JFFO	R4,DSOZW8		:FOUND ONE
	J	DSOZAP			:NO DETACH PORTS, ZAP CIRC TO NETWORK

DSOZW8	HS	0
:	CAUSE ZAPX TO PUT CR/LF INTO BUFFER INSTEAD OF ZAPPER. THIS WILL
:	CAUSE DISPATCHER PORT TO BE FREED UP WITHOUT ZAPPING EXISTING CIRCUIT.
       if       t2gate&acct
        lis     r0,aalr02
        sth     r0,aareas
       ei
	LHI	R1,0D0A			:MAKE ZAPX PUT 'CRLF' INTO BUFFER
	JAL	R9,ZAPX,,		:'ZAP' THE DISPI SIDE OF CIR.
	GL	ZAPX
:	STORE 'DETACH REASON' INTO DETMTY BYTE ARRAY
	LIS	R0,2			:INDICATE HOST OUT OF PORTS, DETECTED
	STB	R0,DETMTY,CHN		: BY SLOT WHICH SENT 'BE' MESSAGE

	AHI	CHN,DETZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER AND
	JAL	R9,CRQHCR,,		:BUILD 2ND HALF OF CKT TO DETACH PROCES
:	SEND NEEDLE POINT TO DETACH PROCESS TO ALERT IT TO NEW PORT.
	XHI	R2,4			:INDEX FOR BUFF TOWARDS DETACH PROCESS
	LIS	R1,3
	JAL	R8,WCI
	LHI	R1,NEEDP
	JAL	R8,WCI			:WRITE NEEDLE POINT IN BUFFER
	J	DSOIRP			:CONTINUE



TOMANY	HS	0
FULMSG	SC	/"8D"8Atoo many login characters/
LSMX08	SC	/"8D"8Aplease see your representative/
	SC	/"8D"8Aif you are having trouble logging in/


        SUBTTL  DISPI (X.409 DISOUT UTILITIES)

       IF       LOGII

::*********************************************************************
::
::	SUBROUTINE:     X4DWCH/X4DW2C
::	FUNCTION:       write 1 (XDWCH) or 2 (XWDWC2) bytes in R1 to 
::                      dispatcher ring
::	CALLING SEQ:    link on R8
::	INPUT:          PRD, R1
::      OUTPUT:         PRD to next free position
::
::*********************************************************************

X4DWCH  STB     R1,DIRNG,PRD,           :save char
        AIS     PRD,1
        NR      PRD,TC
        AIS     LRC,1                   :count of length written
        JR      R8

X4DW2C  EXBR    R1,R1                   :write 2 chars to dispatcher
        JAL     R8,X4DWCH
        EXBR    R1,R1
        JAL     R8,X4DWCH
        JR      R9

::*********************************************************************
::
::	SUBROUTINE:     X4DWLN
::	FUNCTION:       write number in R4 to dispatcher as x.409 len
::	CALLING SEQ:    link on R9
::	INPUT:          PRD, R4
::      OUTPUT:         PRD to next free position
::
::*********************************************************************

X4DWLN  CLHI    R4,MO.LFM               :test if long form
        JLE     X4DWL2                  :short form
        CLHI    R4,100                  :how long
        JGEFS   X4DWL1                  :jump if 2 bytes for len
        LHI     R1,MO.LFM+1             :len of len
        JAL     R8,X4DWCH
        JFS     X4DWL2
X4DWL1  LHI     R1,MO.LFM+2             :len of len
        JAL     R8,X4DWCH
        EXBR    R1,R4                   :leading byte
        JAL     R8,X4DWCH
X4DWL2  LR      R1,R4                   :low byte
        JAL     R8,X4DWCH
        JR      R9

::*********************************************************************
::
::	SUBROUTINE:     X4DGCH
::	FUNCTION:       get char from dispatcher into R1
::	CALLING SEQ:    link on R9
::	INPUT:          PRD, PRC (number more chars to read)
::      OUTPUT:         PRD to next free position, R1 with char, PRC
::
::*********************************************************************

X4DGCH  LB      R1,DORNG,PRD,           :get the char
        AIS     PRD,1
        NR      PRD,TC                  :advance pointer
        SIS     PRC,1                   :reduce count to move
        JR      R9

::*********************************************************************
::
::	SUBROUTINE:     X4DGLN - get len of element
::	SUBROUTINE:     X4DGNM - get number from element
::	FUNCTION:       get number from dispatcher into R4
::	CALLING SEQ:    link on R13
::	INPUT:          PRD, PRC, also for X4DGNM R0 has len of number
::      OUTPUT:         PRD to next free position, R4 with len/number
::
::*********************************************************************

X4DGLN  JAL     R9,X4DGCH
        LR      R4,R1                   :setup for potential quick exit
        THI     R4,MO.LFM               :long form?
        JER     R13                     :just a simple short form
        LHI     R0,-MO.LFM,R4           :how many bytes the length is
X4DGNM  LIS     R4,0
X4DGN1  JAL     R9,X4DGCH               :get another char
        OR      R4,R1                   :add it to running total
        SIS     R0,1                    :done yet?
        JER     R13                     :yes
        SLLS    R4,8                    :open up space for next byte
        JBS     X4DGN1
       EI       :LOGII

        SUBTTL  DISPI (INTRANODE MSG 11 - ICRM Log 2 circuit request)


       IF       1-T2GATE        :following log II stuff is NC specific


:*******************************************************************
:
:       ICRM    handles LOG2 ICRM message (much like a normal PSN request)
:               Comes in on port 0.  Basic Logic is to read ICRM RMOs,
:               saving/checking their data, and writing them back in the
:               NCRM format.  This includes inserting the origination port
:               number.  Format checks on the data are all IDs upto the
:               SMOset are tested for being in correct order.  The RMOset
:               length must be correct and the SMOset length must correspond
:               to the overall (ICRM id) length.  The ICRM id length is checked
:               in LOGSUP when the message is copied to the SUPE's buffer.
:               This routine also calls either ASLP (assign logon port) or
:               ECRI (reject-with the reason).
:*******************************************************************

       IF       LOGII

ICRM    LHI     R0,1A                   :room for the ECRI/ASLP?
        JAL     R8,DIROOM               :returns when there is room
        LIS     R0,0
        STH     R0,CQNBUF               :if nonzero then our buffer #
        LB      R0,DORNG+3,PRD,         :cont,subseq,aux bits
        STH     R0,ICRMSB               :ICRM save for bits
        AIS     PRD,4
        NR      PRD,TC
        LHL     PRC,DORNG,PRD,          :length of ICRM
        LHL     R8,DORNG+2,PRD,         :dispatcher key (only use low byte)
        STH     R8,DORDKY               :save it for response
        NHI     R8,0FF                  :get low byte of diskey
       IF       MXPNM                   :MXP has funny diskey
        SLLS    R8,4
        EXBR    R7,R8
        OR      R8,R7
        NHI     R8,0FF                  :R8 has slot number
       ELSE
        SRLS    R8,2                    :normal diskey is 4*slot#
       EI
        THI     R0,L2F.SQ               :is this a subsequent ICRM msg?
        JN      ICRM80
        RBT     R8,SLTRJT               :init to not reject subsequent pieces
        AR      R8,R8
        STH     R8,DORSLT               :save slot *2 (*2 is same as LOG I)
        AIS     PRD,6                   :done with len, diskey, skip local key
        SIS     PRC,4
        LHL     R0,DORNG-2,PRD,         :local key (okay to -2 since HW alig
        STH     R0,DORLKY
        LHL     R0,TVRBUF               :do we have a supe?
        JE      ECRIX0                  :nope, reject reason 0
        LB      R0,NEWSUP               :what type of supe?
        JE      ECRIX7                  :a log 2 supe?
        JAL     R7,DSZT90               :check circuits per minute
        SKIPAD(ECRIX5)
        LHI     R5,DISZFL+1             :find ourselves a dispatcher chn
        LHI     R1,NDP-1
        GL      FNDCHN
        JAL     R9,FNDCHN,,
        SKIPAD(ECRIX1)                  :no chns is reject reason 1
        SHI     R5,DISZFL               :we want rel dispatcher chn
        JAL     R8,GFCBUF               :get a place to put the MOs
        SKIPAD(ECRIX3)                  :no buffers is reject reason 3
        STH     R2,CQNBUF               :save our buffer number
        SBT     CHN,DISLG2              :this port is doing log 2 login
        LR      PRC,PRC                 :any MOs with ICRM header?
        JGFS    ICRM21
        LIS     R0,0
        SBT     R0,ICRMSB               :mark that this one has no MOs
        JFS     ICRM24

ICRM21  JAL     R9,XCRM                 :handle all of the MO stuff
        SKIPAD(ECRI)                    :error number in R5

ICRM24  AHI     CHN,DISZFL              :back to real chn #
        JAL     R9,CRQHCR,,             :build half circuit
        LIS     R0,1                    :tell LOGIN to avoid aux logic
        JAL     R8,LOGIN
        SKIPAD(ECRIX0)                  :should never happen, checked above
        SHI     CHN,DISZFL              :Back to relative chn#
        SBT     CHN,DISBPV              :release backpressure
        LHI     R0,INXLIM               :transmit limit
        STH     R0,DIXLIM,CHN,CHN

:       Now write ASLP - everything we care about is fine.
        LHL     R6,DRIF,,               :time to write ASLP
        STH     CHN,DIRNG,R6,           :chn, C5, 0, dkey, lkey
        LHI     R1,DM.ASL^8
        STH     R1,DIRNG+2,R6,
        AIS     R6,4
        NR      R6,TC
        LHL     R1,DORDKY               :dispatcher key
        STH     R1,DIRNG,R6,
        LHL     R1,DORLKY
        STH     R1,DIRNG+2,R6,          :write local key
        AIS     R6,4
        NR      R6,TC
        STH     R6,DRIF,,               :ASLP now written

        LHL     R1,HNPORT               :increment number ports in use
        AIS     R1,1
        STH     R1,HNPORT
        CLHI    R1,MXPORT
        JLEFS   ICRM50                  :new high of ports in use
        STH     R1,MXPORT
ICRM50  LHL     R8,DORSLT               :do in use per slot
        LIS     R1,1
        AHM     R1,SCLCNT-2,R8          :another in use

ICRM98  LIS     R0,0
        LHL     R8,DORSLT               :slot#*2
        STH     R0,DORCHN,R8            :mark we finished message
        LHI     R1,LOGXMT+LG.TID        :tell logger ready to go and 1st msg
        STH     R1,BF,R2,
        LH      R0,ICRMSB               :handle potential continue message
        JGEFS   ICRM99
        LHI     R1,10+LG.TID+LOGNDC     :impossible start marks no XCRM rcv
        J       DSOIRP
ICRM99  THI     R0,L2F.PT               :more to come?
        JE      DSOIRP                  :done
        LHI     R1,10+LOGSUP+LG.TID     :we are not ready to send
        STH     R1,BF,R2,               :and tell logger that
        STH     CHN,DORCHN,R8           :mark that we are expecting more pieces
        J       DSOIRP                  :finally done with ICRM

:       This handles the relatively simple case of later pieces of a message.
:       They can either be continues of a successful request (already sent em
:       an ASLP) in which this data is just copied to the buffer.  Or this
:       could be later pieces of a rejected (ECRI already sent) in which case
:       we just skip over this ISIS message

ICRM80  TBT     R8,SLTRJT               :rejecting it?
        JEFS    ICRM90
        AR      PRD,PRC                 :gobble message
        J       DSOIRP                  :done with message

ICRM90  LHL     CHN,DORCHN,R8,R8        :get back our chn #
        JE      ECRI8X                  :we have no record of the 1st piece
        LHL     R2,DIOTAB,CHN,CHN       :get back our buffer #
        AIS     PRD,6                   :point to MOs
        NR      PRD,TC
        SIS     PRC,4
        AR      R8,R8
        STH     R8,DORSLT
        JAL     R9,XCRM                 :go make XCRM if all there
        SKIPAD(ICRS94)
        J       ICRM98                  :copy data and handle more cont



::*******************************************************************
:
:       ECRIXn  returns ECRI with error code n.  All codes except 3
:               must also return the buffer pair.
:               Must skip over rest of ICRM and set up to gobble any
:               subsequent pieces of this message.
:               Routine is alternate exit (instead of ASLP) from ICRM
::*******************************************************************

ECRIX0  LIS     R5,0
        J       ECRI

ECRIX1  LIS     R5,1                    :No dispatcher chns
        J       ECRI

: ECRIX2        :No node code, not returned by NC

ECRIX3  LIS     R5,3                    :no buffers ava
        J       ECRI

:ECRIX4      handled by DSZT80 when it rejects (circuits/min exceeded by host
ECRIX5  LIS     R5,5
        J       ECRI

ECRIX6  LIS     R5,6                    :slot not licensed for aux reqs
        J       ECRI

ECRIX7  LIS     R5,7                    :no LOG II supe
        J       ECRI

ECRI8X  LIS     R5,8                    :bad form before we got any buffers
        JFS     ECRI

ECRIX8  LIS     R5,8                    :bad form of ICRM

ECRI    LHL     R2,CQNBUF               :any buffer to return
        JEFS    ECRI02                  :if 0 then no buffer
        JAL     R8,RFCBUF               :return buffer pair
        GL      RFCBUF
ECRI02  LHL     R0,DORSLT
        SLLS    R0,1                    :make slot #
        SBT     R0,SLTRJT               :reject all subsequent partials
        LHL     R6,DRIF,,               :fill pointer
        LHI     R0,DM.ECR^8             :first word of ECRI
        ST      R0,DIRNG,R6,            :write port 0 type 12 no continue
        AIS     R6,4
        NR      R6,TC
        LIS     R0,0D                   :message size
        STH     R0,DIRNG,R6,
        LHL     R0,DORDKY               :get dispatcher key
        STH     R0,DIRNG+2,R6,
        AIS     R6,4
        NR      R6,TC
        LHL     R0,DORLKY               :get local key
        STH     R0,DIRNG,R6,
        LHI     R0,MO.AC2+IDECRI        :ECRI
        STH     R0,DIRNG+2,R6,
        AIS     R6,4
        NR      R6,TC
        LI      R0,ECRIM0               :smo, len
        ST      R0,DIRNG,R6,
        AIS     R6,4
        NR      R6,TC
        LHI     R0,ECRIM1               :reject code Id and len
        STH     R0,DIRNG,R6,
        STB     R5,DIRNG+2,R6,          :and store the reason
        AIS     R6,4
        NR      R6,TC
        STH     R6,DRIF,,               :and update pointer

:       Done with writing ECRI, just gobble ICRM and will be done

        LHL     PRD,DROE,,              :get back to start of message
        AIS     PRD,6
        NR      PRD,TC                  :point to right after mesage size
        LHL     R0,DORNG-2,PRD,         :get message size
        AR      PRD,R0
        J       DSOIRP                  :and we are done

ECRIM0  EQ      06^18+SMOID^10+04^8+MO.A1+IDBITS :length smo element
ECRIM1  EQ      ID.ERC^8+01             :reject ID and len

       EI       :LOGII

        SUBTTL DISPI (TYPE C4 - ICRS Logon information for LOG II logon)


::***********************************************************
:
:       ICRS    Handles LOG2 supplemental messages.  Writes in
:               RMOset with bit for second msg to supe and dispatcher
:               chn #.  Only check is overall ICRS length and SMO length
:               end up at the same point.
:
::***********************************************************

       IF       LOGII
NCRLHD  SC      /"30"09"5A"00"02/      :RMOseq upto chn # for CHN>100
NCRSHD  SC      /"30"08"5A"00"01/       :same but for chn #<100
NCRMTL  SC      /"5F"3D"00"02"06"40/    :then the NCRM flags

ICRS    LB      R0,DORNG,PRD,           :get bits of continue, subseqent
        STH     R0,ICRMSB               :save them
        AIS     PRD,1                   :bump to len field
        NR      PRD,TC
        LHL     PRC,DORNG,PRD,          :get size of message
        AIS     PRD,2                   :update pointer, no NR since on HW
        LHL     R1,BF,R2,               :make sure port in proper login mode
        TBT     CHN,DISLG2              :Make sure this one started as LOG 2
        JE      ICRSR1                  :this guy started LOG1 and now LOG2?
        CLHI    R1,10+LOGNDC+LG.TID     :ICRS with XCRM MOs?
        JE      ICRS90                  :yes, handle specially
        CLHI    R1,10+LOGSUP            :better in login mode with ready supe
        JN      ICRSR0                  :reject, wrong time for ICRS
        THI     R0,L2F.SP               :is this a subsequent piece?
        JN      ICRS60                  :handle subsequent piece
        LHL     R1,DORNG,PRD,           :get ICRS ID
        CLHI    R1,MO.AC2+IDICRS        :make sure it is ICRS id
        JN      ICRSR2                  :reject ICRS
        AIS     PRD,2
        NR      PRD,TC
        SIS     PRC,2
        LHI     R1,MO.AC2+IDNCRM        :NCRM ID
        JAL     R9,W2CI
        JAL     R13,X4DGLN              :get length of ICRS
        LR      R1,R4                   :make sure ICRS element and SMO end ok
        SR      R1,PRC
        STH     R1,ICRMS2               :compare against smo len
        AIS     R4,0A                   :make room for RMOseq
        CLHI    CHN,100                 :need extra for larger chn#
        JLFS    ICRS10
        AIS     R4,1                    :chn# requires 2 bytes
ICRS10  JAL     R9,X4BWLN,,             :write new length
        LA      R4,NCRSHD               :address of NCRM header for ICRS
        CLHI    CHN,100
        JLFS    ICRS12
        LA      R4,NCRLHD               :NCRM RMO, bits and org port ID&len
ICRS12  JAL     R9,BUFCAN
        GL      BUFCAN
        LR      R1,CHN
        CLHI    CHN,100                 :two bytes of writing?
        JLFS    ICRS14                  :nope
        JAL     R9,WHWI                 :write two byte CHN
        JFS     ICRS15
ICRS14  JAL     R9,WCIE                 :write one byte CHN#
ICRS15  LA      R4,NCRMTL               :then come NCRM flags
        JAL     R9,BUFCAN

:       check for SMOset and compare it's length vs msg length
        JAL     R9,X4DGCH               :get SMO id
        CLHI    R1,SMOID                :SMOID is 30
        JN      ICRSR2
        JAL     R8,WCI                  :write it
        JAL     R13,X4DGLN              :length of SMO
        LR      R1,R4
        SR      R1,PRC
        CLH     R1,ICRMS2               :SMOset end same place as ICRS element
        JN      ICRSR2                  :error, reject
        JAL     R9,X4BWLN,,             :write len back to buffer
        gl      x4bwln

:       now ready for just copy from ring into buffer
:       Also, point of entry for subsequent pieces

ICRS60  LB      R1,DORNG,PRD,           :copy rest of data
        JAL     R9,WCIE
        AIS     PRD,1
        NR      PRD,TC                  :this a just X4DGCH but faster
        SIS     PRC,1
        JGBS    ICRS60

:       setup to handle partial
        LHL     R0,ICRMSB               :get back ICRS msg flags
        THI     R0,L2F.PT
        JN      DSOIRP                  :still waiting for end of ICRS
        LHI     R1,LOGXMT               :tell logger we are ready to send
        STH     R1,BF,R2,
        J       DSOIRP                  :return to mainline

ICRS90  JAL     R9,XCRM 
        SKIPAD(ICRS94)                  :if error
        J       ICRM98                  :set BF for XCRM (not yet sent to SP

ICRS94  LB      R6,ICRSTB,R5            :convert error code
        J       ICRSRJ

ICRSTB  BC      0,0,0,0,0,5,4,0,4       :cir min host and bad XCRM form
        HS      0


:       handle case of NC found bad form.
:       do it by sending RCRI with reject reason back to slot,
:       followed by the detach msg, and send a zapper towards LOGGER
:       LOGGER will take the zapper, convert it for DISLG2 ports into
:       a NCRM with a log zap smo.  LEP will get the RCRM with the log
:       zap ack and then we clean out port and buffers.

ICRSR0  LIS     R6,0                    :reject, they didn't wait for RCRI
        J       ICRSRJ

ICRSR1  LIS     R6,1                    :started as LOG 1 and sent log 2
        JFS     ICRSRJ

ICRSR2  LIS     R6,2                    :bad form

:       for a ICRS reject we clear the offending msg from our buffer
:       and send error back to the port. (as if nothing happened).
ICRSRJ  AR      PRD,PRC                 :eat whatever left of msg
        JAL     R8,CBCLR                :clear msg (whatever written)
        LHL     R7,DRIF,,               :get ring pointer
        STH     CHN,DIRNG,R7,           :write chn #
        LHI     R0,ISRCRI^8             :type C3 RCRI
        STH     R0,DIRNG+2,R7,
        AIS     R7,4
        NR      R7,TC
        LIS     R1,0                    :setup to send reject msg
        JFS     RCRIJ2
RCRIJ1  AIS     R7,1
        NR      R7,TC                   :bump up pointer
RCRIJ2  LB      R0,ICRSRM,R1            :get fixed part of msg
        STB     R0,DIRNG,R7,
        AIS     R1,1                    :offset into msg
        CLHI    R1,ICRSRZ               :done with it?
        JLEBS   RCRIJ1                  :nope, get another
        STB     R6,DIRNG,R7,            :reject reason
        AIS     R7,1+3                  :1 for byte written, 3 for end of msg
        NHI     R7,DRSZ-4               :finished with msg
        STH     R7,DRIF,,               :store ring pointer
        J       DSOIRP



::*****************************************************************
:       XCRM    subroutine which processes the X.409 IcRM msg.
:               skip +4 return if all ok,  normal if error and error
:               code in R6.  code expects len in PRC, pos in PRD and
:               buffer in R2, dispi chn # in r5
::*****************************************************************


XCRM    ST      R9,ICRMS3
XCRM01  LB      R1,DORNG,PRD,           :copy data into buffer for parsing
        JAL     R9,WCIE
        AIS     PRD,1
        NR      PRD,TC                  :this a just X4DGCH but faster
        SIS     PRC,1
        JGBS    XCRM01

        LHL     R0,ICRMSB               :is there more to come?
        THI     R0,L2F.PT               :not done yet bit
        JN      XCRM99

        JAL     R8,X4CRIZ,,             :initialize mo create table
        L       R3,BB,R2,
        ST      R3,ELEPOS               :setup primitive X.409 parse routines
        LIS     R0,2
        JAL     R9,X4NXID,,             :get ICRM id
        LHI     R4,IDNCRM+MO.AC2
        JAL     R8,X4CCID,,             :enter the constructor
        JAL     R9,X4NXID,,             :Parse out RMO
        LHI     R4,RMOID
        JAL     R8,X4CCID,,             :then comes RMO construction
        LR      R1,CHN
        LHI     R4,ID.PRT+MO.A1         :first comes our port number
        JAL     R8,X4CRID,,             :enter into create table
        GL      X4CRID
        JAL     R9,X4NXID,,             :get ICRM flags
        LR      R4,R3                   :save pointer to start of data
        CLHI    R0,2                    :only worry unused bits for first byte
        JGFS    XCRM05
        LB      R0,0,R3                 :get unused bits
        JNFS    XCRM03                  :Not escaped
        JAL     R8,NCI
        LB      R0,0,R3
XCRM03  SIS     R0,6                    :indicate at least 2 bits in use
        JLEFS   XCRM05                  : since we use bit 1
        LIS     R0,6                    :mark that bit 1 is used
        STB     R0,0,R3
XCRM05  LR      R3,R4
        JAL     R9,PCIE                 :skip over byte of unused bits
        LB      R0,0,R3                 :the first byte of bits
        JNFS    XCRM07
        JAL     R8,NCI
        LB      R0,0,R3                 :in case escaped
XCRM07  NHI     R0,@L2F.SQ              :make sure subsequent bit is reset
        STB     R0,0,R3
        RBT     CHN,DISAUX              :guess not aux request
        THI     R0,L2F.AX               :aux cir request?
        JEFS    XCRM10                  :not aux request
        LH      R0,ICRMSB               :get back our saved bits
        THI     R0,L2F.DL               :aux request have dispatcher license?
        JE      XCRMX6                  :nope, reject
        SBT     CHN,DISAUX              :set aux bit
XCRM10  LHL     R0,X4NXVL+2             :get len of buffer data
        LR      R3,R4                   :get address of start of buffer data
        LHI     R4,ID.NMF+MO.A2         :NCRM flags are known okay
        JAL     R8,X4CBID,,             :write element with data in buffer
        GL      X4CBID

        JAL     R9,X4NXEL,,             :move upto end of flags element
        GL      X4NXEL,X4NXID
        JAL     R9,X4NXID,,             :parse OHOST id element
        LHI     R4,ID.OHS
        CLB     R4,X4NXVL+1             :make sure is OHOSt id
        JN      XCRMX8                  :error if not
        LHI     R4,ID.OHS+MO.A1
        JAL     R8,X4CBID,,             :put it into create table
        L       R3,ELEPOS               :adress of x.409 data
        JAL     R7,X4GTNM,,
        GL      X4GTNM
        STH     R4,DORHST               :save host number
        STH     R4,DHSTIX,CHN,CHN       :for tracing
        LR      R13,R2                  :save our buffer #
	IF	RESHST
	LCS	HN,1			:IF NEGATIVE, HOST NOT FOUND,SEE DSZ07C
	LR	R1,R4
	JE	XCRM13			:HOST 0 NOT DEFINED
	JAL	R9,FNDHST,,		:DO WE KNOW ABOUT THIS HOST?
	SKIPAD(XCRM13)			:immed, NO - SKIP ORIGIN HOST EDIT#wjl
	LH	R0,HCTSM,HN,HN		:+4, GET CIRCS/MIN LIMIT FOR THIS HOST
	JLFS	XCRM13			:NO EDITING DESIRED
	CLH	R0,HCTSCT,HN,HN		:LIMIT EXCEEDED?
        JGFS    XCRM13                  :okay to attempt circuit build
        JLFS    XCRM14                  :only report when just reach limit
        JAL     R7,DSZT95		:report limit exceeded
XCRM14	LIS	R5,5			:ECRI reason 5 for log 2
        J       XCRMRG
	EI	:RESHST

XCRM13  LR      R2,R13                  :get back buffer #

        JAL     R9,X4NXEL,,
        JAL     R9,X4NXID,,             :Get CCT id
        LHI     R1,ID.CCT
        CLB     R1,X4NXVL+1             :was that the found ID?
        JN      XCRMX8
        LHI     R4,ID.CCT+MO.A1         :cct ID
        JAL     R8,X4CBID,,
        JAL     R8,X4FXCN,,             :finished with RMO constructor

        JAL     R9,X4NXEL,,
        JAL     R9,X4NXID,,             :get to SMOset ID
        LHI     R1,SMOID&1F             :test if ID correct
        CLB     R1,X4NXVL+1
        JN      XCRMX8
        LHI     R4,SMOID
        JAL     R8,X4CBID,,             :do like a huge element
        JAL     R8,X4FXCN,,             :finished with NCRM constructor

        JAL     R8,CBCCT
        LR      R13,R1
        JAL     R8,X4CBWR,,             :write NCRM into buffer
        GL      X4CBWR
        LR      R0,R13
        JAL     R8,RTBFTS               :eveything before NCRM
        GL      RTBFTS
       IF       RESHST                  :count for hosts with restrictions
        LIS     R1,1
        LR      HN,HN                   :host known to us?
        JLFS    XCRM54
        AHM     R1,HCTSCT,HN,HN
XCRM54
       EI

XCRM99  L       R9,ICRMS3               :get link register
        J       4,R9                    :successful XCRM msg

XCRMX8  LIS     R5,8
        JFS     XCRMRG

XCRMX6  LIS     R5,6
XCRMRG  L       R9,ICRMS3               :got error codes, now return
        SKIP(0,R9)

       EI       :LOGII

       EI       :1-T2GATE  (began before ICRM)


::*********************************************************************
::
::	TABLE:		DSOMTB:
::	FUNCTION:	DISPATCH TABLE FOR PORT SIGNALS FROM ISIS
::	NOTE: SYMBOL SEG1.1 IS DEFINED AT BEGINNING OF DISOUT TO ALLOW
::	ROUTINE ADDRESS TO BE STORED AS HALF-WORDS
::
::*********************************************************************

DSOMTB	HC	DSODET-SEG1.1	:9E - DETACH				###wjl
				:ISIS makes 9E into YB, wait for OB, ZAP.
	HC	DSOZAP-SEG1.1	:9F - ZAPPER
	HC	DSOSBP-SEG1.1	:A0 - SET BACKPRESSURE
	HC	DSORBP-SEG1.1	:A1 - RELEASE BP
	HC	DSOGOB-SEG1.1	:A2 - GOBBLER
	HC	DSOIRP-SEG1.1	:A3 - REVERSE GOBBLER (UNUSED)
	HC	0FD01		:A4 - BLACK BALL
	HC	0FC01		:A5 - GREY BALL
	HC	07		:A6 - EDEM
	HC	04		:A7 - LDEM
	HC	0F201		:A8 - ENTER TRM
	HC	0F301		:A9 - LEAVE TRM
	HC	05		:AA - GREEN BALL
	HC	06		:AB - RED BALL
	HC	0FF01		:AC - YELLOW BALL
	HC	0FE01		:AD - ORANGE BALL
	HC	0FB01		:AE - BREAK DETECTED
	HC	0F001		:AF - HANG UP
	HC	DSOQPR-SEG1.1	:B0 - QUERY PARAMETER
	HC	DSOSPR-SEG1.1	:B1 - SET PARAMETER
	IF	T2GATE
        GL      GDB2,GDB4,GDB5,GDB6
	HC	GDB2-SEG1.1	:B2 - PSEUDO NEEDLE 
	HC	DSOCRH-SEG1.1	:B3 - LOGON CHAR
	HC	GDB4-SEG1.1	:B4 - LOGON STATUS 
	HC	GDB5-SEG1.1	:B5 - LOGON FAILURE 
	HC	GDB6-SEG1.1	:B6 - SUCCESSFUL LOGON 
	HC	DSOCRH-SEG1.1	:B7 - ADDENDUM TO ACCOUNTING
	ELSE
	HC	DSOCRH-SEG1.1	:B2 - PSEUDO NEEDLE (ILLEGAL)
	HC	DSOLGC-SEG1.1	:B3 - LOGON CHAR
	HC	DSOCRH-SEG1.1	:B4 - LOGON STATUS (ILLEGAL)
	HC	DSOCRH-SEG1.1	:B5 - LOGON FAILURE (ILLEGAL)
	HC	DSOCRH-SEG1.1	:B6 - SUCCESSFUL LOGON (ILLEGAL)
	HC	DSZACC-SEG1.1	:B7 - ADDENDUM TO ACCOUNTING
	EI	:T2GATE
	HC	DSOHNG-SEG1.1	:B8 - SUPERHANG
	HC	DSOSXL-SEG1.1	:B9 - SET XMIT LIMIT
	HC	DSOIRP-SEG1.1	:BA - END OF BREAK
	HC	DSOZAK-SEG1.1	:BB - ZAP ACK
	HC	0F401		:BC - ENTER ALTERNATE DEVICE MODE
	HC	0F501		:BD - LEAVE ALTERNATE DEVICE MODE
	HC	DSOZWR-SEG1.1	:BE - ZAP WITH REASON
	HC	0F601		:BF - ENTER IIX EXCHANGE
	HC	0F701		:C0 - LEAVE IIX EXCHANGE
      IF       LOGII           :only legal if LOG II
       IF       1-T2GATE        :different list for gateway
	HC	DSOCRH-SEG1.1	:C1 UUN (never received by NC)
	HC	DSOCRH-SEG1.1	:C2 ISN (never received by NC)
	HC	DSOCRH-SEG1.1	:C3 RCRI (never received by NC)
	HC	ICRS-SEG1.1	:C4 ICRS (more LOGII logon data)
       ELSE      :1-T2GATE  :gateway's list of ISIS msgs
        HC      DSOCRH-SEG1.1   :C1 UUN (never received by gateway)
        HC      GDISN-SEG1.1    :C2 ISN (LOG II needle in for gateway)
        HC      GDRCRI-SEG1.1   :C3 RCRI (circuit building status)
        HC      DSOCRH-SEG1.1   :C4 ICRS (logon data msg never received by gate
        HC      GDASLP-SEG1.1   :C5 ASLP (assigns logon port)
        HC      GDLGSC-SEG1.1   :C6 LGSC (logon successful)
        GL      GDRCRI,GDASLP,GDLGSC
       EI       :1-T2GATE
      EI       :LOGII
DSODMX	EQ	(.-DSOMTB)/2

::*********************************************************************
::
::	TABLE:	DSOMBA:
::	FUNCTION:	
::
::	THE FOLLOWING BIT ARRAY INDICATES WHICH DSOMTB ENTRIES CONTAIN
::	THE ACTUAL MAPPING CHARACTERS, AND WHICH HAVE ROUTINE ADDRESSES TO
::	HANDLE THE MAPPING FUNCTION. THE ARRAY IS RELATIVE TO MESSAGE TYPE
::	9E, AND THE ONE BITS REPRESENT ENTRIES WHICH CONTAIN THE CHARACTER.
::
::*********************************************************************

DSOMBA	BC	03	:9E-A5
	BC	0FF	:A6-AD
	BC	0C0	:AE-B5
	BC	03	:B6-BD
	BC	60	:(BE-C5) BIT ARRAY FOR 'TRIVIAL CONVERSION'

::*********************************************************************
::
::	TABLES:		TQPR,  TSPR,  TSPRM.
::	FUNCTION:
::
::	THE FOLLOWING 3 TABLES ARE ARRANGED IN ISIS MESSAGE ORDER
::	AND ARE USED TO TRANSLATE 'SET TERMINAL' TYPE MESSAGES
::
::*********************************************************************

:	QUERY TERMINAL PARAMETERS
TQPR	BC	0A0,0A2,0A6,0A4	:DSOQPR TABLE
	BC	0AE,093,098,0AA
	BC	0A8,097,096,095
	BC	0AC,0B0,0B2,094
	BC	0B4,0B6,0B8,0BA
	BC	0,0,0,0		:ADDITIONAL 0'S FOR FILLER ONLY
	BC	0,0,0,0
	BC	0,0,0,0

:	SET TERMINAL PARAMETERS
TSPR	BC	0C0,0C2,0C6,0C4	:DSOSPR TABLE
	BC	0CE,030,080,0CA
	BC	0C8,070,060,050
	BC	0CC,0D0,0D2,040
	BC	0D4,0D6,0D8,0DA
	BC	0,0,0,0		:ADDITIONAL 0'S FOR FILLER ONLY
	BC	0,0,0,0
	BC	0,0,0,0

TSPRM	BC	01,01,01,01	:DSOSPR MASKS
	BC	01,0F,0F,01
	BC	01,0F,0F,0F
	BC	01,01,01,0F
	BC	01,01,01,01
	BC	01,01,01,01	:ADDITIONAL 01'S FOR FILLER ONLY
	BC	01,01,01,01
	BC	01,01,01,01

	SUBTTL	DISPI (DSZERO - Intra-ISIS Comunications, RPORT = 0)

::*********************************************************************
::
::	SUBROUTINE:	DSZERO:
::	FUNCTION:	PROCESS COMMANDS ON CHANNEL 0.
::			INTRA-ISIS COMUNICATIONS.
::
::*********************************************************************

DSZERO	LB	R1,DORNG+2,PRD,		:CHANNEL ZERO MESSAGE, GET TYPE
	CLHI	R1,DSZETL		:TEST NOT NECESSARY IF ISIS WORKING OK
	JLFS	DSZER1
	CRASH.(.DSZE0)
DSZER1	SLLS	R1,2			:FW indexing			###wjl
	L	R1,DSZETB,R1,		:DISPATCH			###wjl
	JR	R1			:				###wjl

::*********************************************************************
::
::	SUBROUTINE:	DSZTLG:
::	FUNCTION:	07 - PSEUDO NEEDLE REQUEST
::			NORMAL CIRCUIT-BUILDING REQUEST
::
::*********************************************************************
	IF	(1-T2GATE)		:Not used for Gateway
DSZTLG	IF	TUNL							###AL
	LR	R10,PRD			:TRUNCATE PRD
	AIS	R10,8
	NR	R10,TC
	LHL	R1,DORNG,R10,		:CHECK REQ. HST# FOR TUNNEL
	LHI	R6,(NMTNLS-1)*4		:COMPARE TO EACH X25HST IN KD
	JL	DZ07T4			:SKIP IF NO TUNNELS
DZ07T1	L	R11,TNLPTR,R6,		:KD TABLE, TYC=R11 IS NOT USED HERE
	CLH	R1,X25HST,R11
	JE	DZ07T2			:FIND THE MATCHED ONE, CONTINUE
DZ07TA	SIS	R6,4			:NEXT?
	JGBS	DZ07T1
	J	DZ07T4			:FOR OTHER SLOT HOST REQUEST
DZ07T2	LHL	R1,TNCHN,R11		:IN CASE, 2ND TUNNEL WITH SAME X25HST
	JNBS	DZ07TA			:SKIP THE 1ST ONE
	LIS	R1,DEDBAK		:IF BACKUP TUNL LINK, OPEN PARAMETERS
	TBT	R1,TNSTAT,R11
	JEFS	DZ07T3
	LB	R1,KTYP,R11		:IF KTYP IS TUNNEL, NO SWAP
	CHI	R1,TNLTYP
	JEFS	DZ07T3
	JAL	R8,TNBSWP,,
	GL	TNBSWP
DZ07T3	LH	R1,SLOWC+2,,		:SET UP LOGIN TIMER WHEN SEND B2
	AHI	R1,TNLTMR
	STH	R1,TNLGTM,R11
	LHL	R1,TVRBUF		:CHECK SUP
	JN	DZ07T4			:CONTINUE IF SUP
	JAL	R10,DSZATN		:SET UP FOR ISIS MSG
	GL	DSZATN
	LHI	R1,NDP-1		:FIND A DISPATCHER PORT
	LHI	CHN,DISZFL+1
	JAL	R9,FNDCHN,,
	GL	FNDCHN
	SKIPAD(DSZ07B)			:REJECT IF NOT FOUND
	JAL	R8,GFCBUF,,		:SET UP LOGIN BUFFER
	SKIPAD(DSZ07B)			:REJECT IF NO BUFFER
	STH	R2,IOTAB,CHN,CHN	:PUT INTO DIOTAB
	RBT	CHN,ACP,,		:CHANNEL NOW ACTIVE
	LCS	R0,1
	SR	R0,CHN			:COMPUTE NEGATIVE ACP
	RBT	R0,ACP,,		: INDICATE ACTIVE PORT
	LHI	CHN,-DISZFL,CHN		:USE RELATIVE CHN
	LHI	R10,18			:NO SUP, BF=18X FOR TUNNEL LOGIN
	STH	R10,BF,R2,
	J	DSZ07C			:SEND ISIS B2 MSG
DZ07T4	EI	:TUNL
	JAL	R10,DSZATS		:NORMAL CIRCUIT REQUEST - SET UP
	SKIPAD(DSZ07B)			:IMMED, SOME FAILURE (SEE DSZATS)###wjl
	LHL	R1,DORHST		:+4, GET HOST NUMBER (SET UP IN DSZATS)
	OHI	R1,8000			:PREPARE FOR SUP MESSAGE
	JAL	R9,WHWI			:WRITE INTO LOGIN BUFFER
	GL	WHWI
	LB	R1,DORNG,PRD,		:GET THE TID
	JAL	R8,WCI			:SEND IT TO THE LOG ON BUFFER
	LR	R0,R1			:GET TID FOR LOGIN ROUTINE
	JAL	R8,LOGIN
	GL	LOGIN
	SKIPAD(DSZ07B)			:immed return, NO SUP, ZAP IT	###wjl
	LH	R0,DORSIQ		:+4, SEE IF SIQ SET FOR THIS CIRCUIT
	JGEFS	DZ0710			:NO
:	CIRCUIT HAS SIQ SET, IS 'SMART'. SET GOUGING BIT IN IOTAB FOR
:	THIS CIRCUIT SO LOGGER CAN INFORM SUP OF SMART CIRCUIT.
	XHI	R2,4
	LHL	R4,BF,R2,		:GET ORIGINATION CHANNEL
	LHL	R1,IOTAB,R4,R4
	AIS	R1,1			:'GOUGING' BIT FOR PORT IN LOGIN MODE
	STH	R1,IOTAB,R4,R4		: MEANS SMART CIRCUIT

DZ0710	HS	0
	SHI	CHN,DISZFL		:RELATIVE PORT #
					:RELATIVE DISPI CHANNEL #
       IF       LOGII                   :note that dispi chn is LOGI
        RBT     CHN,DISLG2              :not a LOG II login attempt
       EI       :LOGII                  :
	RBT	CHN,DISELS		:EXTENDED LOG-IN STATUS
	THI	R0,PSNELS		:TEST ELS BIT
	JEFS	DZ0711			:NO
	SBT	CHN,DISELS		:else set bit in ELS bit array
DZ0711	IF	EXPNDL
        RBT     CHN,DISUUN              :NSR #1667 reset so if not requested
                                        :it is not set                  ###sdw
	THI	R0,PSNUUN		:did slot request UUN from sup?
	JEFS	DZ0713			:branch if not
	SBT	CHN,DISUUN		:else set bit in UUN bit array
DZ0713	EI	:EXPNDL
	RBT	CHN,DISAUX		:INDICATE NORMAL LOGON

:	PSEUDO NEEDLE REQUEST O.K. AND CHANNEL ASSIGNED. RETURN
:	PSEUDO NEEDLE TO REQUESTING SLOT.
DSZ07C	HS	0
	LHL	R1,HNPORT		:INCREMENT NUMBER OF HOST PORTS IN USE
	AIS	R1,1
	CLH	R1,MXPORT		:IS THIS A NEW PEAK?
	JLEFS	DSZMPX			:NO
	STH	R1,MXPORT		:YES, RECORD IT
DSZMPX	STH	R1,HNPORT
	LH	R1,DORHST		:GET ORIG. HOST #
	STH	R1,DHSTIX,CHN,CHN	:SAVE IT FOR PROBE TRACE REPORTING
	LHI	R1,0B2			:'B2' MESSAGE - PSEUDO NEEDLE

DSZ07A	LHL	R6,RPSAV		:POINTS TO START OF MESSAGE
	STB	R1,DIRNG+2,R6,		:MESSAGE TYPE (0B2 OR OTHER)
	STH	CHN,DIRNG,R6,		:RELATIVE DISPI CHANNEL #
	AIS	R6,8
	NR	R6,TC			:UPDATE POINTER
	STH	R6,DRIF,,
	LHL	R8,DORSLT		:CIRCUIT ORIGINATING SLOT (SLOT# * 2)
	LIS	R1,1
	AHM	R1,SCLCNT-2,R8		:INCREMENT NUMBER OF CIRCUITS THIS SLOT
	IF	RESHST
	LR	HN,HN			:IS THIS HOST KNOWN TO US?
	JL	DSOIRP			:NO - EXIT
	AHM	R1,HCTSCT,HN,HN		:INCREMENT NUMBER OF CIRCUITS THIS HOST
	EI	:RESHST
	J	DSOIRP			:ALL DONE

:	REJECT LOGON
DSZ07B	LIS	R1,9			:REJECT LOGON (RETURN TYPE '9')
	LIS	CHN,0			:CHANNEL 0 MESS
	J	DSZ07A

::*********************************************************************
::
::	SUBROUTINE:	DSZALG:
::	FUNCTION:	08 - AUX CIRCUIT REQUEST
::
::*********************************************************************

DSZALG	JAL	R10,DSZATS		:AUX CIRCUIT REQUEST - SET UP
	SKIPAD(DSZ08C)			:IMMED, FAILURE, REJECT		###wjl
	IF	1-MXPNM			:MXP DISPATCHER CHECKS AUX CIRC LICENSE
	THI	R7,8000			:TEST SLOT LICENSE FOR AUX STATUS
	JE	DSZNAL			:NO AUX LICENSE, ABORT LOGIN
	EI	:1-MXPNM
	LB	LRC,DORNG,PRD,		:# CHARS IN STRING
	AIS	PRD,1			:START OF STRING
DSZ08A	LB	R1,DORNG,PRD,		:MOVE STRING
	AIS	PRD,1
	NR	PRD,TC
	OHI	R1,80			:ESCAPE ALL
	JAL	R8,WCI
	SIS	LRC,1
	JGBS	DSZ08A
:	IF LAST BYTE NOT CR OR SEMI-COLON, APPEND CR TO USER NAME
	CLHI	R1,8D			:= <CR> ?
	JEFS	DSZ08B			:YES, GO AHEAD
	CLHI	R1,0BB			:= "SEMI-:" ?
	JEFS	DSZ08B			:YES, GO AHEAD
	LHI	R1,8D			:APPEND A <CR> TO
	JAL	R8,WCI			: THE LOG IN STRING
DSZ08B	HS	0
	LIS	R0,0			:INITIATE LOGIN - AUX MODE
	JAL	R8,LOGIN
	SKIPAD(DSZ07B)			:immed ret, NO SUP, REJECT LOGON###wjl
	SHI	CHN,DISZFL		:+4 return, RELATIVE PORT #
	SBT	CHN,DISAUX		:INDICATE AUX LOGON
	J	DSZ07C

DSZNAL	JAL	R9,ZAPHRD,,		:ZAP HALF-CIRCUIT ALREADY BUILT FOR
:	SLOT WHICH ATTEMPTED AUX CIRCUIT WITHOUT PROPER LICENSE

DSZ08C	LB	LRC,DORNG,PRD,		:REJECT, SKIP TO END OF MESS
	AHI	PRD,1,LRC
	J	DSZ07B			:AND REJECT LOGON

::*********************************************************************
::
::	SUBROUTINE:	DSZATS:
::	FUNCTION:	SETUP ROUTINE FOR CIRCUIT REQUEST
::	CALLING SEQ:	JAL	R10,DSZATS
::	RETURNS:	IMMEDIATE - reject
::			+4 - ok
::
::*********************************************************************

DSZATS	HS	0
	LIS	R0,8			:SET UP TO RETURN NEEDLE OR REJECT
	JAL	R8,DIROOM
	LHL	R6,DRIF,,		:INPUT RING POINTER
	STH	R6,RPSAV		:SAVE IT FOR FILLING IN LATER
	LB	R8,DORNG+3,PRD,		:KEY (SLOT NUMBER * 4)
	STB	R8,DIRNG+3,R6,
	IF	MXPNM			:ISIS-MXP EXPECTS A DIFF KEY 	###GT
					: ( = SLOT #, MACHINE #)	###GT
	SLLS	R8,4			:SHIFT LO 4 BITS TO UPPER 4 BITS###GT
	EXBR	R7,R8			:MOVE UPPER 4 BITS TO LO 4 BITS	###GT
	OR	R8,R7			:FORM A SLOT # (MACH #, SLOT #)	###GT
	NHI	R8,0FF			:SAVE LOWER BYTE		###GT
	SLLS	R8,1			:FORM HALFWORD INDEX		###GT
	ELSE				:OLD-FASHIONED ISIS HAS KEY=SLOT # * 4
	SRLS	R8,1
	EI	:MXPNM			:MXP DIFFERENCE ENDS HERE
	STH	R8,DORSLT		:SAVE SLOT NUMBER * 2
	AIS	R6,4
	NR	R6,TC
	AIS	PRD,4
	NR	PRD,TC			:NOW POINTS TO LOCAL KEY
	LHL	R1,DORNG,PRD,		:KEY
	STH	R1,DIRNG,6,
	LHL	R1,DORNG+2,PRD,		:HI-ORDER BIT OF 'DIALECT' FIELD
	STH	R1,DORSIQ		: IS SIQ
	LIS	R1,0
	STH	R1,DIRNG+2,6,
	AIS	R6,4
	NR	R6,TC			:PUT AWAY POINTER
	AIS	PRD,4			:POINT PRD TO ORIGINATING HOST #
	NR	PRD,TC
	LHL	R1,DORNG,PRD,		:GET ORIGINATING HOST,
	STH	R1,DORHST		: AND SAVE FOR 'LOGIN'
	AIS	PRD,2			:PRD NOW POINTS TO TID OR BYTE COUNT
        JAL     R7,DSZT80               :check circuits/min for slot/host###sdw
        SKIPAD(DSZEXI)                  :(immediate return) rejected    ###sdw
	LHI	R1,NDP-1		:FIND A FREE CHANNEL
	LHI	CHN,DISZFL+1
	JAL	R9,FNDCHN,,
	GL	FNDCHN
	SKIPAD(DSZEXI)			:(immediate return) REJECT	###wjl
	JAL	R8,GFCBUF,,		:(+4 return) GET BUFFER  
	SKIPAD(DSZEXI)			:(immediate return) REJECT	###wjl
	JAL	R9,CRQHCR,,		:(+4 return) BUILD HALF CIRCUIT
	LHI	R1,-DISZFL,CHN		:R1 = REL. DISPI CHN #
	SBT	R1,DISBPV		:RELEASE BP
	LHI	R0,INXLIM
	STH	R0,DIXLIM,R1,R1		:TRANSMIT LIMIT PER PORT.
       IF       1-MXPNM                 :return with license in r7
        LHL     R8,DORSLT
        SLLS    R8,1
        LHL     R7,SLTLIC,R8            :get slot license
       EI
	J	4,R10			:ALL OK


:       subroutne linking on R7 to checks host and slot circuits/min limits
:       enterred at either dszt80 or  dszt90

DSZT80                                  :Make circuits/min a subroutine
	IF	RESHST
	LCS	HN,1			:IF NEGATIVE, HOST NOT FOUND,SEE DSZ07C
	LR	R1,R1
	JE	DSZT90			:HOST 0 NOT DEFINED
	JAL	R9,FNDHST,,		:DO WE KNOW ABOUT THIS HOST?
	SKIPAD(DSZT90)			:immed, NO - SKIP ORIGIN HOST EDIT#wjl
	LH	R0,HCTSM,HN,HN		:+4, GET CIRCS/MIN LIMIT FOR THIS HOST
	JLFS	DSZT90			:NO EDITING DESIRED
	CLH	R0,HCTSCT,HN,HN		:LIMIT EXCEEDED?
        JG      4,R7                    :okay to attempt circuit build
        JE      DSZT96			:report limit exceeded
	SKIP(0,R7)
	EI	:RESHST
DSZT90	LHL	R1,DORSLT
	LH	R0,SCLTBL-2,R1		:GET LIMIT FOR CIRCS/MINUTE THIS SLOT
	JL	4,R7			:NO CHECKING DESIRED
	CLH	R0,SCLCNT-2,R1		:LIMIT EXCEEDED?
        JG      4,R7                    :limit not exceeded
        JEFS    DSZT96
        SKIP(0,R7)

DSZT96	OHI	R1,8000
	STH	R1,SUPMBF+4		:HOST NUMBER + 8000
        LHL     R8,DORSLT
	SRLS	R8,1
	OHI	R8,8000			:SLOT NUMBER + 8000
	STH	R8,SUPMBF+2
	LHI	R8,NR.CLE
	STH	R8,SUPMBF		:INDICATE HOST/SLOT CIRC LIMIT EXCEEDED
        LR      R6,R10                  :save R10
	JAL	R10,SUP12,,		:MAKE REPORT TO SUP LOG
        LR      R10,R6
        SKIP(0,R7)                      :Done with report to SUP


DSZEXI	SKIP(0,R10)			:immediate return		###wjl

	EI	:(1-T2GATE)		: All of above not used for Gateway

::*********************************************************************
::
::	SUBROUTINE:	DSZHSH:
::	FUNCTION:	10 - EXTENDED REPORT HOST STATUS
::	FORMAT:
::		--------.-------.-------.--------
::		|	0       |  10   |  key  |
::		|-------.-------.-------.-------|
::		|  Host number  | number/ports  |
::		|-------.-------.-------.-------|
::		|    RH No.     |status | H key |
::		|-------.-------.-------.--------
::		|xstatus|  PID |
::		-----------------
::	Status currently specifies these parameters:
::		The low 2 bits specify one of 4 host states:
::			0	host answered
::			1	host down
::			2	host shut (but up)
::			3	host gone
::		The next bit (mask x04) specifes if H key is meaningful.
::              The high order bit (mask x80) specifies if this is a LOG II
::              capable host.
::
::	Xstatus, the eXtended status byte currently specifies:
::		I O D P C C 0 0
::		I	Host I/Q (HIQ)
::		O	Originate only
::		D	Destination only
::		P	Proxy host
::		C C	Collect-call capability:
::			0	never accept collect calls
::			1	only accept collect calls
::			2	leave the decision to the destination host
::			3	unused
::		0 0	Unused
::	MESSAGE FROM HOST WHICH INCLUDES HOST STATUS, HIQ, AND HID.
::	HOST STATUS PROCESSING IS THE SAME AS FOR THE TYPE 04 ISIS
::	MESSAGE FOR REPORTING HOST STATUS ONLY.  THE CELL 'DSOHYP' IS
::	SET TO -1 FOR TYPE 10 MESSAGE, 0 FOR TYPE 04 MESSAGE SO COMMON
::	LOGIC CAN BE USED.
::
::	THE NODE-TO-SUPERVISOR MESSAGE, TYPE 11, MAY INCLUDE HOST STATUS,
::	HIQ, AND HID.  THE FORMAT OF THE FIRST HALFWORD OF THE MESSAGE
::	INDICATES THE MESSAGE CONTENTS TO THE SUPERVISOR. THE FIRST HALFWORD IS
::			[11,X0+STATUS],
::	WHERE X IS DEFINED BY THE FOLLOWING EQUATES:
::
::*********************************************************************

HS.ANS	EQ	0	:host answered
HS.DWN	EQ	1	:host down
HS.SHT	EQ	2	:host shut (but up)
HS.GNE	EQ	3	:host gone

HS.HID	EQ	80	:HID PRESENT IF 0.  6-BYTE MSG WITH HID, ELSE 4 BYTES.
HS.SET	EQ	40	:SET IF HS.HID NOT SET (TO PREVENT ESCAPING)
HS.STS	EQ	20	:IGNORE HOST STATUS BITS IF 1 (NO CHANGE IN STATUS)
HS.HIQ	EQ	10	:HIQ FLAG.  SMART HOST IF 1, ELSE DUMB.

	IF	(1-T2GATE)		:Gateway will not receive following

DSZHSH	HS	0			:INDICATE PROCESSING TYPE 10 MESSAGE
	TS	DSOHYP			:this message from slot has extra hw
	JFS	DZHS02			: containing HIQ & HID data for host

::*********************************************************************
::
::	SUBROUTINE:	DSZHST:
::	FUNCTION:	04 - REPORT HOST STATUS
::
::*********************************************************************

DSZHST	HS	0
	LIS	R2,0			:INDICATE PROCESSING TYPE 04 MESSAGE
	STH	R2,DSOHYP

:	COMMON LOGIC FOR TYPE 10 AND 04 MESSAGES

DZHS02	LB	R2,DORNG+3,PRD,		:SAVE KEY IN R2
	AIS	PRD,4
	NR	PRD,TC			:REPORT HOST STATUS
	LHL	R1,DORNG,PRD,		:HOST #
	JAL	R9,FNDHST,,		:LOCATE HOST ENTRY
	SKIPAD(DZHS50)			:NO ENTRY IN HOSTN TABLE.  MAKE ONE.

:	Found the host in HOSTN.  VERIFY THAT THE HOST KEY (4*SLOT #) MATCHES.
	CLB	R2,HSTKEY,HN		:+4 return
	JE	DZHS04			:BRANCH IF KEY MATCHES

	LB	R0,HSTAT,HN		:KEY DOESN'T MATCH. INCUMBENT HOST DWN?
	SIS	R0,1			:status 1 is "down"
	JE	DZHS03			:yes, host down			###wjl
	TBT	HN,HSTFLG		:reporting for the first time?	###wjl
	JN	DZHS70			:NO, REJECT THE PRETENDER

:	Old host coming up in new slot, but OK because old host is down or
:	host is reporting for the first time.  Do not report as "imposter" host
	LIS	R0,0			:				###wjl
DZHS03	STH	R0,HOSTN,HN,HN		:clear HOSTN table entry for old host
	STB	R0,HSTAT,HN		:clear host status		###LH

:	CLEAR EXPANDED HOST STAUTS FIELDS
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	STB	R0,HSTATN,HN		:clear expanded host status entry###LH
	SLLS	HN,1			:FORM FW INDEX INTO		###OAS
	ST	R0,HSTTIM,HN,HN		:HOST TIME ARRAY AND clear it.	 ###LH
	SRLS	HN,1			:RESTORE HN			###OAS

	J	DZHS50			:Install the new guy.  When that is
					:done, return here (to DZHS04)

:	Host status msg in proper slot (key matches),
:	or after an entry has been made for new host.  Process it.

DZHS04	SBT	HN,HSTFLG		:SET FLAG INDICATING GOT HOST STATUS
					:REPORT FROM ISIS.		###LH
	LHL	R1,DORNG+2,PRD,		:GET # OF PORTS
	NHI	R1,0FFF

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)
	JEFS	DZHS07			:OUT OF PORTS			###OAS
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R0,0FF-EHHOPT		:reset host out of ports bit	###JHL
	STB	R0,HSTATN,HN		:TO INDICATE PORTS AVAILABLE	###OAS
	JFS	DZHS08
DZHS07	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R0,EHHOPT		:set host out of ports bit	###jhl
	STB	R0,HSTATN,HN		:TO INDICATE OUT OF PORTS	###OAS

DZHS08	HS	0
	AIS	PRD,4
	NR	PRD,TC
	STH	R1,HMAXP,HN,HN		:SAVE MAXIMUM PORTS
	STH	R1,HSTPTA,HN,HN		:SAVE PORTS AVAILABLE
	LB	R0,DORNG+2,PRD,		:NEW STATUS, IS IT ANSWERING?
	NHI	R0,3			:CLEAR 'H KEY' BIT

	JN	DZHS06			:branch if not answering now
					:(gone,down, or shut)
:: Tymtunnel schedules LINKER to send ISIS needle and build Tunnel when
:: X25 host report answering and TUNBLD array is set			###AL
	IF	TUNL
	L	R1,TUNBLD		:CHECK TUNBLD ARRAY
	JE	DZHS09			:SKIP IF NONE OF BIT IS SET
	LHI	R0,1F-PLINKR
	SBT	R0,TLINKR
DZHS09	EI	:TUNL

	LB	R1,HSTAT,HN		:Host answering, then check what it was
	THI	R1,1

	JE	DZHS06			:don't report shut if it was already
					: shut or answered.

:	Report Host shut first if it was gone or down.
:	Host answering, and he hasn't been through the SHUT stage yet.
:	UPDATE HSTATN AND TIME OF UPDATE (USED FOR EXPANDED HOSTS STATUS)
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R1,0FF-EHSTTS		:AND STRIP OFF OLD STATUS BITS	###OAS
	OHI	R1,EHSHUT		:set status "shut"
	STB	R1,HSTATN,HN		:AND RESTORE			###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO HOST TIME	###OAS
	ST	R0,HSTTIM,HN,HN		: ARRAY, STORE CURRENT TIME	###OAS
	SRLS	HN,1			:RESTORE HN			###OAS

	LIS	R0,HS.SHT		:REPORT HIM SHUT FIRST		###wjl
	STB	R0,HSTAT,HN
	JAL	R10,SUP1A,,		:SEND NODE-TO-SUP MSG 1AN###GT ###LH
	GL	SUP1A
	LIS	R0,0			:pretend status "answered" to gen
					:another host status message "answered"

:	SET UP FOR REPORT:  SEND NODE-TO-SUP MESSAGE, TYPE 11, HOST STATUS.
:	THE FIRST HALFWORD OF THE HOST STATUS REPORT IS OF THE FORMAT
:	[11,X0+STATUS]. THE LO-ORDER BYTE OF THIS HALFWORD IS ASSEMBLED
:	IN R14 FOR THE CALL TO SUPHS, WHICH ACTUALLY MAKES THE REPORT.
:	Each of the following states come here:
:	(1) Host is not answering now (gone,down, or shut).
:	(2) Host is answering and it was answered, too.
:	(3) Host is answering and has been through the SHUT stage already.

DZHS06	HS	0
	LHI	R14,1100+HS.HID		:INITIAL VALUE
					: - STATUS PRESENT, HOST ID (HID)
					:NOT PRESENT, HOST IQ (HIQ) DUMB...
       IF       LOGII                   :LOG II may set log2 capable bit
        LR      R1,PRD                  :get ahead and do CC bits before
        AIS     R1,4                    :sending the 1A msg.
        NR      R1,TC                   :get r1 to point to byte with CC bits
        LB      R3,DORNG,R1,            :get byte with CC bits
        NHI     R3,1C                   :remove all other bits
        LB      R1,HSTAT3,HN
        NHI     R1,@1C                  :remove CC bits from saved
        OR      R3,R1                   :combine new CC bits with old other
        STB     R3,HSTAT3,HN            :save it away
        LB      R1,DORNG+2,PRD,         :get status bits
        NHI     R1,80                   :LOG2 capable bit
        SRLS    R1,1                    :Bits are now 0L000000
        LB      R3,HSTAT3,HN            :get old status
        NHI     R3,@40                  :knock off LOG II bit
        OR      R1,R3                   :get new status
        LB      R3,HSTAT3,HN            :get old status (check for change)
        STB     R1,HSTAT3,HN            :save new status
        CR      R1,R3                   :status changed?
        JEFS    DZHS13                  :no log II status change
:       this store forces a different status to be found and thus msg to sup
        STB     R0,HSTAT,HN             :save host status
        J       DZHS15                  :report new LOG II status
       EI       :LOGII
DZHS13	CLB	R0,HSTAT,HN		:HAS THE HOST STATUS CHANGED?
	JN	DZHS10			:YES - NEED TO REPORT HOST STATUS
	LH	R1,DSOHYP		:IS HYPE FIELD PRESENT? (type 10 msg)
	JE	DZHS40			:NO HYPE, NO STATUS CHANGE - NO REPORT!


	J	DZHS11			:NO STATUS CHANGE,
					: BUT NEED PRESENT HYPE		###LH

:	HERE FOR HOST STATUS CHANGE

DZHS10	LB	R1,HSTAT,HN		:SEND A '1A' REPORT TO SUP FIRST###GT
					:IF PREVIOUS STATUS WAS 'GONE'	###GT
	STB	R0,HSTAT,HN		:SAVE NEW HOST STATUS
	SIS	R1,3			:CHECK FOR 'GONE'		###GT
	JNFS	DZHS12			:PREVIOUS STATUS WAS NOT 'GONE' - JUST
					:CONTINUE			###LH
DZHS15	JAL	R10,SUP1A,,		:SEND MESSAGE '1A' TO SUP	###GT
DZHS11	OHI	R14,HS.STS		:SUP WILL IGNORE HOST STATUS	###LH

DZHS12	HS	0
	LB	R0,HSTAT,HN		:RESTORE HOST STATUS		###LH
	OR	R14,R0			:COMBINE HOST STATUS WITH WORKING
					: HEADER			###LH

:	UPDATE HSTATN AND TIME OF UPDATE (USED FOR EXPANDED HOST STATUS)
	SLLS	R0,6			:MOVE HSTAT (BITS 6,7)
					: TO HSTATN (BITS 0,1)
	LB	R1,HSTATN,HN		:GET HSTATN			###OAS
	NHI	R1,0FF-EHSTTS		:strip off old status bits
	OR	R1,R0			:COMBINE			###OAS
	STB	R1,HSTATN,HN		:AND RESTORE			###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO HOST TIME	###OAS
	ST	R0,HSTTIM,HN,HN		: ARRAY AND STORE CURRENT TIME	###OAS
	SRLS	HN,1			:RESTORE HN			###OAS

	LH	R4,DSOHYP		:HYPE FIELD PRESENT?
					:NO, IT IS ISIS MESSAGE TYPE 04
	JE	DZHS30			:REPORT HOST STATUS ONLY

:	PROCESS HIQ AND HID FOR ISIS MESSAGE TYPE 10
	LR	R4,PRD			:TEMP RING POINTER, PRESERVES PRD...
	AIS	R4,4
	NR	R4,TC			:ADVANCE RING POINTER
	LH	R4,DORNG,R4,		:GET HYPE FIELD
:	THE COMBINATION OF HIQ AND HID IS CALLED HYPE. THE HI-ORDER BIT OF
:	HYPE IS HIQ, THE LO-ORDER BYTE IS HID.
	JE	DZHS30			:NO HIQ OR HID - GO REPORT STATUS
	JG	DZHS20			:NO HIQ - DUMB HOST
	OHI	R14,HS.HIQ		:INDICATE SMART HOST

:	SET IIX BIT IN HSTATN (USED FOR EXPANDED HOST STATUS)
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R0,EHIIX		:set IIX bit in HSTATN
	STB	R0,HSTATN,HN		:TO INDICATE HOST IIX		###OAS

:	PROCESS ORG/DEST BITS (USED FOR EXPANDED HOST STATUS)
DZHS20	HS	0
	LR	R0,R4
	NHI	R0,6000			:ISOLATE ORG/DEST ONLY BITS (1/2)###OAS
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS
	NHI	R1,0FF-EHORGN-EHDSTN	:strip off org/dest bits
	SRLS	R0,0B			:GET 1,2 OF HO BYTE INTO 4,5 OF LO BYTE
	OR	R1,R0			:AND COMBINE WITH		###OAS
	STB	R1,HSTATN,HN		:PREVIOUS EXPANDED HOST STATUS	###OAS
        NHI     R0,EHORGN+EHDSTN        :only the ORIG/DEST bits        ###sdw
        OR      R14,R0                  :add them to the header         ###sdw
	CLHI	R0,EHORGN+EHDSTN	:dest only and org only?
	JNFS	DZHS21			:if both, pretend not org only

:	ORIGIN ONLY HOST, SEND OUT OF PORTS MESSAGE TO SUPERVISOR
	LHL	R1,HOSTN,HN,HN		:GET HOST NUMBER FOR SUP REPORT	###OAS
	STH	R1,SUPMBF
	LHI	R5,8F			:SEND HOST OUT OF PORTS		###OAS
	JAL	R10,SUP14,,		:TO SUPERVISOR			###OAS

:	PROCESS PROXY HOST AND COLLECT-CALLS BITS (3,4,5)		###wjl
DZHS21	HS	0
	LR	R0,R4			:get Hype field back		###wjl
	NHI	R0,1C00			:isolate Proxy & CC bits (3,4,5)###wjl
	SRLS	R0,8			:3,4,5 of HO byte to 3,4,5, of LO byte
        LB      R10,HSTAT3,HN           :only change bits 3,4,5         ###sdw
        NHI     R10,@1C                 :LOG II (bit 1) was done above  ###sdw
        OR      R0,R10
	STB	R0,HSTAT3,HN		:store for SUP 1A and SUP 19 msg###wjl

	NHI	R4,0FF			:ISOLATE HID
	JEFS	DZHS30			:DON'T HAVE HID IF ZERO

:	PROCESS HOST ID (USED FOR EXPANDED HOSTS STATUS)
	STB	R4,HSTYPE,HN		:STORE HOST TYPE		###OAS

	XHI	R14,HS.HID+HS.SET 	:INDICATE HOST ID PRESENT, SET
				  	:HS.SET BIT TO PREVENT ESCAPING

:	SEND HOST STATUS REPORT (SUP 11) TO SUP

DZHS30	JAL	R10,SUPHS,,		:MAKE REPORT TO SUP. HEADER BYTE IN R14
	GL	SUPHS			:HID IN R4
	LHL	R0,HOSTN,HN,HN
	STH	R0,CRYSBF+2
	LB	R0,HSTAT,HN
	JAL	R8,CRYPTO,,
	HC	CRYE15			:CHANGE IN HOST STATUS

:	REPORT MULTI-BASE HOST KEY IF PRESENT AND HOST ANSWERED OR SHUT
DZHS40	HS	0
	LB	R0,HSTAT,HN		:HOST ANSWERED ?
	JEFS	DZHS42			:YES
	CLHI	R0,2			:MULTI-BASE HOST KEY VALID IF HOST SHUT
	JN	DZHS44			:NOT ANSWERED OR SHUT

:	HERE IF HOST IS ANSWERED OR SHUT

DZHS42	LIS	R0,5			:TEST 5TH BIT IN STATUS FOR 'SEND KEY'
	TBT	R0,DORNG+2,PRD,		: (BIT SET FOR SENDING IT)
	JE	DZHS46			: (RESET FOR NOT SENDING)
	LB	R0,DORNG+3,PRD,		:HOST KEY = 0 ?
	STH	R0,SUPMBF+2		:SAVE KEY

:	PROCESS MULTI-BASED HOST KEY (USED FOR EXPANDED HOST STATUS)
	STB	R0,HSTMBK,HN		:STORE MULTI BASED HOST KEY	###OAS

	LHI	R5,8C			:TELL SUP IT'S HOST # & KEY
	LIS	R1,0			:SENT BY NODE CODE
	LIS	R6,2			:2 HALFWORDS OF DATA IN SUPMBF
	LHL	R0,HOSTN,HN,HN		:GET HOST NUMBER
	STH	R0,SUPMBF		:SEND TO SUP
	JAL	R10,SUP14,,		:SEND MESSAGE
	J	DZHS46

:	HERE IF HOST NOT ANSWERED OR SHUT, STATUS IN R0

DZHS44	SIS	R0,3			:IS HOST GONE?
	JN	DZHS46			:NO

:	HERE IF HOST IS GONE, CLEAR ENTRY FOR THIS HOST

	STH	R0,HOSTN,HN,HN		:YES, CLEAR ENTRY
	STB	R0,HSTAT,HN		:CLEAR STATUS			###LH

:	CLEAR FIELDS USED FOR EXPANDED HOST STATUS
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	STB	R0,HSTATN,HN		:CLEAR EXTENDED HOST STATUS	###LH
	SLLS	HN,1			:FORM FW INDEX INTO		###OAS
	ST	R0,HSTTIM,HN,HN		:HOST TIME ARRAY AND CLEAR IT	###LH
	SRLS	HN,1			:RESTORE HN			###OAS

:	COMES HERE IF HOST IS DOWN, OR EVERTHING IS DONE.

DZHS46	AIS	PRD,4
	LH	R0,DSOHYP		:HOW LONG WAS MESSAGE FROM SLOT?
	JE	DSOIRP			:NOT LONG - 04 MESSAGE
	AIS	PRD,2			:LONG, TYPE 10 MESSAGE HAS EXTRA HW
	J	DSOIRP			:DONE, RETURN TO MAIN LOOP

:	HERE IF HOST STATUS REPORT FOR AN UNKNOWN HOST. MAKE AN ENTRY
:	FOR HOST AND MARK STATUS AS GONE.

DZHS50	JAL	R9,FNDHSL,,		:LOCATE A FREE ENTRY
	GL	FNDHSL
	J	DZHS52			:THERE ISN'T ONE, REJECT THIS HOST
	LHL	R1,DORNG,PRD,		:RESTORE HOST #

	IF	RESHST
	JAL	R9,VRHOST		:VERIFY THIS HOST
	J	DZHS54			:NOT A VALID HOST FOR THIS NODE OR SLOT
	EI	:RESHST

	STH	R1,HOSTN,HN,HN		:ENTER HOST #
	STB	R2,HSTKEY,HN		:SAVE SLOT# * 4, NON-MXP CONFIGURATIONS
					:SLOT #, MACHINE #, MXP CONFIGURATIONS

:	CLEAR FIELDS USED FOR EXPANDED HOST STATUS
	LIS	R0,0
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	LHI	R0,EHGONE		:set status bits to "gone"
	STB	R0,HSTATN,HN		:TO INDICATE GONE STATUS	###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO HOST TIME	###OAS
	ST	R0,HSTTIM,HN,HN		: ARRAY AND STORE CURRENT TIME	###OAS
	SRLS	HN,1			:RESTORE HN			###OAS

	LIS	R0,HS.GNE		:CALL HIM GONE			###wjl
	STB	R0,HSTAT,HN		:AFTER MADE AN ENTRY FOR THE NEW HOST
	J	DZHS04			:AND PROCEED IT

:	REJECT HOST DUE TO MAX NUMBER ALREADY UP ON THIS NODE.

DZHS52	LIS	R9,0			:ERROR TYPE 0
	IF	RESHST
	J	DZHS60

:	REJECT HOST DUE TO NOT LEGAL RESTRICTED HOST

DZHS54	SBT	HN,RESHMS		:NODE REPORT BEEN SENT YET?
	JN	DZHS56			:YES - NO NEED TO SEND ANOTHER...
	LR	R6,R1
	LR	R7,R2			:SAVE SOME REGS
	OHI	R1,8000
	STH	R1,SUPMBF+4		:HOST NUMBER + 8000
	IF	1-MXPNM			:NON-MXP			###GT
	SRLS	R2,2
	EI	:1-MXPNM						###GT
	OHI	R2,8000
	STH	R2,SUPMBF+2		:SLOT NUMBER + 8000
	LHI	R1,NR.INH
	STH	R1,SUPMBF		:INDICATE INVALID RESTRICTED HOST
	JAL	R10,SUP12,,		:MAKE REPORT TO SUP LOG
	LR	R1,R6
	LR	R2,R7			:RESTORE REGS
DZHS56	LIS	R9,3			:ERROR TYPE '3'
	EI	:RESHST

DZHS60	EXBR	R9,R9			:REJECT HOST, R9 = ERROR * 100x
	LIS	R0,8			:MESSAGE SIZE
	JAL	R8,DIROOM		:GET ROOM FOR ISIS MSG
	LR	R0,R9			:SAVE ERROR NUMBER
	LHL	R9,DRIF,,		:GET FILL POINTER
:	OHI	R2,0B00			:CREATE '0B' MESSAGE, KEY ALREADY IN R2
	OHI	R2,INHTRJ^8		:CREATE '0B' MESSAGE, KEY ALREADY IN R2
	ST	R2,DIRNG,R9,		:SAVE 1ST 4 BYTES OF MSG
	AIS	R9,4			: /
	NR	R9,TC			:/

	EXHR	R1,R1			:'HOST #', '0000'
	AR	R1,R0			:'HOST #', 'ERR', '00'
	ST	R1,DIRNG,R9,		:SAVE 2ND 4 BYTES
	AIS	R9,4			: /
	NR	R9,TC			:/
	STH	R9,DRIF,,		:SAVE BACK THE INDEX
	AIS	PRD,4			:UPDATE OUTPUT EMPTY POINTER
	NR	PRD,TC
	J	DZHS46			:DONE WITH THIS MESSAGE

:	IMPOSTER HOST...HOST COMING UP ON A SLOT, ALREADY EXISTS IN
:	ANOTHER SLOT. SEND NODE REPORT AND REJECT THIS HOST.
DZHS70	HS	0
	STH	R2,DORSLT		:SAVE KEY FROM ISIS		###GT
	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R2,2			:ACTUAL SLOT NUMBER
	ELSE				:MXP -  HAVE TO SWAP NIBBLES	###GT
	SLLS	R2,4			:SHIFT LOWER 4 NIBBLES UP	###GT
	EXBR	R4,R2			:MOVE UPPER 4 BITS TO LO NIBBLE ###GT
	OR	R2,R4			:MAKE A NEW SLOT #		###GT
	NHI	R2,0FF			:MASK OFF UNWANTED BITS		###GT
	EI	:1-MXPNM						###GT
	STB	R2,SUPMBF+3		:SAVE NEW SLOT KEY (BAD GUY)
	LB	R9,HSTKEY,HN		:SAVE OLD SLOT KEY (GOOD GUY)
	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R9,2
	ELSE				:MXP - HAVE TO SWAP NIBBLES	###GT
	SLLS	R9,4			:SHIFT LOWER 4 NIBBLES UP	###GT
	EXBR	R4,R9			:MOVE UPPER 4 BITS TO LO NIBBLE ###GT
	OR	R9,R4			:MAKE A NEW SLOT #		###GT
	NHI	R9,0FF			:MASK OFF UNWANTED BITS		###GT
	EI	:1-MXPNM						###GT
	STB	R9,SUPMBF+2		:HW2 CONTAINS OLD SLOT, OFFENDING SLOT
	LH	R9,HOSTN,HN,HN		:STORE HOST NUMBER + 8000 IN HW3
	OHI	R9,8000
	STH	R9,SUPMBF+4
	LIS	R9,NR.HIM		:INDICATE IMPOSTER HOST,
	STH	R9,SUPMBF		: DETECTED BY NODE
	JAL	R10,SUP12,,		:SEND NODE REPORT
	LHL	R2,DORSLT		:RESTORE R2 - THE ISIS KEY	###GT
	LIS	R9,2			:GET ERROR NUMBER FOR SLOT MSG
	LH	R1,HOSTN,HN,HN		:GET HOST NUMBER
	J	DZHS60			:GO REJECT HOST

	IF	RESHST

::*********************************************************************
::
::	SUBROUTINE:	VRHOST:
::	FUNCTION:	VERIFY RESTRICTED HOST
::	CALLING SEQ:	JAL	R9,VRHOST
::	INPUT:		R1 = HOST NUMBER
::			R2 = REQUESTING SLOT NUMBER*4 IN R2.
::	RETURNS:	TEST FOR HOST NUMBER ENTRY IN GHSTTB TABLE.
::			IF NOT FOUND, OR IF FOUND BUT NOT LEGAL FOR REQUESTING
::			SLOT, DO NON-SKIP RETURN.
::
::*********************************************************************

VRHOST	HS	0
	LHI	R3,(RESHST-1)*2		:HW TABLE, 1 ENTRY EACH RESTRICTED HOST
VRHS10	CLH	R1,GHSTTB,R3		:ENTRY FOUND?
	JEFS	VRHS20			:YES
	SIS	R3,2
	JGEBS	VRHS10
	JR	R9			:ENTRY NOT FOUND - NON-SKIP RETURN

VRHS20	HS	0
	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R2,2			:CONVERT TO ACTUAL SLOT NUMBER
	EI	:1-MXPNM						###GT
	SLLS	R3,1			:MAKE FULLWORD INDEX
	LA	R4,GSHSTB,R3		:POINT TO GSHSnn ENTRY
	TBT	R2,0,R4			:IS HOST LEGAL FOR THIS SLOT?
	JEFS	VRHS30			:NO
	SRLS	R3,1
	LHL	R0,GCHSTB,R3		:GET CIRCUITS/MINUTE LIMIT
	STH	R0,HCTSM,HN,HN		: AND SAVE
	AIS	R9,4			:SKIP RETURN...
VRHS30	HS	0
	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SLLS	R2,2			:RESTORE R2
	EI	:1-MXPNM						###GT
	JR	R9			:RETURN
	EI	:RESHST

::*********************************************************************
::
::	SUBROUTINE:	DSZLGR:
::	FUNCTION:	03 - REPORT TO SUPERVISOR'S LOG
::	FORMATS:
::		--------.-------.-------.--------
::		|	0	|   03  |  key  |
::		|-------.-------.-------+-------|
::		|     DATA2	| R TYP | DATA1 |	R TYP:	Report Type
::		|-------.-------+-------+--------
::		|PROD ID|				PROD ID:  Product ID
::		---------
::
::			12 - ERROR LOG REPORT
::		[1280][ HW1][ HW2][ HW3]
::	This is the generic format for node reports.  HW1 can either be
::	[ss,xx] where ss = Slot number and xx = Product ID or [00,xx]
::	xx = node report type.  HW2 and HW3 are data.
::
::*********************************************************************

DSZLGR	HS	0
	LB	R1,DORNG+3,PRD,		:REPORT TO SUP'S LOG
	AIS	PRD,4
	NR	PRD,TC
	CLHI	R1,0FF			:KERNEL REPORT IF KEY = FF	###LH
	JE	DSZKER			:JUMP TO REPORT, DO NOT NEED TO CHECK
					:IF REPORT LIMIT EXCEEDED OR NOT###LH

	IF	1-MXPNM			:NON-MXP ONLY			###GT
	SRLS	R1,2			:GET ACTUAL SLOT NUMBER
	ELSE				:MXP				###GT
	SLLS	R1,4			:THE KEY = SLOT#, MACHINE #	###GT
	EXBR	R0,R1			:NEED TO SWAP NIBBLES		###GT
	OR	R1,R0			:AND OR INTO PLACE		###GT
	NHI	R1,0FF			:EXTRACT UPPER NIBBLE		###GT
	EI	:1-MXPNM		: TO FORM MACHINE #, SLOT #	###GT

	STB	R1,SUPMBF		:ACTUAL SLOT #
	SLLS	R1,1			:SLOT HALFWORD INDEX
	LH	R0,SMLTBL-2,R1		:GET SLOT'S SLOT REPORT LIMIT
	JLFS	DSZLG2			:NO LIMIT
	AIS	R0,1
	LIS	R10,1
	AHM	R10,SMLCNT-2,R1		:INCREMENT COUNT OF SLOT RPTS FOR SLOT
	CLH	R0,SMLCNT-2,R1		:IS LIMIT EXCEEDED?

	JLE	DSZLG4			:YES - SEND SLOT REPORT LIMIT EXCEEDED
					: - 1E MESSAGE TO SUP

	J	DSZLG2			:NO - SEND SLOT REPORT TO SUP	###LH

:	KEY - FF (KERNEL)

DSZKER	STB	R1,SUPMBF		:KEY - FF (KERNEL)		###LH

:	SEND SLOT OR KERNEL REPORT TO SUP

DSZLG2	L	R0,DORNG,PRD,
	EXHR	R0,R0			:GET THE HALFWORDS IN ORDER
	AIS	PRD,4
	NR	PRD,TC
	ST	R0,SUPMBF+2
	LB	R0,DORNG,PRD,
	AIS	PRD,4
	NR	PRD,TC
	STB	R0,SUPMBF+1
	JAL	R10,SUP12,,
	J	DSOIRP

DSZLG4	JL	DSZLG6			:PAST THRESHOLD - JUST CLEAN UP

:	SEND LIMIT EXCEEDED REPORT TO SUP
	SIS	R0,1
	STH	R0,SUPMBF+4		:EQUAL THRESHOLD - MAKE NODE REPORT
	SRLS	R1,1			:GET ACTUAL SLOT NUMBER,
	OHI	R1,8000			:REDUCE NETWORK ESCAPES,
	STH	R1,SUPMBF+2		:AND STORE
	LHI	R0,NR.SML
	STH	R0,SUPMBF		:INDICATE SLOT REPORT LIMIT EXCEEDED
	JAL	R10,SUP12,,		:AND SEND NODE REPORT TO SUPERVISOR

DSZLG6	AIS	PRD,8			:NO REPORT SENT - ADVANCE
	NR	PRD,TC			:RING POINTER PAST MESSAGE
	J	DSOIRP

DSZHAV	AIS	PRD,4
	NR	PRD,TC			:HOST AVAILABILITY
	L	R7,DORNG,PRD,		:HOST #, PORTS
	AIS	PRD,8
	NR	PRD,TC
	LHL	R2,TVRBUF
	JE	DSOIRP			:NO SUP
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	LHI	R1,140F
	THI	R7,0FFF
	JEFS	DSZL10
	AIS	R1,1
DSZL10	JAL	R9,WHWI			:HEADER
	EXHR	R1,R7
	JAL	R9,WHWI			:HOST #
	J	DSOIRP
::*********************************************************************
::
::	SUBROUTINE:	DSZHPA:
::	FUNCTION:	REPORT HOST PORT AVAILABILITY
::
::*********************************************************************

DSZHPA	LIS	R6,1			:HOST PORT AVAILABILITY
	AIS	PRD,4
	NR	PRD,TC
	LHL	R1,DORNG,PRD,		:HOST #
	JAL	R9,FNDHST,,		:FIND HOST (HN IS INDEX)
	SKIPAD(DSZHP1)			:immed ret, NOT FOUND, SKIP IT	###wjl
	STH	R1,SUPMBF		:+4 return
	LHI	R5,8F			:HOST OUT OF PORTS (MSG SUBTYPE)
	LHL	R0,DORNG+2,PRD,		:GET # AVAILABLE
	STH	R0,HSTPTA,HN,HN		:SAVE IN PORT AVAILABLE

:	UPDATE HSTATN (USED FOR EXPANDED HOST STATUS)
	JEFS	DSZH10
	LHI	R5,90			:HOST HAS PORTS (MSG SUBTYPE)	###OAS
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R1,0FF-EHHOPT		:reset host out ports bit,we have ports
	STB	R1,HSTATN,HN		:TO INDICATE PORTS AVAILABLE	###OAS
	JFS	DSZH11

DSZH10	HS	0			:OUT OF PORTS			###OAS
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	OHI	R1,EHHOPT		:set host out of ports bit
	STB	R1,HSTATN,HN		:TO INDICATE OUT OF PORTS	###OAS

DSZH11	HS	0
	AIS	PRD,8
	NR	PRD,TC
	JAL	R10,SUP14,,
	J	DSOIRP

DSZHP1	AIS	PRD,8			:UPDATE RING POINTER
	NR	PRD,TC
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSZHCS:
::	FUNCTION:	0C - REPORT HOST COST
::
::*********************************************************************

DSZHCS	LHI	R5,88			:HOST COST
	LIS	R6,2			:SUP14 PARAMETER
	AIS	PRD,4
	NR	PRD,TC
	L	R0,DORNG,PRD,
	ST	R0,SUPMBF
	AIS	PRD,8
	NR	PRD,TC

:	UPDATE HSTCST (USED FOR EXPANDED HOST STATUS)
	LR	R1,R0
	EXHR	R1,R1			:ISOLATE			###OAS
	NHI	R1,7FFF			:HOST NUMBER IN R1		###OAS
	JAL	R9,FNDHST,,		:AND FIND HOST TABLE INDEX	###OAS
	SKIPAD(DSOIRP)			:NOT FOUND, IGNORE MESSAGE	###OAS
	LR	R1,R0			:+4 return
	NHI	R1,00FF			:ISOLATE HOST COST AND		###OAS
	STB	R1,HSTCST,HN		:STORE IN HOST COST TABLE	###OAS

	JAL	R10,SUP14,,
	J	DSOIRP

::*********************************************************************
::
::	SUBROUTINE:	DSZACC:
::	FUNCTION:	PROCESS ISIS MESSAGE B7 - ADDENDUM TO ACCOUNTING
::			& INTRA-ISIS MESSAGE 05 - REPORT ACCOUNTING
::
::*********************************************************************

DSZACC	LHI	R5,89
	LIS	R6,2
	AIS	PRD,4
	NR	PRD,TC			:ACCOUNTING MESSAGE
	L	R0,DORNG,PRD,
	AIS	PRD,4
	NR	PRD,TC
	ST	R0,SUPMBF
	LIS	R1,4			:SET FLAG TO INDICATE DISPI SENDING
	JAL	R10,SUP14,,		: ACCT REC.
	J	DSOIRP			
	EI	:(1-T2GATE)		:End of Gateway non-use section


::*********************************************************************
::
::	SUBROUTINES:	DSZK04,DSZK08,DSZK0C
::	FUNCTION:	TO SKIP OVER UNDECODED MESSAGES
::
::*********************************************************************

DSZK04	LIS	R0,4			:TO SKIP OVER UNDECODED MESSAGES
	JFS	DSZKIL
DSZK08	LIS	R0,8
	JFS	DSZKIL
DSZK0C	LIS	R0,0C
DSZKIL	AH	R0,DROE,,
	NHI	R0,DRSZ-4
	STH	0,DROE,,
	J	DSONXT

::*********************************************************************
::
::	SUBROUTINE:	DSIOER:
::	FUNCTION:	COME HERE FOR MESSAGES RECEIVED FROM THE
::			DISPATCHER WHICH ARE ONLY VALID GOING TOWARDS
::			THE DISPATCHER.
::
::*********************************************************************

DSIOER	HS	0
	CRASH.(.DSIO0)

::*********************************************************************
::
::	TABLE:		DSZETB:
::	FUNCTION:	DISPATCH TABLE FOR CHANNEL ZERO MESSAGES 
::			FROM ISIS.
::
::*********************************************************************

      IF	T2GATE		:Gateway dispatch table for port 0 messages

        GL      G0DNSP,GLZ9,G02NUP
				:SUBTYPE
DSZETB	WC	DSZK04		:00 - DISCONNECT (IGNORED)
	WC	DSZK04		:01 - RESTART INTERFACE (IGNORED)
	WC	G02NUP		:02 - TAKEOVER MESSAGE ##AL
	WC	DSIOER		:03 - LOG REPORT
	WC	DSIOER		:04 - HOST STATUS
	WC	DSIOER		:05 - ACCOUNTING
	WC	DSZK08		:06 - TIME 
	WC	DSIOER		:07 - TERMINAL LOGIN
	WC	DSZK0C		:08 - AUX LOGIN
	WC	GLZ9		:09 - REJECT LOGON 
	WC	DSIOER		:0A - REPORT HOST PORT AVAILABILTY
	WC	DSIOER		:0B - HOST UNACCEPT
	WC	DSIOER		:0C - HOST COST
	WC	G0DNSP		:0D - NO SUP ##AL
	WC	DSIOER		:0E - 1-DOWN 	:Illegal at this time
	WC	DSIOER		:0F - REPORT ALL HOSTS 
	WC	DSIOER		:10 - HOST STATUS AND TYPE(ILLEGAL)
       IF       LOGII           :following only for logii gateway
	WC	DSIOER		:11 - ICRM (ILLEGAL)
	WC	GDECRI		:11 - ECRI - LOG II PSUEDO NEEDLE REJECT
        GL      GDECRI
       EI       :LOGII
DSZETL	EQ	(.-DSZETB)/4

      ELSE	:not T2GATE	:NodeCode dispatch table

DSZETB	WC	DSZK04		:00 - DISCONNECT (UNUSED)
	WC	DSZK04		:01 - RESTART INTERFACE (UNUSED)
	WC	DSZK04		:02 - TAKEOVER MESSAGE (N/A)
	WC	DSZLGR		:03 - LOG REPORT
	WC	DSZHST		:04 - HOST STATUS
	WC	DSZACC		:05 - ACCOUNTING
	WC	DSZK08		:06 - TIME (N/A)
	WC	DSZTLG		:07 - TERMINAL LOGIN
	WC	DSZALG		:08 - AUX LOGIN
	WC	DSZK08		:09 - REJECT LOGON (N/A)
	WC	DSZHPA		:0A - REPORT HOST PORT AVAILABILTY
	WC	DSZK08		:0B - HOST UNACCEPT (N/A)
	WC	DSZHCS		:0C - HOST COST
	WC	DSIOER		:0D - NO SUP (ILLEGAL)
	WC	DSIOER		:0E - 1-DOWN (PLITEXT) (ILLEGAL)
	WC	DSIOER		:0F - REPORT ALL HOSTS (ILLEGAL)
	WC	DSZHSH		:10 - HOST STATUS AND HYPE
       IF       LOGII
	WC	ICRM		:11 - LOG2 CIRCUIT REQUEST
       EI       :LOGII
DSZETL  EQ	(.-DSZETB)/4

      EI	:not T2GATE

::*********************************************************************
::
::	SUBROUTINE:	DISKIP:
::	FUNCTION:	SKIP OVER DISPATCHER MESSAGE.
::			EXPECT PRD POINTING TO PORT #, UPDATES DROE.
::	CALLING SEQ:	JAL	R8,DISKIP RETURNS TO DSONXT WHEN DONE
::
::*********************************************************************

DISKIP	NHI	PRD,DRSZ-4		:MAKE SURE PRD IS OK
	LB	R1,DORNG+2,PRD,		:GET TYPE
::Point of departure for Gateway Needle
	IF	T2GATE
	JE	GNEDIN,,		:Needle front end process for Gateway
        GL      GNEDIN
	CLHI	R1,0B2		:Only other legal from this caller is B2
	JE	GDB2,,			:Go to the Gateway B2 handler
       IF       LOGII                   :log 2 gateways have ISNs and ASLPs
        CLHI    R1,DM.ASL               :ASLP
        JE      GDASLP,,
        CLHI    R1,DM.ISN
        JE      GDISN,,         :ISN needle
        GL      GDISN,GDASLP
       EI       :LOGII
	ELSE
	JE	DSKP2			:NEEDLE (GROSSLY ILLEGAL)
	EI	:T2GATE
	CLHI	R1,DTDAT
	JG	DSKP3			:SOME CONTROL MESS
	LHI	R0,6,R1
	NHI	R0,DRSZ-4
DSKP1	AR	PRD,R0							###AL
	NHI	PRD,DRSZ-4		:INDEX PRD			###AL
	STH	PRD,DROE,,		:UPDATE DROE
        j       dsonxt                  :message flushed
DSKP2	LB	R0,DORNG+3,PRD,		:NEEDLE, GET ADDIT LENGTH
	AIS	R0,4			:OVERALL LENGTH
	JBS	DSKP1
DSKP3	CLHI	R1,DTCON		:TYPE TOO LARGE
	JLEFS	DSKP4
	CRASH.(.DSKP0)
DSKP4	LIS	R0,4
	SHI	R1,0B1
	JL	DSKP1
	LB	R0,DSKPLN,R1		:OVERALL LENGTH
	J	DSKP1

DSKPLN	BC	8,8,4,4,4,0C,8,4,4,4,4,4,4,4,4,4	:TYPES B1 - DTCON
	HS	0			:INSURE HW ALIGNMENT

	SUBTTL	DISPI (Utility routines)

::*********************************************************************
::
::	SUBROUTINE:	DIRMES:
::	FUNCTION:	SEND A 1-WORD MESSAGE
::	CALLING SEQ:	JAL	R8,DIRMES
::	INPUT:		R1 = 2 BYTES DATA
::			CHN = CHANNEL #
::	DESTROYED:	R3
::
::*********************************************************************

DIRMES	HS	0
	LHL	R3,DRIF,,		:INPUT PTR
	STH	CHN,DIRNG,R3,
	STH	R1,DIRNG+2,R3,
	AIS	R3,4
	NHI	R3,DRSZ-4
	STH	R3,DRIF,,
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	DIROOM:
::	FUNCTION:	DISMISSES UNTIL SPACE MADE IN THE INPUT RING.
::	CALLING SEQ:	JAL	R8,DIROOM
::	INPUT:		R0 = SPACE REQUESTED
::	DESTROYED:	R3
::
::*********************************************************************

DIROOM	LH	R3,DRIE,,		:COMPUTE EXISTING SPACE
	SH	R3,DRIF,,
	JGFS	DIRO10
	AI	R3,DRSZ			:ALLOW FOR RING WRAP
DIRO10	SIS	R3,4			:FILL MAY ONLY GET WITHIN 4 OF EMPTY
	CR	R0,R3			: POINTER
	JLER	R8			:ENOUGH SPACE--RETURN TO CALLER
	SVC	DISMIS,0		:NOT ENOUGH, DISMISS
	J	DIROOM

::*********************************************************************
::
::	SUBROUTINE:	DIMMES:
::	FUNCTION:	MGVES CANNED MESSAGES TO DISPATCHER INPUT
::			RING. (TOWARD APPLICATION SLOTS)
::			DATA STRING IN THE FORMAT (n/B1/B2/..  ../Bn)
::
::	CALLING SEQ:	JAL	R8,DIMMES
::	INPUT:
::			R1 = ADDRESS OF MESSAGE
::			CHN = CHANNEL NUMBER
::	REGISTER USAGE:	
::			R0 = CHARACTER BEING MOVED
::			R3 = LENGTH OF STRING
::			R14 = WORK REGISTER
::			R15 = DRIF ( DISPI INPUT RING FILL POINTER)
::
::*********************************************************************

DIMMES	HS	0
	STM	R14,DIMMSV		:SAVE WORKING REGISTERS
	LR	R14,R8			:SAVE RETURN REGISTER
	LB	R0,0,R1			:GET LENGTH
	AIS	R0,6			:ALLOW FOR MAXIMUM MESSAGE SIZE
	JAL	R8,DIROOM		:WAIT FOR ROOM
	LHL	R15,DRIF,,		:GET FILL POINTER
	STH	CHN,DIRNG,R15,		:SAVE PORT NUMBER INTO MESSAGE
	LB	R3,0,R1			:GET MESSAGE LENGTH
	STB	R3,DIRNG+2,R15,		:SAVE LENGTH
	AIS	R15,3			:ADD LENGTH FOR PORT AND LEN.
DIMME1	HS	0
	LB	R0,1,R1			:GET CHARACTER
	STB	R0,DIRNG,R15,		:PUT IT IN RING
	AIS	R1,1			:UPDATE MESSAGE POINTER
	AIS	R15,1			:MOVE FILL POINTER
	NHI	R15,DRSZ-1
	SIS	R3,1			:DONE?
	JNBS	DIMME1			:NO, CONTINUE
	AIS	R15,3
	NHI	R15,DRSZ-4
	STH	R15,DRIF,,		:DONE
	LR	R8,R14			:RESTORE LINK REG
	LM	R14,DIMMSV		:RESTORE WORKING REGS
	JR	R8			:RETURN


::*********************************************************************
::
::	SUBROUTINE:	DIXCAP:
::	FUNCTION:	TO GIVE NEW CIRCUITS SOME XMIT CAPACITY.
::	CALLING SEQ:	JAL	R9,DIXCAP
::
::*********************************************************************

DIXCAP	HS	0
	LIS	R1,3			:GET CIRCUIT SPEED
	NH	R1,DIOTAB,CHN,CHN
DIXCAB	LHL	R1,CIRSPK,R1,R1
	CLHI	R1,09E			:0FF IS MAX ALLOWED BY MESS FORMAT
	JLFS	DIXC10
	LHI	R1,09D
DIXC10	AHI	R1,XMTCAP
	STH	CHN,DIRNG,PRD,
	STH	R1,DIRNG+2,PRD,
	AIS	PRD,4
	NR	PRD,TC
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	DISBPS:
::	FUNCTION:	RELIEVE BACKPRESSURE ON DIS PORTS THAT HAVE
::			SUFFICIENTLY LOW CHARACTER COUNTS.
::	CALLING SEQ:	JAL	R10,DISBPS  (from 1/2 logic)
::
::*********************************************************************

:       rewritten 11/19/87 to not call DIROOM which will dismiss NC 
:       (SVC FAST,0) when no room in ring.  When no room just quit and
:       do it next 1/2 second                                           ###sdw


DISBPS	HS	0
	LIS	R4,0			:UPDATE DISBPS BITS
	LIS	R7,0

DISBP1	L	R0,DISBPX,R7		:PORTS (BITS) ARE RESET IF BACKPRESSURD
	O	R0,DISACP,R7,		:PORTS ACTIVE IF RESET
	LCS	R1,1
	XR	R1,R0			:BITS SET IF BP'D .AND. ACTIVE
	ST	R1,SBPTMP		:USED AS TEMP STORAGE
DISBP2	L	R1,SBPTMP
        JFFO    R1,DISBP4
DISBP3	AIS	R7,4			:TRY NEXT PORT GROUP
	AHI	R4,20
	CLHI	R4,NDP
	JL	DISBP1
	JR	R10			:RETURN TO SPIDER

DISBP4	RBT	R2,SBPTMP
	AR	R2,R4			:DIS CHANNEL #
	LHL	R3,DIOTAB,R2,R2
	LR	R6,R3			:SAVE CIRCUIT SPEED
	NHI	R3,-4			:R3=BUFF #
	JE	DISBP2			:IDLE CHANNELS REMAIN BP'ED
	NHI	R6,3			:SPEED BITS
	LHL	R8,bct,r3,		:SPEED
	CLH	R8,cirspk,r6,r6
	jge	DISBP2			:PORT MUST REMAIN BP'ED
        LH      R8,DRIF,,               :fill pointer
        LH      R3,DRIE,,               :fill+new size must be < empty or wrap
        SR      R3,R8                   :occurs
        JGFS    DISBP5
        AI      R3,DRSZ                 :
DISBP5  SIS     R3,4+4                  :4 for msg 4 to keep ring from wrapping
        JLER    R10                     :if no room then wait till next 1/2 sec
        SBT     R2,DISBPX
        STH     R2,DIRNG,R8,            :store chn number
        LHI     R2,RDSPBP               :0A1 release BP
        STH     R2,DIRNG+2,R8,
        AIS     R8,4
        NHI     R8,DRSZ-4
        STH     R8,DRIF,,
	J	DISBP2

::*********************************************************************
::
::	SUBROUTINE:	DSODBF                                          ###SDW
::	FUNCTION:	SET BACKPRESSURE ON ALL PORTS.  CALLED ONLY
::			WHEN INPUT RING IS GETTING OVERRUN AND DISPATCHER
::			IS PROBABLY BUFFERING WHICH ADDS HEAVY OVERHEAD
::			WHICH MAKES IT IMPOSSIBLE FOR NC TO GET THE TIME
::			TO RECOVER FROM THE OVERRUN.  BACKPRESSURING ALL
::			PORTS GIVES NC A CHANCE TO EMPTY THE RING AND
::			THUS END THE DISPATCHER'S BUFFERING.  TESTING HAD
::			SHOWN NC RECEIVING 50KCPS AND THEN DISPATCHER BUFFERING
::			AND DROPPED TO 18KCPS AND HAD TO CHANGE TPUT HOST
::			TO SEND ONLY 15KCPS BEFORE THE BUFFERING WENT AWAY.
::			ALSO, FIELD HAS SEEN NODES D-BUFFERING FOR HOURS.
::	CALLING SEQ:	JAL	R10,DSODBF  (from DISOUT)
::
::*********************************************************************

DSODBF  STM     R0,DSOREG               :save our registers
        LIS     R4,0
        LIS     R7,0
DSODB1  L       R0,DISACP,R7,           :0 if active
        LCS     R1,1                    :flip to 1 if active
        XR      R0,R1
        N       R0,DISBPX,R7,           :set if not BPed
        ST      R0,SBPTMP               :continue with these ports
DSODB3  L       R0,SBPTMP               :reenter after doing a port
        JFFO    R0,DSODB5
        AIS     R7,4
        AHI     R4,20                   :our port group
        CLHI    R4,NDP
        JL      DSODB1                  :another group of ports to do
DSODB4  LM      R0,DSOREG               :exit
        JR      R10                     :done

DSODB5  RBT     R1,SBPTMP               :port serviced
        LH      R8,DRIF,,               :fill pointer
        LH      R3,DRIE,,               :fill+new size must be < empty or wrap
        SR      R3,R8                   :occurs
        JGFS    DSODB7
        AI      R3,DRSZ                 :
DSODB7  SIS     R3,4+4                  :4 for msg 4 to keep ring from wrapping
        JLE     DSODB4                  :if no room then wait till next 1/2 sec
        AR      R1,R4                   :make into a real DPORT
        RBT     R1,DISBPX               :note port BPed
        STH     R1,DIRNG,R8,            :store chn number
        LHI     R2,SDSPBP               :0A0 release BP
        STH     R2,DIRNG+2,R8,
        AIS     R8,4
        NHI     R8,DRSZ-4
        STH     R8,DRIF,,
	J	DSODB3



	SUBTTL	DISPI (LOGCHR)

	SEG	1

:	BIT ARRAY TO INDICATE LOGON ESCAPE CHARACTERS (1B-1F,7B-7E)

DLMESC	HC	0000,001F,0000,0000,0000,0000,0000,001E

::*********************************************************************
::
::	SUBROUTINE:	LOGCHR:
::	FUNCTION:	PROCESS CHARACTERS COMING FROM PORTS IN LOGIN
::			MODE.
::			THIS ROUTINE IS USED BOTH BY DISPI AND THE
::			CONSAT (ASYNC) MODULE.
::	CALLING SEQ:	JAL	R11,LOGCHR
::	INPUT:		R1 = CHAR FROM PORT IN LOGIN MODE
::			R2 = OUTBOUND BUFFER #
::	RETURNS:	IMMEDIATE IF PORT NOT IN LOGIN MODE
::			+4 IF LOGIN BUFFER FULL
::			+8 IF EVERYTHING OK
::
::*********************************************************************

:	VERIFY PORT IN LOGIN MODE, AND TOSS CHARACTER IF NOT
LOGCHR	HS	0
	LHL	R0,BF,R2,
	IF	TUNL
	CLHI	R0,18			:WHEN NO SUP, TUNNEL LOGIN BF=18X
	JE	TLGCHR			:TUNNEL LOGIN CHAR. PROCESSING
	GL	TLGCHR
	EI	:TUNL
	CLHI	R0,LOGMAX		:RANGE CHECK BUFFER FLAG
	JG	LOGEX0			:immed ret, NOT IN LOGIN MODE	###wjl
	CLHI	R0,LOGMIN
	JL	LOGEX0			:immed ret, NOT IN LOGIN MODE	###wjl

	OHI	R1,80			:SET HOB OF CHARACTER
	TBT	R1,DLMESC-10		:IS CHARACTER AN ESCAPE ?
	JN	LOGBAD			:YES, HANDLE ESCAPE
	LR	R6,R1			:SAVE LOGON CHARECTER
	JAL	R8,WCI			:R1=CHAR, R2=BUFFER #*4
	LIS	LRC,1

	JAL	R8,CBCCT		: *REMOVE WHEN SUP GOES TO 56 CHARS*
	CHI	R1,$A48			: > 48 CHARS ?
	JG	LOGCHA			:ZAP BUFFER, SEND MESSAGE TO USER

	CHI	R6,8D			:= 'CR' ?
	JEFS	LOGCH0			:YES, SET NODE CODE TO OK
	CHI	R6,0BB			:= "SEMI-:" ?
	JN	8,R11			:NO, DO +8 RETURN
:	SET BF TO 'NODE CODE = YES' IF CHARACTER IS CR OR SEMI-:
LOGCH0	HS	0
	LHL	R8,BF,R2,		:GET BF
	OHI	R8,LOGNDC		:SET 'NODE CODE = OK' BIT
	STH	R8,BF,R2,
	J	8,R11			:CONTINUE WITH +8 RETURN

:	BUFFER OVERFLOW, ZAP BUFFER, TELL USER

LOGCHA	HS	0
	LIS	R1,0			:SET TO 0 FOR NO ESC CHAR

LOGBAD	LIS	R0,0			:COMMON ENTRY POINT FOR ESCAPE
					: & BUFFER FULL
	ST	R0,DSOLGH		:CLEAR TEMPORARY SAVE AREA
	GL	DSOLGH
	STB	R1,DSOLGH+3		:STORE R1 (EITHER ESCAPE CHAR OR 0)
	LIS	R0,0F
	TBT	R0,BF,R2,		:IS TID IN THE BUFFER?
	JEFS	LOGBA1			:NO
	JAL	R9,GHWI			:YES, GET HOST NUMBER
	STH	R1,DSOLGH		:AND SAVE IT
	JAL	R8,GCI			:ALSO GET TID
	STB	R1,DSOLGH+2		:SAVE IT ALSO
LOGBA1  LB	R1,DSOLGH+3		:ESCAPE OR BUFFER FULL?
	JE	LGFULL			:BUFFER FULL, GO CLEAR IT

LOGES2  LHL	R0,BCT,R2,		:ESCAPE TYPED...ANYTHING IN BUFFER?
	JEFS	LOGES1			:NO, BUFFER EMPTY
	JAL	R9,GCIE			:YES, GET A CHARACTER, ESCAPE STRIPPED
	NHI	R1,7F			:STRIP OFF MSB
	CLHI	R1,01F			:CONTROL CHARACTER?
	JGBS	LOGES2			:NO, GET ANOTHER CHARACTER
	SBT	R1,DSOSPC		:CONTROL CHARACTER, NOTE IT
	GL	DSOSPC
	JBS	LOGES2			:AND KEEP EMPTYING BUFFER
LOGES1  LHL	R1,DSOLGH		:GET HOST NUMBER
	JEFS	LOGES6			:NO HOST NUMBER IN BUFFER
	JAL	R9,WHWI			:DEPOSIT HOST NUMBER
	LB	R1,DSOLGH+2
	JAL	R8,WCI			:AND TID
LOGES6	LHL	R3,DSOSPC		:SEND SUP ALL CONTROL CHARACTERS
        JFFOH   R3,LOGES4               :find a control char            ###sdw
        JFS     LOGES3                  :no more control char           ###sdw
LOGES4  RBT	R4,DSOSPC		:THIS ONE DONE
	LHI	R1,80,R4		:YES, APPEND 80-BIT...
	JAL	R8,WCI			:AND, WRITE IT IN
	JBS	LOGES6			:LOOP OVER ALL CINTROL CHARACTERS
LOGES3  LB	R1,DSOLGH+3		:GET THE ESCAPE CHAR
	JAL	R8,WCI			:AND WRITE IT IN
	LIS	R0,0E
	SBT	R0,BF,R2,		:SET NODE CODE TO GO AHEAD
	J	8,R11			:DO A +8 RETURN

LGFULL	JAL	R8,CBCLR		:CLEAR BUFFER
	LHL	R1,DSOLGH		:IS HOST NUMBER IN BUFFER
	JEFS	LOGEX4			:NO, DO A +4 RETURN		###wjl
	JAL	R9,WHWI			:YES, REDEPOSIT IT
	LB	R1,DSOLGH+2		:AND ALSO THE TID
	JAL	R8,WCI
LOGEX4	SKIP(4,R11)			:+4 return			###wjl

LOGEX0	SKIP(0,R11)			:immediate return		###wjl

::	Log-in  Error messages for Gateway (terminal in Log-in mode)
LFER08	SC	/out of origination ports/

	ENDMO.(DISPI)
	EI	:1-KILLIT
	KILMSG(DISPI)

       ei       :1-swtchr               :no dispatcher if switcher

:	***NOTHING PAST THIS POINT***


	SUBTTL BUFF

:			****   *   * ***** *****
:			*   *  *   * *     *
:			****   *   * ***   ***
:			*   *  *   * *     *
:			****    ***  *     *

::#####################################################################
::
::	MODULE:		BUFF
::
::	FUNCTION:	CHARACTER BUFFER ROUTINES
::
::	REGISTER CONVENTIONS:
::		R0=SCRATCH
::		R1=CHARACTER TO OR FROM BUFFER. ALSO SCRATCH.
::		R2=BUFFER # (MULTIPLE OF 4)
::		R3=SCRATCH
::		R8=LINK
::	SUBTTLS:
::		WCI - Write character into a buffer
::		GCI - Get character from a buffer
::		CBCLR - Clear a buffer
::		CKZB - Refill bufferlet reserve tank
::		Utilities
::		GFCBUF/RFCBUF - Get/Return free character buffer pair)
::		Copy message into a buffer
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA  0
	SEG  1

::*********************************************************************
::
::	SUBROUTINE:	WCI:
::	FUNCTION:	Write character into buffer
::	CALLING SEQ:	JAL	R8,WCI
::	INPUT:		R1 = CHARACTER
::			R2 = BUFFER INDEX
::
::*********************************************************************

WCI	HS	0			:Entry point

	CLHI	R2,4			:TEST FOR BUFFER NUMBER 0 OR 1
	JGFS	WCI0			:OK
	CRASH.(.WCIC0)			:Crash if buffer index 0 or 4.

:	IF	ESYNC
       IF	1-NAD68		:NAD or Nada				###wjl

WCI0	HS	0
:	Check buffer's BF, crash if negative. Else to WCI1.
	IF	DB.DEB
	LH	R0,BF,R2,		:EDIT BUFFER'S BF
	JGEFS	WCI1
	DBOOPS				:SPECIAL OOPS CALL
	EI	DB.DEB

WCI1	HS	0			:Here to do a WCI.
:	WCI instruction.  Takes us to WCIERR if bad buffer index, to WCNXT
:	to fetch another bufferlet, to WCFRST to get the first bufferlet.
:	Falls through when done, and we return to caller (R8).
WCI2	HS	0			:WCI INSTRUCTION
	HC	3912			:R1=CHAR, R2=BUFFER INDEX

	HC	BE-BB			:SIZE OF BB STORAGE
	HC	WCIERR-WCI2		:HERE ON INVALID BUFFER NUMBER
	HC	BE/4			:ADDRESS OF BE STORAGE/4
	HC	WCNXT-WCI2		:HERE TO CHAIN IN ANOTHER BUFFERLET
	HC	WCFRST-WCI2		:HERE TO GET FIRST BUFFERLET

	JR	R8			:DONE

:	Crash due to bad buffer index detected by WCI.
WCIERR	HS	0
	CRASH.(.WCIC1)

:	ELSE	:NOT ESYNC
       ELSE	:NAD68		:NAD to 68020 assembler			###wjl

WCI0	L	R3,BE,R2,		:LOAD IN PTR
	JEFS	WCFRST			:IF 0, BUFF EMPTY, SO GET BUFFERLET
	AIS	R3,1			:INC TO NEXTSLOT
	THI	R3,CBSZ-1
	JEFS	WCI1			:NEED ANOTHER BUFFERLET
	STB	R1,0,R3
	ST	R3,BE,R2,		:RESTORE IN PTR
	JR	R8

WCI1	J	WCNXT

:	EI	:ESYNC
       EI	:NAD68

::*********************************************************************
::
::	WCFRST:	Chain the first bufferlet into a buffer.
::	Set BCT to 1, bump the count of bufferlets in use (by 14d),
::	set the buffers attention flag (NFLAGS).
::
::*********************************************************************

WCFRST	HS	0
	LIS	R3,1			:FIRST BFLET, SET CHRCNT=1
	STH	R3,BCT,2,
	lhi	R3,cbsz-cbptsz
	AM	R3,BFLTSV		:INCREMENT COUNT OF BUFFERLETS IN USE
	JGEFS	WCFRS9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCFRS9	HS	0
	IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	WCFRS1			:NO				###OAS
	AM	R3,HBFTSV		:YES, INCREMENT COUNT		###OAS
	JGEFS	WCFRS1			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCFRS1	HS	0
	EI	:REBILD

	LH	R3,BF,2,		:SET ATTN FLAG
	SBT	R3,NFLAGS

:	Get a bufferlet from the free list (FREELT). If one is there,
:	continue at WCFRS0.  If not, call WRE to get the reserve tank,
:	then jump back here and try again.
WCFRS0	HS	0
	LHL	R3,FREELT		:GET BFLET FROM FREE LIST
	JNFS	WCFRS2
	JAL	R0,WRE
	JBS	WCFRS0

:	Got a free bufferlet to chain.  Point BB to it, put its link pointer
:	in FREELT, put the character into it, set up BE, and return to the WCI
:	caller.
WCFRS2	HS	0
	SLLS	R3,CBSZL		:COMPUTE ADDR OF FIRST SLOT
	AIs	R3,cbptsz
	ST	R3,BB,R2,		:IT'S ALSO THE NEW OUT PTR
	LHL	R0,CBSZ-2,R3		:UPDATE FREE LIST
	STH	R0,FREELT
	STB	R1,0,R3			:PUT AWAY BYTE
	ST	R3,BE,R2,		:RESTORE PTR
	JR	R8

::*********************************************************************
::
::	WCNXT:	Chain another bufferlet to a buffer.
::	Bump the count of bufferlets in use (BFLTSV), bump BCT by 14d.
::	If BCT<32K, continue at WCNXT0.  Else if BCT<0FFF0, continue at WCNXT0.
::	Else call BUFZAP to zap the buffer because we're in danger of
::	overflowing BCT.  If the buffer we zapped was a history buffer (there
::	is nothing--i.e., no black ball--in it) continue at WCFRST.
::	Else continue at WCNXT2.
::
::*********************************************************************

WCNXT	HS	0
        THI     R3,CBSZ-1               :is this 16d boundary end of bflet?
        JEFS    WCNX00
        STB     R1,0,R3                 :put the char
        ST      R3,BE,R2,
        JR      R8
WCNX00
	lhi	R0,cbsz-cbptsz		:CHAIN ANOTHER BFLET - INC CNT
	AM	R0,BFLTSV		:INCREMENT NUMBER OF BUFFERLETS IN USE
	JGEFS	WCNXT9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
       if       1-rebild                :need to slip in a nearby label
wcnxt4  j       wcnxt5
       ei

WCNXT9	HS	0
	IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	WCNX33			:NO				###OAS
	AM	R0,HBFTSV		:YES,INCREMENT COUNT		###OAS
	JGEFS	WCNX33			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
wcnxt4  j       wcnxt5
WCNX33	HS	0
	EI	:REBILD

	AHM	R0,BCT,R2,		:AND BCT FOR THIS BUFFER
	Jlbs	WCNXT4			:BCT < 32K

:	Here if BCT not too big.  Get the next bufferlet from the free list.
:	If one is there, continue at WCNXT1.  Else call WRE to get the reserve
:	pool and come back here to try again.
WCNXT0	HS	0
	LHL	R0,FREELT		:LINK TO NEXT BUFFERLET IN CHAIN
	JNFS	WCNXT1			:LINK ADDRESS<>0,BUFFERLET CHAIN INTACT
	JAL	R0,WRE			:FREE POOL EMPTY, GET LINK ADDRESS FROM
	JBS	WCNXT0			:RESERVE POOL AND SCHEDULE 'CKZB' TO
					:REFILL RESERVE POOL, ZAPPING A BUFFER
					:IF NECESSARY.

:	Here after successfully chaining in another bufferlet.
:	Set up link, update FREELT.
WCNXT1	HS	0
	STH	R0,0,R3			:R3 PTS TO LINK SLOT
	LR	R3,R0			:COMPUTE NEW IN PTR
	SLLS	R3,CBSZL
	AIs	R3,cbptsz
	LHL	R0,CBSZ-2,R3
	STH	R0,FREELT

:	Got a bufferlet, bookkeeping done. Now store away the character
:	and update BE.  Then return to WCI caller.
WCNXT2	HS	0
	STB	R1,0,R3			:STORE THE CHAR
	ST	R3,BE,R2,
	JR	R8

:       here if bct in danger of overflow
wcnxt5	LHL	R0,BCT,R2,
	CI	R0,0FFF0		:ARE WE IN DANGER OF BCT OVERFLOW?
	JL	WCNXT0			:NO
	STM	R0,REGST		:STORE REGS			###LSH
	JAL	R14,BFZDB2,,		:STORE SOME DATA FOR DEBUGGING	###LSH
	GL	BFZDB2			:BEFORE WE ZAP THE BUFFER 	###LSH
	LM	R0,REGST		:RESTORE REGS			###sdw
	JAL	R0,BUFZAP		:YES - ZAP BUFFER
	L	R3,BE,R2,		:SET UP BE
	JN	WCNXT2			:AND GO STORE CHARACTER
	J	WCFRST			:MUST BE HIST BUFF,NO BLACK BALL IN IT


::*********************************************************************
::
::	SUBROUTINE:	WRE:
::	FUNCTION:	Link the reserve tank into the free list.
::			Called when free list found empty.
::	CALLING SEQ:	JAL	R0,WRE
::	DESTROYED:	NO REGISTERS
::
::*********************************************************************

WRE	HS	0			:Get the reserve tank pointer.

	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,WREDB1,,
	GL	WREDB1
	LM	R0,REGST                :restore regs           ###sdw
	EI	:BFSDBG

	ST	R0,WRERET		:IN ORDER TO SAVE ON REGISTERS
	LHL	R0,FREELT		:MAKE SURE WE SHOULD BE HERE
	JEFS	WRE0
	CRASH.(.WREFL)
WRE0	HS	0
	LH	R0,REBL
	JNFS	WRE2
	CRASH.(.WRECR)			:Crash if reserve tank empty
				:unreasonable drain on bufferlet storage

:	Link reserve tank into bufferlet free list.  Schedule CKZB (highest
:	priority) to refill the reserve tank, zapping buffers if necessary.
:	Then return.
WRE2	HS	0
	STH	R0,FREELT
	LIS	R0,0
	STH	R0,REBL
	LHI	R0,1F-PCKZB		:SCHEDULE REFILL OF RESERVE TANK
	SBT	R0,SQUEUE		:A HIGH PRIORITY PROCESS
	L	R0,WRERET

	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,WREDB2,,
	GL	WREDB2
	LM	R0,REGST                :restore regs           ###sdw
	EI	:BFSDBG

	JR	R0

::*********************************************************************
::
::	SUBROUTINE:	WCD:
::	FUNCTION:	Prefix a character to a buffer
::	CALLING SEQ:	JAL	R8,WCD
::
::*********************************************************************

:	If buffer empty, go handle same as WCI (WCFRST).
WCD	HS	0
	L	R3,BB,R2,		:USE THE IN PTR
	JE	WCFRST			:EMPTY BUFF, SAME AS A WCI

:	If no room in first bufferlet, go get another one (WDNXT).
	SIS	R3,1			:BACK UP PTR
	THI	R3,CBSZ-cbptsz		:OFF THE BUFFER?
	JEFS	WDNXT			:YES, GET ANOTHER BUFFERLET

:	Otherwise, store the character and update BB, then return to caller.
	STB	R1,0,R3			:NO, JUST STORE BYTE
	ST	R3,BB,R2,		:AND UPDATE 'BB'
	JR	R8

:	Prefix a bufferlet in order to prefix a char.
:	Increment BCT and bufferlets-in-use count.
WDNXT	HS	0
	lhi	R0,CBSZ-cbptsz		:PREFIX A BUFFERLET, INC BCT FIELD
	AHM	R0,BCT,R2,
	AM	R0,BFLTSV		:UPDATE COUNT OF BUFFERLETS IN USE
	JGEFS	WCD09			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCD09	HS	0
	IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	WCD01			:NO				###OAS
	AM	R0,HBFTSV		:YES, ADJUST COUNT		###OAS
	JGEFS	WCD01			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
WCD01	HS	0
	EI	:REBILD

	SRLS	R3,CBSZL
	STH	R3,WCDSAV		:SAVE BUFFERLET #		###GT

:	Get free list pointer. If something there, continue at WDNXT1.
WDNXT0	HS	0
	LHL	R3,FREELT		:LINK TO NEXT BUFFERLET IN CHAIN
	JNFS	WDNXT1			:LINK ADDRESS<>0,BUFFERLET CHAIN INTACT

:	Else call WRE to get reserve pool, then back to WDNXT0.
	JAL	R0,WRE			:FREE POOL EMPTY, GET LINK ADDRESS FROM
	JBS	WDNXT0			:RESERVE POOL AND SCHEDULE 'CKBZ' TO
					:REFILL RESERVE POOL, ZAPPING A BUFFER
					:IF NECESSARY.

:	Got a free bufferlet. Store the character at the end of the bufferlet,
:	update FREELT, and chain old first bufferlet to this one. Update BB and
:	return to caller.
WDNXT1	HS	0
	SLLS	R3,CBSZL		:MAKE PTR TO LAST BYTE
	AhI	R3,CBSZ-cbptsz+1
	STB	R1,0,R3			:PUT AWAY BYTE
	LHL	R0,1,R3			:GET THE LINK
	STH	R0,FREELT		:NEW HEAD OF LIST
	LHL	R0,WCDSAV		:RESTORE THE BUFFERLET # FOR LINK###GT
	STH	R0,1,R3			:CHAIN TO OLD BUFFLET
	ST	R3,BB,R2,		:SAVE NEW PTR
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	WHWI:
::	FUNCTION:	Write a HW from R1 into a buffer (index in R2),
::			escaping bytes 00-03.
::	CALLING SEQ:	JAL	R9,WHWI
::	INPUT:		R1 = HW
::			R2 = BUFFER INDEX
::	DESTROYED:	R1, R8
::	CALLS:		JAL	R8,WCI	Crashes (in WCI) if R2=0 or 4
::
::*********************************************************************

WHWI	HS	0
	EXBR	R1,R1
	THI	R1,0FC			:ESCAPE CHARACTERS 0 - 3
	JNFS	WHW1
	SLLS	R1,8
	JAL	R8,WCI
	SRLS	R1,8
WHW1	JAL	R8,WCI
	EXBR	R1,R1
	THI	R1,0FC
	JNFS	WHW2
	SLLS	R1,8
	JAL	R8,WCI
	SRLS	R1,8
WHW2	JAL	R8,WCI
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	WHWI0:
::	FUNCTION:	Same as WHWI but allows buffer index (R2) of 0 or 4.
::			Used by CRQ and LOGGER.
::	CALLING SEQ:	JAL	R9,WHWI0
::	INPUT:		R1 = HW
::			R2 = BUFFER INDEX
::	DESTROYED:	R1, R8
::	CALLS:		JAL	R8,WCI0
::
::*********************************************************************

WHWI0	HS	0
	EXBR	R1,R1			:DO LEFT BYTE FIRST
	THI	R1,0FC
	JNFS	WHWI01			:ESCAPE BYTES 00 - 03 ONLY
	SLLS	R1,8
	JAL	R8,WCI0			:WRITE 0 INTO BUF
	SRLS	R1,8
WHWI01	JAL	R8,WCI0
	EXBR	R1,R1			:GET 2ND BYTE INTO LOW-ORDER POSITION
	THI	R1,0FC
	JNFS	WHWI02			:ESCAPE 2ND BYTE ALSO
	SLLS	R1,8
	JAL	R8,WCI0
	SRLS	R1,8
WHWI02	JAL	R8,WCI0
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	WCIE:
::	FUNCTION:	Write a character (from R1), escaped if necessary, into
::		a buffer (index in R2).
::	CALLING SEQ:	JAL	R9,WCIE
::	INPUT:		R1 = CHARACTER
::			R2 = BUFFER INDEX
::	CALLS:		JAL	R8,WCI	Crashes (in WCI) if R2=0 or 4. 
::
::*********************************************************************

WCIE	HS	0
	THI	R1,0F8			:is it in the 0-7 range?
	JNFS	WCIE1
	EXHR	R1,R1			:if yes, shift zero to low byte
	JAL	R8,WCI			:and write in an escape
	EXHR	R1,R1			:get the data back back to low byte
WCIE1	JAL	R8,WCI			:write data byte to buffer
	JR	R9			:and return

::*********************************************************************
::
::	SUBROUTINE:	WCDE:
::	FUNCTION:	Prefix a character (from R1), escaped if necessary,
::			into a buffer (index in R2).
::	CALLING SEQ:	JAL	R9,WCDE
::	INPUT:		R1 = CHARACTER
::			R2 = BUFFER INDEX
::	DESTROYED:	R8
::	CALLS:		JAL	R8,WCD
::
::*********************************************************************

WCDE	JAL	R8,WCD
	THI	R1,0F8
	JNR	R9
	EXHR	R1,R1
	JAL	R8,WCD
	EXHR	R1,R1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	W2CI:
::	FUNCTION:	Write 2 characters (from R1), without escaping, into a
::		buffer (index in R2).
::	CALLING SEQ:	JAL	R9,W2CI
::	INPUT:		R1 = 2 CHARACTERS
::			R2 = BUFFER INDEX
::	DESTROYED:	R8
::	CALLS:		JAL	R8,WCI	Crashes (in WCI) if R2=0 or 4.
::
::*********************************************************************

W2CI	HS	0
	EXBR	R1,R1			:HIGH-ORDER BYTE GOES FIRST
	JAL	R8,WCI
	EXBR	R1,R1
	JAL	R8,WCI			:WRITE SECOND BYTE
	JR	R9			:AND RETURN

	SUBTTL	BUFF (GCI - Get character from a buffer)

::*********************************************************************
::
::	SUBROUTINE:	GCI:
::	FUNCTION:	Get a byte of data from a buffer.
::	CALLING SEQ:	JAL	R8,GCI
::	INPUT:		R2 = BUFFER NUMBER X 4
::	OUTPUT:		R1 = CONTAINS THE CHARACTER
::	DESTROYED:	R0, R3
::	PRESERVED:	ALL OTHERS
::
::*********************************************************************

:	Normal entry point.  Make sure not using buffer	index 0 or 4.
:	(CRQ and LOGGER enter at GCI0).
GCI	HS	0
	CLHI	R2,4			:TEST FOR BUFFER NUMBER 0 OR 1
	JGFS	GCI0			:OK
	CRASH.(.GCICR)			:Illegal use of buffer 0 or 4 at GCI

:	IF	ESYNC
       IF	1-NAD68		:NAD or Nada				###wjl

:	Entry point for CRQ, LOGGER using buffer index 0, 4.
:	Fall thru here for valid regular GCI buffer index.
GCI0	HS	0
:	Edit buffer's BF. Crash if negative.  Else continue at GCI1.
	IF	DB.DEB
	LH	R1,BF,R2,		:EDIT BUFFER'S BF
	JGEFS	GCI1
	DBOOPS
	EI	:DB.DEB
GCI1	HS	0
:	GCI instruction takes us to GCIERR on empty buffer or invalid buffer
:	index, to GCRET to return empty bufferlet, to GCLAST when buffer is
:	empty.  Otherwise, fall thru, check for buffer tracing, and return.
GCI2	HS	0
	HC	3812			:GCI  R1,R2

	HC	BE-BB			:SIZE OF BB STORAGE
	HC	GCIERR-GCI2		:HERE ON EMPTY OR INVALID BUF #
	HC	BB/4			:ADDRESS OF BB STORAGE /4
	HC	GCRET-GCI2		:HERE TO RETURN EMPTY BUFFERLET
	HC	GCLAST-GCI2		:HERE TO CLEAR EMPTY BUFFER

	JR	R8			:DONE

:	Here from GCI instruction for bad buffer index or empty buffer.
GCIERR	HS	0
	CRASH.(.GCIC0)

:	ELSE	:NOT ESYNC
       ELSE	:NAD68		:NAD to 68020 assembler			###wjl

GCI0	L	R3,BB,R2,		:GET THE OUT PTR
	JNFS	GCI1
	JAL	R0,OOPS,,		:EMPTY BUFFER
	JR	R8
GCI1	LB	R1,0,R3			:GET THE CHAR
	CL	R3,BE,R2,		:IS IT THE LAST?
	JEFS	GCLAST
	AIS	R3,1			:NO, MOVE TO NEXT SLOT
	THI	R3,CBSZ-1
	JE	GCRET			:TIME TO RETURN BFLT
	ST	R3,BB,R2,
	JR	R8
:	EI	:ESYNC
       EI	:NAD68
::*********************************************************************
::
::	GCLAST:	Here when GCI empties a buffer.
::
::*********************************************************************

:	Clear BB, BE, BCT and reset attention flag.
:	Decrement count of bufferlets in use.
:	Link to and update FREELT.
GCLAST	HS	0
	LIS	R0,0			:LAST CHAR - CLEAR THE BUFFER
	ST	R0,BB,R2,		:SET BOTH PTRS TO 0
	ST	R0,BE,R2,
	STH	R0,BCT,R2,
	LH	R0,BF,R2,		:CLEAR ATTN FLAG
	RBT	R0,NFLAGS
	AHI	R3,CBSZ-1		:INDEX PTR TO LINK
	NHI	R3,-cbsz
	lhi	R0,cbptsz-cbsz		:negative number of data bytes in bflt
	AM	R0,BFLTSV		:DECREMENT NUMBER OF BUFFERLETS IN USE
	JGEFS	GCLAS9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS

GCLAS9	HS	0
	IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	GCLAS1			:NO				###OAS
	AM	R0,HBFTSV		:YES, INCREMENT COUNT		###OAS
	JGEFS	GCLAS1			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
GCLAS1	HS	0
	EI	:REBILD

	LHL	R0,FREELT
	STH	R0,0,R3
        sis     r3,1                    :put into correct area for shifts
	SRLS	R3,CBSZL
	STH	R3,FREELT
	JR	R8			:RETURN TO CALLER

::*********************************************************************
::
::	GCRET:	GCI emptied a bufferlet. Return it to the free list.
::
::*********************************************************************

:	Decrement BCT and bufferlet-in-use count.
:	Return bufferlet and link to FREELT.
GCRET	HS	0
        THI     R3,CBSZ-1               :TRUE END OF BFLET?
        JEFS    GCRE00                  :yes, return it
        ST      R3,BB,R2,
        JR      R8                      :and done
GCRE00	LHI	R0,cbptsz-cbsz		:RETURN A BFLET - DEC CNT
	AHM	R0,BCT,R2,
	AM	R0,BFLTSV		:DECREMENT COUNT OF BUFFERLETS IN USE
	JGEFS	GCRET9			:CHECK FOR BFLTSV GOING<0	###OAS
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
GCRET9	HS	0

	IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	GCRET1			:NO				###OAS
	AM	R0,HBFTSV		:YES, ADJUST COUNT		###OAS
	JGEFS	GCRET1			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
GCRET1	HS	0
	EI	:REBILD

	LHL	R0,0,R3			:GET LINK
	SLLS	R0,CBSZL			:COMPUTE PTR
	AIs	R0,cbptsz
	ST	R0,BB,R2,
	LHL	R0,FREELT		:PREFFIX BUFF TO LIST
	STH	R0,0,R3
	sis	R3,1			:COMPUTE BFLET #
	SRLS	R3,CBSZL
	STH	R3,FREELT
	JR	R8			:RETURN TO CALLER

::*********************************************************************
::
::	SUBROUTINE:	GHWI:
::	FUNCTION:	Assemble a HW (no escapes) in R1 from a buffer.
::		Buffer must contain a HW of data or we'll crash in GCI.
::	CALLING SEQ:	JAL	R9,GHWI
::	DESTROYED:	R0, R3, R4
::
::*********************************************************************

GHWI	HS	0
	JAL	R8,GCI			:GET CHAR
	LR	R1,R1
	JNFS	GHWI10
	JAL	R8,GCI			:ESCAPED CHAR
GHWI10	LR	R4,R1
	EXBR	R4,R4
	JAL	R8,GCI			:SECOND CHAR
	LR	R1,R1
	JNFS	GHWI20			:###jhl
	JAL	R8,GCI
GHWI20	AR	R1,R4			:###jhl
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	GHWI0:
::	FUNCTION:	Same as GHWI but accepts buffer index 0 or 4.
::	CALLING SEQ:	JAL	R9,GHWI0
::	INPUT:		R2 = VALID BUFFER INDEX
::	OUTPUT:		R1 = HALFWORD
::	DESTROYED:	R0, R3, R4, R8
::	CALLS:		JAL	R8,GCI0
::
::*********************************************************************

GHWI0	HS	0
	JAL	R8,GCI0			:GET CHARACTER
	LR	R1,R1
	JNFS	GHWI01			:NOT ESCAPE
	JAL	R8,GCI0
GHWI01	LR	R4,R1
	EXBR	R4,R4			:MOVE FIRST BYTE TO HI-ORDER POS. OF HW
	JAL	R8,GCI0
	LR	R1,R1			:REQUIRE ESCAPE?
	JNFS	GHWI02			:NO
	JAL	R8,GCI0			:YES - GET ESCAPED CHARACTER
GHWI02	AR	R1,R4			:COMBINE FIRST AND SECOND CHARACTERS
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	GCIE:
::	FUNCTION:	Get a character (returned in R1) from a buffer
::			(index in R2),	stripping escapes.
::	CALLING SEQ:	JAL	R9,GCIE
::	INPUT:		R2 = VALID BUFFER INDEX  Crashes if R2=0 or 4.
::	OUTPUT:		R1 = CHARACTER
::	DESTROYED:	R1, R8
::	CALLS:		JAL	R8,GCI
::
::*********************************************************************

GCIE	HS	0
	JAL	R8,GCI			:GET CHAR (UNESCAPED)
	LR	R1,R1
	JNR	R9
	JAL	R8,GCI
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	G2CI:
::	FUNCTION:	Get 2 characters (into R1) from a buffer (index in R2),
::			without stripping escapes.
::	CALLING SEQ:	JAL	R9,G2CI
::	INPUT:		R2 = VALID BUFFER INDEX  Crashes (in GCI) if R2=0 or 4.
::	OUTPUT:		R1 = 2 CHARACTERS
::	DESTROYED:	R1, R4, R8
::	CALLS:		JAL	R8,GCI
::
::*********************************************************************

G2CI	HS	0
	JAL	R8,GCI
	LR	R4,R1
	EXBR	R4,R4			:FIRST CHARACTER IN HIGH-ORDER BYTE
	JAL	R8,GCI
	OR	R1,R4			:COMBINE BOTH CHARACTERS
	JR	R9			:AND RETURN

	SUBTTL	BUFF (PCI - Peek at first character in a buffer)

::*********************************************************************
::
::	SUBROUTINE:	PCIS:/PCI:/NCI:
::	FUNCTION:	ENTRY POINTS:
::		PCIS -	Peek at the first character in a buffer.
::		PCI  -	Peek at (the next) character in a buffer.
::			R3 must contain a legal pointer into the buffer,
::			else garbage is returned.  Before calling PCI,
::			set up R3 to point to desired position in buffer,
::			or use PCIS for first character, PCI for subsequent
::			characters in sequence.  R3 must stay in tact from
::			PCIS to last PCI.  
::		NCI  -	Same as PCI, but does not peek at character,
::			just increments pointer into buffer.
::
::*********************************************************************

:	Init R3 to point to first character in buffer (BB).
PCIS	HS	0
	L	R3,BB,R2,		:INIT PCI

:	Enter here if R3 already set up.
:	(Either by caller or by previous call to PCIS)
PCI	HS	0
	LB	R1,0,R3			:GET THE CHARACTER

:	Enter here to increment pointer into buffer (R3) by one position,
:	without peeking at characters.
NCI	HS	0
	AIS	R3,1			:INC PTR
	THI	R3,CBSZ-1
	JNR	R8
	LHL	R3,0,R3			:MOVE TO NEXT BUFFERLET
	SLLS	R3,CBSZL
	AIs	R3,2
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	PCIE:
::	FUNCTION:	Peek at next (escaped) character in buffer.
::			Same as PCI, but strips escapes.
::	CALLING SEQ:	JAL	R9,PCIE
::	CALLS:		JAL	R8,PCI
::
::*********************************************************************

:	PCI a char.  If 00, PCI another and return. Else just return.
PCIE	HS	0
	JAL	R8,PCI			:PEEK AT NEXT CHARACTER
	LR	R1,R1			:ESCAPE?
	JNR	R9			:NO - RETURN 
	JAL	R8,PCI			:YES - GET ESCAPED CHARACTER AND
	JR	R9			:RETURN


::*********************************************************************
::
::	SUBROUTINE:	PHWI:
::	FUNCTION:	Peek at next HW (returned in R1) in a buffer, stripping
::		escapes.  R3 must contain a valid pointer into the buffer
::		(see PCI).  There must be a HW of data in the buffer, or
::		garbage is returned.
::	CALLING SEQ:	JAL	R9,PHWI
::	INPUT:		R3 = VALID BUFFER POINTER
::	OUTPUT:		R1 = HW
::	DESTROYED:	R1, R4, R8
::	CALLS:		JAL	R8,PCI
::
::*********************************************************************

PHWI	HS	0
	JAL	R8,PCI			:GET A CHAR
	LR	R1,R1			:TEST FOR ESCAPE CHAR '00'
	JNFS	PHWI1			:SKIP ANOTHER READ IF NOT ESC-PAIR
	JAL	R8,PCI			:READ SECOND OF PAIR IF ESCAPED CHAR
PHWI1	LR	R4,R1			:SAVE CHAR IN REG 4
	EXBR	R4,R4			:PUT IN 2ND BYTE FROM RIGHT FOR LATER
	JAL	R8,PCI			:GET NEXT CHARACTER
	LR	R1,R1			:TEST FOR ESCAPE CHARACTER
	JNFS	PHWI2			:SKIP ANOTHER READ IF NOT ESCAPE-PAIR
	JAL	R8,PCI			:READ SECOND OF PAIR IF ESCAPED
PHWI2	AR	R1,R4			:COMBINE SECOND BYTE WITH FIRST IN R1
	JR	R9			:RETURN TO CALLING ROUTINE

::*********************************************************************
::
::	SUBROUTINE:	CHWI:
::	FUNCTION:	RETURNS A HALF-WORD IN R1 AND REPLACES IT WITH 'FFFF'.
::	CALLING SEQ:	JAL	R9,CHWI
::	DESTROYED:	R0
::	CALLS:		JAL	R8,NCI
::
::*********************************************************************

CHWI	HS	0
	LCS	R0,1
	LB	R4,0,R3			:GET A CHARACTER
	JNFS	CHWI1			:IT IS NOT BEING ESCAPED, SKIP
	JAL	R8,NCI,,		:ESCAPED, INC PTR, GET NEXT CHAR###CY
	LB	R4,0,R3
CHWI1	STB	R0,0,R3			:REPLACE IT W/ 'FF'
	EXBR	R4,R4
	JAL	R8,NCI,,		:INC PTR  			###CY
	LB	R1,0,R3			:AND REPEAT
	JNFS	CHWI2
	JAL	R8,NCI,,		:###CY
	LB	R1,0,R3
CHWI2	STB	R0,0,R3
	JAL	R8,NCI,,		:###CY
	AR	R1,R4
	JR	R9

	SUBTTL	BUFF (CBCLR - Clear a buffer)

::*********************************************************************
::
::	SUBROUTINE:	CBCLR: / GLBCLR:
::	FUNTION:	Clear a buffer (index in R2), reset its attention flag.
::			Crashes if R2 not a valid buffer index, or if buffer's
::			BF is negative.
::	CALLING SEQ:	JAL	R8,CBCLR
::	INPUT:		R2 = VALID BUFFER INDEX
::	DESTROYED:	R0, R3
::
::*********************************************************************
::GLBCLR avoids possible complications by not resetting the BF, which is 
::actually marked as Log-in state - therefore not a real BF, therfore avoiding
::a wild reset of some bit somewhere between 10 and 17.

	IF	T2GATE
GLBCLR	HS	0		:Special section for Gateway 1/2 circuits
	THI	R2,3			:LEGAL BUFF?
	JE	GBCLR1
	CRASH.(.CBCLC)
GBCLR1	LH	R3,BF,R2,		:GET ABSOLUTE CHANNEL NUMBER 
	JGE	GBCLR2
	CRASH.(.CBCL0)
GBCLR2	L	R3,BE,R2,		:GET BUFFER FILL POINTER
	JER	R8			:ZERO, BUFFER EMPTY. RETURN
	J	GLBC01		:continue with clearing process
	EI	:T2GATE


CBCLR	HS	0
	ST	R2,TSTSAV		:TESTING ###EV
	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,CBCDB1,,
	GL	CBCDB1
	LM	R0,REGST                :restore regs           ###sdw
	EI	:BFSDBG

	THI	R2,3			:LEGAL BUFF?
	JE	CBCLR1
	CRASH.(.CBCLC)
CBCLR1	LH	R3,BF,R2,		:GET ABSOLUTE CHANNEL NUMBER 
	JGE	CBCLR2
	CRASH.(.CBCL0)
CBCLR2	RBT	R3,NFLAGS		:CLEAR ATTN FLAG
	L	R3,BE,R2,		:GET BUFFER FILL POINTER
	JER	R8			:ZERO, BUFFER EMPTY. RETURN

:	If the buffer is empty, just RETURN.  Otherwise, chain the first
:	bufferlet to the free list, clear BB, BE, and BCT, decrement
:	bufferlets-in-use count, then RETURN.
GLBC01	AHI	R3,CBSZ-1		:MAKE PTR TO BFRLT LINK
	NHI	R3,@(CBSZ-1)
	LHL	R0,FREELT		:INSERT HEAD OF LIST
	STH	R0,0,R3
	L	R3,BB,R2,		:COMPUTE # OF FIRST BUFFERLET
	SIs	R3,2
	SRLS	R3,CBSZL
	STH	R3,FREELT

	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,CBCDB2,,
	GL	CBCDB2
	LM	R0,REGST                :restore regs           ###sdw
	EI	:BFSDBG

	LIS	R0,0			:CLEAR BOTH PTRS
	ST	R0,BE,R2,
	ST	R0,BB,R2,
	LHL	R3,BCT,R2,		:BCT=14*N-13,N=NUMBER OF B'LETS CHAINED
	ahi	R3,CBSZ-1-cbptsz	:R3 NOW = 14*(NUMBER OF B'LETS CHAINED)
	STH	R0,BCT,R2,		:ZERO OUT THE BCT COUNT
	SR	R0,R3			:FORM 2'S COMPLEMENT OF R0 R3???

	IF	REBILD
	CI	R2,HBUFN		:IS THIS A HISTORY BUFFER	###OAS
	JLFS	CBCLR3			:NO				###OAS
	AM	R0,HBFTSV		:YES, ADJUST COUNT		###OAS
	JGEFS	CBCLR3			:CHECK FOR HBFTSV GOING<0	###OAS
	JAL	R7,NEGHCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS
CBCLR3	HS	0
	EI	:REBILD

	AM	R0,BFLTSV		:DECREMENT THE NUMBER OF B'LETS IN USE
	JGER	R8			:				###TZ
	JAL	R7,NEGBCR,,		:ERROR, CRASH (R7=CRASH LOC)	###OAS


	SUBTTL	BUFF (CKZB - Refill bufferlet reserve tank)

::*******************************************************************
::
::	PROCESS:	CKZB:
::	FUNCTION:	Refill bufferlet reserve tank.
::		Highest priority process in the node code.  Gets scheduled
::		whenever the reserve tank is linked into the free list.  We
::		must recover 80x bufferlets to refill the reserve tank. If
::		they are not available, we will zap buffers until they are.
::
::*********************************************************************

:	Init R1 to 80 (number of free bufferlets required to refill reserve
:	tank).  Get the free list pointer in R3, continue at REB3.
CKZB	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(CKZB  )			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU
	LHI	R1,80			:80 bufferlets to refill reserve tank
CKZB0	LHL	R3,FREELT		:Free list pointer to R3
	JFS	REB3			:Skip on first pass

:	Get the current bufferlet's link pointer to R3.
REB2	HS	0
	LR	R2,R3
	SLLS	R2,CBSZL
	LHL	R3,CBSZ,R2

:	If R3 is 0 (last bufferlet), go to REBZ to zap another buffer.
:	Else decrement R1 by 1 and back to REB2 until R1 is 0
:	(80 bufferlets found).
REB3	HS	0
	JE	REBZ
	SIS	R1,1
	JGBS	REB2

:	Got 80 bufferlets. Link them into the reserve tank (REBL),
:	update FREELT, and DISMISS to EXEC.
	STH	R1,CBSZ,R2
	LHL	R1,FREELT		:80 BUFFERLETS FOUND,
	STH	R1,REBL			:LINK THEM INTO RESERVE TANK
	STH	R3,FREELT
	
	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,CKZDB1,,
	GL	CKZDB1
	LM	R0,REGST                :restore regs           ###sdw
	EI	:BFSDBG

	J	EXDISM,,

:	ZAP A BUFFER, AND RETURN TO CKBZ TO TRY AGAIN TO REFILL RESERVE TANK.

:	Find the biggest buffer (based on BCT) and call BUFZAP to zap it and
:	report to sup.  Then back to CKZB to finish refilling reserve tank.
REBZ	HS	0
	LHI	R1,BBSIZE-4		:ZAP BIGGEST BUFFER, MAKE MORE STORAGE
	LIS	R7,0
REBZ1	LHL	R0,BCT,R1,
	CLR	R7,R0
	JGEFS	REBZ2
	LR	R7,R0			:LARGEST COUNT SO FAR
	LR	R2,R1			:AND BUFFER INDEX
REBZ2	SIS	R1,4
	JGEBS	REBZ1
:	R2 CONTAINS INDEX FOR BUFFER WITH LARGEST COUNT. ZAP IT.
	JAL	R0,BUFZAP		:ZAP BUFFER, REPORT TO SUP

	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,RBZDB1,,
	GL	RBZDB1
	LM	R0,REGST                :restore regs           ###sdw
	EI	:BFSDBG

	J	CKZB			:###TZ

::*********************************************************************
::
::	SUBROUTINE:	BUFZAP:
::	FUNCTION:	Zap the buffer specified by R2.
::	ZAP BUFFER SPECIFIED BY BUFFER INDEX IN R2. CLEAR BUFFER, AND PLACE
::	BLACK BALL INTO BUFFER TO NOTIFY DESTINATION THAT
::	DATA HAVE BEEN LOST. MAKE REPORT TO SUPERVISOR.
::	CALLING SEQ:	JAL	R0,BUFZAP
::	INPUT:		R2 = BUFFER INDEX
::	PRESERVED:	ALL OTHER REGISTERS
::	CALLS:		JAL	R8,CBCCT
::			JAL	R8,CBCLR
::			JAL	R9,W2CI
::			JAL	R10,SUP12
::
::*********************************************************************

:	Get and save (R4) the exact buffer byte count, then clear the buffer.
BUFZAP	HS	0
	STM	R0,BFZPRS		:PRESERVE CONTEXT
	JAL	R8,CBCCT
	LR	R4,R1			:SAVE EXACT BUFFER COUNT
	JAL	R8,CBCLR		:CLEAR BUFFER

	IF	BFSDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LR	R8,R4			:BUFFER COUNT
	JAL	R14,BFZDB1,,
	GL	BFZDB1
	LM	R0,REGST                :restore regs           ###sdw
	EI	:BFSDBG

:	If we're zapping a history buffer, update HSEQN by the count of
:	characters clear (R4)--total pruning.
:	Go to BUFZP4 to bypass putting a black ball in.
	IF	REBILD
	CI	R2,HBUFN		:HISTORY BUFFER?
	JLFS	BUFZP2			:NO - GARDEN VARIETY
	AM	R4,HSEQN,R2,		:YES - TOTAL PRUNING! ADVANCE HIST SEQ#
	JFS	BUFZP4			:BYPASS BLACK BALL
	EI	:REBILD

:	Not a history buffer, so put a black ball in buffer to inform
:	destination of data loss.
BUFZP2	HS	0
	LHI	R1,01FD			:BLACK BALL
	JAL	R9,W2CI

:	Inform supe and CRYPTO of buffer zap, bump count of buffer zaps,
:	return to caller.
BUFZP4	HS	0
	LIS	R0,NR.BFZ		:BUFFER ZAP NODE REPORT
	STH	R0,SUPMBF
	STH	R2,SUPMBF+2		:BUFFER INDEX
	STH	R4,SUPMBF+4		:BUFFER COUNT
	XHI	R2,4			:FLIP BUFFER
	LHL	R0,BF,R2,		:GET GUILTY CHANNEL
	STH	R0,SUPMBF+6		:AND STORE FOR XRAY DISPLAY
	XHI	R2,4			:RECOVER BUFFER
	JAL	R10,SUP12,,		:NODE REPORT AND CRYPTOGRAM
	LIS	R0,1
	AHM	R0,BZAPCT		:COUNT BUFFER ZAPS
	LM	R0,BFZPRS
	JR	R0			:RETURN

	SUBTTL	BUFF (Utilities)


::*********************************************************************
::
::	SUBROUTINE:	RTBFTS:
::	FUNCTION:       ReTurn BufFerleTS  removes the number of chars
::		specified in R0 from buffer in R2.  Returns actual
::		number chars removed in R0.  Destroys R0 and R3.  Much
::		more efficient than either using a GCI per char or
::		repeatedly calling a similar routine that only returns
::		a bflet at a time (which removed between 1 and 14 chars
::		per bflet).                             ###sdw
::
::*********************************************************************

RTBFTS  ST      R4,R4RBFT       :save a reg
        STH     R0,R0RBFT       :save count to remove
        ST      R1,R1RBFT       :save R1
        cbcctm(r4,r2,r1)        : CBCCT R4,R2   (r1 is scratch)
        CR      R4,R0           :have enough (r4) to return asked amount? (r0)
        JG      RTBFT1          :jump if enough
        ST      R8,R0RBFT       :just empty it
        JAL     R8,CBCLR
        L       R8,R0RBFT       :save regs as use normal empty
        LR      R0,R4           :restore count removed
        L       R1,R1RBFT
        L       R4,R4RBFT
        JR      R8              :handle the complete empty case

RTBFT1  L       R3,BB,R2,       :get start
        LR      R1,R3           :get copy to calc how many in 1st buflet
        ahi     R1,CBSZ-1       :bump up to pointer plus a byte
        NHI     R1,-CBSZ        :knock of a bit and get pointer
        SR      R3,R1           :R3 gets negative count of chars in 1st buflet
        AR      R0,R3           :that many already read
        JL      RTBFT7          :all chars to remove were in first bufferlet
        LIS     R4,0            :count how many bflets removed for BCT
RTBFT2  LR      R3,R1           :repeat for next buflet
        LHL     R1,0,R3         :get next pointer to next buflet
        SLLS    R1,CBSZL        :make pointer into address
        ahi     R1,CBSZ
        shi     R4,CBSZ-cbptsz  :another bflet returned
        shi     R0,CBSZ-cbptsz  :reduce count of how many to remove
        JGEBS   RTBFT2          :new BB will be in next buflet
        AHM     R4,BCT,R2,      :r0 is BCT by buflet
        AM      R4,BFLTSV
        JGEFS   RTBFT4
        JAL     R7,NEGBCR,,     :crash if in use goes negative
RTBFT4  HS      0
      IF REBILD         :rebuild's in use
        CI      R2,HBUFN        :history buff?
        JLFS    RTBFT5          :nope
        AM      R4,HBFTSV       :fewer history in use
        JGEFS   RTBFT5
        JAL     R7,NEGHCR,,     :crash if neg
RTBFT5  HS      0
      EI  :REBILD
        LHL     R4,FREELT       :chain 1st free to end of chain we're returning
        STH     R4,0,R3
        L       R4,BB,R2,       :1st free will is buflet number of what was BB
        ahi     R4,CBSZ-1       :make the address into pointer
        NHI     R4,-CBSZ
        sis     R4,2
        SRLS    R4,CBSZL        :now a pointer
        STH     R4,FREELT       :newest free
RTBFT7  AR      R1,R0           :R1 is end of bflet, R4 is chars from end
        ST      R1,BB,R2,       :save new bb
        LHL     R0,R0RBFT       :get how many removed
        L       R1,R1RBFT       :restore a couple of regs
        L       R4,R4RBFT
        JR      R8              :nicely done  ###sdw

::*********************************************************************
::
::      SUBROUTINE:     RTBFTA:
::	FUNCTION:
::      returns number of chars in R0 plus however many to ensure that
::      first char in buff could not be a second char of a char pair
::      Can't allow potential split char be intepreted as a first char
::      of a pair since this probably would make an invalid char pair.
::
::*********************************************************************

        IF      REBTST
RTBFTA  JAL     R8,RTBFTS       :remove specified number of char
        LHL     R1,BCT,R2,
        JER     R9
        JAL     R8,PCIS
        SIS     R1,3
        JGR     R9              :no problem
        LIS     R4,1            :count how many extra read
        JFS     RTBFA2
RTBFA1  JAL     R8,PCIS
        SIS     R1,3
        JGFS    RTBFA3
        AIS     R4,1
RTBFA2  JAL     R8,GCI          :take out the offending char
        LHL     R1,BCT,R2,
        JGBS    RTBFA1          :make sure buffer not empty
RTBFA3  LHL     R0,R0RBFT       :get back R0 from RTBFTS
        AR      R0,R4           :and extra chars
        L       R4,R4RBFT
        JR      R9
        EI :REBTST

::*********************************************************************
::
::	SUBROUTINE:	CBCCT:
::	FUNCTION:	Compute the (exact) count (returned in R1) of bytes in
::			a buffer (index in R2).
::	CALLING SEQ:	JAL	R8,CBCCT
::	INPUT:		R2 = BUFFER NUMBER * 4
::	OUTPUT:		R1 = CHARACTER COUNT
::
::*********************************************************************


:	CBCCT:
:	RETURNS COUNT OF CHARACTER IN BUFFER. (IN R1)
:	***NOTE THAT THE MAXIMUM # CHARACTERS ALLOWED IN A BUFFER
:	IS 2^15-1 (I.E., HI ORDER BIT OF COUNT MUST BE 0). OTHERWISE AN
:	OVERFLOW WILL RESULT.****	:?? should be FFF0  ??		###wjl

CBCCT	LHL	R0,BB+2,R2,
	NHI	R0,CBSZ-1
	LHL	R1,BE+2,R2,
	NHI	R1,CBSZ-1
	SR	R1,R0
:					:was	AH	R1,BCT,R2,	###wjl
	LHL	R0,BCT,R2,		:for BCT > 7FFF			###wjl
	AR	R1,R0			:  will cause crash		###wjl
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	SNDFX0:
::	FUNCTION:	Write a SQFIX with a count of 0 into a buffer
::		(index in R2).
::		This special sextet is sent immediately behind a needle to
::		determine whether a new circuit is rebuildable.  If it is,
::		the destination node will respond with a SQACK with a count 
::		of 0 before sending any data.  If we don't get a SQACK0 
::		before any data, we know the circuit is not rebuildable..
::	CALLING SEQ:	JAL	R9,SNDFX0
::	INPUT:		R2 = BUFFER INDEX
::	DESTROYED:	R1, R4, R8
::	CALLS:		JAL	R8,WCI
::
::*********************************************************************

	IF	REBILD

SNDFX0	LR	R4,R3			:SAVE R3			###GT
	LIS	R1,3			:SEND BACK A SQFIX 0		###GT
	JAL	R8,WCI
	LIS	R1,SQFIX&0FF
	JAL	R8,WCI			:TO DETERMINE REBUILDABILITY	###GT
	LIS	R1,0			:SEQUENCE NUMBER = 0
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	JAL	R8,WCI
	LR	R3,R4			:RESTORE R3
	JR	R9			:RETURN

	EI	:REBILD

	SUBTTL	BUFF (GFCBUF/RFCBUF - Get/Return free character buffer pair)

::*********************************************************************
::
::	SUBROUTINE:	GFCBUF:
::	FUNCTION:	Grab-Free-Character-BUFfer
::	CALLING SEQ:	JAL	R8,GFCBUF
::	OUTPUT:		R2 = BUFFER #
::	DESTROYED:	R0
::
::*********************************************************************

:	Get buffer index from FREELB, crash if 0, or if <CIRZBF, or if >HBUFN-8
GFCBUF	HS	0

	IF	BFSDBG			:DEBUGGER			###LSH
	STM	R0,REGST
	JAL	R14,GFCDB1,,
	GL	GFCDB1
	LM	R0,REGST                :restore regs           ###sdw
	EI	:BFSDBG		

	LHL	R2,FREELB		:GET THE BUFF #
	JE	OP8063			:NONE, COMPLAIN
	CLHI	R2,CIRZBF		:RANGE CHECK BUFFER NUMBER
	JL	OP8263			:TOO LOW
	CI	R2,HBUFN-8
	JG	OP8263			:TOO HIGH

:	Get linked buffer (via BB), crash if <CIRZBF, or if >HBUFN-8,
:	or if not multiple of 4.
	LHL	R0,BB,R2,		:UPDATE FREE LIST
	JE	GFCEXI			:immediate return - out of buffers!#wjl
	CLHI	R0,CIRZBF		:RANGE CHECK LINKED BUFFER NUMBER
	JL	OP8463			:(NEW HEAD OF FREE LIST)
	CI	R0,HBUFN-8
	JG	OP8463
	THI	R0,3			:BETTER BE A BUFF #
	JN	OP8663			:NOT

:	BUFFER EDITS COMPLETE - STORE NEW HEAD OF FREE LIST
:	Got good free buffer and linked buffer index.
:	Update the free list, clear the new buffers' BFs and BB
:	(also history buffer's BF if REBILD).
:	Skip +4 RETURN.
	STH	R0,FREELB
	LIS	R0,0			:CLEAR THE ATTN FLAG
	STH	R0,BF,R2,
	STH	R0,BF+4,R2,

	IF	REBILD
	SRHLS	R2,1
	STH	R0,BF+HBUFN,R2,
	SLHLS	R2,1
	EI	:REBILD

	STH	R0,BB,R2,

	IF	\TZ.TST
	DBCRY.(TZ.TST,R2,R8)
	EI	:TZ.TST

	J	4,R8			:SKIP RETURN

GFCEXI	SKIP(0,R8)			:immediate return		###wjl

OP8063	CRASH.(.GFCR0)			:out of buffers
OP8263	CRASH.(.GFCR1)			:free list pointer out of range
OP8463	CRASH.(.GFCR2)			:linked buffer pointer out of range
OP8663	CRASH.(.GFCR3)			:bad buffer index, not mult of 4

::**********************************************************************
::
::	SUBROUTINE:	RFCBUF:
::	FUNCTION:	RETURNS A BUFFER PAIR TO THE FREE LIST.
::			USES 'BB' AS LINK IN FREE BUFFER CHAIN.
::			SETS 'BF' TO 'DEAD' TO INDICATE BUFF NOT IN USE.
::	CALLING SEQ:	JAL	R8,RFCBUF
::	INPUT:		R2 = BUFFER #
::
::*********************************************************************

RFCBUF	STH	R2,RFCSAV		:SAVE BUFFER #
	NHI	R2,-8			:USE LOW ORDER HALF of pair (even bfr)

	IF	BFSDBG			:DEBUGGER			###LSH
	STM	R0,REGST
	JAL	R14,RFCDB1,,
	GL	RFCDB1
	LM	R0,REGST                :restore regs           ###sdw
	EI	:BFSDBG		

	CLHI	R2,CIRZBF		:RANGE CHECK BUFFER # BEING RETURNED
	JL	OP8863			:ERROR - TOO LOW
	CI	R2,HBUFN-8
	JG	OP8863			:TOO HIGH
	LR	R1,R8			:SAVE LINK
	JAL	R8,CBCLR,,		:DON'T TAKE ANY BUFFERLETS WITH IT
	LHL	R0,FREELB
	STH	R0,BB,R2,
	STH	R2,FREELB

	IF	\TZ.TST
	DBCRY.(TZ.TST,R2,R1)
	EI	:

	IF	REBILD
	LIS	R0,0			:CLEAR OTHER VARIABLES
	ST	R0,SEQN,R2,
	ST	R0,SEQN+4,R2,
	EI	:REBILD

	XHI	R2,4			:CLEAR OTHER HALF

	JAL	R8,CBCLR,,

	LHI	R3,DEAD			:SET BF'S TO 'DEAD'
	STH	R3,BF-4,R2,
	STH	R3,BF,R2,

	SRHLS	R2,1			:CLEAR HISTORY BUFF VARIABLES
	LR	R0,R2
	SRHLS	R0,2			:REBUILD TIMEOUTS
	RBT	R0,CRQBSY		:CIRCUIT NO LONGER IN USE

	IF	REBILD
	RBT	R0,SQFIXV		:CLEAR REBUILD-QUADS-RECEIVED ARRAY 
	EI	:REBILD

	RBT	R0,CRQEND		:CIRCUIT NO LONGER AN ENDPOINT
	RBT	R0,REBTMO
	RBT	R0,REBTMI

	IF	REBILD
	RBT	R0,SQFTMO		:NO REBUILD			###GT
	RBT	R0,SQFTMI
	NHI	R2,-4
	AI	R2,HBUFN
	JAL	R8,CBCLR,,
	LIS	R0,0
	ST	R0,HSEQN,R2,
	ST	R0,RINVC,R2,
	STH	R0,RNFLAG,R2,
	STH	R0,RHOSTN,R2,
	STH	R0,RBASE,R2,
	STH	R0,RHBSZ,R2,
	EI	:REBILD

	LHL	R2,RFCSAV
	LR	R8,R1
	JR	R8

OP8863	CRASH.(.RFCR0)

	SUBTTL	BUFF (Copy message into a buffer)

::*********************************************************************
::
::	SUBROUTINE:	BUFCAN:
::	FUNCTION:	Copy a canned message (address in R4) into a buffer
::		(index in R2).  First byte of message must be byte count.
::	CALLING SEQ:	JAL	R9,BUFCAN
::	INPUT:		R2 = BUFFER INDEX
::			R4 = ADDRESS
::	DESTROYED:	R1, R4, R5, R8
::	CALLS:		JAL	R8,WCI
::
::*********************************************************************

BUFCAN	HS	0
	ST	R5,BURSAV		:Save reg 5 (CHN)
	LB	R1,0,R4			:GET LENGTH
	JER	R9			:ZERO COUNT, RETURN
	LIS	R5,1			:COMPUTE NEG. INDEX
	SR	R5,R1
	AR	R4,R1			:COMPUTE END OF STRING

BUFCA1	HS	0			:LOOP
	LB	R1,0,R4,R5		:GET DATA BYTE
	JAL	R8,WCI			:WRITE IT INTO BUFFER
	AIS	R5,1			:NEXT BYTE
	JLEBS	BUFCA1			:CONTINUE
	L	R5,BURSAV		:Restore reg 5 (CHN)
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	MERGE:/PREFIX:/MOVE:
::	ENTRY POINTS:
::		MERGE:	USED DURING REBUILD PROCESS.
::		ANY USER BYTES THAT MAY HAVE ACCUMMULATED IN THE OUTBOUND
::		BUFFER (NOW CONNECTED TO A 'STUB') ARE COPIED OVER BYTE
::		BY BYTE INTO THE CORRESPONDING HISTORY BUFFER, BEHIND THE
::		HISTORY DATA ITSELF. THEN THE H-BUFFER DESCRIPTOR (BB,
::		BE, BF, BCT, SEQN) IS COPIED INTO THE S-BUFFER DESCRIPTOR,
::		AND IS ITSELF CLEARED.	THE RESULT IS AN EMPTY HISTORY
::		BUFFER AND AN OUTPUT BUFFER CONTAINING HISTORY DATA FOLOWED
::		BY SUBSEQUENT USER DATA.
::		IN THE EVENT THAT THE OUTPUT BUFFER CONTAINS A GOBBLER,
::		THE HISTORY BUFFER IS SIMPLY CLEARED.
::		R6 = OUTBOUND BUFF #
::		R7 = HISTORY BUFF (COMPUTED FROM R6)
::		PREFIX:
::		CONTENTS OF BUFFER IN R7 TO THE CONTENTS OF BUFFER IN R6.
::		SOURCE BUFFER IS CLEARED.
::		R6 = DESTINATION
::		R7 = SOURCE (CLEARED)
::		MOVE:
::		MOVES ALL DATA IN BUFFER GIVEN IN R7 TO BUFFER GIVEN IN R6.
::		R6 = DESTINATION
::		R7 = SOURCE
::
::*********************************************************************

	IF	REBILD

MERGE	LR	R7,R6			:COMPUTE HB #
	SRHLS	R7,1
	NHI	R7,-4
	AI	R7,HBUFN
	LHL	R1,BCT,R7,
	JER	R9			:HISTORY BUFFER IS EMPTY
	LR	R2,R6			:IF GOBBLER IN OB, CLEAR HB
	L	R3,BB,R2,
	JE	MERGE2			:TEST FOR GOBBLER IN OB

	JAL	R8,PCI		:IF A GOBBLER IN OB, CLEAR HB...###OAS
	CLHI	R1,3
	JN	MERGE2
	JAL	R8,PCI
	CLHI	R1,GOBBL&0FF
	JN	MERGE2
	LR	R2,R7			:CLEAR HB (CONTENTS IRRELEVANT)
	JAL	R8,CBCLR,,
	L	R1,SEQN,R6,		:MAINTAIN INTEGRITY OF SEQUENCE
	ST	R1,SEQN,R7,
	JR	R9
MERGE2  HS      0
     IF  REBTST
	LHI     R0,SPLCSZ               :if both large BCT then use SPLICE
        CLH     R0,BCT,R6,
        JGFS    MERGE4
        CLH     R0,BCT,R7,              :APPEND is ok if one of buff is smalle
        JGFS    MERGE4
        ST      R9,SPLSV1
        JAL     R9,SPLICE
        L       R9,SPLSV1
        JFS     MERGE3                  :SPLICEd to save our CPU from working
      EI  :REBTST
MERGE4	ST	R9,SPLSV1		:SAVE LINK
	JAL	R9,APPEND		:EMPTY DATA IN OB AND WRITE IT INTO HB
	L	R9,SPLSV1
MERGE3	LR	R2,R6			:NOW CLEAR OB
	JAL	R8,CBCLR,,
	LIS	R0,0
	L	R1,BB,R7,		:MOVE EVERYTHING FROM HB TO OB
	ST	R1,BB,R6,
	ST	R0,BB,R7,
	L	R1,BE,R7,
	ST	R1,BE,R6,
	ST	R0,BE,R7,
	LHL	R1,BF,R7,
	STH	R1,BF,R6,
	STH	R0,BF,R7,
	LHL	R1,BCT,R7,
	STH	R1,BCT,R6,
	STH	R0,BCT,R7,
                                 :correct bug of history in use number
        ahi     R1,CBSZ-1-cbptsz :BCT to a mult of 14d (HW pointer, 1st char)
        CI      R6,HBUFN        :dest history buffer?
        JLFS    MERG8           :nope
        AM      R1,HBFTSV       :bump up its in use
        JGEFS   MERG8           :in use still ok
        JAL     R7,NEGHCR,,     :went negative
MERG8   CI      R7,HBUFN        :one losing the chars a hist buff?
        JLFS    MERG9           :nope
        SR      R0,R1           :get a count to reduce the number
        AM      R0,HBFTSV       :little bit smaller
        JGEFS   MERG9
        JAL     R7,NEGHCR,,     :history went negative
MERG9   LIS     R0,0            :restore reg.
	L	R1,SEQN,R7,
	ST	R1,SEQN,R6,
	JR	R9


PREFIX	EQ	MERGE4
MOVE	EQ	MERGE3

	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	TRUNC:
::	FUNCTION:	REMOVES CHARS FROM BUFFER UNTIL 'BE'=CONTENTS OF R3.
::	CALLING SEQ:	JAL	R9,TRUNC
::	INPUT:		R2 = BUFF #
::			R3 = FULL WORD PTR TO CHARACTER
::
::*********************************************************************

TRUNC	HS	0
	LR	R6,R3
TRUNC1	LHL	R0,BCT,R2,		:BUFF EMPTY
	JER	R9
	JAL	R8,GCI		:REMOVE A CHAR
	CL	R6,BB,R2,
	JNBS	TRUNC1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	APPEND:
::	FUNCTION:	DOES A BYTE-BY-BYTE COPY OF SOURCE (R6) BUFFER
::		INTO DESTINATION (R7) BUFFER, LEAVING THE SOURCE BUFFER EMPTY
::	CALLING SEQ:	JAL	R9,APPEND
::	INPUT:		R6 = SOURCE
::			R7 = DESTINATION
::
::*********************************************************************

APPEND	HS	0
	LHL	R0,BCT,R6,		:SOURCE EMPTY?
	JER	R9			:YES, EXIT
        LHL     R1,BCT,R7,              :any in destination?
        JE      APPEN6                  :no, just move buffers as a group
        SRLS    R1,2                    :divide dest BCT by 4
        CR      R0,R1                   :if dest much smaller than source?
        JLFS    APPEN3                  :if yes then empty from the smaller

APPEN2	LR	R2,R6                   :here's the old and normal append logic
	JAL	R8,GCI
	LR	R2,R7
	JAL	R8,WCI
        LHL     R0,BCT,R6,              :source empty?
        JGBS    APPEN2                  :nope do it again
        JR      R9                      :done and exit

APPEN3  LR      R2,R7                   :dest
        JAL     R8,GCD                  :get from other end of buff
        LR      R2,R6                   :source
        JAL     R8,WCD                  :write to other end of buff
        LHL     R0,BCT,R7,              :buff empty?
        JGBS    APPEN3                  :nope, loop
                                        :nice little fallthrough
APPEN6  L       R0,BB,R6,               :move buflets from source to dest
        ST      R0,BB,R7,               :and we know dest was empty
        L       R0,BE,R6,
        ST      R0,BE,R7,               :BB, BE, and will do BCT
        LH      R0,BF,R6,               :and mark buffer as empty
        RBT     R0,NFLAGS
        LH      R0,BF,R7,
        SBT     R0,NFLAGS               :and other now has data
                                        :and get BCT to fix history in use
        LHL     R0,BCT,R6,
        STH     R0,BCT,R7,              :all dest pointers ok
        ahi     R0,CBSZ-1-cbptsz        :2 for pointer and 1 for first char

SPLIC9  HS      0                       :standard HBUF in use and clear source
                                        :section of code
     IF REBILD
        CI      R7,HBUFN                :dest a hist buff?
        JLFS    APPEN7                  :nope, normal buff
        AM      R0,HBFTSV               :yes, more history bytes in use
APPEN7  CLHI    R6,HBFTSV               :source a hist buff?
        JLFS    APPEN8                  :nope
        LIS     R1,0                    :we need to subtract
        SR      R1,R0                   :get a negative BCT
        AM      R1,HBFTSV               :reduce count in use
        JGEFS   APPEN8                  :make sure didn't go negative
        JAL     R7,NEGHCR,,             :crash if went neg
     EI  :REBILD
APPEN8  LIS     R0,0                    :clear out source
        STH     R0,BCT,R6,
        ST      R0,BB,R6,
        ST      R0,BE,R6,
        JR      R9                      :DONE

::*********************************************************************
::
::	SUBROUTINE:  SPLICE:
::	FUNCTION:  A special rebuild routine that is used when there are a ton
::         a chars that need to be appended to another buffer.  Instead of
::         GCI and WCI every char SPLICE escapes data chars until the buffers
::         line up on even bufflet boundaries and then chains the bufflets.
::         NOTE: escaping of data does add a bit of a load to other nodes but
::               that is better than spending >.1 sec of CPU time on this node.
::
::*********************************************************************

        IF      REBTST
SPLICE  LR      R2,R6           :buff pointer in R6 gets added to buff of R7
        L       R4,BE,R7,       :fill up to last bufflet for dest
SPLIC1  LHL     R0,BCT,R2,      :should'nt happen (was supposed to be big buff)
        JEFS    SPLIC8          :could have big buff full of char pairs though
        AIS     R4,1            :fill upto end
        THI     R4,CBSZ-1       :at end of bflet
        JEFS    SPLIC0          :evened up dest buflet
        JAL     R8,GCI          :get char from source
        STB     R1,0,R4         :and put the char
        JBS     SPLIC1          :loop until filled up BFLET

SPLIC8  ST      R4,BE,R7,
        JR      R9              :no more to move so then done

SPLIC0  CLHI    R1,3            :don't want to split char pairs
        JGFS    SPLIC2          :no worries
        SIS     R4,1            :damn pair, make R4 to last char
        ST      R4,BE,R7,       :BE is set up for WCi
        LR      R2,R7           :trick idea is to simply write char and start
        JAL     R8,WCI          :SPLICEing all over again on next BUFlet
        J       SPLICE          :easiest way to handle rare case
SPLIC2  ST      R4,BE,R7,       :note BE points to pointer and not a char
        L       R4,BB,R6,       :now start escaping the data
        LR      R3,R4           :make copy
        NHI     R4,-CBSZ        :make R4 to start of BFlet
        AIS     R4,2            :where to start putting the data
        ST      R4,BB,R6,       :save what is going to be new BB
SPLIC3  CR      R4,R3           :done if equal
        JE      SPLIC5
        C       R3,BE,R6,       :make sure not at end
        JE      SPLIC5
        JAL     R8,PCI          :get a char to esc and +1 to R3
        CLHI    R1,7            :don't escape signals
        JLEFS   SPLIC4          :otherwise signals become data
        EXBR    R1,R1           :get a zero (escape the data)
        JAL     R8,PWCI         :write char and +1 to R4
        EXBR    R1,R1           :get back the char
        JAL     R8,PWCI         :+1 to R4
        J       SPLIC3          :note this loop added 2 to R4 and 1 to R3
SPLIC4  JAL     R8,PWCI         :put the char at new position
        CLHI    R1,4
        JGE     SPLIC3          :not a char pair signal
        JAL     R8,PCI
        JAL     R8,PWCI         :do second char of pair
        J       SPLIC3

SPLIC5  L       R3,BB,R6,               :chain the buflets now
        sis     R3,2                    :make start of source to BF pointer
        SRLS    R3,4                    :now pointer
        L       R4,BE,R7,               :get address to put pointer
        STH     R3,0,R4                 :have chain

        L       R4,BE,R6,
        ST      R4,BE,R7,               :and end of source is now end of data
        LHL     R0,BCT,R6,              :and fix up char count
        ahi     R0,CBSZ-1-cbptsz       :2 bytes for pointer 1 byte for 1st char
        AHM     R0,BCT,R7,              :add in chars of chained
        J       SPLIC9                  :and do buff in use logic

::******************************************************
:  PWCI is sort of like PCI except it writes char in R1 at R4, moves
:       R4 to next spot but does not touch BB, BE or BCT.  It assumes
:       that caller knows where writing to (by R4) and caller will not
:       try writing after BE (not checked because don't ask for R2).
::********************************************************

PWCI    STB     R1,0,R4                 :store it
        AIS     R4,1
        THI     R4,CBSZ-1               :at pointer now?
        JNR     R8                      :nope so den done
        LHL     R4,0,R4                 :get next buffer number
        SLLS    R4,cbszl                :relative address
        Ais     R4,2                    :real address
        JR      R8                      :R4 setup for next char
        ei  :REBTST


::*****************************************************
: GCD   gets char from other end of buffer.  the end which WCI writes to.
:       links on R8
:       input:  R2 is buffer number
:       trashes: R0 and R3 (normal buffer trashed regs).

GCD     L       R3,BE,R2,               :end of buffer
        JNFS    GCD1                    :not empty
        JAL     R0,OOPS,,
        JR      R8
GCD1    LB      R1,0,R3                 :get the char
        CL      R3,BB,R2,               :last char?
        JE      GCLAST                  :BE=BB so empty and use existing
        SIS     R3,1                    :back up BE
        ST      R3,BE,R2,               :save it
        THI     R3,CBSZ-cbptsz          :if BFlet empty then nibble =1 so
        JNR     R8                      :bflet still has data

:cute little fall through.  must return bufferlet but all we have is
:last entry of linked buffer list.  so must go to start and look for
:the link that points to our current position.

GCDRET  ahi     R3,cbsz-1               :move it up to the pointer
        LHL     R0,FREELT               :insert our buffer to start of free
        STH     R0,0,R3                 :link all free to our buflet
        sis     R3,2                    :make r3 a buf number
        SRLS    R3,CBSZL                :now it is buf number
        STH     R3,FREELT               :put it on free list
        LR      R0,R3                   :use R0 so R3 can be used for index
        L       R3,BB,R2,               :get start of list
        ahi     R3,CBSZ-cbptsz          :get pointer location
        NHI     R3,-CBSZ                :got it (it sits on quad word bound)
        STH     R1,GCDSV                :save character
        LHL     R1,BCT,R2,              :limit number of buffers to search
GCD2    CLH     R0,0,R3                 :R0 is buffer just emptied
        JE      GCD3                    :found link
        LHL     R3,0,R3                 :get next pointer
        SLLS    R3,CBSZL                :make into address
        ahi     R3,CBSZ                 :now is address of the next pointer
        shi     R1,CBSZ-cbptsz          :limit on search
        JGEBS   GCD2                    :loop until find link
        CRASH.(.GCD0)                   :buffer chains are messed up

GCD3    LH      R1,GCDSV                :restore char
        SIS     R3,1                    :adjust to end of bflet
        ST      R3,BE,R2,               :save new end
        lhi     R0,cbptsz-cbsz
        AHM     R0,BCT,R2,              :knock down BCT
        AM      R0,BFLTSV               :knock bytes in use
     IF REBILD
        JGEFS   GCD4                    :count still ok
     ELSE
        JGER    R8                      :not rebuild have nothing else to do
     EI         :REBILD
        JAL     R7,NEGBCR,,             :crash if not negative
      IF REBILD
GCD4    CI      R2,HBUFN                :history buffer?
        JLR     R8                      :done
        AM      R0,HBFTSV
        JGER    R8                      :done
        JAL     R7,NEGHCR,,             :crash r7 being location
      EI        :REBILD



::*********************************************************************
::
::	SUBROUTINE:	PURGE:
::	FUNCTION:	REMOVES CHARACTERS FROM SOURCE BUFFER UNTIL CHAR
::		BEARING A GIVEN SEQ # IS AT FRONT OF BUFFER.
::	CALLING SEQ:	JAL	R9,PURGE
::	INPUT:		R2 = BUFF #
::			R4 = SEQN OF FIRST CHAR IN BUFFER
::			R5 = SEQN OF FIRST CHAR AFTER PURGE
::	RETURNS:	TAKES IMMED RETURN IF DATA HAS BEEN LOST.
::			ELSE +4 RETURN
::
::*********************************************************************

	IF	REBILD

PURGE	HS	0
	SR	R4,R5			:FORM -(NUMBER OF EXCESS CHARACTERS)
	JE	4,R9			:NO EXCESS CHARACTERS, DO SKIP RETURN
	JG	PUREXI			:DESIRED DATA NOT IN H-BUFFER	###wjl
					: - DATA LOST!
PURG1	LHL	R0,BCT,R2,		:DATA IN BUFFER?
	JEFS	PUREXI			:NO, LOST DATA, DO NON-SKIP RETURN#wjl
        LIS     R0,0                    :r0 is going to be how many to purge
        SR      R0,R4                   :how many to purge
        LR      R4,R0                   :save a copy for ourselves
        JAL     R8,RTBFTS               :return chars
        CR      R0,R4                   :r0 is how many actually purged
        JNFS	PUREXI                  :not able to return requested #	###wjl
        ST      R5,SEQN,R2,             :bump number purged
        J       4,R9                    :routine by ###sdw

PUREXI	SKIP(0,R9)			:immediate return		###wjl

	EI	:REBILD


        SUBTTL  BUFF (LOG II character scan)


::*****************************************************************
::
::      IGPCIE  special peek of buffers.  Gets a char and saves how
::              many chars read so X.409 parse routine knows where it
::              is it in the X.409 element.
::              IGPCIE will count each char read at ELEDIS.
::
::              Links on R9, trashes  r8.  New BFposition in R3.
::              Char in R1.
::
::*****************************************************************

       IF       LOGII

IGPCIE  LIS     R1,1                    :eount how many read
        AHM     R1,ELEDIS               :to figure out where messages end
IGPCIO  JAL     R8,PCI                  :other entry does not update count
        LR      R1,R1                   :escaped char?
        JNR     R9                      :nope so done
        JAL     R8,PCI                  :get the escaped char
        JR      R9                      :and done
       EI       :LOGII
	ENDMO.(BUFF)
	EI	:1-KILLIT
	KILMSG(BUFF)

:	***NOTHING PAST THIS POINT***

	SUBTTL	LOGSUP

:			*      ***   ***   ***  *   * ****
:			*     *   * *     *     *   * *   *
:			*     *   * *  **  ***  *   * ****
:			*     *   * *   *     * *   * *
:			*****  ***   ***  ****   ***  *

::#####################################################################
::
::	MODULE:		LOGSUP
::
::	SUBTTLS:	LOGGER - Process data to sup in login mode
::			SUP message generators
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA  0
	SEG  1

::*********************************************************************
::
::	SUBPROCESS:	LOGGER:
::	FUNCTION:	Process ports in login mode.
::	SCHEDULED:	Runs off SWITCH exec loop, based on presence of
::			data in LOGBUF.
::		LOGGER processes data from ports in login mode (ISIS)
::		toward the supervisor.  It does not use the 
::		usual attention-flag scheme to detect which login buffers
::		have data ready to go.  This is because login data is not
::		necessarily "ready to go" simply because it is available
::		in a buffer.  Instead, the process which fills the login
::		buffer monitors the input for 1) a login-string terminator
::		(semi-:or CR), 2) an escape, or 3) overflow (a login-string
::		may not be longer than 55d bytes).  When one of these is
::		detected, the filling process marks the buffer ready for
::		LOGGER service by writing the login-buffer's index into
::		LOGBUF (as an escaped HW).  LOGGER's attention gets flagged
::		by the presence of something in LOGBUF.  For related reasons,
::		a login-buffer's BF is never a channel number in the regular
::		sense.  Instead, it is a value between 10 (LOGMIN) and 17
::		(LOGMAX).  This value defines the current state of the login-
::		buffer, as follows:
::			10-bit :port is in login mode.
::			01-bit :(LG.TID) TID is in the login buffer (i.e.,
::				 hasn't been sent to the supe yet.
::			02-bit :(LOGNDC) node code is ready to transmit 
::				 login data.
::			04-bit :(LOGSUP) supe is ready to accept login data.
::
::*********************************************************************

IIXLOG	EQ	1	:bit of IOTAB entry set for IIX circuit request	###jhl
LGCHMX	EQ	$A 48	:Maximum characters allowed for login
:	Start out by appending a marker (0 HW) to the contents of LOGBUF.
:	We will cycle thru LOGBUF looking for login-buffer numbers.
:	We will service each buffer once, and when we get to the marker 
:	we'll know that we're through.
       if       1-NCSLOT                :NO LOGGER IF NO DISPATCHER
LOGGER	HS	0
	LIS	R2,0			:PUT A MARKER IN THE LOGGER LIST

:	Write marker to LOGBUF (first pass) or return buffer just serviced
:	to LOGBUF (if it still needs LOGGER service).  Jumping to here from
:	below has the effect of returning the current buffer to the LOGGER
:	list before going on to the next login-buffer.
LOG1	HS	0
	LR	R1,R2			:RETURN CURRENT PORT TO LOGGER LIST
	LIS	2,LOGBUF
	JAL	R9,WHWI0
	GL	WHWI0

:	Get the next buffer index from LOGBUF. If its our 0-marker,
:	RETURN via LOGXIT. Otherwise, check its BF to make sure its a valid
:	login-buffer (LOGMIN<=BF<=logmax).  If it is, skip to LOG7.
:	Jumping here from below has the effect of removing the current buffer
:	from the LOGGER list.
LOG0	HS	0
	LIS	R2,LOGBUF		:PROCESS NEXT PORT
	JAL	R9,GHWI0
	GL	GHWI0
	LR	R2,R1			:THIS IS THE BUFFER W/ CHARS FOR SUP
	JE	LOGXIT,,		:MARKER, WE'RE DONE

	LHL	R1,BF,R2,		:INSURE WE'RE REALLY IN LOGIN
	CLHI	R1,LOGMIN		:TEST FOR VALID LOG IN MODE
	JLFS	LOG8
	CLHI	R1,LOGMAX
	JLE	LOG7			:YES WE ARE IN LOGIN MODE
:	INVALID LOGGER BF. REPORT TO XRAY AND REMOVE OFFENDING BUFFER
:	NUMBER FROM THE LOGGER LIST.
:	Found an invalid BF (not in login mode) for a buffer in LOGBUF.
:	Report to crypto (CRYE23) and go on to the next entry (LOG0) without
:	putting this buffer back into LOGBUF.
LOG8	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,0			:CASE # 0
	JAL	R14,LGGDB2,,
	GL	LGGDB2
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	EXHR	R0,R2			:###TZ
	OR	R0,R1			:###TZ
	JAL	R8,CRYPTO,,		:REPORT WITH BAD BUFFER INDEX, BF IN R0
	HC	CRYE23
	J	LOG0			:JUMPING TO LOG0 HAS THE EFFECT OF
					:REMOVING BUFFER # FROM LOGGER LIST.
:	Found a login-buffer with a valid BF.  Check to see if we have a sup
:	circuit and if we have not had a recent takeover.  If both are ture,
:	continue.  Else, go zap the login circuit (LOGZAP).  We can't
:	process logins if there is no sup, and we can't continue to process
:	logins if there a possibility that a new supe is taking us over.
LOG7	HS	0
	LHL	R0,TVRBUF		:IS THERE A SUP?
	JE	LOGZAP,,		:NO, ZAP CIRCUIT
	LHL	R0,LOGZPF		:HAS THERE BEEN A TAKEOVER?
	JN	LOGZAP,,		:YES, ZAP CIRCUIT

:	If the INFinite-LoGin-Timer flag is not set, we have to see if the
:	login-circuit has timed out.  If the TID has already been sent to the
:	sup, we let the sup handle the timeout (skip to LOG9).  Otherwise,
:	we check for timeout by seeing if we've passed the SLOWC time that was
:	saved in BUFTIM when the login was initiated (timeout is 120d seconds).
	IF	1-INFLGT
	LHL	R1,BF,R2,		:GET BUFFER FLAG
	THI	R1,LG.TID		:TID IN BUFFER ?
	JE	LOG9			:NO, SUP WILL TIME THIS ONE OUT

	SRLS	R2,1			:COMPUTE BUFTIM INDEX
	NHI	R2,-4
	L	R0,BUFTIM,R2,		:HAS THIS CIRCUIT TIMED OUT?
	SLLS	R2,1			:RESTORE BUFFER #
	S	R0,SLOWC,,		:(BUFTIM HAD START TIME + 120d)
	JG	LOG9			:NOT YET

:	HAVE DISPI (IN) SEND:
:		SUPER HANG (ISIS B8) (FOR HDX TERMINALS)
:		TEXT "PLEASE SEE YOUR REPRE..."
:		HANG (ISIS AF)  (NORMAL HANG)
:	Login-circuit timed out.  Send "please see your Rep"
:	(with HANG and HDX-HANG) to port.  Then go service the next
:	login-buffer (LOG0) without putting this one back in the LOGGER list
:	(LOGBUF).

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,2			:CASE # 2
	JAL	R14,LGGDB2,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	XHI	R2,4			:OTHER BUFFER

	IF	T2GATE
	LHL	R5,BF,R2,
	SHI	R5,DISZFL		:Get dispatcher port
	LA	R1,PSRMSG,,
	JAL	R8,DIMMES		:Output "pls see your rep.."
	TBT	R5,GTTRNS
	JN	GLOG7
	LA	R1,GNGONE,,
	JAL	R8,DIMMES
	DROUTE(ISISN,HOMEN)		:If non-transparent send
	LA	R1,CRLF			:"inter-link cleared .."
	JAL	R8,DIMMES
GLOG7	LHI	R1,09E00		:In either case zap circuit
	JAL	R8,DIRMES
	LIS	R1,0			:and let dispatcher Zapper ack
	XHI	R2,4			:return logon circuitry
	STH	R1,BF,R2,		:Set bf to Zero for RFCBUF
	SBT	CHN,DISZNK		:And set up for Zapv to clean up

	ELSE	:NOT T2GATE
         IF     LOGII                   :rejecting a LOG II request?
        LHL     CHN,BF,R2,              :get chn #
        SHI     CHN,DISZFL
        TBT     CHN,DISLG2              :a log 2 request?
        JEFS    LOG007                  :nope do normal
        LHI     R1,L2NRJT               :NC generated log 2 reject
        JAL     R9,W2CI
        LIS     R1,4                    :reason being timout
        JAL     R8,WCI
        J       LGZPCN                  :leading to a zap
         EI     :LOGII
:	timeout a regular port (timout a logon attempt)
LOG007	LA	R4,PSRMSG,,		:ADDRESS OF Please See your...(W/HANGS)
	GL	PSRMSG
	JAL	R9,BUFCAN		:OUTPUT MESSAGE TO BUFFER
	GL	BUFCAN
	EI	:T2GATE

	J	LOG0			:REMOVE THIS BUFFER FROM LIST
	EI	:1-INFLGT

:	Here for login-buffer that has not timed out.
:	If the supe and node code bits are both set in the buffer's BF,
:	we continue.  Otherwise, we go on to the next buffer (LOG1) and
:	return this buffer to the LOGGER list.
LOG9	HS	0
       IF       T2GATE
        J       GLOG9,,                 :go to separate gateway lgosup
CRLF    SC      /"8D"8A/
        GL      GLOG9,LOGZAP,LOGXIT     :for gateway in gatway module
      ELSE      :otherwise use normal logsup which is not gateway
	LHL	R1,BF,R2,		:ARE WE IN XMIT MODE (SUP & NC)
	NHI	R1,@LG.TID		:(TID DOESN'T COUNT)
	CLHI	R1,LOGXMT
	JN	LOG1			:NO, BACK TO THE LIST

:	Here for buffer with BF set ready to transmit.
:	If there is data in the buffer, continue.  Otherwise,
:	go on to next buffer (LOG1).
	LHL	R1,BCT,R2,
	JLE	LOG1			:RETURN TO LOGGER LIST

LOG10	HS	0			:Found a login-buffer with data in it.
       IF       LOGII                   :log 2 logon data gets special handlng
        XHI     R2,4
        LHL     CHN,BF,R2,              :so find if it is a log 2 dport
        XHI     R2,4                    :back to logon chars
        SHI     CHN,DISZFL
        TBT     CHN,DISLG2              :a log 2 request
        JE      LOG101                  :not a log 2 request

:       this is a log 2 request.  Thus in the buffer should be a complete
:       NCRM.  All we have to do is add the node #, type and length and
:       copy the NCRM into the supe's buffer.

        LR      R6,R2                   :handle log 2
        LHL     R2,TVRBUF               :get supe buf
        LR      R7,R2                   :make a copy to prepare for copy
        LHI     R1,MACHNM
        JAL     R9,WHWI                 :our node #
        LHI     R1,0880                 :NCRM is type 8 msg | unused byte of 80
        JAL     R9,W2CI
        IF      LPGDBG
        L       R9,BE,R2,
        ST      R9,LPGSSV               :before start of new data
        EI      :LPGDBG
        LR      R2,R6                   :check for a zapper now
        JAL     R8,PCIS
        SIS     R1,3                    :zapper gets converted to NCRM zap msg
        JN      L2G400                  :not a zapper, no worries
        JAL     R8,CBCLR                :is a zap, clear buffer
        LR      R2,R7                   :send logon zap to supe
        CLHI    CHN,100                 :does chn require 1 or 2 bytes
        JLFS    L2G020
        LA      R4,NCRLZM               :requires the long zap msg
        JFS     L2G021
L2G020  LA      R4,NCRSZM               :takes the shorter (1 byte for chn) msg
L2G021  LB      R1,3,R4                 :get Len of X.409 msg
        AIS     R1,3                    :add in length of header of len
        JAL     R9,WHWI                 :write len of zapper NCRM
        JAL     R9,BUFCAN               :put it
        LR      R1,CHN                  :prepare chn # for writing
        CLHI    CHN,100                 :now ready to write chn #
        JLFS    L2G050
        JAL     R9,WHWI                 :write chn #
        JFS     L2G054
L2G050  JAL     R9,WCIE                 :write 1 byte chn number
L2G054  LA      R4,NCRMZE               :the second half of the zap msg
        JAL     R9,BUFCAN               :SMOSET with zap indication
        LR      R2,R7

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,6			:CASE # 6
	JAL	R14,LGGDB2,,
	LR	R2,R7			:R2 = TVRBUF
	JAL	R14,LGGDB3,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	LR	R2,R6
	LHI	R1,LOGMIN		:set not send since sent zapper
	STH	R1,BF,R2,
        LHI     R1,ZAPPH
        JAL     R9,W2CI                 :leave a zapper in the buffer
	J	LOG1			:PUT HIM BACK ON QUEUE

:       strings of NCRM msgs, NCRxZM is before chn #, NCRMZE after chn #
NCRMZE  SC      /"5F"3D"00"02"06"40"31"00"03"4B"00"01"FF/
NCRLZM  SC      /"7F"3C"10"30"09"5A"00"02/ :NCRM id, len, RMOseq,len, CHN ID
NCRSZM  SC      /"7F"3C"0F"30"08"5A"00"01/ :same as above except for chn<100

L2G400  L       R3,BB,R6,
        ST      R3,ELEPOS               :start of first position
        JAL     R9,X4NXID,,             :get len of element into R0
        CLHI    R0,80
        JLFS    L2G402                  :what is len of len
        CLHI    R0,100                  :was three bytes
        JLFS    L2G401
        AIS     R0,1                    :for len 3
L2G401  AIS     R0,1                    :for len 2
L2G402  AIS     R0,3                    :two for id, 1 for len
        LR      R1,R0
        LR      R2,R7
        JAL     R9,WHWI                 :write it as halfwords
        JAL     R9,APPEND               :now just append the NCRM data


        LHI     R1,LG.SNT               :waiting for supe response
        LR      R2,R6                   :get back dport buffer
        STH     R1,BF,R2,

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,5			:CASE # 5
	JAL	R14,LGGDB2,,
        LHL     R2,TVRBUF
	JAL	R14,LGGDB3,,
	GL	LGGDB3
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG
	
        J       LOG1                    :keep on logger list
       EI       :LOGII

LOG101	LR	R6,R2			:MOVE CHARS TO THE LEP BUFFER
	LHL	R10,BF,R2,		:GET LOGIN STATUS (16 OR 17 HEX)

:	Get the login status from BF and convert to proper sup message type
:	(0E=login string continuation, 0F=TID+login string).  
:	Create a login string message in the sup buffer (TVRBUF)
:	get logon status from BF and convert to NEW or not depending on TID
:	in buffer or not.  Send a type 0C message in either case.
LOG11	HS	0
	IF	EXPNDL
	LHL	R2,TVRBUF		:init R2 to hold to-SUP buffer number
	LR	R7,R2			:R7 holds sup buffer while we work
	LHI	R1,MACHNM+8000		:MAKE SUP RECORD
	JAL	R9,WHWI			:node number to identify us
	LIS	R1,0C			:send a type 0C message
	JAL	R8,WCI

	IF	LPGDBG 			:DEBUGFGER		###LSH 
	L	R1,BE,R7,
	ST	R1,LPGSSV		:save ptr to use in cpying data
	EI	:LPGDBG

	THI	R10,LG.TID		:Is TID still in the buffer?
	JNFS	LGEN10			:branch if it is 
	LIS	R1,8			:sup ignores if not NEW
	JFS	LGEN15			:--won't escape this

:	the TID is sent from DSZTLG in the login buffer
LGEN10	LR	R2,R6			:get the login buffer into R2
	JAL	R9,GHWI			:first read out the requesting host #
	LR	R11,R1			:and save it in R11
	JAL	R8,GCI			:read in the TID
	OHI	R1,80			:set the NEW bit (hob set already?)
	LR	R2,R7			:get sup buffer into R2
LGEN15	JAL	R8,WCI			:write second byte of 0C msg into buff
	LR	R1,R6			:get the login buffer
	XHI	R1,4			:flip to slot-bound buffer
	LHL	R1,BF,R1,		:BF of +4 is port number to tell sup
	OHI	R1,8000			:set high order bit for sup
	JAL	R9,WHWI			:write in the port number
	LIS	R1,0			:prepare field for msg length
	JAL	R8,WCI			:lay an escaped byte of zero
	JAL	R8,WCI			:escape, then the place for count
	L	R1,BE,R2,		:save pointer to second byte
	ST	R1,SNCSV1		:fill it in when we know the length
:	Now for the SNI list--R10 has BF of login buffer
	LIS	LRC,0			:init SNI-length count
	THI	R10,LG.TID		:if NEW then send orig host SNI
	JEFS	LGEN18			:otherwise don't
	LHI	R1,SNIHST+SNTYP1	:send SNI: org hst/hw of host
	JAL	R8,WCI
	LR	R1,R11			:get requesting host from R11
	JAL	R9,WHWI			:fill in host field for org hst SNI
:	00-03 are escaped
	AIS	LRC,3			:update SNI-length count
:	test for UUN request and send SNI if appropriate
LGEN18	LR	R1,R6			:get the login buffer again
	XHI	R1,4			:turn in slot bound direction
	LHL	R1,BF,R1,		:BF of +4 is channel number
	SHI	R1,DISZFL		:get rel offset into dispatcher array
	RBT	R1,DISUUN		:test for send UUN request
	JEFS	LGEN20			:branch around if not set by DSZTLG
	LIS	R1,SNIUUN+SNTYP0
	JAL	R8,WCI			:write SNI asking for UUN
	AIS	LRC,1			:update the SNI-length count
:	test for IIX circuit and send SNI if appropriate
LGEN20	LR	R9,R6			:get login buffer
	XHI	R9,4			:flip to outbound buffer
	LHL	R9,BF,R9,		:BF of outbound is originating channel 
	LHL	R0,IOTAB,R9,R9		:permuter table entry for circuit orig
	THI	R0,IIXLOG		:SIQ circuit?
	JEFS	LGEN23			:no
	THI	R10,LG.TID		:check BF for TID still in buffer
	JEFS	LGEN23			:send only for NEW request
	LHI	R1,SNIIIX+SNTYP0	:write in the IIX SNI
	JAL	R8,WCI
	AIS	LRC,1			:update SNI-length
LGEN23	HS	0
:	Next put in the SNI for logon characters
	LHI	R1,SNILGC+SNTYP3
	JAL	R8,WCI			:write in the SNI header
	LIS	R1,0			:write in the count field
	JAL	R8,WCI			:escape it just to be safe
	JAL	R8,WCI			:hold the place with  zero
	L	R10,BE,R2,		:get pointer to count-cell for later
	AIS	LRC,2			:add in LOG CHR header
	STH	LRC,SNCTSV		:save for retrieval later
	LIS	LRC,0			:initialize counter of login string

:	now proceed from LOG3 to append login string
	ELSE	:not EXPNDL
	SHI	R10,08			:CONVERT TO MESSAGE TYPE (0E OR 0F HEX)
	LHL	R2,TVRBUF		:init R2 to hold to-SUP buffer number
	LR	R7,R2			:R7 holds sup buffer while we work
	LHI	R1,MACHNM+8000		:MAKE SUP RECORD
	JAL	R9,WHWI
	LR	R1,R10			:MESSAGE TYPE '0E' OR '0F'
	JAL	R8,WCI

	IF	LPGDBG 			:DEBUGFGER		###LSH 
	L	R1,BE,R7,
	ST	R1,LPGSSV		:save ptr to use in cpying data
	EI	:LPGDBG

	LIS	R1,0
	JAL	R8,WCI			:ASSUME CHAR COUNT NEEDS ESCAPING
	JAL	R8,WCI			:ESCAPED CHAR CNT WILL GO HERE IN BUFF
	L	R10,BE,R2,		:SAVE POINTER TO IT
	LR	R1,R6
	XHI	R1,4			:GET THE PORT #
	LHL	R1,BF,R1,
	OHI	R1,8000			:SET FOR SUP
	JAL	R9,WHWI
	GL	WHWI
	LHI	LRC,80			:NUMB OF CHARACTERS TO BE SENT.
:	80-bit means not SIQ circuit. May be reset below.
		
:	If the TID is still in the buffer, include the host number.
:	Else skip to LOG3.
	LIS	R2,0F			:LAST (TID) BIT IN HW
	TBT	R2,BF,R6,		:TID WAITING TO BE SENT ?
	JE	LOG3			:NO, SKIP HOST NUMBER
:	If we're sending the intial login string (msg type 0F),
:	we have to check for a smart (SIQ) circuit and inform the sup if so.
:	We know a circuit is SIQ if the LO bit of the orginating channel's
:	permuter table entry is set (i.e., the LO gouging bit).  We tell
:	the supe a circuit is SIQ by resetting the HO bit of the count field
:	(1 byte) in the type-0F message.
	XHI	R6,4
	LHL	R9,BF,R6,		:GET ORIGINATING CHANNEL
	XHI	R6,4
	LHL	R0,IOTAB,R9,R9		:PERMUTER TABLE ENTRY FOR CIRCUIT ORIG
	THI	R0,IIXLOG		:SIQ CIRCUIT?
	JEFS	LOG9SQ			:NO
	LIS	LRC,0			:ABSENCE OF 80 BIT INDICATES SIQ TO SUP
LOG9SQ	HS	0			:Type 0F msg. Include host number+8000.
	LR	R2,R6			:GET PORT BUFFER
	JAL	R9,GHWI			:GET 8000+HOST NUMBER
	LR	R2,R7			:GET SUP BUFFER
	JAL	R9,WHWI			:WRITE HOST NUMBER
	EI	:not EXPNDL

:	Supe message header complete.  Now append login string from login
:	buffer to it (escaping as necessary) until login buffer is depleted or
:	a terminator or escape char is detected.  (See LOGDLM for escape
:	characters-- there are several.)  Bump the count in LRC as we go.
:	Skip to LOG05 if the buffer empties.
LOG3	HS	0
LOG33	LR	R2,R6			:port buffer
	LHL	R0,BCT,R2,		:check for more data
	JE	LOG05			:IT'S EMPTY NOW
LOG309	JAL	R8,GCI			:read out a byte
	LR	R2,R7			:sup buffer
	CLHI	R1,8			:ESCAPE IF NEEDED (00-07)
	JGE	LOG6
	EXBR	R1,R1			:move high order byte of 0 down
	JAL	R8,WCI			:write in the escape
	EXBR	R1,R1			:move data byte back
LOG6	HS	0
	JAL	R8,WCI			:and write in data byte
	AIS	LRC,1			:INC STRING COUNT (don't count escapes)
	AIS	R4,1			:STOP WHEN CR, SEMI-:, OR ESC IS FOUND
	TBT	R1,LOGDLM-10		:DELIMITER = 'CR', "SEMI-:", 'ESC' ?
	JE	LOG33			:no, continue at top of loop
	J	LOG4

:	Detected terminator (semi-:, CR) or escape in login string.
:	Complete supe message, mark BF for TID sent and waiting for response
:	from sup (ie, node code and sup not ready).  Go on to next buffer(LOG1)

LOG4	HS	0
	STB	LRC,0,R10		:CR OR SEM--PUT AWAY COUNT
	IF	EXPNDL
	AH	LRC,SNCTSV		:add on cumulative SNI-length
	LHI	R1,SNITRM+SNTYP0	:terminate the SNI list
	JAL	R8,WCI			:write it to the sup buffer
	AIS	LRC,1			:up the SNI-length
	L	R10,SNCSV1		:points to the msg length entry
	STB	LRC,0,R10		:enter (escaped) msg length
	EI	:EXPNDL
	LR	R2,R6			:get .ALBUF (if SOLOCS) into R2 
	LHI	R1,LG.SNT		:SET NO TID, SUP NO LONGER READY,
	STH	R1,BF,R2,		:	NODE CODE NO LONGER READY

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,4			:CASE # 4
	JAL	R14,LGGDB2,,
	LR	R2,R7			:R2 = TVRBUF
	JAL	R14,LGGDB3,,
	GL	LGGDB3
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG
	
	J	LOG1

:	Login buffer emptied while we were transfering it to the sup buffer.
:	Close out the supe message, mark the login buffer's BF to show TID has
:	been sent, then go on to next buffer (LOG1).
LOG05	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,3			:CASE # 3
	JAL	R14,LGGDB2,,
	LR	R2,R7			:R2 = TVRBUF
	JAL	R14,LGGDB3,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	STB	LRC,0,R10		:EMPTY BUFF - PUT AWAY COUNT
	IF	EXPNDL
	AH	LRC,SNCTSV		:add on cumulative SNI-length
	LHI	R1,SNITRM+SNTYP0	:terminate the SNI list
	LR	R2,R7			:get to-sup buffer into R2
	JAL	R8,WCI			:write it to the sup buffer
	AIS	LRC,1			:up the SNI-length
	L	R10,SNCSV1		:points to the msg length entry
	STB	LRC,0,R10		:enter (escaped) msg length
	EI	:EXPNDL	
	LR	R2,R6
	LHI	R1,LGSN.T		:SET SUP & NC = Y, TID = N
	STH	R1,BF,R2,
	J	LOG1			:PUT HIM BACK ON QUEUE

:	(CR) (ESC,FS,GS,RS,US) (SEMI:) ({,|,},TILDA)
:	Bit array (80x bits) marks ASCII codes that are to be considered
:	"escapes" in a login string.
LOGDLM	HS	0
	HC	0004,001F,0000,0010,0000,0000,0000,001E

::	Here to zap a login circuit because LOGGER found no sup or recent
::	takeover (in either case we can't process any more login data now,
::	and because we can't be sure of the status of any login data 
::	already sent to the (a) sup, we have to ask every one to start over
::	again).  We zap a port in login mode by sending it a
::	login-error-character-pair (0313).  If ISIS, DISPI will send the
::	dispatcher a B5 message and a zapper, and will call ZAPV when it gets
::	the corresponding zapper ack.  In a CONSAT, the port will be hung and
::	a zapper sent back to the node code by ASYNC.
::	For Gateway, we must send a zapper (to invoke an ISIS detatch)
::	and let the zap ack invoke Zapv to clear circuit - because we are not
::	talking to a terminal in Log-in mode, but to an active circuit in
::	another network.
LOGZAP	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,1			:CASE # 1
	JAL	R14,LGGDB2,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	XHI	R2,4			:ZAP CIRCUIT
         IF     LOGII
        LHL     CHN,BF,R2,              :zapping a log 2 port?
        SHI     CHN,DISZFL
        TBT     CHN,DISLG2              :log 2 circuit request?
        JE      LGZA3                   :nope do normal
        LHI     R1,L2NRJT               :log 2 circuit reject
        JAL     R9,W2CI
        LIS     R1,03
        JAL     R8,WCI                  :with lost supe as reason
        J       LGZPCN                  :and finish
         EI     :LOGII
LGZA3	LIS	R1,3
	JAL	R8,WCI			:LOGRR (0313) ACTS AS ZAPPER
	LHI	R1,LOGRR&0FF		:(SENT TOWARDS CIRCUIT ORIGINATOR)
	JAL	R8,WCI
	LIS	R1,0			:ISIS unable to complete request###wjl
	JAL	R8,WCI			:ERROR CODE
LGZPCN	XHI	R2,4			:Continuation point in either case

:	Set this guy's BF back to 0 (nothing doing) and go on to the next
:	buffer (LOG0).
	LIS	R1,0			:ZERO BUFFER FLAG
	STH	R1,BF,2,
	
	J	LOG0			:DONT PUT HIM BACK

:	LOGGER exit point.  Mark the 'has-ther-been-a-recent-takeover" flag
:	to "no" before returning to SWITCH exec loop (LOGRET).
LOGXIT	HS	0
	LIS	R0,0			:FORCE THIS TO NORMAL STATE
	STH	R0,LOGZPF
	J	LOGRET,,

       EI       :T2GATE :the not gateway section

       EI       :1-NCSLOT


::*********************************************************************
::
::	SUBROUTINE:	LOGCLR:
::	FUNCTION:	Remove a login-buffer (index in R6) from the
::		LOGGER list (LOGBUF).
::		Starts by appending a marker (HW 0) into LOGBUF,
::		then searching thru LOGBUF for the specified buffer index.
::		It is removed, the marker is removed, and we RETURN to the
::		caller.
::	CALLING SEQ:	JAL	R9,LOGCLR
::	DESTROYED:	R1
::	CALLS:		JAL	R9,WHWI0
::			JAL	R9,GHWI0
::
::*********************************************************************

LOGCLR	HS	0
	ST	R9,LGCSAV		:SAVE LINKER REGISTER		###LSH
	ST	R2,LOGTBF
	LIS	R2,LOGBUF
	LIS	R1,0
LOGCL1	JAL	R9,WHWI0		:WRITE MARKER
LOGCL2	JAL	R9,GHWI0		:GET NEXT ENTRY
	LR	R1,R1			:MARKERZ?
	JEFS	LOGCL3			:YES, WE'RE DONE
	CR	R1,6
	JEBS	LOGCL2			:THIS IS IT, DONT PUT IT BACK
	JBS	LOGCL1
LOGCL3	L	R9,LGCSAV		:RESTORE LINKER REGISTER	###LSH
	L	R2,LOGTBF
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	LOGIN:
::	FUNCTION:	Initiates login process for a dispatcher or CONSAT port
::	CALLING SEQ:	JAL	R8,LOGIN
::	INPUT:		R0 = TID (0 if aux circuit)
::			R2 = login input buffer (.ALBUF in the case of
::				the SOLOCS) index
::			R5 = CHN = absolute channel number of the login port
::				(not the async port number, but the ANITAB
::				index in the case of the SOLOCS)
::	RETURNS:	Does skip+4 return if successful,
::			straight return if no sup. 
::
::*********************************************************************

       IF       1-NCSLOT

:	If there is no sup, call ZAPHRD to zap the login circuit,
:	then do straight return.  Otherwise, continue at LOGI1.
LOGIN	HS	0

	IF	LNFDBG		:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LINDB1,,
	GL	LINDB1
	LM	R0,REGST		:restore regs		###sdw
	EI	:LNFDBG

	ST	R8,LOGSAV		:SAVE RETURN
	STB	R0,LOGTID		:SAVE TID
	STH	R2,LOGTBF		:AND A REG
	LHL	R3,TVRBUF		:IS THERE A SUP?
	JGFS	LOGI1			:YES
LOGI2	JAL	R9,ZAPHRD		:NO SUP, ZAP (FROM REQUESTING PORT)
	L	R8,LOGSAV		:AND TAKE IMMEDIATE RETURN
	SKIP(0,R8)			:				###wjl

:	We have a sup.  Put the login buffer index into LOGBUF so LOGGER will
:	process the data.  If the TID is 0, got to LOGAUX to set up for
:	aux circuit login.  Otherwise, mark the login status (BF) to indicate
:	sup OK, TID in buffer, node code not OK.  Go to LOGIEX to finish up.
LOGI1	HS	0
	LR	R1,R2			:PUT HIM ON LOGGER LIST
	LIS	R2,LOGBUF
	JAL	R9,WHWI0
	LB	R0,LOGTID		:TID=0 (AUX CIR ?)
	JEFS	LOGAUX			:YES,

	LHI	R0,LGST.N		:SUP=Y, TID=Y, NODE CODE=N
	STH	R0,BF,R1,		:SET BF TO LOGIN
	J	LOGIEX			:EXIT, RESTORING REGS.

:	Here because TID is 0 -- aux circuit login.
:	Set login status bits (BF) to indicate supe not OK,
:	TID not in buffer, node code OK.
LOGAUX	HS	0
       IF       1-T2GATE                :gateway never does aux login
	LHI	R0,LGN.ST		:AUX LOGIN -SUP=WAIT, NC=OK, TID =NONE
	STH	R0,BF,R1,
:	Build the aux circuit request in the supe buffer, as follows:
:		8000+node#
:		1081 (or 1001 if ISIS SIQ circuit)
:		8000+channel#
:		8000+requesting host#
	LHL	R2,TVRBUF
	LHI	R1,MACHNM+8000		:REQUEST AUX CIRCUIT
	JAL	R9,WHWI
	LHI	R1,1081			:TYPE,ETC
:	IF SIQ CIRCUIT, INDICATE TO SUP BY ABSENCE OF 80 BIT
	LH	R0,DORSIQ		:SIQ CIRCUIT?
	JGEFS	LOGAX1			:NO
	LHI	R1,1001			:YES - INDICATE SMART SOURCE TO SUP
LOGAX1	JAL	R9,WHWI
	LR	R1,CHN			:PORT #
	OHI	R1,8000
	JAL	R9,WHWI
	LHL	R1,DORHST		:ADD HOST NUMBER TO 
	OHI	R1,8000			:AUX CIRCUIT REQUEST
	JAL	R9,WHWI

       EI       :1-T2GATE

:	Common exit point for regular and aux logins.
:	Set up buffer timeout (BUFTIM, 2 min.), and skip+4 return for all OK.
LOGIEX	HS	0
	L	R8,LOGSAV		:RESTORE LINK
	LH	R2,LOGTBF		:AND BUFFER #

	SRLS	R2,1			:SET UP BUFTIM INDEX
	L	R9,SLOWC,,		:SET UP 2-MINUTE WARNING IN CASE WE
	AHI	R9,$A120		:WANT TO TIME THIS LOGIN OUT
	ST	R9,BUFTIM,R2,
	SLLS	R2,1

	J	4,R8			:SKIP RETURN, ALL OK

       EI       :1-NCSLOT

	SUBTTL	LOGSUP (Sup message generators)

::*********************************************************************
::
::	SUBROUTINE:	SUP0B:
::	FUNCTION:	Resources Report to Sup
::	CALLING SEQ:	JAL	R10,SUP0B    Called from 2-MINUTE LOGIC
::			and from CRQ when node goes out of passthroughs
::
::*********************************************************************

SUP0B	HS	0
	LHL	R2,TVRBUF		:REPORT AVAILABLE PASSTHRUS
	JER	R10			:no sup--can't report
	LHI	R1,8000+MACHNM		:else write our node #
	JAL	R9,WHWI
	LHI	R1,0B80			:write our messge type
	JAL	R9,WHWI
	LHI	R1,NPASTH		:number of total possible passthroughs
	SH	R1,PASTHR		:minus number of used passthroughs
	JGEFS	SUP0B2			:a neg check is expecting the worst
	LIS	R1,0			:report none left--an understatement
SUP0B2	STH	R1,PTHRPD		:store # Passthrus reported available
	JAL	R9,WHWI			:tell the sup our conclusion
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUP11:
::	FUNCTION:	REPORT HOST STATUS
::	CALLING SEQ:	JAL	R10,SUP11
::	INPUT:		R13 = HN = HOST # (NOT FOR GATEWAY)
::
::*********************************************************************

SUP11	HS	0
	LHL	R2,TVRBUF		:THE USUAL
	JER	R10
	ST	R4,YAKT1
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	IF	T2GATE			:GATEWAY SUP11 REPORT TO HNET
	LB	R1,HSTAT
	AHI	R1,1190			:Report as IIX Gateway
	ELSE
        LB      R4,HSTATN,HN            :get ORIG/DEST only bits        ###SDW
        SRLS    R4,1                    :move from bits 4,5 to 5,6      ###SDW
        NHI     R4,0C                   :mask off other bits            ###SDW
	LB	R1,HSTAT,HN		:STATUS BITS, MESS #
	AHI	R1,1180
        OR      R1,R4                   :and ORIG/DEST only bits        ###sdw
	EI	:T2GATE ##AL
	JAL	R9,WHWI
	IF	T2GATE			:GATEWAY RPT TO HNET
	LHL	R1,HOSTN		:ONLY ONE GW SLOT HOST
	ELSE
	LHL	R1,HOSTN,HN,HN		:HOST #
	EI	:T2GATE ##AL
	OHI	R1,8000			:PLUS 8000X
	JAL	R9,WHWI
	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUP1A:
::	FUNCTION:	REPORT HOST STATUS IN NEW FORMAT FOR MXP SYSTEMS
::			INCLUDING MACHINE # AND SLOT #
::	CALLING SEQ:	JAL	R10,SUP1A
::	INPUT:		R13 = HN = HOST #
::	FORMAT:
::	[1A,STATUS] where STATUS is 8 bits long, STATUS = 100P CCXY
::		P = Proxy host
::		CC= collect-calls
::			00 = never accept collect-calls
::			01 = only accept collect calls
::			10 = leave the decision to the destination host
::			11 = unused
::		XY= Status
::			00 = answered
::			10 = shut
::			01 = down
::			11 = gone
::	[8080] - if LOGII then 1L001000 - Log2
::	[8000 + Host #]
::	[80 + MXP machine #, 80 + Host slot]
::*********************************************************************

SUP1A	HS	0
	LHL	R2,TVRBUF		:IS THERE A SUPERVISOR?
	JER	R10			:DON'T BOTHER IF NOT
	ST	R4,YAKT1
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	LB	R1,HSTAT,HN		:STATUS BITS
	LB	R0,HSTAT3,HN		:Log2, Proxy, CC bits (1,3,4,5)	###wjl
	OR	R1,R0			:combine			###wjl
	AHI	R1,1A80			:+ MESSAGE NUMBER (NEW)
	JAL	R9,WHWI
	LHI	R1,8080			:FOR FUTURE USE
	JAL	R9,WHWI
	LHL	R1,HOSTN,HN,HN		:HOST NUMBER
	OHI	R1,8000			:SET 8000 BIT
        JAL     R9,WHWI			:###LH
	LB	R1,HSTKEY,HN		:GET SLOT# * 4 IF NON-MXP (00SS)
					:    SLOT#,MACHINE# IF MXP (00SM)
        IF      MXPNM			:IF MXP, CONVERT (00SM) TO (0M0S)
	EXBR	R0,R1			:R0 = (SM00)
        NHI     R0,0F00         	:R0 = (0M00)
        SRHLS   R1,4            	:R1 = (000S)
	OR	R1,R0			:R1 = (0M0S)
        ELSE	:not MXPNM		:IF NON-MXP, COMPUTE SLOT#
        SRHLS   R1,2	           	:(TRUE SLOT#, NOT SLOT# * 4)
        EI      :MXPNM
	OHI	R1,8080			:SEND SLOT# (00SS) + 8080 IF NON-MXP
	                               	:SEND MACHINE#,SLOT# (0M0S) + 8080 IF
        	                       	:MXP MACHINE			###LH
	JAL	R9,WHWI
	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUPHS:
::	FUNCTION:	SEND HOST STATUS REPORT TO SUP WHICH MAY
::			CONTAIN HIQ, HID DATA.
::	CALLING SEQ:	JAL	R10,SUPHS
::	INPUT:		R4  = HID
::			R13 = HOST #
::			R14 = MESSAGE HEADER
::
::*********************************************************************

SUPHS	HS	0
	LHL	R2,TVRBUF		:IS THERE A COMMAND CIRCUIT?
	JER	R10			:NO
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI			:IDENTIFY OURSELVES
	LR	R1,R14
	JAL	R9,WHWI			:SEND MESSAGE HEADER
	LHL	R1,HOSTN,HN,HN
	OHI	R1,8000			:HOST NUMBER + 8000
	JAL	R9,WHWI
	LR	R1,R4
	JER	R10			:NO HID, DONE WITH MESSAGE
	OHI	R1,8000
	JAL	R9,WHWI			:HID + 8000
	JR	R10			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	SUP12:
::	FUNCTION:	REPORTS TO SUP'S LOG.
::	CALLING SEQ:	JAL	R10,SUP12
::	DESTROYED:	R0, R1, R2, R3, R8, R9
::
::*********************************************************************

:	COMMAND CIRCUIT EXISTS IF TVRBUF<>0 (TVRBUF CONTAINS COMMAND CIRCUIT
:	BUFFER INDEX) AND AN ENTRY IN LIOTAB MATCHES IT (TVRBUF MAY BE
:	NON-ZERO IF UPSTREAM LINK JUST WENT OUT AND LEP HAS NOT YET
:	PROCESSED THE ZAPPER FROM TRLINK). IF THERE IS NO COMMAND CIRCUIT,
:	TEST FOR LINE DIAGNOSTIC MESSAGE, CHARACTERISED BY THE 8000 BIT
:	SET IN SUPMBF. IF NOT A LINE DIAGNOSTIC, STORE REPORT TO LOG IN
:	'NCCBUF' BUFFER TO BE SENT TO SUP FOLLOWING NODE'S TAKEOVER.

SUP12	HS	0
	LHL	R2,TVRBUF		:GOT A COMMAND CIRCUIT?
	JEFS	SUP12B			:NO
	LHI	R1,NLQ-1		:MAYBE - SEE IF ANY LEP P.T. ENTRIES
:	ARE EQUAL TO THE CONTENTS OF TVRBUF, AND THEREFORE POINT TO ACTIVE SUP
SUP12A	LHL	R0,LIOTAB,R1,R1
	NHI	R0,-4
	CR	R0,R2			:UPSTREAM POINTER?
	JEFS	SUP12C			:YES - GOT A COMMAND CIRCUIT
	SIS	R1,1
	JGEBS	SUP12A			:KEEP CHECKING

:	NO COMMAND CIRCUIT PRESENT...
SUP12B	LH	R2,SUPMBF		:IS THIS A LINE DIAGNOSTIC?
	JLR	R10			:YES, RETURN
	LIS	R2,NCCBUF		:NO - STORE TYPE 12 MSG IN TEMP BUFFER
SUP12C	ST	R4,YAKT1
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	LHI	R1,1280
	JAL	R9,WHWI
	LHL	R1,SUPMBF
	JAL	R9,WHWI			:48 BITS OF MESSAGE
	LHL	R1,SUPMBF+2
	JAL	R9,WHWI
	LHL	R1,SUPMBF+4
	JAL	R9,WHWI

:	FORMAT CRYPTOGRAM FOR XRAY LOG
SUP12D	HS	0
	LHL	R4,SUPMBF		:GET NODE REPORT TYPE
	CLHI	R4,NRMPNE		:DO WE WANT TO SEND CRYPTOGRAM?
	JG	NRCREX			:NO - EXIT
	SLLS	R4,2
	LH	R1,NRMPTB-4,R4		:GET MAPPING ENTRY
	JL	NRCREX			:NO FORMATTING DESIRED
	LB	R1,NRFMTB-1,R1		:GET MAPPING ARRAY ADDRESS
NRCR10	LB	R8,NRMPBS,R1		:GET SOURCE DISPLACEMENT
	JEFS	NRCR20			:DONE WITH THIS CRYPTOGRAM
	LB	R9,NRMPBS+2,R1		:GET MASK
	LB	R3,SUPMBF,R8		:GET SOURCE BYTE AND
	NR	R3,R9			:MASK OUT UNWANTED BITS
	LB	R9,NRMPBS+1,R1
	STB	R3,CRYSBF,R9		:STORE FOR CRYPTOGRAM
	AIS	R1,3
	JBS	NRCR10
NRCR20	LHL	R1,NRMPTB-2,R4		:GET CRYPTO NUMBER AND MESSAGE FLAGS
	L	R0,CRYSBF+4
	JAL	R8,CRYPT1,,		:SEND CRYPTOGRAM
NRCREX	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	TABLE:		NRMPTB
::	FUNCTION:	DEFINE MAPPING BETWEEN NODE REPORTS AND CRYPTOGRAMS
::
::*********************************************************************

:	EACH ENTRY IS 2 HALFWORDS LONG, WITH A FORMAT VALUE AND A CRYPTO VALUE.
:	BOTH ENTRY FIELDS ARE -1 IF NO CRYPTOGRAM IS TO BE GENERATED.
:	THE FORMAT VALUE PROVIDES AN INDEX INTO THE 'NRFMTB' TABLE WHICH
:	DIRECTS THE FORMATTING OF CRYPTOGRAMS BASED ON THE DATA IN THE NODE
:	REPORT. THE NRMPTB ENTRIES ARE ORDERED BY NODE REPORT NUMBER.
:
:	Six DIFFERENT MAPPINGS OF SUP DATA TO CRYPTO DATA ARE OFFERED.
:	FOR REFERENCE, THE SUP12 ROUTINE EXPECTS up to 4 HW OF DATA IN SUPMBF.
:	THESE ARE REFERRED TO AS SUP HW0 TO SUP HW3. CRYPT1 EXPECTS UP
:	TO 4 HW STARTING AT CRYSBF. THESE ARE REFERRED TO AS CRY HW0 TO
:	CRY HW3.
:
:	SUPMBF HW0 contains NR.### and is preceeded by 1280.
:	SUPMBF HW1 and HW2 contain data for the Sup as explained below.
:	SUPMBF HW3 may contain additional data for CRYPTO message.
:	CRYSBF contains data in the following order: HW2 HW3 HW0 HW1 !!
:
:	CRYPTO Equate Codes indicate which HW's contain data.  For example,
:	a code of 5 (0101) indicates HW1 and HW3 contain data.
:
:	MAPS 1 AND 5 ARE BOTH USED FOR A CRYEXX CODE OF 5. THE REASON IS 
:	THAT CRY HW3 IS RESERVED FOR EITHER NEIGHBOR NUMBERS OR HOST NUMBERS
:	TO PROVIDE FOR FUTURE SCAN FUNCTIONS FOR A SPECIFIED NEIGHBOR OR
:	HOST. THE NODE REPORT CONVENTION HAS BEEN TO PUT THE NEIGHBOR
:	NUMBER IN SUP HW1 AND THE HOST NUMBER IN SUP HW2 FOR THE VARIOUS
:	DIFFERENT NODE REPORTS. THEREFORE, MAPS 1 AND 5 REVERSE THE FORMATTING
:	OF THOSE TWO FIELDS.
:
:	MAP 1:	SUP HW1 -> CRY HW3	CRYEXX CODE 5XXX
:		SUP HW2 -> CRY HW1
:
:	MAP 2:	SUP HW1 -> CRY HW0	CRYEXX CODE CXXX
:		SUP HW2 -> CRY HW1
:
:	MAP 3:	SUP HW1 -> CRY HW3	CRYEXX CODE 3XXX
:		SUP HW2 -> CRY HW2
:
:	MAP 4:	SUP HW1 -> CRY HW3	CRYEXX CODE 7XXX
:		SUP HW2 -> CRY HW1	:###wjl
:		SUP HW3 -> CRY HW2	:###wjl
:
:	MAP 5:	SUP HW1 -> CRY HW1	CRYEXX CODE 5XXX
:		SUP HW2 -> CRY HW3
:
:	MAP 6:	SUP HW1 -> CRY HW0	CRYEXX CODE CXXX
:		SUP HW2 -> CRY HW1	(SAME AS MAP 2 EXCEPT NO MASKING OF
:					 HI-ORDER BIT)

NRMPTB	HS	0
	HC	1,CRYE5F	:1 - CHANNEL IN USE
	HC	-1,-1		:2 - DATA ON UNASSIGNED CHANNEL
	HC	4,CRYE60	:3 - BUFFER ZAP
	HC	-1,-1		:4 - REMOVE NEIGHBOR RESPONSE
	HC	-1,-1		:5 - ADD NEIGHBOR RESPONSE
	HC	1,CRYE22	:6 - LINK BUBBLE
	HC	1,CRYE21	:7 - LINK SHRINK
	HC	3,CRYE68	:8 - OUT OF PERMUTER TABLE SPACE
	HC	3,CRYE69	:9 - OUT OF LINK DESCRIPTOR SPACE
	HC	4,CRYE4D	:0A- LINK OUT PLI COUNT
	HC	5,CRYE1C	:0B- OUT OF DISPATCHER PORTS
	HC	5,CRYE61	:0C- NEEDLE REJECTED BY SLOT OUT OF PORTS
	HC	5,CRYE62	:0D- IMPOSTER HOST
	HC	-1,-1		:0E- CIRCUIT LIFETIME
	HC	1,CRYE39	:0F- LINK SNIP
	HC	-1,-1		:10- DIAGNOSTIC REPORT
	HC	1,CRYE0A	:11- NO NEIGHBOR
	HC	1,CRYE26	:12- INVALID MACHNM ON COMMAND CIRCUIT
	HC	2,CRYE27	:13- INVALID COMMAND ON COMMAND CIRCUIT
	HC	2,CRYE34	:14- CIRCUIT ERRORS
	HC	2,CRYE35	:15- CIRCUIT INCONSISTENCIES
	HC	1,CRYE51	:16- LINK FROZEN
	HC	1,CRYE52	:17- LINK THAWED
	HC	4,CRYE4E	:18- COMMAND CIRCUIT PLI'S
	HC	-1,-1		:19- NODE CRASH REPORT
	HC	-1,-1		:1A- REPORT SIO, SYNC, XLINKS, NLINKS
	HC	-1,-1		:1B- REPORT PORTS, PASSTHROUGHS
	HC	-1,-1		:1C- REPORT UNUSED LINES
	HC	-1,-1		:1D- LINE/LINK REPORT
	HC	2,CRYE58	:1E- SLOT REPORT LIMIT EXCEEDED
	HC	5,CRYE5B	:1F- INVALID HOST FOR RESTRICTED NODE
	HC	5,CRYE5A	:20- SLOT/HOST CIRCUIT LIMIT EXCEEDED
	HC	-1,-1		:21- CNT OF CIRCUITS ZAPPED DUE TO DLOAD OR BT
	HC	2,CRYE5E	:22- INVALID 03-CHAR PAIR ON COMMAND CIRCUIT
	HC	2,CRYE56	:23- MAC ERROR, SOFT FAILURE
	HC	2,CRYE55	:24- 56KB DIAGNOSTIC - CCW CHAINING TIMEOUT
	HC	2,CRYE58	:25- DATA ON IDLE TYMSAT PORT
	HC	1,CRYE5C	:26- INVALID 03-CHAR PAIR ON T-I CMND CIRCUIT
	HC	1,CRYE5D	:27- T-I SUP RECORD WITH INVALID LENGTH
	HC	2,CRYE57	:28- DMA HARDWARE TIMEOUT CAUSED MAC INTERRUPT
	HC	5,CRYE64	:29- KERNEL PORT ZAP FAILED
	HC	-1,-1		:2A- FIRST ADDENDUM TO CRASH REPORT
	HC	-1,-1		:2B- 2ND ADDENDUM TO CRASH REPORT
	HC	-1,-1		:2C- REPORT KERNEL HOST NUMBER
	HC	-1,-1		:2D- SQFIX ERROR
	HC	-1,-1		:2E- TEMPERATURE OUT OF RANGE
	HC	2,CRYE75	:2F- NETID MISMATCH			###wjl
	HC	2,CRYE76	:30- WSIZ MATCH DOWN			###wjl
	HC	2,CRYE77	:31- XRAY NETID MOD			###wjl
	HC	3,CRYE79	:32- STARLINK RESET RETRY FAILURE	###EV
	HC	2,CRYE4F	:33- ASYNC RING WRAP			###wjl
NRMPNE	EQ	(.-NRMPTB)/4	:NUMBER OF NRMPTB ENTRIES

::*********************************************************************
::
::	TABLE:		NRMPBS
::	FUNCTION:	SET OF MAPPING ARRAYS TO CONSTRUCT CRYTPOGRAMS
::			FROM NODE REPORTS.
::
::*********************************************************************

:	EACH MAP CONSISTS OF 3-BYTE ELEMENTS, FOR BYTE-BY-BYTE FORMATTING.
:	THE FIRST BYTE IS THE SOURCE ADDRESS, RELATIVE TO SUPMBF.
:	THE SECOND BYTE IS THE DESTINATION ADDRESS, RELATIVE TO CRYSBF.
:	THE THIRD BYTE IS A MASK, SINCE MANY NODE REPORT FIELDS ARE OR'D WITH
:	8000 TO PREVENT NETWORK ESCAPES.

NRMPBS	HS	0		:BASE ADDRESS FOR MAP ENTRIES.

NRMP01	EQ	.
	BC	2,2,7F
	BC	3,3,0FF
	BC	4,6,7F
	BC	5,7,0FF
	BC	0		:END OF MAP 01

NRMP02	EQ	.
	BC	2,4,7F
	BC	3,5,0FF
	BC	4,6,7F
	BC	5,7,0FF
	BC	0		:END OF MAP 02

NRMP03	EQ	.
	BC	2,2,7F
	BC	3,3,0FF
	BC	4,0,7F
	BC	5,1,7F
	BC	0		:END OF MAP 03

NRMP04	EQ	.
	BC	2,2,7F
	BC	3,3,0FF
	BC	6,0,0FF		:###TZ
	BC	7,1,0FF		:###TZ
	BC	4,6,7F
	BC	5,7,0FF
	BC	0		:END OF MAP 04

NRMP05	EQ	.
	BC	2,6,7F
	BC	3,7,7F
	BC	4,2,7F
	BC	5,3,0FF
	BC	0		:END OF MAP 05


NRMP06	EQ	.
	BC	2,4,0FF
	BC	3,5,0FF
	BC	4,6,0FF
	BC	5,7,0FF
	BC	0		:END OF MAP 06

::*********************************************************************
::
::	TABLE:		NRFMTB:
::	FUNCTION:	POINTS TO FORMAT ACTION ARRAY
::			INDEXED BY FORMATTING TYPE
::
::*********************************************************************

NRFMTB	HS	0
	BC	NRMP01-NRMPBS
	BC	NRMP02-NRMPBS
	BC	NRMP03-NRMPBS
	BC	NRMP04-NRMPBS
	BC	NRMP05-NRMPBS
	BC	NRMP06-NRMPBS
	HS	0

::*********************************************************************
::
::	SUBROUTINE:	SUP12L:
::	FUNCTION:	FORMAT LINK BUBBLE/SHRINK NODE REPORT
::
::*********************************************************************

SUP12L	HS	0
	STH	R0,SUPMBF		:ENTERED WITH REPORT TYPE IN R0
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER IN HW2
	LHL	R0,NCHN,KD
	OHI	R0,8000
	STH	R0,SUPMBF+4		:CURRENT # OF CHANNELS IN HW3
	ST	R10,RTMT1
	JAL	R10,SUP12,,		:SHIP REPORT TO SUPERVISOR
	L	R10,RTMT1		:RESTORE LINK REG..
	JR	R10			:..AND RETURN

::*********************************************************************
::
::	SUBROUTINE:	NETDGN:
::	FUNCTION:	FORMAT DIAGNOSTIC CRYPTOGRAMS AND NODE REPORTS.
::	CALLING SEQ:	JAL	R9,NETDGN
::	INPUT:		R8 = DIAGNOSTIC SUB-TYPE
::
::*********************************************************************

NETDGN	HS	0
:	THROTTLE REPORTING IN CASE PATHOLOGICAL CONDITION...
	LHI	R0,NR.DGN
	AM	R0,NETDCT		:SHOULD WE THROTTLE DIAGNOSTIC REPORT?
	JGR	R9			:YES - ENOUGH THIS MINUTE

	STH	R0,SUPMBF		:STORE NODE REPORT TYPE
	L	R0,SUPMBF+2		:SET UP R0 FOR CRYPTO (LAST 3 BYTES OF
					:NODE REPORT ALSO USED AS CRYPTO DATA)
	STB	R8,SUPMBF+2		:STORE DIAGNOSTIC SUB-TYPE
	NHI	R8,NTDRTS/4-1		:INSURE VALID VALUE		###wjl
	SLLS	R8,2			:FW indexing			###wjl
	L	R10,NTDRTN,R8,		:GET SUB-TYPE ROUTINE ADDRESS	###wjl
	JR	R10			:DISPATCH			###wjl

NTDSYM	JAL	R8,CRYPTO,,
	HC	CRYE30			:SYNC SCAN ERROR
	J	NTDSNR

NTDSIO	NI	R0,0FFFFFF		:strip out diagnostic sub-type	###wjl
	JAL	R8,CRYPTO,,
	HC	CRYE32			:SIO BUFFER COUNT ERROR
	JFS	NTDSNR

NTDSBZ	NI	R0,0FF0000		:STRIP OUT NEIGHBOR NUMBER
	AR	R0,R8			:PUT IN REASON FOR TIMEOUT
	JAL	R8,CRYPTO,,		:M-BOARD TIMEOUT
	HC	CRYE33
	JFS	NTDSNR

NTDOPS	JAL	R8,CRYPTO,,
	HC	CRYE31			:OOPS - INVALID CALLING ARGUMENT IN R8
	JR	R9

NTDSNR	HS	0			:SEND NODE REPORT
	ST	R9,NTDRET
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP
	L	R9,NTDRET		:RESTORE LINK REG AND
	JR	R9			:RETURN

::*********************************************************************
::
::	TABLE:		NTDRTN
::	FUNCTION:	HANDLER ROUTINES, BASED ON SUB-TYPE
::
::*********************************************************************

NTDRTN	WC	NTDSYM,NTDSIO,NTDSBZ,NTDSBZ
	WC	NTDSBZ,NTDSBZ,NTDOPS,NTDOPS
NTDRTS	EQ	.-NTDRTN		:TABLE SIZE

::*********************************************************************
::
::	SUBROUTINE:	SUP13:
::	FUNCTION:	INDICATES CHANGES IN LINK CONDITIONS
::	CALLING SEQ:	JAL	R10,SUP13
::	INPUT:		R4  =  MESSAGE TYPE
::			R14 = LN
::			R15 = KD
::
::*********************************************************************

SUP13	HS	0
	LHL	R2,TVRBUF		:IS THERE A SUP?
	JER	R10
	ST	R4,YAKT1
	LHI	R1,8000+MACHNM
	JAL	R9,WHWI
	LR	R1,R4
	JAL	R9,WHWI
	EXBR	R1,LN
	SRHLS	R1,1
	OHI	R1,8000
	LB	R0,KSPD,KD
	AR	R1,R0
	JAL	R9,WHWI
	LHL	R1,NDID,KD
	OHI	R1,8000
	JAL	R9,WHWI
	L	R4,YAKT1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SUP14:/SUP14A:
::	FUNCTION:	GENERAL AND SUNDRY MISCELLANEA
::	REGISTER USAGE:
::		R1 - SOURCE OF ACCOUNTING (IF SUBTYPE = 89x)
::			0 FOR NODE CODE, 4 FOR DISPATCHER OR TYMSAT.
::			ALSO USED FOR WCI DATA
::		R2 - SUP BUFFER # (IF SUP IS PRESENT) SUPPLIED BY THIS RTN
::		R3 - SCRATCH, USED BY WCI
::		R4 - PRESERVED.  USED FOR CURRENT 7--- ACCT. RECORD
::		R5 - SUB-TYPE, PROVIDED BY CALLING ROUTINE
::		R6 - LENGTH OF DATA IN HW'S (2 MAXIMUM)
::		R8 - LINK FROM WHWI TO WCI
::		R9 - LINK TO WHWI
::		R10- LINK TO THIS ROUTINE
::
::*********************************************************************

:	SUP14A:
:	ENTRY POINT FOR NODE CODE GENERATED ACCOUTING MESSAGE TO SUP.
:	ENTERED WITH FIRST 2 HALFWORDS ACCOUNTING DATA IN R1.

SPTP14	EQ	1400			:sup msg type 14, subtype field empty
NCACCT	EQ	89			:node code generated accounting msg

SUP14A	HS	0
	ST	R1,SUPMBF		:HW1, HW2 OF ACCOUNTING MSG
	LHI	R5,NCACCT		:INDICATE ACCOUNTING MESSAGE,
	LIS	R1,0			:GENERATED BY NODE CODE,
	LIS	R6,2			:2 HALFWORDS LONG

SUP14	HS	0
	ST	R4,YAKT1		:PRESERVE R4
	CLHI	R5,NCACCT		:ACCOUNTING MESSAGE?
	JN	SUP14B			:NO, CONTINUE "NORMALLY"
	LB	R8,SUPMBF		:GET ACCOUNTING DATA TYPE
	NHI	R8,00F0			:GET HIGH ORDER NIBBLE
	CLHI	R8,0070			:TYPE 07?  (CHANGE INVOICE #)
	JE	SUP14C			:YES

:	ACCOUNTING DATA RECEIVED
	THI	R1,0FFFB		:TYPE OF CALL = 0 OR 4 ?
	JEFS	SUP14E			:YES, OK
	CRASH.(.SUPCR)
SUP14E	L	R4,ACT7,R1		:COMPARE LAST 7--- OF THIS TYPE
	LB	R8,ACTLST		:WITH LAST 7--- ISSUED
	C	R4,ACT7,R8
	STB	R1,ACTLST		:(SAVE CURRENT SOURCE AS OLD SOURCE)
	JE	SUP14B			:EQUAL, SEND NO 7--- RECORD

:	7---'S NOT EQUAL, SEND LAST 7--- OF THIS TYPE, AND DATA REC.
	LHL	R2,TVRBUF		:SUP?
	JE	SUP14F			:NO, EXIT
	LHI	R1,8000+MACHNM		:SEND NODE #
	JAL	R9,WHWI
	LHI	R1,SPTP14+NCACCT	:ACCOUNTING MESSAGE SUB-TYPE
	JAL	R9,WHWI
	EXHR	R1,R4			:GET FIRST HALF OF 7--- RECORD
	JAL	R9,WHWI
	LHR	R1,R4			:SECOND HALF
	JAL	R9,WHWI
	J	SUP14D			:WRITE NON-7--- DATA

SUP14C	L	R8,SUPMBF		:GET NEW ACCT MESSAGE
	C	R8,ACT7,R1		:= LAST ONE OF THIS TYPE?
	JE	SUP14F			:YES, REDUNDANT MSG, SKIP IT
	ST	R8,ACT7,R1		:SAVE 7---
	CLB	R1,ACTLST		:IF THIS 7--- IS FROM THE SAME SOURCE
	JN	SUP14F			:AS THE LAST ONE, WE MUST SET IT TO
	LIS	R8,8			:SOMTHING DIFFERENT OR IT MAY NOT
	STB	R8,ACTLST		:BE SENT
	J	SUP14F			:RESTORE R4 AND EXIT

SUP14B	HS	0
GSP14H	LHL	R2,TVRBUF		:SUP PRESENT? (entry for Gateway
	JER	R10			:host cost report to H-net)
SUP14D	LHI	R1,8000+MACHNM
	JAL	R9,WHWI
	LHI	R1,SPTP14		:sup msg type 14, empty subtype field
	AR	R1,R5			:R5 CONTAINS SUBTYPE
	JAL	R9,WHWI
	LHL	R1,SUPMBF  
	JAL	R9,WHWI
	SIS	R6,1
	JLEFS	SUP14F
	LHL	R1,SUPMBF+2
	JAL	R9,WHWI
SUP14F	L	R4,YAKT1
	JR	R10

	ENDMO.(LOGSUP)

	EI	:1-KILLIT

	KILMSG(LOGSUP)

:	***NOTHING PAST THIS POINT***

	SUBTTL	LEP

:			*     ***** ****
:			*     *     *   *
:			*     ****  ****
:			*     *     *
:			***** ***** *

::#####################################################################
::
::	MODULE:		LEP
::
::	FUNCTION:	SUPERVISOR TO NODE COMMANDS
::
::	SUBTTLS:
::		LEP08 - Takeover command
::		LEP09 - Circuit building command
::		LEP0A - LOG II Circuit building command
::		LEP0B - Circuit trace request
::		LEP0C - Sleeping pills
::		LEP0D - Message for ports in login mode
::		LEP0E - Aux circuit message
::		LEP0F - General supervisor commands
::		LEP10 - Port status request
::		LEP11 - Assign channel to TYMNET-I
::		LEP12 - LOG II message for port in login mode
::		LEPZAP - Handle command circuit zapper
::		LEP utilities and tables
::
::#####################################################################

	IF 	1-KILLIT	
	BEGMO.
	SEG	1

::*********************************************************************
::
::	SUBPROCESS:	LEP:
::	FUNCTION:	Process data on a command channel.
::	SCHEDULED:	Runs off SWITCH exec loop, based on data being
::			received on a command channel.
::
::*********************************************************************

:	TYMNET-II LEPRECHAUN
LEP	HS	0			:###OAS

	IF	DB.CPU
	LR	R3,R2			:SAVE R2			###OAS
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR LEP		###OAS
	CPUTNM(LEP   )			:DEFINE LEP CPUTIL ENTRY	###OAS
	LR	R2,R3			:RESTORE R2			###OAS
	EI	:DB.CPU

	LR	CHN,R2			:SAVE THE CHANNEL #
	LHL	R2,LIOTAB,R2,R2		:GET BUFF #
	NHI	R2,-4
	XHI	R2,4
	STH	R2,LEPINB		:SAVE IT

:	ENTRY POINT - RETURN FROM PROCESSING COMMAND
LEP1	HS	0
	LHL	R2,LEPINB		:RETREIVE BUFFER #
	L	R3,BB,R2,		:PEEK AT BYTE COUNT
	JE	BIDDRT,,		:BUFFER EMPTY
	JAL	R8,PCI			:SKIP LEADING 0
	CLHI	R1,3			:TEST FOR 03-PAIR (ONLY ZAPPERS)
	JE	LEPZAP			:ZAP SUP CIRCUIT IF IT IS
:       following handles new variable size len fields                  ###sdw

        JL      LEP1.0                  :otherwise 1st byte is high byte of len
        LR      LRC,R1
        EXBR    LRC,LRC                 :put into high byte
        J       LEP1.5
LEP1.0  LIS     LRC,0                   :clear so AR works for 1 byte of len
        JAL     R8,PCI                  :get second byte of len
        CLHI    R1,6                    :if 2nd byte<6 then it is high byte
        JGEFS   LEP1.6                  :we have all of len
        LR      LRC,R1
        EXBR    LRC,LRC                 :put high byte into high byte
LEP1.5  JAL     R8,PCI
        JAL	R8,PCI			:ACTUAL BYTE CNT
LEP1.6	AR	LRC,R1			:SAVE IT
	JAL	R8,CBCCT		:CNT OF CHARS IN BUFF
	CLHI	R1,6			:NEED AT LEAST 6 CHARS IN BUFF
	JL	BIDDRT,,
	CR	R1,LRC
	JL	BIDDRT,,		:EXIT IF ENTIRE MESS NOT IN BUFF

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LEPDB1,,
	GL	LEPDB1
	LM	R0,REGST		:restore regs		###sdw
	LR	R5,LRC			:GET BYTE COUNT INTO R5
	JAL	R14,LEPDB2,,
	GL	LEPDB2
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	JAL	R8,GCI			:DISCARD BYTE CNT
	JAL	R8,GCI

	L	R3,BB,R2,		:PCI needs this
	JAL	R9,PHWI			:GET THE NODE #
	NHI	R1,7FFF
	CLHI	R1,MACHNM
	JN	LEPXMN			:ABORT IF INCORRECT NODE #
	JAL	R8,PCI			:GET THE MESSAGE TYPE
	SIS	R1,8			:DISPATCH
	JL	LEPXCM			:MSG TYPE OUT OF RANGE
	CLHI	R1,LEPDMX
	JGE	LEPXCM			:MSG TYPE OUT OF RANGE
	SLLS	R1,2			:FW indexing			###wjl
	L	R1,LEPDIS,R1,		:GET PTR FROM DISPATCH TYPE 	###wjl
	JR	R1			:AND GO EXECUTE			###wjl

:	ILLEGAL MACHINE NUMBER
LEPXMN	HS	0		
	OHI	R1,8000
	STH	R1,SUPMBF+2		:SAVE ILLEGAL NODE # FOR NODE REPORT
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP COMMAND CIRCUIT...
	LHI	R0,NR.XMN		:SET UP FOR NODE REPORT
	JFS	LEPXC2

:	INVALID COMMAND TYPE
LEPXCM	HS	0		
	OHI	R1,8000
	AIS	R1,8			:REPLACE BIAS
	STH	R1,SUPMBF+2		:SAVE INVALID COMMAND FOR NODE REPORT
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP COMMAND CIRCUIT...
	LHI	R0,NR.XCM
:	SEND NODE REPORT TO SUP
LEPXC2	STH	R0,SUPMBF		:NODE REPORT TYPE
	LH	R0,LEPXER
	AIS	R0,1			:INCREMENT COUNT OF LEP ERRORS
	STH	R0,LEPXER
	OHI	R0,8000
	STH	R0,SUPMBF+4		:INCLUDE COUNT IN NODE REPORT
	JAL	R10,SUP12		:SEND NODE REPORT
	J	LEPZA4			:OUTPUT CRYPTOGRAM AND EXIT

:	HANDLER ROUTINE FOR UNKNOWN MESSAGE TYPE FROM SUPERVISOR
LEPXT	LHI	R6,-2,LRC		:REMOVE THE COMMAND
LEPXT1	LHL	R0,BCT,R2,		:EXTRA CARE TAKEN FOR UNKNOWN COMMAND
	JE	BIDDRT,,		:TO AVOID GCI CRASHES
	JAL	R8,GCI
	SIS	R6,1			:MARK CHAR OF MSG OUT OF BUFFER
	JGBS	LEPXT1			:LOOP FOR NEXT ONE IF THERE IS ONE
	J	LEP1

	SUBTTL	LEP (LEP08 - Type 8:  Takeover command)

::*********************************************************************
::
::	COMMAND:	LEP08:
::	FUNCTION:	PROCESS TAKEOVER COMMANDS (TYPE 8)
::
::*********************************************************************

LEP08   HS     0
:       BEFORE PROCESSING TAKEOVER COMMANDS ON AN ISIS MACHINE, WE FIRST
:	NEED TO VERIFY THAT THE STATUS OF EACH HOST IS CORRECT.
        IF     (1-T2GATE)
        ST     R2,HSTSAV	       :SAVE R2

        JAL    R7,CHKHST	       :VERIFY THE STATUS OF ALL HOSTS
        L      R2,HSTSAV	       :RESTORE R2
        EI     :(1-T2GATE)

:       START TO PROCESS TAKEOVER COMMANDS
	IF	T2GATE			:RPT TO INET SUP IF NESSARY
        LB      R1,G0DFG                :have INET supe?
        JEFS    LP081                   :shut until have both supes ###sdw
	LIS	R3,0			:remember is answerred
	STB	R3,HSTAT		:TAKEOVER RESP. MAY RPT HSTAT
	JAL	R10,GHSTST,,
	EI	:T2GATE			:##AL
LP081	JAL	R9,GHWI			:TAKEOVER - GET NODE #

:	OLD SUP REQUIRES TYPE 09 TAKEOVER RESPONSE, NEWSUP TAKES TYPE 19
:	WHICH INCLUDES EXPANDED HOST INFORMATION
	LIS	R8,0			:ASSUME OLD TYPE SUP		###OAS
	THI	R1,8000			:CHECK FOR BIT 0 OF NODE NO. SET###OAS
	JNFS	LEP08S			:SET, OLD TYPE SUPERVISOR	###OAS
	LIS	R8,1			:NOT SET, FLAG AS NEW TYPE SUP	###OAS
LEP08S	HS	0	
	STH	R8,NEWSUP		:STORE NEW SUP FLAG		###OAS

	JAL	R8,GCI			:DISCARD TYPE
	JAL	R8,GCI			:GET THE SUP #
       IF       LOGII
        LIS     R0,0                    :init not LOG2 supe
        THI     R1,L2F.TK               :LogII supes have bit 2 set
        JEFS    LEP08L
        LIS     R0,1
LEP08L  STB     R0,NEWSUP               :mark it in first byte of newsup
       EI       :LOGII
	NHI	R1,0F			:four bits max for sup number
	LR	PRC,R1
	LHL	R2,TVRBUF		:GET BUFF TOWARDS OLD SUP
	JEFS	LEP08A			:NONE
	LHI	R1,MACHNM+8000		:SEND TAKEOVER NOTICE TO OLD SUP
	JAL	R9,WHWI
	LR	R1,PRC			:NEW SUP #
	AHI	R1,0A80
	JAL	R9,WHWI
LEP08A	LHL	R2,LIOTAB,CHN,CHN	:GET BUFF # (TOWARDS SUP)
	NHI	R2,-4
	STH	PRC,TVRSUP		:SAVE # OF CURRENT SUP
	STH	R2,TVRBUF		:AND UPSTREAM BUFF #

:	CHECK FOR OLD OR NEW SUP (NEW SUP ACCEPTS EXPANDED HOST INFO)
	LHL	R1,NEWSUP		:CHECK FOR OLD OR NEW SUP	###OAS
	JN	LEP08T			:NEW SUP, FORM NEW TAKEOVER RESP###OAS

:	SEND TYPE 09 TAKEOVER RESPONSE TO OLD SUP
	LHI	R1,MACHNM+8000		:NOW SEND TAKEOVER RESPONSE
	JAL	R9,WHWI
	LR	R1,PRC			:SUP #
	AHI	R1,980
	JAL	R9,WHWI
	LH	R1,VERSSV+2,,		:VERSION
	JAL	R9,WHWI
	LH	R1,CRSHAD+2		:CRASH MARK
	JAL	R9,WHWI
	LB	R1,CRHCNT+1		:CRASH COUNT
	EXBR	R1,R1
	OHI	R1,8080			:(BOTH ARE "ESCAPED")
	AH	R1,NALINK		:...& # OF LINKS
	JAL	R9,WHWI
	L	R1,BE,R2,		:				###AL
	ST	R1,NALNKA		:STORE NALINK FLD. PTR ADDR.	###AL
	LHI	R1,80			:LEAVE ROOM FOR # OF HOSTS
	JAL	R8,WCI
	L	R0,BE,R2,		:SAVE PTR TO IT
	ST	R0,YAKT1
	JAL	R8,WCI			:FOLLOWING BYTE ALWAYS 80
	LHI	R1,NPASTH		:# OF PASSTHRUS
	SH	R1,PASTHR
	JGEFS	LEP810			:MAY BE <0 DUE TO SUP CIRCS
	LIS	R1,4
LEP810	JAL	R9,WHWI

	LIS	KN,0			:NEIGHBOR #'S
:: An additional ckeck for the number of active links and number of neighbors
:: to be matched in the takeover response. If not matched, report CRYPTO and
:: use number of active links as a correct number for both.		###AL
	LHI	R0,0			:				###AL
	STH	R0,TEMPHS		:ZERO THE NUMBER OF NBR COUNT	###AL
LEP08B	SLLS	KN,1
	L	KD,KDKN,KN,KN
	SRLS	KN,1
	LB	R0,NLAT,KD		:DON'T REPORT LINK IF INACTIVE
	JE	LEP08D			:				###wjl
	LH	R1,NDID,KD

:	DON'T REPORT SCLP LINK NEIGHBOR
      IF	SCLP
	CLHI	R1,$8 2000		:SCLP link always 2000		###wjl
	JNFS	LEP08W			:not SCLP link			###wjl
	LHL	R0,NALINK		:reduce NALINK reported		###wjl
	SIS	R0,1			:by one				###wjl
	OHI	R0,80			:set ho bit			###wjl
	L	R1,NALNKA		:get address			###wjl
	STB	R0,,R1,			:store reduced NALINK value	###wjl
	J	LEP08X			:count, but don't report neighbor##wjl
LEP08W
      EI	:SCLP

	OHI	R1,8000
	JAL	R9,WHWI
LEP08X	LIS	R0,1			:				###AL
	AHM	R0,TEMPHS		:INC. TEMPHS			###AL
LEP08D	AIS	KN,1
	CLHI	KN,NLINKS
	JL	LEP08B
	LHL	R0,TEMPHS		:CHECK IF #NBRS MATCH NALINK	###AL
	CLH	R0,NALINK		:				###AL
	JE	LEP8CC			:IF OK DO NOTHING		###AL
	EXHR	R0,R0			:REPORT CRYPTO. HW0=#NBRS,HW1=NALINK
	AH	R0,NALINK
	JAL	R8,CRYPTO,,
	HC	CRYE74
	LH	R0,TEMPHS		:FORCE TO MATCH #NBRS=NALINK	###AL
	OHI	R0,80			:HO BIT SET IN FORMAT		###AL
	L	R1,NALNKA		:PREVIOUS FLD. ADDR SAVED	###AL
	STB	R0,,R1,			:				###AL
LEP8CC

	LIS	KN,0			:LINK SPEEDS
LEP08C	SLLS	KN,1
	L	KD,KDKN,KN,KN
	SRLS	KN,1
	LB	R0,NLAT,KD		:SKIP INACTIVE LINKS
	JEFS	LEP08E
	LB	R1,KSPD,KD
	OHI	R1,80
	JAL	R8,WCI
LEP08E	AIS	KN,1
	CLHI	KN,NLINKS
	JL	LEP08C

	LIS	HN,0			:HOST DATA
	LHI	R5,80			:TO COUNT HOW MANY HOSTS
LEP08G	LHL	R1,HOSTN,HN,HN		:HOST #
	JEFS	LEP08F			:NONE THERE
	AIS	R5,1
	AHI	R1,8000
	JAL	R9,WHWI
LEP08F	AIS	HN,1
	CLHI	HN,NHOSTS
	JL	LEP08G
	L	R1,YAKT1		:PUT AWAY HOST COUNT
	STB	R5,0,R1
	LIS	HN,0			:SEND STATUS BITS
	LIS	R1,1			:2 BITS/HOST IS DUMB!
LEP08J	LHL	R5,HOSTN,HN,HN		:read host entry
	JEFS	LEP08K			:nothing doing if no host there
	SLHLS	R1,2			:shift R1--make room for next status
	LB	R5,HSTAT,HN		:STATUS IS HI 2 BITS
	AR	R1,R5			:add status bits into the byte
	THI	R1,100			:test for overflow from byte
	JEFS	LEP08K			:branch until it is full
	JAL	R9,WCIE			:BYTE FULL -- write it into buffer
	GL	WCIE
	LIS	R1,1			:reset register for next bunch of stati
LEP08K	AIS	HN,1			:increment pointer to next entry
	CLHI	HN,NHOSTS		:check for end of table
	JL	LEP08J			:there may be more hosts--keep looping
	CLHI	R1,1			:now check for remnants in R1
	JE	LEP08M			:if it's 1, no new info there
LEP820	SLHLS	R1,2			:left adjust any partials	###jhl
	THI	R1,100			:overflow means we're adjusted
	JEBS	LEP820			:keep shifting until overflow	###jhl
	JAL	R9,WCIE			:then write in the final byte of stati

	J	LEP08M

:	SEND TYPE 19 TAKEOVER RESPONSE TO NEW SUP (WITH EXPANDED HOST INFO)
LEP08T	HS	0			:FORM NEW TAKEOVER RESPONSE	###OAS
	LHI	R1,MACHNM+8000		:SET UP HEADER			###OAS
	JAL	R9,WHWI
	LR	R1,PRC			:GET SUPERVISOR NUMBER		###OAS
	AHI	R1,1980			:FORM NEW TAKEOVER RESP (19)	###OAS
	JAL	R9,WHWI

	LB	R1,CRHCNT+1		:GET CRASH COUNT		###OAS
	EXBR	R1,R1			:INTO HO BYTE OF LO HW		###OAS
	OHI	R1,8080			:ESCAPE BOTH BYTES		###OAS
	AH	R1,NALINK		:AND COMBINE # OF LINKS		###OAS
	JAL	R9,WHWI
	L	R1,BE,R2,		:				###AL
	ST	R1,NALNKA		:STORE NALINK FLD. PTR ADDR.	###AL
	LIS	HN,0			:COUNT NUMBER OF HOSTS		###OAS
	LHI	R1,8000			:TO COUNT HOW MANY HOSTS	###OAS
LEPN8J	HS	0
	LHL	R5,HOSTN,HN,HN		:CHECK HOST TABLE FOR ENTRY	###OAS
	JEFS	LEPN8K			:NONE THERE, DON'T COUNT	###OAS
	AIS	R1,1			:HOST THERE, BUMP COUNT		###OAS
LEPN8K	HS	0
	AIS	HN,1			:BUMP HOST INDEX		###OAS
	CLHI	HN,NHOSTS		:EXCEEDED NUMBER OF ENTRIES	###OAS
	JL	LEPN8J			:NO, CHECK FOR MORE HOSTS	###OAS
	JAL	R9,WHWI			:ALL DONE, WRITE # HOSTS	###OAS

	LH	R1,VERSSV+2,,		:GET VERSION NUMBER		###OAS
	JAL	R9,WHWI	

	LH	R1,CSMTBL+CS.CID	:GET CRASH SUBTYPE,TYPE		###OAS
	JAL	R9,WHWI

        LHI     R1,8080+L2F.NC          :bit 1 says LOGII capable NC    ###sdw
	JAL	R9,WHWI

	LHI	R1,NETID		:GET NODE'S NETWORK ID		###OAS
	JAL	R9,WHWI
	LHI	R1,NETMOD		:GET NODE'S NETWORK MODIFIER	###OAS
	JAL	R9,WHWI
	LHI	R1,SUBNET		:GET NODE'S SUBNET NUMBER	###OAS
	JAL	R9,WHWI

	LHI	R1,NPASTH		:GET NUMBER OF POSSIBLE PASSTHRUS##OAS
	JAL	R9,WHWI
	LHI	R1,NPASTH		:COMPUTE AVAILABLE FROM TOTAL	###OAS
	SH	R1,PASTHR		:MINUS CURRENT PASSTHRUS	###OAS
	JAL	R9,WHWI

	LIS	KN,0			:BEGIN LINK CLUSTERS		###OAS
	LIS	R0,0			:INIT TEMPHS CNT FOR #NBRS	###AL
	STH	R0,TEMPHS		:				###AL	
LEPN8B	HS	0
	SLLS	KN,1
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR		###OAS
	SRLS	KN,1
	LB	R0,NLAT,KD		:CHECK IF LINK ACTIVE		###OAS
	JE	LEPN8D			:NOT ACTIVE, DON'T REPORT	###OAS

	LH	R1,NDID,KD		:GET NEIGHBOR NO.		###OAS

:	DON'T REPORT SCLP LINK NEIGHBOR
      IF	SCLP
	CLHI	R1,$8 2000		:SCLP link always 2000		###wjl
	JNFS	LEP08U			:not SCLP link			###wjl
	LHL	R0,NALINK		:reduce NALINK reported		###wjl
	SIS	R0,1			:by one				###wjl
	OHI	R0,80			:set ho bit			###wjl
	L	R1,NALNKA		:get address			###wjl
	STB	R0,,R1,			:store reduced NALINK value	###wjl
	J	LEP08V			:count, but don't report neighbor##wjl
LEP08U
      EI	:SCLP

	OHI	R1,8000
	JAL	R9,WHWI

	LHI	R1,0080
	JAL	R8,WCI			:SAVE FOR FUTURE USE AS LINK FLAGS#OAS
	LB	R1,KSPD,KD		:GET LINK SPEED/FLAGS		###OAS
	OHI	R1,0080
	JAL	R8,WCI
LEP08V	LIS	R0,1			:INC. TEMPHS CNT		###AL
	AHM	R0,TEMPHS		:				###AL
LEPN8D	HS	0
	AIS	KN,1			:BUMP LINK INDEX		###OAS
	CLHI	KN,NLINKS		:# LINKS EXCEEDED?		###OAS
	JL	LEPN8B			:NO, LOOK THROUGH MORE LINKS	###OAS
	LHL	R0,TEMPHS		:CHECK IF #NBRS MATCH NALINK	###AL
	CLH	R0,NALINK		:				###AL
	JE	LEP8GG			:IF OK DO NOTHING		###AL
	EXHR	R0,R0			:REPORT CRYPTO. HW0=#NBRS,HW1=NALINK
	AH	R0,NALINK
	JAL	R8,CRYPTO,,
	HC	CRYE74
	LH	R0,TEMPHS		:FORCE TO MATCH #NBRS=NALINK	###AL
	OHI	R0,80			:SET HO BIT IN FORMAT		###AL
	L	R1,NALNKA		:PREVIOUS FLD. ADDR SAVED	###AL
	STB	R0,,R1,			:				###AL
LEP8GG	HS	0

	LIS	HN,0			:BEGIN HOST CLUSTERS		###OAS
LEPN8G	HS	0
	LHL	R1,HOSTN,HN,HN		:CHECK HOST TABLE FOR HOST ENTRIES#OAS
	JE	LEPN8F			:NO HOST AT THIS ENTRY		###OAS

	LB	R1,HSTAT3,HN		:Log2, Proxy, and CC (bits 1,3,4,5)#wjl
	SLLS	R1,03			:r1= 0000 00l0 pcc0 0000       	###sdw
        EXBR    R0,R1                   :r0= pcc0 0000 0000 00l0
        SLLS    R0,3                    :r0= 0000 0000 000l 0000
        OR      R1,R0                   :r1= 0000 0000 PCCL 0000
        SLLS    R1,8                    :r1= PCCL 0000 0000 0000        ###sdw
	JAL	R9,WHWI
	LHL	R1,HOSTN,HN,HN		:RECOVER HOST NUMBER		###OAS
	JAL	R9,WHWI

:	PREPARE TO SEND SLOT NUMBER TO SUP			        ###LH
	LB	R1,HSTKEY,HN		:GET SLOT# * 4  IF NON-MXP  (00SS)
					:    SLOT#,MACHINE# IF MXP  (00SM)
        IF      MXPNM			:IF MXP, CONVERT (00SM) TO (0M0S)
	EXBR	R0,R1			:R0 = (SM00)
        NHI     R0,0F00         	:R0 = (0M00)
        SRHLS   R1,4            	:R1 = (000S)
	OR	R1,R0		 	:R1 = (0M0S)
        ELSE	:NON-MXP, COMPUTE SLOT#
        SRHLS   R1,2			:(TRUE SLOT#. NOT SLOT# * 4)
        EI      :MXPNM
        OHI     R1,8080         	:SEND SLOT# (00SS) + 8080 IF NON-MXP
					:SEND MACHINE#,SLOT# (0M0S) + 8080 IF
					:MXP MACHINE			###LH
	JAL	R9,WHWI
	LB	R1,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	IF	T2GATE
	OHI	R1,10			:For Gateway, always IIX	###ev
      :fixed above to OR in 10 (iix bit) from 80 (origination only bit)###sdw
	EI	:T2GATE
	EXBR	R1,R1			:INTO HO BYTE OF LO HW		###OAS
	LB	R0,HSTCST,HN		:GET MULTI-TARGET HOST COST	###OAS
	OR	R1,R0			:COMBINE AND WRITE		###OAS
	JAL	R9,WHWI
	LB	R1,HSTMBK,HN		:GET MUTI-BASED HOST KEY	###OAS
	EXBR	R1,R1			:INTO HO BYTE OF LO HW		###OAS
	IF	T2GATE
	LHI	R0,08B			:Gateway is prodid 8B		###ev
	ELSE
	LB	R0,HSTYPE,HN		:GET HOST TYPE (PID)		###OAS
	EI	:T2GATE
	OR	R1,R0			:COMBINE AND WRITE		###OAS
	JAL	R9,WHWI

LEPN8F	HS	0
	AIS	HN,1			:BUMP HOST INDEX		###OAS
	CLHI	HN,NHOSTS		:MORE HOST ENTRIES?		###OAS
	JL	LEPN8G			:YES, GO CHECK THEM		###OAS

:	FINISHED WITH TAKEOVER RESPONSE, NOW MAKE CRYPTO LOG ENTRY
LEP08M	LR	R0,PRC			:TELL XRAY
	JAL	R8,CRYPTO,,
	HC	CRYE05			:TAKEOVER

	TS	TAKOVR			:FOR DEFERRED TAKEOVER NODE REPORTS

	IF	DB.CPU
	IF	SUPER
	LH	R0,CPUTFL,,		:ARE WE MEASURING CPUTIL ?
	JGEFS	LEPCP0			:NO, SIMPLY CLEAR SUP TRAFFIC COUNTERS.
	LIS	R0,0
	S	R0,SUPICC		:MEASURING,ADJUST BASE TRAFFIC COUNTERS
	AM	R0,SUICCT,,		:THIS IS TO ALLOW GOOD SUP TRAFFIC
	LIS	R0,0			:COUNT ON SUP BASES WHILE MEASURING
	S	R0,SUPOCC		:CPUTIL DURING NETWORK TAKEOVER	###OAS
	AM	R0,SUOCCT,,
	EI	:SUPER
LEPCP0	LIS	R0,0			:CLEAR SUP CHARACTER COUNTS
	ST	R0,SUPICC
	ST	R0,SUPOCC

	ELSE	:DB.CPU
	LIS	R0,0			:CLEAR SUP CHARACTER COUNTS
	ST	R0,SUPICC
	ST	R0,SUPOCC
	EI	:DB.CPU

	IF	(1-T2GATE)		:INFORM DISPATCHER (but not if Gateway)
	LHI	HN,NHOSTS		:TELL SUP OF ALL HOSTS OUT 
LEP08N	HS	0			:OF PORTS.
	SIS	HN,1			:NEXT HOST
	JL	LEP08O			:DONE
	LHL	R0,HOSTN,HN,HN		:GET HOST #
	JEBS	LEP08N			:IF ZERO HE IS GONE
	LHL	R1,HSTPTA,HN,HN		:GET PORTS AVAILABLE
	JNBS	LEP08N			:NOT 0 PORTS, DON'T REPORT
	LIS	R6,1			:TELL SUP 1 HW
	STH	R0,SUPMBF		:SAVE HOST #
	LHI	R5,8F			:HOST OUT OF PORTS MSG
	JAL	R10,SUP14
	J	LEP08N			:CONTINUE

LEP08O	HS	0			:DONE WITH OUT OF PORTS REPORTING
       IF       1-NCSLOT                 :allow NC to run in a slot
	LIS	R0,4
	JAL	R8,DIROOM		:WAIT FOR ROOM
	LHL	PRD,DRIF,,
	LHI	R0,INTKVR^8		:PORT 0 TAKEOVER MESS		###jhl
	AH	R0,TVRSUP		:INCLUDE SUP # IN 'UNUSED' MSG BYTE
       IF       LOGII                   :LOG2 supes are reported as 80+num
        LB      R1,NEWSUP               :where we put LOG2 capable indication
        JEFS    LEPL8O
        AHI     R0,L2F.DK               :tell dispathcer LOG II takevoer
       EI       :LOGII
LEPL8O	ST	R0,DIRNG,PRD,
	AIS	PRD,4
	NHI	PRD,DRSZ-4
	STH	PRD,DRIF,,
       EI       :1-NCSLOT
	EI	:(1-T2GATE)		:###EV
	LHL	R0,BCT+4,,		:ANY PORTS IN LOGIN MODE (IN BUFFER 4)?
	JEFS	LEP08P			:NO
	STH	R0,LOGZPF		:YES, TELL LOGGER TO ZAP THEM ALL

LEP08P	LIS	R6,NCCBUF
	LR	R7,R2
LEP08Q	LHL	R0,BCT,R6,		:ANY DATA IN TEMP STORAGE BUF?
	JEFS	LEP08R			:NO,MAKE KHOST REPORT,PERHAPS CRASH RPT
	LR	R2,R6
	JAL	R8,GCI			:COPY DATA FROM TEMPORARY BUFFER
	LR	R2,R7
	JAL	R8,WCI			:TO NEW COMMAND CIRCUIT BUFFER
	JBS	LEP08Q
LEP08R	LHI	R3,HST0			:GET KERNEL HOST NUMBER
	JAL	R9,HEXDEC,,		:GO DECIMAL
	GL	HEXDEC
	STH	R3,SUPMBF+2		:AND STORE AWAY
	LHI	R3,VERSIO		:GET VERSION NUMBER
	JAL	R9,HEXOCT,,		:GO OCTAL
	GL	HEXOCT
	STH	R3,SUPMBF+4		:AND STORE AWAY
	LHI	R3,NR.HVR		:REPORT KERNEL AND VERSION NUMBER
	STH	R3,SUPMBF
	JAL	R10,SUP12
	IF	T2GATE
	IF	\HNCOST
	LHI	R0,HNCOST		:Get specified cost
	LHI	R1,HHOST		:and H-net host #
	EXHR	R1,R1
	AR	R1,R0			:Make sup message content
	ST	R1,SUPMBF		:and store in sup mesage buffer
	LHI	R5,NCHCST		:Get message subtype 88
	JAL	R10,GSP14H		:and send it to sup
	EI	:\HNCOST
        LB      R1,HSTAT                :have to explicity say shut
        JEFS    LEP9TG                  :(shut if no INET supe)
        JAL     R10,SUP11
LEP9TG  HS      0
	EI	:T2GATE
	TS	CREPRT			:CRASH REPORT ALREADY MADE?
	JL	LPCR401			:YES - don't report crash

:	REPORT CRASH WITH:
:	NODE REPORT node# TYPE 19 aabbbbbb
:	where:
:		19 - Node crash report
:		aa = crash reason code
:	    bbbbbb = crash address
:
:	FOLLOWED BY CRASH ADDENDUM REPORT1:
:	NODE REPORT node# TYPE 2A aabbccdd
:	where:
:		2A - First addendum to the node crash report
:		aa = Crash code extension
:		bb = Current crash count
:		cc = Node code version number + 80
:			<0=SWITCHER, 1=ISIS, 2=TYMSAT, 3=GATEWAY>
:		dd = 0	<80 + NO. OF ADDITIONAL CRASH ADDENDUM REPORTS
:			 (TYPE 2B) TO FOLLOW.>
:
:	FOLLOWED BY 0-2 CRASH ADDENDUM REPORTS (CONTENTS OF CRITICAL REGISTERS)
:		(not implemented)

	LIS	R7,0			:INDEX INTO ADDITIONAL CRASH DATA AREA
	LHL	R6,NXTCRP		:GET OFFSET INTO CRASH SUMMARY TABLE
					:FOR NEXT CRASH TO REPORT TO SUP.
	JEFS	LPCR00			:THIS IS THE LATEST CRASH
	LIS	R7,0A			:'OLD' CRASH ADDITIONAL DATA AREA
LPCR00	L	R0,CSMTBL+CS.PSD+4,R6	:CRASH ADDRESS
	LR	R6,R6			:LATEST CRASH?
	JEFS	LPCR10			:YES
	OI	R0,800000		:SET HO BIT OF CRASH ADDRESS TO
					:INDICATE THIS IS AN 'OLD' CRASH
LPCR10	ST	R0,SUPMBF+2		:CRASH ADDRESS TO SUP BUFFER
	LB	R0,CSMTBL+CS.CID+1	:COMMON CRASH CODE		###wjl
	STB	R0,SUPMBF+2		:TO SUP BUFFER
	LHI	R0,NR.CRP		:REPORT TYPE 19
	STH	R0,SUPMBF		:TO SUP BUFFER
	JAL	R10,SUP12

:	Make first addendum to the node crash report  
LPCR20	LB	R0,CSMTBL+CS.CID	:CRASH SUBTYPE CODE
	SLLS	R0,8			:SHIFT IT UP 1 BYTE		###wjl
	LB	R1,CRHCNT+1		:GET CURRENT CRASH COUNT	###wjl
	OR	R0,R1			:COMBINE AND
	EXHR	R0,R0			:SHIFT UP
	LI	R1,8080+((VERSIO&0F000)^-4) :COMBINE WITH HO NIBBLE OF VERSION
	OR	R0,R1			:COMBINE
:	R0 = CRASH SUBTYE<1BYTE>,CRASH COUNT<1BYTE>,VERSION TYPE+80,
:	NUMBER ADDENDA TO FOLLOW+80.
	ST	R0,SUPMBF+2
	LHI	R0,NR.CR1		:REPORT TYPE 2A
	STH	R0,SUPMBF		:to sup buffer			###wjl
	JAL	R10,SUP12		:MAKE REPORT TO SUP
LPCR30	LR	R6,R6			:WAS THIS FOR THE MOST RECENT CRASH?
	JEFS	LPCR40			:YES
	LIS	R7,0			:POINT TO LATEST CRASH
	LIS	R6,0
	STH	R6,NXTCRP		:INDICATE NEXT CRASH TO SEND IS LATEST
	J	LPCR00
LPCR40  HS      0
       IF       1-(REBTAK&REBILD)       :if to resend rebuild requests  ###sdw

::  	Tymtunnel reports host up when Takeover message is done.	###AL
      IF	TUNL
:	LIS	KN,0			:search for each link
:TLEP08	SLL	KN,1
:	L	KD,KDKN,KN,KN
:	SRL	KN,1
	JAL	R10,TSUP1A		:report host up
:	AIS	KN,1			:next link
:	CLHI	KN,NLINKS
:	JL	TLEP08
      EI	:TUNL

        J	LEP1			:ALL DONE
       ELSE     :REBTAK			:resend them
        LIS     R5,0                    :index into array
LP8RB0	L	R6,REBTMO,R5		:on rebuild timout?
	O	R6,REBTMI,R5		:on either of the rebuild timouts?
LP8RB2  JFFO    R6,LP8RB1               :got one
	AIS	R5,4			:next group			###sdw
	CLHI	R5,NCIRCS/20		:done with all ports?
	JLBS	LP8RB0
	J	LP8RB9			:done with rebuild resending 
LP8RB1  SLLS    R5,3			:make into real number
        ST	R6,LP8RS1		:save active flags
        RBT     R7,LP8RS1		:this one serviced
        AR      R7,R5
        SRLS    R5,3                    :restore index into flags
        SLLS    R7,2                    :make buffer index
        AI      R7,HBUFN                :got our history buffer
        LHL     R0,RNFLAG,R7,           :origination?
        JE      LP8RB8                  :nope, skip resending
        LHL     R2,TVRBUF               :
        LHI     R1,8000+MACHNM          :make rebuild request supe msg
        JAL     R9,WHWI
        LHI     R1,0D80                 :type 0D
        JAL     R9,WHWI
        LHL     R1,RNFLAG,R7,           :needle flags
        JAL     R9,WHWI
        LHI     R1,8080                 :scratch port number
        JAL     R9,WHWI
        LHL     R1,RBASE,R7,            :base and host #
        JAL     R9,WHWI
	LHL	R1,RHOSTN,R7,
	JAL	R9,WHWI
        LHL     R1,RINVC,R7,            :invoice number
        JAL     R9,WHWI
        LHL     R1,RINVC+2,R7,          :all of invoice number
        JAL     R9,WHWI
        LCS     R1,1                    :no idea of which link and node though
        JAL     R9,WHWI
        JAL     R9,WHWI
LP8RB8  L       R6,LP8RS1               :get back bits still to do
        J       LP8RB2
LP8RB9  J       LEP1                    :end of takeover
       EI       :REBTAK

::*********************************************************************
::
::	SUBROUTINE:	CHKHST:
::	FUNCTION:	VERIFY THAT THE STATUS OF EACH HOST IS CORRECT
::	CALLING SEQ:	JAL	R7,CHKHST       CALLED FROM "LEP08"
::
::*********************************************************************

:       BEFORE PROCESSING TAKEOVER COMMANDS ON AN ISIS MACHINE, WE FIRST
:	NEED TO VERIFY THAT THE STATUS OF EACH HOST IS CORRECT.
:
:	CONSIDER THE FOLLOWING SITUATION:
:       IF HOST "A" GOES DOWN DURING A NODE CODE CRASH, ISIS TRIES
:       TO NOTIFY THE NODE CODE OF THE CHANGE IN STATUS, BUT THE NODE CODE
:	IS NOT THERE.
:       
:       THE NODE CODE DOESN'T CLEAR ALL THE HOST TABLES DURING RESTART, 
:       SO AFTER A NODE CODE RESTART, THE NODE CODE STILL HAS ALL
:       THE OLD HOST INFORMATION, AND DOESN'T KNOW THAT HOST "A" IS GONE.
:       HOW CAN THE NODE CODE CHECK IF ANY HOSTS WENT DOWN DURING A NODE
:	CODE CRASH?
:
:       DURING RESTART, NODE CODE SENDS AN "0F" COMMAND TO ISIS
:       REQUESTING HOST STATUS REPORTS FOR ALL HOSTS.  THIS WILL CAUSE
:       A SERIES OF "04" MESSAGES TO BE RETURNED TO THE NODE CODE.
:       THE NODE CODE WILL SET A FLAG, "HSTFLG", TO INDICATE
:       WHICH HOSTS IT HAS RECEIVED HOST STATUS REPORTS FOR FROM ISIS SINCE
:       THE LAST RESTART.  THEREFORE, FOR THOSE HOSTS IN THE HOST TABLE FOR
:	WHICH WE HAVE NOT RECEIVED HOST STATUS REPORTS FROM ISIS AFTER
:	RESTART, WE CAN BE SURE THOSE HOSTS ARE GONE, AND WE NEED TO NOTIFY
:	THE SUP OF THEIR "GONE" STATUS, AND CLEAR THE HOST ENTRY FOR THOSE
:	HOSTS.

        IF	(1-T2GATE)		:###EV

CHKHST  HS     0
        LIS    HN,1			:THE SECOND ENTRY TO HOST TABLE
					:SKIP THE FIRST ENTRY 0, SINCE IT IS
					:KERNEL HOST.
CHKENT  HS     0
        LHL    R1,HOSTN,HN,HN		:CHECK HOST TABLE FOR HOST ENTRIES
        JE     CHKNXT			:NO HOST AT THIS ENTRY, GO CHECK NEXT

:       YES, THERE IS A HOST AT THIS ENTRY.
:       CHECK IF WE RECEIVED A HOST STATUS REPORT FOR THIS HOST SINCE LAST
:       RESTART.
        TBT    HN,HSTFLG		:IS FLAG SET ?
        JN     CHKNXT			:YES,RECEIVED STATUS REPORT SINCE LAST 
					:RESTART, GO CHECK NEXT

:       NO STATUS REPORT RECEIVED SINCE LAST RESTART.
:       THIS HOST GONE, NOTIFY SUP OF STATUS, AND CLEAR ENTRY.
HSTGON  HS     0
       IF       1-SWTCHR                :CAN'T HAPPEN FOR A SWITCHER
        LIS    R0,HS.GNE		:STATUS IS "GONE"		###wjl
        LHI    R14,1180			:HOST STATUS REPORT WITHOUT TYPE FIELD
        OR     R14,R0			:COMBINE WITH STATUS
        LIS    R4,0			:INDICATING NO PID
        STB    R0,HSTAT,HN		:SAVE HOST STATUS

:	UPDATE HSTATN AND TIME OF UPDATE (USED FOR EXPANDED HOST STATUS)
        SLLS   R0,6			:MOVE HSTAT (BITS 6,7) TO HSTATN 
					:(BITS 0,1)
        LB     R1,HSTATN,HN		:GET HSTATN
        NHI    R1,0FF-EHSTTS		:STRIP OFF OLD STATUS BITS
        OR     R1,R0			:COMBINE WITH STATUS
        STB    R1,HSTATN,HN		:RESTORE
        JAL    R9,GMTCAL,,		:GET CURRENT GMT
        L      R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE
        SLLS   HN,1			:FORM FW INDEX INTO HOST TIME ARRAY
        ST     R0,HSTTIM,HN,HN		:STORE CURRENT TIME
        SRLS   HN,1			:RESTORE HN

:       SEND  STATUS REPORT TO SUP
        JAL    R10,SUPHS,,		:SEND [11,80+STATUS] TO SUP
        GL     SUPHS
        LHL    R0,HOSTN,HN,HN
        STH    R0,CRYSBF+2
        LB     R0,HSTAT,HN
        JAL    R8,CRYPTO,,
        HC     CRYE15			:CHANGE IN HOST STATUS 
     
:       DELETE THIS HOST FROM HOST TABLE
        LIS    R0,0        
        STH    R0,HOSTN,HN,HN		:CLEAR ENTRY
        STB    R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST
        STB    R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY
        STB    R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)
        STB    R0,HSTAT			:CLEAR HOST STATUS
        STB    R0,HSTATN		:CLEAR EXTENDED HOST STATUS
        SLLS   HN,1			:FORM FW INDEX INTO HOST TIME ARRAY
        ST     R0,HSTTIM,HN,HN		:CLEAR TIME ARRAY
        SRLS   HN,1			:RESTORE HN
        EI      :SWTCHR

:       CHECK NEXT HOST ENTRY
CHKNXT  HS     0
        AIS    HN,1			:BUMP HOST INDEX
        CLHI   HN,NHOSTS-1		:MORE HOST ENTRIES?  (EXCEPT KERNEL
					:HOST)
        JLE    CHKENT			:CHECK NEXT ENTRY		###cwc
        JR     R7			:DONE, RETURN

        EI	:(1-T2GATE)

	SUBTTL	LEP (LEP09 - Type 9:  Circuit building command)

::*********************************************************************
::
::	COMMAND:	LEP09:
::	FUNCTION:	PROCESS CIRCUIT-BUILDING REQUESTS (TYPE 9)
::
::*********************************************************************

LEP09	HS	0
	LR	R5,R2			:NEEDLE, SAVE SUP BUFF # AND GET
	JAL	R8,GFCBUF		:A BUFFER PAIR FOR NETWORK-BOUND DATA
	SKIPAD(OP8463)			:immed. return - out of buffers!###wjl
	LR	R7,R2			:+4 return, ok - SAVE IT IN R7

	SRLS	R2,1			:SET UP BUFTIM INDEX
	NHI	R2,-4
	L	R0,FASTC,,		:STORE FASTC TIME THAT
	ST	R0,BUFTIM,R2,		:NEEDLE ORIGINATES IN NODE

	LHI	R6,-2,LRC		:COPY OVER THE REST OF NEEDLE
	IF	EXPNDL
	LIS	R9,3			:counter to link count byte
	JAL	R10,LEP90A
	SIS	R6,1			:do this for the last byte
	NHI	R1,7F			:strip high order bit from link count
	STH	R1,CQNLK
	LIS	R9,4			:counter to first byte of FLAGS hw
	JAL	R10,LEP90A
:	Check for SNI list attached to needle.
:	If one is there we must write it to the SNIBUF buffer, instead
:	of to the network bound buffer.
SNICHK	HS	0
	SIS	R6,1			:we missed doing this above
	THI	R1,NF.SNI^-8		:test for presence of SNI list
	JE	LEP09A			:if no list, just copy the needle 
:	Note--We can assume that we have neither a TYMNET-I origination
:	nor termination if there is an SNI list present.

:	Needle has SNI list appended.  Copy needle up to the list into
:	the network-bound buffer, and then get a new buffer and copy
:	the SNI list into it for later processing.
:	We have now copied the buffer as far as the first byte of the
:	FLAGS halfword into the network-bound buffer.
	JAL	R8,GFCBUF,,		:get a free buffer for SNI list
	SKIPAD(OP8463)			:immed. return - out of buffers!###wjl
	ST	R2,SNIBUF		:+4, keep buffer number for later use
	LIS	R9,0B			:number HW's left, exclusive of node
					:list, up to start of user data field 
	AH	R9,CQNLK		:add 2 bytes per node in link list
	AH	R9,CQNLK
SNICH3	LR	R2,R5			:R5 has buffer # from sup
	JAL	R8,GCI
	LR	R2,R7			:put data into new net-bound buffer
	JAL	R8,WCI
	SIS	R6,1			:decrement needle length counter
	LR	R1,R1			:is it a data escape?
	JEFS	SNICH4
	SIS	R9,1			:dec to-username counter
	JGBS	SNICH3
	JFS	SNICH5

SNICH4	LR	R2,R5			:R5 has buffer # from sup
	JAL	R8,GCI		:read out the escaped character
	LR	R2,R7			:put data into new net-bound buffer
	JAL	R8,WCI
	SIS	R6,1			:decrement needle length counter
	SIS	R9,1			:dec count only by data--not by escapes
	JG	SNICH3
:	We have arrived at the user data field.
SNICH5	LR	R2,R5			:get from-sup buffer
	JAL	R8,GCI
	LR	R2,R7			:get net-bound buffer
	JAL	R8,WCI
	SIS	R6,1			:decrement needle length counter
	CLHI	R1,ASCCR+80
	JEFS	SNIC52
	CLHI	R1,ASCSMC+80
	JNBS	SNICH5
SNIC52	L	R9,SNIBUF		:prime for SNI list write
	LR	R2,R5
	JAL	R8,GCI
	CLHI	R1,80			:it's a pad char or first SNI header
	JN	SNIC62
	LR	R2,R7
	JAL	R8,WCI		:write pad char to net-bound buffer
	SIS	R6,1			:decrement needle length counter

:	We are now pointing to the SNI list.  
:	Write the SNI list into SNIBUF for later processing.
	JEFS	SNIC64			:if end of needle, go process(ERROR)
SNICH6	LR	R2,R5			:get byte from the needle buffer
	JAL	R8,GCI
SNIC62	LR	R2,R9			:write into the SNI buffer
	JAL	R8,WCI
	SIS	R6,1			:decrement needle length counter
	JGBS	SNICH6

SNIC64	LR	R2,R7			:need net-bound buffer in R2
	JFS	LEP90C
	EI	:EXPNDL

LEP09A	LR	R2,R5			:R5 HAS BUFFER # FROM SUP
	JAL	R8,GCI
	LR	R2,R7			:PUT DATA INTO NEW NET-BOUND BUFFER
	JAL	R8,WCI
	SIS	R6,1			:DECREMENT COUNT
	JGBS	LEP09A			:LOOP FOR ALL THE DATA
:	Next set up the net-bound buffer in the proper format
LEP90C	JAL	R9,GHWI			:REMOVE NODE #
	JAL	R8,GCI			:AND MESSAGE TYPE
	LIS	R1,0			:PRECEDE LINK CNT BY AN ESCAPE
	JAL	R8,WCD
	JAL	R8,WCD			:LEAVE A SLOT FOR BYTE CNT
	L	PRD,BB,R2,		:SAVE PTR TO SAME
	JAL	R8,WCD			:PRECEDE BYTE CNT BY AN ESCAPE
	LHI	R1,NEEDP		:INSERT NEEDLE POINT
	JAL	R8,WCD
	EXBR	R1,R1
	JAL	R8,WCD
	JAL	R8,CBCCT		:GET THE RESULTING BYTE COUNT
	STB	R1,0,PRD		:AND PUT IT AWAY
	STH	R2,CQNBUF		:SAVE THE NET-BOUND BUFF # IN CASE

:	NEEDLE HAS BEEN ASSEMBLED IN BUFFER, NOW PROCESS THE ORIGIN:

	L	R3,BB,R2,		:SET UP FOR PEEK ROUTINES
	JAL	R9,PHWI			:SKIP NEEDLE POINT
	JAL	R9,PHWI			:GET BYTE AND LINK COUNTS
	NHI	R1,7F			:SAVE LINK COUNT
	STH	R1,CQNLK
	JAL	R9,PHWI			:SAVE INVOICE #
	STH	R1,CQINV
	JAL	R9,PHWI
	STH	R1,CQINV+2
	JAL	R9,PHWI			:GET THE FLAGS
	LR	R7,R1			:SAVE NEEDLE FLAGS IN R7
	STH	R7,NEDFLG		:	AND IN MEMORY
	JAL	R9,PHWI			:SAVE REQUESTING NODE
	STH	R1,CQNODE
	JAL	R9,PHWI			:GET REQUESTING PORT#
LEP09B	STH	R1,CQPORT		:SAVE REQUESTING PORT
	LR	CHN,R1			:IT'S OUR ABSOLUTE CHAN #
	THI	R7,NF.REB		:IS THIS A REBUILD NEEDLE?
	JN	LEP09R			:YES, A REBUILD IS IN PROGRESS
	LHL	R0,CQNLK		:NO...ORIGINAL CIRCUIT. IS IT INTERNAL?
	JNFS	LEP09G			:NOT INTERNAL, SET UP REBILD PARAMETERS

:	INTERNAL CIRCUIT - SAVE DESTINATION HOST NUMBER TO TEST
:	FOR KERNEL HOST OR XRAY.
	LR	R6,R3			:SAVE BB	
	JAL	R9,PHWI			:NEXT HW IS DESTINATION HOST+8000
	NHI	R1,7FFF
	STH	R1,CQDHST		:INTERNAL CIRCUIT DESTINATION HOST #
	LR	R3,R6			:RESTORE BB (STILL POINTS TO DEST HST)
	IF	REBILD
	J	LEP09N			:NO HISTORY REQUIRED FOR INTERNAL CIRC
	EI	:REBILD

:	INITIALIZE THE VARIABLES ASSOCIATED WITH THE ORIGIN OF A
:	REBUILDABLE CIRCUIT.

LEP09G	HS	0
	IF	REBILD
	ST	R3,TRCSV1		:TEMP STORE,POINTS TO 1ST OF NODE LIST
	JFS	LEP9G2
LEP9G1	STH	R1,CQHOST		:SAVE IN CASE THIS IS THE BASE
LEP9G2	JAL	R9,PHWI			:READ NEXT NODE #
	THI	R1,8000			:IF NEG IT'S HOST #
	JEBS	LEP9G1			:POSSIBLY BASE
	LR	R3,R2			:HOST # IN R1, COMPUTE HIST BUFF #
	SRHLS	R3,1
	AI	R3,HBUFN
	STH	R7,RNFLAG,R3,		:SAVE NEEDL FLAGS, HOST, INVOICE
	STH	R1,RHOSTN,R3,
	LHL	R0,CQHOST
	STH	R0,RBASE,R3,
	L	R0,CQINV
	ST	R0,RINVC,R3,
	LR	R1,R7			:COMPUTE 2*BP CONSTANT* # LINKS-BP
	HSIZE(R1)			:COMPUTE SIZE BASED ON SPEED BITS###CY
	STH	R0,RHBSZ,R3,
	L	R3,TRCSV1		:RESTORE PEEK PTR
	EI	:REBILD

LEP09N	LHL	R6,IOTAB,CHN,CHN	:PORT IS SOME INTERNAL INTERFACE
	NHI	R6,-4			:CHECK THE PORT'S OUTBOUND BUFFER
	JE	LEP09F			:NO PERMTR TABLE ENTRY MADE YET,PROCEED
	LHL	R1,BF,6,		:THERE'S ALREADY A PERMUTER TABLE ENTRY
	CLHI	R1,LOGMIN		:..THE PORT HAD BETTER BE IN LOGIN MODE
	JL	LEP09U			:NOT IN LOGIN MODE,GENERATE DIAGNOSTICS
	CLHI	R1,LOGMAX
	JG	LEP09U			:NOT IN LOGIN MODE...CHANNEL IN USE ERR

LEP9N1	JAL	R9,LOGCLR		:CLEAR BUFF # FROM LOGGER LIST
	LCS	KD,1			:INDICATE T-II TERM

LEP09V	LR	R7,R2			:CHECK FOR 'EARLY ZAP' IN FROM-TERM BFR

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LP9DB1,,
	GL	LP9DB1
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	L	R3,BB,R6,		:SET UP FOR A PEEK
	JAL	R8,PCI
	SIS	R1,3			:BY TESTING FOR AN 03...
	JN	LEP9V2			:NO ZAPPER, APPEND WHATEVER DATA
	JAL	R8,PCI			:SOMETHING IS UP, LOOK AT NEXT BYTE
	CLHI	R1,ZAPPH&0FF		:IS IT A HARD ZAPPER?
	JEFS	LEP9V1			:YES, ZAP CIRCUIT
	CLHI	R1,ZAPPN&0FF		:OR A NON-GOBBLING ZAPPER?
	JN	LEP9V2			:NO, JUST PASS ON WHATEVER IT MAY BE

:	GOT AN 'EARLY ZAPPER' FROM AN ORIGINATING T-1 PORT -
:	MUST CLEAR THE CIRCUIT TO PREVENT DEAD ENDS, SO
:	SEND A NON-GOBBLING ZAPPER AFTER NEEDLE SO THAT THE
:	T-II DESTINATION WILL SEND A NEEDLE ACK TO SUP.

LEP9V1	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R3,1			:CASE # 1
	JAL	R14,LP9DB2,,
	GL	LP9DB2
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	LHI	R1,ZAPPN		:SEND A NON-GOBBLING ZAPPER
	JAL	R9,W2CI
	IF	(1-T2GATE)
	LIS	R0,0			:CLEAR PERMUTER ENTRY
	STH	R0,IOTAB,CHN,CHN
	EI	:(1-T2GATE)		:Gateway uses Zap Ack to clean up

	IF	T2GATE
	LHI	R1,-DISZFL,CHN		:F.T. buf must be dispatcher channel
	RBT	R1,DISFLG,,		:Possible 3E63 crash averted
	SBT	R1,DISZNK		:Prepare for ZAPV
	LR	R0,CHN			:Save absolute channel number
	LR	CHN,R1			:Use rel dispatcher port
	LHI	R1,09F00		:to clear for reuse
	JAL	R8,DIRMES
	LIS	R1,0
	STH	R1,BF,R6,		:Prepare for Zapv to return buffer
	LR	CHN,R0			:Restore absolute channel for crypto
	EI	:T2GATE

	IF	(1-T2GATE)		:Gateway must hold until Zap Ack clears
	SBT	CHN,ACP,,		:FREE THE CHANNEL'S ACP BIT
	LCS	R2,1			:SET NEGATIVE ACP ARRAY ALSO
	SR	R2,CHN
	SBT	R2,ACP,,
	LR	R2,R6			:RETURN ORIGINAL BUFFER
	JAL	R8,RFCBUF
	GL	RFCBUF
	EI	:(1-T2GATE)
	LR	R2,R7			:ALERT CRQ OF NEEDLE BY WRITING NEEDLE
	JAL	R9,CRQALT		:BUFFER NUMBER INTO BUFFER 0
	JAL	R8,CHFLNK,,		:GO FIND NEIGHBOR
	GL	CHFLNK
	SKIPAD(LEP9V3)			:immediate return, NOP		###wjl
	SKIPAD(LEP9V3)			:+4 return, NOP			###wjl
LEP9V3	EXHR	R0,CHN			:+8 ret, MOVE CHAN TO UPPER HW OF R0
	OR	R0,R3			:COMBINE WITH T-1 NEIGHBOR NUMBER
	JAL	R8,CRYPTO,,		:REPORT ZAPPER
	HC	CRYE18			:MESSAGE - EARLY ZAPPER
	J	BIDDRT,,		:EXIT - CAN DO NO MORE FOR THIS CIRCUIT

:	NO ZAPPER--APPEND DTA IN FROM-TERM BUFFER TO OUR NEW
:	NETWORK-BOUND BUFFER
LEP9V2	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R3,2			:CASE # 2
	JAL	R14,LP9DB2,,
	GL	LP9DB2
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	JAL	R9,APPEND		:NO ZAPPER, APPEND DATA
	GL	APPEND

	LR	R2,R6			:RETURN DATA (FROM-TERM) BUFFER
	JAL	R8,RFCBUF
	LR	R2,R7			:NET-BOUND IS NOW THE RELEVANT BUFFER
LEP09F	JAL	R9,CRQHCR		:BUILD HALF CIRC TO OUR REQUESTING PORT
	LHI	R1,-DISZFL,CHN		:IS REQUESTING PORT A DISPATCHER PORT?
	JL	LEP9F1			:NO, TOO LOW
	CLHI	R1,NDP			:TEST UPPER BOUND
	JGE	LEP9F1			:TOO LARGE, NOT A DISPATCHER PORT
	SBT	R1,DISBPV		:FOR A DISPATCHER PORT,FIRST RELIEVE BP
	LHI	R0,INXLIM		:AND GIVE IT XMIT CAPACITY
	STH	R0,DIXLIM,R1,R1

	IF	T2GATE
	RBT	R1,LOGING		:No longer in Log-in mode
::If IIX circuit - must send IIX reached ##/## host reply
	TBT	R1,GIIXCT
	JE	GASTRT
	LHL	R0,NEDFLG		:Get needle flags
	THI	R0,NF.SMC
	JEFS	GLPNSM			:Not smart
	LA	R4,IIXGRS,,		:Smart
	JFS	GLPSND
GLPNSM	LA	R4,IIXGRD,,
        GL      IIXGRD,IIXGRS
GLPSND	XHI	R2,4			:Flip to terminal bound buffer
	JAL	R9,BUFCAN		:send it
	XHI	R2,4			:Back to sup bound bffer
GASTRT  HS      0

::Circuit initiation  complete -  initiate accounting 
	IF	ACCT
	GL	AASTRT,GASTR1,AASWAP
	ST	R2,GASTOR
	LR	R3,CHN
	CLHI	R3,MNACHN
	JL	GASKIP
	CLHI	R3,MXACHN
	JG	GASKIP		:Range check on the absolute chan
	SHI	R3,MNACHN
	JAL	R9,AAMKPT,,	:Make pointer to the accounting block
        GL      AAMKPT
	L	R0,AAINV,R11	:Get previously stored  Invoice number
	ST	R0,ININV	:Store temporarily
	XI	R0,80000000	:Check high order bit (should be set)
	JL	GASKIP
	JAL	R8,GASTR1,,	:Initiate accounting
	NOP			:Need this 4 bytes for the normal return
	JAL	R10,AASWAP,,	:and swap invoice numbers
	L	R0,AAINV,R11	:R11 still hold accounting pointer, get inv#
	OI	R0,0C0000000	:Mark as origin circuit - do not report
	ST	R0,AAINV,R11
GASKIP	HS	0
	L	R2,GASTOR
	EI	:ACCT

	ELSE	:(1-T2GATE)		:Gate does not send back "needle eye"
	XHI	R2,4			:FLIP TO ISIS-BOUND BUFFER
	LHI	R1,NEEDE		:SEND NEEDLE EYE TO DISPATCHER
	JAL	R9,W2CI
:	SEND NEEDLE FLAGS TO CIRCUIT ORIGINATION WITH NEEDLE EYE. FLAGS
:	INDICATE IIX SMART CIRCUITS, ALSO INTERNAL CIRCUITS.
	LHL	R1,NEDFLG		:NEEDLE FLAGS, FROM CIRCUIT NEEDLE
	OHI	R1,NF.INT		:MAY BE UNNECESSARY, BUT SAFE
	LHL	R0,CQNLK		:IF ZERO LINKS, THIS IS INTERNAL CIRC
	JN	LEP9F0			:NOT INTERNAL - NF.INT LEFT SET
:	DON'T INDICATE INTERNAL CIRCUIT TO ISIS IF DESTINATION HOST
:	IS NOT A DISPATCHER HOST (I.E. KERNEL HOST OR XRAY)...
	LHL	R0,CQDHST
	CLHI	R0,HST0			:KERNEL HOST AS DESTINATION?
	JE	LEP9F0			:YES, DON'T INDICATE ISIS INTERNAL CIRC
	IF	TUNL 			:  				###AL
	LHI	R8,(NMTNLS-1)*4		:SEARCH IF TUNNEL HOST
LEP9T1	L	R9,TNLPTR,R8,
	CLH	R0,OHST,R9
	JEFS	LEP9F0			:TUNNEL HOST HAS NO INTERNAL CIRCUIT
	SIS	R8,4			:NEXT TUNNEL LINK?
	JGBS	LEP9T1
	EI	:TUNL
	XHI	R1,NF.INT		:INTERNAL CIRCUIT - RESET NF.INT
LEP9F0	JAL	R9,WHWI			:NEEDLE FLAGS TOWARD DISPATCHER INTERFC
	LHL	R1,CQINV
	JAL	R9,WHWI			:APPEND INVOICE #
	LHL	R1,CQINV+2
	JAL	R9,WHWI
	EI	:(T2GATE)	
	IF	EXPNDL
	L	R9,SNIBUF		:set up peek pointer into SNIBUF
	JE	LP9F15			:no buffer--no SNI list
	L	R3,BB,R9,
:	parse SNI list for valid syntax.  Zap if bad form. (implement)
LP9F24	JAL	R8,PCI			:get the SNI header
LP9F25	LR	R6,R3			:save running BB pointer,clobbrd in WCI
	JAL	R8,WCI			:write SNI header to the slot
	LR	R3,R6			:restore peek pointer
	LR	R0,R1			:lift out the type bits
	NHI	R1,0FF-SNITYP		:get which WHAT it is
	CLHI	R1,SNITRM		:is this the list terminator?
	JE	LP9F12			:if so, get out of here

	CLHI	R1,SNIUUN		:min valid value
	JL	LPSNIR			:crypto and exit
	CLHI	R1,SNILGC		:max valid value
	JG	LPSNIR			:crypto and exit

	NHI	R0,SNITYP		:R0 has type now--use for length
	JE	LP9F24			:type 0 is already processed
	SIS	R0,1			:is it type 1?
	JE	LPTYP1			:process type 1
	SIS	R0,1			:is it type 2?
	JE	LPTYP2			:process type 2
:	fall through to type 3
	JAL	R9,PCI			:get char count
	LR	R7,R1			:save it in R7
	LR	R6,R3			:save peek pointer 
	JAL	R8,WCI			:write to the slot
	LR	R3,R6			:restore peek pointer
LP3GET	JAL	R9,PCI			:get character
	LR	R6,R3			:save peek pointer
	JAL	R8,WCI			:write char to slot
	LR	R3,R6			:restore peek pointer
	SIS	R7,1			:decrement the count
	JGBS	LP3GET			:loop for next character
	J	LP9F24			:next list entry

LPTYP2	JAL	R9,PHWI			:peek at next halfword (strips escapes)
	LR	R6,R3			:preserve peek pointer
	JAL	R9,WHWI			:write escaped data to DISPI
	LR	R3,R6			:restore peek pointer
LPTYP1	JAL	R9,PHWI			:peek at next halfword
	LR	R6,R3			:preserve peek pointer
	JAL	R9,WHWI			:write escaped data to DISPI
	LR	R3,R6			:restore peek pointer
	J	LP9F24			:get next list entry

LPSNIR	LR	R0,R1			:HW0 and HW1 (ADDRESS) holds bad SNI
	ST	R7,CRYSBF		:put needle flags in HW2 and HW3
	JAL	R8,CRYPTO,,		:send wild card message to crypto log
	HC	CRYE71			:and ignore the rest of the mess

LP9F12	LR	R6,R2			:save R2 for a moment
	L	R2,SNIBUF		:get the SNI list holder
	JAL	R8,RFCBUF,,		:return to the free list
	LIS	R2,0
	ST	R2,SNIBUF		:zero the buffer cell for next pass
	LR	R2,R6			:restore R2
LP9F15	EI	:EXPNDL

	IF	T2GATE
	JFS	LEP9F1			:CRQALT done here to outbound circuit
	ELSE
	XHI	R2,4			:RESTORE BUFFER POINTER NET-BOUND###GT
	JFS	LEP9F2			:SKIP CRQALT (WILL BE DONE IN DISPI)
	EI	:T2GATE

LEP9F1	JAL	R9,CRQALT		:ALERT CRQ TO NEEDLE
LEP9F2	SRHLS	R2,3			:MAKE CRQ INDEX			###CY
	SBT	R2,CRQEND		:CIRCUIT ENDPOINT CREATED
	RBT	R2,REBTMO		:CLEAR CRQ TIMEOUT (SEE LEP11)  ###CY
	RBT	R2,REBTMI
	IF	REBILD
	LHL	R0,CQNLK		:INT CRQ NOT REBUILDABLE	###CY
	JE	BIDDRT,,		:				###CY
	SBT	R2,CRQBSY		:REBUILDABLE CIRCUIT IN USE
	RBT	R2,SQFTMO		:CLEAR REBUILD TIMEOUT
	SBT	R2,SQFTMI		:SET REBUILD TIMER
	SLHLS	R2,3			:RESTORE BUFFER INDEX		###GT
	JAL	R9,SNDFX0		:SEND SEQ FIX 0			###CY
	GL	SNDFX0
	EI	:REBILD

	J	BIDDRT,,		:ALL DONE

:	PROCESS ARRIVAL AT ORIGIN OF A REBUILD NEEDLE:

	IF	REBILD

LEP09R	JAL	R9,FNDCRQ,,		:REBUILD NEEDLE, LOCATE CIRCUIT
	GL	FNDCRQ
	SKIPAD(LEP09Z)			:CANNOT MATCH THE INVOICE NUMBER, ABORT
	LHL	R5,CQNFLG		:+4 return, RECOMPUTE HIST BUFF SIZE
	HSIZE(R5)			:BASED ON SPEED BITS		###CY
	STH	R0,RHBSZ,R7,		:R6, R7 WERE SET UP IN FNDCRQ
	JAL	R9,MERGE		:MERGE OUTBOUND AND HISTORY BUFFERS
	GL	MERGE
	LR	R2,R6			:CHECK MERGED OUTBOUND BUFF'S 1ST CHAR
        IF      REBTST                   :SHOULD WORK FOR ALL           ###sdw
        LHL     R1,BCT,R2,              :NO PEEK EMPTY BUFFER
        JE      LEP09S
        EI
	JAL	R8,PCIS			:IT MIGHT BE AN '02' OR '03' RESULTING

    IF 1-REBTST
					:FIX REBUILD SPLIT CHAR PROBLEMS###LSH
	SIS	R1,7		:FROM HIST-BUFF PRUNING,SPLIT CHAR PAIR ###LSH
	JGFS	LEP09S			:NOPE, IT'S > 7
    ELSE                        :new rebuild does not split char pairs
        SIS     R1,3            :sequence numbers do not split char pairs and
        JGFS    LEP09S          :since new logic returns exactly as many as
        AIS     R1,1            :seq num thus split pairs stay together.
        JLFS    LEP09S          :old logic returned convient number of bytes
   EI  :REBTST                   :which could split the pairs
	XHI	R2,4			:FIRST CHAR IS <= 7, NO REBUILD
	JAL	R9,ZAPHRD		:ZAP BACK TOWARDS THE ORIGINATING PORT
	J	LEP1			:AND GO TO NEXT SUP MESSAGE

LEP09S	LHL	R2,CQNBUF		:BUFFER WHERE NEEDLE ASSEMBLED
	XHI	R6,4			:R6=INBOUND BUFFER
	LHL	R1,VSEQN,R6,		:GET COUNT OF CHARS RECEIVED ON CIRC
	JAL	R9,WHWI			:...TELLS FAR END WHAT TO SEND NEXT
	LHL	R1,VSEQN+2,R6,		:LOWER HW OF 32-BIT NUMBER	###GT
	JAL	R9,WHWI
	XHI	R6,4			:FLIP TO OUTBOUND BUFFER...TELLS
	LHL	R1,XSEQN,R6,		: FAR END WHICH CHAR WE'LL SEND NEXT
	JAL	R9,WHWI			:WRITE IT INTO NEEDLE BUFFER
	LHL	R1,XSEQN+2,R6,		:LOWER HW			###GT
	JAL	R9,WHWI
	JAL	R8,CBCCT		:COMPUTE NEW NEEDLE BYTE COUNT
	STB	R1,0,PRD		:AND STORE IN APPROPRIATE NEEDLE FIELD

	JAL	R9,SNDFX0		:SEND A FIX0 BEHIND THE NEEDLE	###GT

	LR	R7,R2			:R7 SOURCE, R6 DEST
	L	R0,SEQN,R6,		:KEEP SEQN S,TRAIGHT
	ST	R0,SEQN,R7,
	JAL	R9,PREFIX		:PREFIX NEEDLE TO OB
	GL	PREFIX
	LHL	R2,CQNBUF		:RETURN NEEDLE BUFFER
	JAL	R8,RFCBUF
	LR	R2,R6
	JAL	R9,CRQALT		:ALERT CRQ OF NEEDLE
	SRHLS	R2,3			:CLEAR TIMEOUTS
	SBT	R2,CRQBSY		:RE-ACTIVATE REBUILD PROCESSING
	SBT	R2,CRQEND		:AND NOTE CREATION OF AN ENDPOINT
	RBT	R2,REBTMO
	RBT	R2,REBTMI
	RBT	R2,SQFTMO		:CLEAR REBUILD TIMEOUT BIT	###GT
	SBT	R2,SQFTMI		:SET REBUILD TIMEOUT COUNTER	###GT
	J	BIDDRT,,		:ALL DONE

	ELSE	:NOT REBILD

LEP09R	J	LEP09Z			:CANNOT REBUILD, NOT ENABLED. ABORT

	EI	:REBILD

LEP09U	HS	0
	ST	R2,LEPSV1		:TYPE 1 MESS TO SUP'S LOG
	JAL	R10,SWRCHU		:FORMAT CHANNEL IN USE NODE REPORT,
	GL	SWRCHU			: CIRCUIT LIFETIME NODE REPORT,
					: AND CRYPTOGRAM.
	L	R2,LEPSV1
	J	LEP09Z			:ABORT

LEP09H	HS	0			:NO SUCH NEIGHBOR
	ST	R2,LEPSV1		:SAVE BUFFER INDEX
:	SEND NODE REPORT FOR 'NO NEIGHBOR'
	LHI	R0,NR.NNE
	STH	R0,SUPMBF		:REPORT TYPE
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER NOT FOUND
	LHL	R0,NEDFLG
	STH	R0,SUPMBF+4		:NEEDLE FLAGS
	JAL	R10,SUP12		:SEND NODE REPORT TO SUPERVISOR LOG
	L	R2,LEPSV1		:RESTORE BUFFER INDEX TO RETURN IT...

LEP09Z	JAL	R8,RFCBUF		:ABORT - RETURN BUFFER
	LIS	R0,1
	AHM	R0,NC.LPE		:COUNT CIRCUIT BUILDING ERRORS IN LEP
	J	LEP1			:AND PROCESS NEXT COMMAND

::*********************************************************************
::
::	SUBROUTINE:	LEP90A:
::	FUNCTION:	Routine to copy # of chars (in R9) from buffer (in R5)
::			to buffer (in R7), and to return the R9th byte (in R1).
::			Resumes execution at LEP90C if data in R5 runs out.
::	CALLING SEQ:	JAL	R10,LEP90A
::	DESTROYED:	R1, R2, R6
::
::*********************************************************************

	IF	EXPNDL

LEP90A	LR	R2,R5			:R5 HAS BUFFER # FROM SUP
	JAL	R8,GCI
	LR	R2,R7			:PUT DATA INTO NEW NET-BOUND BUFFER
	JAL	R8,WCI
	LR	R1,R1			:check for escapes
	JEFS	LEP90B
	SIS	R9,1			:dec counter to FLAGS
	JLR	R10
	SIS	R6,1			:dec the needle length counter
	JG	LEP90A			:and go get another char
	J	LEP90C			:we should never get here

LEP90B	LR	R2,R5			:R5 has buffer # from sup
	JAL	R8,GCI			:get the escaped byte
	LR	R2,R7			:get net-bound buffer
	JAL	R8,WCI			:write in the escaped byte
	SIS	R6,1
	SIS	R9,1			:dec counter to FLAGS
	JLR	R10			:don't count escapes for this count
	SIS	R6,1			:decrement LRC count
	JG	LEP90A			:loop for all the data
	J	LEP90C			:needle transferred to net-buffer
					:we should never get here
	EI	:EXPNDL


        SUBTTL LEP (LEP0A - CCN Log II Command Channel Needle)

       IF       LOGII&(1-NCSLOT)        :only if log 2 with dispatcher


::****************************************************************
:
:       LEP0A   Receive CCN (log2 needle data) from supe and convert to
:               a needle that travels along.
:               This needle will be converted into one of the following:
:               a) the NCN needle (the needle with x.409 mos)  
:               b) a log I needle followed by x.409 MOs.  the log I is to
:                  allow backlevel NCs built circuit to LOG II destination.
:               c) a log I needle for log I hosts.
:               Logic is to leave needle in sup buffer and continually peek
:               at it to get whatever needed info.  When completed then we
:               return entire needle via one call to RTBFTS.  Logic has
:               significant differents between log I lep (lep09) since lep09
:               logic is leftover T-I and solo consat code that happens to
:               handle t-II needles.
:
:       Notes: the NEEDBD (032A) and NEEDTL (032B) only travel when there is
:       a needle head.  Thus, case B needles are followed by data which dest
:       has to know is needle body data.  (needle flag does indicate that).
:       All converted needles have username.  This makes it much easier if
:       the destination is XRAY.
:
::****************************************************************

LEP0A   SIS     LRC,2                   :LEP1 removed 2 byte len field
        L       R3,BB,R2,               :setup for peeks
        JAL     R9,PHWI                 :node number
        JAL     R9,PHWI                 :type (0A) and unused byte
        JAL     R9,PHWI                 :logical length
        LHI     R4,ID.CNF               :ccn flags id
        JAL     R7,X4PARS,,             :let parser find it
        SKIPAD(.LEPA1)                  :ccn error
        JAL     R9,PCIE                 :get byte of unused bits
        JAL     R9,PCIE                 :get only byte of bits we care about
        STB     R1,NEDFLG               :save it (bits in diff places than LG I
        LHI     R4,ID.PRT               :find origination port
        JAL     R7,X4PARC,,             :continue parse
        SKIPAD(.LEPA1)                  :error
        JAL     R7,X4GTNM,,             :get chn #
        LR      CHN,R4                  :port is rel dispi port
        AHI     R4,DISZFL
        STH     R4,CQPORT               :save absolute port #
:       since X4PARC stores everything except r6 and doesn't need r2,
:       we no longer must retain sup buf (it is in LEPINB if we need it)
        LHL     R2,DIOTAB,CHN,CHN       :get orig's buffer
        NHI     R2,-4                   :knock off any speed bits
        JE      .LEPA1                  :our buffer must still be there
        LHL     R1,BF,R2,               :port better be in login mode
        CLHI    R1,LOGMIN
        JL      .LEPA1                  :error, port lost
        CLHI    R1,LOGMAX
        JG      .LEPA1                  :error, port in use
        LR      R6,R2                   :logger buff is other direction
        JAL     R9,LOGCLR               :port no longer logging in
LEPA04  LHL     R1,BCT,R2,              :any data in from orig
        JE      LEPA07                  :no worry about waiting zappers
        L       R3,BB,R2,               :setup for peek
        JAL     R8,PCI                  :get first char in buff
        CLHI    R1,3                    :zap or gobbler?
        JN      LEPA07                  :no worries
        JAL     R8,PCI,,                :what type of char pair
        CLHI    R1,ZAPMAX&0FF           :zap family?
        JLE     LEP0AZ                  :it's a zap
        CLHI    R1,GOBBL&0FF            :gobbler?
        JNFS    LEPA07                  :not a worrisome 03 pair
                                        :remove gobbler since it has gobbled
        JAL     R8,GCI                  :everything a gobbler should gobble
        JAL     R8,GCI
        J       LEPA04                  :see if anything else after gobbler

LEPA07  JAL     R8,GFCBUF               :a buff to assemble needle
        SKIPAD(.LEPA1)
        LB      R0,NEDFLG               :see if must convert to LOG I needle
        THI     R0,L2F.N2               :term not log2
        JN      LEPA28                  :go convert it
        LHI     R4,ID.ISN               :find needle data (ISN MOs)
        JAL     R7,X4PARC,,
        SKIPAD(.LEPA0)                  :another ccn error
        XHI     R2,4                    :'other' direction for assemblin body
        JAL     R7,X4WTEL,,             :copies element in table to buff
        GL      X4WTEL
        JAL     R8,CBCCT                :size of body
        JAL     R9,WCDE                 :put len at start
        EXBR    R1,R1
        JAL     R9,WCDE                 :high byte
        XHI     R2,4                    :back to net direction
        LB      R0,NEDFLG               :time to test for nasty passthroughs
        THI     R0,L2F.PN               :convert needle head to log I
        JN      LEPA28                  :convert head
:       converted needle only has needle eye.  the rest follows as data
        XHI     R2,4                    :needle tail at end of buffer
        LHI     R1,NEEDTL               :append needle tail
        JAL     R9,W2CI
        XHI     R2,4                    :towards net direction
        LIS     R10,0                   :X4WTEL does a running cnt in r10
        LB      R0,NEDFLG
        THI     R0,L2F.IC               :intranode has no list of nodes
        JN      LEPA10
        LHI     R4,ID.NNL               :first in head in needle node list
        JAL     R7,X4PARC,,
        SKIPAD(.LEPA0)                  :bad needle form or something
        JAL     R7,X4WTEL,,
LEPA10  LHI     R4,ID.CNF
        JAL     R7,X4PARC,,             :followed by flags
        SKIPAD(.LEPA0)                  :has to be there, already found it
        LHI     R4,ID.NCF
        STB     R4,X4T.ID,R6            :the ID we want to write
        JAL     R7,X4WTEL,,
        LHI     R4,ID.TPC               :followed by throughput class
        JAL     R7,X4PARC,,
        SKIPAD(.LEPA0)
        JAL     R9,PCIE                 :and what is our TCLASS?
        STB     R1,NEDFLG+1
        JAL     R7,X4WTEL,,
        LHI     R4,ID.INV               :get invoice number
        GL      X4PARC
        JAL     R7,X4PARC,,
        SKIPAD(.LEPA0)
        JAL     R7,X4GTNM,,             :get and save it
        GL      X4GTNM
        ST      R4,CQINV
        JAL     R7,X4WTEL,,             :put it into head
        LHI     R4,ID.THS               :terminating host number
        JAL     R7,X4PARC,,
        SKIPAD(.LEPA0)
        JAL     R7,X4GTNM,,             :save term host
        STH     R4,CQHOST
        JAL     R7,X4WTEL,,             :add to needle head
        LIS     R0,0
        STH     R0,CQNLK                :init to no links (internal)
        LB      R0,NEDFLG               :intra node circuits have no links
        THI     R0,L2F.IC
        JN      LEPA18
        LHI     R4,ID.LNK
        JAL     R7,X4PARC,,             :number of links circuit takes
        SKIPAD(.LEPA0)
        JAL     R7,X4GTNM,,
        STH     R4,CQNLK                :save it for rebuild HSIZE
        JAL     R7,X4WTEL,,             :add it to head
LEPA18  LR      R1,R10                  :retrieve total head size
        JAL     R9,WCDE                 :write 2nd byte of len
        CLHI    R1,MO.LFM
        JL      LEPA1C                  :only requires one byte
        CLHI    R1,100                  :require len of len
        JL      LEPA1B
        EXBR    R1,R1
        JAL     R9,WCDE                 :write high byte
        LHI     R1,MO.LFM+2             :len of len
        JAL     R8,WCD
        JFS     LEPA1C                  :done with two byte long form
LEPA1B  LHI     R1,MO.LFM+1             :len of len
        JAL     R8,WCD
LEPA1C  LHI     R1,NEEDBD               :needle head followed by body
        JAL     R9,W2CI
        LHI     R1,MO.AC2+ID.NCH        :before len comes ID
        JAL     R8,WCD
        EXBR    R1,R1
        JAL     R8,WCD
        LHI     R1,NEEDHD
        JAL     R8,WCD
        EXBR    R1,R1                   :write needle head (0329)
        JAL     R8,WCD
        JFS     LEPA30

:       here to make a log I needle (for log I term and log I passthrough)
LEPA28  JAL     R9,LEPACV               :convert needle

:       come here when LOG II needle head or translated needle is in
:       buffer.  Needle body, if present, is in buffer's other direction
:       and any user data is in original buffer (in DIOTAB).

LEPA30  LR      R7,R2                   :set current buffer as destination
        LR      R6,R2                   :needle body was stored in other side
        XHI     R6,4                    :looking for needle body
        JAL     R9,APPEND,,             :append if anything there
        LHL     R6,DIOTAB,CHN,CHN       :do userdata
        NHI     R6,-4                   :knock of speed bits
        JAL     R9,APPEND,,             :copy any userdata to end
        LR      R2,R6                   :no longer need source buff
        JAL     R8,RFCBUF
        LR      R2,R7                   :new buff is now for the circuit
        AHI     CHN,DISZFL              :make real chn number
        JAL     R9,CRQHCR,,             :build with new buff
        SHI     CHN,DISZFL              :back to rel dispi chn #

        LR      R6,R15                  :restore parse register
        LR      R2,R7                   :time to write Logon success
        LHI     R1,LG2EYE               :write our log 2 needle eye
        XHI     R2,4                    :towards dispatcher
        JAL     R9,W2CI

:       internal circuit indication on LGSC tells dispatcher that circuit
:       goes between two other slots and dispatcher will disconnect cir from
:       NC.  circuits to hst0 are to receive dispatcher service like internode
:       circuits so don't tell ISIS that it is intranode.
        LIS     R1,1                    :write if internal or not (1=internal)
        LHL     R0,CQHOST               :if internal host, not intra node
        CLHI    R0,HST0
        JEFS    LEPA33                  :circuit will still go to NC
        LHL     R0,CQNLK                :no links means internal
        JEFS    LEPA34                  :followed by a zero is not internal
LEPA33  XHI     R2,4                    :needle heads towards net
        JAL     R9,CRQALT,,             :tell CRQ we have a needle
        XHI     R2,4                    :back towards dispi
        LIS     R1,0                    :not internal
LEPA34  JAL     R9,WCIE
        LHI     R4,IDLGSC               :find logon successful indication
        JAL     R7,X4PARC,,
        SKIPAD(.LEPA0)                  :format error
        LR      R1,R0                   :prepare to write len of entire msg
        AIS     R1,2                    :len of id and its len
        CLHI    R0,MO.LFM               :two byte len
        JLFS    LEPA37
        AIS     R1,1
        CLHI    R0,100                  :three byte len
        JLFS    LEPA37
        AIS     R1,1
LEPA37  JAL     R9,WHWI                 :write a HW of len
        JAL     R7,X4WTEL               :write element LGSC
        LR      R4,R2                   :save chn buffer
        LHL     R2,LEPINB               :get supe buffer
        LR      R0,LRC                  :size of CCN (we have finished with it)
        JAL     R9,RTBFTS               :kill CCN
        LR      R2,R4                   :back to circuit's buf
        SRHLS   R2,3                    :make it for bit array
        SBT     R2,CRQEND               :termination
        RBT     R2,REBTMO               :clear stupid timouts
        RBT     R2,REBTMI               :(timout logic not needed for T-II)
        SLHLS   R2,3                    :restore R2 to net direction
       IF       REBILD
        LHL     R0,CQNLK                :not for internal circuits
        JE      LEPA40
        SRHLS   R2,3                    :make into bit array index again
        SBT     R2,CRQBSY               : rebuildable needle
        RBT     R2,SQFTMO               :set rebuild timout (for ACK to FX0)
        SBT     R2,SQFTMI
        SLHLS   R2,2                    :make it for storing rebuild stuff
        AI      R2,HBUFN                :make it the history buffer
        L       R0,CQINV                :get invoice number
        ST      R0,RINVC,R2,            :save it
        LHL     R0,CQHOST               :get dest host
        STH     R0,RHOSTN,R2,
        JAL     R7,LPAFLG               :get log I flags
        STH     R4,RNFLAG,R2,           :save flags in log I format
        JAL     R7,LEPADN               :now find dest node
        STH     R4,RBASE,R2,
        LB      R1,NEDFLG+1             :get speed bits
        SLHLS   R1,4                    :move to where HSIZE expects em
        HSIZE(R1)
        STH     R0,RHBSZ,R2,            :completed history stuff
        SI      R2,HBUFN                :make it back buff with needle
        SLHLS   R2,1                    :above shift left of 2 cancels right 3
        JAL     R9,SNDFX0
       EI       :REBILD

:       setup dispi stuff
LEPA40  SBT     CHN,DISBPV              :release backpressure
        LHI     R0,INXLIM               :XMIT capability
        STH     R0,DIXLIM,CHN,CHN
:       and now done!
        J       BIDDRT,,

:       Gobble needle and return whatever we started
.LEPA0  JAL     R8,RFCBUF               :return buffer
.LEPA1  LHL     R2,LEPINB               :gobble bad needle
        JFS     .LEPA2
.LEPA3  JAL     R8,GCI
.LEPA2  SIS     LRC,1
        JGBS    .LEPA3                  :gobble bad needle
        LIS     R0,1
        AHM     R0,NC.LPE               :count another error
        J       LEP1


:       LEPACV  converts LOG2 CCN into log I needle.  Does translation
:               for termnotlog2 (total coversion) and for passthroughnotlog2
:               (log I head to build circuit and log2 body so term host gets
:               ISN).
:       Translates both CCN needle and NCN (NCN head only).  Little
:       trick of using bit 08 (log i term)  of NEDFLG to determine whether to 
:       append username.  (only for case of CCN since NCN has username in body)
:
:       both expect the log2 needle to be in parsed form with r6 setup
:       by X4PARS.  Also, needle written into buffer in R2.
:       trashes r0,r1,r3,r4,r7,r8.  R6 will be different but still
:       will point inside X4PARC table.

LEPACV  ST      R9,LEPAS1               :save it
        LHI     R1,NEEDP
        JAL     R9,W2CI
        LIS     R1,0                    :write len
        JAL     R9,W2CI                 :give room for len
        L       R3,BE,R2,               :where to write len
        ST      R3,LEPAS2               :save loc of len
        JAL     R8,WCI                  :escape link count
        LHI     R4,ID.LNK               :get number of links
        JAL     R7,X4PARC,,
        SKIPAD(LGCV04)
        JAL     R7,X4GTNM               :get the number
        JFS     LGCV06
LGCV04  LIS     R4,0
LGCV06  STH     R4,CQNLK                :save it
        LR      R1,R4
        OHI     R1,80                   :80+number of links
        JAL     R8,WCI                  :write number of links
        LHI     R4,ID.INV               :now invoice number
        JAL     R7,X4PARC,,
        SKIPAD(.LEPA0)                  :fatal error if can't make em pay
        JAL     R7,X4GTNM               :get the invoice number
        EXHR    R1,R4
        JAL     R9,WHWI                 :write high HW of invoice number
        LR      R1,R4                   :then low HW
        JAL     R9,WHWI
        JAL     R7,LPAFLG               :get log2 flags into log I form
                                        :hw of flags returned in r4
        NHI     R4,@NF.LG2              :assume dest not log 2
        LB      R1,NEDFLG               :get CCN flags to see if dest log 2
        THI     R1,L2F.N2               :destination log 2?
        JNFS    LGCV08                  :not a log ii dest
        OHI     R4,NF.LG2               :ISN data follows needle
LGCV08  LR      R1,R4                   :write converted needle flags
        JAL     R9,W2CI
        LHI     R1,MACHNM               :requesting node is known
        JAL     R9,WHWI                 :write it
        LR      R1,CHN                  :orig port
        AHI     R1,DISZFL               :expect it as relative dispatcher port
        JAL     R9,WHWI                 :write origination port
        ST      CHN,LEPAS3              :save chn# for a free reg
        LHL     R5,CQNLK                :get number of links
        JE      LGCV11                  :no node numbers to write
        LHI     R4,ID.NNL
        JAL     R7,X4PARC               :find it
        SKIPAD(.LEPA0)                  :has to be there
LGCV10  JAL     R9,PCIE                 :get id of octet number
        JAL     R9,PCIE                 :get len of node number
        LR      R0,R1
        JAL     R7,X4GTNM               :get this node # into r4
        LR      R1,R4                   :move to write it
        lr      r15,r3                  :save r3 for pcie
        JAL     R9,WHWI                 :escape if necc
        lr      r3,r15                  :restore r3 for pcie
        SIS     R5,1                    :couunt of how many till last
        JG      LGCV10
LGCV11  LHI     R4,ID.THS               :find term host
        JAL     R7,X4PARC
        SKIPAD(LGCV15)                  :might not be there on rebuild needle
        JAL     R7,X4GTNM  
        STH     R4,CQHOST
        LR      R1,R4
        OHI     R1,8000                 :lead bit always set
        JFS     LGCV16
LGCV15  LHI     R1,8080                 :value of null host
LGCV16  JAL     R9,WHWI                 :write term host
        JAL     R8,WCI                  :write whatever, we just want location
        L       R5,BE,R2,               :where to write CCT, hdx
        LHI     R4,ID.CCT               :now comes CCT
        JAL     R7,X4PARC
        SKIPAD(LGCV18)                  :who knows if rebuild has this
        JAL     R7,X4GTNM
        JFS     LGCV19
LGCV18  LIS     R4,0                    :it had no CCT
LGCV19  OHI     R4,0C0                  :always with those bits
        STB     R4,0,R5                 :save it
        LHI     R4,ID.HDX               :and set hdx bit
        JAL     R7,X4PARC
        SKIPAD(LGCV20)
        JAL     R9,PCIE                 :get indication
        LR      R1,R1
        JEFS    LGCV20                  :not HDX
        LB      R1,0,R5                 :set HDX bit
        OHI     R1,NF.HDX
        STB     R1,0,R5                 :save it with HDX set
::  while x40 bit of second byte of user flags is documented as being the
::  collect call indication, node code versions prior to 5.30 use the bit
::  to support a different type of LOG I needle sent by supes sometime prior
::  to 1983.  thus the x40 bit cannot be used for collect call.         ###sdw

LGCV20  LHI     R1,80                   :2nd byte of user flags
        JAL     R8,WCI
        LHI     R4,ID.OHS               :get requesting host
        JAL     R7,X4PARC
        SKIPAD(LGCV26)
        JAL     R7,X4GTNM
        LHI     R1,8000,R4              :
        JFS     LGCV27
LGCV26  LHI     R1,8080                 :orig host unknown
LGCV27  JAL     R9,WHWI                 :write OHOST

:       now append username, remember to set chars with mark parity.
:       add null (80) so username len ends up even.  Supe sends it in
:       uname field for log I dest but not for log i passthrough, which
:       doesn't make much sense.
        LHI     R4,ID.UNM               :get username it
        JAL     R7,X4PARC
        SKIPAD(LGCVEX)
        LR      R5,R0                   :copy to dec till get to end
        LR      R6,R5			:even/odd indicaton
        LR      R4,R3                   :Setup PCIER4
LGCV30  JAL     R9,PCIER4               :get the char
        GL      PCIER4
        OHI     R1,80
        JAL     R8,WCI
        SIS     R5,1
        JGBS    LGCV30                  :do all logon chars
        THI     R6,1			:odd len?
        JEFS    LGCVEX                  :nope, all done
        LHI     R1,80			:get null
        JAL     R8,WCI			:and write it

LGCVEX  JAL     R8,CBCCT                :how big did needle end up?
        L       R4,LEPAS2               :where len byte goes
        STB     R1,0,R4
        L       CHN,LEPAS3              :restore chn
:       patch to put the data in the password MO immediately after the
:       needle when the destination is LOG I.                           ###sdw
        LB      R0,NEDFLG               :First make sure dest is LOG I
        THI     R0,L2F.N2               :bit is 1 if dest log I
        JE      LGCVP9                  :dest log II, nothing to do
        LHI     R4,ID.PWD               :and if password present
        JAL     R7,X4PARC,,
        SKIPAD(LGCVP9)                  :not there so exit
        LR      R6,R0                   :get length
        LR      R4,R3                   :setup PCIER4
LGCVP2  JAL     R9,PCIER4,,             :get a char
        JAL     R9,WCIE                 :write it
        SIS     R6,1
        JGBS    LGCVP2
        LHI     R1,8D                   :supe striped CR off
        JAL     R8,WCI
LGCVP9  L       R9,LEPAS1
        JR      R9

:       LEPADN  finds the destination node in the needle node list
:               links on R7 and trashes the usual (0-9 except r2,chn)

LEPADN  ST      R7,LEPAS1               :save link
        ST      R5,LEPAS2               :save chn#
        LHI     R4,ID.NNL
        JAL     R7,X4PARC
        SKIPAD(LEPADX)                  :jump to exit
        LHL     R5,CQNLK                :number of links in list
LEPAD2  JAL     R9,PCIE                 :get id of octet string
        JAL     R9,PCIE                 :get len of number
        LR      R0,R1                   :save len
        JAL     R7,X4GTNM               :get node number
        SIS     R5,1
        JGBS    LEPAD2
LEPAD3  L       CHN,LEPAS2
        L       R7,LEPAS1
        JR      R7

LEPADX  LIS     R4,0                    :mark that node list found
        JBS     LEPAD3

       EI       :LOGII(1-NCSLOT)


:       LPAFLG  does the rather messy task of converting all of LOG 2's
:               flags into the flags field normally present after the
:               invoice number.  Must have R6 setup from X4PARS.  Needed
:               for reporting rebuild stuff to supe and for CRQ parallel
:               processing of LOGI and LOGII needles.
:               trashes r0-r9 except r2 and r5.  r6 will be changed but
:               still setup for X4PARC.
:               Returns bits for both CCN and NCN
:               returns the bits in R4

       IF       LOGII
        GL      X4GTNM,X4PARC

LPAFLG  ST      R7,LEPAS4               :save link
        ST      CHN,LEPAS5              :save chn
        LHI     R5,8080                 :these always set
        LHI     R4,ID.CNF               :CCN flags?
        JAL     R7,X4PARC  
        SKIPAD(LPAF02)
        JFS     LPAF03                  :found CCN flags so process it
LPAF02  LHI     R4,ID.NCF               :then try to find NCN flags
        JAL     R7,X4PARC
        SKIPAD(LPAF06)                  :neither flags found
LPAF03  JAL     R9,PCIE                 :get byte of unused bits
        JAL     R9,PCIE                 :get bits
        THI     R1,L2F.CC               :command circuit
        JEFS    LPAF04
        OHI     R5,NF.CMD               :set command bit
        OHI     R5,NF.PRI               :command circuits are priority too
LPAF04  THI     R1,L2F.RC               :rebuild circuit?
        JEFS    LPAF06
        OHI     R5,NF.REB               :yes
LPAF06  LHI     R4,ID.TPC               :get speed bits
        JAL     R7,X4PARC
        SKIPAD(LPAF10)                  :if not there then 0
        JAL     R7,X4GTNM
        NHI     R4,3                    :only have room for 2 bits
        SLLS    R4,4                    :speed bits are 0030
        OR      R5,R4                   :add em in
LPAF10  LHI     R4,ID.RIX               :iix capable?
        JAL     R7,X4PARC
        SKIPAD(LPAF16)
        JAL     R9,PCIE
        LR      R1,R1
        JEFS    LPAF16
        LHI     R0,NF.SMC               :iix indicator flag
        OR      R5,R0
LPAF16  LHI     R4,ID.IRC               :handle IRC
        JAL     R7,X4PARC
        SKIPAD(LPAF20)
        JAL     R7,X4GTNM
        NHI     R4,0F                   :only four bits for IRC
        SLLS    R4,0A
        OR      R5,R4
LPAF20  LHI     R4,ID.COS               :batch or interactive?
        JAL     R7,X4PARC               :find it
        SKIPAD(LPFA28)
        JAL     R7,X4GTNM
        THI     R4,L2F.BT               : values 0-3 not batch, 4-7 are batch
        JNFS    LPFA28
        LHI     R4,NF.BAT               :batch circuit request
        OR      R5,R4                   :add in batch type
LPFA28                                  :for any other flag finding
        LR      R4,R5                   :return flags in R4
        L       CHN,LEPAS5
        L       R7,LEPAS4
        JR      R7

       EI       :LOGII

       IF       LOGII&(1-NCSLOT)


:       LEP0AZ  handles case of got CCN after user zapped circuit.
:               Logic is very simple.  Toss CCN then call ZAPV to clear
:               out circuit (only 1/2 exists).

LEP0AZ  LIS     R0,0
        STH     R0,BF,R2,               :port no longer in logon mode
        XHI     R2,4                    :zap towards supe direction
        JAL     R9,ZAPV,,               :clear out circuit
        LHL     R2,LEPINB
        LR      R0,LRC                  :toss CCN
        JAL     R9,RTBFTS
        J       BIDDRT,,                :and exit

       ELSE     :not LOGII
LEP0A   EQ      LEPXT	                :legal only if LOGII		###wjl
       EI       :LOGII


	SUBTTL	LEP (LEP0B - Type B:  Circuit trace request)

::*********************************************************************
::
::	COMMAND:	LEP0B:
::	FUNCTION:	PROCESS TRACE REQUEST (TYPE 0B)
::
::*********************************************************************

LEP0B	HS	0
	JAL	R9,GHWI			:DISCARD NODE NUMBER,
	JAL	R9,GHWI			:AND TYPE
	LI	R1,03008001		:INIT TRACE HEADER
	ST	R1,LEPMES
	JAL	R9,GHWI			:HOST #
	STH	R1,LEPMES+4
	JAL	R9,GHWI			:PORT #
	STH	R1,LEPMES+6
	LHI	R1,MACHNM
	STH	R1,LEPMES+8
	LIS	PRD,0A			:TRACE NEEDS THIS INITIALIZED

	LHL	R1,LEPMES+4		:RECOVER HOST #
	IF	SUPER
	LHI	CHN,SUPZFL
	CI	R1,0FFFE
	JE	LEP0B1
	EI	:SUPER
	THI	R1,4000			:IF THE 4000 BIT IS NOT SET...
	JE	LEP0B3			:...R1 CONTAINS A HOST NUMBER, ELSE
	NHI	R1,3FFF			:R1 IS A T-1 NEIGHBOR. STRIP 4000 BIT
	LIS	CHN,0
	JAL	R9,FNDLNK,,		:GO FIND THE T-1 NEIGHBOR
	SKIPAD(LEP0B2)			:NGHBR NOT FOUND, REJECT TRACE REQUEST
	LHL	CHN,LKZFKN,KN,KN	:+4 return
LEP0B1	AH	CHN,LEPMES+6		:CHN=ABSOLUTE PORT #
LEP0B2	NHI	R1,7FFF
	JAL	R10,TRACE		:TRACE WIL REJECT REQUEST IF CHN=0
	J	LEP1			:DONE

LEP0B3	NHI	R1,3FFF			:HERE TO TRACE FROM A HOST ON THE NODE
	JEFS	LEP0B7			:HOST = 0 SERVES AS A WILD-CARD HOST #
	LIS	CHN,0			:CLEAR CHN IN CASE WE REJECT TRACE REQ
	JAL	R9,FNDHST		:MAKE SURE THE HOST EXISTS
	GL	FNDHST
	SKIPAD(LEP0B2)			:CAN'T FIND HOST, REJECT TRACE REQUEST
	LHI	CHN,KERZFL		:+4 return, BASE = FIRST KERNEL PORT
	LR	HN,HN			:IF FNDHST RETURNS WITH INDEX = 0...
	JE	LEP0B1			:IT IS THE KERNEL (HOST0)
LEP0B7	HS	0			:				##TZ
	LHI	CHN,DISZFL		:IT'S A DISPATCHER PORT		##TZ
	J	LEP0B1

	SUBTTL	LEP (LEP0C - Type C:  Sleeping pills)

::*********************************************************************
::
::	COMMAND:	LEP0C:
::	FUNCTION:	PROCESS PILLS  (TYPE 0C)
::
::*********************************************************************

LEP0C	HS	0
	JAL	R9,GHWI			:DISCARD NODE # AND TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:GET FIRST BYTE (SUP # + 80)
	IF	SUPER
	IF	SNRING
	LR	R8,R1			:NEW INTERFACE, REPORT OF SENDING SUP #
	NHI	R8,7F
	ELSE	:NOT SNRING
	LIS	R8,1			:OLD INTERFACE RECOGNIZES SUP 1 ONLY
	EI	:SNRING
	LIS	R0,0
	LHL	R1,TVRSTT		:IS SUP FROZEN?
	SIS	R1,3
	JE	BIDDRT,,		:SUP FROZEN IGNORE
	IF	SNRING
	JAL	R9,SIROOM,,		:ROOM IN SUP INPUT RING?
	CLHI	PRC,8
	JLE	BIDDRT,,		:THIS SUP A HEAVY SLEEPER...
	ELSE	:NOT SNRING
	LHL	PRD,NISI,,		:SEND PILL
	NHI	PRD,SUPBSZ-1
	EI	:SNRING
	STH	R0,SIB,PRD,		:CHANNEL 0
	AIS	PRD,2
	IF	SNRING
	JLFS	LEP0C1
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
	ELSE	:NOT SNRING
	NHI	PRD,SUPBSZ-1
	EI	:SNRING
LEP0C1	LIS	R0,2			:LRC = 2
	STH	R0,SIB,PRD,
	AIS	PRD,2
	IF	SNRING
	JLFS	LEP0C2
	SHI	PRD,SUPBSZ
	ELSE	:NOT SNRING
	NHI	PRD,SUPBSZ-1
	EI	:SNRING
LEP0C2	LHI	R0,8000,R8		:PILL WITH SENDING SUP NUMBER
	STH	R0,SIB,PRD,
	IF	SNRING
	LIS	PRD,6			:6-BYTE RECORD
	AH	PRD,NISI,,		:INCREMENT SIB LEAD POINTER
	JLFS	LEP0C3
	SHI	PRD,SUPBSZ		:NEGATIVE RING WRAP
LEP0C3	STH	PRD,NISI,,		:STORE NEW SIB RING INDEX
	ELSE	:NOT SNRING
	LIS	R0,6			:INDEX IN POINTER
	AHM	R0,NISI,,
	EI	:SNRING
	EI	:SUPER
	J	BIDDRT,,		:IF NOT A SUP'S BASE, JUST EXIT

	SUBTTL	LEP (LEP0D - Type D:  Message for ports in login mode)

::*********************************************************************
::
::	COMMAND:	LEP0D:
::	FUNCTION:	PROCESS LOGIN MESSAGES
::
::*********************************************************************

:	Format of messages is :
:	[node#],[0D,n+flags],[port#],<# chars>,<char>,...,<char>

LEP0D	HS	0
	JAL	R9,GHWI			:DISCARD NODE # AND TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:SAVE FIRST BYTE
	LR	R7,R1
	JAL	R9,GHWI			:ABSOLUTE PORT#
	NHI	R1,7FFF			:strip HOB of port # (ANITAB index)
	LR	CHN,R1			:port # becomes CHN
	LR	R6,R2			:SAVE SUP BUFF #
	LHL	R2,IOTAB,CHN,CHN	:MAKE SURE THAT THE PORT IS THERE
	NHI	R2,-4

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LPDDB1,,
	GL	LPDDB1
	LM	R0,REGST		:restore regs		###sdw
	LR	R2,R2
	EI	:LPGDBG

::Departure for Gateway logins
	IF	T2GATE
	JN	GLP0DD,,
        GL      GLP0DD                  :moved to be with other gateway stuff
	ELSE
	JN	LEP0DD			:YES, PROCEED
	EI	:T2GATE
LEP0D4	LR	R2,R6			:NO CIRCUIT OR CKTKEY DOESN'T MATCH
	CLHI	R7,10			:IS THERE ADDIT STUFF? (R7 is n+flags)
	JN	LEP1			:NO, GO BYE
	JAL	R8,GCI			:CHAR COUNT
	LR	R1,R1			:is it escaped?
	JNFS	LEPD10			:non-zero means not escaped
	JAL	R8,GCI			:if escaped, second byte is the count
LEPD10	LR	LRC,R1			:count becomes log record count
LEPD20	JAL	R8,GCI			:read out a data byte
	SIS	LRC,1			:	and decrement counter
	JGBS	LEPD20			:go while we have it
	J	LEP1			:return when we don't no more

       IF       1-T2GATE        :this section not for gateway

LEP0DD	XHI	R2,4			:flip to port bound buffer(.ALBUF+4)
	LHI	R1,TILIM		:SEND 03-12  PAIR TO PORT IN LOGIN
	JAL	R9,W2CI
	LR	R1,R7			:GET CODE BYTE, e.g n + flags
	NHI	R7,1F			:mask down to five bits in work reg 7
	TBT	R7,EXLGMG		:EXPAND LOGIN MESSAGE ?
	JE	LEP0DE			:NO
	SHI	CHN,DISZFL		:RELATIVE CHANNEL NO.
	TBT	CHN,DISELS		:CHECK ELS BIT - IF SET, NO TEXT
	JN	LEP0DF			:NO TEXT
	J	LEP0D3			:SEND TEXT
LEP0DE	CLHI	R7,10			:NO
	JEFS	LEP0DG			:IF 10, THERE'S ADDITIONAL STUFF
LEP0DF	JAL	R8,WCI			:WRITE CODE STATUS BYTE IN TO PORT
	J	LEP0DA
LEP0DG	XHI	R1,18			:MAKE IT INTO A $2 XXX01000
	JAL	R8,WCI

       EI       :1-T2GATE

::A reentry point for Gateway log-ins
GLPEI4	LR	R7,R2			:PORT INPUT BUFF SAVE(.ALBUF+4, solocs)
	LR	R2,R6			:BYTE COUNT OF STRING FROM R6(LEP buff)
	JAL	R8,GCI			:GET (ESCAPED) LENGTH
	LR	R1,R1			:is it escaped?
	JNFS	LEPD30
	JAL	R8,GCI			:else second byte is count
LEPD30	LR	LRC,R1			:write count to buffer (R6)
LEP0DB	LR	R2,R6			:R6 is LEP buffer
	JAL	R8,GCI			:move string from LEP buffer to port
	LR	R2,R7			:R7 is port input buffer
	JAL	R8,WCI
	SIS	LRC,1
	JGBS	LEP0DB
	LR	R2,R6			:KLUDGE TO CIRCUMVENT SUP BUG
	LH	R1,BCT,R2,		:INSURE BUFFER NOT EMPTY
	JEFS	LEP0D1
	JAL	R8,GCI
	CLHI	R1,80			:REMOVE FOLLOWING NULL, IF ANY
	JEFS	LEP0D1
	JAL	R8,WCD
LEP0D1	LR	R2,R7
::Gateway log-on response processing reenters here
LEP0DA	HS	0			:INDICATE THAT SUP HAS SAID 'GO AHEAD'
	XHI	R2,0004			:GET OPPOSITE BUFFER
	LH	R1,BF,R2,		:GET CURRENT BUFFER FLAG
	CLHI	R1,LOGMIN		:VERIFY IN LOGIN MODE
	JL	LEP1
	CLHI	R1,LOGMAX
	JG	LEP1			:OUT OF RANGE
	OHI	R1,LOGSUP		:SET SUP 'OK' BIT
	STH	R1,BF,R2,
	J	LEP1			:ALL DONE

LEP0D3	HS	0			:EXPAND CANNED MESSAGE
	SHI	R7,13			:FIRST MESSAGE IS 13X
	LHL	R7,EXLGTB,R7,R7		:GET TABLE ENTRY		###CY
      IF	NAD68
	LA	R7,SEG1,R7,		:SEG1 in 68K environment	###wjl
      ELSE	:Engine
	LA	R7,SEGD,R7,             :changed to seg D   9/27/87     ###sdw
      EI	:NAD68
	LB	LRC,0,R7
	NHI	R1,0E0			:MSG TYPE="SEND NO MESSAGE"(CONTINUE)
	OHI	R1,8			:EMPTIERS EXPECT BIAS OF 8
	JAL	R8,WCI
	LHI	R1,8D			:KLUDGE TO SIMULATE SUP MESSAGE WITH
	JAL	R8,WCI			:EXTRA CARRIAGE-RETURN
LEP0D2	LB	R1,1,R7			:GET CHARACTER
	JAL	R8,WCI
	AIS	R7,1			:NEXT CHAR.
	SIS	LRC,1
	JGBS	LEP0D2			:LOOP
	LHI	R1,8D8A			:INSERT TRAILING CARRIAGE-RETURN,
	JAL	R9,WHWI			:LINE-FEED...
	J	LEP0DA			:MESSAGE COPIED

EXLGMG	HC	0000,1FFE (13-1E)	:EXPAND LOGIN MESSAGE

	SUBTTL	LEP (LEP0E - Type E:  Aux circuit message)
::*********************************************************************
::
::	COMMAND:	LEP0E:
::	FUNCTION:	PROCESS AUX CIRCUIT MESSAGE (TYPE E)
::
::*********************************************************************

       IF       T2GATE                  :not used for gateway           ###sdw
LEP0E   EQ      LEPXT                   :just gobble if msg found
       ELSE

LEP0E	HS	0
	JAL	R9,GHWI			:DISCARD NODE & TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:GET SUBTYPE
	LR	R7,R1
	JAL	R9,GHWI			:PORT #
	LR	CHN,R1
	NHI	CHN,7FFF		:RESET HI-ORD BIT
	LHL	R2,IOTAB,CHN,CHN
	NHI	R2,-4
	JE	LEP1			:NO SUCH CIRCUIT
	LHL	R1,BF,R2,		:MAKE SURE ITS IN LOGIN
	CLHI	R1,LOGMIN
	JL	LEP1
	CLHI	R1,LOGMAX
	JG	LEP1
	CLHI	R7,80			:DO WE SEND REST OF LOGIN
	JN	LEP0EZ			:ERROR
	LH	R0,BF,R2,		:GET OLD FLAG,
	OHI	R0,LOGSUP		:SET SUP 'OK' BIT
	STH	R0,BF,R2,
	J	LEP1

LEP0EZ	XHI	R2,4			:SOME ERROR
	LIS 	R1,3
	JAL	R8,WCI			:RETURN LOGRR MESSAGE
	LHI 	R1,LOGRR&0FF
	JAL	R8,WCI
	LR 	R1,R7
	JAL	R8,WCI			:FOLLOWED BY ERROR CODE
	LIS	R0,0
	XHI	R2,4
	STH	R0,BF,R2,		:CLEAR BUFFER FLAG
	LR	R6,R2
	JAL	R9,LOGCLR		:REMOVE ENTRY FROM LOGGER LIST
	J	LEP1			:ALL DONE

       EI       :T2GATE

	SUBTTL	LEP (LEP0F - Type F:  General supervisor commands)

::*********************************************************************
::
::	COMMAND:	LEP0F:
::	FUNCTION:	PROCESS GENERAL SUP COMMANDS (TYPE F)
::
::*********************************************************************

LEP0F	HS	0
	JAL	R9,LEPGMS		:COPY MESSAGE TO BUFFER
	LB	R1,LEPMES+1
	SHI	R1,88			:RANGE CHECK 0F SUBTYPE
	JL	LEP1			:ERROR - TOO LOW
	CLHI	R1,LEPN0F
	JG	LEP1			:ERROR - TOO HIGH
	SLLS	R1,2			:FW indexing			###wjl
	L	R1,LEP0FT,R1,		:				###wjl
	JR	R1			:				###wjl

::*********************************************************************
::
::	SUBTYPE:	LEPHTM:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 08:  SEND HOST GMT
::
::*********************************************************************

LEPHTM	HS	0			:GET SUP TIME FOR NODECODE AND/OR ISIS.
	TS	GETGMT			:GET GMT FOR NODE CODE ONLY IF WE ARE
					:BEING TAKEN OVER AFTER CRASH, GMTGET=0
	JL	LEPHT1			:DON'T BOTHER, GO DO ISIS.
	L	R1,SLOWC,,		:SLOWC BASE TIME.
	ST	R1,GMTSLC		:STORE IT.
	ST	R1,SUPSLC		:FOR CRASH TABLES
	L	R1,LEPMES+4		:GET GMT IN HEX SEC'S
	ST	R1,SUPTIM		:FOR CRASH TABLES
:	NOW WE REDUCE R1 (HEX GMT) TO THE NO. OF SEC'S SINCE THE
:	BEGINNING OF THE CURRENT YEAR, PLUS A DAY'S WORTH.  THIS SO THAT
:	DAY 0 MEANS WE HAVEN'T YET GOTTEN GMT FROM THE SUP.
	SI	R1,$A(7*365*24*3600)+(2*24*3600) :R1= NO. SEC'S SINCE START
					:OF 1980 (A LEAPYEAR BOUNDARY)
:	FOR EFFICIENCY, PRECEDING LINE SHOULD BE MODIFIED AFTER EVERY LEAPYEAR.
:	NOTE: THIS WILL GO WRONG IN THE YEAR 2000. BEWARE!
LEPHT7	CI	R1,$A(4*365*24*3600)+(24*3600)	:HAS A LEAPYEAR PASSED SINCE?
	JLEFS	LEPHT2			:NO, SO SKIP
	SI	R1,$A(4*365*24*3600)+(24*3600)	:ADJUST FOR QUADYEAR PASSED
	JBS	LEPHT7			:AND CHECK AGAIN
LEPHT2	LIS	R0,1			:IF R0 GOES TO 4 (WRAPS TO 0) = LEAP YR
	LI	R6,$A(365*24*3600)	:SEC'S IN NORMAL YEAR
LEPHT5	CR	R1,R6			:HAS A YEAR PASSED?
	JLEFS	LEPHT6			:NO, SO SKIP
	LBR	R0,R0			:LEAPYEAR?
	JEFS	LEPHTC			:YES, MUST BE LAST DAY OF LEAPYEAR,SKIP
	AIS	R0,1			:A YEAR CLOSER TO A LEAPYEAR
	NHI	R0,3			:MOD 4
	SR	R1,R6			:ADJUST FOR NORMAL YEAR PASSED
	JBS	LEPHT5			:CHECK AGAIN
LEPHT6	LBR	R0,R0			:LEAPYEAR?
	JNFS	LEPHT4			:NO, SKIP
LEPHTC	AI	R6,$A24*3600		:ADD A DAY'S WORTH FOR CURRENT LEAPYEAR
LEPHT4	AI	R6,$A24*3600		:SEE NEXT COMMENT
	AI	R1,$A24*3600		:ADD DAY'S WORTH OF SEC'S, WHEN CONVERT
					:TO HUMAN FORM WE NEVER GET A DAY 0
					:UNLESS HAVEN'T BEEN HERE TOP GET GMT
	ST	R1,GMTHEX		:BASE GMT HEX SEC'S:GMTSLC
	SLLS	R1,7			:FORMAT FOR GMTCNV
	ST	R1,XLCRSH		:TIME OF LAST CRASH FOR ND DISPLAY
	ST	R6,CYRMAX		:MAX SEC'S IN CURRENT YEAR
	STH	R0,CYRCOD		:CURRENT YEAR TYPE (0-3) 0=LEAPYEAR
	L	R0,XFIRST		:IS THIS THE FIRST TAKEOVER SINCE LOAD?
	JNFS	LEPHTD			:XFIRST ALREADY HAS 1ST TAKEOVER TIME
	ST	R1,XFIRST		:YES, STORE FIRST TAKEOVER TIME
	L	R1,SUPTIM		:GET UNADULTERATED TAKE TIME
	ST	R1,TAKETI		:FOR CRASH TABLE

LEPHTD	HS	0
:	SOME LINES CAME UP BEFORE TAKEOVER, SO THEY HAVE ATT TIMES THAT
:	ARE NOT GMT. WE NOW ADJUST THEM TO GMT.
	LHI	R6,(NLINES-1)*4		:CHECK EACH LINE - FW INDEX
LEPHT8	L	R0,LINTIM,R6		:GET TIME FOR LINE
	JEFS	LEPHT9			:IF 0 IGNORE
	SRLS	R0,7			:ADJUST FROM GMTCNV FORMAT
	L	R1,GMTHEX		:GET BASE GMT
	SR	R1,R0			:FIND GMT FOR LINE
	CI	R1,$A24*3600		:IF < 1 DAY, TIME IS IN PREVIOUS YEAR
	JLFS	LEPHTA			:GO FIGURE
LEPHTB	SLLS	R1,7			:GMTCNV FORMAT
	ST	R1,LINTIM,R6		:STORE LINE GMT
LEPHT9	SIS	R6,4			:NEXT LINE
	JGE	LEPHT8			:IF ANY MORE

	JFS	LPHTM1			:CONTINUE

LEPHTA	AI	R1,$A365*24*3600	:ASSUME PREV YEAR NORMAL
	LHL	R0,CYRCOD		:CURRENT YEAR CODE
	SIS	R0,1			:PREV YEAR LEAPYEAR IF/ONLYIF CYRCOD=1
	JNBS	LEPHTB			:GMT OK
	AI	R1,$A24*3600		:ADD FOR LEAPYEAR
	J	LEPHTB

:	SOME HOSTS REPORTED STATUS BEFORE TAKEOVER, SO THEY HAVE HOST
:	STATUS TIMES THAT ARE NOT GMT. WE NOW ADJUST THEM TO GMT.
:	(USED FOR EXPANDED HOST STATUS)
LPHTM1	LHI	R6,0			:HW INDEX INTO HOST TABLES
LPHTM8	LHL	R0,HOSTN,R6		:CHECK FOR HOST ENTRY
	JE	LPHTM9			:NO ENTRY, SKIP
	L	R0,HSTTIM,R6,R6		:GET HOST STATUS TIME FOR ADJUSTMENT
	SRLS	R0,7			:ADJUST FROM GMTCNV FORMAT
	L	R1,GMTHEX		:GET BASE GMT
	SR	R1,R0			:FIND GMT FOR HOST
	CI	R1,$A24*3600		:IF < 1 DAY, TIME IS IN PREVIOUS YEAR
	JLFS	LPHTMA			:GO FIGURE
LPHTMB	SLLS	R1,7			:GMTCNV FORMAT
	ST	R1,HSTTIM,R6,R6		:STORE HOST GMT
LPHTM9	AIS	R6,2			:NEXT HOST TABLE HW INDEX
	CLHI	R6,NHOSTS^1		:AT END OF HOSTS TABLES
	JL	LPHTM8			:IF ANY MORE HOSTS
	JFS	LEPHT1			:CONTINUE
LPHTMA	AI	R1,$A365*24*3600	:ASSUME PREV YEAR NORMAL
	LHL	R0,CYRCOD		:CURRENT YEAR CODE
	SIS	R0,1			:PREV YEAR LEAPYEAR IF/ONLYIF CYRCOD=1
	JN	LPHTMB			:GMT OK
	AI	R1,$A24*3600		:ADD FOR LEAPYEAR
	J	LPHTMB

LEPHT1	IF	(1-T2GATE)		:ONLY APPLIES TO DISPATCHER HOSTS
       IF       1-NCSLOT                 :allow NC to run as slot
	LIS	R0,8			:WAIT FOR ROOM
	JAL	R8,DIROOM
	LHL	R6,DRIF,,		:get the fill pointer
	LHI	R1,INSTTM^8		:TIME MESSAGE			###jhl
	ST	R1,DIRNG,R6,		:put it in the ring
	AIS	R6,4
	NHI	R6,DRSZ-4
	L	R1,LEPMES+4		:GMT
	ST	R1,DIRNG,R6,
	AIS	R6,4
	NHI	R6,DRSZ-4
	STH	R6,DRIF,,
       EI       :1-NCSLOT
	EI	:(1-T2GATE)		:###EV
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPBRZ:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 09: STOP TALKING TO NODE
::
::*********************************************************************

LEPBRZ	HS	0
	LHL	R1,LEPMES+2		:LOAD NEIGHBOR NUMBER
	JAL	R9,FNDLNK,,		:ZAP LINK IF UP
	SKIPAD(LEPB10)			:immediate return		###wjl
	rBT	KN,BORZAP		:+4 return      inverted by sdw
LEPB10  HS      0               	:###wjl
        NHI     R1,7FFF         	:RESET HIGH-ORDER BIT		###wjl
      	LHI	R5,(BGLSIZ-1)*2
LEPB30	LH	R0,BGLIST,R5
	JEFS	LEPB20          	:IF NO ENTRY, GO MAKE ENTRY
        CR      R1,R0           	:SEE IF THIS A DUPLICATE	###wjl
        JEFS    LEPB40          	:DUPLICATE, SO RETURN		###wjl
	SIS	R5,2            	:PREPARE TO CHECK NEXT ENTRY OR
	JGBS	LEPB30			:IF LIST FULL, REUSE FIRST ENTRY
LEPB20	STH	R1,BGLIST,R5    	:MAKE ENTRY IN BAD GUY LIST
LEPB40	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPBRU:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0A: START TALKING TO NODE
::
::*********************************************************************

LEPBRU	HS	0
	LHL	R1,LEPMES+2		:LOAD NEIGHBOR NUMBER
	JAL	R9,FNDLNK,,		:FIND LINK
	SKIPAD(LEPBR2)			:TRLINK HAS PROBABLY RESET BORZAP##wjl
:       borizap is now inverted (0 to zap 1 to normal)
	sBT	KN,BORZAP		:+4 ret, PROBABLY REDUNDANT, BUT SAFE
LEPBR2  HS      0               	:###wjl
        NHI     R1,7FFF         	:RESET HIGH-ORDER BIT		###wjl
	LIS	R0,0
	LHI	R5,(BGLSIZ-1)*2
LEPBR6	CLH	R1,BGLIST,R5
	JNFS	LEPBR4
	STH	R0,BGLIST,R5		:REMOVE ENTRY FROM BAD GUY LIST
LEPBR4	SIS	R5,2
	JGEBS	LEPBR6
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPRBJ:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0B:  REBUILD ABORTED
::
::*********************************************************************

	IF	REBILD

LEPRBJ	HS	0
	L	R1,LEPMES+2		:REB REJECT - GET INVOICE #
	ST	R1,CQINV
	JAL	R9,FNDCRQ		:LOCATE CIRCUIT
	SKIPAD(LEPRBX)			:immed ret, CIRCUIT NOT FOUND	###wjl
	LR	R2,R6			:+4 return, RETURNS OUTBOUND BUFF IN R6
       if       t2gate!acct
        lis     r0,aalr03
        sth     r0,aareas
       ei
	XHI	R2,4			:INBOUND BUFF
	JAL	R9,ZAPHRD		:BYEBYE CIRCUIT
       if       t2gate!acct
        lis     r0,0
        sth     r0,aareas
       ei
LEPRBX	J	BIDDRT,,

	ELSE	:NOT REBILD

:	DESTINATION NODE WITH NO REBUILD CAPABILITY RECEIVED A REBUILD
:	REJECT COMMAND FROM SUPERVISOR AND DOES NOT KNOW HOW TO HANDLE
:	THE COMMAND...			:###wjl
LEPRBJ	HS	0
	J	BIDDRT,,		:###wjl
	EI	:REBILD

::*********************************************************************
::
::	SUBTYPE:	LEPDLL:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0C:  DLOAD COMMAND (GO TO BOOT)
::
::*********************************************************************

LEPDLL	HS	0
      IF	1-NAD68			:not supported in 68K environment###wjl
	LHL	R0,HNPORT		:# OF ACTIVE PORTS (TYMSAT+KERNEL+ISIS)
	OHI	R0,8000
	STH	R0,SUPMBF+2		:FORMAT FOR REPORT TO SUPERVISOR LOG
	LHL	R0,PASTHR
	OHI	R0,8000			:NUMBER OF PASSTHROUGHS + 8000
	STH	R0,SUPMBF+4
	LHI	R0,NR.DLD		:NODE REPORT TYPE
	STH	R0,SUPMBF
	JAL	R10,SUP12		:SEND THE REPORT
	TS	DLDFLG			:SET DLOAD FLAG FOR THE 4-SECOND LOGIC
      EI	:NAD68
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPZLI:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0D:  LOGIN ZAPPER CONFIRMATION
::
::*********************************************************************

LEPZLI	HS	0
	LHL	CHN,LEPMES+2		:ZAPPER CONFIRMATION ON LOGIN
	NHI	CHN,7FFF		:PORT #

:       same logic for log II log zap confirmation                      ###sdw
LEPZL3	LHL	R2,IOTAB,CHN,CHN	:GET CHN'S OUTBOUND BUFFER
	NHI	R2,-4

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LPZDB1,,
	GL	LPZDB1
	LM	R0,REGST		:restore regs		###sdw
	LR	R2,R2
	EI	:LPGDBG

	JE	LEP1			:NOTHING THERE
	LHL	R1,BF,R2,		:entry point for LOG II logon zap acks
	CLHI	R1,LOGMIN       	:HAS NEEDLE BEEN SENT DOWN YET  ??
	JL	LEPZL0		
	CLHI	R1,LOGMAX
	JLE	LEPZL1

:	NEEDLE HAS BEEN SENT DOWN ALREADY	###LSH
LEPZL0  HS      0
	GL	ZAPX

:	ZAP IN BOTH DIRECTIONS
	LHI	R1,ZAPPN		:NON-GOBBLING TYPE ZAPPER
	JAL	R9,ZAPX			:CLEAR HALF CIRCUIT (TO DISPATCHER)
					: AND SEND ZAP DOWN TO HOST
	JAL	R8,GFCBUF		:GET ANOTHER BUFFER PAIR
	SKIPAD(OP8463)			:immed. return - out of buffers!###wjl
	JAL	R9,CRQHCR		:+4, BUILD HALF CIRCUIT (TO DISPATCHER)
	XHI	R2,4			:SWITCH TO CHN'S INCOMING BUFFER
	JAL	R9,ZAPHRD		:SEND ZAP TO DISPATCHER

	J	LEP1

:	NEEDLE HAS NOT BEEN SENT YET.  WE CAN RETURN BUFFER, AND
:	STOP CIRCUIT RIGHT HERE.

LEPZL1	LIS	R0,0
	STH	R0,IOTAB,CHN,CHN	:CLEAR PERMUTER TABLE
	LR	R6,R2
	JAL	R9,LOGCLR		:REMOVE FROM LIST
	SBT	CHN,ACP,,		:MARK PORT AS AVAILABLE
	LCS	R0,1
	SR	R0,CHN
	SBT	R0,ACP,,		:NEGATIVE ACP MARKED AS AVAILABLE
	JAL	R8,RFCBUF		:RETURN BUFFER PAIR
	IF	T2GATE
	SHI	CHN,DISZFL		:make dispatcher port (relative chn)
	LHI	R1,9F00
	JAL	R8,DIRMES		:and free up port for dispatcher use
	EI	:T2GATE
	J	LEP1


::*********************************************************************
::
::	SUBTYPE:	LEPSPR:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0E:  SYNC PORT REQUEST
::
::*********************************************************************

LEPSPR	HS	0
	JAL	R10,SUPMHD		:SYNC LINE REPORT
	LHI	R1,148D			:RETURN TYPE '14'
	JAL	R9,WHWI
	LHI	R1,NLINES+8080
	JAL	R9,WHWI
	LIS	R5,0
LEPSP1	LHL	R1,NGSVLN,R5,R5
	NHI	R1,0BFFF		:ERRONEOUS NGHBR NOT REPORTED AS SIO
	IF	SILINS
	CLHI	R5,NLINES-SILINS
	JLFS	LEPS20
	OHI	R1,4000
LEPS20	HS	0
	EI	:SILINS
	JAL	R9,WHWI
	AIS	R5,1
	CLHI	R5,NLINES
	JLBS	LEPSP1
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPLSP:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 0F:  LINK SPEED REQUEST
::
::*********************************************************************

LEPLSP	HS	0
	JAL	R10,SUPMHD		:LINK SPEED REQUEST 0F/0F
	LHI	R1,148E
	JAL	R9,WHWI
	LHL	R1,LEPMES+2		:GET NEIGHBOR IN QUESTION
	NHI	R1,7FFF
	JAL	R9,WHWI			:RETURN #
	JAL	R9,FNDLNK
	SKIPAD(LEPLS1)			:immed return, NO SUCH NEIGHBOR	##wjl
	LB	R1,KSPD,KD		:+4 return
	NHI	R1,7F
	JNFS	LEPL10
LEPLS1	LCS	R1,1			:LINK IS DOWN
LEPL10	JAL	R9,WHWI
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPHRJ:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 10:  HOST REJECT COMMAND
::
::*********************************************************************

LEPHRJ	HS	0			:HOST REJECT MESSAGE,SENT TO DISPATCHER
       IF       1-NCSLOT
	LIS	R0,8			:CHECK FOR ENOUGH ROOM
	JAL	R8,DIROOM
	LHL	R6,DRIF,,		:GET FILL INDEX FOR RING
	LHL	R1,LEPMES+2		:GET HOST NUMBER
	NHI	R1,7FFF
	CLHI	R1,HST0			:KERNEL HOST NUMBER?
	JE	LEP1			:YES, IGNORE
	JAL	R9,FNDHST		:RETURNS HN AS HOST # INDEX
	SKIPAD(LEP1)			:immed, REJECT A HOST WE DON'T HAVE#wjl
	LB	R0,HSTKEY,HN		:+4 return, "KEY" (4*SLOT #)
	AHI	R0,0B00			:TYPE B MSG - REJECT
	ST	R0,DIRNG,R6,		:INTRA-ISIS MSG ON RPORT 0 (UPPER HW)
	AIS	R6,4			:UPDATE POINTER
	NHI	R6,DRSZ-4
:	RETURN HOST NUMBER, ERROR REASON=1 FOR HOST REJECT BY SUPERVISOR
	EXHR	R1,R1			:HOST NUMBER IN UPPER HALFWORD,
	AHI	R1,0100			:REASON=01 IN FOLLOWING BYTE
	ST	R1,DIRNG,R6,		:PUT IT AWAY TOWARDS OFFENDING SLOT
	AIS	R6,4
	NHI	R6,DRSZ-4		:UPDATE POINTER
	STH	R6,DRIF,,
	LIS	R0,0
	STH	R0,HOSTN,HN,HN		:CLEAR HOST ENTRY

:	CLEAR EXPANDED HOST STATUS INFORMATION
	STB	R0,HSTCST,HN		:CLEAR MULTI-TARGET HOST COST	###OAS
	STB	R0,HSTMBK,HN		:CLEAR MULTI-BASED HOST KEY	###OAS
	STB	R0,HSTYPE,HN		:CLEAR HOST TYPE (PID)		###OAS
	LB	R0,HSTATN,HN		:GET EXPANDED HOST STATUS	###OAS
	NHI	R0,00C0			:CLEAR BITS 2,3,4,5 OF LO BYTE	###OAS
	STB	R0,HSTATN,HN		:AND RESTORE			###OAS
	JAL	R9,GMTCAL,,		:GET CURRENT GMT		###OAS
	L	R0,GMTNOW		:FOR TIME OF LAST STATUS UPDATE	###OAS
	SLLS	HN,1			:FORM FW INDEX INTO		###OAS
	ST	R0,HSTTIM,HN,HN		:HOST TIME ARRAY,STORE CURRENT TIME#OAS
	SRLS	HN,1			:RESTORE HN#			###OAS
       EI       :1-NCSLOT
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPBGL:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 11:  REPORT BAD-GUY LIST
::
::*********************************************************************

LEPBGL	HS	0
	JAL	R10,SUPMHD		:REPORT THE BAD GUYS LIST  (14/12)
	LHI	R1,1492			:TYPE 14, SUBTYPE 12
	JAL	R9,WHWI
	LHI	R1,8080
	LHI	R5,(BGLSIZ-1)*2
LEPBG1  LH	R0,BGLIST,R5		:COUNT HOW MANY ON LIST
	JEFS	LEPBG4
	AIS	R1,1
LEPBG4	SIS	R5,2
	JGEBS	LEPBG1
	JAL	R9,WHWI
	LHI	R5,(BGLSIZ-1)*2
LEPBG2  LH	R1,BGLIST,R5		:NOW SEND THEM IN
	JEFS	LEPBG6
	OHI	R1,8000
	JAL	R9,WHWI
LEPBG6	SIS	R5,2
	JGEBS	LEPBG2
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPRKD:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 12:  REMOVE NEIGHBOR
::
::*********************************************************************

:	NEIGHBOR NUMBER TO REMOVE IS IN LEPMES+2. RESPONSE IS A REPORT TO
:	LOG (TYPE 12), WITH 3 HALFWORDS, AS FOLLOWS:
:	*HW1* 4 (SUBTYPE 4)
:	*HW2* NEIGH # + 8000
:	*HW3* STATUS + 8080
:		=1 FOR NEIGHBOR NUMBER REMOVED
:		=2 FOR NEIGHBOR NUMBER NOT FOUND

LEPRKD	HS	0
	LHL	R1,LEPMES+2
	STH	R1,SUPMBF+2		:SAVE NEIGHBOR NUMBER FOR RESPONSE
	NHI	R1,7FFF
	JAL	R9,FNDLNK		:GET LINK DESCRIPTOR FOR THIS NEIGHBOR
	SKIPAD(LEPRK4)			:immediate return, NOT FOUND	###wjl
	LB	R7,NLAT,KD		:+4, ANY LINES ATTACHED TO THIS LINK?
	JEFS	LEPRK2			:NO - LINK DOWN

:	LINK TO BE REMOVED IS UP - TEAR IT DOWN
	JAL	R10,TRLINK,,		:ZAP CIRCUITS, MARK LINK INACTIVE
	LHI	R4,13A4			:REPORT LINK OUT BY COMMAND
:	(NOTE R7=0 FROM TRLINK, WHICH DETERMINES LINK STATUS IN SUP13)
	JAL	R10,SUP13		:REPORT LINK DOWN TO SUP

LEPRK2	LIS	R0,1			:INDICATE NEIGHBOR NUMBER REMOVED
	JFS	LEPRK6
LEPRK4	LIS	R0,2			:INDICATE NEIGHBOR NUMBER NOT FOUND
LEPRK6	STH	R0,SUPMBF+4		:(HW3)
	LIS	R0,NR.RLK
	STH	R0,SUPMBF		:REPORT TO LOG, SUBTYPE 4
	JAL	R10,SUP12
	J	LEP1

::*********************************************************************
::
::	SUBTYPE:	LEPAKD:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 13:  ADD NEIGHBOR
::
::*********************************************************************

:	NEIGHBOR NUMBER TO ADD IS IN LEPMES+2. DESIRED WINDOW SIZE + 8000 IS
:	IN LEPMES+4. IF SPECIFIED WINDOW SIZE IS 0, THEN ANY AVAILABLE LINK
:	WILL DO. RESPONSE IS A REPORT TO LOG (TYPE 12), WITH 3 HALFWORDS,
:	AS FOLLOWS:
:	*HW1* 5 (SUBTYPE 5)
:	*HW2* NEIGH # + 8000
:	*HW3* STATUS
:		=8000 + WSIZ IF NEIGHBOR ADDED
:		=FF00 + WSIZ IF LINK SPACE AVAILABLE BUT NO WSIZ MATCH
:		=FFFF IF NO LINK SPACE AVAILABLE

LEPAKD	HS	0
	LIS	R0,NR.ALK		:SET UP RESPONSE MESSAGE
	STH	R0,SUPMBF		: (REPORT TO LOG, SUBTYPE 5)
	LHL	R2,LEPMES+4
	STH	R2,SUPMBF+4		:SAVE WINDOW SIZE + 8000
	NHI	R2,7FFF
	LIS	R3,0			:R3 IS FLAG FOR ANY LINK FOUND
	LHL	R1,LEPMES+2
	STH	R1,SUPMBF+2		:NEIGHBOR # + 8000
	NHI	R1,7FFF
	STH	R1,LEPMES+2		:STORE BACK FOR LEPBRU (8000 BIT OFF)
:	SCAN ALL LINKS FOR AVAILABLE LINK DESCRIPTOR
	LHI	KN,NLINKS-1
LEPAK2	SLLS	KN,1
	L	KD,KDKN,KN,KN
	SRLS	KN,1
	LH	R0,NDID,KD		:IS LINK SPACE FREE?
	JNFS	LEPAK4			:NO
	LR	R2,R2			:YES - WSIZ SPECIFIED?
	JE	LEPAK6			:NO - ANY SIZE WILL DO
	CLH	R2,WSIZ,KD		:TEST FOR MATCH ON WINDOW SIZE
	JEFS	LEPAK6			:YES - ADD NEIGHBOR TO THIS LINK
	LCS	R3,1			:FLAG FOR LINK FOUND BUT WSIZ MISMATCH
LEPAK4	SIS	KN,1
	JGE	LEPAK2			:SCAN ALL LINKS
:	ALL LINK DESCRIPTORS EXAMINED - NO MATCH FOUND
	STB	KN,LEPMES+4		:INDICATE NEIGHBOR NOT ADDED
	LR	R3,R3			:DID WE REJECT DUE TO WSIZ MISMATCH?
	JLFS	LEPAK5			:YES - RETURN REQUESTED WINDOW SIZE
	STB	KN,LEPMES+5		:NO, ABSOLUTELY NO LINK SPACE AVAILABLE
LEPAK5	JAL	R10,SUP12		:REPORT TO LOG
	J	LEPBRU			:INSURE NEIGHBOR NOT ON BAD GUY LIST

LEPAK6	STH	R1,NDID,KD		:RESERVE LINK DESCRIPTOR FOR THIS NGHBR
	STH	R1,ONDID,KD
	JBS	LEPAK5			:REPORT AND CLEAN BAD GUY LIST

::*********************************************************************
::
::	SUBTYPE:	LEPNOP:
::	FUNCTION:	LEP TYPE 0F, SUBTYPE 14:  SUP NOP COMMAND -
::			TIMING DIAGNOSTIC REQUEST
::	FORMAT:	[0F,n+80]    where n=14
::		[time
::		 time]       Sup data to return intact
::		[8000+count] Return count messages
::*********************************************************************

:	THE SUP NOP COMMAND IS USED TO TIME ROUND TRIP OF SUP MESSAGES TO
:	INDIVIDUAL NODES BY PASSING AND HAVING RETURNED ITS OWN 'FASTC'. IN
:	ADDITION, AN ARTIFICIAL LOAD CAN BE CREATED SINCE THE THIRD HALFWORD
:	CONTAINS A LOOP COUNTER. THE LOOP COUNTER INDICATES THE NUMBER OF
:	RESPONSES TO RETURN FOR THIS COMMAND. RESPONSE IS A TYPE 14,
:	SUBTYPE 15, WITH 5 HALFWORDS, AS FOLLOWS:
:	*HW1* SUP FASTC
:	*HW2* SUP FASTC+2
:	*HW3* DECREMENTING LOOP COUNTER
:	*HW4* NODE FASTC
:	*HW5* NODE FASTC+2

LEPNOP	HS	0
	LHL	R15,LEPMES+6		:GET LOOP COUNTER AND
	NHI	R15,7FFF		:ISOLATE
	JE	LEP1			:SUP GENERATING ONE-WAY LOAD DOWNSTREAM

	L	R0,LEPMES+2		:MOVE SUP FASTC TO SAVE AREA IN
	ST	R0,LEPNSF		:CASE WE INTERRUPT TO OBSERVE BP LIMIT

:	NUMBER OF RESPONSE MESSAGES IS BASED ON LOOP COUNTER IN R15
LEPNP2	JAL	R10,SUPMHD		:SET UP MESSAGE HEADER
	LHI	R1,1415
	JAL	R9,WHWI			:TYPE 14, SUBTYPE 15
	LHL	R1,LEPNSF
	JAL	R9,WHWI			:RETURN SUP FASTC
	LHL	R1,LEPNSF+2
	JAL	R9,WHWI			:AND FASTC+2
	LR	R1,R15
	OHI	R1,8000			:INCLUDE LOOP COUNTER
	JAL	R9,WHWI
	LHL	R1,FASTC,,
	JAL	R9,WHWI			:RETURN NODE FASTC
	LHL	R1,FASTC+2,,
	JAL	R9,WHWI			:AND FASTC+2
	SIS	R15,1			:DECREMENT LOOP COUNTER
	JLE	SWICRQ,,			:DONE
	LHL	R0,BCT,R2,
	CLHI	R0,CIRSP3		:HAVE WE REACHED BACKPRESSURE LIMIT?
	JLE	LEPNP2			:NO - CONTINUE
	ST	R15,LEPNPF		:YES - COME BACK FROM 'SWITCH'
:	TO CHECK FOR OUTPUT DRAINED. HIGH-ORDER HW FLAGS BRANCH TO LEPNP4.
	J	SWICRQ,,

LEPNP4	HS	0			:CONTINUATION POINT FOR SUP NOP PROCESS
	LHL	R15,LEPNPF+2		:RESTORE LOOP COUNTER
	J	LEPNP2

	SUBTTL	LEP (LEP10 - Type 10:  Port status request)

::*********************************************************************
::
::	COMMAND:	LEP TYPE 10:
::	FUNCTION:	PORT STATUS REQUEST
::
::*********************************************************************

LEP10	HS	0
	JAL	R9,GHWI			:DISCARD NODE & TYPE
	JAL	R8,GCI
	JAL	R8,GCI			:PORT GROUP #
	LR	R15,R1			:TO REG 15
	JAL	R9,GHWI			:HOST #
	LR	R14,R1			:TO REG 14
	JAL	R10,SUPMHD		:CREATE HEADER
	LHI	R1,148B
	JAL	R9,WHWI
	LR	R1,R14			:HOST #
	JAL	R9,WHWI

:	TEST FOR LINK PORT STATUS REQUEST
:	IF 40 BIT OF PORT GROUP BYTE SET R14 = NODE#
	THI	R15,40
	JN	L10LNK			:YES, LINK PORT STATUS REQUEST

	LR	R1,R14			:GET HOST #
	NHI	R1,7FFF			:CLEAR HI-ORD BIT
	JNFS	LEP10A			:IF HOST <> 0 SKIP

:	HOST = 0, REPORT ALL DISPATCHER PORTS IN USE
	LHI	R6,(NDP+7)/8		:NUMBER OF BYTES OF ACP TO CHECK
	LA	R7,DISACP,,		:GET START ADDR OF DISPATCHER ACP ARRAY
	J	LEP10C			:PROCESS

LEP10A	CLHI	R1,7FFE			:IS IT THE SUP?
	JE	LEP10E

	JAL	R9,FNDHST		:HOST, FIND IT
	SKIPAD(LEP10G)			:immed ret, WE DONT KNOW HIM	###wjl
	CLHI	R1,HST0			:+4 return, HOST = KERNEL ?
	JN	LEP10D			:NO,REPORT DISPATCHER HOST PORTS IN USE
	LHI	R6,(NKU+07)/8		:YES, SET UP # OF PORTS
	LHI	R7,KERACP,		:SET UP START OF KER PRTS

:	REPORT ACTIVE PORTS BY SENDING SUP COMPLEMENTED 'ACP' ARRAY
:	SO THAT AN ACTIVE PORT IS INDICATED BY A BIT SET
LEP10C	LIS	R5,8
	NHI	R15,3F
	LR	R1,R15			:RESPOND WITH
	OHI	R1,8080			:PORT GROUP + 8080
	SLLS	R15,4			:GET NUMBER OF BYTES OFFSET FOR GROUP
					:16d BYTES PER GROUP
	AR	R7,R15			:ADD TO EXISTING OFFSET
	CI	R7,DISACP+(NDP+7)/8
	JGE	LEP10X			:INVALID, COMPUTED ADDRESS OUT OF RANGE

	JAL	R9,WHWI			:ADDR OK, SEND PORT GROUP +8080 TO SUP
	SR	R6,R15			:GET MAX # OF NON-ZERO BYTES TO SEND
	LCS	R10,1			:COMPLEMENT ACP SO 1'S FOR ACTIVE PORTS
LEP10F	LHL	R1,0,R7			:GET A PORT GROUP
	XR	R1,R10			:MAKE ACTIVE PORTS ONES
	LR	R6,R6			:ZERO PAD IF NEEDED
	JGFS	LEP10H
	LIS	R1,0
LEP10H	JAL	R9,WHWI
	AIS	R7,2			:GO TO NEXT GROUP
	SIS	R6,2
	SIS	R5,1
	JGBS	LEP10F
	J	LEP1			:ALL DONE

:	RETURN PORTS IN USE BY SPECIFIED HOST
LEP10D	HS	0
	LR	R14,R1			:SAVE HOST NUMBER
	LR	R1,R15			:REQUESTED PORT GROUP 
	OHI	R1,8080			:+ 8080
	JAL	R9,WHWI			:RETURN PORT GROUP NUMBER
	NHI	R15,3F			:ISOLATE RELEVANT BITS AND
	EXBR	R15,R15			:COMPUTE HW OFFSET FOR PORTS TO EXAMINE

L10D10	CLHI	R15,NDP*2		:OUT OF RANGE FOR DISPATCHER PORTS?
	JGE	L10D40			:YES - MARK REMAINING PORTS UNUSED...
	LIS	R1,0			:R1 CARRIES 1 BIT FOR EACH PORT IN USE
	LIS	CHN,0			:INIT CHN FOR THIS GROUP OF 10
L10D20	LHL	R0,DHSTIX,R15,CHN	:GET HOST # FOR CIRCUIT ON THIS PORT
	CR	R0,R14			:IS THIS THE HOST SPECIFIED?
	JNFS	L10D30			:NO
	OH	R1,HMSK,CHN,		:YES - TURN ON BIT FOR THIS PORT
L10D30	AIS	CHN,2
	THI	CHN,1E			:DONE WITH THIS GROUP OF 10?
	JNBS	L10D20			:NO
	JAL	R9,WHWI			:YES - PASS IT ON

	AHI	R15,20			:INCREMENT TO NEXT GROUP OF 10 PORTS
	THI	R15,0FE			:DONE WITH PSTAT?
	JN	L10D10			:NO
	J	LEP1			:YES - RETURN TO LEP COMMAND PROCESSOR

:	PAD REMAINING PORT ENTRIES WITH ZEROS
L10D40	LIS	R1,0
	JAL	R9,WHWI			:UNUSED PORTS...
	AHI	R15,20
	THI	R15,0FE			:DONE?
	JNBS	L10D40			:NO
	J	LEP1			:YES - RETURN

LEP10E	LA	R7,SUPACP,,		:SUPERVISOR ACP ADDRESS
	LHI	R6,(NSP+07)/8		:# OF GROUPS
	J	LEP10C

:	PORT STATUS REQUEST IS FOR LINK. FIND LINK DESCRIPTOR, 
:	ACP OFFSET, AND NUMBER OF CHANNELS TO SCAN.
L10LNK	HS	0
	LR	R10,R15			:GET PORT GROUP BYTE AND
	NHI	R10,3F			:ISOLATE PORT GROUP NUMBER
	LR	R1,R14			:GET NODE NUMBER AND
	NHI	R1,7FFF			:MASK OUT HIGH-ORDER BIT
	JAL	R9,FNDLNK		:FIND LINK DESCRIPTOR FOR THIS NEIGHBOR
	SKIPAD(LEP10G)			:immed, NEIGHBOR DOES NOT EXIST	###wjl
	TBT	KN,ALINKS		:+4 return, IS LINK ACTIVE?
	JE	LEP10G			:NO, SEND REPORT TO SUP

	LHL	R7,FLDPKN,KN,KN
	LA	R7,LNKACP,R7,		:ADDRESS OF ACP ARRAY FOR THIS LINK
	LHL	R6,NCHN,KD		:NUMBER OF CHANNELS ASSIGNED TO LINK
	SRLS	R6,3			:NCHN/8 = # BYTES OF ACP FOR THIS LINK

	LR	R15,R10			:RESTORE R15 FOR PSTAT RESPONSE, LEP10C
	SLLS	R10,4			:PORT GROUP*10=BYTE DISPLACMNT INTO ACP
	LR	R9,R6			:NUMBER OF BYTES OF ACP ARRAY TO SCAN
	SR	R9,R10			:MINUS PORT GROUP OFFSET IS POSTIVE?
	JG	LEP10C			:GO FORMAT PSTAT RESPONSE

LEP10X	OHI	R1,200			:ARRAY OUT OF RANGE,
	JFS	LEP10V			: SEND 8080+200+ARRAY#
LEP10G	LHI	R1,8180			:NODE/HOST UNKNOWN,
					: SEND 8080+100+PORT ARRAY#
	NHI	R15,3F			:EXTRACT PORT ARRAY NUMBER
	OR	R1,R15			:INCLUDE PORT ARRAY NUMBER INTO R1
LEP10V	JAL	R9,WHWI			:SEND ERROR RESPONSE TO SUP
	LIS	R5,8			:SEND 8 HW OF 1'S
	LCS	R1,1
LEP10B	JAL	R9,WHWI			:RETURN -1 FOR PORT GROUP #
	SIS	R5,1
	JGBS	LEP10B
	J	LEP1

	SUBTTL	LEP (LEP11 - Type 11:  Assign channel to TYMNET-I)

::*********************************************************************
::
::	COMMAND:	LEP11:
::	FUNCTION:	04-APR-87 UNUSED AT THIS TIME
::
::*********************************************************************

LEP11   EQ      LEPXT           :go to the gobble msg routine


        SUBTTL  LEP (LEP12 - RCRM - Log II login response)

::*********************************************************
:
:       LEP12   The reponse/reject logon message (NCRM).
:               Idea is to pass it to dispatcher unchanged unless
:               it is a logon zapper ack.  If it is the zap ack then
:               we can finally set that port to be reused
::*********************************************************

       IF       LOGII&(1-NCSLOT)        :only if LOG 2 Dispatcher

LEP12
        JAL     R9,GHWI                 :remove node #
        JAL     R9,GHWI                 :remove type (12) and unused byte
        L       R3,BB,R2,               :setup for peek
        JAL     R9,PHWI                 :get logical (not counting escs) len
        LHI     LRC,2,R1                :save it (in R14) PWHI returns it in r1
        LHI     R4,ID.PRT               :get our chn number first
        JAL     R7,X4PARS               :find chn #
        SKIPAD(LEP12A)                  :crash if no chn
        JAL     R7,X4GTNM               :get the chn
        LR      CHN,R4                  :put chn in normal register
        LR      R11,R2                  :save supe's buffer #
        LHL     R2,DIOTAB,CHN,CHN       :get port's buffer #
        NHI     R2,-4                   :knock off any speed bits
        JNFS    LEP12B                  :make sure a buffer is there
        LR      R2,R11                  :gobble supe msg
LEP12A  JAL     R9,GCIE                 :we have a logical len
        SIS     LRC,1                   :another logical char read out
        JGBS    LEP12A                  :gobble our lep 12 msg
        LIS     R0,1
        AHM     R0,NC.LPE               :another lep error
        J       LEP1

LEP12B  XHI     R2,4
        LHI     R4,ID.RMF               :find our flags
        GL      X4PARC
        JAL     R7,X4PARC               :continue parse
        SKIPAD(LEP12A)                  :gobble msg if no rcrm flags
        JAL     R9,PCIE                 :get the number of unused bits
        JAL     R9,PCIE                 :the first byte of the bits
        THI     R1,L2F.ZA               :is this a zapper ack?
        JN      LEP12Z                  :joins LEP type 0F subtype 0D of
                                        :logon zapper confirmation (LEPZLI)
        LHI     R1,L2SRJT               :message for log 2 terminal
        JAL     R9,W2CI
        LR      R7,R2                   :make a copy of the term buffer
LEP12D  LR      R2,R11                  :get supe buff back
        JAL     R9,GCIE                 :get 1st char
        LR      R2,R7                   :get term buff back
        JAL     R9,WCIE
        SIS     LRC,1
        JGBS    LEP12D                  :copy it all
        XHI     R2,4
        LH      R1,BF,R2,               :make sure port still in login mode
        CLHI    R1,LOGMIN               :
        JL      LEP1                    :too low, just return
        CLHI    R1,LOGMAX               :
        JG      LEP1                    :too big, just return (let it fix itself
        OHI     R1,LOGSUP               :supe ready to receive
        STH     R1,BF,R2,
        J       LEP1


:       zap circuit after gobbling rest of this msg
LEP12Z  LR      R2,R11                  :lep buffer
LEP12Y  JAL     R9,GCIE                 :gobble the zap ack msg
        SIS     LRC,1
        JGBS    LEP12Y
        AHI     CHN,DISZFL              :get back to absolute chn
        J       LEPZL3                  :goto log I log zap ack logic

       ELSE     :not LOGII
LEP12   EQ      LEPXT	                :if not LOG2 then illegal msg	###wjl
       EI       :LOGII

	SUBTTL	LEP (LEPZAP:  Handle command circuit zapper)

::*********************************************************************
::
::	LEPZAP:
::	FUNCTION:	PROCESS ZAPPERS ARRIVED ON COMMAND CIRCUITS
::
::*********************************************************************

LEPZAP	HS	0			:ZAPPER ON COMMAND CIRCUIT

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,LEPDB1,,
	GL	LEPDB1
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	LHI	R0,LEPZFL,CHN		:GET ABSOLUTE CHANNEL NUMBER AND
	RBT	R0,TRCHAN,,		:TURN OFF TRACING FOR THIS CHANNEL
	JAL	R8,PCI
	CLHI	R1,GOBBL&0FF		:TEST FOR ZAPPER
	JL	LEPZA2			:YES - COMPLETE CIRCUIT TEARDOWN
:	AN 03-CHARACTER PAIR WHICH IS NOT A ZAPPER IS RATHER ANOMALOUS...
:	ZAP COMMAND CIRCUIT, AND ISSUE NODE REPORT
	OI	R1,0FFFF0300
	ST	R1,SUPMBF+2		:SHOW WHAT WE GOT
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP COMMAND CIRCUIT...
	LHI	R1,NR.I3C
	STH	R1,SUPMBF		:INDICATE INVALID 03-CHARACTER PAIR
	JAL	R10,SUP12		:SUP12 WILL BUFFER NODE REPORT
	JFS	LEPZA3			: UNTIL RE-TAKEN
LEPZA2
	JAL	R9,ZAPV			:GOT A ZAPPER - TEAR DOWN CIRCUIT
LEPZA3	IF	SUPER			:IF FROM OUR SUP, REBUILD CIRC
	LHL	R0,LIOTAB,,
	JNFS	LEPZA4
	JAL	R9,SUPCRQ
	EI	:SUPER
LEPZA4	LHL	R4,TVRBUF		:IS IT FROM REIGNING SUP?
	XHI	R4,4
	CLH	R4,LEPINB
	JN	BIDDRT,,		:NO, EXIT
	IF	T2GATE			:RPT TO INET SUP HST SHUT ##AL
	LIS	R3,HSHUT
        STB     R3,HSTAT                :we are shut
	JAL	R10,GHSTST,,		:HST STATUS TO INET SUP
	EI	:T2GATE
	LHL	R0,TVRSUP		:GET CURRENT SDUPERVISOR NUMBER
	JAL	R8,CRYPTO,,		:TELL XRAY
	HC	CRYE07			:MESSAGE = SUP CRQ LOST
	LIS	R0,0			:YES, NO MORE SUPER
	STH	R0,TVRBUF
	STH	R0,TVRSUP
	IF	(1-T2GATE)
       IF       1-NCSLOT                 :allow NC to run as a slot
	LIS	R0,8			:ROOM FOR NO SUP MSG
	JAL	R8,DIROOM,,
	LHI	R0,INNOSP^8		:NO SUP MESSAGE			###jhl
	LHL	R8,DRIF,,		:GET FILL POINTER
	ST	R0,DIRNG,R8,		:SAVE IT
	AIS	R8,4			:BUMP INDEX
	NHI	R8,DRSZ-1		:FIX WRAP
	STH	R8,DRIF,,
       EI       :1-NCSLOT
	EI	:(1-T2GATE)		:###EV

	J	BIDDRT,,

	SUBTTL	LEP (Utilities and tables)

::*********************************************************************
::
::	SUBROUTINE:	LEPGMS:
::	FUNCTION:	COPIES LEP MESSAGES TO INTERMEDIATE BUFFER
::	CALLING SEQ:	JAL	R9,LEPGMS
::
::*********************************************************************

LEPGMS	HS	0
	LA	R4,LEPNOD
	LHI	R6,-2,LRC
LEPGM1	JAL	R8,GCI
	LR	R1,R1
	JNFS	LEPG10
	JAL	R8,GCI
	SIS	R6,1
LEPG10	STB	R1,0,R4
	AIS	R4,1
	SIS	R6,1
	JGBS	LEPGM1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	SUPMHD:
::	FUNCTION:	CREATE A SUP MESSAGE HEADER
::	CALLING SEQ:	JAL	R10,SUPMHD
::
::*********************************************************************

SUPMHD	HS	0
	LHL	R2,TVRBUF
	JE	LEP1			:NO SUP, ABORT
	LHI	R1,MACHNM+8000
	JAL	R9,WHWI
	JR	R10

::*********************************************************************
::
::	TABLE:		LEPDIS:
::	FUNCTION:	LEP DISPATCH TABLE
::
::*********************************************************************

LEPDIS	WC	LEP08,LEP09,LEP0A,LEP0B
	WC	LEP0C,LEP0D,LEP0E,LEP0F
	WC	LEP10,LEP11,LEP12
LEPDMX	EQ	(.-LEPDIS)/4		:NUMBER OF VALID LEP COMMANDS

::*********************************************************************
::
::	TABLE:		LEP0FT:
::	FUNCTION:	LEP0F SUBTYPE DISPATCH TABLE
::
::*********************************************************************

LEP0FT  WC	LEPHTM,LEPBRZ,LEPBRU,LEPRBJ
	WC	LEPDLL,LEPZLI,LEPSPR,LEPLSP
	WC	LEPHRJ,LEPBGL,LEPRKD,LEPAKD
	WC	LEPNOP
LEPN0F	EQ	(.-LEP0FT)/4	:NUMBER OF LEP 0F TYPE COMMANDS

	ENDMO.(LEP)
	EI	:1-KILLIT
	KILMSG(LEP)

:	***NOTHING PAST THIS POINT***

	SUBTTL	CRQ

:			 ***  ****   ***
:			*   * *   * *   *
:			*     ****  *   *
:			*   * *  *  *  **
:			 ***  *   *  ****
:					 *

::#####################################################################
::
::	MODULE:		CRQ
::
::	FUNCTION:	Circuit building, teardown, timeout, detach,
::		and trace routines.
::
::	SUBTTLS:
::		CRQ - Second half circuit building
::		Circuit building routines
::		Utilities
::		DETCIR - Handle data for 'Detached Ports'
::		TRACE - Circuit tracing logic
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA  0
	SEG  1

::*********************************************************************
::
::	SUBPROCESS:	CRQ:
::	FUNCTION:	Completes the "second half" of the circuit-building
::			process.
::	SCHEDULED:	Like LOGGER, gets called when there is something in its
::		buffer (CRQBUF) by SWITCH.  Returns to SWITCH (CRQRET) when
::		done.
::		When LEP or RTD writes a needle into a buffer, it writes
::		the buffer's index into CRQBUF via CRQALT.  CRQ makes one
::		pass through this list of buffers, servicing as appropriate.
::
::*********************************************************************

:	Write a 00 marker into CRQBUF.  When we come to it,
:	we'll know we're thru.
CRQ	HS	0
	LIS	R2,0			:PUT A 0 MARKER IN THE CRQ BUFFER

:	Come back here to put a buffer back in CRQBUF for further processing
:	next time around.
CRQ10	HS	0
	LR	R1,R2			:WRITE THE BUFFER # IN R2 INTO CRQBUF
	LIS	R2,CRQBUF		:R1=0 ON FIRST PASS, BUFFER # OTHERWISE
	JAL	R9,WHWI0,,		:WHWI0 ALLOWS USE OF BUFFER # 0

:	Come here to get the next buffer that needs service.
:	If it's our 0-marker, we're done, go to CRQRET.
CRQ20	HS	0
	LIS	R2,CRQBUF		:PROCESS NEXT BUFFER IN THE LIST
	JAL	R9,GHWI0		:BUFF IN WHICH NEEDLE IS ASSEMBLED
	LR	R2,R1
	JE	CRQRET,,		:IF THE 0 MARKER, WE'RE DONE

:	DO RANGE CHECK TO INSURE VALID BUFFER NUMBER
:	Buffer index must be in range (>=CIRZBF, <=HBUFN-8).
:	If not, crash. Else, continue at CRQ40.
	CLHI	R2,CIRZBF
	JLFS	CRQ30			:ERROR - TOO LOW
	CI	R2,HBUFN-8
	JLEFS	CRQ40			:BUFFER NUMBER O.K.
CRQ30	HS	0
	CRASH.(.CRQCR)			:Bad buffer index in CRQBUF
CRQ40	HS	0			:Buffer index OK
	STH	R2,CQNBUF		:SAVE THE NEEDLE BUFF #
	IF	NDREAD
        IF      CBZDBG                  :use debugger rings instead of buffers
        STM     R0,REGST                :save all registers
        JAL     R14,NEDDB1,,            :save needle in debugger ring
        GL      NEDDB1
        LM      R0,REGST
        EI      :CBZDBG
        EI      :NDREAD

:	If the buffer's BF is marked for "intercept" (=INCPFL),
:	go handle at CRQINT.
	IF	REBILD
	LHL	R0,BF,R2,		:IF BF=INCPFL, IT'S AN 'INTERCEPT'
	CLHI	R0,INCPFL
	JE	CRQINT
	EI	:REBILD
:	If 1st byte in buffer not a possible needle point (03xx),
:	go to garbage-handler (CRQER1).
	JAL	R8,PCIS			:TEST FOR NEEDLE POINT
	CLHI	R1,NEEDP/100		:DO WE START WITH "03
	JN	CRQER1			:GARBAGE
	JAL	R8,PCI			:GOT AN 03 - LOOK AT NEXT BYTE
:	If 1st HW in buffer not a needle point (0310), go to CRQZOG.
       IF       LOGII                   :look for LOG II needles
        CLHI    R1,NEEDBD&0FF           :needle in waiting?
        JE      CRQLWT                  :test it for timout
        CLHI    R1,NEEDHD&0FF           :complete LOG II needle
        JE      CRQLG2                  :process it
       EI       :LOGII
	CLHI	R1,NEEDP&0FF		:IS IT "10
	JN	CRQZOG			:NOT NEEDLE POINT,SOME OTHER 03-XX PAIR
:	Got a needle point (via peeks only so far).
:	It should look like this in the buffer:
:		[0310]
:		[00cc] - byte count
:		[00ll] - link count
:		[iiii]
:		[iiii] - invoice number
:		[ffff] - 8080+flags
:		[nnnn] - origin node#
:		[pppp] - requesting port#
:		[mmmm] - node list (several of these HW's)
:	Get and save off these quantities via peeks
:	(i.e., leave the buffer as is).
	JAL	R8,PCI			:GOT NEEDLE - SKIP OVER LENGTH ESCAPE
	JAL	R8,PCI			:BYTE COUNT
	STH	R1,CQNSZ		:SAVE IT
	JAL	R8,PCI			:GET ESCAPE FOR LINK COUNT
	JAL	R8,PCI			:READ LINK COUNT
	NHI	R1,7F			:MASK HIGH ORDER BIT
	STH	R1,CQNLK		:AND SAVE LINK COUNT
	JAL	R9,PHWI			:READ 4 BYTES OF INVOICE #,HW AT A TIME
	STH	R1,CQINV		: AND STORE FOR LATER
	JAL	R9,PHWI			:READ SECOND HALFWORD
	STH	R1,CQINV+2		: AND STORE FOR LATER
	JAL	R9,PHWI			:GET FLAGS
	LR	R7,R1			:SET R7=FLAGS (+8080)
	STH	R1,CQNFLG		:SAVE THEM TOO
	JAL	R9,PHWI			:READ AND SAVE REQUESTING NODE
	STH	R1,CQNODE
	JAL	R9,PHWI			:READ AND SAVE REQUESTING PORT
	STH	R1,CQPORT
      IF	MNC68K!MNTST1
	LIS	R1,N.L1TP		:this is old style needle (Log-1)
	STH	R1,CQNTYP		:store for later MNC recognition
      EI	:MNC68K!MNTST1						###ev

:	Now go through the node list, ignoring FFFF's (nodes already processed
:	by other nodes) until we find one that is not FFFF.  If the 8000 bit
:	is set, it should be us, go to CRQTRM.  If not, see if it's for an
:	active neighbor. If not (either active or a neighbor), go zap
:	the needle (CRQNNE).
CRQ50	HS	0
	LR	R5,R3			:SLEW OVER 'CREAMED' NODE #'S
	JAL	R9,PHWI			:READ NEXT NODE NUMBER
	CI	R1,0FFFF		:ALREADY PROCESSED AT ANOTHER NODE?
	JEBS	CRQ50			:IF -1, IT WAS CROSSED OFF
	TI	R1,8000			:ARE WE THE TERMINATION NODE?
	JN	CRQTRM			:YES--HIGH BIT SET 

CRQNOD	JAL	R9,FNDLNK		:FOR T-II NEIGHBOR - LOCATE LINK
      IF	MNTST1:MNC68K		:For Multi-NC, check shared mem for
	SKIPAD(MNCCRQ)			:links on other NC slots.  MNC logic
      ELSE	:NOT Multi-NC		:returns to normal CRQ exit points.##ev
	SKIPAD(CRQNNE)			:immed, NOT THERE, ZAP NEEDLE	###wjl
      EI	:MNC68K
CRQ60	TBT	KN,ALINKS		:+4 ret, FOUND THE LINK, IS IT ACTIVE?
	JE	CRQNNE			:NOPE, ZAP NEEDLE

:	Got a needle for an active neighbor.
:	Check for shrink activity on link (SHSTAT) and if true (RMAKE frozen),
:	return this buffer to CRQBUF for later handling (go to CRQ10).
	LH	R0,SHSTAT,KD		:ANY SHRINK ACTIVITY?
	JN	CRQ10			:YES - RETURN BUFFER BACK TO CRQ LIST

CRQ62	HS	0
:	EDITS COMPLETE ON DESTINATION LINK. CREAM NEIGHBOR NUMBER IN NEEDLE...
	LR	R3,R5			:POINTER TO NEIGHBOR # ENTRY IN NEEDLE
	JAL	R9,CHWI			:STORE 'FFFF', CREAMS NEEDLE ENTRY
	GL	CHWI

:	Find an available channel (JAL FNDKNC). If none, go to CRQER2.
CRQ64	HS	0
	LHL	R1,NCHN,KD		:NUMBER OF CHANNELS ON LINK
	JAL	R9,FNDKNC		:FIND AVAILABLE CHANNEL
	GL	FNDKNC			: (RETURNS CHAN# IN CHN)
	SKIPAD(CRQER2)			:immed return, OUT OF CHANNELS	###wjl

:	New channel better be available (IOTAB=0). If not,
:	go zap needle at CRQCHU.
CRQ70	HS	0
	LHL	0,IOTAB,CHN,CHN		:+4 return, IS THERE A CIRCUIT THERE?
	JN	CRQCHU			:YES, ZAP NEEDLE

:	Got a good channel.  Bump count of circuits completed (NC.CRC) and
:	build the last half of the circuit.
CRQ72	HS	0
	LIS	R3,1
	AHM	R3,NC.CRC		:COUNT CIRCUITS COMPLETED

:	BUILD LAST HALF OF CIRCUIT...
:	Set up our BF and get the speed bits from the needle into R1.
:	If the source channel is not a link neighbor, go on to CRQ90.
	STH	CHN,BF,R2,		:STORE ONGOING CHANNEL NUMBER INTO BF

	IF	CBZDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,CRQDB1,,
	GL	CRQDB1
	LM	R0,REGST		:restore regs		###sdw
	EI	:CBZDBG

	XHI	R2,4			:FLIP TO ONGOING CHANNEL'S BUFFER
	LHL	R3,BF,R2,		:READ INCOMING CHANNEL NUMBER INTO R3
	LR	R1,R7			:GET THE SPEED BITS FROM NEEDLE
	SRHLS	R1,4
	NHI	R1,3
	CLHI	R3,LNKZFL		:IS INCOMING CIRCUIT FROM A NEIGHBOR?
	JL	CRQ90			:NO, INTERNAL, SKIP NETWORK BOOKKEEPING
	CLHI	R3,LNKLFL
	JGE	CRQ90
:	Needle came from a neighbor, need to set/reset various bits for the
:	incoming channel, some of them depending on needle flags.
	SBT	R3,BPSVCP-LNKZFL/8,,	:ENABLE RMAKE SERVICE OF THIS CHANNEL
	SBT	R3,LNKBPV-LNKZFL/8,,
	RBT	R3,PRIRTY-LNKZFL/8,,
	RBT	R3,CMDCTS-LNKZFL/8,,
        lhi     r0,200
        sth     r0,bpscnt-2*lnkzfl,r3,r3 :store xmit capability
	THI	R7,NF.PRI		:TEST FOR PRIORITY CIRCUIT
	JEFS	CRQ74			:NOT A PRIORITY CIRCUIT
	SBT	R3,PRIRTY-LNKZFL/8,,
CRQ74	THI	R7,NF.CMD		:TEST FOR COMMAND CIRCUIT
	JEFS	CRQ76			:NOT A COMMAND CIRCUIT
	SBT	R3,CMDCTS-LNKZFL/8,,
:	If the needle is not headed toward a (T-II) neighbor
:	(internal termination), skip to CRQ80.  Otherwise,
:	inc the passthru count and init various bits for the out-going channel.
CRQ76	HS	0
	CLHI	CHN,LNKZFL		:IS IT TOWARDS A NEIGHBOR?
	JL	CRQ80			:NO
	CLHI	CHN,LNKLFL
	JGE	CRQ80
        thi     r7,nf.cmd               :passthrough a cmd cir?
        jefs    crq765
        lis     r0,1
        ahm     r0,nbrcmd               :count cmd cir that are passthroughs
CRQ765	LHL	R0,PASTHR		:INCREMENT PASSTHROUGH COUNT
	AIS	R0,1
	CLH	R0,MXPASS		:NEW HIGH FOR # OF PASSTHRUS?
	JLEFS	CRQMPS			:NO
	STH	R0,MXPASS		:YES, STORE THE NEW PEAK
CRQMPS	STH	R0,PASTHR
CRQ78	SBT	CHN,CHSRVD-LNKZFL/8,,	:MAKE SURE NEEDLE TRAVELS
	SBT	CHN,BPSVCP-LNKZFL/8,,
	RBT	CHN,PRIRTY-LNKZFL/8,,
	RBT	CHN,CMDCTS-LNKZFL/8,,
:	Inc NEDOUT (count of needles outstanding between CRQ and RMAKE).
:	(Can't let a shrink occur while this is true.)
	LIS	R0,1			:INCREMENT # OF NEEDLES OUTSTANDING
	AHM	R0,NEDOUT,KD		:BETWEEN CRQ AND RMAKE

	SBT	CHN,NEEDLE-LNKZFL/8,,	:NEW NEEDLE FOR THIS CHANNEL

	THI	R7,NF.CMD		:TEST FOR A COMMAND CIRCUIT
	JEFS	CRQ79			:NOT A COMMAND CIRCUIT
	SBT	CHN,CMDCTS-LNKZFL/8,,
CRQ79	THI	R7,NF.PRI		:TEST FOR PRIORITY CIRCUIT
	JEFS	CRQ80			:NO
	SBT	CHN,PRIRTY-LNKZFL/8,,	:YES - GIVE THIS CIRCUIT PRIORITY

:	Here after bookkeeping done for needle from one neighbor to another,
:	or from neighbor to internal termination.
CRQ80	HS	0
	LHL	R0,IOTAB,R3,R3		:GET THE INCOMING BUFFER NUMBER
	OR	R0,R1			:OR IN THE SPEED BITS
	STH	R0,IOTAB,R3,R3
:	Merge the speed bits (R1) from the needle flags into
:	the incoming channels IOTAB and complete the IOTAB entry
:	for the outgoing channel.  Mark the new channel active (+/-ACP),
:	report "circuit built" to CRYPTO (CRYE0B), set the inbound buffer's
:	attention flag if appropriate, and return to mainline via CRQ20.
CRQ83	HS	0
	AR	R1,R2			:MERGE SPEED BITS INTO OUTGOING BUFFER
	STH	R1,IOTAB,CHN,CHN	:AND COMPLETE THE PERMUTER TABLE ENTRY
	RBT	CHN,ACP,,		:ACTIVE PORT
::Report International Record Carrier for Inet login to Hnet link here!
	IF	T2GATE
	IF	IRC
	CHI	R3,DISZFL
	JL	CRQ84			:SKIP IF NOT USER CIRCUIT
	CHI	R3,DISZFL+NDP
	JG	CRQ84
	SHI	R3,DISZFL
	LR	R8,R3			:SAVE TO R8 FOR LATER USE
	LR	R3,CHN			:ABSOLUTE CHAN# TO HNET LINK
	JAL	R9,FCHLNK		:FIND LINK#
        GL      FCHLNK
	SKIPAD(CRQ84)			:immediate return, ERR RETURN	###wjl
        LR      R1,R0			:+4 ret, cannot index off of R0 ###sdw
	LB	R0,IRCTBL,R1		:FIND IRC VALUE FOR THIS LINK
	JE	CRQ84			:SKIP IF NO VALUE
	STB	R0,GB7REA		:STORE INTO CANNED MSG.
	STH	R8,GB7PRT		:R8 IS IRC REPORT DISP. RRT
	LHI	R1,0E00E		:MSG.# IS 14 FOR IRC LOCATN
	STH	R1,GB7INV		:Store anew message
	LIS	R1,0
	STB	R1,GB7INV+2		:(may have been previously used)
	LA	R1,GDB7M		:IRC REPORT
	LHI	R3,GDB7L		:LENGTH BYTE
	JAL	R8,DIZSMS,,		:REPORT TO INET SUP AT PORT 0
        GL      DIZSMS
CRQ84		
	EI	:IRC

	EI	:T2GATE

	LCS	R0,1
	SR	R0,CHN
	RBT	R0,ACP,,		:MARK NEGATIVE ACP AS WELL
	LHL	R0,BF,R2,		:CRYPTO - ONE OF THE PORTS
	EXHR	R0,R0			:SHIFT UP 
	XHI	R2,4
	LHL	R8,BF,R2,		:THE OTHER PORT
	AR	R0,R8
	JAL	R8,CRYPTO,,
	HC	CRYE0B			:CRYPTO MESSAGE - CRQ BUILT
	IF	INTACC&(1-T2GATE)			:###EV
	JAL	R8,AASTRT
	GL	AASTRT
	EI	:INTACC&(1-T2GATE)
CRQ110	LHL	R1,BCT,R2,		:ANYTHING IN BUFF?
	JEFS	CRQ111			:NIX, check passthroughs
	LHL	R1,BF,R2,		:SET ATTN FLAG
	SBT	R1,NFLAGS
CRQ111	LHL	R0,PASTHR               :section moved here from CRQ78  ###sdw
	CLHI	R0,NPASTH		:out of passthroughs?		###wjl
	JL	CRQ20			:no				###wjl
	LHL	R0,PTHRPD		:what was our last report?	###wjl
	JE	CRQ20			:zero=out of passthrus reported	###wjl
	JAL	R10,SUP0B		:make Resources Report to Sup	###wjl
	J	CRQ20			:RETURN TO MAINLINE

:	Here because needle did not come from a neighbor.  If from an ??
CRQ90	HS	0
	CLHI	CHN,LNKZFL
	JL	CRQ80
	CLHI	CHN,LNKLFL
	JGE	CRQ80
	J	CRQ78

:	Here from CRQ50 if we are the destination of a needle.
CRQTRM	HS	0
	NHI	R1,7FFF			:TERMINATION - SAVE THE HOST #
	LR	HN,R1
CRQTRL	STH	HN,CQHOST               :entry point for log II logons

:	If it is a REBILD needle, skip to CRQREB.
:	If for an internal circuit,
:	skip to CRQTR3 (no need to make circuit rebuildable).
	IF	REBILD
	THI	R7,NF.REB		:IS REBUILD BIT IN NEEDLE FLAGS SET?
	JN	CRQREB			:YES, THIS IS A REBUILD NEEDLE
	LHL	R0,CQNLK		:IS ORIGIN IN THIS NODE (# LNKS=0)?
	JE	CRQTR3			:YES, CIRCUIT WILL NEVER NEED REBILDING

:	We are the termination of a new circuit that may be rebildable.
:	Save the invoice number for possible REBILD use, compute and save away
:	the max history buffer size (based on gouging level and number of
:	links in circuit), set/reset various REBILD bits, and stuff a SQFX0
:	into the buffer toward the circuit origin.
	LR	R4,R2			:FORM INDEX INTO INVOICE-NUMBER ARRAY
	SRHLS	R4,1			:BASED ON CIRCUIT BUFFER NUMBER
	L	R0,CQINV		:RECOVER THE INVOICE NUMBER
	ST	R0,RINVC+HBUFN,R4,	:AND SAVE FOR POSSIBLE FUTURE REBUILD
	LR	R5,R7			:COMPUTE HISTORY BUFFER SIZE
	HSIZE(R5)			:BASED ON THROUGHPUT CLASS	###CY
	STH	R0,RHBSZ+HBUFN,R4,	:STORE AWAY FINAL HISTORY BUFFER SIZE
	SRHLS	R4,2
	SBT	R4,CRQBSY		:MARK CREATION OF A REBUILDABLE CIRCUIT
	SBT	R4,CRQEND		:MARK CREATION OF A CIRCUIT TRMINATION
	RBT	R4,SQFTMO		:CLEAR REBUILD TIMEOUT BIT	###GT
	SBT	R4,SQFTMI		:SET BIT FOR TIMEOUT COUNTER	###GT
	XHI	R2,4			:FLIP TO OTHER BUFFER		###GT
	JAL	R9,SNDFX0		:SEND OUT SQFIX WITH SEQN = 0	###GT
	XHI	R2,4			:RESTORE BUFFER INDEX

	ELSE	:NOT REBILD
	THI	R7,NF.REB		:ZAP REBUILD NEEDLES
	JN	CRQZPN

	EI	:REBILD

:	If this is a command circuit, go to CRQLEP.
CRQTR3	HS	0
	THI	R7,NF.CMD		:IS THIS A COMMAND CIRCUIT?
	JN	CRQLEP			:YES, IT'S FOR THE LEP

:	Must be for a host.  If not HST0, must be ISIS host, go to CRQHS2.
CRQHST	HS	0
	CLHI	HN,HST0			:CIRCUIT FOR A HOST
	IF	TUNL							###AL
	JE	CRQHT2			:INTERNAL CIRCUIT
	LHI	R1,(NMTNLS-1)*4		:CHECK EACH TUNNEL FOR OHST#
CRQHT1	L	KD,TNLPTR,R1,
	CLH	HN,OHST,KD
	JE	CRQTUN			:SUBROUTINE TO HANDLE NEEDLE CHECK
	SIS	R1,4			:NEXT TUNNEL?
	JGBS	CRQHT1		
	J	CRQHS2			:OTHER KIND CIRCUIT
CRQHT2	ELSE
	IF	T2GATE
	JN	CRQHSZ			:Gateway should have a match w/HST0
	ELSE
	JN	CRQHS2			:FOR A DISPATCHER HOST
	EI	:T2GATE
	EI	:TUNL

:	Needle for internal host
	IF	(1-T2GATE)		:Gateway must save Needle for now
	JAL	R9,TRUNC		:DISCARD NEEDLE
	GL	TRUNC
	L	R3,BB,R2,		:INTERNAL HOST, CHECK USER NAME
	EI	:(1-T2GATE)		:Gateway discards it next time around
					:and does not need a reload of R3
	JAL	R9,PCIE			:This is TID
	STB	R1,CQTID		:Save for Gateway Log-in purposes
	GL	PCIE
	JAL	R9,PCIE			:SKIP OVER TID AND ORIGINATION DATA
	JAL	R9,PCIE			:WHICH MAY BE ESCAPED
	JAL	R9,PCIE
	JAL	R8,PCI
	LIS	R4,0			:COUNT USERNAME CHARS
	ST	R4,XUTMP		:CLEAR TEMP USERNAME AREA
	ST	R4,XUTMP+4		:FOR 12(D) CHARS
	ST	R4,XUTMP+8
	CLHI	R1,0A1			:= "!" ?
	JNFS	CRQH10
CRQH11	JAL	R8,PCI
CRQH10	NHI	R1,7F			:REMOVE MSB
	CLHI	R1,3B			:SEMICOLON?
	JEFS	CRQH12			:YES
	CLHI	R1,0D			:CARRIAGE RETURN
	JEFS	CRQH12			:YES
	CLHI	R4,0C			:UP TO 12(D) CHARS
	JGEBS	CRQH11			:AFTER 12 CHARS, JUST SCAN FOR CR OR ;
	STB	R1,XUTMP,R4		:USER NAME FOR VALIDATION
	AIS	R4,1			:BUMP CHAR COUNT
	J	CRQH11			:LOOP UNTIL ALL USERNAME IS IN

CRQH12	LIS	R8,0			:INIT GG LIST INDEX 
CRQH13	LIS	R9,0			:INIT WORD POINTER INTO XUTMP
CRQH16	L	R1,XRAYGG+XGGNAM,R8,R9	:COMPARE TO GOODGUY LIST
	GL	XRAYGG			:###wjl
	NI	R1,7F7F7F7F		:CLEAR MSB
	C	R1,XUTMP,R9		:GET USERNAME FROM NEEDLE
	JNFS	CRQH14			:NAME DOESN'T THIS MATCH ENTRY
	AIS	R9,4			:BUMP FW INDEX INTO XUTMP
	CR	R9,R4			:ANY MORE FWS OF USERNAME IN XUTMP
	JGEFS	CRQH15			:NAME MATCH FOUND
	JBS	CRQH16			:CHECK MORE OF THIS ENTRY
CRQH14	AHI	R8,XGGSIZ		:BUMP GGLIST INDEX
	CLHI	R8,XGGLEN		:END OF GGLIST?
	GL	XGGLEN			:###wjl
	JL	CRQH13			:NO, CHECK NEXT GGLIST ENTRY
       IF	T2GATE
	J	GCRTRM			:If no match and Gateway - user circuit
       ELSE	:not T2GATE		:No Kernel stuff for Gateway
	J	CRQHS1			:NOT AN INTERNAL HOST
       EI	:T2GATE

CRQH15	LR	R4,R8			:BOUND FOR INTHST PROCESSING
					:SET UP INTUSR AS GGLIST INDEX

CRQHS5	LHI	CHN,INTZFL		:FOR INTERNAL HOST
	LHI	R1,TINTCH		:GET TOTAL # OF INTERNAL HOST CHANNELS
CRQHS4	JAL	R9,FNDCHN		:AND FIND AVAILABLE CHANNEL
	GL	FNDCHN
	SKIPAD(CRQDL1)			:immed return - NO,NONE AVAILABLE###wjl
	LR	R1,CHN			:+4 return - FOUND ONE, GET
	SHI	R1,INTZFL		:RELATIVE INT HOST INDEX
	SLLS	R1,2			:FORM FW INDEX
	ST	R4,INTUSR,R1		:STORE USERNAME
	JAL	R9,TRUNC		:EMPTY NEEDLE BUFF UP TO CURRENT POINTR
       IF      T2GATE&LOGII             :LOG II converted needle to XRAY?
        THI     R7,NF.LG2               :Needle body data will follow
        JNFS    CRQH23                  :so don't insert anything before it.
       EI       :T2GATE&LOGII
	LHL	R1,BCT,R2,		:ANYTHING IN THE BUFFER?!
	JNFS	CRQH23			:YES, LEAVE IT THERE TO SET ATTN FLAGS
	LHI	R1,80			:OTHERWISE STORE A NULL IN THE BUFFER
	JAL	R8,WCI,,		:TO CAUSE ATTN FLAGS TO BE SET
CRQH23	JAL	R8,NEDTIM		:TEST NEEDLE TIME, RECORD CIRCUIT TIME
        IF      INTACC                  :changed from T2GATE&INTACC     ###sdw
	JAL	R8,AASTRT		:Begin internal host accounting
	EI	:INTACC			:###EV
:       Following IIX stuff is since IIX interfaces will not send any data
:       until they receive the select dialect.  Note that gateway XRAY will
:       still not properly handle any further IIX msgs, but that should not
:       have much effect on the user.                           ###sdw
       IF       T2GATE                  :gateway is IIX and must do IIX negoti
        LR      R4,R4                   :do this only for XRAY users
        JE      CRQ70
        LHL     R0,CQNFLG               :test if IIX origination
        THI     R0,NF.SMC               :                               ###sdw
        JE      CRQ70                   :not IIX, nothing to do
        XHI     R2,4
        LHI     R1,01F6                 :the start IIX signal
        JAL     R9,W2CI,,
        LHI     R1,8080                 :the select dialect
        JAL     R9,W2CI,,
        LHI     R1,8081                 :the ascii dialect (just ascii data)
        JAL     R9,W2CI,,
        LHI     R1,01F7                 :the TIIX signal
        JAL     R9,W2CI,,
        XHI     R2,4
       EI       :T2GATE
	J	CRQ70			:CONTINUE WITH CIRCUIT BUILDING
CRQDL1	LIS	R0,0
	JAL	R8,CRYPTO,,
	HC	CRYE2E			:MESSAGE - OUT OF INTERNAL HOST PORTS
	IF	ACCT			:###EV
	L	R1,CQINV		:Supply inv # to accounting
	LI	R0,AALR07		:and zap reason for addendum
	JAL	R8,AANCZP		:and send to Sup
	GL	AANCZP
	EI	:ACCT		
	J	CRQZPN

CRQHS1	IF	1-T2GATE
	LHI	R1,NKU			:# OF KERNEL PORTS
	LHI	CHN,KERZFL
	JAL	R9,FNDCHN		:LOCATE A PORT
	SKIPAD(CRQER3)			:immed return - ALL OUT		###wjl
	LHI	R1,-KERZFL,CHN		:SET NEW LOG FLAG
	SBT	R1,KERNWL,,
:	FIRST 4 CHARS IN BUFFER ARE TID, 80, 8000+ORIG HOST. IF ORIG
:	HOST IS 04-07, KERNEL WILL INTERPRET AS NETWORK CHARACTERS SINCE
:	COMMAND CIRCUITS ONLY ESCAPE 00-03. THEREFORE, IF ORIG HOST IS
:	04-07, WE MUST INSERT AN ESCAPE...

:	COPY USER NAME STRING TO LINEAR ARRAY
	LIS	R7,0			:BYTE INDEX, HAS COUNT WHEN DONE
CRQH10	LH	R0,BCT,R2,
	JEFS	CRQH20			:BUFFER EMPTY - USER NAME COPIED
	JAL	R8,GCI,,
	STB	R1,KERUSR,R7,		:PUT USER NAME IN HOLD AREA
	AIS	R7,1
	JBS	CRQH10

:	USER NAME STRING COPIED
CRQH20	LIS	R6,0
	STB	R6,KERUSR,R7,		:DELIMIT USER NAME WITH NULLS
	STB	R6,KERUSR+1,R7,
	LHL	R1,KERUSR,,
	JAL	R9,WHWI,,		:RESTORE FIRST 2 BYTES BACK IN BUFFER
	LB	R1,KERUSR+2,,
	JAL	R8,WCI,,
	LB	R1,KERUSR+3,,		:GET CRITICAL BYTE
	JEFS	CRQH22			:IF ESCAPE, LO-ORDER 00-03 - O.K.
	CLHI	R1,8
	JGEFS	CRQH22			:VALUE ABOVE ESCAPED CHARACTER
:	WE GOT A 04-07...INSERT ESCAPE FOR KERNEL
	EXBR	R1,R1
	JAL	R8,WCI,,			:WRITE 00 (ESCAPE)
	EXBR	R1,R1
CRQH22	JAL	R8,WCI,,
	SIS	R7,4			:4 BYTES ALREADY STORED
	LIS	R6,4
CRQH30	LB	R1,KERUSR,R6,
	JAL	R8,WCI,,		:RESTORE USER NAME BACK IN BUFFER
	AIS	R6,1
	SIS	R7,1
	JGBS	CRQH30
	LHL	R7,CQNFLG		:RESTORE NEEDLE FLAGS IN R7
	J	CRQ70

	EI	:1-T2GATE

CRQHS2	HS	0			:FOR HOST OTHER THAN HST0
	LR	R1,HN			:DO WE KNOW THIS GUY
	JAL	R9,FNDHST
	SKIPAD(CRQHSZ)			:immediate return, NO, ZAP	###wjl

:	TEST FOR HOST OUT OF PORTS
	LHL	R1,HSTPTA,HN,HN		:+4, GET # OF PORTS AVAIL, PER LAST MSG
	JE	CRQER6			:NONE, HANDLE HOST OUT OF PORTS

	LHI	R1,NDP-1		:MUST BE A DISPATCHER HOST
	LHI	CHN,DISZFL+1
	JAL	R9,FNDCHN
	SKIPAD(CRQER4)			:immed - OUT OF DISPATCHER PORTS###wjl
	LHI	R1,-DISZFL,CHN		:+4 return - RELIEVE BACKPRESSURE
	SBT	R1,DISBPV
	SBT	R1,DISBPX               :don't let it send BP relief yet
        lhl     r0,cqhost               :get host number
        sth     r0,dhstix,r1,r1         :store it for probe trace cmd
	LHI	R0,INXLIM		:AND GIVE IT XMIT CAPACITY
	STH	R0,DIXLIM,R1,R1
       IF       LOGII
        LHL     R0,CQNFLG               :get flags
        THI     R0,NF.LG2               :is this a converted needle
        JE      CRQHS3
        LHL     R2,CQNBUF               :need our buffer back
        JAL     R9,G2CI                 :remove converted needle
        JAL     R9,G2CI                 :get len (all we want is needle body)
        LR      R0,R1
        SIS     R0,4                    :removed 0310 and 2 byte len
        JAL     R8,RTBFTS               :converted needle gone
        LHI     R1,NEEDCV               :tell DISPI LOGII ISN follows needle
        JAL     R8,WCD                  :needle body may not all be in yet
        EXBR    R1,R1
        JAL     R8,WCD
       EI       :LOGII
CRQHS3	LHL	R2,CQNBUF		:RESTORE NEW CIRCUIT BUFFER INDEX
	JAL	R8,NEDTIM		:COMPUTE NEEDLE TIME, SET CIRCUIT TIME
	J	CRQ72			:BUILD LAST HALF OF CIRCUIT
					:FOR SUPERVISOR STATISTICS

CRQHSZ	LR	R0,HN			:NO SUCH HOST - ZAP
	JAL	R8,CRYPTO,,
	HC	CRYE0D
	J	CRQZPN
:       CRQLWT  In waiting (received head char but not end of needle).
:               Time out needle after 120seconds since LOG II needle
:               passes like data and could get gobbled like data.

       IF       LOGII
CRQLWT  LR      R1,R2                   :get buftim
        SRLS    R1,1
        L       R0,BUFTIM,R1,
        AI      R0,RATE*$A120           :120 seconds after arrival of head
        C       R0,FASTC,,              :if no body yet, probably never
        JG      CRQ10                   :put back in CRQ buffer and wait
        J       CRQZPN                  :otherwise zap it

:       CRQLG2  Process a LOGII Needle.  Get and store CQNFLG, CQINV,
:               CQNLK.  If passthrough then find the link and jump to
:               CRQ64.  If term then find host, CQHOST and go CRQHS2.
:               Remember we are not a LOG II host so LOGII needles are
:               not for XRAY or KERNEL.


CRQLG2	HS	0
      IF	MNC68K!MNTST1
	LHI	R4,N.L2TP		:this is LogII Needle type
	STH	R4,CQNTYP		:record for later MNC use
      EI	:MNC68K							###ev
        LHI     R4,ID.NCF               :get LOGII form of flags
        JAL     R7,X4PARS,,             :find flags
        SKIPAD(CRQZPN)                  :error, zap it
        JAL     R9,PCIE,,               :unused count
        JAL     R9,PCIE,,               :flags
        STH     R1,NEDFLG               :save in case internal and such
        JAL     R7,LPAFLG               :convert to LOGII flags
        STH     R4,CQNFLG               :save it
        LHI     R4,ID.INV               :get invoice number
        JAL     R7,X4PARC,,             :get it
        SKIPAD(CRQL06)                  :better be there
        JAL     R7,X4GTNM,,
        GL      X4GTNM
        ST      R4,CQINV
CRQL06  LHL     R0,NEDFLG               :internal have no links
        THI     R0,L2F.IC               :internal?
        JN      CRQL08
        LHI     R4,ID.LNK               :number of links
        JAL     R7,X4PARC,,
        SKIPAD(CRQL08)                  :0 if not there
        JAL     R7,X4GTNM,,             :get the number
        JFS     CRQL09
CRQL08  LIS     R4,0                    :internal has no links
CRQL09  STH     R4,CQNLK
        LR      R4,R4
        JE      CRQLTM                  :no links is a log II termination
        LHI     R4,ID.NNL               :where circuit to go to
        JAL     R7,X4PARC,,
        SKIPAD(CRQLTM)                  :not there then LOGII term
        LR      R7,R0                   :len of list
        JAL     R9,PCIE                 :get id 04 of octet string
        JAL     R9,PCIE                 :get len of first number in list
        LR      R0,R1                   :len of node number
        LR      R5,R0
        AIS     R5,2                    :len of node number element and ID
        SR      R7,R5                   :new len of needle list element
        LIS     R4,0
CRQL14  SLLS    R4,8
        JAL     R9,PCIE
        AR      R4,R1                   :node # could be 1 or 2 bytes
        SIS     R0,1
        JGBS    CRQL14
        LR      R1,R4                   :setup FNDLNK
        JAL     R9,FNDLNK               :returns KD, KN
 IF	MNTST1:MNC68K		:For Multi-NC, check shared mem for
	SKIPAD(MNCCRQ)			:links on other NC slots.  MNC logic
      ELSE	:NOT Multi-NC		:returns to normal CRQ exit points.##ev
	SKIPAD(CRQNNE)			:immed, NOT THERE, ZAP NEEDLE	###wjl
      EI	:MNC68K
        TBT     KN,ALINKS               :active link
        JE      CRQNNE                  :neighbor not there
        LH      R0,SHSTAT,KD            :can't pass while shrinking link
        JN      CRQ10                   :put back in CRQ buffer
:       now remove that node number from list.  The list is the first element
:       in the needle.
	JAL	R9,L2CHWI		:needle houskeeping
        J       CRQ64                   :return to mainline CRQ

:       CRQLTM  LOG II terminations.  Just get termhost into HN and goto
:               mainline LEP.  Remember XRAY is not a LOG II host so it
:               can't be for an internal host.

CRQLTM  LHI     R4,ID.THS               :find term host
        JAL     R7,X4PARC,,
        SKIPAD(CRQZPN)                  :if not there what else to do with it?
        JAL     R7,X4GTNM
        LR      HN,R4
       IF       1-T2GATE                :when T2GATE circuit may goto XRAY
        LHL     R7,CQNFLG
        J       CRQTRL
       ELSE     :T2GATE
        L       R3,X4T.LB+X4TBBG,,      :get address after NCN MO's len
        JAL     R9,TRUNC                :remove it
        LHL     R4,X4T.LN+X4TBBG,,      :how many chars long is NCN head
CRQLT1  JAL     R9,GCIE
        SIS     R4,1
        JGBS    CRQLT1                  :eat needle head
        JAL     R8,PCIS                 :now parse needle body
        CLHI    R1,03                   :better be needle body char pair
        JN      CRQZPN
        JAL     R8,PCI
        CLHI    R1,NEEDBD&0FF           :needle body
        JN      CRQZPN
        LHI     R4,ID.UNM               :find username to see if Internal host
        JAL     R7,X4PARS,,
        SKIPAD(GL2TRM)                  :if not there then not for xray
        LIS     R4,0
        ST      R4,XUTMP                :clear uname temp area
        ST      R4,XUTMP+4
        ST      R4,XUTMP+8
CRQLT3  JAL     R9,PCIE                 :get first char of uname
        NHI     R1,7F
        STB     R1,XUTMP,R4             :save username for XRAY check
        AIS     R4,1
        SIS     R0,1                    :count of how long setup by X4PARS
        JLEFS   CRQLT4
        CLHI    R4,0C                   :only room for 12 chars
        JLBS    CRQLT3
CRQLT4  LIS     R8,0                    :this is same as CRQH12-CRQH15
CRQLT5  LIS     R9,0                    :counter into uname
CRQLT6  L       R1,XRAYGG+XGGNAM,R8,R9  :genned in xray unames
        NI      R1,7F7F7F7F             :have high bits set
        CI      R1,XUTMP,R9             :word of uname match?
        JNFS    CRQLT7
        AIS     R9,4
        CR      R9,R4                   :compare all of uname?
        JGEFS   CRQLT8                  :found uname for XRAY
        JBS     CRQLT6
CRQLT7  AHI     R8,XGGSIZ               :next xray entry
        CLHI    R8,XGGLEN
        JL      CRQLT5
        J       GL2TRM                  :then uname is for normal gateway

CRQLT8  LR      R7,R8                   :save XGG block pointer
        JAL     R9,G2CI                 :remove needbd char pair
        JAL     R9,GHWI                 :get length of body
        LR      R0,R1
        JAL     R8,RTBFTS               :eat body
        LR      R4,R7                   :setup r4,r7 for CRQHS5
        LHL     R7,CQNFLG               :prepare to go to normal inthst logic
        OHI     R7,NF.LG2               :ensure converted bit is reset
        XHI     R7,NF.LG2
        STH     R7,CQNFLG
        J       CRQHS5                  :and normal inthst processing


       EI       :T2GATE

       EI       :LOGII

:       For LEP just eat the needle and then connect up.  First thing
:       following the needle will be the takeover command.
CRQLEP	JAL	R9,TRUNC		:LEP CIRCUIT - CLEAR NEEDLE
	LHI	R1,NLQ			:# OF COMM CIRCS
	LHI	CHN,LEPZFL		:BASE COMMAND CIRCUIT
	JAL	R9,FNDCHN		:GET A LEP PORT
	SKIPAD(CRQER5)			:immed - OUT OF COMMAND PORTS	###wjl
	JAL	R8,NEDTIM		:+4 return - RECORD TIME
	SBT	CHN,TRCHAN,,		:ENABLE CHARACTER TRACE OF COMMAND CIRC
	J	CRQ70			:BUILD CIRC

:	SEND NEEDLE ACK TO SUPERVISOR
CRQCHU	HS	0			:CHANNEL IN USE - ZAP NEEDLE
	IF	ACCT		:###EV
	CLHI	HN,HST0			:Is this for an internal host?
	JN	CRQCH1			:If not dont do accounting
	L	R1,CQINV		:Supply inv # to accounting routine
	LI	R0,AALR07		:Provide zap reason
	JAL	R8,AANCZP		:and send to Sup
CRQCH1	HS	0
	EI	:ACCT		
	JAL	R10,SWRCHU		:FORMAT CHANNEL IN USE NODE REPORT,
					:CIRCUIT LIFETIME NODE REPORT, CRYPTO
	J	CRQZPN


CRQNNE	HS	0			:NO SUCH NEIGHBOR - ZAP CIRCUIT
:	SEND NODE REPORT FOR 'NO NEIGHBOR'
	LHI	R0,NR.NNE
	STH	R0,SUPMBF		:REPORT TYPE
	OHI	R1,8000
	STH	R1,SUPMBF+2		:NEIGHBOR NUMBER IN ERROR
	LH	R0,CQNFLG
	STH	R0,SUPMBF+4		:NEEDLE FLAGS
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP LOG
	JFS	CRQZPN			:ZAP CIRCUIT

CRQZPS	LHI	R1,ZAPPS		:SOFT ZAPPER
	JFS	CRQZP2

CRQZPN	HS	0			:CIRCUIT BUILDING ERROR - ZAP IT
	LIS	R1,1
	AHM	R1,NC.CRZ		:COUNT CRQ CIRCUIT BUILDING ERRORS
	LHI	R1,ZAPPH		:HARD ZAPPER

CRQZP2	LHL	R2,CQNBUF
	XHI	R2,4			:ZAP NEEDLE CIRCUIT (NOTE ZAPPER...
	JAL	R9,ZAPX			:...TRAVELS TOWARDS ORIGIN)
	GL	ZAPX
	J	CRQ20

:	ZAPPER, GOBBLER OR OTHER 03-XX PAIR DETECTED IN CRQ BUFFER
:	INSTEAD OF A NEEDLE POINT

CRQZOG	HS	0
	LHI	R0,300
	OR	R0,R1			:FORM THE OFFENDING CHARACTER PAIR
	JAL	R8,CHFLNK,,		:GET THE NEIGHBOR # FROM THE CHANNEL
	GL	CHFLNK
	SKIPAD(CRQZ02)			:immed return, nghbr isn't there###wjl
	SKIPAD(CRQZ04)			:+4 return, internal termination###wjl
CRQZ02	STH	R3,CRYSBF+2		:+8 return - STORE IT AWAY
	JAL	R8,CRYPTO,,		:REPORT NEEDLE GOBBLED TO XRAY
	HC	CRYE08
	THI	R1,-8			:IS IT A ZAPPER?
	JN	CRQZPN			:GOBBLER OR ??, ZAP TOWARDS CIRC SOURCE
	JAL	R9,ZAPV			:ZAP SECOND HALF OF CIRCUIT...
	LIS	R1,1
	AHM	R1,NC.CRZ		:AND COUNT CRQ ERROR
	J	CRQ20

CRQZ04	LHI	R3,MACHNM		:internal termination		###wjl
	J	CRQZ02			:				###wjl

:	GET HERE FOR A VARIETY OF CIRCUIT BUILDING ERRORS. MAKE
:	CRYPTOGRAM AND ZAP CIRCUIT.

CRQER1	HS	0			:NEEDLE POINT GARBAGE
	LR	R0,R1			:SAVE FIRST BYTE OF GARBAGED NEEDLE
	EXBR	R0,R0
	JAL	R8,PCI,,		:GET NEXT BYTE AND
	OR	R0,R1			:COMBINE WITH FIRST
	STH	R0,CQNLK		:SAVE REG 0
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE1A			:NEEDLE POINT GARBAGE
	LHL	R0,CQNLK		:RESTORE REG 0
	CLHI	R0,01FD			:IS IT BLACK BALL ?
	JE	CRQZPN			:YES, ZAP CIRCUIT
	CRASH.(.CRQC0)
CRQER2	HS	0			:OUT OF CHANNELS TO  T-II LINK
	JAL	R8,BUBBLE		:ALLOCATE ANOTHER 1/2 PAGE TO LINK
	SKIPAD(CRQE22)			:CAN'T DO IT - OUT OF 1/2 PAGES	###wjl
	LHL	R2,CQNBUF		:+4 return, RESTORE BUFFER NUMBER
	J	CRQ64			:SUCCEEDED - CONTINUE CIRCUIT BUILD
CRQE22	LHL	R0,NDID,KD		:GET NEIGHBOR NUMBER		###wjl
	STH	R0,CRYSBF+2		:SAVE FOR CRYPTO
	LIS	R0,0			:NO DATA
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE19			:OUT OF CHANNELS
	J	CRQZPN			:ZAP CIRCUIT

CRQER3	HS	0			:OUT OF KERNEL PORTS
	LIS	R0,0
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE1B			:NO KERNEL PORTS
	IF	INTACC			:###EV
	L	R1,CQINV		:Supply inv # to accounting
	LI	R0,AALR07		:and zap reason for addendum
	JAL	R8,AANCZP		:and send to Sup
        GL      AANCZP                  :                               ###sdw
	EI	:INTACC

:	SET UP TO DETACH CIRCUIT. DETACH TYPE 03 INFORMS USER OF NO
:	KERNEL PORTS.
	LIS	R1,3
	JAL	R8,WCI,,		:NEEDLE POINT TRIGGERS 'DETCIR' TO
	LHI	R1,NEEDP&0FF		:SEND TEXT, START TIMER
	JAL	R8,WCI,,
	LR	R7,R2			:(CRQE4B EXPECTS BUFFER INDEX IN R7)
	LIS	R1,3			:DETACH TYPE
	J	CRQER7			:GO DETACH CIRCUIT

:	OUT OF DISPATCHER PORTS -- SEND NODE REPORT, CLOSE ACCOUNTING,
:	AND DETACH CIRCUIT...
CRQER4	HS	0
	LR	R7,R2			:SAVE BUFFER #
	LI	R10,NR.ODP*10000+NDP
	ST	R10,SUPMBF		:NODE ERR # AND # OF DISPI PORTS
	LH	R10,CQHOST		:GET HOST # (FROM NEEDLE)
	OHI	R10,8000		:SET MSB ON HOST #
	STH	R10,SUPMBF+4
	JAL	R10,SUP12		:SEND MESSAGE TO SUP
	L	R1,CQINV		:GET INVOICE NUMBER
	OI	R1,070000000		:MAKE IT A TYPE '07' RECORD
	NI	R1,07FFFFFFF
	JAL	R10,SUP14A		:SEND NODE CODE GEN'D 07-TYPE
	GL	SUP14A			: ACCOUNTING MSG

	LIS	R1,0
	STH	R1,DETTSV		:SAVE DETACH MESSAGE TYPE
	LI	R1,0E000000F		:ACCOUNTING MSG
CRQE4B	JAL	R10,SUP14A		:SEND ACCOUNTING ADDENDUM, VALUE=0F
:	CLOSE ACCOUNTING FOR THIS SESSION. SEND TYPE B MSG, CHARACTER
:	COUNT ZERO.
	LI	R1,0B0000000		:FINAL CHAR COUNT (0)
	JAL	R10,SUP14A		:NODE CODE GENERATED ACCOUNTING MSG

	LR	R2,R7			:RESTORE BUFF #

:	DETACH CIRCUIT. FIND AVAILABLE CHANNEL TO DISPATCH PROCESS IN CIOTAB 
:	(STARTING WITH DETZFL). CONNECT NETWORK HALF-CIRCUIT TO DETACH PROCESS
:	FOR SENDING APPROPRIATE TEXT TO USER, BOUNCING YELLOW BALL, AND TIMING
:	OUT CIRCUIT IF NO ORANGE BALL RETURNED. TEXT TO USER IS DETERMINED BY
:	VALUE STORED IN DETMTY BYTE ARRAY.

	L	R4,DETACP,,		:GET DETACH PROCESS ACTIVE PORT ARRAY
	JFFO	R4,CRQE4A		:ANY PORTS AVAILABLE?
	J	CRQZPN			:NO, JUST ZAP NEW CIRCUIT
CRQE4A	HS	0			:FOUND ROOM TO DETACH THIS ONE
	LH	R0,DETTSV		:GET DETACH MESSAGE TYPE
	STB	R0,DETMTY,CHN		:AND SAVE IT
	AHI	CHN,DETZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER
	J	CRQ70			:CONNECT IT UP

CRQER5	HS	0			:OUT OF COMMAND PORTS
	L	R0,CQINV		:INVOICE NUMBER
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE17			:NO COMMAND PORTS
	J	CRQZPN			:ZAP CIRCUIT

CRQER6	HS	0			:HOST OUT OF PORTS
	LR	R7,R2			:SAVE BUFFER #
	L	R0,CQINV		:INVOICE NUMBER
	JAL	R8,CRYPTO,,		:REPORT...
	HC	CRYE2F			:ISIS HOST OUT OF PORTS

:	SEND ACCOUNTING RECORDS TO CLOSE ACCTING ON THIS CIRCUIT

	L	R1,CQINV		:GET INVOICE NUMBER
	OI	R1,070000000		:MAKE IT A TYPE '7' ACCT REC
	NI	R1,07FFFFFFF
	JAL	R10,SUP14A		:SEND 07/INVOICE #

	LIS	R1,1
CRQER7	STH	R1,DETTSV		:SAVE DETACH MESSAGE TYPE
	LI	R1,0E0000007		:0E=CODE,0=MSG,00=SUB-MSG,0007=VALUE,
:	ACCOUTING ADDENDUM TO INDICATE HOST OUT OF PORTS
	J	CRQE4B			:SEND AND FINISH OFF

	IF	REBILD

:	HERE TO PROCESS THE ARRIVAL AT THE TERMINUS OF A REBUILD
:	NEEDLE.

CRQREB	JAL	R9,PHWI,,		:GET SEQN OF CHAR WE SHOULD SEND
	STH	R1,CQXSEQ		:AND SAVE IT
	JAL	R9,PHWI,,		:				###GT
	STH	R1,CQXSEQ+2
	JAL	R9,PHWI,,		:GET SEQN OF CHAR WE'LL GET FIRST
	STH	R1,CQVSEQ		:SAVE THAT, TOO
	JAL	R9,PHWI,,		:				###GT
	STH	R1,CQVSEQ+2
	JAL	R9,TRUNC		:DISCARD NEEDLE DATA UP TO CURRENT 'R3'
	JAL	R9,FNDCRQ		:LOCATE CIRCUIT BASED ON INVOICE NUMBER
	GL	FNDCRQ
	SKIPAD(CRQRE1)			:FAILED, MAKE REPORT, ZAP REBUILD CIRC

:	FNDCRQ SUCCESSFUL. R6 (XBF) CONTAINS THE ORIGINAL OUTBOUND BUFFER
:	NUMBER AND R7 (HBF) CONTAINS THE CORRESPONDING HISTORY BUFFER NUMBER.
:	R2 CONTAINS THE NEEDLE BUFFER NUMBER.
CRQRE8	LHL	R5,CQNFLG		:+4 return, RECOMPUTE SIZE OF HIST BUFF
	HSIZE(R5)			:BASED ON SPEED BITS		###CY
	STH	R0,RHBSZ,HBF,		:STORE AWAY NEW HISTORY BUFFER SIZE
	XHI	R2,4			:FLIP OVER TO OUTGOING BUFFER
	LHL	R1,BF,R2,		:GET THE NEEDLE-ENTRY CHANNEL NUMBER
	SRHLS	R5,1			:POSITION SPEED BITS FOR IOTAB  ###CY
	AHM	R5,IOTAB,R1,R1		:SET ENTRY CHAN PERMUTER TBL SPEED BITS
	LR	R2,XBF			:R2=ORIGINAL OUTBOUND BUFFER FOR CSETUP
	JAL	R8,CSETUP		:SET UP REBUILD PARAMETERS FOR CRYPTO
	JAL	R8,CRYPTO,,
	HC	CRYE6A			:MESSAGE - CHAN STATUS
	JAL	R9,CSTUP2		:2ND PORTION OF MESSAGE		###GT
	L	R0,CQVSEQ		:GET CQVSEQ
	ST	R0,CRYSBF		:AND SAVE FOR XRAY
	L	R0,CQXSEQ		:GET CQXSEQ FOR XRAY		###GT
	JAL	R8,CRYPTO,,		:CRQREB REPORT
	HC	CRYE67
CRQREA	JAL	R9,MERGE		:COPY H-BUF TO FRONT OF OUT-BUF.
	GL	MERGE			: CLEAR H-BUF
	LR	R2,XBF			:PURGE REDUNDANT DATA IN OUTBOUND BUFF
	L	R4,XSEQN,XBF,		:SEQUENCE # OF FIRST CHAR IN OUT-BUF
	L	R5,CQXSEQ		:FIRST CHAR OTHER END WANTS TO RECEIVE
	JAL	R9,PURGE		:RECONCILE THEM BY DISCARDING BYTES
	GL	PURGE			: IF NEEDED
	SKIPAD(CRQRE2)			:immed, LOST DATA - DON'T REBUILD, ZAP
	L	R0,XSEQN,R6,		:+4, UPDATE SEQN OF HISTORY BUFF###GT
	ST	R0,HSEQN,R7,

:	NOW PROCESS THE OTHER BUFFER PAIR - THE ONE ASSIGNED TO THE
:	REBUILD NEEDLE. IT'S INBOUND BF WILL BE SET TO 'INCPFL' TO
:	INDICATE INTERCEPT MODE. HISTORY DATA FORM THE OTHER END WILL
:	ACCUMMULATE HERE UNTIL THE FIRST NEW CHARACTER ARRIVES.

	LHL	R2,CQNBUF		:INCOMING BUFF ASSIGNED TO REBILD NEEDL
	LR	R7,R2			:COMPUTE IT'S ASSOCIATED HISTORY BUFFER
	SRHLS	R7,1
	NHI	R7,-4
	AI	R7,HBUFN
	XHI	XBF,4			:FORM ORIGINAL INCOMING BUFFER NUMBER
	STH	R6,RBIBUF,R7,		:SAVE IT INDEXED ON NEEDLE HISTORY BUFF
	SRHLS	R6,3			:MAKE CRQ INDEX			###CY
	SBT	R6,REBTMI		:REFRESH CRQ TIMEOUT		###CY
	RBT	R6,REBTMO		:REFRESH CRQ TIMEOUT		###CY
	SLHLS	R6,2			:				###CY
	AI	R6,HBUFN		:MAKE HISTORY BUFFER INDEX	###CY
	STH	R6,RBHIS,R7,		:SAVE IN NEEDLE HIST BFR DESCRIPTOR##CY
	L	R0,CQINV		:GET INVOICE NO.		###CY
	ST	R0,RBKEY,R7,		:SAVE IN NEEDLE HIST BFR DESCRIPTOR##CY
	L	R1,CQVSEQ		:GET SEQN OF CHAR THAT FOLOWS NEEDLE#GT
	ST	R1,RBVSEQ,R7,		:SAVE IT INDEXED ON NEEDLE HISTORY BUFF
	AM	R1,VSEQN,R2,		:INIT SEQ# TO EXPECT HISTORY BUFF DATA
	LHI	R1,INCPFL		:SO CRQ KNOWS WE'RE INTERCEPTING
	STH	R1,BF,R2,
	LIS	R3,1
	AHM	R3,NC.CRC		:INCREMENT COUNT OF CRQ'S COMPLETED
	LHL	R7,CQNFLG		:GET NEEDLE FLAGS BACK
	XHI	R2,4
	LHL	R3,BF,R2,		:CHANNEL # OF ENTRY (LINK) CHANNEL
	XHI	R2,4
	SBT	R3,BPSVCP-LNKZFL/8,,
	SBT	R3,LNKBPV-LNKZFL/8,,	:INSURE CHANNEL SERVICE
	RBT	R3,PRIRTY-LNKZFL/8,,
	RBT	R3,CMDCTS-LNKZFL/8,,
        lhi     r1,200
        sth     r1,bpscnt-2*lnkzfl,r3,r3 :ensure it has xmit capability
	THI	R7,NF.PRI		:PRIORITY CIRCUIT?
	JEFS	CRQRE0			:NO
	SBT	R3,PRIRTY-LNKZFL/8,,	:YES - INDICATE SUCH
CRQRE0	THI	R7,NF.CMD		:COMMAND CIRCUIT?
	JE	CRQ10			:NO
	SBT	R3,CMDCTS-LNKZFL/8,,	:YES
	J	CRQ10			:WAIT FOR INTERCEPT LOGIC TO HANDLE

CRQRE1	LR	R0,R0			:FNDCRQ FAILURE - INVOICE# OR STUB?
	JE	CRQRE9			:R0=0, FNDCRQ COULDN'T MATCH INVOICE #

:	GOT A REBUILD NEEDLE FOR AN APPARENTLY GOOD CIRCUIT. PRESUME THAT
:	A FAT ZAPPER IS ON IT'S WAY AND WILL EVENTUALLY ARRIVE. CLEAR OUT
:	THE ORIGINAL CIRCUIT AND MERGE BACK INTO REBUILD LOGIC. NOTE THAT
:	WE MAY GET SOME 'DATA ON UNASSIGNED CHANNEL' ON THE OLD CIRCUIT

	SIS	R6,4			:GET THE ORIGINAL INCOMING BUFER
	LHL	R0,BF,R6,		:GET THE TERMINATING CHANNEL NUMBER
	JAL	R8,CRYPTO,,		:TELL XRAY
	HC	CRYE6C			:MESSAGE = EARLY REBUILD NEEDLE
	LR	R2,R6			:COPY ORIGINAL INCOMING BUFFER	###CY
	LHI	R1,ZAPPS		:SIMULATE ARRIVAL OF A FAT ZAPPER##CY
	JAL	R10,TRCIRC		:AND USE COMMON TEARDOWN LOGIC	###CY
	JAL	R9,FNDCRQ		:CHECK TO SEE IF CRQ IS STILL THERE##CY
	SKIPAD(CRQRE9)			:NOT REBUILDABLE ACCORDING TO TRCIRC#CY
	J	CRQRE8			:+4, HANDLE STUB IN NORMAL FASHION###CY

CRQRE9	L	R0,CQINV		:UNKNOWN REBUILD (INVOICE #)
	JAL	R8,CRYPTO,,
	HC	CRYE13			:MESSAGE - REBUILD REJECT
	J	CRQZPN			:ZAP BACKWARDS ALONG NEEDLE PATH

CRQRE2	XHI	R6,4			:LOST DATA - INBOUND BUFF #
CRQR22	LHL	R0,BF,R6,		:TERMINATION #
	JAL	R8,CRYPTO,,
	HC	CRYE14			:MESSAGE - REBUILD DATA LOST
	J	CRQZPN			:ZAP THE CIRCUIT - NOT SALVAGABLE
CRQRE3	LR	R6,R7			:LOST DATA
	JBS	CRQR22
CRQRE4	JAL	R8,CRYPTO,,		:LOST CRQ WHILE IN INTERCEPT STATE###CY
	HC	CRYE6D
	J	CRQZPN			:ZAP BACK TOWARDS ORIGIN	###CY

:	INTERCEPT -- WAITING FOR HISTORY DATA TO ARRIVE FROM SOURCE TO
:	COMPLETE CIRCUIT. WHEN EXPECTED SEQN ARRIVES, TOSS LEADING DATA
:	AND FUSE NEW CRQ WITH EXISTING CIRCUIT STUB...

CRQINT	LR	R9,R2			:INTERCEPT - GET THE REQUIRED DATA
	SRHLS	R9,1
	NHI	R9,-4
	AI	R9,HBUFN
	L	R4,RBVSEQ,R9,		:GET VSEQN OF FIRST CHARACTER IN NB##GT
	LHL	R7,RBIBUF,R9,		:GET ORIGINAL INBOUND BUFFER NUMBER
	LHL	R1,RBHIS,R9,		:GET ORIG CRQ STUB HISTORY BFR	###CY
	L	R0,RBKEY,R9,		:ALSO GET INVOICE NO.		###CY
	CL	R0,RINVC,R1,		:CONSISTENCY CHECK ORIGINAL CRQ STUB#CY
	JN	CRQRE4			:ABANDON INTERCEPT, TIMED OUT?	###CY
	L	R1,VSEQN,R2,		:GET CURRENT RECEIVE SEQUENCE NUMBER
	S	R1,VSEQN,R7,		:COMPARE TO VSEQN OF THE ORIGINAL CIRC
	JGEFS	CRQIN1			:INCOMING HIST DATA CAUGHT UP, PROCESS
	JAL	R8,CBCLR,,		:NOT CAUGHT UP YET - DISCARD OLD DATA
	L	R1,SEQN,R2,		:THIS'LL NOW BE #1 IN BUFF	###GT
	ST	R1,RBVSEQ,R9,
	J	CRQ10			:DONE PROCESSING REBUILD STUB FOR NOW

CRQIN1	L	R5,VSEQN,R7,		:HIST DATA CAUGHT UP - RECONCILE
	JAL	R9,PURGE		:ORIGINAL IN-BUFFER AND CURRENT IN-BUFF
	SKIPAD(CRQRE3)			:immed, DATA LOST, REJECT REBILD ATTMPT
	JAL	R8,CBCCT,,		:+4, UPDATE ORIGINAL IN-BUFFER'S SEQ #
	AM	R1,VSEQN,R7,		:BY EXCESS BYTES LEFT OVER AFTER PURGE
	LR	R6,R2			:COPY CURRENT IN-BUFF>ORIGINAL IN-BUFF
	JAL	R9,APPEND		:THIS ALSO CLEARS THE CURRENT IN-BUFFER
	GL	APPEND
	LR	R2,R6	
	XHI	R6,4			:GET THE NEW NETWORK CHANNEL NUMBER
	LHL	CHN,BF,R6,		:CHN = EXIT PORT #
	LR	R0,R2			:COPY NEEDLE BUFFER NO.		###CY
	SRHLS	R0,3			:MAKE CRQ INDEX			###CY
	TBT	R0,SQFIXV		:HAVE WE SEEN A SEQ-FIX OR ACK?	###CY
	JEFS	CRQINA			:SKIP IF NOT			###CY
	LR	R0,R7			:COPY CRQ STUB BUFFER NO.	###CY
	SRHLS	R0,3			:MAKE CRQ INDEX			###CY
	SBT	R0,SQFIXV		:SET FOR CRQ STUB		###CY
CRQINA	JAL	R8,RFCBUF,,		:RETURN NEEDLE BUFF,NO LONGER NEEDED#CY
	LR	R2,R7			:CONNECT THE ORIGINAL IN-BUFFER TO THE
	JAL	R9,CRQHCR		:NEW NETWORK CHANNEL
	SRHLS	R2,3			:CLEAR TIMEOUTS
	RBT	R2,REBTMO
	RBT	R2,REBTMI
	SBT	R2,CRQBSY		:MARK CREATION OF A REBUILDABLE CIRCUIT
	SBT	R2,CRQEND		:MARK CREATION OF A CIRCUIT TERMINATION
	TBT	R2,SQFIXV		:DO WE HAVE FIX OR ACK ALREADY?	###CY
	JNFS	CRQINB			:SKIP IF SO			###CY
	RBT	R2,SQFTMO		:INIT REBUILD TIMEOUT
	SBT	R2,SQFTMI		:SET REBUILD TIMER COUNT
CRQINB	LR	R2,R7			:GET INBOUND BUFFER		###CY
	XHI	R2,4			:SWITCH TO OUTPUT BUFFER NUMBER	###GT
	JAL	R9,SNDFX0,,		:SEND A SQFIX WITH SEQN=0	###GT
	LHL	R6,BF,R7,
	LIS	R8,3
	NH	R8,IOTAB,R6,R6
	AHM	R8,IOTAB,CHN,CHN
	XHI	R7,4			:OUTPUT BUFFER #
	LHL	R0,BCT,R7,		:SET ATTN FLAG IF CHARS IN OB
	JEFS	CRQIN2
	SBT	CHN,NFLAGS
CRQIN2	CLHI	R6,LNKZFL		:IS DESTINATION CHANNEL A LINK CHAN?#CY
	JL	CRQIN3			:NO, NOT A PASSTHROUGH		###CY
	CLHI	R6,LNKLFL		:IS IT GREATER THAN LAST LINK CHAN?##CY
	JGE	CRQIN3			:YES, NOT A PASSTHROUGH		###CY
	CLHI	CHN,LNKZFL		:IS SOURCE CHANNEL A LINK CHANNEL?###CY
	JL	CRQIN3			:NO, NOT A PASSTHROUGH		###CY
	CLHI	CHN,LNKLFL		:IS IT GREATER THAN LAST LINK CHAN?##CY
	JGE	CRQIN3			:YES, NOT A PASSTHROUGH		###CY
	LHL	R0,PASTHR		:increment passthrough count	###wjl
	AIS	R0,1			:				###wjl
	STH	R0,PASTHR		:				###wjl
	CLHI	R0,NPASTH		:out of passthroughs?		###wjl
	JLFS	CRQIN3			:no				###wjl
	LHL	R0,PTHRPD		:what was the last report?	###wjl
	JEFS	CRQIN3			:zero=out of passthrus reported ###wjl
	JAL	R10,SUP0B		:make Resources Report to Sup	###wjl
CRQIN3	LR	R2,R7			:MOVE OUTPUT BUFFER TO R2 FOR CSETUP#CY
	JAL	R8,CSETUP		:SET UP REBUILD DATA FOR CRYPTO
	JAL	R8,CRYPTO,,
	HC	CRYE12
	JAL	R9,CSTUP2		:2ND PART OF CRYPTO MESSAGE	###GT
	J	CRQ20

	EI	:REBILD

	IF	T2GATE
::*********************************************************************
::
::	ENTRY POINT:	GCRTRM:	Gateway CiRcuit TeRMination
::	FUNCTION:	Recieves a Needle inbound from HNET, via CRQ.
::			Gets info to send a Type 07 to ISIS, marks 
::			buffer and sets timer.
::	INPUT:		Expects buffer number in R2.
::	CALLS:		JAL	R8,DIZSMS
::			JAL	R9,FNDCHN
::	RETURNS:	Jumps directly to further processing at CRQ20.
::
::*********************************************************************

GCRTRM	HS	0		:Here for Gateway Log-in
	CLHI	HN,HHOST	:Sanity check - destination always HHOST
	JN	CRQHSZ		:Some problem - error, zap circuit
GCRL00	LHI	R1,NDP-1
	LHI	CHN,DISZFL+1
	JAL	R9,FNDCHN	:Just see if ports are available at all
	SKIPAD(CRQER4)		:immed - If not, error.  Zap circuit.	###wjl
GCRL07	LHL	R1,CQNFLG
       IF       LOGII           :A log II converted needle?
        THI     R1,NF.LG2
        JN      GL2CTM          :go handle converted needles
       EI       :LOGII
	STH	R2,GLOKEY	:+4 return, Local Key becomes our buffer number
	THI	R1,NF.SMC	:Is this a smart circuit?
	JE	GCRL08		:No, don't set IIX bit
	LHI	R1,0C000	:IIX and ELS
	J	GCRL09
GCRL08	LHI	R1,04000	:Always ELS, but not IIX
GCRL09	STH	R1,GIXELF	:Store into Typ07 message
	LB	R1,CQTID	:Get TID (CCT)
	NHI	R1,1F		:MASK OUT TO GET TID
	LBR	R1,R1		:Is it 00
	JN	GCRL10		:NO
	LHI	R1,GAXTID	:Yes, exchange for Gateway Aux TID
	JFS	GCRL11
GCRL10	LB	R1,CQTID
GCRL11	STB	R1,GHINID	:and store in message
	LA	R1,GDM07M	:Load message address
	LHI	R3,GDM07L	:and length
	JAL	R8,DIZSMS,,	:Send Typ 07 (pseudo needle request)
::Now set up BF to show Log-in state and set timer
	LHI	R0,LGST.N	:(used only as a check)
	STH	R0,BF,R2,,
	SRLS	R2,1
	L	R9,SLOWC,,
	AHI	R9,GLGTMR	:Set up 2 minute time out
	ST	R9,BUFTIM,R2,
	J	CRQ20		:Thats all folks!

       IF       LOGII           :<<<<<<<< all of gateway's log II stuff

::*****************************************************************
:
:       GL2CTM  handles LOG II converted needles (a log I needle with a
:               LOG II body following).  After removing the LOG I needle
:               and adding the needle body control char then this is the
:               same as a normal LOG II needle.  
:               R3=end of log I needle
::*****************************************************************

GL2CTM  JAL     R9,TRUNC
        LHI     R1,NEEDBD               :converted body has no control char
        JAL     R8,WCD
        EXBR    R1,R1
        JAL     R8,WCD                  :now it looks like a LOG II needle bod
                                        :and fall through to normal LOGII
:       GL2TRM  simply write ICRM with no MOs and process needle body
:               after get back ASLP.

GL2TRM  
        LHI     R0,0A                   :len of null ICRM
        JAL     R8,DIROOM,,
        LHL     R6,DRIF,,               :fill pointer
        LHI     R4,DRSZ-1               :wrap preventer
        LHI     R1,1100                 :type port 0, type 11, unused byte
        ST      R1,DIRNG,R6,
        AIS     R6,4
        NR      R6,R4
        LI      R1,00040000             :len and dispatcher key
        ST      R1,DIRNG,R6,
        AIS     R6,4
        NR      R6,R4
        STH     R2,DIRNG,R6,            :use buffer number as local key
        AIS     R6,4
        NR      R6,R4
        STH     R6,DRIF,,               :save msg
        J       CRQ20                   :done

       EI       :LOGII          <<<<<<<<<< end of gateway LOGII stuff

	EI	:T2GATE

::*********************************************************************
::
::	SUBROUTINES:	CSETUP:/CSTUP2:
::	FUNCTION:	SET UP REBUILD DATA FOR CRYPTO
::	INPUT:		R2 = BUFFER NUMBER
::		CSETUP RETURNS R0 = CHAN, CRYSBF = HSEQN.
::		CSTUP2 COMPLETES REMAINING PART OF CRYPTO LOG - WRITES
::			VSEQN AND XSEQN. TO BE USED WITH CSETUP ONLY!
::	DESTROYED:	R0, R1
::
::*********************************************************************

	IF	REBILD
CSETUP	HS	0
	LR	R1,R2
	XHI	R1,4			:GET OTHER BUFFER NUMBER	###GT
	LHL	R0,BF,R1,		:CHANNEL			###GT
	SRLS	R1,3
	SLLS	R1,2
	L	R1,HBSEQN,R1,		:HB SEQN NUMBER			###GT
	ST	R1,CRYSBF		:SET UP FOR CRYPTO		###GT
	JR	R8

CSTUP2	HS	0
	L	R0,XSEQN,R2,		:XSEQN NUMBER			###GT
	LR	R1,R2			:				###GT
	XHI	R1,4
	L	R1,VSEQN,R1,		:VSEQN NUMBER			###GT
	ST	R1,CRYSBF
	JAL	R8,CRYPTO,,		:LOG THE SEQUENCE NUMBERS	###GT
	HC	CRYE6E
	JR	R9

	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	SWRCHU:
::	FUNCTION:	FORMAT CHANNEL IN USE NODE REPORT TO SUPERVISOR.
::	CALLING SEQ:	JAL	R10,SWRCHU
::	INPUT:		R5 = CHN = ABSOLUTE CHANNEL NUMBER OF CHANNEL IN USE
::		IF CHANNEL IS TO NEIGHBOR, HW3 CONTAINS RELATIVE CHANNEL
::		NUMBER AND HW2 HAS NEIGHBOR NUMBER.
::		IF CHANNEL NOT TO NEIGHBOR, HW3 CONTAINS ABSOLUTE CHANNEL #,
::		AND HW2 IS SET TO -1.
::	DESTROYED:	R0, R1, R2, R3, R4, R8, R9
::
::*********************************************************************

SWRCHU	HS	0
	ST	R10,CHUSAV		:SAVE LINK REGISTER
	LIS	R0,NR.CHU
	STH	R0,SUPMBF		:INDICATE CHANNEL IN USE NODE REPORT
	CLHI	CHN,LNKZFL		:IS THIS A LINK CHANNEL?
	JL	SWRCU2			:NO
	SH	CHN,LKZFKN,KN,KN	:YES - COMPUTE RELATIVE CHANNEL NUMBER
	STH	CHN,SUPMBF+4
	AH	CHN,LKZFKN,KN,KN	:RESTORE CHN
	LHL	R0,NDID,KD
	OHI	R0,8000
	STH	R0,SUPMBF+2		:NEIGHBOR NUMBER IN HW2
	JFS	SWRCU3
SWRCU2	STH	CHN,SUPMBF+4		:ABSOLUTE CHANNEL NUMBER
	LCS	R0,1
	STH	R0,SUPMBF+2		:INDICATE NOT A NEIGHBOR CHANNEL
SWRCU3	STH	R0,CRYSBF+2		:NGHBR# FOR CRYPTO
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP

:	NOW COMPUTE CIRCUIT TIME FOR COMPANION NODE REPORT. HW2 CONTAINS
:	THE LIFETIME OF THE CIRCUIT IN SECONDS, AND HW3 REMAINS THE SAME.
	LHL	R1,IOTAB,CHN,CHN
	SRLS	R1,1			:COMPUTE BUFTIM INDEX
	NHI	R1,-4
	L	R0,SLOWC,,		:GET CURRENT TIME AND
	S	R0,BUFTIM,R1,		:SUBTRACT TIME WHEN CIRCUIT WAS BUILT
	CI	R0,0FFFF		:LONG TIME?
	JLEFS	SWRCH4			:NO
	LCS	R0,1			:YES, EXCEEDS HW RANGE. MAKE MAX VALUE
SWRCH4	STH	R0,SUPMBF+2		:STORE CIRCUIT LIFETIME
	LIS	R0,NR.CTM
	STH	R0,SUPMBF		:INDICATE CIRCUIT LIFETIME NODE REPORT
	JAL	R10,SUP12		:SEND NODE REPORT TO SUP

:	FORMAT CRYPTOGRAM. LOW-ORDER HW CONTAINS CHN, UPPER BYTE HAS
:	CIRCUIT LIFETIME (IN SECONDS).
	LH	R0,SUPMBF+2		:GET CIRCUIT LIFETIME BACK
SWRCH6	SLL	R0,10			:ALIGN TO UPPER BYTE AND
	OR	R0,CHN			:COMBINE WITH CHANNEL
	JAL	R8,CRYPTO,,		:SEND CRYPTOGRAM FOR
	HC	CRYE10			:CHANNEL IN USE
	L	R10,CHUSAV		:RESTORE R10
	JR	R10

::*********************************************************************
::
::	TABLE:		CIRSPK:
::	FUNCTION:	CIRCUIT SPEED TABLE
::
::*********************************************************************

CIRSPK	HS	0		:CIRCUIT SPEEDS
	HC	CIRSP0
	HC	CIRSP1
	HC	CIRSP2
	IF	1-\SUPGCS	:ALLOW FOR MODIFICATION OF LEVEL 3 GOUGE SPEED
	HC	CIRSP3
	ELSE	:LEVEL 3 GOUGE OPTION SPECIFIED
	HC	SUPGCS
	EI	:1-\SUPGCS

	SUBTTL	CRQ (Circuit building routines)

::*********************************************************************
::
::	SUBROUTINE:	CRQFCR:
::	FUNCTION:	BUILD A FULL CIRCUIT
::	CALLING SEQ:	JAL	R9,CRQFCR
::	INPUT:		R2 = BUFF #
::			R3 = SPEED (2 BITS)
::			R4 = ORIGIN PORT #
::			R5 = CHN = DESTINATION PORT NUMBER
::
::*********************************************************************

CRQFCR	HS	0
	NHI	R3,3			:MAKE SURE SPEED IS LEGAL
	STH	R2,IOTAB,R4,R4		:MAKE PERMUTER TABLE ENTRY AND
	AHM	R3,IOTAB,R4,R4		:INCLUDE SPEED BITS
	RBT	R4,ACP,,		:INDICATE ACTIVE PORT
	LCS	R0,1
	SR	R0,R4			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		:MARK THAT ACTIVE
	STH	CHN,BF,R2,
	XHI	R2,4
	STH	R2,IOTAB,CHN,CHN	:COMPLEMENTARY PERMUTER TABLE ENTRY
	AHM	R3,IOTAB,CHN,CHN	:WITH SPEED BITS
	RBT	CHN,ACP,,		:FULL CIRCUIT MARKED AS ACTIVE
	LCS	R0,1
	SR	R0,CHN			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		:FLAG AS ACTIVE PORT
	STH	R4,BF,R2,
	XHI	R2,4
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	CRQHCR:
::	FUNCTION:	CREATES ONE HALF OF A CIRCUIT BY MAKING ENTRY
::		IN PERMUTER TABLE AND SETTING THE ATTENTION FLAG POINTER
::		OF THE CORRESPONDING BUFFER.
::	CALLING SEQ:	JAL	R9,CRQHCR
::	INPUT:		R2 = BUFFER #
::			R5 = CHN = ABSOLUTE CHANNEL #
::
::*********************************************************************

CRQHCR	HS	0
	XHI	R2,4			:THE CHAN # IS THE ATTENTION FLAG
	STH	CHN,BF,R2,
	XHI	R2,4
	STH	R2,IOTAB,CHN,CHN	:THE BUFF # IS THE PERMUTER TABLE ENTRY
	RBT	CHN,ACP,,		:CHANNEL NOW ACTIVE
	LCS	R0,1
	SR	R0,CHN			:COMPUTE NEGATIVE ACP AND
	RBT	R0,ACP,,		:INDICATE ACTIVE PORT

	IF	CBZDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	JAL	R14,CRHDB1,,
	GL	CRHDB1
	LM	R0,REGST		:restore regs		###sdw
	EI	:CBZDBG

	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	CRQALT:
::	FUNCTION:	SIGNALS CRQ OF NEEDLE BY PUTTING NEEDLE BUFF #
::			IN THE CRQ BUFFER (BUFF 0).
::	CALLING SEQ:	JAL	R9,CRQALT
::	INPUT:		R2 = NEEDLE BUFFER #
::	DESTROYED:	R1, R8
::
::*********************************************************************

CRQALT	HS	0
	ST	R9,CRQASV		:SAVE LINK REG
	CLHI	R2,CIRZBF		:RANGE CHECK BUFFER NUMBER
	JL	CRQAL1			:TOO LOW
	CI	R2,HBUFN-8
	JG	CRQAL1			:TOO HIGH
	LHI	R1,CRQZFL		:SET CRQ ATTN FLAG
	STH	R1,BF,R2,
	LR	R1,R2			:ALERT CRQ FIRST
	LIS	R2,CRQBUF
	JAL	R9,WHWI0,,		:WHWI0 ALLOWS USE OF BUFFER # 0
	LIS	R2,1			:INCREMENT CONSISTENCY COUNT
	AHM	R2,NC.CRQ		: OF CIRCUITS ATTEMPTED
	LR	R2,R1			:RESTORE BUFF #
	L	R9,CRQASV
	JR	R9			:RETURN

CRQAL1	HS	0
	CRASH.(.CRQC2)

::*********************************************************************
::
::	SUBROUTINE:	SUPCRQ:
::	FUNCTION:	BUILDS THE INITIAL CIRCUIT FROM THE SUPERVISOR
::			TO THE LEPRECHAUN OF ITS OWN BASE
::
::*********************************************************************

	IF	SUPER
SUPCRQ	HS	0
	ST	R9,WCDSAV		:SAVE RETURN
	JAL	R8,GFCBUF		:GET A FREE BUFFER PAIR
	SKIPAD(OP8463)			:immed. return - out of buffers!###wjl
	LHI	CHN,SUPER+2		:+4, ok - GET REL CHN FOR SUP INTERFACE
	IF	SNRING
	SBT	CHN,SUPBPV		:ENABLE FLOW TOWARDS SUPERVISOR
	EI	:SNRING
	AHI	CHN,SUPZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER
	JAL	R9,CRQHCR
	XHI	R2,4			:COMPLEMENTARY BUFFER
	LHI	CHN,LEPZFL
	JAL	R9,CRQHCR
	L	R9,WCDSAV		:RESTORE R9
	JR	R9
	EI	:SUPER

::*********************************************************************
::
::	SUBROUTINE:	TRCRFT:/TRCIRC:
::	FUNCTION:	TEARS DOWN CIRCUIT AND REQUESTS REBUILD IF APROPPRIATE
::	LINK:		R10
::	INPUT:		R1 = ZAPPER (SOFT OR HARD)
::			R2 = BUFFER #
::
::*********************************************************************

:	TRCRFT - ENTRY POINT IF CALLED AS A RESULT OF FAT ZAPPER.
:	'PRD' POINTS TO NODE PAIR (FAT) WHICH FOLLOWS FAT ZAPPER.

TRCRFT	HS	0
	LB	R0,0,PRD
	STB	R0,RFAT			:MUST DO A BYTE AT A TIME SINCE NOT
	LB	R0,1,PRD		:ASSURED OF HALFWORD ALIGNMENT
	STB	R0,RFAT+1
	LB	R0,2,PRD
	STB	R0,RFAT+2
	LB	R0,3,PRD
	STB	R0,RFAT+3
	JFS	TRCR02

:	TRCIRC - ENTRY POINT IF NODE PAIR OF LINK OUTAGE NOT KNOWN.
:	REBUILD REQUEST WILL SEND -1'S IN NODE NUMBER FIELDS.

TRCIRC	HS	0
	LCS	R0,1
	ST	R0,RFAT			:NO FAT
TRCR02	ST	R10,TRCSV1		:SAVE LINK REG
	ST	R2,TRCSV2		:BUFFER INDEX OF CIRCUIT BEING ZAPPED
	CLHI	R1,ZAPPF		:IS IT A FAT ZAPPER?
	JEFS	TRCR10			:YES, REBUILDABLE
	CLHI	R1,ZAPPS		:SOFT ZAPPER REBUILDABLE TOO
	JN	TRCZP1			:NONE OF THE ABOVE
TRCR10	LHL	R0,REBREN,,		:REBUILD REQUESTS ENABLED?
	JE	TRCZPH			:NO, JUST HARD ZAP CIRCUIT
	LR	R10,R2			:COMPUTE CIRCUIT #
	SRHLS	R10,3
	LR	R9,R10			:PRESERVE CRQBSY INDEX
	TBT	R9,CRQEND		:ARE WE A TERMINATION?		###GT
	JE	TRCZP1			:NO, PASS SOFT ZAPPER ON

	IF	REBILD			:REQUEST REBILD ONLY IF ENABLED	###gt
	TS	TRCSV2			:INDICATE CALLER SHOULD NOT

:	DEPOSIT NODE PAIR INFORMATION IN CIRCUIT'S BUFFER
	SLHLS	R10,2			:COMPUTE HBUFN			###GT
	AI	R10,HBUFN		:				###GT
	RBT	R9,SQFTMI		:CANCEL ACTIVE REBUILD TIMER	###CY
	RBT	R9,SQFTMO		:				###CY
	RBT	R9,SQFIXV		:NO SEQ FIX OR ACK SEEN ON THIS CRQ##CY
	TBT	R9,CRQBSY		:REBUILD ENABLED FOR THIS CIRCUIT?###CY
	JE	TRCZPH			:NO, MAKE NO REBUILD REQUEST	###CY
	LHL	R0,RNFLAG,R10,		:ARE WE THE CIRCUIT ORIGIN?
	JE	TRCZHC			:NO, CLEAR PERMUTER TABLE ENTRY ONLY
	LHL	R2,TVRBUF		:MAKE REBUILD REQUEST TO SUP
       IF       REBTAK			:if no supe, wait, send it a takeover
        JE      TRCZHC
       ELSE     :just zap it
	JE	TRCZPH			:NO SUP, MUST HARD ZAP CIRCUIT
       EI       :REBTAK
	LHI	R1,8000+MACHNM
	JAL	R9,WHWI,,
	LHI	R1,0D80
	JAL	R9,WHWI,,
	LHL	R1,RNFLAG,R10,		:NEEDLE FLAGS
	JAL	R9,WHWI,,
	LHI	R1,8080			:***TEMP PORT #
	JAL	R9,WHWI,,
	LHL	R1,RBASE,R10,		:BASE & HOST
	JAL	R9,WHWI,,
	LHL	R1,RHOSTN,R10,
	JAL	R9,WHWI,,
	LHL	R1,RINVC,R10,		:INVOICE
	JAL	R9,WHWI,,
	LHL	R1,RINVC+2,R10,
	JAL	R9,WHWI,,
	LHL	R1,RFAT
	JAL	R9,WHWI,,		:NODE PAIR OF LINK WHICH WENT OUT
	LHL	R1,RFAT+2
	JAL	R9,WHWI,,
	LHL	R2,TRCSV2+2		:GET ZAPPER-ENTRY BUFFER INDEX
	XHI	R2,4			:FLIP TO OPPOSITE BUFFER FOR CSETUP
	JAL	R8,CSETUP		:SET UP FOR REBUILD PARAMETERS
	JAL	R8,CRYPTO,,		:REBUILD REQUEST
	HC	CRYE11
	JAL	R9,CSTUP2		:REST OF LOG			###GT

TRCZHC	LHL	R2,TRCSV2+2		:GET BACK THE ZAPPER-ENTRY BUFFER
	LHL	R8,BF,R2,		:GET THE ZAPPER-EXIT CHANNEL NUMBER
	XHI	R2,4			:GET THE OPPOSITE BUFFER NUMBER
	LHL	R3,BF,R2,		:GET THE ZAPPER-ENTRY CHANNEL NUMBER
	CLHI	R8,LNKZFL		:IS ZAPPER-EXIT CHANNEL A TERMINATION?
	JL	TRCZH1			:YES, THIS WASN'T A PASSTHRU	###CY
	CLHI	R8,LNKLFL		:GREATER THAN LAST LINK CHANNEL?###CY
	JGE	TRCZH1			:				###CY
	CLHI	R3,LNKZFL		:TEST THE OTHER CHANNEL
	JLFS	TRCZH1			:IT TERMINATES, WASN'T A PASSTHRU##CY
	CLHI	R3,LNKLFL		:GREATER THAN LAST LINK CHANNEL?###CY
	JGEFS	TRCZH1			:				###CY
	LCS	R0,1			:THIS WAS A PASSTHRU
	AHM	R0,PASTHR		:DECREMENT COUNT OF ACTIVE PASSTHROUGHS
        tbt     r3,cmdcts-(lnkzfl/8),,             :a command circuit?
        jefs    trczh1                  :nope, not one fewer in use
        ahm     r0,nbrcmd               :one fewer in use
:	NOTE CRQREB MUST INCREMENT AGAIN IF STUB REBUILT		###CY

TRCZH1	LIS	R0,0
	STH	R0,IOTAB,R3,R3		:CLEAR PERMUTER TABLE ENTRY
	SBT	R3,ACP,,		:PORT IS  NOW IDLE
	RBT	R3,CHS,,		:SUSPEND CHANNEL		###CY
	SBT	R3,CHS1,,		:		 		###CY
	LCS	R0,1			:ALSO SET NEGATIVE ACP ARRAY	###CY
	SR	R0,R3			:				###CY
	SBT	R0,ACP,,		:				###CY
	RBT	R0,CHS,,		:###CY
	SBT	R0,CHS1,,		:###CY
	RBT	R3,NFLAGS		:FREEZE OUTBOUND BUFFER
	LHI	R0,STUBFL
	STH	R0,BF,R2,		:CORRESPONDING BF IS SET TO STUBFL
	XHI	R2,4
	LR	R0,R2			:SET TIMEOUT
	SRHLS	R0,3
	SBT	R0,REBTMI
	L	R10,TRCSV1		:RESTORE LINK REG
	JR	R10			:RETURN

	EI	:REBILD	###GT

TRCZPH	LHI	R1,ZAPPH		:TO HARD ZAP WHEN NEEDED
	TS	TRCSV2			:PREVENT 'FAT' FROM TRAVELING
	LHL	R2,TRCSV2+2		:TO PASS A ZAPPER ON
	J	TRCZP3			:COMMON EXIT			###GT

:	AVOID CLEARING NEEDLE POINT IN BUFFER				###CY
TRCZP1	LHL	R0,BCT,R2,		:ANYTHING IN BUFFER?		###GT
	JE	TRCZP3			:SKIP IF EMPTY			###GT
	LR	R0,R1			:COPY ZAPPER TYPE		###GT
	JAL	R8,PCIS,,		:PEEK AT 1ST CHAR		###GT
	SIS	R1,3			:IS IT A ZAPPER PAIR?		###GT
	JNFS	TRCZP2			:SKIP IF NOT			###GT
	JAL	R8,PCI,,		:LOOK AT 2ND OF PAIR		###GT
	CLHI	R1,NEEDP&0FF		:CHECK FOR NEEDLE POINT		###GT
	JNFS	TRCZP2			:SKIP IF NOT			###GT
	LR	R1,R0			:RECOVER ZAPPER TYPE		###GT
	JAL	R9,ZAPXN		:ZAP WITHOUT CLEARING BUFFER	###GT
	JFS	TRCZP4			:ALMOST DONE			###GT
TRCZP2	LR	R1,R0			:RECOVER ZAP TYPE		###GT
TRCZP3	JAL	R9,ZAPX			:ZAP 1/2 CRQ			###GT
TRCZP4	L	R10,TRCSV1		:RESTORE RETURN ADDR		###GT
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	ZAPHRD:/ZAPX:/ZAPXN:/ZAPXNG:
::	FUNCTION:	Zaps first half of a circuit.  If the other half
::		is dead, returns the buffer (R2) to the free list.
::		May or may not clear the buffer (R2), depending on type of
::		zapper (R1) or entry point.
::	ENTRY POINTS:
::		ZAPHRD - Zaps circuit (hard zapper).
::		ZAPX   - Zaps circuit (zapper in R1).
::		ZAPXN  - Zaps circuit (zapper in R1), does not CBCLR.
::		ZAPXNG - Zaps circuit (2nd byte of zapper in R1),does not CBCLR
::	LINKS:		R9
::	INPUT:		R2 = buffer index.
::			R1 = zapper (not expected by ZAPHRD).
::	DESTROYED:	R0, R3, R8
::
::*********************************************************************

ZAPHRD	HS	0			:Enter here to force hard zapper
	LHI	R1,ZAPPH

ZAPX	HS	0			:Enter here with zapper of choice in R1
	IF	CBZDBG			:DEBUGGER			###LSH
	STM	R0,REGST
	JAL	R14,ZPHDB1,,
	GL	ZPHDB1
	LM	R0,REGST		:restore regs		###sdw
	EI	:CBZDBG		

	CLHI	R1,ZAPPN		:IF A NON-GOBBLING TYPE...
	JE	ZAPXN			:DONT CLEAR BUFFER

	LR	R2,R2			:R2 = ORIG. BUFFER #.	###LSH
	JLR	R9			:IF BUFFER IS NOT THERE, JUST RETURN

	JAL	R8,CBCLR,,		:ELSE CLEAR THE ORIG. BUFFER FIRST
        IF      T2GATE          :gateway keeps another char count
        LHL     R8,BF,R2,               :               9/15/87 ###sdw
        SHI     R8,DISZFL               :get maybe isis port number
        JLFS    ZAPXN                   :not isis dport
        CLHI    R8,NDP                  :small enough?
        JGEFS   ZAPXN                   :too big
        TBT     R8,LOGING             :for ports in login mode
        JEFS    ZAPXN
        LIS     R3,0            :now the zapper cannot look like an already
        STB     R3,GLGCNT,R8,   :read and known about character pair.  ###sdw
        EI      :T2GATE

:	Enter here to bypass CBCLR.  Deposit zapper (R1) into buffer (R2)
:	and SPEED it along.
ZAPXN	HS	0			:R2 = ORIG. BUFFER NUMBER
	LH	R3,BF,R2,		:IS IT DEAD-END OR ZAPPED CIRCUIT?##LSH
	JLE	ZAPX0			:IF YES, DON'T SEND ZAPPER. SKIP.###LSH

	EXBR	R1,R1			:DEPOSIT ZAPPER (ALWAYS A PAIR)	###CY
	JAL	R8,WCI,,
	EXBR	R1,R1

ZAPXNG	HS	0	:ENTRY POINT FOR ESYNC RTD DETECTING NON-GBBLNG ZPPER
	JAL	R8,WCI,,
	LHL	R3,BF,R2,		:PORT OF ZAPPER EXIT
	JAL	R8,SPEED		:SPEED ZAPPER ALONG
:	Get zapper destination channel # (BF of entry buffer) to R3.
:	Switch R2 to complementary buffer index, get channel # of
:	zapper origin to R8.  If both channels are link channels,
:	decrement passthrough count.
ZAPX0	HS	0			:###LSH
	XHI	R2,4			:R2 = COMP. BUFFER NUMBER
	LHL	R8,BF,R2,		:PORT OF ENTRY
	CLHI	R3,LNKZFL		:DEC PASSTHRU CNT IF APPROPRIATE
	JL	ZAPX2
	CLHI	R3,LNKLFL		:R3 = BF OF ORIG. BUFFER
	JGE	ZAPX2			:R8 = BF OF COMP. BUFFER
	CLHI	R8,LNKZFL
	JLFS	ZAPX2
	CLHI	R8,LNKLFL
	JGEFS	ZAPX2
	LCS	R0,1			:PASSTHROUGH CIRCUIT
	AHM	R0,PASTHR		:DECREMENT PASSTHROUGH COUNT
        tbt     r8,cmdcts-(lnkzfl/8),,
        jefs    zapx2                   :not a cmd circuit
        ahm     r0,nbrcmd               :was a cmd circuit

:	Skip to here if not passthrough or fall thru after decrementing
:	passthru count.
ZAPX2	HS	0
	IF	T2GATE
::Count a port and send "cleared" message if appropriate
        st      r4,zapxs2               :R4 is needed by inthst zaps
        sth     r3,GASAVE               :is restored soshould be saved
        STH     CHN,GZAPSV              :save some regs to allow some work regs
        STH     R8,GZSAVE
        LIS     R0,0
        STH     R0,GRSAVE+2             :mark no ISIS port known yet
	CLHI	R8,DISZFL               :r8 (channel received zap) ISIS port?
	JGEFS	GZPCX0			:nope too small
        CLHI    R3,DISZFL               :either a Dispatcher port?      ###sdw
        JL      GZPCX6                  :neither a Dport, skip gateway stuff
        J       GZPCX2                  :R2 probably a dport
GZPCX0	CLHI	R8,DISZFL+NDP		:
        JGE     GZPCX2                  :thus r3 is the ISIS port
::Zapper came from I-Net, if not login  we must re-emit zap to clear port
	LHI	R5,-DISZFL,R8		:Get dispatcher port from known BF
        STH     R8,GRSAVE+2             :we have an ISIS port (channel #)
	TBT	R5,LOGING		:Skip if in log-in mode
	JN	GZPCX4
	LHI	R1,09F00
	JAL	R8,DIRMES,,		:Re-issue Zap to clear port
	J	GZPCX4                  :only clear out one ISIS port
GZPCX2	CLHI    R3,DISZFL               :is r3 an ISIS port?
        JL      GZPCX4                  :nope do accounting
        CLHI    R3,DISZFL+NDP           :
        JGE     GZPCX4
        LHI     R5,-DISZFL,R3           :channel to isis port
        TBT     R5,LOGING               :login mode means others does msgs
        JN      GZPCX4                  :account for logon mode zaps    ###sdw
::Now send "inter-link cleared" message if appropriate
	TBT	R5,GORGPT		:and being from the host to terminal
	JE	GZPCX4			:(an I-net to H-net log-in)
	TBT	R5,GTTRNS		:No messages for transparent
	JN	GZPCX4
        XHI     R2,4                    :flip to ISIS (direction of zap)
        ST      R9,GESAVE               :save link reg
        JAL     R8,GCD,,                :remove zapper
        JAL     R8,GCD,,
	LA	R4,GNGONE,,
	JAL	R9,BUFCAN,,
	ROUTE(ISISN,HOMEN)		:put it in the buffer
        LHI     R1,8D8A
        JAL     R9,W2CI,,
        LHI     R1,ZAPPN
        JAL     R9,W2CI,,
        L       R9,GESAVE               :restore link reg
        XHI     R2,4                    :flip to NET (where zap started)
::Now perform Log-out accounting if appropriate
GZPCX4	LHL     R1,GRSAVE+2             :was r8 an ISIS port?
        JEFS    GZPCX5                  :nope
        SHI     R1,DISZFL               :knock down to port
        TBT     R1,GDSTPT               :destination port?
        JEFS    GZPCX5                  :r8 was not dest ISIS port
        LR      R5,R1                   :it was so set it up
GZPCX5	LHI	R3,DISZFL,CHN		:Make absoulute channel
	CLHI	R3,MNACHN
	JL	GZPCX6
	CLHI	R3,MXACHN		:do accounting range check
	JGE	GZPCX6
        TBT     CHN,GDSTPT              :destination port
        JE      GZPCX6                  :nope, no accounting
	LHL	R0,AAREAS		:Load previously stored reason
	JE	GZPCX6			:Skip if no reason
	LHI	R3,-MNACHN,R3		:Make relative accounting port index
	ST	R2,GESAVE		:Better save buffer number
	ST	R9,GRSAVE		:(We are in reg 9 right now)
	JAL	R8,AARLO,,		:Perform accounting logout stuff
	GL	AARLO
	LIS	R0,0
	STH	R0,AAREAS		:Re-init accounting logout reason
	L	R2,GESAVE		:Get back Loretta'
	L	R9,GRSAVE
GZPCX6	LHL	R3,GASAVE		:...and proceed ....
	LHL	R8,GZSAVE		:and continue
	LHL	CHN,GZAPSV
        l       r4,zapxs2               :restore r4 saved at ZAPX2
	LIS	R0,0
	EI	:T2GATE

	EXHR	R0,R8			:put source chn in high hw
	OR	R0,R3			:AND COMBINE
	JAL	R8,CRYPTO,, 
	HC	CRYE0C			:ENTRY ON LEFT, EXIT ON RIGHT
:	Clear the complementary buffer.  
:	If the zapper entry point is a real channel (>CRQZFL), make sure
:	its IOTAB entry is consistent (i.e., it should be the buffer index
:	we entered with).  If not, crash.
	JAL	R8,CBCLR,,		:CLEAR THE COMPLEMENTARY BUFFER
					:R3 = BF OF COMP. BUFFER
	LHL	R3,BF,R2,		:GET ENTRY PORT (AGAIN)
	CLHI	R3,CRQZFL		:IS THERE AN IOTAB ENTRY?
	JLE	ZAPX1			:NO
	LHL	R0,IOTAB,R3,R3		:MAKE SURE IT'S ALL CONSISTENT
	NHI	R0,-4
	XHI	R0,4
	CR	R2,R0
	JEFS	ZAPX1
	CRASH.(.ZAPCR)
:	Now see if the zapper is traveling toward LOGGER.
:	If not, skip to ZAPX5.
ZAPX1	HS	0
	XHI	R2,4			:R2 = ORIG. BUFFER NUMBER
	LHL	R0,BF,R2,
	CLHI	R0,LOGMIN
	JL	ZAPX5			:NOT TRAVELING TOWARD LOGGER
	CLHI	R0,LOGMAX
	JG	ZAPX5			:NOT TRAVELING TOWARD LOGGER

	IF	T2GATE
::************************************************************
::	If this is a Gateway, we must provide for the case of
::	a log-in from HNET to INET which will find the BF
::	in log-in state and no B2 message having been processed.
::	This is called an Early Zapper, and we must return the 
::	buffer in this case.  If a DIOTAB entry already exists,
::	then we can just pass the Zapper on and let GDB3 find it and
::	return the buffer at that time.
::	INPUT:	R2	=  buffer of inbound (from term)
::first be sure this comes from H-net
	XHI	R2,4
	LHL	R1,BF,R2,
	CLHI	R1,LNKZFL
	JL	GDZ001		:If not from Hnet, go around
	XHI	R2,4		:Return to f. t. buf
	STH	R3,AAR1SV	:save R3 for use later in Zapx7
	STH	R0,AAR2SV	:Save R0 for use in normal zap
	LR	R8,R2		:Load buffer to find complimentary CHN
	LHI	R1,NDP-1	:Number of channels to be considered
	XHI	R8,4		:Now use the complimentary buf # to match
MATCHN	HS	0
	LHL	R0,DIOTAB,R1,R1	:Get a table entry
	CR	R0,R8		:Is it the one we want?
	JN	MATCH8		:No
	LR	R8,R0		:Save it
	XHI	R0,4		:Should be .. let's check
	CR	R0,R2		:Better be equal
	JE	MATCHD		:Yes, found a match  (R1 = relative channel #)
	CRASH.(.FNCHC)		:Problem .. but wed'vd crashed anyway
MATCH8	SIS	R1,1		:End of range yet?
	JG	MATCHN
	J	MATCON		:Could be a problem .. if so we'll crash
MATCHD	LR	CHN,R1		:load  relative channel # discovered
	XHI	R8,4
	LHL	R1,BF,R8,	:Let's see if this is really it
	CLHI	R1,LOGMIN
	JGE	MATCH9
	CRASH.(.ZAPCR)		:Unmistakeable MESS
MATCH9	CLHI	R1,LOGMAX
	JLE	MATHOK
	CRASH.(.ZAPCR)		:Same mess
::Found a match- make sure we are HNET to INET log-on - reset bits etc.
MATHOK	TBT	CHN,GDSTPT		:(this test may not be necessary)##ev
	JE	MATCON
::Continue..expect ZAPPER PASSED IN GDB3 returns buffer 
	LHL	R3,AAR1SV
	J	ZAPX7	:The above will have been executed in lieu
			: of the code below for "normal" node code
			:log-ins, so jump around the following
			:clear tables and expect GDB3 to RFCBUF and Zap prt

::Come here for Hnet login not initiated with B2 response yet
MATCON	HS	0
	LHL	R3,AAR1SV
	LHL	R0,AAR2SV
	J	ZAPX6	:Needle not sent down yet .. return buffer and
			:expect GDB2 to catch this
::If in login mode and not from H-net, come here
GDZ001	HS	0
	XHI	R2,4
			:Fall through here to Inet - Hnet login
	EI	:T2GATE
::	Come here for normal Node Code Log-in processing
:	The needle has not been sent down yet.	The port is in login mode, 
:	and the zapper is traveling toward LOGGER, see if the TID has 
:	been sent to the sup.  If it has, let the zapper go to the sup
:	and RETURN.  The sup will respond with a zapper ack, at which time
:	we will clear the channel and free the buffer.  If TID not yet sent,
:	we can clean things up ourselves without fear of a race condition
:	in reassigning a port which the sup thinks is still in login mode.
	IF	T2GATE
	OHI	R0,LOGSUP		:Gateway only requires bit 4
	ELSE
	OHI	R0,LOGSUP+LOGNDC	:MAKE SURE ZAPPER TRAVELS
	EI	:T2GATE
	STH	R0,BF,R2,
	THI	R0,LG.TID		:HAS TID BEEN SENT TO SUP?
	JER	R9			:YES, SEND ZAPPER TO SUP.
:	ZAPPER CONFIRMATION WILL FREE CHANNEL AND BUFFER (SEE LEPZLI).

::For Gateway we must emit a Zap to free dispatcher port
::Or we will clear tables and return buffer below, in which case we are in 
::log-in mode and must send a Zap to Dispatcher to clear the port for reuse.
	IF	T2GATE
	XHI	R2,4			:Get to-terminal buffer
	LHL	R5,BF,R2,		:Get channel number
        XHI     R2,4                    :restore from terminal buffer
	SHI	R5,DISZFL		:Make into dispatcher port

:  The following test for loging is to take care of INET which logged
:  into HNET and back to INET.  While in login mode the orig INET channel
:  has BF of being in loging mode when in fact the secondary channel is
:  actually sending the B3 messages.  The secondary channel BF are to the
:  orig INET port and of login mode.  The trouble is that a zap on the orig
:  channel while the secondary is in login would notice that is built a
:  circuit (by the loging bit) and that it was in login mode (by BF) and
:  send two zaps back on the origin channel and none one the secondary chann
:  and return the buffers.  Thus, a test for the LOGING bit determines whether
:  this channel is really an INET-HNET (LOGING set) or INET-HNET-INET (loging
:  reset).       ###sdw

        TBT     R5,LOGING               :make sure login port
        JE      ZAPX7                   :###sdw
	LHI	R1,09F00
        STH     R3,GASAVE
	JAL	R8,DIRMES,,		:Send zapper
        LHL     R3,GASAVE               :save R3 and fix link snip ###sdw
	EI	:T2GATE

:	Fall thru to here for the case that port in login mode,
:	zapper is travelling toward LOGGER, and the TID is still in buffer.
:	Remove the buffer from the LOGGER list.  Set the buffer's BF to 0
:	so it will be treated like a dead end below (buffer released).
:	Return the buffer, and stop circuit right here.

ZAPX6	HS	0
	LIS	R0,0			:ZERO BF SO THAT BUFFER GETS RETURNED 
	STH	R0,BF,R2,		:(SEE TEST BELOW)

	J	ZAPX7			:RETURN BUFFER AND INDICATE PORT
					:AVAILABLE. ALSO CLEAR LOGGER LIST##LSH

:	Skip to here for the case that the needle has been sent down already.
ZAPX5	HS	0

:	Skip to here for:
:		1.  all the passthrough nodes.
:		2.  ISIS originating node, as long as the needle has been sent
:			 down already.
:		3.  after cleaning up for login port with TID still in buffer
:			 (see ZAPX6).
:	Flip to the complementary buffer and set its BF to 0.
:	Set the zapper entry port's IOTAB entry to 0.  Free the port (ACP),
:	and temporaily suspend it (CHS, CHS1).
ZAPX7	HS	0			:###LSH
        IF      T2GATE
        IF      CBZDBG                  :debug this too (like ZAPV)
	STM	R0,REGST
        JAL     R14,GPZDB2,,
        GL      GPZDB2
	LM	R0,REGST		:restore regs		###sdw
        EI   :CBZDBG
        EI    :T2GATE

	XHI	R2,4			:R2 = COMP. BUFFER NUMBER
	LIS	R0,0
	STH	R0,BF,R2,		:CLEAR COMPLEMENTARY BUFFER'S BF
	STH	R0,IOTAB,R3,R3		:CLEAR THE PERM TAB ENTRY
	SBT	R3,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R3,CHS,,		:SUSPEND PORT WHILE ZAPPER CLEARS,
	SBT	R3,CHS1,,		:MAKE IT AVAILABLE IN 30-60 SECS
	LCS	R0,1
	SR	R0,R3			:COMPUTE NEGATIVE ACP INDEX
	SBT	R0,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R0,CHS,,		:BUT TEMPORARILY SUSPENDED
	SBT	R0,CHS1,,		:8-SECOND LOGIC WILL REINSTATE CHANNEL

:	Flip back to the original buffer.  If it doesn't point to a dead-end
:	circuit (BF=0) or circuit stub (BF=STUBFL) then just RETURN.
	XHI	R2,4			:R2 = ORIG. BUFFER NUMBER
	LHL	R0,BF,R2,		:IS THIS A DEAD-END CIRCUIT
	JEFS	ZAPX3			:YES, RETURN BUFFER
	CLHI	R0,STUBFL
	JNR	R9			:NOT A STUB EITHER
ZAPX3	HS	0	:Dead-end or stub, release buffer, then RETURN.
	ST	R1,YAKT1
	JAL	R8,RFCBUF,,		:RETURN BUFFER
	ST	R9,ZAPXS1		:STORE LINK REGISTER		###LSH
	ST	R6,ZAPXS2		:STORE R6 			###LSH 
	LR	R6,R2			:COPY BUFFER # INTO R6		###LSH
	JAL	R9,LOGCLR		:REMOVE BUFFER # FROM LOGGER LIST##LSH
	L	R9,ZAPXS1		:RESTORE LINK REGISTER		###LSH
	L	R6,ZAPXS2		:RESTORE R6 			###LSH
	L	R1,YAKT1
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	ZAPV:
::	FUNCTION:	Zaps the last half of a circuit.
::	CALLING SEQ:	JAL	R9,ZAPV
::
::*********************************************************************

:	See if zapper destination is real circuit.  If so, make sure
:	IOTAB is consistent (crash if not). If not, skip to ZAPV1.
ZAPV	HS	0
	IF	CBZDBG			:DEBUGGER			###LSH
	STM	R0,REGST
	JAL	R14,ZPVDB1,,
	GL	ZPVDB1
	LM	R0,REGST		:restore regs		###sdw
	EI	:CBZDBG		

	LHL	R1,BF,R2,		:GET DESTINATION CHANNEL NUMBER
	CLHI	R1,CRQZFL		:SHOULD WE HAVE AN IOTAB ENTRY?
	JLE	ZAPV1			:NO - CIRCUIT NOT YET BUILT
	LHL	R0,IOTAB,R1,R1		:YES, DO CIRCUIT CONSISTENCY CHECK.
					:GET OPPOSITE CHANNEL'S BUFFER INDEX,
	NHI	R0,-4			:STRIP SPEED BITS,
	XHI	R0,4			:COMPUTE COMPLEMENTARY BUFFER INDEX,
	CR	R2,R0			:SHOULD EQUAL BFR INDEX WE ENTERED WITH
	JEFS	ZAPV1			:IOTAB ENTRY CONSISTENT
	CRASH.(.ZAPC0)			:Failed consistency check.
:	Here if circuit not real or if real and consistent.
:	Clear destination channel's IOTAB entry, clear port (ACP),
:	suspend it temporarily (CHS, CHS1).
ZAPV1	HS	0
	LIS	R0,0
	STH	R0,IOTAB,R1,R1		:CLEAR IOTAB ENTRY
	SBT	R1,ACP,,		:PORT NO LONGER IN USE
	RBT	R1,CHS,,		:BUT SUSPENDED TEMPORARILY
	SBT	R1,CHS1,,		:ENABLE REINSTATEMENT BY 30-SEC LOGIC
	LCS	R0,1
	SR	R0,R1			:COMPUTE NEGATIVE ACP INDEX
	SBT	R0,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R0,CHS,,		:SUSPENDED FOR BOTH NEGATIVE
	SBT	R0,CHS1,,		: AND POSITIVE

:	Make sure complementary buffer's BF is 0.  Crash if not.

	LR	R1,R2			:COMPLEMENTARY BF BETTER BE 0
	XHI	R1,4
	LHL	R8,BF,R1,
	JEFS	ZAPV2
	CRASH.(.ZAPC1)
ZAPV2	HS	0		:Everything OK, return buffer and RETURN.
	JAL	R8,RFCBUF,,		:AOK, RETURN BUFFER
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	GOBBLN:/GOBBLE:
::	FUNCTION:	Eat buffer contents, override backpressure,
::			put gobbler into buffer.
::	ENTRY POINTS:	GOBBLN, GOBBLE
::	LINK:		R9
::	INPUT:		R2 =  BUFFER INDEX
::	CALLS:		CBCLR, PCIS, SPEED, AND WCI
::
::*********************************************************************

:	Enter here to ignore gobbler if needle point or SQFIX in buffer.
GOBBLN	HS	0
	LIS	R8,1			: ONLY 1 CHARACTER IN THE BUFFER?##GT
	CLH	R8,BCT,R2,		:03 WAS JUST WRITTEN IN		###GT
	JE	GOBBLE			:YES, DON'T CHECK FOR NEEDLE IN BUFFER
	JAL	R8,PCIS,,		:PEEK AT FIRST BYTE
	SIS	R1,3			:POSSIBLE NEEDLE POINT?
	JN	GOBBLE			:NO
	JAL	R8,PCI,,		:YES - CHECK NEXT BYTE
	CLHI	R1,NEEDP&0FF
	JER	R9			:NEEDLE POINT - IGNORE GOBBLER
	CLHI	R1,SQFIX&0FF		:SEQUENCE FIX?			###GT
	JER	R9			:YES - IGNORE GOBBLER		###GT
       IF       LOGII
        CLHI    R1,NEEDHD&0FF           :don't eat LOG II needles       ###sdw
        JER     R9
        CLHI    R1,NEEDBD&0FF           :LOG II needle before CRQ runs  ###sdw
        JER     R9
        CLHI    R1,NEEDCV&0FF           :converted LOG II needle at dispi
        JER     R9                      :don't eat it (will zap it)
       EI       :LOGII

:	Here to gobble.
:	Clear buffer, SPEED it along, deposit gobbler, and RETURN.
GOBBLE	HS	0
	JAL	R8,CBCLR,,		:CLEAR BUFFER
	LHL	R3,BF,R2,		:GET GOBBLER DESTINATION CHANNEL AND
	JAL	R8,SPEED		:EXPEDITE GOBBLER
	LIS	R1,3			:PUT A GOBBLER IN IT
	JAL	R8,WCI,,		:				###OAS
	LIS	R1,GOBBL&0FF
	JAL	R8,WCI,,		:				###OAS
	JR	R9			:RETURN

	SUBTTL	CRQ (Utilities)

::*********************************************************************
::
::	SUBROUTINE:	CKTCON:
::	FUNCTION:	CIRCUIT CONSISTENCY TESTS.
::	CALLING SEQ:	JAL	R10,CKTCON  CALLED FROM 4-MINUTE LOGIC (G04MIN)
::
::*********************************************************************

:	ALL CIRCUIT ERRORS ARE COUNTED (SUCH AS CHANNEL IN USE, NO NEIGHBOR,
:	ETC.), AND, IF THEIR OCCURRENCES EXCEED A THRESHOLD, ARE REPORTED
:	TO THE PROBE LOG. IN ADDITION, THE NUMBER OF CIRCUITS ATTEMPTED
:	AND COMPLETED BY CRQ ARE COUNTED. IF THE SUM OF CIRCUITS IN ERROR
:	AND CIRCUITS COMPLETED DOES NOT EQUAL THE NUMBER OF CIRCUITS 
:	ATTEMPTED, A CONSISTENCY ERROR NODE REPORT IS GENERATED.

CKTCON	HS	0
	ST	R10,LNKRGS		:SAVE LINK REG
	LHL	R2,NC.LPE		:LEP CIRCUIT BUILDING ERRORS DETECTED
	AH	R2,NC.CRZ		:PLUS # OF CRQ CIRCUIT BUILDING ERRORS
	CLH	R2,NC.THS		:REPORTING THRESHOLD EXCEEDED?
	JL	CKTC10			:NO

	LHI	R0,NR.NCE		:SHOW CIRCUIT BUILDING ERRORS DETECTED
	STH	R0,SUPMBF
	LHL	R0,NC.LPE
	OHI	R0,8000			:NUMBER OF LEP ERRORS (+8000)
	STH	R0,SUPMBF+2
	LHL	R0,NC.CRZ
	OHI	R0,8000			:NUMBER OF CRQ ERRORS (+8000)
	STH	R0,SUPMBF+4
	JAL	R10,SUP12

CKTC10	LHL	R2,NC.CRC		:NUMBER OF CIRCUITS COMPLETED PLUS
	AH	R2,NC.CRZ		:NUMBER OF CIRCUITS IN ERROR
	SH	R2,NC.CRQ		:SHOULD EQUAL # OF CIRCUITS ATTEMPTED
	JE	CKTC40			:IT DOES

:	INTERNALLY DETECTED CONSISTENCY ERROR FOR COUNTING CIRCUITS
:	COMPLETED AND IN ERROR.
	LHI	R0,NR.CKC		:NODE REPORT
	STH	R0,SUPMBF		: FOR CIRCUIT BUILDING CONSISTENCY
	OHI	R2,8000
	STH	R2,SUPMBF+2		:WE ARE OFF BY THIS MANY
	LHL	R0,NC.CER
	AIS	R0,1			:INCREMENT COUNT OF
	STH	R0,NC.CER		: CIRCUIT CONSISTENCY ERRORS DETECTED

	OHI	R0,8000
	STH	R0,SUPMBF+4		:NUMBER OF OCCURRENCES
	JAL	R10,SUP12		:SEND NODE REPORT

CKTC40	LIS	R0,0
	ST	R0,NC.LPE		:CLEAR COUNTERS
	ST	R0,NC.CRZ
	L	R10,LNKRGS

        JR      R10

::*********************************************************************
::
::	SUBROUTINE:	SPEED:
::	FUNCTION:	Expedite zapper or gobbler by overridding backpressure
::			and setting channel service flag.
::	CALLING SEQ:	JAL	R8,SPEED
::	INPUT:		R3 = DESTINATION CHANNEL NUMBER
::
::*********************************************************************

:	Expedite zappers, gobblers.
:	If not dispatcher or link channel, just RETURN.
SPEED	HS	0
	CLHI	R3,DISZFL		:DISPATCHER PORT?
	JLR	R8			:NO - TOO LOW
	CLHI	R3,DISZFL+NDP		:RANGE CHECK FOR DISPATCHER PORT
	JGEFS	SPEED2			:OUT OF RANGE
:	Dispatcher port--override backpressure (DISBPV)
:	and set service flag (DISSVD), then RETURN.
	SBT	R3,DISBPV-DISZFL/8,,	:OVERRIDE BACKPRESSURE AND
	SBT	R3,DISSVD-DISZFL/8,,	:INSURE PROMPT SERVICE
	JR	R8
:	Link channel, override backpressure (BPSVCP)
:	and set service flag (CHSRVD), then RETURN.
SPEED2	HS	0
	CLHI	R3,LNKZFL		:LINK CHANNEL?
	JLR	R8			:NO - TOO LOW
	CLHI	R3,LNKLFL		:RANGE CHECK FOR LINK CHANNEL
	JGER	R8			:OUT OF RANGE
	SBT	R3,BPSVCP-LNKZFL/8,,	:OVERRIDE BACKPRESSURE AND
	SBT	R3,CHSRVD-LNKZFL/8,,	:INSURE PROMPT SERVICE
        lhi     r0,200
        sth     r0,bpscnt-2*lnkzfl,r3,r3 :ensure it has xmit capability
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	NEDTIM:
::	FUNCTION:	COMPUTE AMOUNT OF TIME IT TOOK NEEDLE TO
::			COMPLETE TRIP THROUGH NODE.
::	CALLING SEQ:	JAL	R8,NEDTIM
::	INPUT:		R2 = BUFTIM INDEX IS 1/2 BUFFER INDEX
::	DESTROYED:	R0, R1, R3
::
::*********************************************************************

:	BUFTIM FOR THIS CIRCUIT CONTAINS THE FASTC TIME THAT NEEDLE
:	ORIGINATED IN NODE. THIS ROUTINE IS CALLED AS NEEDLE IS TERMINATING
:	CIRCUIT IN NODE. THE DIFFERENCE BETWEEN CURRENT FASTC AND BUFTIM
:	IS THE NUMBER OF FASTC TICKS THAT NEEDLE TOOK TO COMPLETE CIRCUIT
:	IN THIS NODE.

NEDTIM	HS	0
	LR	R1,R2
	SRLS	R1,1			:COMPUTE BUFTIM INDEX
	NHI	R1,-4
	L	R3,FASTC,,		:GET CURRENT TIME AND SUBTRACT
	S	R3,BUFTIM,R1,		:TIME NEEDLE ORIGINATED IN NODE
	CI	R3,10000		:check for halfword overflow	###jhl
	JLFS	NEDT08			:				###jhl
	LHI	R3,$A9999		:corresponds to about 16 2/3 secs##jhl
:	should be converted to msecs somewhere for display
	JFS	NEDT09			:				###jhl
NEDT08	CLH	R3,NEDHWM		:MORE THAN PREVIOUS HIGH-WATER MARK?
	JLEFS	NEDT10			:NO
NEDT09	STH	R3,NEDHWM		:YES - SAVE NEW HIGH-WATER MARK
NEDT10	LIS	R0,1
	AHM	R0,NEDCNT		:COUNT ALL NEEDLES TIMED
	SRLS	R3,2			:HISTOGRAM RECORDS IN FASTC/4 UNITS
	CLHI	R3,NEDTSZ/2		:IS TIME OUTSIDE OF HISTOGRAM RANGE?
	JLFS	NEDT20			:NO
	LHI	R3,NEDTSZ/2-1		:YES - SET TO MAX VALUE
NEDT20	AHM	R0,NEDHST,R3,R3		:RECORD NEEDLE TIME IN HISTOGRAM
	L	R0,SLOWC,,
	ST	R0,BUFTIM,R1,		:RECORD TIME THAT CIRCUIT IS BUILT
	JR	R8			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	CHSUPD:
::	FUNCTION:	UPDATE CHS ARRAY.
::	CALLING SEQ:	JAL	R0,CHSUPD
::
::*********************************************************************

:	CHS IS RESET WHEN A ZAPPER TRAVELS ON A CIRCUIT TO
:	SUSPEND THAT CHANNEL UNTIL ZAPPER CLEARS MACHINE. WHEN CHS IS RESET,
:	CHS1 IS SET. THIS CAUSES THE CHANNEL TO BE REINSTATED 30 TO 60 SECONDS
:	LATER BY CHSUPD.

CHSUPD	HS	0
	LHI	R3,-ACPSZP*2		:SIZE OF CHS, CHS1, & CHS2 ARRAYS
	LR	R2,R3			: (POSITIVE AND NEGATIVE)

CHSUP2	L	R1,CHS2+ACPSZP,R3,
	O	R1,CHS+ACPSZP,R3,	:REINSTATE CHANNELS SUSPENDED
	ST	R1,CHS+ACPSZP,R3,
	AIS	R3,4
	JLBS	CHSUP2

CHSUP4	L	R1,CHS1+ACPSZP,R2,	:LATEST CANDIDATES FOR REINSTATEMENT
	ST	R1,CHS2+ACPSZP,R2,	:COPY TO CHS2 TO UPDATE CHS NEXT TIME
	ST	R3,CHS1+ACPSZP,R2,	:CLEAR CHS1 TO ZERO
	AIS	R2,4
	JLBS	CHSUP4
	JR	R0			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	CRTOUT:
::	FUNCTION:	PROCESS CIRCUIT TIME-OUTS
::	CALLING SEQ:	JAL	R10,CRTOUT	Called from 1-minute logic
::
::*********************************************************************

:	Bits set in REBTMI will be timed out next time.
:	Time out circuits whose buffers have bits set in REBTMO this
:	time, and then copy REBTMI into REBTMO.

CRTOUT	LIS	R7,0			:zap circuits that have timed out
	LIS	R4,0			:word index into bit array,bits by buf#
CRTOU2	L	R1,REBTMO,R7		:get a word of bit flags
        JFFO    R1,CRTO09
        J       CRTOU3
CRTO09	AR	R2,R4			:bit index + word index into bit array
	RBT	R2,REBTMO		:turn off--pay attention only once
	SLHLS	R2,3			:POINTS TO THE RELEVANT BUFFER PAIR
	LHL	R0,BF,R2,		:ZAPPER MUST TRAVEL TOWARDS PORT
	CLHI	R0,CRQZFL		:if in CRQ range OK,
	JGFS	CRTO10			: else look other direction	###JHL
	XHI	R2,4
CRTO10	LHL	R0,BF,R2,		:report port # to XRAY		###jhl
	JAL	R8,CRYPTO,,
	HC	CRYE0F			:MESSAGE = NEEDLE TIMEOUT
       if       t2gate!acct
        lis     r0,aalr03
        sth     r0,aareas
       ei
	JAL	R9,ZAPHRD		:zap the circuit--clean up leftovers
       if       t2gate!acct
        lis     r0,0
        sth     r0,aareas
       ei
	J	CRTOU2			:and check bit array for more
CRTOU3	L	R0,REBTMI,R7		:move next version of attention flags
	ST	R0,REBTMO,R7		: for subsequent pass
	ST	R1,REBTMI,R7		:clear the next-pass array
	AHI	R4,20			:increment our base buffer #
	AIS	R7,4			:increment our word index
	CLHI	R4,NCIRCS		:check for end of buffer range
	JL	CRTOU2			:do more
	JR	R10			:looked at flags for all buffers,return

::*********************************************************************
::
::	SUBROUTINE:	RBDOUT:
::	FUNCTION:	PROCESS REBUILD TIME-OUTS			###GT
::	CALLING SEQ:	JAL	R10,RBDOUT
::
::*********************************************************************

:	WHEN THE SOURCE SENDS ON A NEEDLE, A SPECIAL SQFIX		###GT
:	(SEQN = 0) IS ALSO SENT. WHEN THE DESTINATION GETS		###GT
:	A NEEDLE, IT ALSO SENDS A SQFIX 0 TOWARDS THE SOURCE.		###GT
:	IF A FIX0 IS NOT RECEIVED ON EITHER END 1-2 MINUTES
:	AFTER A FIX0 IS SENT OUT, THE CIRCUIT WILL BE MARKED
:	AS NOT REBUILDABLE. HISTORY BUFFERS WILL BE CLEARED.

	IF	REBILD
RBDOUT	HS	0
	LIS	R7,0			:LOOK AT ALL CIRCUITS
	LIS	R4,0
RBDOU1	L	R1,SQFTMO,R7		:CHECK FOR CIRCUITS THAT TIMED-OUT
        JE      RBDOU4
        JFFO    R1,RBDOU3
RBDOU3	AR	R2,R4			:GET NUMBER
	RBT	R2,SQFTMO		:RESET TIME-OUT FLAG
	TBT	R2,SQFIXV		:CHECK IF A SQFIX HAS BEEN RECEIVED
	JN	RBDOU1			:YES - THE CIRCUIT IS REBUILDABLE
	SLLS	R2,3			:NO - FLAG AS NOT REBUILDABLE
	JAL	R9,RBCOUT		:RELEASE HISTORY BUFFERS AND LOG
	J	RBDOU1			:CHECK NEXT CIRCUIT
RBDOU4	L	R0,SQFTMI,R7		:PROCESS TIME-OUT
	ST	R0,SQFTMO,R7
	ST	R1,SQFTMI,R7		:CLEAR THIS
	AHI	R4,20			:NEXT SET OF CIRCUITS
	AIS	R7,4
	CLHI	R4,NCIRCS		:ALL DONE?
	JL	RBDOU1			:NOT YET
	JR	R10			:YES - RETURN
	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	RBCOUT:
::	FUNCTION:	CLEAN UP AFTER A CIRCUIT IS FLAGGED AS NOT REBUILDABLE
::	CALLING SEQ:	JAL	R9,RBCOUT
::	INPUT:		R2 = BUFFER NUMBER
::
::*********************************************************************

	IF	REBILD
RBCOUT	LR	R1,R2			:SAVE BUFFER INDEX      	###GT
	XHI	R2,4			:GET INCOMING BUFFER
	LHL	R0,BF,R2,,		:GET THE INCOMING CHANNEL NUMBER
	JAL	R8,CRYPTO,,
	HC	CRYE6B			:MESSAGE = REBUILD DISABLED
	XHI	R2,4			:RESTORE BUFFER INDEX
RBCOU1	SRLS	R2,3			:FORM INDEX INTO BIT ARRAY
	RBT	R2,CRQBSY		:INDICATE CIRCUIT NOT REBUILDABLE
	RBT	R2,SQFTMI		:CLEAR REBUILD TIMEOUT		###CY
	RBT	R2,SQFTMO		:				###CY
	SLLS	R2,2			:GET HISTORY BUFFER INDEX
	LI	R2,HBUFN,R2		:FORM HISTORY BUFFER NUMBER
	JAL	R8,CBCLR,,		:CLEAR HISTORY BUFFER
	LIS	R0,0
	ST	R0,RINVC,R2,		:AND INVOICE NUMBER TO PREVENT REBUILDS
	LR	R2,R1			:RESTORE BUFFER INDEX        	###GT
	JR	R9
	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	DETOUT:
::	FUNCTION:	DETACH TIMEOUT ROUTINE, RUN EVERY 30 SEC.
::	CALLING SEQ:	JAL	R10,DETOUT
::
::*********************************************************************

DETOUT	HS	0
	L	R4,DETACP,,		:ANY PORTS ACTIVE ?
	XHI	R4,-1			:COMPLEMENT WORD
	JER	R10			:NO, SKIP IT
	ST	R4,DETSVC		:SAVE THOSE NEEDING SERVICE

DETONX	L	R4,DETSVC		:DETACH TIMEOUT NEXT
	JFFO	R4,DETTO2
	JR	R10			:NONE LEFT, RETURN

DETTO2	RBT	CHN,DETSVC		:THIS ONE IS SERVICED
	LHL	R2,CIOTAB,CHN,CHN	:PERMUTER TABLE ENTRY
	SRLS	R2,1			:GET BUFTIM INDEX
	NHI	R2,-4
	L	R1,BUFTIM,R2,		:START TIME
	AHI	R1,$A60			:+ 60 SEC GIVES TIME TO STOP
	C	R1,SLOWC,,		:> NOW ?
	JG	DETONX			:NO, CONTINUE

:	PORT IN DETACH STATE HAS NOT BOUNCED ORANGE BALL IN OVER 60 SECONDS.
:	ZAP CIRCUIT...
	LHL	R2,CIOTAB,CHN,CHN	:GET BUFFER INDEX BACK
	NHI	R2,-4			:MASK OUT GOUGING BITS,
	JAL	R9,ZAPHRD		:AND ZAP CIRCUIT
	J	DETONX			:CONTINUE

	SUBTTL	CRQ  (DETCIR - Handle data for 'Detached Ports')

::*********************************************************************
::
::	SUBPROCESS:	DETCIR:
::	FUNCTION:	CIRCUITS ARRIVING FOR HOSTS OUT OF PORTS
::			ARE DETACHED INSTEAD OF MERELY BEING ZAPPED.
::	SCHEDULED:	Dispatched by SWITCH based on data being
::		detected on port in detached mode.  Returns to SWITCH
::		(DETRET) when done.
::
::*********************************************************************

:	THE TERMINATING HALF OF THE CIRCUIT IS BUILT TO THE DETACH PROCESS,
:	WHICH SUPPORTS $A32 PORTS BEGINNING WITH 'DETZFL'.  THE SETUP FOR
:	THE DETACH PROCESS INCLUDES STORING A VALUE IN THE 'DETMTY' BYTE
:	ARRAY (INDEXED BY CHANNEL) TO SPECIFY THE TEXT TO THE USER, AND
:	PASSING A NEEDLE POINT TO THE NEW CIRCUIT TERMINATION. WHEN DETCIR
:	DETECTS A NEEDLE IT SENDS TEXT TO THE USER FOLLOWED BY A YELLOW BALL,
:	AND STORES THE CURRENT TIME IN BUFTIM. IF AN ORANGE BALL IS RETURNED,
:	WE ZAP THE CIRCUIT (ALL OTHER INPUT IS TOSSED). IF NO ORANGE BALL IS
:	BOUNCED BACK, DETOUT WILL DETECT AND ZAP.

DETCIR	HS	0			:FOUND DATA ON A PORT IN 'DETACH' MODE
	L	R4,DETFLG,,		:SEE WHICH PORTS NEED ATTENTION
	ST	R4,DETSVC		:SAVE PORTS SERVICED ARRAY

DETNXT	HS	0			:PROCESS NEXT PORT
	L	R4,DETSVC		:GET PORTS THAT NEED ATTENTION
	JFFO	R4,DETCR2		:FIND FIRST
	J	DETRET,,		:NONE LEFT, EXIT

DETCR2	RBT	CHN,DETSVC		:MARK AS SERVICED
	LHL	R2,CIOTAB,CHN,CHN 	:GET BUFFER INDEX
	NHI	R2,-4
	XHI	R2,4			:POINT TO INCOMING BUFFER
	JFS	DETCR4			:START LOOKING FOR DATA

DETCR3	HS	0			:TEST FOR DATA REMAINING
	LHL	R1,BCT,R2,		:CHARS LEFT IN BUFFER?
	JE	DETNXT			:NO, TRY NEXT BUFFER
DETCR4	JAL	R8,GCI,,		:GET CHARACTER
	LR	R1,R1			:ESCAPE?
	JNFS	DETCR5			:NO
	JAL	R8,GCI,,		:YES, GET DATA BYTE (AND IGNORE)
	JBS	DETCR3

DETCR5	CLHI	R1,03			:ZAPPER, GOBBLER, NEEDLE?
	JE	DETCR7			:YES
	SIS	R1,01			:PREFIX CODE?
	JN	DETCR3			:NO, KEEP LOOKING
	JAL	R8,GCI,,		:YES, LOOK FOR ORANGE BALL
	CLHI	R1,0FE			:ORANGE BALL?
	JN	DETCR3			:NO, KEEP LOOKING

:	FOUND AN ORANGE BALL, ZAP CIRCUIT BOTH WAYS
	XHI	R2,4
	JAL	R9,ZAPHRD		:ZAP IT ALL
	J	DETNXT			:LOOK AT NEXT PORT

DETCR7	HS	0			:FOUND ZAPPER, GOBBLER, ETC
	JAL	R8,GCI,,		:GET SECOND BYTE
	CLHI	R1,NEEDP&0FF		:NEEDLE?
	JEFS	DETCR8			:YES
	CLHI	R1,ZAPPN&0FF		:ZAPPER?
	JG	DETCR3			:NO, KEEP LOOKING
	JAL	R9,ZAPV			:ZAP 2ND HALF
	J	DETNXT			:LOOK AT NEXT PORT

DETCR8	HS	0			:FOUND NEEDLE
:	FOUND NEEDLE, CLEAR BUFFER, SEND CANNED MESSAGE BACK TO USER

	JAL	R8,CBCLR,,		:CLEAR INPUT BUFFER (NEEDLE AND DATA)
        XHI     R2,4                    :POINT OPPOSITE THE NEEDLE JUST READ
	LB	R4,DETMTY,CHN		:GET MESSAGE TYPE
       if       t2gate                  :gateway has no message option
        clhi    r4,0ff
        jefs    detcr9
       ei       :t2gate
	LHL	R4,DETMTB,R4,R4		:GET ADDRESS OF MESSAGE (LESS SEG1)
	AI	R4,SEG1
	JAL	R9,BUFCAN,,		:OUTPUT 'CANNED MESSAGE' TO BUFFER
DETCR9	LIS	R1,1			:OUTPUT YELLOW BALL
	JAL	R8,WCI,,
	LHI	R1,0FF
	JAL	R8,WCI,,

	SRLS	R2,1			:SET UP BUFTIM INDEX - BUFFER
	NHI	R2,-4			:NUMBER TIMES 2
	L	R0,SLOWC,,
	ST	R0,BUFTIM,R2,		:STORE TIME FOR POSSIBLE TIME-OUT

	J	DETNXT			:LOOK AT NEXT PORT

	SUBTTL	CRQ (TRACE - Circuit tracing logic)

::*********************************************************************
::
::	SUBROUTINE:	TRACE:
::	FUNCTION:	CIRCUIT TRACING LOGIC
::	CALLING SEQ:	JAL	R10,TRACE
::	INPUT:		R5 = CHN = ABSOLUTE CHANNEL NUMBER TO BE TRACED
::			REJECTS TRACE REQUEST IF NO CIRCUIT EXISTS
::
::*********************************************************************

TRACE	HS	0
	LHL	R2,IOTAB,CHN,CHN	:IS THERE A CIRCUIT THERE
	NHI	R2,-4
	JE	TRACE6			:NO
	LHL	CHN,BF,R2,		:EXIT PORT #
	LCS	R1,4			:GET HOST OR NODE AND RELATIVE PORT #
TRACE1	AIS	R1,4
	CLH	CHN,CHNMAP,R1
	JLBS	TRACE1
	SH	CHN,CHNMAP,R1
	LHL	R1,CHNMAP+2,R1
	THI	R1,8000			:TEST FOR INTERNAL CIRC, R1 HAS HOB SET
	JN	TRACE4			:YES, INTERNAL TERMINATION

	LHL	R1,CHNMPD,R1		:GET NEIGHBOR NUMBER
	THI	R1,8000			:TEST FOR TERMINATION, C000+NODE#
	JN	TRACE4			:YES

TRACE2	JAL	R9,FNDLNK		:IT'S A T-II NEIGHBOR, MAKE SURE ITS UP
	SKIPAD(TRACE6)			:immed return, NOT FOUND	###wjl
	LHL	R2,LKZFKN,KN,KN		:+4 return, UP, GET IT'S ILC BUFFER #
	LHL	R2,IOTAB,R2,R2
	NHI	R2,-4
	XHI	R2,4
	LIS	R0,1
	AHM	R0,LEPMES+2		:INC THE NODE COUNT
	STH	R1,LEPMES,PRD		:ADD NODE, CHANN TO LIST
	STH	CHN,LEPMES+2,PRD
	LHI	LRC,4,PRD
	LIS	PRD,0			:MOVE MESSAGE TO ILC BUFFER
	LHI	R1,1,LRC		:BYTE COUNT
	JAL	R8,WCI,,
TRACE3	LB	R1,LEPMES,PRD
	JAL	R8,WCI,,
	AIS	PRD,1
	CR	PRD,LRC
	JLBS	TRACE3
	JR	R10

TRACE4	HS	0			:TERMINATION, ADD HOST AND PORT #
	CI	R1,0FFFD		:THIS A DISPATCHER PORT?(-3 FOR 16BITS)
	JNFS	TRACE7			:NO, SKIP IT
	LHL	R1,DHSTIX,CHN,CHN	:GET HOST NUMBER
	OHI	R1,8000			:WITH MSB SET

TRACE7	HS	0
	STH	R1,LEPMES,PRD
	STH	CHN,LEPMES+2,PRD	:<COUNT OF NODES>
	LHI	R1,148A			:GENERAL FUNCTION (14),
	STH	R1,LEPMES		:TRACE RESPON. (0A)+80

	LHI	LRC,4,PRD		:GET SIZE OF LEP MESSAGE
	LIS	PRD,0
	LHL	R2,TVRBUF		:TEST FOR SUP
	JER	R10			:NO ACTIVE SUP, SKIP IT
	LHI	R1,MACHNM+8000		:SEND NODE NUMBER AS 1ST HW
	JAL	R9,WHWI,,
TRACE5	LHL	R1,LEPMES,PRD		:SEND ALL OF LEP MESSAGE
	JAL	R9,WHWI,,
	AIS	PRD,2
	CR	PRD,LRC
	JLBS	TRACE5
	JR	R10

TRACE6	LCS	R1,1
	LCS	CHN,1			:NONEXISTENT CIRCUIT
	J	TRACE4

	IF	LOGII			:some LogII CRQ utilities
::*********************************************************************
::
::	SUBROUTINE:	L2CHWI:	Log 2 Cover HalfWord Immediate
::	FUNCTION:	Covers neighbor number in LogII needle and
::			other housekeeping chores.
::	CALLING SEQ:	JAL	R9,L2CHWI
::	INPUT:		Expects R2 and R3 as pointers
::	PRESERVED:	R7
::	CALLS:		JAL	R9,WCDE/WCD/TRUNC
::	RETURNS:
::
::*********************************************************************

L2CHWI	HS	0			: LogII Needle houskeeping
	ST	R9,L2CHSV,,		:store return address

        JAL     R9,TRUNC,,              :clear upto next element	
        LR      R1,R7                   :new len of element (could be 0)
        JNFS    L2CH10                  :zero means no element
        AIS     R5,3                    :2bytes for id, one for 1
        J       L2CH15                  :skip needle element
L2CH10  JAL     R9,WCDE,,               :len 0 is okay (null element)
        LHI     R1,MO.AC1+ID.NNL        :header ID
        JAL     R9,WCDE,,
L2CH15  LHL     R1,X4T.LN+X4TBBG,,      :get overall len of head
        SR      R1,R5
        JAL     R9,WCDE,,               :new len of needle head element
        CLHI    R1,100
        JLFS    L2CH40                  :not 2 byte len
        EXBR    R1,R1
        JAL     R9,WCDE,,               :high byte of 2 byte len
        LHI     R1,MO.LFM+2
        JAL     R8,WCD,,                :and len of len
        JFS     L2CH41
L2CH40  CLHI    R1,MO.LFM               :long form?
        JLFS    L2CH41
        LHI     R1,MO.LFM+1
        JAL     R8,WCD,,                :1 byte long form
L2CH41  LHI     R1,MO.AC2+ID.NCH        :Node Code Needle Head MO
        JAL     R8,WCD,,
        EXBR    R1,R1
        JAL     R8,WCD,,
        LHI     R1,NEEDHD               :write back needle head
        JAL     R8,WCD,,
        EXBR    R1,R1
        JAL     R8,WCD,,
        LHL     R7,CQNFLG               :mainline expects flags in R7

L2CH99	L	R9,L2CHSV		:restore return address
	JR	R9			:and return to caller
::----------------------------------------------------------------------
::	End of some LogII CRQ utilities
::----------------------------------------------------------------------
       EI       :LOGII

	IF	T2GATE
::*********************************************************************
::
::	SUBROUTINE:	GLZPV:	Gateway Login ZaPV
::	FUNCTION:	Used to Zap half a circuit in response to a
::			Zap Ack from dispatcher...or second time around
::			if Zap from Inet is received and aked with 
::			DISZNK set for the channel.
::	CALLING SEQ:	JAL	R9,GLZPV
::	INPUT:		CHN	Relative Dispatcher port
::	RETURNS:	JR	R9
::
::*********************************************************************

GLZPV	HS	0
        IF      CBZDBG                  :debug this too (like ZAPV)
	STM	R0,REGST
        JAL     R14,GPZDB1,,
        GL      GPZDB1
	LM	R0,REGST		:restore regs		###sdw
        EI   :CBZDBG

	LR	R1,CHN
	RBT	R1,DISFLG,,
	AHI	R1,DISZFL		:Make absolute channel #
	LIS	R0,0
	STH	R0,IOTAB,R1,R1		:CLEAR IOTAB ENTRY
	SBT	R1,ACP,,		:PORT NO LONGER IN USE
	RBT	R1,CHS,,		:BUT SUSPENDED TEMPORARILY
	SBT	R1,CHS1,,		:ENABLE REINSTATEMENT BY 30-SEC LOGIC
	LCS	R0,1
	SR	R0,R1			:COMPUTE NEGATIVE ACP INDEX
	SBT	R0,ACP,,		:INDICATE PORT AVAILABLE
	RBT	R0,CHS,,		:SUSPENDED FOR BOTH NEGATIVE
	SBT	R0,CHS1,,		: AND POSITIVE
GLPZV2	JR	R9
	EI	:T2GATE

	ENDMO.(CRQ)

	EI	:1-KILLIT

	KILMSG(CRQ)

:	***NOTHING PAST THIS POINT***

	SUBTTL	INTHST

:		***** *   * ***** *   *  **** *****
:		  *   **  *   *   *   * *       *
:		  *   * * *   *   *****  ***    *
:		  *   *  **   *   *   *     *   *
:		***** *   *   *   *   * ****    *

::#####################################################################
::
::	MODULE:		INTHST
::
::	FUNCTION:	Process data for internal hosts (remote XRAY,
::		downline load, delay measurement processing).
::
::	SUBTTLS:
::		INTHST - Internal host processor
::		Utilities
::		DWLIN - Handle Down-Line Load record from neighbor
::		DLYSRC - Delay measurement source
::		INTTIM - Internal Host Time-Out logic
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	SEG	1

:	THE FOLLOWING SYMBOL IS USED AS A BASE ADDRESS TO ALLOW ROUTINE
:	ADDRESSES TO BE STORED AS HALF-WORDS IN INTDSP
SEG1.2	HS	0			:###wjl

::*********************************************************************
::
::	XRAYGG:	USERNAME VALIDATION LIST
::              TARG is defined by XGGXxx macro and targets which are not
::              present on the node are not included.                   ###sdw
::
::*********************************************************************

XGGXIX  EQ      0               :no unames have been target for IIXRAY
XGGXDW  EQ      0               :no unames have been target for downline load
XGGXSC  EQ      0               :no unames have been target for SCLP

XRAYGG	HS	0

	IF	XGGCNT
QQ	EQ	0
QQQ     EQ      XGGCNT
	RE	QQQ             :may reduce XGGCNT within repeat block  ###sdw
	XGGX|$0QQ|              :macro removes entries for nonexist targs###sdw
QQ	EQ	QQ+1
      IF	1-XGGXGO			:entry not made
XGGCNT	EQ	XGGCNT-1		:one fewer entry
      EI	:1-XGGXGO
	ER
	EI	:XGGCNT

	ORG	XRAYGG+((10+XGGCNT)*XGGSIZ)  :room to add 16 goodguys   ###sdw

XGGLEN	EQ	.-XRAYGG

       IF       SCLP&(1-XGGXSC)                 :no SCLP uname defiend
 REMARK%%WARNING -- Single Channel Link Protocol (SCLP) requires a xray goodguy
 REMARK%%    entry targeted to T.SCLP to allow access to a Turbo Engine
 REMARK%%    neighbor.
      EI        :SCLP&(1-XGGXSC


      IF        1-XGGXDW                :no downline load entry
 REMARK%%WARNING -- Node cannot downline load neighbor unless an Xray
 REMARK%%    goodguy entry is targeted to T.DLOAD.
      EI        :XGGXDW


::*********************************************************************
::
::	SUBPROCESS:	INTHST:
::	FUNCTION:	INTERNAL HOST PROCESSOR
::	SCHEDULED:	Dispatched by SWITCH based on internal host
::		channels with data requesting service.  Returns to
::		SWITCH (INTRET) when done.
::
::*********************************************************************

:	THE INTERNAL HOST ATTENTION FLAGS START AT INTZFL
:
:	THE INTERNAL HOST PROCESSOR FIRST TESTS THE CHN FOR A ZAPPER,
:	AND COMPLETES THE ZAP IF ONE IS FOUND. ELSE, THE DISPATCH ADDRESS
:	ARRAY INTDSP IS EXAMINED FOR A VALID ( >0 ) ADDRESS, AND A DISPATCH
:	IS DONE ACCORDINGLY.  FOR A ZERO DISPATCH ADDRESS THE CHANNEL IS
:	PRESUMED IN LOGIN MODE AND THE USERNAME IS STRIPPED AND THE FUNCTION
:	BYTE EXAMINED.  CERTAIN USER NAMES REQUIRE NO FUNCTION BYTE.
:	INITIALLY TIMEOUT IS ENABLED ON ALL NEW INTERNAL HOST CHANNELS 
:	BY SETTING THE CORRESPONDING BIT IN INTOUT. SUBSEQUENTLY TIMEOUT
:	IS DISABLED FOR CERTAIN FUNCTIONS.

INTHST	HS	0
	LH	R3,INTFLG,,		:TEST ALL THE FLAGS
	JNFS	INTH10
	CRASH.(.INTCR)
INTH10	STH	R3,INTLST		:SAVE FOR LATER REFERENCE
INTNXT	LH	R3,INTLST		:FIND NEXT CHANNEL WITH WORK
	JFFOH	R3,INTH12	
	J	INTRET,,		:ALL DONE

INTH12	CLHI	R4,TINTCH		:IS THIS A VALID CHANNEL?
	JLFS	INTH16			:YES, GO HANDLE IT
	J	INTRET,,		:NO, ALL DONE

INTH16	RBT	R4,INTLST		:MARK THIS ONE AS DONE
	LHL	R2,INTTAB,R4,R4		:GET OUTBOUND BUFFER NUMBER
	XHI	R2,4			:FLIP TO INCOMING BUFFER
	NHI	R2,-4			:STRIP SPEED BITS
	JAL	R8,PCIS,,		:TEST FOR CONTROL CHAR OR ZAPPER
	CLHI	R1,3			
	JE	INTZAK			:FOUND ONE, INVESTIGATE FURTHER

	LHL	R1,INTDSP,R4,R4		:ALREADY GOT ROUTINE ADDRESS?
	JN	SEG1.2,R1,		:YES, (NOTE R1=0 ISN'T VALID)	###wjl
	TBT	R4,INTUSE		:NO, ALREADY STRIPPED USER NAME?
	JN	INTDWL			:YES, GET FUNCTION

:	CODE STRIPS WHOLE USERNAME IN CRQ
INTH20	SBT	R4,INTUSE		:MARK COMPLETION OF LOGIN
	SBT	R4,INTOUT		:ENABLE TIMEOUT UNTIL TOLD OTHERWISE
	LHL	R1,BCT,R2,		:ANY MORE DATA?
	JEFS	INTH22			:NO, EXAMINE USER NAME
	JAL	R8,GCI,,		:YES
	CLHI	R1,80			:IS IT A PAD CHARACTER?
	JEFS	INTH22			:YES, STRIP IT
	JAL	R8,WCD,,		:NO, RESTORE IT

INTH22	LR	R1,R4			:FORM FW INDEX INTO
	SLLS	R1,2			:USERNAME GGLIST INDEX (STORED IN CRQ)
	L	R8,INTUSR,R1		:GET GGLIST INDEX
	JL	INTH60			:INVALID USER, SOLO MACHINE W/O KERNEL
	L	R7,XRAYGG+XGGTAR,R8,	:get user's TARGET address	###wjl
      IF	SCLP
	LA	R9,INTSKY		:if SCLP entry, load INTDSP 	###AL
	CR	R9,R7
	JNR	R7
	LHI	R0,SKYLOD-SEG1		:store dummy dispatch address for SCLP
	STH	R0,INTDSP,R4,R4
      EI	:SCLP
	JR	R7			:dispatch			###wjl

::*********************************************************************
::
::	TARGET DISPATCH ADDRESS:  INTXRY:
::	FUNCTION:		  XRAY
::
::*********************************************************************

:	PROCESS REMOTE XRAY
INTXRY	JAL	R7,INTSLT		:get XRAY slot for XRAY user	###wjl
	RBT	R4,INTOUT		:NO TIMEOUT FOR REMOTE X-RAY
	JAL	R8,CBCLR,,		:CLEAR TRAILING DATA
	XHI	R2,4			:GET OUTGOING BUFFER NUMBER
	STH	R2,XRYBFO,XD		:OUTBOUND BUFFER NO. THIS USER
	STH	R4,XUINTH,XD		:INTERNAL HOST CHANNEL#
	STH	R1,XUSLTN,XD		:XRAY USER SLOT NO.
	SBT	R4,INTXRF		:NOTE THE PRESENCE OF REMOTE XRAY

	SBT	R4,XWMFLG		:###TZ
	LHI	R0,REMXRY-SEG1.2	:GET ROUTINE ADDRESS		###wjl
	STH	R0,INTDSP,R4,R4
	LIS	R0,0
	STH	R0,EKOTYP,XD		:INIT TO REMOTE ECHO
	LIS	R0,1
	STH	R0,CRYMOD,XD		:INIT AUTO CRYPTO DISPLAY OFF
	STH	R0,XPOWER,XD
	J	REMXRZ			:JUMP TO INITIALIZE ROUTINE

::*********************************************************************
::
::	TARGET DISPATCH ADDRESS:  INTIIX:
::	FUNCTION:		  IIXRAY
::
::*********************************************************************

INTIIX	HS	0
	J	INTH60			:invalid, no IIXRAY configured	###wjl

::*********************************************************************
::
::	TARGET DISPATCH ADDRESS:  INTDWL:
::	FUNCTION:		  DLOAD
::
::*********************************************************************

INTDWL	JAL	R9,INTGET		:GET FUNCTION BYTE
	CLHI	R1,40			:LINE NUMBER (0-63) ?
	JGE	INTPLI			:NO, THIS ISN'T A DWL COMMAND
	SBT	R4,INTDWF		:MAKE ENTRY INTO DWL ARRAY
	RBT	R4,INTOUT		:NO TIMEOUT
	LHI	R0,DWLOUT-SEG1.2	:STORE ROUTINE ADDRESS		###wjl
	STH	R0,INTDSP,R4,R4
	J	DWLOUT			:GO TO DWL ROUTINE

:	CHECK FOR PLI MESSAGE
INTPLI	CLHI	R1,82			:PLI MESSAGE?
	JN	INTDLY			:NO
	XHI	R2,4			:GET OUTBOUND BUFFER NUMBER
	JAL	R8,WCI,,			:ECHO COMMAND BYTE
	XHI	R2,4
	LCS	R0,1
	STH	R0,PLICNT		:INITIALIZE PLICNT
	LHI	R0,PLIMSG-SEG1.2	:ROUTINE ADDRESS		###wjl
	STH	R0,INTDSP,R4,R4
	J	PLIMSG

:	CHECK FOR DELAY MEASUREMENT
INTDLY	CLHI	R1,44			:ROUND-TRIP DELAY MEASUREMENT?
	JN	INTLPB			:NO, PERHAPS LOOPBACK
	RBT	R4,INTOUT		:YES, NO TIMEOUT HERE
	SBT	R4,INTDSF		:SET THE DELAY CHECK CHANNEL FLAG
	LHI	R0,01F-PDLYSR		:GET SCHEDULE PRIORITY FOR DLYSRC
:       always off of 1/8 sec, dly source determines how often for the circuit
	SBT	R0,T125MS		:AND SCHEDULE DLYSRC OFF TIMEOUT LIST
	LHI	R0,DLYSFL-SEG1.2	:INITIAL ENTRY POINT FOR DLYSRC	###wjl
	STH	R0,INTDSP,R4,R4
	J	INTNXT

:	CHECK FOR LOOPBACK
INTLPB	CLHI	R1,4C			:LOOPBACK TEST?
	JNFS	INTEND			:NO,BAD COMMAND. ZAP!
	LHI	R0,LOOPBK-SEG1.2	:				###wjl
	STH	R0,INTDSP,R4,R4		:YES, SET UP FOR LOOPBACK
	RBT	R4,INTOUT		:NO TIMEOUT
	J	INTNXT

:	BAD INT HOST FUNCTION BYTE
INTEND	LR	R0,R1
	JAL	R8,CRYPTO,,		:MESSAGE = BAD INT HOST FUNCTION BYTE
	HC	CRYE50
	J	INTZPH			:ZAP THE CIRCUIT

::*********************************************************************
::
::	TARGET DISPATCH ADDRESS:  INTSKY:
::	FUNCTION:		  SKYLOAD
::	Get the function byte which is the line number.  Set the bit in
::	the INTDWF array to show that the channel is a Down-load channel.
::	This bit is used by INTZAP for clean up if a zap occurs.  Reset
::	the bit in INTOUT array to disable the timeout which is set on
::	all new Internal Host channels.  Call DWLVAL to determine if the
::	line number is valid, unattached, and not in Down-line load mode.
::	If any one of these tests fails DWLVAL jumps to INTZPH to zap the
::	circuit and make a Crypto Log entry 2D: DWL LINE ZAP.  Reset the
::	bit in the Down-line load dispatch array, DWLDSP.  DWLDSP is used
::	by the SYNC and SIO Input processes to identify lines which are
::	being used for Engine down-line loads.  Call RSSCLP to begin sending
::	a continuous stream of SCLP resets to the target machine.  Save the
::	Internal Host channel number in SKYCHN for future completion of the
::	circuit to the IOCP after link establishment is completed.  INTZAP
::	clears SKYCHN if the Internal Host circuit is zapped before completion
::	of the circuit to the IOCP.  Store SKYLOD as a dummy dispatch
::	address which is needed as the attention flag for the Internal
::	Host channel will be set when data arrives in the incoming needle.
::	No further processing of the down-line load data will take place
::	in INTHST.  Internal Host fields and arrays, including the SKYLOD
::	dispatch address, will be cleared after the SCLP link has come up and
::	the down-load circuit has been redirected to the link to the IOCP.
::
::*********************************************************************

INTSKY	HS	0			:###wjl
      IF	SCLP
	JAL	R9,INTGET		:get function byte		###wjl
	SBT	R4,INTDWF		:make entry into DWL array	###wjl
	RBT	R4,INTOUT		:no timeout			###wjl
	JAL	R7,DWLVAL		:determine if the line # is valid##wjl
	RBT	LN,DWLDSP,,		:reset the DWL dispatch array	###wjl
	STH	R4,INTCHN,,		:save R4 from being clobbered	###wjl
	JAL	R9,RSSCLP,,		:begin sending resets to IOCP	###wjl
	LHL	R4,INTCHN,,		:recover INTHST channel number	###wjl
	STH	R4,SKYCHN,LN,		:save INTHST CHN # for completion##wjl
	LHI	R0,SKYLOD-SEG1.2	:store dummy dispatch address	###wjl
	STH	R0,INTDSP,R4,R4		:				###wjl
SKYLOD	J	INTNXT			:				###wjl

      ELSE	:not SCLP

	J	INTH60			:invalid, not configured for SCLP##wjl

      EI	:SCLP

:	DEAL WITH 03-XX CHARACTER PAIR
INTZAK	JAL	R8,GCI,,		:DEAL WITH 03-XX CHARACTER PAIR
	JAL	R8,GCI,,
	CLHI	R1,ZAPPH&0FF		:IS IT A HARD-ZAPPER?
	JE	INTZK1			:YES
       IF       LOGII&T2GATE            :logII converted needle
        CLHI    R1,NEEDBD&0FF           :needle body?
        JN      INTZK0                  :nope, woory about something else
        LHL     R0,BCT,R2,              :make sure len has arrived
        CLHI    R0,2                    :2 means 2 bflets, but body is long
        JGFS    INTZL3
INTZL1  LHI     R1,NEEDBD               :go back and wait for body
        JAL     R8,WCD,,
        EXBR    R1,R1                   :restore removed NEEDHD
        JAL     R8,WCD,,
        J       INTNXT                  :look at this port later
INTZL3  JAL     R9,GHWI,,               :get len
        LR      R4,R1
        JAL     R8,CBCCT,,              :len in buffer
        CR      R4,R1
        JGEFS   INTZL4
        LR      R1,R4                   :write back len
        JAL     R9,WCDE,,
        EXBR    R1,R1
        JAL     R9,WCDE,,               :return and will finish when all ther
        J       INTZL1                  :and write back needle head
INTZL4  LR      R0,R4                   :get count in R0
        JAL     R8,RTBFTS,,             :eat needle body
        LHL     R1,BCT,R2,              :anything in buffer
        JN      INTNXT
        LHI     R1,80
        JAL     R8,WCI,,                :parallel what is done in CRQ
        J       INTNXT
       EI       :LOGII&T2GATE
INTZK0
       IF	IDTACH			:ISIS Detach			###wjl
	CLHI	R1,ZAPPN&0FF		:Is it a Non-Gobbling Zapper?
	JE	INTZK1			:Yes
       EI	:IDTACH							###wjl
	TBT	R4,INTXRF		:NO, IS THIS A REMOTE XRAY CHN?
       IF INTACC
	JE	INAZ24			:Go do final accounting
       ELSE
	JE	INTZPH			:NO, ZAP THE CRQ
       EI	:INTACC			:###EV
	CLHI	R1,GOBBL&0FF		:REM XRAY MAY GET A GOBBLER FROM NAD
	JEFS	INTZK2			:SKINNY GOBBLER
	CLHI	R1,GOBBF&0FF		:OR FAT GOBBLER
	IF	INTACC		
	JN	INAZ24			:Go do final accounting
	ELSE	
	JN	INTZPH			:OTHER STUFF. ZAP CHANNEL
	EI	:INTACC			:###EV
INTZK2	LIS	R1,3			:NAD SENDS GOBBLER INSTEAD OF ^C
	LHL	R2,INTTAB,R4,R4		:SO WE MUST INSERT ^C
	NHI	R2,-4
	XHI	R2,4
	JAL	R9,WCIE,,
	J	INTNXT			:AND RETURN TO MAINLINE
INTZK1	HS	0
	IF	INTACC		
	LR	R3,R4			:Get internal port index 
	LI	R0,AALR03		:Logout reason (zap from user)
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###EV
	JAL	R9,ZAPV			:ZAPPER, ACKNOWLEDGE
	JAL	R10,INTZA1		:GO DO THE CLOSING BOOKKEEPING
	J	INTNXT

	IF 	INTACC		
INAZ24	HS	0			:Final accounting, circuit reject
	LR	R3,R4			:Get internal port index
	LI	R0,AALR24		:and logout reason
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###EV

INTZPH	JAL	R10,INTZAP
	J	INTNXT

	IF	INTACC		
DWAZ19	HS	0			:Here for bad dwl function accounting
	LR	R3,R4			:Get DWL channel index
	LI	R0,AALR19		:Logout reason 19 bad DWL function
	JAL	R8,AARLO		:Perform final accounting
	J	INTZPH			:Now Zap the circuit
	EI	:INTACC			:###ev

::*********************************************************************
::
::	ENTRY POINT:	DWLOUT:
::	FUNCTION:	FORMAT DOWN-LINE LOAD RECORD FOR NEIGHBOR
::	FORMATS A RECORD FOR THE MACHINE BEING LOADED
::	R4	=	ACTIVE DWL CHANNEL INDEX
::	R6	=	2 X R4
::
::*********************************************************************

DWLOUT	HS	0
	JAL	R7,DWLVAL		:determine if line # is valid	###wjl	

	LHI	R0,SIOIDL-SEG1		:PUT SIO LINE INTO IDLE STATE
	STH	R0,SIOTST,LN		:BY STORING ADDRESS OF THE IDLE ROUTINE
      IF	SILINS
	CLHI	LN,(NLINES-SILINS)*2	:SIO LINE?
	JGEFS	DWLSI1			:YES, IT GETS DIFFERENT TREATMENT
      EI	:SILINS
	L	R1,SIOBLA,LN,LN		:get output rotor
	LIS	R0,0			:clear any possible condition
	STH	R0,0,R1
	J	DWLOU3

      IF	SILINS
DWLSI1	LR	R1,LN
	SHI	R1,(NLINES-SILINS)*2	:REMOVE SIO LINE BIAS
	SLLS	R1,3
	LIS	R0,7			:INITIALIZE COMMAND AREA FOR SIO BOARD
	STB	R0,SIDWCM,R1,
      EI	:SILINS

DWLOU3	HS	0
	LR	R1,LN
	SRLS 	R1,1			:IDLE LINE
	RBT	R1,VRSTDL		:INSURE WE STAY IDLE
	RBT	R1,LINATT
	RBT	R1,LINDET
	LIS	R0,0			:INITIALIZE RECORD OUT PTR
	STH	R0,DWLOPT,R6
	STH	R0,DWLCIN
	STH	R0,DWLCOU
	STH	R0,DWLCLI
	STH	R0,DWBUSY,R6		:INPUT BUFFER IS FREE
	LHI	R0,DWLOU2-SEG1.2	:STORE NEW ENTRY ADDRESS	###wjl
	STH	R0,INTDSP,R6
	LHL	R0,BCT,R2,		:ANY MORE BYTES IN BUFFER?
	JE	INTNXT			:NO, DISMISS

::*********************************************************************
::
::	ENTRY POINT:	DWLOU2:
::	FUNCTION:	INTHST DISPATCHES TO HERE AFTER A VALID LINE
::			NUMBER HAS BEEN RECEIVED
::
::*********************************************************************

DWLOU2	HS	0
	SBT	R4,INTACT		:MARK AS ACTIVE TO AVOID TIMEOUT
	LR	R6,R4
	AR	R6,R6
	LHL	LN,DWLNUM,R6		:GET LINE NUMBER
	IF	SILINS
	CLHI	LN,(NLINES-SILINS)*2	:SIO LINE?
	JGE	DWLSI3			:YES, BRANCH AWAY FOR SPECIAL TREATMENT
	EI	:SILINS

	L	R1,SIOBLA,LN,LN		:get address of output ROTOR
	LHL	R0,0,R1			:get status of current output
	JN	INTNXT			:if non zero then still sending
	LR	R7,R6			:FORM DWOBUF OFFSET (66*DWL LINE INDEX)
	SLLS	R7,5			:...= (33 X R6)
	AR	R7,R6
	LHL	PRD,DWLOPT,R6		:GET OUTPUT PTR
	JN	DWLOU1
	JAL	R8,CBCCT,,		:WAIT FOR A FEW BYTES
	SIS	R1,4
	JLE	INTNXT
	JAL	R9,INTGET
	CLHI	R1,32			:WAIT FOR HEADER
	JN	INTNXT
	JAL	R8,GCI,,			:DISCARD NEXT 32
	LHI	R1,3232			:SET HEADER
	STH	R1,DWOBUF,R7,
DWLOU1	JAL	R9,INTGET		:GET NEXT BYTE
	STB	R1,DWOBUF+2,PRD,R7
	AIS	PRD,1
	NHI	PRD,3F
	STH	PRD,DWLOPT,R6
	JN	DWLOU1

:	TARGET MACHINE RECORD ASSEMBLED...SET UP SVC CALL TO TRANSMIT
:	BLOCK. R0=line number, R1= address of rotor.  Notice that the
:	force output SVC just in case any output was still being done
:	by the foreground (the line was put in idle state so fg could
:	only do this to the first downline load record).
	LR	R0,LN
	SRLS	R0,1			:TARGET LINE NUMBER
	L	R1,SIOBLA,LN,LN		:get address of rotor
	LA	R2,DWOBUF,R7,		:POINT TO BLOCK TO BE TRANSMITTED
	ST	R2,4,R1			:store address of data into rotor
	LHI	R3,42			:ISIS EXPECTS LENGTH IN HALFWORDS

	STH	R3,2,R1			:byte count to transmit
	LIS	R3,1			:write the output command
	STH	R3,0,R1
	SVC	IO,20+R0		:output SVC
	J	SVCR32			:handle error
	IF	INTACC			
	LHI	R0,42			:Load byte count - expected in R0
	LR	R3,R4			:Internal host port index in wrk reg
	JAL	R8,AARDIC		:Accumulate to INput count to DWload
	EI	:INTACC			:###EV
	SRLS	R6,1
	SBT	R6,INTACT		:MARK LINE AS ACTIVE FOR INTOUT
	LIS	R0,1
	AHM	R0,DWLCOU
	J	INTNXT			:AND GO TO NEXT LINE

SVCR32	JAL	R0,SVCE32,,		:calls crash
	J	INTNXT			:just in case get returned

:	FOR SIO LINES A DIFFERENT SVC IS CALLED. THE MOTHERBOARD IS 
:	PASSED A QUAD WORD ADDRESS IN R1 WHICH IS THE BEGINNING OF THE
:	CHANNEL OUTPUT COMMAND ROUTINE.  FOR ISIS R0 = LINE NO.

	IF	SILINS
DWLSI3	LR	R7,LN
	SHI	R7,(NLINES-SILINS)*2	:REMOVE SIO LINE BIAS
	SLLS	R7,3			:USE LINE# X 10 (HEX) FOR CONVENIENCE
	LB	R0,SIDWCM,R7,		:SIO CARD DONE TRANSMITTING?
	JE	INTNXT			:NOPE, DISMISS
	SLLS	R7,3			:USE LINE# X 80 (HEX) FOR CONVENIENCE
	LHL	PRD,DWLOPT,R6		:IN THE MIDDLE OF SOMETHING?
	JN	DWLSI4			:YES
DWLS3B	JAL	R8,CBCCT,,		:NO, DO WE HAVE 4 BYTES TO WORK WITH?
	SIS	R1,4
	JL	INTNXT			:NO, DISMISS UNTIL WE DO
	JAL	R9,GHWI,,		:GET FIRST TWO BYTES
	CLHI	R1,3232			:AND CHECK FOR DWL HEADER
	JN	INTNXT			:ISN'T A HEADER, DISMISS
	STH	R1,SIDWBF+2,R7,PRD	:IS A HEADER. STORE INTO OUT-BUFFER
DWLSI4	JAL	R9,INTGET		:GET ANOTHER BYTE
	STB	R1,SIDWBF+4,PRD,R7	:AND STORE INTO OUT-BUFFER
	AIS	PRD,1			:INCREMENT POINTER
	NHI	PRD,3F			:MOD 40 (HEX)
	STH	PRD,DWLOPT,R6
	JN	DWLSI4			:LOOP BACK TILL WE HAVE 40 (HEX) BYTES
DWLS15	SRLS	R7,3			:USE LINE #  X  10 (HEX) FOR EASE...
	LA	R1,SIDWCM,R7,		:R1=ADDRESS OF CHANNEL COMMAND ROUTINE
	LR	R0,LN			:R0= 2*LINE NUMBER
	LIS	R2,1			:FORM OUTPUT COMMAND
	STH	R2,SIDWCM,R7,		:AND STORE IT INTO COMMAND AREA
	SRLS	R0,1			:ISIS WANTS ACTUAL LINE NO
	TBT	R0,SIOPTA		:IS SIO PORT AVAILABLE?		###OAS
	JNFS	SIOPT7			:NO, SKIP SVC
	SVC	IO,0B0			:Force M-board output
	JAL	R12,SVCR3B		:ERROR, HANDLE IT		###OAS
SIOPT7	HS	0
	LIS	R0,1			:EVERYTHING OK
	AHM	R0,DWLCOU
DBZRET	SRLS	R6,1
	SBT	R6,INTACT		:MARK LINE AS ACTIVE
	IF	INTACC			
	LHI	R0,40			:SIO records are 40 hex bytes
	LR	R3,R6			:SIO uses R6 for port index wrk reg
	JAL	R8,AARDIC		:Accumulate character count
	EI	:INTACC			:###EV
	J	INTNXT			:GO SERVICE NEXT LINE



SVCR3B	J	SVCE3B,,		:HANDLE SVC ERROR IN LINKER

	EI	:SILINS

::*********************************************************************
::
::	ENTRY POINT:	PLIMSG:
::	FUNCTION:	PLI MESSAGE
::	RECEIVES A SLOT NUMBER, TYPE BYTE, BYTE COUNT, DATA, AND CHECKSUM
::	FROM A HOST MACHINE. PLICNT SERVES AS A STATE COUNTER AS WELL AS BYTE 
::	COUNT
::
::*********************************************************************

PLIMSG	HS	0
	SBT	R4,INTACT		:NOTE WE ARE ACTIVE FOR TIMEOUT
	LH	R3,PLICNT		:GET PRESENT STATUS FROM PLICNT
	JGE	PLIMS0			:=>0 MEANS TAKING DATA
	CLHI	R3,0FFFC		:-4 MEANS TAKING BYTE COUNT
	JE	PLIMS2
	CLHI	R3,0FFFE
	JE	PLIMS1			:-2 MEANS TAKING TYPE BYTE 
	LIS	R0,0			:FALLTHROUGH MEANS TAKING SLOT#
	STH	R0,PLIXOR		:INITIALIZE CHECKSUM AND
	STH	R0,PLINDX		:CURRENT BYTES RECEIVED COUNT
	JAL	R9,INTGET		:GET SLOT NUMBER
	CLHI	R1,3F			:MAX SLOT NUMBER = 63
	IF	INTACC		
	JG	PLAZ19			:Accounting and zap
	ELSE
	JG	INTZPH			:RIDICULOUS SLOT NUMBER, ZAP!
	EI	:INTACC			:###EV
	STH	R1,PLISLT		:OK, STORE
	LCS	R0,2
	STH	R0,PLICNT		:SET PLICNT TO -2
PLIMS1	JAL	R9,INTGET		:GET THE TYPE BYTE
	LR	R1,R1			:VERIFY THAT ITS 0
	IF	INTACC		
	JN	PLAZ19			:Accounting and zap
	ELSE
	JN	INTZPH			:NO, ZAP THE CRQ
	EI	:INTACC			:###EV
	LCS	R0,4
	STH	R0,PLICNT		:SET PLICNT TO -4 
PLIMS2	JAL	R9,INTGET		:GET THE BYTE COUNT
	STH	R1,PLICNT		:MESSAGE IS OK. STORE COUNT
PLIMS0	JAL	R9,INTGET		:GET A CHARACTER
	LHL	R3,PLINDX
	CLH	R3,PLICNT		:GOT ALL THE DATA?
	JEFS	PLIMS5			:YES, DEAL WITH CHECKSUM
	STB	R1,PLIDAT,R3		:STORE DATA
	AIS	R3,1			:INCREMENT DATA RECEIVED COUNT
	STH	R3,PLINDX
	LHL	R3,PLIXOR		:PERFORM CHECKSUM
	XR	R3,R1
	STH	R3,PLIXOR
	J	PLIMS0			:AND LOOP BACK
PLIMS5	CLH	R1,PLIXOR		:DO CHECKSUMS MATCH?
	IF	INTACC		
	JN	PLAZ19			:Accounting and zap
	ELSE
	JN	INTZPH			:NO, ZAP THE CRQ
	EI	:INTACC			:###EV
	XHI	R2,4			:YES, SO ECHO CHECKSUM, ESCAPED
	JAL	R9,WCIE,,
	LHL	R0,PLICNT		:MOVE PLICNT TO PLICN2
	JEFS	PLIMS6			:0-LENGTH MESSAGE--reset from IULMSG
	TS	PLIXOR			:SET PLIXOR TO FFFF TO TURN MESSAGE ON
	STB	R0,PLICN2		:PERMIT USE OF 'BUFCAN' ROUTINE

PLIMS6	HS	0
       IF       1-NCSLOT
	AIS	R0,6			:R0 = LENGTH OF DISPATCHER MESSAGE
	JAL	R8,DIROOM,,		:DISMISS UNTIL THE SPACE IS AVAILABLE
	LHL	R15,DRIF,,		:CURRENT FILL POINTER
	LHL	R3,PLISLT		:SLOT NUMBER
	SLLS	R3,2			:WE WANT 4*SLOT#
	AHI	R3,IN1DWN^8		:R3=<00><00><0E><4*SLOT#>
	ST	R3,DIRNG,R15,,		:FIRST FOUR BYTES OF MESSAGE
	AIS	R15,4
	NHI	R15,DRSZ-1
	LHL	R3,PLICNT
	STH	R3,DIRNG,R15,,		:STORE TYPE AND COUNT
	AIS	R15,2			:INCREMENT FILL INDEX
	NHI	R15,DRSZ-1
	LIS	R2,0			:INITIALIZE PLIDAT INDEX
PLIMS8	SIS	R3,1			:ZERO MESSAGE BYTES LEFT?
	JLFS	PLIMS7			:YES,EXIT
	LB	R1,PLIDAT,R2		:GET NEXT MESSAGE BYTE
	STB	R1,DIRNG,R15,,		:STORE IT INTO THE DISPATCHER RING
	AIS	R15,1			:INCREMENT FILL INDEX
	NHI	R15,DRSZ-1		:AND REDUCE MOD DRSZ
	AIS	R2,1			:INCREMENT PLIDAT INDEX
	JBS	PLIMS8			:AND REPEAT
PLIMS7	AIS	R15,3
	NHI	R15,DRSZ-4		:ROUND FILL POINTER UP TO NEXT WORD
	STH	R15,DRIF,,
	IF	INTACC			
	LHL	R0,PLICNT		:Count of charaters input
	LR	R3,R4			:Get port index in wrk register
	JAL	R8,AARDIC		:Accumulate characters
	EI	:INTACC			:###EV
       EI       :1-NCSLOT
	J	INTNXT			:GO SERVICE NEXT INTHST CHANNEL

	IF	INTACC		
PLAZ19	HS	0			:Here for bad dwl function accounting
	LR	R3,R4			:Get DWL channel index
	LI	R0,AALR19		:Logout reason 19 bad DWL function
	JAL	R8,AARLO		:Perform final accounting
	J	INTZPH			:Now Zap the circuit
	EI	:INTACC			:###ev

::*********************************************************************
::
::	ENTRY POINT:	REMXRY:
::	FUNCTION:	INTERFACE BETWEEN XRAY AND THE NETWORK.
::	SCANS THE DATA STREAM FOR 'Z' (LOGOUT) OR ^C OR & (BREAK, RESTART XRAY)
::	& RESTARTS XRAY BECAUSE ^C HAS A SPECIAL MEANING FOR NAD IN PDP MODE
::	****	NOTE	****
::	R4 IS NOT EXPLICITLY USED BUT CONTAINS THE INTERNAL HOST PORT INDEX
::	AND IS NEEDED SHOULD THE BRANCH TO INTZPH OCCUR.
::
::*********************************************************************

REMXRY	HS	0
	JAL	R8,CBCCT,,		:GET CHARACTER COUNT 
	LR	R5,R1
	LB	XN,XNINT,R4,
	LHL	XD,XDXN,XN,XN		:GET USER BLOCK POINTER
	LHL	R6,XRYPTF,XD
	IF	INTACC			
	GL	AARDIC
	LIS	R14,0			:Init character counter
	EI	:INTACC			:###ev	
REMXR1	LR	R5,R5
	JE	REMXR2			:NO MORE DATA
	AIS	R6,1			:MAKE SURE WE HAVEN'T WRAPPED AROUND
	NHI	R6,XBFSZE-1		:MOD BUFFER SIZE
	CLH	R6,XRYPTE,XD,		:TO EMPTY POINTER
	JE	REMX20			:NO ROOM
	SIS	R6,1			:OK SO RESTORE FILL POINTER AND PROCEDE
	NHI	R6,XBFSZE-1		:MOD BUFFERSIZE
	JAL	R9,GCXRAY		:GET NEXT CHARACTER
	STB	R1,XRYBFI,R6,XD		:AND MOVE TO XRAY BUFFER
	NHI	R1,7F			:STRIP MSB
	CLHI	R1,1A			:UNCONDITIONALLY END SESSION IF ^Z
	IF	INTACC			
	JE	AARXLG			:Perform logout accounting
	JFS	REMXJ1			:REMOVE AFTER TESTING
	EI	:INTACC			:###EV	
	JE	INTZPH			:GO ZAP AND DO CLOSING BOOK-KEEPING
REMXJ1	CLHI	R1,03			:CHECK FOR ^C
	JEFS	REMXZ1			:YES
	CLHI	R1,26			:OR &
	JN	REMXR9			:NO

REMXZ1	HS	0
	IF	INTACC			
	LR	R0,R14			:Expect counts in R0
	LR	R3,R4			:Get port index in work reg
	JAL	R8,AARDIC		:Accumulate characters so far
	EI	:INTACC			:###EV
	XHI	R2,4
	JAL	R9,GOBBLN		:SEND GOBBLER TOWARDS USER

REMXRZ	HS	0			:ENTRY POINT TO RESTART XRAY
	LHL	R0,XRYPTF,XD		:FLUSH INPUT RING
	STH	R0,XRYPTE,XD
	LHI	R1,01F-PXRAY
	SBT	R1,SQUEUE		:SCHEDULE XRAY OFF EXEC QUEUE
	LHL	XN,XUSLTN,XD		:THIS USER'S XRAY SLOT NO.
	SBT	XN,XQUEM,,		:SET XRAY USER QUEUE
	LHL	XD,XDXN,XN,XN		:RESTORE XRAY USER BLOCK POINTER
	LI	R1,XRAYIS		:INITIAL ADDRESS FOR XRAY USER
	GL	XRAYIS
	ST	R1,XRYADR,XD,
	J	INTNXT

	IF	INTACC			
AARXLG	HS	0			:Perform logout accounting
	LR	R3,R4			:Get internal port index in wrk reg
	LIS	R0,AALR03		:Pass logout reason to accting 
	JAL	R8,AARLO		:Call accounting
	GL	AARLO
	J	INTZPH			:Zap & do closing cleanup
	EI	:INTACC			:###EV

REMXR9	AIS	R6,1			:INCREMENT FILL INDEX
	NHI	R6,XBFSZE-1		:MOD BUFFER SIZE
	SIS	R5,1			:DECREMENT BYTE COUNT INDEX
	IF	INTACC			
	AIS	R14,1			:And add to character count
	EI	:INTACC			:###EV
	J	REMXR1			:AND LOOP BACK

REMX20	SIS	R6,1			:RAN OUT OF ROOM IN INPUT RING,SO
	NHI	R6,XBFSZE-1		:RESTORE FILL POINTER
REMXR2	STH	R6,XRYPTF,XD		:STORE AWAY FILL POINTER
	IF	INTACC			
	LR	R0,R14			:Expects count in R0
	LR	R3,R4			:Get port index in work reg
	JAL	R8,AARDIC		:Accumulate character count
	EI	:INTACC			:###EV
	LHI	R0,01F-PXRAY		:SCHEDULE XRAY OFF EXEC LOOP
	SBT	R0,SQUEUE
	LHL	XN,XUSLTN,XD		:THIS USER'S XRAY SLOT NO.
	SBT	XN,XQUEM,,		:SCHEDULE IN XRAY USER'S QUEUE
	LHL	XD,XDXN,XN,XN		:RESTORE POINTER TO XRAY USER BLOCK
	J	INTNXT			:AND RETURN TO MAINLINE

::*********************************************************************
::
::	ENTRY POINT:	DLYREC:
::	FUNCTION:	RECEIVING END FOR DELAY MEASUREMENT.
::		RECEIVES DATA AS HW OF FASTC, COMPUTES DELAY, STORES INTO
::		DLYTBL, AND DOES MINOR SIGNAL PROCESSING TRAVEL TIME IS STORED
::		IN UNITS OF 8/600 SEC, OR 13.333 MS
::		R2 = BUFFER NUMBER
::		R4 = INTERNAL HOST CHANNEL INDEX
::
::*********************************************************************

DLYREC	HS	0
	LHL	R7,FASTC+2,,		:GET CURRENT TIME
	LR	R6,R4			:SAVE INDEX BEFORE GHWI CLOBBERS IT
DLYRE1	LR	R5,R7			:COPY FASTC OVER
	JAL	R8,CBCCT,,		:GET CHARACTER COUNT IN BUFFER
	SIS	R1,2			:WANT HW OF FASTC (NEVER ESCAPED)
	JL	INTNXT			:NO, NOT ENOUGH DATA. GO AWAY
	JAL	R9,GHWI,,		:GET THE HW 
	CHI	R1,FILLCH		:IS IT A FILL CHARACTER?
	JEBS	DLYRE1			:YES,GET ANOTHER
	SR	R5,R1			:GOT FASTC, SUBTRACT OUT TRAVEL TIME 
	JGFS	DLYRE2			:NO WRAP-AROUND
	AI	R5,10000		:CORRECT FOR WRAP-AROUND
DLYRE2	LHL	R1,CHNDLY,R6,R6		:CHAN NUMBER TO USER ADDRESS LINK TBL
        AI      R1,DLYBSE               :address this kid's data block  ###sdw
	LHL	R3,DLYPTF,R1		:FILL POINTER FOR THIS TEST
	STH	R5,DLYTBL,R1,R3		:AND STORE INTO DATA TABLE
	AIS	R3,2			:INCREMENT DLYTBL FILL PTR
	NHI	R3,DLYTSZ-1		:AND REDUCE
	STH	R3,DLYPTF,R1
	LHL	R3,DLYAV1,R1		:GET RUNNING AVERAGE
	JEFS	DLYREZ			:0 SO DON'T FILTER
	SRLS	R5,4			:1/16 OF SAMPLE
	SRLS	R3,4			:1/16 OF RUNNING AVERAGE
	SR	R5,R3			:(NEW-OLD)/16
DLYREZ	AHM	R5,DLYAV1,R1		:UPDATE RUNNING AVERAGE (OLD)
	LHL	R5,DLYAV1,R1		:GET R/A#1
	LHL	R3,DLYAV2,R1		:GET R/A#2
	JEFS	DLYREY			:IF 0 DON'T FILTER
	SRLS	R5,3			:1/8 OF R/A#1
	SRLS	R3,3			:1/8 OF R/A#2
	SR	R5,R3			:1/8*(R/A#1 - R/A#2)
DLYREY	AHM	R5,DLYAV2,R1		:UPDATE R/A#2
	J	DLYRE1			:AND RETURN

::*********************************************************************
::
::	ENTRY POINT:	DLYSFL:
::	FUNCTION:
::		THE FIRST two DATA BYTEs RECEIVED ON THE DATA SOURCE
::		CHANNEL IS CONSIDERED TO BE THE HW FILL COUNT FOR THAT
::		CHANNEL. ALL SUBSEQUENT DATA RECEIVED IS CONSIDERED TO
::		BE AN ERROR.
::
::*********************************************************************

DLYSFL	HS	0
	JAL	R9,INTGET		:GET THE HW FILL COUNT
	STB	R1,CHNFIL+1,R4,R4	:first is low order byte	###JHL
	JAL	R9,INTGET		:				###JHL
	STB	R1,CHNFIL,R4,R4		:next is the high order byte	###JHL
        jal     r9,intget               :get rate
        sth     r1,dlyint,r4,r4         :new logic sends rate to destination
	LHI	R0,DLYERR-SEG1.2	:ACCEPT NO MORE DATA HERE	###wjl
	STH	R0,INTDSP,R4,R4
	J	INTNXT

::*********************************************************************
::
::	ENTRY POINT:	DLYERR:
::	FUNCTION:	BIT BUCKET FOR UNWANTED DATA
::
::*********************************************************************

DLYERR	HS	0
	J	INTNXT			:BIT BUCKET FOR UNWANTED DATA

::*********************************************************************
::
::	ENTRY POINT:	LOOPBK:
::	FUNCTION:	CHASES ITS TAIL...
::
::*********************************************************************

LOOPBK	HS	0
	LHL	R10,INTLPF		:GET LOOPBACK BIT ARRAY
	JFFOH	R10,LOOPB1		:FIND INT HOST CHANNEL THAT IS SENDING
	J	LOOPNX			:NOT THERE, PROBABLY ZAPPED
LOOPB1	JAL	R8,CBCCT,,		:GET BYTE COUNT IN OUR INPUT BUFFER
	LR	R10,R1			:AND SAVE IT
	LHL	R11,INTTAB,R11,R11	:GET INPUT BUFFER FOR OTHER SIDE
	NHI	R11,-4			:STRIP SPEED BITS
	LR	R12,R2			:SAVE BUFFER #
LOOPB2	LR	R2,R12
	JAL	R8,GCI,,		:READ ONE CHARACTER FROM OUR IN-BUFFER
	LR	R2,R11
	JAL	R8,WCI,,		:AND WRITE INTO OTHER CHANL'S BUF##AL
	SIS	R10,1			:MORE DATA?
	JGBS	LOOPB2			:YES, GET IT
	J	INTNXT

LOOPNX	JAL	R8,CBCLR,,		:CLEAR ALL DATA THAT HAS NOWHERE TO GO
	J	INTNXT

	SUBTTL	INTHST (Utilities)

::*********************************************************************
::
::	SUBROUTINE:	INTSLT:
::	FUNCTION:	GET AN XRAY SLOT FOR AN XRAY/IIXRAY USER
::	CALLING SEQ:	JAL	R7,INTSLT
::
::*********************************************************************

INTSLT	ST	R7,INTSAV+0A		:save return			###wjl
	LIS	R1,1			:ANY XRAY SLOTS? (SLOT 0 FOR TTY)
INTS10	SBT	R1,XUSIUA
	JN	INTS12			:NOT THIS ONE, GO TRY AGAIN
	STB	R1,XNINT,R4,		:XN INTO ARRAY BY INTERNAL HOST PORT
	LHL	XD,XDXN,R1,R1		:GET POINTER TO USER BLOCK
	GL	XDXN
	STH	R8,XUNAME,XD		:USER GG INDEX INTO XRAYUSER BLOCK
	L	R7,INTSAV+0A		:get return address		###wjl
	JR	R7			:GO PROCESS REMOTE XRAY/IIXRAY	###wjl

INTS12	AIS	R1,1
	CLHI	R1,NXUBLK-1
	JLE	INTS10

:	NO SLOTS EMPTY, CHECK FOR OVERRIDE
	LIS	R1,1			:NO SLOTS EMPTY, CHECK FOR OVERRIDE
INTS20	LHL	XD,XDXN,R1,R1		:GET SLOT USERS XRAY USERBLOCK
	LH	R9,XUNAME,XD		:GET SLOT USERS GOODGUY INDEX
	LB	R9,XRAYGG+XGGOVR,R9,	:GET SLOT USERS OVERRIDE LEVEL
	CLB	R9,XRAYGG+XGGOVR,R8,	:COMPARE WITH REQ USERS OVERRIDE LEVEL
	JL	INTS30			:REQUESTOR OVERRIDES CURRENT SLOT
	AIS	R1,1			:TRY NEXT SLOT
	CLHI	R1,NXUBLK-1		:UNTIL WE RUN OUT
	JLE	INTS20
	J	INTS40			:NO SLOTS, REJECT REQUESTOR

:	REQUESTOR OVERRIDES CURRENT SLOT, ZAP VICTIM
INTS30	STH	R2,INTSAV		:SAVE OUR BUFFER #
	STH	R1,INTSAV+2		:AND OUR SLOT# * 4
	STH	R4,INTSAV+4		:AND OUR INTHOST INDEX
	STH	R8,INTSAV+8		:SAVE GGLIST INDEX
	LHL	XD,XDXN,R1,R1		:GET OUR VICTIM'S POINTER
	IF	INTACC		
	LHL	R3,XUINTH,XD		:Get internal port index (poor guy)
	LI	R0,AALR26		:and logout reason (tuff luck buddy)
	JAL	R8,AARLO		:Tell Sup this guy is finished
	EI	:INTACC			:###EV
	LHL	R2,XRYBFO,XD		:GET HIS OUT BUFFER #
	L	R4,DETACP,,		:FIND AN AVAIL. DETACHED PROCESS PORT
	JFFO	R4,INTS32		:IF POSSIBLE
	LHL	R4,XUINTH,XD		:ELSE GET VICTIM'S INTHOST PORT INDEX
	JAL	R10,INTZAP		:AND JUST ZAP 
	J	INTS34			:AND CONTINUE

:	FOUND A DETACH PORT, SEND A DETACH MESSAGE
INTS32	LHL	R4,XUINTH,XD		:GET VICTIM'S INTHOST INDEX
	LIS	R0,6			:DETACH MESSAGE #6 (XRAY SLOT OVERRIDE)
	STB	R0,DETMTY,CHN
	LHI	R1,0D0A			:CRLF FOR FAKE ZAPPER
	JAL	R9,ZAPX			:REMOVE INTTAB ENTRY, SET ACP
	STH	R2,INTSAV+6		:SAVE R2 FROM INTZA1
	JAL	R10,INTZA1		:INTHOST CLEANUP
	LHL	R2,INTSAV+6		:RECOVER R2
	AHI	CHN,DETZFL		:DETACH PROCESS ABS CHAN #
	JAL	R9,CRQHCR		:CONNECT CRQ STUB TO DETACH PROCESS
	XHI	R2,4			:POINT TOWARD DETACH PROCESS AND
	LIS	R1,3			:WRITE NEEDLE POINT INTO BUFFER
	JAL	R8,WCI,,			:TO ALERT DETCIR OF NEW PORT
	LHI	R1,NEEDP
	JAL	R8,WCI,,
INTS34	LHL	R1,INTSAV+2		:RECOVER OUR SLOT# * 4
	LHL	R2,INTSAV		:AND OUR OUT BUFFER#
	LHL	R4,INTSAV+4		:AND OUR INTHOST INDEX
	LHL	R8,INTSAV+8		:RECOVER GGLIST INDEX
	RBT	R1,XUSIUA		:FREE UP THE SLOT
	J	INTS10			:TAKE OVER THE SLOT

:	NO SLOTS AVAILABLE, REJECT REQUESTOR
INTS40	STH	R4,INTSAV+4		:SAVE OUR INTHOST INDEX
	L	R4,DETACP,,		:FIND A DETACH PORT
	JFFO	R4,INTS42
	LHL	R4,INTSAV+4		:ELSE RECOVER OUR INTHOST INDEX
	IF	INTACC		
	LR	R3,R4
	LI	R0,AALR19		:Get logout reason
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###ev
	J	INTZPH			:AND GET ZAPPED

:	FOUND A DETACH PORT, SEND A DETACH MESSAGE
INTS42	LHL	R4,INTSAV+4		:FOUND ONE, RECOVER INHOST INDEX
	LIS	R0,5			:DETACH MESSAGE (OUT OF XRAY SLOTS)

INTS50	STB	R0,DETMTY,CHN		:SET UP FOR DETACH PROCESS
	LHI	R1,ASCCR^8+ASCLF	:FAKE ZAPPER - CRLF (0D0A)
	XHI	R2,4			:FLIP TO OUT BUFF#
	JAL	R9,ZAPX			:ZAP HALF
	JAL	R10,INTZA1		:AND INTHOST CLEANUP
	AHI	CHN,DETZFL		:ABS CHN # FOR DETACH PROCESS
	JAL	R9,CRQHCR		:CONNECT CRQ STUB TO DETACH PROCESS
	XHI	R2,4			:POINT TOWARD DETACH PROCESS AND
	LIS	R1,3			:WRITE NEEDLE POINT INTO BUFFER
	JAL	R8,WCI,,
	LHI	R1,NEEDP
	JAL	R8,WCI,,
	J	INTNXT			:BACK TO THE TOP

:	BAD USERNAME, REJECT REQUESTOR
INTH60	HS	0			:REJECT REQUESTOR, BAD USERNAME
	IF	INTACC		
	LR	R3,R4			:Internal port index
	LI	R0,AALR11		:Accounting logout reason
	JAL	R8,AARLO		:Perform final accounting
	EI	:INTACC			:###EV
	STH	R4,INTSAV+4		:SAVE OUR INTHOST INDEX
	L	R4,DETACP,,		:FIND A DETACH PORT
	JFFO	R4,INTH61
	LHL	R4,INTSAV+4		:ELSE RECOVER OUR INTHOST INDEX
	J	INTZPH			:AND GET ZAPPED

:	FOUND A DETACH PORT, SEND A DETACH MESSAGE
INTH61	LHL	R4,INTSAV+4		:FOUND ONE, RECOVER INHOST INDEX
	LIS	R0,7			:DETACH MESSAGE (BAD USERNAME)
	J	INTS50			:set up for detach process	###wjl

::*********************************************************************
::
::	SUBROUTINE:	INTGET:
::	FUNCTION:	GET A BYTE
::	CALLING SEQ:	JAL	R9,INTGET
::
::*********************************************************************

INTGET	HS	0
	LHL	R1,BCT,R2,
	JE	INTNXT			:THIS BUFFER IS EMPTY
	JAL	R8,GCI,,
	LR	R1,R1
	JNR	R9			:UNESCAPED, RETURN
	JAL	R8,GCI,,		:ESCAPED, GET NEXT CHARACTER
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	INTZAP:
::	FUNCTION:	INTZAP ZAPS THE FIRST HALF OF A CRQ AND DOES
::		THE CLEAN-UP OF THE INTERNAL HOST STATUS FLAGS AND ARRAYS
::	LINK:		R10, R11 (R10 PRESERVED IN R11 FOR RETURN LINK)
::	INPUT:		R2 = BUFFER NO.
::			R4 = INTERNAL HOST CHANNEL INDEX
::	DESTROYED:	R0, R1, R3, R8, R9
::
::*********************************************************************

INTZAP	HS	0
	XHI	R2,4			:WE EXPECT THE INBOUND BUFFER NO.
	JAL	R9,ZAPHRD		:SO FLIP  AND ZAP
INTZA1	LIS	R0,0			:ALTERNATE ENTRY POINT FOR INTZAK
	STH	R0,INTDSP,R4,R4		:CLEAR DISPATCH ADDRESS
	RBT	R4,INTUSE		:CLEAR LOGIN OVER BIT
	RBT	R4,INTWRN		:CLEAR TIMEOUT WARNING BIT
	RBT	R4,INTOUT		:CLEAR TIMEOUT ENABLE BIT
					:CLEAR FLAGS FOR SPECIFIC FUNCTIONS
	RBT	R4,INTDSF		:CLEAR DELAY MEASUREMENT SOURCE CHN BIT
	RBT	R4,INTLPF		:CLEAR LOOPBACK CHANNEL BIT
	JNFS	INTZ11			:LOOPBACK FUNCTION, SPECIAL CLEANUP
	RBT	R4,INTXRF		:TEST AND CLEAR REMOTE XRAY BIT
	JEFS	INTZA8
	JAL	R12,REMZAP		:DO CLOSING BOOK KEEPING FOR REM XRAY
	JR	R10

INTZA8	RBT	R4,INTDRF		:CLEAR AND TEST DELAY RECEIVER CHN BIT
	JE	INTZA6
INTZ11	LHL	R1,CHNDLY,R4,R4		:CHN INDEX TO DELAY USER OFFSET TABLE
        AI      R1,DLYBSE               :address this gal's data block  ###sdw
	LCS	R0,1
	STH	R0,DLSTAT,R1		:NOTE THE CHAN ZAPPED IN STATUS FIELD
					:###JHL
	LHL	R3,INTNDX,R4,R4		:READ INDEX FROM ARRAY BY INTHST CHAN#
	AR	R3,R3			:GET HW INDEX FROM BYTE INDEX
	LCS	R0,1			:STORE -1 TO SHOW USED--IDLE INFO ONLY
	ST	R0,DB0USE,R3,R3		:ERASE XRY USRBLK ENTRY FOR INDEX
	STH	R0,INTNDX,R4,R4		:ERASE INDEX ARRAY ENTRY FOR CHAN

INTZA6	RBT	R4,INTDWF		:TEST AND CLEAR DWL BIT
	JER	R10			:DONE
	LR	R11,R10			:Save return register
	LH	LN,DWLNUM,R4,R4		:Get line index (2*line #)
	JL	INTZ15

	J	INTZA5			:For non-Starhub machines
INTZ15	XHI	LN,-1			:INVALID LINE NUMBER, COMLEMENT
	LR	R0,LN			:MOVE LINE # AND REASON TO R0
	LBR	LN,R0			:ISOLATE LINE NUMBER (LOWER BYTE OF LN)
	SRLS	R0,8			:MOVE REASON FOR REJECT TO LOWER BYTE
	J	INTZA4			:MAKE CRYPTO REPORT

INTZA5	HS	0
	RBT	LN,DWLDSP		:RESET DWL DISPATCH ARRAY BIT
      IF	SCLP
	LIS	R0,0			:clear INTHST CHN # from SKYCHN	###wjl
	STH	R0,SKYCHN,LN,		:
      EI	:SCLP
	STH	R4,INTCHN		:save R4 from being clobbered	###wjl
	JAL	R9,RSTSTR,,		:PUT LINE BACK IN RESET MODE
	LHL	R4,INTCHN		:recover INTHST channel number	###wjl
	LIS	R0,0			:REASON FOR ZAP = ZAPPER RECEIVED
	SRLS	LN,1			:GET TRUE LINE NUMBER FOR XRAY	###OAS
INTZA4	STH	LN,CRYSBF		:AND STORE AWAY INTO HW3
	JAL	R8,CRYPTO,,
	HC	CRYE2D			:DWL LINE ZAP MESSAGE
	LCS	R0,1
	STH	R0,DWLNUM,R4,R4		:REINITIALIZE DWLNUM TO -1

	JR	R11

::*********************************************************************
::
::	SUBROUTINE:	REMZAP:
::	FUNCTION:	DO CLOSING BOOK KEEPING FOR REMOTE XRAY
::	CALLING SEQ:	JAL	R12,REMZAP
::
::*********************************************************************

REMZAP	HS	0
	LIS	R1,0
	JAL	R11,XWRITE,,		:GET SEG1 WRITE ACCESS
	LB	XN,XNINT,R4,		:SET UP XD
	STB	R1,XNINT,R4,
	LHL	XD,XDXN,XN,XN
REMZAI	HS	0		:alt entry for ISIS DDT quitters
	IF	(XRSZLV-2)		:XRAY SIZE SAVING LEVEL ##AL
	JAL	R9,REMTR0,,		:GO RESET ANY TRAPS
	GL	REMTR0
	EI	:(XRSZLV-2)		:XRAY SIZE SAVING LEVEL ##AL
REMZA3	LHI	R11,TINTCH-2		:SET HW OFFSET TO LOOP DB INDICES
:	DB0USE STARTS A WORD-ARRAY, DLYCHN IS A HW ARRAY, EACH BY DB-INDEX
REMZA4	C	XD,DB0USE,R11,R11	:CLEAR DELAY CIRCUIT IF NECESSARY
	JN	REMZA5			:NOT THIS GUY
	LHL	R6,DLYCHN,R11		:INT HOST CHN # FOR DB-R11
	RBT	R6,INTDRF		:MAKE SURE IT'S BEING USED
	JN	REMZA6			:YES				###JHL
	RBT	R6,INTLPF		:IF NOT, IS IT LOOPBACK CH?
	JE	REMZA5			:JUMP IF CHANNEL NOT IN USE
REMZA6	LIS	R0,0			:CH IN USE--ZAP IT		###JHL
	STH	R0,INTDSP,R6,R6		:CLEAR DISPATCH ADDRESS
	RBT	R6,INTUSE		:CLEAR LOGIN OVER BIT
	RBT	R6,INTWRN		:T/O WARNING
	RBT	R6,INTOUT		:T/O
	RBT	R6,INTLST		:remove from service list       ###sdw
	AHI	R6,INTZFL		:GET ABS CHN NO.
	LHL	R2,IOTAB,R6,R6		:OUT BUFFER
	JE	REMZA5			:ALREADY ZAPPED
	NHI	R2,-4			:STRIP SPEED BITS
	JAL	R9,ZAPHRD		:ZAP DB0 CIRCUIT
	LHL	R6,DLYCHN,R11		:INT HOST CHN # FOR DB-R11
	LCS	R0,1
	ST	R0,DB0USE,R11,R11	:CLEAR XRY USRBLK PTR BY DB-INDEX
	STH	R0,INTNDX,R6,R6		:CLEAR DB-INDEX BY INTHST CHAN #
	LHL	R6,CHNDLY,R6,R6		:DATA AREA POINTER
        AI      R6,DLYBSE               :address this guy's data block  ###sdw
	LCS	R0,2			:INDICATE ZAPPED BY USER
	STH	R0,DLSTAT,R6		:LOGOFF
REMZA5	SIS	R11,2			:STEP BACK TO NEXT DB-INDEX
	JGE	REMZA4			:LOOP THROUGH ALL DB-INDICES
	
REMZA2	JAL	R11,XCLEAN,,		:DO CLOSING CLEANUP
	GL	XCLEAN
	STH	R0,XPOWER,XD
	LHL	XN,XUSLTN,XD		:GET USER SLOT #
	RBT	XN,XUSIUA		:RESET SLOT IN USE BIT
	RBT	XN,XQUEM,,		:CLEAR HIM FROM
	RBT	XN,XQUEC,,		:XRAY QUEUES
	JAL	R11,XPRTKT,,		:RESTORE SEG1 WRITE PROTECT
	JR	R12

::*********************************************************************
::
::	SUBROUTINE:	GCXRAY:
::	FUNCTION:	GET NEXT CHARACTER FROM REMOTE XRAY CIRCUIT.
::		STRIP ESCAPES, AND TOSS NETWORK CONTROL CHARACTERS.
::		BRANCH TO REMXR2 IF BUFFER EMPTY.
::	CALLING SEQ:	JAL	R9,GCXRAY
::	OUTPUT:		R1 = CHARACTER
::			R5 = DECREMENTED AS NEEDED
::
::*********************************************************************

GCXRAY	HS	0
	LHL	R8,BCT,R2,		:EXTRA CARE, NO GCI CRASH
	JE	REMXR2			:BUFFER EMPTY...
	JAL	R8,GCI,,		:GET NEXT CHARACTER FROM BUFFER
	CLHI	R1,8			:NORMAL CHARACTER?
	JGER	R9			:YES - RETURN
	LR	R1,R1			:ESCAPED CHARACTER?
	JEFS	GCXR00			:YES - GET NEXT
	SIS	R1,1			:NETWORK CHARACTER PAIR?
	JEFS	GCXR10			:YES - ADJUST COUNT IN R5 AND TOSS
	SIS	R5,1			:NO - SOME BALL. IGNORE IT TOO...
	JN	GCXRAY			:MORE TO DO
	J	REMXR2			:NO MORE - UPDATE POINTER
GCXR00	SIS	R5,1			:DEC COUNT SINCE '00' CHAR. TOSSED
	JE	REMXR2			:SHOULDN'T HAPPEN, DON'T TAKE GCI CRASH
	JAL	R8,GCI,,		:GET ESCAPED CHARACTER AND
	JR	R9			:RETURN
GCXR10	LH	R8,BCT,R2,
	JE	REMXR2			:NEXT CHAR. NOT PRESENT...
	JAL	R8,GCI,,		:TOSS IT
	SIS	R5,2			:ADJUST COUNT FOR CHARACTER PAIR
	JG	GCXRAY			:MORE TO DO
	J	REMXR2			:DONE

::*********************************************************************
::
::	SUBROUTINE:	DWLVAL
::	FUNCTION:	DETERMINE IF DLOAD LINE NUMBER IS VALID,
::		UNATTACHED, AND NOT IN DLOAD MODE.  BRANCH TO INTZPH IF NOT.
::	CALLING SEQ:	JAL	R7,DWLVAL
::
::*********************************************************************

DWLVAL	ST	R7,INTSAV+0A		:save return			###wjl
	LR	R6,R4
	AR	R6,R4
	CLHI	R1,NLINES		:IS IT A VALID PORT NUMBER?
	JLFS	DWLOU9			:YES IT IS
SDWKER	XHI	R1,0FEFF		:INSERT FAULT INDICATOR AND COMPLEMENT
	STH	R1,DWLNUM,R6
	IF	INTACC		
	J	DWAZ19			:Accounting and zap
	ELSE
	J	INTZPH			:AND ZAP THE CHANNEL
	EI	:INTACC			:###ev
DWLOU9	LR	LN,R1			:NEED 2*LINE #
	AR	LN,LN
DWLC09	L	R0,KDLN,LN,LN		:LINE BETTER BE UNATTACHED
	JLFS	DWLOU8			:IT IS
SDLUP	XHI	R1,0FDFF		:INSERT FAULT INDICATOR AND COMPLEMENT
	STH	R1,DWLNUM,R6
	IF	INTACC		
	J	DWAZ19			:Accounting and zap
	ELSE
	J	INTZPH			:AND ZAP THE CHANNEL
	EI	:INTACC			:###EV

::	Downline load proceeds here for load over downed line
DWLOU8	SBT	LN,DWLDSP		:TEST AND SET THE DWL DISPATCH ARRAY
      IF	SCLP
	JNFS	SDNAVL			:it is not available		###wjl
	LHL	R0,SKYCHN,LN		:see if a skyload has begun	###wjl
      EI	:SCLP
	JEFS	DWLOU7			:IT IS AVAILABLE
SDNAVL	XHI	R1,0FCFF		:INSERT FAULT INDICATOR AND COMPLEMENT
	STH	R1,DWLNUM,R6		:AND STORE BACK
	IF	INTACC		
	J	DWAZ19			:Accounting and zap
	ELSE
	J	INTZPH			:AND ZAP THE CHANNEL
	EI	:INTACC			:###EV

DWLOU7	XHI	R2,4
	JAL	R9,WCIE,,		:ECHO LINE NUMBER BACK TO HOST
	XHI	R2,4
DWST07	LCS	R0,2			:MARK IT IN DOWNLINE MODE
	ST	R0,KDLN,LN,LN
	STH	LN,DWLNUM,R6
	LHI	R0,INTZFL,R4		:TELL XRAY ABOUT NEW DWL CHANNEL
	STH	R1,CRYSBF		:STORE LINE NUMBER FOR CRYPTO
	JAL	R8,CRYPTO,,		:LINE # IN TOP, CHANNEL # IN BOTTOM
	HC	CRYE2C
	L	R7,INTSAV+0A		:get return			###wjl
	JR	R7			:return				###wjl

	SUBTTL	INTHST (DWLIN - Handle Down-Line Load record from neighbor)

::*********************************************************************
::
::	PROCESS:	DWLIN:
::	FUNCTION:	DOWNLINE LOAD RECEIVER
::	SCHEDULED:	Upon demand by SYLVER (SIO and SYNC input processing),
::		to process downline load records echoed to the node from it's
::		loading neighbor on unattached lines.  DWLIN processes one
::		downline load record for each line requiring it, and yields
::		between each one, until no more downline load records are 
::		received by SYLVER, when DWLIN dismisses to the EXEC loop.
::
::*********************************************************************

:	DOWNLINE RECORD TEAR DOWN. RECEIVES A 33-HW RECORD FROM
:	NEIGHBOR BEING LOADED AND SENDS IT ON TO THE HOST PROGRAM.
:	UPON COMPLETION, DWLIN DISMISSES ITSELF FROM THE EXEC JOB QUEUE BY
:	CLEARING ITS BIT IN SQUEUE.  HOWEVER IT DOES SO ONLY PROVIDED THAT
:	LINKER HASN'T CREATED MORE WORK IN THE MEANTIME.  IT CHECKS FOR THIS BY
:	EXAMINING DWQUEU UNDER THE PROTECTION OF THE SEMAPHORE DWTEST.  THIS
:	CONDITION CAN ONLY ARISE UNDER ISIS, WHERE LINKER IS RUN INDEPENDENTLY
:	AND MAY INTERRUPT DWLIN.

DWLIN	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(DWLIN )			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU
	LHL	R5,DWQUEU		:GET DWL JOB QUEUE
	LCS	R4,1
DWLIN5	LR	R5,R5			:R5 EMPTY?
	JN	DWLIN3			:NO, CONTINUE
	TS	DWTEST			:TEST AND SET SEMAPHORE
	LHL	R5,DWQUEU		:EXAMINE DWL JOB QUEUE
	JNFS	DWLIN6			:LINKER HAS RUN. DONT RESET SQUEQE
	LHI	R0,01F-PDWLIN		:LINKER HASNT BEEN RUN....
	RBT	R0,SQUEUE		:...SO RESET SQUEUE.
DWLIN6	LIS	R0,1
	STH	R0,DWTEST		:CLEAR THE SEMAPHORE...
	LA	R0,DWLIN
	J	EXYLD,,			:AND RETURN TO EXEC

DWLIN3	AIS	R4,1			:INCREMENT R4 AND
	SLHLS	R5,1			:TEST NEXT LINE
	JCFS	DWLIN4			:FOUND ONE. PROCESS IT
	J	DWLIN5			:HAVENT FOUND ONE.  KEEP LOOKING

:	THROUGHOUT THE CODE R5 = DWL JOB QUEUE
:	AND R4 = INTERNAL HOST CHANNEL INDEX

DWLIN4	RBT	R4,DWQUEU
	LHL	R2,INTTAB,R4,R4		:BUFFER #
	JE	DWLIN5
	NHI	R2,-4
	LHI	R1,32			:SEND THE SYNCS
	JAL	R8,WCI,,
	JAL	R8,WCI,,
	LIS	R6,1
	AHM	R6,DWLCIN,,
	LR	R6,R4
	LIS	PRD,0			:TEAR DOWN RECORD
	SLLS	R6,6			:OBTAIN APPROPRIATE OFFSET (64 X R4)
DWLIN1	LB	R1,DWIBUF,PRD,R6	:...AND INDEX INTO DWIBUF
	CLHI	R1,8			:ESCAPE IF NEEDED
	JGEFS	DWLIN2
	EXBR	R1,R1
	JAL	R8,WCI,,
	EXBR	R1,R1
DWLIN2	JAL	R8,WCI,,
	AIS	PRD,1
	CLHI	PRD,40
	JL	DWLIN1
	IF	INTACC			
	LR	R0,PRD			:Get byte count into R0 for accumulator
	LR	R3,R4			:Get internal port index in work reg
	JAL	R8,AARDOC		:Accumulate byte count for accounting
	GL	AARDOC
	EI	:INTACC			:###EV
	LIS	R0,0			:CLEAR BUSY FLAG
	STH	R0,DWBUSY,R4,R4
	J	DWLIN5			:CONTINUE...

	SUBTTL	INTHST (DLYSRC - Delay measurement source)

::*********************************************************************
::
::	PROCESS:	DLYSRC:
::	FUNCTION:	SOURCE OF THE TEST DATA USED IN ROUND-TRIP
::		DELAY MEASUREMENTS.  FILLS ALL REQUESTING CHANNELS WITH
::		THE SPECIFIED NUMBER OF FILL HALF-WORDS.
::	SCHEDULED:	IN INTDLY WHENEVER A DELAY MEASUREMENT IS DETECTED,
::		AND SUBSEQUENTLY RUNS PERIODICALLY OFF THE TIME-OUT LIST.
::
::*********************************************************************

FILLCH	EQ	04141			:this is our fill character

DLYSRC	HS	0
        lis     r0,1
        ahm     r0,dlyrat               :so delay circuits can have diff rates
	LHL	R4,INTDSF		:MAKE SURE THERE IS AT LEAST 1 CHANNEL
	JNFS	DLYSR9			:YES
	LHI	R0,01F-PDLYSR		:NO, SO UN-SCHEDULE DLYSRC
	LHI	R1,3C
DLYSR8	RBT	R0,SCHTAB,R1		:BY CLEARING ALL THE TIMEOUT-LIST BITS
	SIS	R1,4
	JL	EXDISM,,		:CLEARED ALL BITS
	JBS	DLYSR8			:SOME LEFT, LOOP BACK

DLYSR9	LHL	R1,FASTC+2,,		:GET CURRENT TIME
	THI	R1,0FC00
	JE	EXDISM,,		:FASTC REQUIRES ESCAPES...TRY LATER
	THI	R1,0FC
	JE	EXDISM,,		:IT WILL REQUIRE ESCAPES HERE, TOO...

	LR	R10,R1			:SAVE FASTC
DLYSR5	JFFOH	R4,DLYSR3		:GET NEXT CHANNEL
	J	EXDISM,,		:NONE LEFT,RETURN
DLYSR3	XH	R4,HMSK,R5,R5		:MARK AS DONE
        lh      r0,dlyrat
        nh      r0,dlyint,r5,r5         :really time for this port?
        jn      dlysr5                  :nope, next port
	LHL	R2,INTTAB,R5,R5		:GET OUTGOING BUFFER NUMBER
:	subject delay msmt circuits to backpressure from source		###jhl
	LR	R7,R2			:copy buffer index to R7
	NHI	R7,3			:read speed bits
	NHI	R2,-4			:strip speed bits
	LHL	R0,CIRSPK,R7,R7		:if BCT > TP class limit, do nothing
	CLH	R0,BCT,R2,		:compare the BCT for the channel
	JL	DLYSR5			:go to service next channel
:	OK to put more chars in buffer	
	LHL	R6,CFLCNT,R5,R5		:read channel count array
	JN	DLYS10			:if non-zero, take it from there
:	time to start a new barrage of CHNFIL worth of chars
	LHL	R6,CHNFIL,R5,R5		:reset CFLCNT to top value
	STH	R6,CFLCNT,R5,R5
	JAL	R9,WHWI,,		:send FASTC from R1 as a starter
DLYS10	SR	R6,R0			:HW 'to send' count - TP class limit
	JL	DLYS20			:branch if < TP left
:	here if > TP limit left to put in buffer for this message
	STH	R6,CFLCNT,R5,R5		:reset 'to send' count
	LR	R6,R0			:move TP no. of chars into the buffer
	J	DLYS30
:	here if < TP limit left -- end of this message
DLYS20	LHL	R6,CFLCNT,R5,R5		:get 'to send' count 
	LIS	R0,0			:zero out CFLCNT
	STH	R0,CFLCNT,R5,R5
DLYS30	HS	0
	LI	R1,FILLCH		:load fill character
DLYSR6	JAL	R9,WHWI,,		:WRITE IN NEXT FILL HW
	SIS	R6,1
	JGBS	DLYSR6			:LOOP BACK

	LHL	R6,CFLCNT,R5,R5		:this is 'end of msg' test	###jhl
	JN	DLYSR5			:send FASTC only at end of msg	###jhl

	LR	R1,R10			:RECOVER FASTC
	JAL	R9,WHWI,,		:AND PUT INTO END OF PACKET
	J	DLYSR5			:REPEAT

	SUBTTL	INTHST (INTTIM - Internal Host Time-Out logic)

::*********************************************************************
::
::	SUBROUTINE:	INTTIM:
::	FUNCTION:	Internal Host Time-Out logic
::	CALLING SEQ:	JAL	R11,INTTIM	CALLED BY THE 4-MINUTE PROCESS.
::		INTTIM ACTUALLY RUNS EVERY 8 MINUTES THROUGH THE USE OF THE
::		INT8MN CELL
::
::*********************************************************************

:	TIMEOUT IS ENABLED FOR AN INTERNAL HOST CRQ WHEN THE CORRESPONDING
:	BIT IN INTOUT IS SET. SUCH A CRQ KEEPS FROM BEING ZAPPED BY KEEPING
:	ITS BIT IN INTACT SET.
:
:	INTTIM EXAMINES THE INTACT ARRAY AND SETS A BIT IN THE INTWRN
:	ARRAY FOR EACH CRQ THAT HAS NOT BEEN ACTIVE. IF INTWRN HAS
:	ALREADY BEEN SET INTTIM ZAPS THE CRQ.

INTTIM	HS	0
	LCS	R0,1			
	AHM	R0,INT8MN		:DECREMENT CLOCK
	JGR	R11			:NOT TIME TO RUN INTTIM  YET

	ST	R11,INTTSV
	LIS	R1,3			:REINITIALIZE CLOCK
	AHM	R1,INT8MN
	LH	R3,INTACP,,		:EXAMINE ALL INT HOST CHANNELS	###jhl
:	recall that set bits in ACP are inactive channels.
	OH	R3,INTACT		:OR in the active channels
	XR	R3,R0			:EACH 1 => (PORT IN USE) AND (NO DATA)
	NH	R3,INTOUT		:MASK WITH TIMEOUT ENABLE ARRAY
	STH	R3,INTSAV
INTTI2	LHL	R3,INTSAV		:LOOP OVER ALL POSSIBILITIES
	JFFOH	R3,INTTI3
	J	INTTI1			:ALL DONE. RETURN
INTTI3	CLHI	R4,TINTCH		:IS IT WITHIN RANGE?
	JGE	INTTI1			:NO..  ALL DONE,RETURN
	RBT	R4,INTSAV		:FOUND A POSSIBILITY
	SBT	R4,INTWRN		:TEST AND SET ITS WARNING BIT
	JEBS	INTTI2			:WARNING HADN'T BEEN GIVEN.  CONTINUE
	LHL	R2,INTTAB,R4,R4 	:TIME TO ZAP... GET BUFFER NUMBER
	NHI	R2,-4
	XHI	R2,4			:FLIP FOR INTZAP (WANTS INCOMING #)
	JAL	R10,INTZAP		:ZAP AND DO CLOSING BOOK-KEEPING
	LHI	R0,INTZFL		:CRYPTO MESSAGE HAS ABS CHN #
	AR	R0,R4
	JAL	R8,CRYPTO,,
	HC	CRYE2B			:CRYPTO MESSAGE:INT HST TIMEOUT
	J	INTTI2			:CONTINUE...
INTTI1	LIS	R0,0
	STH	R0,INTACT		:CLEAR THE ACTIVE ARRAY
	L	R11,INTTSV
	JR	R11			:RETURN TO EXEC

	ENDMO.(INTHST)
	EI	:1-KILLIT
	KILMSG(INTHST)

:	***NOTHING PAST THIS POINT***

	SUBTTL	UTIL

:			*   * ***** ***** *
:			*   *   *     *   *
:			*   *   *     *   *
:			*   *   *     *   *
:			 ***    *   ***** *****

::#####################################################################
::
::	MODULE:		UTIL
::
::	SUBTTLS:
::		TRACER
::		Measurement routines
::		BUBBLE
::		SHRINK
::		FIND
::		ACCOUNTING
::
::#####################################################################

	IF	1-KILLIT
	BEGMO.
	RA 0
	SEG  1

::*********************************************************************
::
::	ROUTINE:	TRACER:
::	FUNCTION:	UPSW trace interrupt routine.  If the PSW trace bit is
::		set, the interrupt will send us here just before every jump
::		instruction is executed.  The PSD (with PC=jump destination)
::		has been stored at 10x mac'd (TRPSW) and the trace bit has
::		been turned off.  TRACER runs in set 0F mac'd.  We return 
::		by loading the mainline PSW from TRPSW.  Trace table (TRCTAB)
::		entries are the LO HW's of the jump destination addresses.
::		TRNDEX points to the next entry in the table.  When a node
::		crashes, the trace table is copied into SEGC at TRSTAB where
::		it can be examined at leisure with the XRAY 'TT' command.
::		(TRSTAB is created so that its last entry is the address of
::		of the last jump before the crash.  Trace is turned off when
::		the node crashes.)
::
::		TRACER may only be enabled when the Tymfile OPTION(UTRC) is
::		invoked.  This sets assembly switch (DB.TRC).  Under the
::		DB.TRC switch, the trace bit is set by writing a 1000 at
::		EXEPSW+2.  It is also enabled/disabled by the XRAY 'TR'
::		command, though this causes a special kind of tracing to take
::		place (see below).
::
::		We will do one of 3 things in TRACER, depending on the
::		value of TRCRRQ:
::			1) If it is >0, we will simply return without making
::				a trace table entry.  This allows us to disable
::				tracing while the PSW trace bit is set.
::			2) If it is =0, we will unconditionally make an entry
::				in the trace table.  This is the default state
::				when trace is enabled via DB.TRC or by setting
::				the trace bit in EXEPSW.  When we reach the end
::				of the table, we'll wrap back around to the
::				beginning again.
::			3) If it is <0 (-1), we will make table entries only
::				for jumps which are within, into, or out of a
::				specified address range (TRCBEG to TRCEND).  
::				See XRAY 'TR' command for use of this trace.
::
::*********************************************************************

	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl

:	Save some registers which will be clobbered by what follows.
:	TRCRRQ tells us what to do next:
:		If >0, exit via TREND.
:		If =0, do regular trace at TRACR0.
:		If <0, fall through to do special trace-in-range.
TRACER  HS	0
	STM	R13,TRSAVE,,		:SAVE SOME REGISTERS
	LH	R14,TRCRRQ,,		:SPECIAL TRACE REQUEST?
	JG	TREND			:FORCE NO TRACE IF > 0
	JE	TRACR0			:NO

:	Fall thru to here to trace jumps in a specified address range
:	(TRCRRQ set to -1 by 'TR' command).  If the jump destination is
:	in the range (TRCBEG to TRCEND), then make an entry in the trace table.
:	If the jump destination is out of the range and the previous entry
:	was in range, make an entry to show how we left the range.
:	If the jump destination	is in range and the previous entry was
:	out of range, preserve the previous entry to show how we got into
:	the range.

	LHL	R14,TRNDEX,,		:INDEX INTO TRACE TABLE
	L	R15,TRPSW+4		:GET JUMP DESTINATION ADDRESS
	C	R15,TRCBEG,,		:IN RANGE?
	JL	TRACR1			:NO, TOO LOW

	C	R15,TRCEND,,		:UPPER LIMIT
	JGE	TRACR1			:NO, TOO HIGH

	LH	R13,TRCRFL,,		:WAS PREVIOUS ENTRY IN RANGE?
	JLFS	TRACR4			:YES

	AIS	R14,2
	NHI	R14,TRTBSZ-1		:MASK FOR WRAP

TRACR4	HS	0
	STH	R15,TRCTAB,R14,,	:MAKE ENTRY
	TS	TRCRFL,,		:INDICATE THAT LAST ENTRY WAS IN RANGE
	AIS	R14,2			:BUMP INDEX
	NHI	R14,TRTBSZ-1		:MASK FOR WRAP
	STH	R14,TRNDEX,,		:NEW INDEX
TRACR2	LM	R13,TRSAVE,,		:RESTORE REGISTERS
	UPSW	TRPSW			:CONTINUE

TRACR1	HS	0			:JUMP ADDRESS OUT OF RANGE
	STH	R15,TRCTAB,R14,,	:MAKE TABLE ENTRY
	LH	R13,TRCRFL,,		:WAS PREVIOUS ENTRY IN RANGE?
	JGEFS	TRACR3			:NO

	AIS	R14,2			:BUMP INDEX
	NHI	R14,TRTBSZ-1		:MASK FOR WRAP
	STH	R14,TRNDEX,,		:SAVE NEW INDEX
	STH	R14,TRCRFL,,		:INDICATE LAST ENTRY OUT OF RANGE
TRACR3	HS	0
	LM	R13,TRSAVE,,		:RESTORE REGISTERS
	UPSW	TRPSW			:CONTINUE

TRACR0	HS	0			:Here for regular trace.
	LHL	R15,TRPSW+6		:GET BRANCH ADDRESS
	LH	R14,TRNDEX,,		:GET INDEX INTO TRACE TABLE
	AIS	R14,2			:INC TO NEXT ENTRY
	NHI	R14,TRTBSZ-1
	STH	R15,TRCTAB,R14,,	:STORE IN TABLE
	STH	R14,TRNDEX,,		:SAVE INDEX FOR NEXT TIME
        lh      r14,8
        ahi     r14,10
        jn      trend
        lis     r14,1
        sth     r14,trcrrq,,            :stop tracing
        stm     r0,dorsav,,
	J	TREND
	WS	8			:PLACE TO PATCH IN SPECIFIC TESTS

:	Here to restore registers and UPSW back to mainline.
TREND	HS	0
	LM	R13,TRSAVE,,		:RESTORE REGISTERS
	UPSW	TRPSW

	EI	:DB.TRC

	SUBTTL 	UTIL (Measurement routines)

::*********************************************************************
::
::	SUBROUTINE:	MTRFIC:
::	FUNCTION:	MEASURES CHARACTER TRAFFIC ON THE NETWORK LINKS.
::	CALLING SEQ:	JAL	R10,MTRFIC	(called from 1sec logic)
::
::*********************************************************************

:	EACH LINK MAINTAINS COUNTS FOR LOGICAL CPS IN AND OUT, PHYSICAL
:	CPS IN AND OUT, RMAKE CALLS IN WHICH NO PACKETS WERE MADE, AND
:	PACKETS MADE. THE RUNNING COUNTS ARE STORED IN
:	THE "LAST MINUTE'S"  LINK DESCRIPTOR FIELD AND COMPARED TO THE
:	"HI-WATER MARK" FIELD. THE SUM  OF ALL LINKS' COUNTS FOR LOGICAL
:	CHARACTERS IS SAVED, AND COMPARED TO HI-WATER MARKS FOR THE NODE.
:
:	IN ADDITION RMAKE STORES THE TIME EACH PACKET IS MADE IN THE AREA
:	PKTTIM, INDEXED BY RECORD NUMBER. THE SYNC INTERRUPT ROUTINE USES THIS
:	VALUE TO COMPUTE HOW LONG THE PACKET WAS QUEUED. A RUNNING COUNT OF
:	PACKET QUEUEING TIMES IS MAINTAINED IN KS.PQC

MTRFIC	HS	0
	LH	R7,SLOWC+2,,		:CURRENT TIME
	LH	R6,MTLTIM		:LAST TIME WE WERE HERE
	STH	R7,MTLTIM
	SR	R7,R6
	CHVR	R7,R7
	STH	R7,MTTINT		:EXACT TIME INTERVAL BETWEEN SAMPLES.
	LHL	R8,FASTC+2,,
	LHL	R6,MTLFST		:LAST FASTC TIME
	STH	R8,MTLFST
	SR	R8,R6
	JGEFS	MTRFI1			:CAN'T USE CHVR HERE
	AI	R8,10000		:BECAUSE R8 MAY HAVE 8000 BIT SET
MTRFI1	HS	0
	ST	R10,MTRSAV		:save return to free up register###wjl
	LIS	R10,0			:sum of all links phys counts output
	LIS	R5,0			:sum of all links phys counts input
	LIS	R0,0
        st      r0,rmklrs               :clear counr of logical records made
	LIS	LRC,0			:SUM OF ALL LINKS LOGICAL COUNTS OUTPUT
	LIS	R12,0			:SUM OF ALL LINKS LOGICAL COUNTS INPUT

	LHI	KN,NLINKS-1		:DO FOR ALL LINKS
MTRFI2	SLLS	KN,1
	L	KD,KDKN,KN,KN		:GET LINK DESCRIPTOR INDEX
	SRLS	KN,1
	LB	R1,NLAT,KD		:ANY LINES UP ON THIS LINK?
	JE	MTRFI5			:NO, GO DIRECTLY TO THE NEXT LINK
	A	LRC,KS.LCO,KD		:INCREMENT CUMULATIVE COUNTERS
	A	R12,KS.LCI,KD
	A	R10,KS.PCO,KD		:###wjl
	A	R5,KS.PCI,KD		:###wjl
	LIS	R1,5			:UPDATE 5 GROUPS OF COUNTERS,
	LA	R2,KS.PCO,KD		:BEGINNING WITH PCO

MTRFI3	L	R3,0,R2			:GET RUNNING COUNT AND
	ST	R3,4,R2			:STORE IN 'LAST MINUTE' FIELD
	ST	R0,0,R2			:CLEAR RUNNING COUNT
	C	R3,8,R2			:NEW HI-WATER MARK?
	JLEFS	MTRFI4			:NO
	ST	R3,8,R2			:YES - SAVE IT
MTRFI4	AIS	R2,0C			:ADVANCE TO NEXT GROUP
	SIS	R1,1			:IF MORE TO DO
	JGBS	MTRFI3

	LR	R1,R8			:MOVE TIME INTERVAL OVER
	DH	R1,KS.RRC,KD		:DIVIDE BY RMAKE R-ROBIN COUNT
	STH	R0,KS.RRC,KD		:CLEAR OUT ROUND ROBIN COUNT
	SRLS	R2,1			:DIVIDE BY 2
	STH	R2,KS.RRT,KD		:AND STORE BACK AVERAGE R-ROBIN DELAY

	LH	R2,LRMSAV,KD		:GET LRM SAVE VALUE
	LH	R3,LRM,KD		:AND LAST REC MADE ON LINK
	STH	R3,LRMSAV,KD		:UPDATE LRMSAV
	SR	R3,R2			:SUBTRACT TO GET NUMBER OF RECORDS MADE
	JGEFS	MTRFI7
	AI	R3,10000
MTRFI7	STH	R3,KS.PKM,KD		:SAVE NUMBER OF PACKETS MADE
	L	R1,KS.PQC,KD		:GET CUMMULATIVE QUEUEING DELAYS
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRI88			:SET ZERO ##AL
	STH	R3,KS.AQU,KD		:STORE 0 DELAY (IN FASTC TICKS)
	JFS	MTRFI9
MTRI88	DHR	R1,R3			:DIVIDE BY NUMBER OF PACKETS MADE
	STH	R2,KS.AQU,KD		:STORE AVERAGE DELAY (IN FASTC TICKS)
MTRFI9	ST	R0,KS.PQC,KD		:CLEAR OUT QUEUEING DELAY ACCUMULATOR

	IF	BFLTMR			:for buffer delay timing pairs	###JHL
	LHL	R1,BDLCNT,KD		:read running occurrence counter
	STH	R0,BDLCNT,KD		:start fresh for new minute
	STH	R1,KS.BFC,KD		:save minute count for display
	LHL	R1,BDLACC,KD		:read running delay accumulator
	STH	R0,BDLACC,KD		:start fresh for new minute
	STH	R1,KS.BFD,KD		:save minute count for display
	EI	:BFLTMR			:				###JHL

:	COLLECT LOGICAL RECORDS FOR RECDS/PKT STAT.			###JHL
	LHL	R1,KS.LRM,KD		:GET COUNT OF LOGICAL RECORDS MADE
        am      r1,rmklrs               :count of logical records
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRFIA			:SET ZERO ##AL
	STH	R3,KS.LRA,KD		:PUT 0 IF NO LRM
	JFS	MTRFIB
MTRFIA  LR      R2,R3                   :round instead of truncate
        SRLS    R2,1
        AR      R1,R2                   :add in half the divisor        ###sdw
	DHR	R1,R3			:DIVIDE BY NUMBER OF PACKETS MADE
	STH	R2,KS.LRA,KD		:QUOTIENT IS AVG RECS/PKT
MTRFIB	STH	R0,KS.LRM,KD		:CLEAR COUNT -- START NEXT MINUTE ANEW
					:				###JHL

	L	R1,KS.PMO,KD		:GET TOTAL NUMBER OF BYTES
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRICC			:SET ZERO ##AL
	STH	R3,KS.ASZ,KD		:RESULT= 0 PACKET SIZE
	JFS	MTRFID
MTRICC	DHR	R1,R3			:DIVIDE BY NUMBER OF PACKETS
	STH	R2,KS.ASZ,KD		:RESULT=AVERAGE PACKET SIZE
MTRFID	LB	R1,KSPD,KD		:FIGURE OUT LINE SPEED IN CPS
	NHI	R1,01F
	SLLS	R1,2
	LHL	R6,KSPCPF,R1,		:LOOK UP THE CPS RATE IN FASTC	###wjl
	GL	KSPCPF
	LB	R4,NLAT,KD		:GET NUMBER OF LINES ON LINK
	MHR	R2,R4			:FORM <AVE SIZE>*<NLINES>
	LHR	R6,R6			:DIVIDER CAN'T BE 0
	JNFS	MTRFIE			:SET ZERO ##AL
	STH	R6,KS.XMT,KD		:0 XMIT TIME...
	JFS	MTRFIF
MTRFIE	DHR	R2,R6			:DIVIDE BY LINK CPS RATE TO GET MEAN
	STH	R3,KS.XMT,KD		: XMIT TIME... THIS RESULT IS IN FASTC
MTRFIF	LHL	R1,KS.BAK,KD		:GET BACKLOG COUNT FOR LINK
	STH	R1,KS.BAM,KD		:AND MOVE TO SAVE AREA
	STH	R0,KS.BAK,KD		:CLEAR BACKLOG COUNT

	LH	R2,LRTSAV,KD		:GET OLD LRT VALUE
	LH	R3,LRT,KD		:AND CURRENT VALUE
	STH	R3,LRTSAV,KD		:UPDATE LRTSAV
	SR	R3,R2
	JGEFS	MTRFI8
	AI	R3,10000
MTRFI8	L	R1,KS.SRC,KD		:GET CUMMULATIVE SYLVER-RTD DELAYS
	ST	R0,KS.SRC,KD		:AND CLEAR THE ACCUMULATOR
	LR	R3,R3			:DIVIDER CAN'T BE 0
	JNFS	MTRI8N			:SET ZERO ##AL
	STH	R3,KS.SRA,KD		:STORE 0 DELAY (IN FASTC TICKS)
	JFS	MTRFI5
MTRI8N	DHR	R1,R3			:GET AVERAGE SYLVER-RTD DELAY IN FASTC
	STH	R2,KS.SRA,KD		:AND SAVE IT

MTRFI5	SIS	KN,1			:DO FOR ALL LINKS
	JGE	MTRFI2

:	COLLECT MARK, REXMT, AND XMT STATS FOR LINES ON THIS LINK
:	--SHOWN IN KS COMMAND						###JHL
	LHI	R1,(NLINES-1)*2		:				###wjl
NXTLI3	L	R2,KDLN,R1,R1		:SEE IF THIS LINE IS ATTACHED	###wjl
	JL	NXTLI1			:NEG VALUE SAYS NO
	LHL	R2,LXMSET,R1		:READ CURRENT RUNNING COUNT(MARKING)
	LHL	R3,KL.LRF,R1		:READ  PREVIOUS MIN'S START COUNT##wjl
	STH	R2,KL.LRF,R1		:SAVE NEW START MINUTE COUNT	###wjl
	SR	R2,R3			:RUNNING - SAVE	 = NEW TOTAL
	JGEFS	NXTLI4			:HAVE WE WRAPPED??
	AI	R2,10000		:IF SO ADD ON MODULO HW
NXTLI4	STH	R2,KL.LSV,R1		:SAVE NEW MINUTE'S TOTAL	###wjl
	LHL	R2,TRRXMT,R1		:READ CURRENT RUNNING COUNT(REXMIT)
	LHL	R3,KL.TRF,R1		:READ  PREVIOUS MIN'S START COUNT##wjl
	STH	R2,KL.TRF,R1		:SAVE NEW START MINUTE COUNT	###wjl
	SR	R2,R3			:RUNNING - SAVE	
	JGEFS	NXTLI5			:HAVE WE WRAPPED??
	AI	R2,10000		:IF SO ADD ON MODULO HW
NXTLI5	STH	R2,KL.TSV,R1		:SAVE NEW MINUTE'S TOTAL	###wjl
	LHL	R2,RCTRNS,R1		:READ CURRENT RUNNING COUNT(TRANSMIT)
	LHL	R3,KL.RRF,R1		:READ  PREVIOUS MIN'S START COUNT##wjl
	STH	R2,KL.RRF,R1		:SAVE NEW START MINUTE COUNT	###wjl
	SR	R2,R3			:RUNNING - SAVE	 = NEW TOTAL
	JGEFS	NXTLI6			:HAVE WE WRAPPED??
	AI	R2,10000		:IF SO ADD ON MODULO HW
NXTLI6	STH	R2,KL.RSV,R1,		:SAVE NEW MINUTE'S TOTAL	###wjl
NXTLI1	SIS	R1,2			:STEP BACK TO NEXT LOWEST LINE
	JGE	NXTLI3			:LOOP UNTIL ALL LINES DONE
					:				###JHL

	DH	R8,SYLXEC		:DIVIDE TIME INTERVAL BY # SYLVER RUNS
	SRLS	R9,1			:DIVIDE AVERAGE INTERVAL BY 2
	STH	R9,SYLXAV		:AND STORE INTO AVERAGE DELAY CELL
	STH	R0,SYLXEC		:CLEAR COUNT OF SYLVER RUNS

:	SAVE COUNTS FOR ALL LINKS AND TEST FOR NEW HI-WATER MARK
	ST	LRC,TOTCHR		:SAVE TOTAL CHARS OUT
	AM	R12,TOTCHR		:PLUS TOTAL CHARS IN
	DHR	LRC,R7			:CONVERT EACH TO SECONDS
	STH	R15,NSCPSO		:AND SAVE
	DHR	R12,R7
	STH	R13,NSCPSI		:INPUT COUNT
	LHL	R9,NSCPHO		:NEW HI-WATER MARK?
        cr      r15,r9
	JLEFS	MTRFI6			:NO
	STH	R15,NSCPHO		:YES - SAVE
MTRFI6	LHL	R9,NSCPHI		:TEST FOR HWM FOR INPUT CHRAS
        cr      r13,r9
	JLEFS	MTRF10			:NO
	STH	R13,NSCPHI

:	NODE LINKS' TOTAL PHYSICAL CPS RATES
MTRF10	HS	0
	DHR	R10,R7			:convert physical chars out	###wjl
	STH	R11,NS.PCO+2		:store HW value in FW location	###wjl
	DHR	R5,R7			:convert physical chars in	###wjl
	STH	R6,NS.PCI+2		:store HW value in FW location	###wjl
	LHL	R9,NS.PHO		:new hi-water mark for PCO?	###wjl
        cr      r11,r9
	JLEFS	MTR020			:no				###wjl
	STH	R11,NS.PHO		:yes, save			###wjl
MTR020	LHL	R9,NS.PHI		:new hi-water mark for PCI?	###wjl
        cr      r6,r9
	JLEFS	MTR022			:no				###wjl
	STH	R6,NS.PHI		:yes, save			###wjl
MTR022  LIS     R3,0                    :for clearing running counts
        L       R1,DISICC               :current value
        ST      R3,DISICC               :and clear it
        ST      R1,DISICM               :is current min value
        CL      R1,DISICH
        JLFS    MTR040
        ST      R1,DISICH
        JAL     R9,GMTCAL,,             :get time it happened
        L       R0,GMTNOW
        ST      R0,DISICT
:       same statistics but for output side
MTR040  L       R1,DISOCC               :current value
        LIS     R3,0
        ST      R3,DISOCC               :and clear it
        ST      R1,DISOCM               :is current min value
        CL      R1,DISOCH
        JLFS    MTR043
        ST      R1,DISOCH
        JAL     R9,GMTCAL,,             :get time it happened
        L       R0,GMTNOW
        ST      R0,DISOCT
MTR043
	L	R10,MTRSAV		:load return			###wjl

	JR	R10			:RETURN TO CALLER

::*********************************************************************
::
::	SUBROUTINE:	MAKNDL:
::	FUNCTION:	MAKES A NEEDLE IN ACCORDANCE WITH THE DATA
::			SUPPLIED IN NODLS AND DLYFLG, AND NOTIFYS CRQ
::	CALLING SEQ:	JAL	R10,MAKNDL
::	INPUT:		CHN = ABSOLUTE CHANNEL NUMBER TO BE USED
::			R6  = OFFSET INTO DLYBSE, THE DATA AREA
::
::*********************************************************************

MAKNDL	HS	0
	JAL	R8,GFCBUF,,		:GET A FREE BUFFER PAIR
	SKIPAD(MAKOOB)			:immed. return - out of buffers!###wjl
	LHI	R1,NEEDP		:+4, ok -WRITE NEEDLE POINT INTO BUFFER
	EXBR	R1,R1
	JAL	R8,WCI,,
	EXBR	R1,R1
	JAL	R8,WCI,,
	LIS	R1,0
	JAL	R8,WCI,,		:ESCAPE THE BYTE COUNT
	JAL	R8,WCI,,		:LEAVE SLOT FOR BYTE COUNT
	L	PRD,BE,R2,		:SAVE POINTER TO BYTE COUNT SLOT
	JAL	R8,WCI,,		:ESCAPE THE LINK COUNT
	LHL	R1,NODCNT,R6		:NODCNT = 2X # OF 1-WAY NODES 
	OHI	R1,80
	JAL	R8,WCI,,		:WHICH = TOTAL ROUND TRIP LINK COUNT
	LHI	R1,0FFFF		:DUMMY INVOICE NUMBER
	JAL	R9,WHWI,,
	JAL	R9,WHWI,,
	LHL	R1,DLYFLG,R6		:FLAGS
	JAL	R9,WHWI,,
	LHI	R1,MACHNM		:REQUESTING NODE NUMBER
	JAL	R9,WHWI,,
	LR	R1,CHN			:ABSOLUTE PORT NUMBER
	JAL	R9,WHWI,,
	LHL	R7,NODCNT,R6		:NUMBER OF NODES IN 1-WAY PATH
	JE	MAKND4			:ZERO, SOMEONE WNTS AN INTERNAL PATH
	LIS 	R4,0			:NONZERO, COPY NODE LIST INTO NEEDLE
MAKND1	LHL	R1,NODLST,R6,R4		:GET THE NEXT NODE OFF THE LIST
	JAL	R9,WHWI,,		:AND WRITE INTO NEEDLE
	AIS	R4,2
	CR	R7,R4			:AT END OF LIST?
	JGBS	MAKND1			:NO,LOOP BACK
	SIS	R4,4			:YES,BACK UP TO NEXT-TO-LAST NODE
	JLFS	MAKND3 			:SPECIAL CASE:ONLY 1 NODE IN LIST
MAKND2	LHL	R1,NODLST,R6,R4		:WORK BACKWARDS FOR RETURN PATH
	JAL	R9,WHWI,,
	SIS	R4,2
	JGEBS	MAKND2			:MORE NODES LEFT, LOOP BACK
MAKND3	LHI	R1,MACHNM		:WE ARE THE DESTINAION NODE
	JAL	R9,WHWI,,
MAKND4	LHI	R1,HST0+8000		:AND THE DESTINATION HOST
	JAL	R9,WHWI,,
	LHI	R1,7FFF			:DEPOSIT DUMMY ID'S
	JAL	R9,WHWI,,
	JAL	R9,WHWI,,
	LHI	R1,444C
	JAL	R9,WHWI,,		:DEPOSIT DLOAD USER NAME
	LHI	R1,4F41
	JAL	R9,WHWI,,
	LHI	R1,440D
	JAL	R9,WHWI,,
	JAL	R8,CBCCT,,		:GET THE BYTE COUNT FOR THE NEEDLE
	STB	R1,0,PRD		:AND DEPOSIT INTO ITS SLOT
	JAL	R9,CRQHCR		:BUILD HALF CRQ
	JAL	R9,CRQALT		:ALERT CRQ
	LR	R3,R2
	SRLS	R3,3
	SBT	R3,CRQEND

        LR      R1,R2
        SRLS    R1,1                    :SET UP BUFTIM INDEX
        L       R0,FASTC,,
        ST      R0,BUFTIM,R1,           :TIME THAT NEEDLE ORIGINATES IN NODE

	JR	R10			:RETURN TO CALLER

MAKOOB	J	OP8463,,		:out of buffers! - crash	###wjl
::*********************************************************************
::
::	SUBROUTINE:	CKOVLD:
::	FUNCTION:	CHECKS ALL ACTIVE LINKS TO SEE WHICH ONES HAVE
::			BEEN OVERLOADED DURING THE PREVIOUS 1/2 SECOND.
::			INCS A COUNTER FOR THOSE WHICH HAVE.
::	CALLING SEQ:	JAL	R10,CKOVLD  CALLED FROM 1/2 SEC LOGIC.
::
::*********************************************************************

CKOVLD	HS	0
        LHI     R2,LKSIZE-4
CKOV2	L	R3,ALINKS,R2		:COPY ALINKS INTO CKOSAV
	ST	R3,CKOSAV,R2
	SIS	R2,4
	JGEBS	CKOV2
	LIS	R3,1			:FOR INCREMENT COUNTERS
	LIS	R0,0			:FOR REFRESHING IDLE ARRAY
	LHI	R5,LKSIZE-4		:R5 = INDEX INTO ARRAY
CKOVA	L	R1,CKOSAV,R5
	JFFO	R1,CKOVC		:ACT ON ACTIVE LINKS
	SIS	R5,4			:NO BITS SET
	JGEBS	CKOVA
	JR	R10			:NO MORE ACTIVE LINKS
CKOVC	RBT	R2,CKOSAV,R5		:FIRST BIT FOUND
        LR      R4,R5                   :preserve R5 for next link      ###sdw
	SLLS	R4,3			:FORM LINK NO.
	AR	R2,R4
	SLLS	R2,1
	L	R4,KDKN,R2,R2		:GET LINK DESCRIPTOR INDEX
	SRLS	R2,1
	SBT	R2,LKRR			:RESET IF ROUND-ROBIN SERVICED FOR 
					: ALL CHANNELS ON LINK
	JEFS	CKOVB			:ALL CHANNELS SERVICED
	AHM	R3,LKOVLD,R2,R2		:BUMP COUNT FOR LINK OVERLOADED
CKOVB	LH	R1,IDLE,R4		:NEGATIVE IF LINK EVER WENT IDLE
					: DURING PAST 1/2 SECOND
	STH	R0,IDLE,R4		:REFRESH CELL, STH DOESN'T ALTER PSW CC
	JL	CKOVA			:LINK NOT SATURATED
	AHM	R3,LKSTCT,R2,R2		:INCREMENT COUNT OF LINK SATURATED
	J	CKOVA

	SUBTTL	UTIL (BUBBLE)

::*********************************************************************
::
::	SUBROUTINE:	BUBBLE:
::	FUNCTION:	THIS ROUTINE IS CALLED WHEN:
::		A)  A NEW LINK IS COMING UP,
::		B)  ADDITIONAL CHANNELS FROM T-II TO T-II ON A LINK ARE NEEDED.
::		    TYMNET-1.5 AND TYMNET-I DO NOT BUBBLE.
::	CALLING SEQ:	JAL	R8,BUBBLE
::	RETURNS:	IMMEDIATE - NO SPACE IS AVAILABLE
::			+4 - BUBBLED
::
::*********************************************************************

:	WHEN THE NEED FOR MORE CHANNELS IS REALIZED, THE FOLLOWING
:	CODE STARTS OUT AT THE LINK NUMBER REQUESTING THE ADDITIONAL
:	CHANNELS AND SCANS TO THE RIGHT (HIGHER MEM ADDR'S) LOOKING
:	FOR AN AREA OF EMPTY PERMUTER TABLE SPACE.  IF IT FINDS SPACE
:	AVAILABLE IT MOVES ANY INTERMEDIATE LINKS INTO THAT SPACE, 
:	LEAVING THE FREE SPACE IMMEDIATELY BEHIND THE EXISTING LINK'S
:	PERMUTER TABLES.  THE LINK'S POINTERS ARE THEN ADJUSTED TO
:	REFLECT THE INCREASED CAPACITY.
:	IF NO SPACE IS FOUND AFTER THE LINK, THE PERMUTER TABLES
:	ARE SEARCHED FROM THE BEGINNING, AGAIN LOOKING FOR FREE SPACE.
:	WHEN THAT FREE SPACE IS FOUND ALL LINKS FROM THAT SPACE TO THE
:	LINK REQUESTING SPACE (INCLUSIVE) ARE SHIFTED LEFT LEAVING 
:	ROOM AGAIN BEHIND THE LINK IN QUESTION.  IT'S POINTERS ARE 
:	AGAIN UPDATED TO INCLUDE AN ADDITIONAL 1/2 PAGE OF P.T.
:	IF NO SPACE IS AVAILABLE THEN THIS ROUTINE TAKES AN ERROR
:	RETURN (NO SKIP).  

:	TRY TO FIND A HALF-PAGE FROM THE PERMUTER TABLE POOL. IF NO HALF-
:	PAGES AVAILABLE, TAKE IMMEDIATE RETURN. IF A HALF-PAGE IS FOUND,
:	INCLUDE IT IN THE DOMAIN OF PERMUTER TABLE SPACE ALLOCATED TO
:	THE LINK 'KN'.
BUBBLE	HS	0
	LR	R5,KN			:START WITH CURRENT LINK, SCAN TO END
BUBL1	LHL	R1,TBDPKN+2,R5,R5	:GET NEXT LINK'S BEGIN POINTER AND
	LHL	R0,EBDPKN,R5,R5		:COMPARE TO THIS LINK'S END POINTER
        SR      R1,R0
	JG	BUBL3			:GREATER - FOUND A BUBBLE
	AIS	R5,1			:INCREMENT LINK INDEX
	CLHI	R5,NLINKS		:END?
	JLBS	BUBL1			:NOT YET

:	REACHED FINAL LINK WITHOUT FINDING A BUBBLE. START FROM BEGINNING
:	AND SCAN UP TO LINK WE ENTERED WITH.
	LIS	R5,0
BUBL2	LHL	R1,TBDPKN+2,R5,R5	:GET NEXT LINK'S BEGIN POINTER AND
	LHL	R0,EBDPKN,R5,R5		:COMPARE TO THIS LINK'S END POINTER
        SR      R1,R0
	JG	BUBL13			:FOUND A BUBBLE
	AIS	R5,1
	CLR	R5,KN			:SCANNED ALL LINKS FOR BUBBLES?
	JLBS	BUBL2			:NO - CONTINUE
	IF	DB.DEB
	LH	R0,NUMPAG,,		:CONSISTENCY TEST - PAGES AVAIL > 0?
	JEFS	BUBEXI			:NO - O.K.			###wjl
	DBOOPS
	EI	:DB.DEB
BUBEXI	SKIP(0,R8)			:YES, NON-SKIP RETURN - NO BUBBLE FOUND

BUBL3	STH	R5,BUBS1		:SAVE NUMBER OF LINK PRIOR TO BUBBLE
	LHL	R3,EBDPKN,R5,R5
	LHL	R4,TBDPKN+2,R5,R5
	LR	R5,R4
	SR	R5,R3			:COMPUTE SIZE OF EXISTING BUBBLE
	ST	R5,BUBS2		:AND SAVE
	SRLS	R5,1			:NUMBER OF CHANNELS IN BUBBLE
	LR	R1,R3			:GET BEGIN-BUBBLE POINTER, COMPUTE DIST
	LHL	R0,EBDPKN,KN,KN		:BACK TO END OF CURRENT LINK'S TABLES
        SR      R1,R0
	STH	R1,BUBS3		:SAVE FOR POSSIBLE POST-MORTEM

:	BUBS1 -	LINK NUMBER OF LINK PRIOR TO BUBBLE
:	BUBS2 -	BUBBLE SIZE
:	R1 -	# BYTES FROM END OF CURRENT LINK'S TABLES TO BEGINNING OF BUBBL
:	R3 -	POINTER TO BEGINNING OF BUBBLE
:	R4 -	POINTER TO END OF BUBBLE
:	R5 -	NUMBER OF CHANNELS IN BUBBLE

:	ALL TABLES FROM THE END OF THE CURRENT LINK TO THE BEGINNING OF THE
:	BUBBLE MUST BE MOVED SO THAT THE BUBBLE FOLLOWS THE CURRENT LINK (KN).
BUBL4	SIS	R3,2
	SIS	R4,2			:MOVING A HW AT A TIME
	SIS	R1,2			:NUMBER OF BYTES REMAINING TO MOVE
	JL	BUBL5			:DONE

	LHL	R2,NIOTAB,R3,		:MOVING FROM LEFT..
	STH	R2,NIOTAB,R4,		:..TO RIGHT
	JEBS	BUBL4			:NULL ENTRY
	LIS	R0,0
	STH	R0,NIOTAB,R3,		:DON'T LEAVE JUNK BEHIND
	LHL	R0,BPSCNT,R3,
	STH	R0,BPSCNT,R4,		:MOVE BACKPRESSURE RESTRICTION COUNT
	NHI	R2,-4			:ISOLATE BUFFER INDEX FROM P.T. ENTRY
	XHI	R2,4			:BUFFER INDEX POINTS TO P.T. ENTRY
	LH	R0,BF,R2,
	JE	BUBL4			:BF ZERO
	AR	R0,R5			:RE-COMPUTE BF BASED ON NUMBER
	STH	R0,BF,R2,		:OF CHANNELS DIFFERENCE
	SHI	R0,LNKZFL		:CONSISTENCY CHECK TO INSURE BF POINTS
	SLLS	R0,1			:TO CHANNEL JUST MODIFIED
	CR	R0,R4
	JE	BUBL4			:POINTER CONSISTENT WITH NIOTAB INDEX
	CRASH.(.BUBCR)
:	PERMUTER TABLES MOVED...NOW COPY BIT ARRAYS
BUBL5	LH	R5,BUBS1		:GET BACK NUMBER OF LINK PRIOR TO BUBBL
	CLR	R5,KN			:BUBBLE DIRECTLY BEHIND CURRENT LINK?
	JE	BUBL9			:YES, NO TABLES MOVED,
					: SO NO BIT ARRAYS TO COPY
	LHL	R3,EBDPKN,R5,R5
	LHL	R4,TBDPKN+2,R5,R5
	LR	R1,R3			:RE-COMPUTE NUMBER OF TABLE BYTES MOVED
	LHL	R0,EBDPKN,KN,KN		:TO KNOW HOW MUCH OF BIT ARRAYS TO COPY
        SR      R1,R0
	SRLS	R3,4			:SET UP INDEX REGS
	SRLS	R4,4			: FOR COPYING BIT ARRAYS
BUBL6	SIS	R3,4
	SIS	R4,4			:DECREMENT FOR NEXT FULLWORD COPY
	SHI	R1,40			:20 CHANNELS/WORD * 2 BYTES/CHANNEL
	JLFS	BUBL7			:FINISHED BIT ARRAY COPY
	JAL	R2,BUBSUB		:COPY BIT VALUES TO NEW POSITION
	JBS	BUBL6
:	NOW UPDATE POINTERS FOR ALL LINKS WHICH HAD P.T. TABLES MOVED
BUBL7	L	R0,BUBS2		:BUBBLE SIZE
	LR	R1,R0
	SRLS	R1,1			:NUMBER OF CHANNELS MOVED
	LR	R3,R1
	SRLS	R3,3			:NUMBER OF CHANNELS/8 = BYTE
					: DISPLACEMENT FOR LINK BIT ARRAYS
	LHI	R4,1,KN			:LINK NUMBER OF LINK AFTER CURRENT LINK
BUBL8	AHM	R1,LKZFKN,R4,R4		:ADJUST ABS CHANNEL # WHERE LINK BEGINS
	AHM	R0,TBDPKN,R4,R4		:ADJUST ALL TABLE ADDRESS POINTERS BY
        LHL     R6,TBDPKN,R4,R4
	AHM	R3,FLDPKN,R4,R4		: ACTUAL BYTE DISPLACEMENT
	AHM	R3,LKFGND,R4,R4
	AHM	R3,LKSVND,R4,R4
	AHM	R3,LKBPND,R4,R4
	AHM	R0,EBDPKN,R4,R4
	LR	R2,R3			:ASSUME WE'RE SLAVE ON THIS LINK
	LB	R6,MASTKN,R4,		:0 IF SLAVE, 1 IF MASTER
	JEFS	BUBL8C			:SLAVE, ALLOCATE CHANS FROM BOTTOM UP
	LIS	R2,0			:MASTER.  WE USE NEGATIVE ACP, CHS,
	SR	R2,R3			: AND MUST ADJUST POINTERS IN NEGATIVE
					: DIRECTION, CHANNEL SCAN FROM TOP DOWN
BUBL8C	AHM	R2,LKAPND,R4,R4		:POINTER TO LAST HW IN ACP ARRAY
	AHM	R2,LKCSND,R4,R4		:POINTER TO LAST HW IN CHS ARRAY
	AIS	R4,1			:ANY MORE LINKS REQUIRE ADJUSTMENT?
	CLR	R4,R5
	JLE	BUBL8			:YES - CONTINUE

:	ALLOCATE BUBBLE TO CURRENT LINK'S (KN) DOMAIN
BUBL9	LHI	R0,80			:NUMBER OF CHANNELS PER HALF-PAGE
	AHM	R0,NCHN,KD
	LHI	R3,10			:BYTE DISPLACEMENT FOR CHAN BIT ARRAY
	AR	R0,R0
	AHM	R3,LKFGND,KN,KN		:ADJUST END POINTERS TO REFLECT
	AHM	R3,LKSVND,KN,KN		:ADDITIONAL CHANNELS AVAILABLE TO LINK
	AHM	R3,LKBPND,KN,KN
	AHM	R0,EBDPKN,KN,KN
	LB	R0,MASTKN,KN,		:ARE WE MASTER OR SLAVE ON THIS LINK?
	JNFS	BUBL9C			:MASTER
	AHM	R3,LKAPND,KN,KN		:SLAVE - ADJUST END POINTERS
	AHM	R3,LKCSND,KN,KN
BUBL9C	LH	R0,NUMPAG,,
	SIS	R0,1			:DECREMENT NUMBER OF AVAILABLE PAGES
	STH	R0,NUMPAG,,
	SIS	R0,2			:RUNNING LOW ON FREE HALF-PAGES?
	JGFS	BUBL10			:NO
	LHI	R0,1F-PGMSRK		:YES - SCHEDULE PROCESS TO SEE
	SBT	R0,SQUEUE		:IF ANY LINKS COULD USE SOME SHRINKING
:	NEW HALF-PAGE ALLOCATED TO LINK. INITIALIZE NIOTAB ENTRIES TO ZERO.
BUBL10	LIS	R0,0
	LHI	R1,40
	LHL	R2,EBDPKN,KN,KN		:END OF TABLES POINTER
BUBL11	ST	R0,NIOTAB-4,R2,		:ZERO PERMUTER TABLE ENTRY
	SIS	R2,4			:WORKING BACKWARDS THROUGH TABLE
	SIS	R1,1			:DONE?
	JGBS	BUBL11			:NO - CONTINUE
:	INITIALIZE FLAGS TO ZERO AND ACP, CHS (POSITIVE AND NEGATIVE) TO
:	ONES. CLEAR GUSH AND TRIKLE.
	LHL	R2,LKZFKN,KN,KN		:CHANNEL 0 FOR LINK (DISTANCE FROM ACP)
	AH	R2,NCHN,KD		:NEW NUMBER OF CHANNELS MINUS 80 POINTS
	SHI	R2,80			:TO NEWLY ACQUIRED HALF-PAGE
	SRLS	R2,3			:DIVIDE BITS/8 FOR BYTE DISPLACEMENT
	LCS	R3,4
	SR	R3,R2			:INDEX FOR NEGATIVE ACP, CHS
	LCS	R4,1
	LIS	R1,4			:HALF-PAGE BIT ARRAY IS 4 WORDS LONG
BUBL12	ST	R0,NFLAGS,R2
	ST	R0,GUSH-LNKZFL/8,R2,
       if       1-notrik                :don't do trickle logic
	ST	R0,TRIKLE-LNKZFL/8,R2,
       ei      :1-notrik
	ST	R0,NEEDLE-LNKZFL/8,R2,
	ST	R0,PRIRTY-LNKZFL/8,R2,
	ST	R0,CMDCTS-LNKZFL/8,R2,
	ST	R4,ACP,R2,
	ST	R4,CHS,R2,		:INDICATE THESE CHANNELS AVAILABLE
	ST	R4,ACP,R3,
	ST	R4,CHS,R3,
	SIS	R3,4
	AIS	R2,4
	SIS	R1,1
	JG	BUBL12
:	TABLES, ARRAYS, AND FLAGS FIXED. RE-COMPUTE CHANNEL MAP.
	LIS	R2,4			:START WITH 2ND ENTRY IN CHNMAP
	LHI	R1,(NLINKS-1)*2		:CHNMAP ORDERED FROM HIGHEST LINK
BUBLF	LHL	R0,LKZFKN,R1,		:GET ABS CHAN # FOR THIS LINK'S CHN 0
	STH	R0,CHNMAP,R2		:STORE IN CHANNEL MAP FOR PROBE TRACE
	AIS	R2,4
	SIS	R1,2
	JGEBS	BUBLF			:DO FOR ALL LINKS

:	CONSISTENCY CHECK FOR LKAPND IF WE ARE SLAVE...
	LHI	R9,NLINKS-1
BUBLF1	LB	R0,MASTKN,R9,		:ONLY EDIT IF WE ARE SLAVE
	JN	BUBLF2			:WE'RE MASTER
	LHL	R0,LKSVND,R9,R9
	SI	R0,CHSRVD,		:COMPARE 'END OF' POINTER WE HAVE
	LHL	R10,LKAPND,R9,R9	:CONFIDENCE IN TO LKAPND FOR SAME
	SHI	R10,LNKACP		:DISTANCE FROM RESPECTIVE ORIGINS
	CR	R0,R10			:SHOULD BE EQUAL
	JEFS	BUBLF2			:O.K.
	CRASH.(.BUBC0)
BUBLF2	SIS	R9,2			:DO FOR ALL LINKS
	JGE	BUBLF1

	TBT	KN,ALINKS		:LINK JUST COMING UP?
	JE	4,R8			:YES, MAKE NO REPORT FOR INITIAL BUBBLE
	ST	R8,RTMT2		:SAVE LINK REGISTER FOR CALL TO SUP12
	LIS	R0,NR.BUB		:INDICATE TYPE OF REPORT 
	JAL	R10,SUP12L,,		:REPORT LINK BUBBLE TO SUPERVISOR LOG
	L	R8,RTMT2
	J	4,R8			:SKIP RETURN

:	FOUND A BUBBLE BEFORE CURRENT LINK
BUBL13	STH	R5,BUBS1		:SAVE NUMBER OF LINK PRIOR TO BUBBLE
	LHL	R3,TBDPKN+2,R5,R5	:FIRST HW AFTER BUBBLE
	LHL	R4,EBDPKN,R5,R5		:FIRST HW OF BUBBLE
	LR	R5,R4
	SR	R5,R3			:COMPUTE NEGATIVE BUBBLE SIZE
	ST	R5,BUBS2
	SRA	R5,1			:NEGATIVE NUMBER OF CHANNELS IN BUBBLE
	LHL	R1,EBDPKN,KN,KN		:# OF BYTES TO MOVE IS DIFF BETWEEN
	SR	R1,R3			: END OF CURRENT LINK'S TABLES (KN)
					: AND END OF BUBBLE
	STH	R1,BUBS3		:SAVE FOR INTERESTED OBSERVER

:	BUBS1 -	LINK NUMBER OF LINK PRIOR TO BUBBLE
:	BUBS2 -	NEGATIVE BUBBLE SIZE
:	R1 -	NUMBER OF BYTES TO MOVE
:	R3 -	POINTER TO END OF EXISTING BUBBLE
:	R4 -	POINTER TO BEGINNING OF EXISTING BUBBLE
:	R5 -	NEGATIVE NUMBER OF CHANNELS IN BUBBLE
	SIS	R3,2
	SIS	R4,2
:	MOVE TABLES INTO AREA WHICH IS CURRENTLY A BUBBLE. MEMORY WHICH IS
:	VACATED BY MOVE BECOMES NEW BUBBLE, DIRECTLY BEHIND CURRENT LINK.
BUBL14	AIS	R3,2
	AIS	R4,2
	SIS	R1,2			:MOVED ALL PERMUTER TABLE ENTRIES?
	JL	BUBL15			:YES

	LHL	R2,NIOTAB,R3,		:MOVING FROM RIGHT..
	STH	R2,NIOTAB,R4,		:..TO LEFT
	JEBS	BUBL14			:NULL P.T. ENTRY
	LIS	R0,0
	STH	R0,NIOTAB,R3,		:CLEAN UP BEHIND US
	LH	R0,BPSCNT,R3,
	STH	R0,BPSCNT,R4,		:MOVE BUFFER RESTRICTION COUNT
	NHI	R2,-4
	XHI	R2,4			:GET BF WHICH POINTS TO THIS P.T. ENTRY
	LH	R0,BF,R2,
	JE	BUBL14			:BF ZERO
	AR	R0,R5			:DECREMENT BF, P.T. ENTRY AT LOWER ADDR
	STH	R0,BF,R2,
	SHI	R0,LNKZFL		:TEST CHANNEL # AGAINST NIOTAB INDEX
	SLLS	R0,1
	CR	R0,R4			:INSURE POINTING TO PROPER IOTAB ENTRY
	JE	BUBL14			:O.K.
	CRASH.(.BUBC1)
:	PERMUTER TABLE ENTRIES MOVED...COPY BIT ARRAYS
BUBL15	LH	R5,BUBS1		:GET # OF LINK WHICH WAS BEFORE BUBBLE
	LHL	R3,TBDPKN+2,R5,R5	:SOURCE..
	LHL	R4,EBDPKN,R5,R5		:..DESTINATION
	LHL	R1,EBDPKN,KN,KN
	SR	R1,R3			:RE-COMPUTE NUMBER OF BYTES MOVED
	SRLS	R3,4
	SRLS	R4,4			:BIT ARRAY INDEX
	SIS	R3,4
	SIS	R4,4
BUBL16	AIS	R3,4
	AIS	R4,4			:INCREMENT FOR NEXT FULLWORD COPY
	SHI	R1,40
	JLFS	BUBL17			:FINISHED BIT ARRAY COPY
	JAL	R2,BUBSUB		:COPY BIT VALUES TO NEW POSITION
	JBS	BUBL16
:	NOW DECREMENT POINTERS FOR ALL LINKS WHICH HAD P.T. ENTRIES MOVED
BUBL17	L	R0,BUBS2		:NEGATIVE BUBBLE SIZE
	LR	R1,R0
	SRLS	R1,1			:NEGATIVE NUMBER OF CHANNELS
	LR	R3,R1
	SRLS	R3,3			:NUMBER OF CHANNELS/8 = BYTE
					: DISPLACEMENT FOR LINK BIT ARRAYS
	AIS	R5,1			:INCREMENT R5 TO FIRST LINK MOVED
BUBL18	AHM	R1,LKZFKN,R5,R5		:ADJUST ABS CHAN # WHERE LINK BEGINS
	AHM	R0,TBDPKN,R5,R5		:ADJUST ALL TABLE ADDRESS POINTERS BY
        LHL     R6,TBDPKN,R5,R5
	AHM	R3,FLDPKN,R5,R5		: ACTUAL BYTE DISPLACEMENT
	AHM	R3,LKFGND,R5,R5
	AHM	R3,LKSVND,R5,R5
	AHM	R3,LKBPND,R5,R5
	AHM	R0,EBDPKN,R5,R5
:	DECREMENTING POINTERS IS ACTUALLY MOVING THEM CLOSER TO ORIGIN. IF
:	WE ARE MASTER ON THIS LINK, ACP AND CHS POINTERS SHOULD BE INCREMENTED.
	LR	R2,R3			:ASSUME WE ARE SLAVE
	LB	R6,MASTKN,R5,		:ARE WE MASTER OR SLAVE?
	JEFS	BUB18C			:SLAVE
	LIS	R2,0			:MASTER - CHANGE DIRECTION OF
	SR	R2,R3			:POINTER UPDATE
BUB18C	AHM	R2,LKAPND,R5,R5		:POINTER TO LAST HW IN ACP FOR LINK
	AHM	R2,LKCSND,R5,R5		:POINTER TO LAST HW IN CHS FOR LINK
	AIS	R5,1			:DO FOR ALL LINKS WHICH GOT P.T. MOVED
	CLR	R5,KN
	JLE	BUBL18			:UP TO AND INCLUDING CURRENT LINK
	J	BUBL9

::*********************************************************************
::
::	SUBROUTINE:	BUBSUB:
::	FUNCTION:	COPY BIT ARRAYS
::	CALLING SEQ:	JAL	R2,BUBSUB
::
::*********************************************************************

BUBSUB	HS	0			:SUBROUTINE FOR COPYING BIT ARRAYS
	L	R0,GUSH,R3,
	ST	R0,GUSH,R4,		:COPY 'GUSH', R3 SOURCE, R4 DESTINATION
       if       1-notrik
	L	R0,TRIKLE,R3,
	ST	R0,TRIKLE,R4,		:TRIKLE
       ei       :1-notrik
	L	R0,LNKFLG,R3,
	ST	R0,LNKFLG,R4,
	L	R0,LNKBPV,R3,
	ST	R0,LNKBPV,R4,
	L	R0,CHSRVD,R3,
	ST	R0,CHSRVD,R4,
	L	R0,BPSVCP,R3,
	ST	R0,BPSVCP,R4,
	L	R0,NEEDLE,R3,
	ST	R0,NEEDLE,R4,
	L	R0,PRIRTY,R3,
	ST	R0,PRIRTY,R4,
	L	R0,CMDCTS,R3,
	ST	R0,CMDCTS,R4,
	L	R0,LNKACP,R3,
	ST	R0,LNKACP,R4,
:	COPY 'NEGATIVE' ACP, CHS. USE R14, R15 AS INDEX REGS FOR OPPOSITE
:	POLARITY.
	STM	R14,LNKRGS		:PRESERVE REGS
	LCS	R14,4
	SR	R14,R3			:NEGATIVE SOURCE
	LCS	R15,4
	SR	R15,R4			:NEGATIVE DESTINATION
	L	R0,EKNACP,R14,
	ST	R0,EKNACP,R15,
	L	R0,EKNCHS,R14,
	ST	R0,EKNCHS,R15,
	LM	R14,LNKRGS
	JR	R2			:RETURN

	SUBTTL	UTIL (SHRINK)

::*********************************************************************
::
::	PROCESS:	MSHRNK:
::	FUNCTION:	SEE IF ANY LINKS NEED P.T. SHRINK
::	SCHEDULED:	Every 8 minutes.  Dismisses to EXEC loop.
::
::*********************************************************************

MSHRNK	HS	0
	IF	DB.CPU
	JALMAC(CPUTIZ`,`,)		:START CPUTIL FOR THIS ROUTINE	###OAS
	CPUTNM(MSHRNK)			:DEFINE THIS CPUTIL ENTRY	###OAS
	EI	:DB.CPU
	LHI	R9,4*(NLINKS-1)         :2 links means doing link 0 and link 1
MSHRN1	L	KD,KDKN,R9,
	LB	R0,KTYP,KD		:GET LINK TYPE	###EV
	JE	MSHRN2			:NO - CAN ONLY SHRINK T-II LINKS
	LH	R0,SHSTAT,KD		:IS SHRINK IN PROGRESS?
	JN	MSHRN2			:YES - ONLY ONE AT A TIME
	LB	R0,NLAT,KD		:IS LINK UP?
	JE	MSHRN2			:NOT IF NO LINES ATTACHED
	LH	R0,NEDOUT,KD		:ARE ANY NEEDLES OUTSTANDING BETWEEN
					: CRQ AND RMAKE?
	JN	MSHRN2			:YES, AVOID POSSIBLE RACE, DEFER SHRINK
:	SEE IF ENOUGH INACTIVE CHANNELS TO CALL FOR SHRINK.
:	IF 4*(# INACTIVE CHANNELS) >= (MAX # CHANNELS)+600,
:	THEN REQUEST A SHRINK FOR THIS LINK
	LH	R0,NCHN,KD		:3*NCHN-4*ANCHN-600
	CLHI	R0,80
	JLEFS	MSHRN2			:DON'T CONSIDER LINK WITH ONLY 80 CHANS
	SH	R0,ANCHN,KD
	SLLS	R0,2
	SH	R0,NCHN,KD
	SHI	R0,$A 600
	JLFS	MSHRN2
	LIS	R0,2			:LOTS OF SPARE CHANNELS...
	STB	R0,SHSTAT,KD		:DO A SHRINK
MSHRN2
	SIS	R9,4
	JGE	MSHRN1			:CHECK ALL LINKS
	J	EXDISM,,		:DONE

	SUBTTL	UTIL (FIND)

::*********************************************************************
::
::	SUBROUTINE:	FNDHST:
::	FUNCTION:	LOCATES A HOST IN THE HOST TABLES.
::	CALLING SEQ:	JAL	R9,FNDHST
::	INPUT:		R1  = HOST NUMBER
::	OUTPUT:		R13 = HN = HOST INDEX
::	PRESERVED:	R1
::	RETURNS:	IMMEDIATE = NONEXISTENT HOST
::			+4 = HOST FOUND
::
::*********************************************************************

FNDHSL	LIS	R1,0			:>>ENTER HERE TO FIND NEXT FREE ENTRY<<
FNDHST	HS	0			:>>ENTER HERE TO FIND A GIVEN HOST<<
	LHI	HN,NHOSTS-1
FNDHS1	CLH	R1,HOSTN,HN,HN
	JE	4,R9			:FOUND IT, SKIP 4 BYTES
	SIS	HN,1
	JGEBS	FNDHS1
        LR      HN,R1   	        :RESTORE HOST NUMBER AND EXIT  ###LH
	SKIP(0,R9)			:immediate ret, NONEXISTENT HOST##wjl

::*********************************************************************
::
::	SUBROUTINE:	FNDLNK:
::	FUNCTION:	LOCATES THE LINK DESCRIPTOR TO A GIVEN NEIGHBOR.
::			SETS REGISTERS 'KN' AND 'KD' TO THE APPROPRIATE VALUES.
::	CALLING SEQ:	JAL	R9,FNDLNK
::	INPUT:		R1 = NEIGHBOR # (PRESERVED)
::	RETURNS:	SKIP RETURN IF FOUND, ELSE TAKES IMMEDIATE RETURN.
::
::*********************************************************************

FNDLNZ	LIS	R1,0			:>>ENTER HERE TO FIND NEXT FREE ENTRY<<
FNDLNK	HS	0			:>>ENTER HERE TO FIND A GIVEN LINK D.<<
	LHI	KN,NLINKS-1		:HIGHEST LINK #
FNDLN1	SLLS	KN,1			:				###wjl
	L	KD,KDKN,KN,KN		:LINK DESCRIPTOR FOR THIS LINK
	SRLS	KN,1			:				###wjl
	CLH	R1,NDID,KD
	JE	4,R9			:FOUND IT, SKIP 4 BYTES
	SIS	KN,1
	JGEBS	FNDLN1
	SKIP(0,R9)			:NONEXISTENT LINK, TAKE IMMED RETURN

::*********************************************************************
::
::	SUBROUTINE:	FCHLNK:
::	FUNCTION:	LOCATES THE LINK NUMBER TO THE ABSOLUTE CHAN#
::	CALLING SEQ:	JAL	R9,FCHLNK
::	INPUT:		R3 = ABSOLUTE CHAN NUMBER
::	DESTROYED:	R0,R1
::	RETURNS:	SKIP RETURN IF FOUND, ELSE TAKES IMMEDIATE RETURN.
::	OUTPUT:		R0 IS THE LINK#
::
::*********************************************************************

      IF	T2GATE		:T-II Gateway only			###wjl
      IF	IRC		:International record Carrier only	###wjl
FCHLNK	HS	0
	LIS	R0,0		:INIT LINK# 0
	CLH	R3,LKZFKN,,	:TABLE OF ABSOLUTE CHAN# FOR 1ST CHANS
	JL	FCHEXI		:ERR RETURN IF <LNKZFL			###wjl
	CHI	R3,LNKLFL	:MAX CHAN#
	JGFS	FCHEXI		:ERR RETURN IF >LNKLFL			###wjl
	LIS	R1,2		:LINK PTR. TO LKZFKN TABLE
FCK01	CLH	R3,LKZFKN,R1,
	JL	4,R9		:WE GOT IT, GOOD RETURN
	CI	R1,2*TCHANS	:MAX. PTR.
	JE	4,R9		:END OF LAST CHAN#
	AIS	R0,1		:INC. LINK#
	AIS	R1,2		:INC. PTR.
	JBS	FCK01		:TRY NEXT ONE

FCHEXI	SKIP(0,R9)		:immediate return			###wjl
      EI	:IRC
      EI	:T2GATE

::*********************************************************************
::
::      SUBROUTINE:  CHFLNK
::      FUNCTION:    finds the link (returned in r3) from chn (in r5)
::      RETURN:      Links on R8, normal return if can't find neighbor
::                   for chn, +4 is chn is internal, +8 if link chn.
::
:	Fix crash 0007 from corrupted Qexec entry 11x, caused by
:	non-Xray process CRQZOG (needle-point killed by an 03-xx
:	char pair, usually a hard zapper) as follows:
:	  Calling Xray routine CHNLNK/XFNDLK which expects R15 to
:	  be Xray user block for data storage, resulting in random
:	  memory corruption.
:	Also fixed:
:	  CRQZOG does not establish the channel register.
:	  Non-Xray LEP9V1 (T-I early zapper) calls Xray CHNLNK/XFDNLK.
:	  Use own node# on internal termination return from CHNLNK/
:	  XFNDLK (wasn't carried forward from v5.06 patch).
:
::*****************************************************************

CHFLNK	LHL	CHN,BF,R2,		:Get channel# from buffer BF
CHFLN1	LCS	R3,4			:Initial index to CHNMAP
CHFLN2	AIS	R3,4			:Bump to next entry
	CLH	CHN,CHNMAP,R3		:Q.Less than beginning channel
	JLBS	CHFLN2			:Y.Look at next entry
	LHL	R3,CHNMAP+2,R3		:Right chnl range, get data
	THI	R3,8000			:Q.HOB for internal term.
	JN	CHFLN7			:Y.Return as internal term.
	LHL	R3,CHNMPD,R3		:Get link data
	THI	R3,8000			:Q.HOB for T-I neighbor
	JEFS	CHFLN3			:N.Go verify that T-II is up
	NHI	R3,3FFF			:Clear HOB for T-I
	J	8,R8			:Return as found neighbor
CHFLN3	LHI	R1,2*(NLINKS-1)		:Index for links
CHFLN4	LHL	R9,KDKN,R1,		:Get link descriptor
	CLH	R3,NDID,R9		:Q.Neighbor found
	JEFS	CHFLN5			:Y.Return as found neighbor
	SIS	R1,2			:Q.More to check
	JGEBS	CHFLN4			:Y.Go check next entry
	LBR	R1,R0			:Restore R1
	J	CHFLN6			:Return as no neighbor
CHFLN5	LBR	R1,R0			:Restore R1
	J	8,R8			:Return as found neighbor

CHFLN6  SKIP(0,R8)                      :no neighbor at all
CHFLN7  SKIP(4,R8)                      :found internal


::*********************************************************************
::
::	SUBROUTINE:	FNDCRQ:
::	FUNCTION:	LOCATES A GIVEN CIRCUIT FOR CRQ/LEP.
::	CALLING SEQ:	JAL	R9,FNDCRQ
::	OUTPUT:
::		IF INVOICE NUMBER FOUND:
::			R6 = OUTBOUND BUFF #
::			R7 = HISTORY BUFFER #
::		IF INVOICE NUMBER NOT FOUND, R0 = 0
::		IF INVOICE NUMBER FOUND BUT BF ISN'T A STUB, R0 = -1
::	DESTROYED:	R0, R1
::	RETURNS:	IMMEDIATE RETURN IF BUFFER NOT FOUND
::			+4 SKIP RETURN IF A MATCH IS FOUND
::
::*********************************************************************

:	FNDCRQ STEPS THROUGH ALL HISTORY BUFFER NUMBERS, BEGINNING AT HBUFN,
:	LOOKING FOR A BUFFER WHOSE INVOICE NUMBER MATCHES CQINV AND WHOSE
:	BF IS A STUB. SKIP RETURNS IF A MATCH IS FOUND, ELSE IMMEDIATE RETURN

	IF	REBILD
FNDCRQ	L	R1,CQINV		:SEARCH ON INVOICE #
	LIS	R0,0			:SET R0=0, INDICATE INVOICE # NOT FOUND
	LI	R7,LBUFN-HBUFN-4	:START AT LAST HISTORY BUFFER
FNDCR1	CL	R1,RINVC+HBUFN,R7,	:DOES IT'S INVOICE NUMBER MATCH CQINV?
	JEFS	FNDCR2			:YES, POSSIBLE MATCH
	SIS	R7,4			:NO, ADVANCE TO NEXT BUFFER
	JGEBS	FNDCR1			:KEEP LOOKING IF MORE LEFT
	SKIP(0,R9)			:AT END OF HISTORY BUFFERS, NO MATCH.
					: RETURN
FNDCR2	LCS	R0,1			:SET R0= -1 TO INDICATE INVOICE # FOUND
	LR	R6,R7			:COMPUTE OUTBOUND BUFF #
	AI	R7,HBUFN		:AND THE ABSOLUTE HISTORY BUFFER NUMBER
	SLHLS	R6,1
	LHL	R1,BF,R6,		:CHECK FOR STUB AT THE OTHER END
	CLHI	R1,STUBFL
	JE	4,R9			:YES, THIS IS A GOOD STUB... RETURN
	AIS	R6,4			:NO, ARE WE LOOKING AT WRONG SIDE...
	LHL	R1,BF,R6,
	CLHI	R1,STUBFL
	JE	4,R9			:FOUND THE STUB, RETURN
	SKIP(0,R9)			:CAN'T FIND A STUB, RETURN WITH R0= -1
	EI	:REBILD

::*********************************************************************
::
::	SUBROUTINE:	FNDCHN:
::	FUNCTION:	LOCATES A FREE PORT
::	CALLING SEQ:	JAL	R9,FNDCHN
::	INPUT:		R5 = INITIAL CHANNEL # (CHN)
::			R1 = # OF CHANNELS TO SEARCH
::	DETROYED:	R0
::	RETURNS:	SKIPS IF FOUND, ELSE TAKES IMMEDIATE RETURN.
::
::*********************************************************************

FNDCHN	HS	0
	LHL	R0,IOTAB,CHN,CHN	:IS THIS CHANNEL FREE?
	JN	FNDCH2			:NO
	TBT	CHN,ACP,,		:YES - ACP SHOULD BE CONSISTENT
	JE	FNDCRS			:ACP INDICATES CHANNEL NOT AVAILABLE,
					: - OOOPS!
	LCS	R0,1			:CHECK NEGATIVE ACP ARRAY
	SR	R0,CHN
	TBT	R0,ACP,,
	JE	FNDCRS			:WHY IS CHANNEL NOT AVAILABLE??
	LR	R0,R2
	LHI	R2,-DISZFL,CHN		:CHECK IF DISPATCHER PORT
	JGEFS	FNDCH1			:YES - CHECK ISIS
	LR	R2,R0
	J	4,R9			:NO - RETURN
FNDCH1	LHL	R2,PTABLE,R2,R2,	:CHECK ISIS PERMUTER TABLE
	JNFS	FNDCRS			:ISIS INDICATES CHANNEL IN USE
	LR	R2,R0			:PRESERVE R2
	J	4,R9			:TAKE OK RETURN
FNDCRS	CRASH.(.FNCHC)
FNDCH2	AIS	CHN,1
	SIS	R1,1
	JG	FNDCHN
	SKIP(0,R9)			:immed ret - NO FREE PORT FOUND	###wjl

::*********************************************************************
::
::	SUBROUTINE:	FNDKNC:
::	FUNCTION:	FIND CHANNEL FOR LINK.
::	CALLING SEQ:	JAL	R9,FNDKNC
::	RETURNS:	IMMEDIATE = NO CHANNEL FOUND
::			+4 = CHANNEL FOUND
::
::*********************************************************************

:	CHANNEL IS AVAILABLE IF ACP .AND. CHS ARE SET. ARRAYAND
:	INSTRUCTION IS USED TO SCAN ACP AND CHS BIT ARRAYS.
:	EACH LINK PROVIDES POINTER TO LAST HALFWORD IN ARRAY. NCHN (NUMBER OF
:	CHANNELS ALLOCATED TO LINK) PROVIDES THE BIT COUNT FOR THE ARRAYAND.
:	THE BYTE ARRAY MASTKN INDICATES WHETHER WE ARE MASTER OR SLAVE ON THIS
:	LINK. IF WE ARE SLAVE, POINTERS DIRECT US TO THE 'POSITIVE' ACP AND CHS
:	WHERE WE SCAN FROM THE BOTTOM UP. IF WE ARE MASTER, POINTERS ARE TO
:	'NEGATIVE' ACP AND CHS, AND WE SCAN FROM THE TOP DOWN WITH REGARD TO
:	CHANNEL NUMBERS.

FNDKNC	HS	0
	STM	R14,LNKRGS		:SAVE WORK REGS
	LHL	R14,LKAPND,KN,KN	:LAST HW IN ACP ARRAY
	LHL	R15,LKCSND,KN,KN	:LAST HW IN CHS ARRAY

	IF	ESYNC
	SIS	R1,1			:NUMBER OF CHANNELS MINUS 1
	ARAND	R14,R1			:ARRAYAND, POINTERS IN R14, R15,
					: COUNT IN R1
	JFS	FNDC10			:GOT A HIT
	J	FNDC40			:NO CHANNELS AVAILABLE
FNDC10	HS	0
	ELSE	:ESYNC			:NOT ENHANCED SYNC
	SRLS	R1,3			:# OF CHANS/8 FOR BYTE COUNT
	SIS	R1,2			:LESS 2 FOR THE LAST HW
	SR	R14,R1			:FIRST WORD IN ACP FOR KN
	SR	R15,R1			:FIRST WORD IN CHS FOR KN
	LIS	CHN,0			:CHANNEL COUNT (BUMP FOR EACH WD)
FNDC09  HS	0			:START ARRAY AND LOOP
	L	R0,0,R14		:GET A WD OF ACP
	N	R0,0,R15		:AND A WD OF CHS
	JFFO	R0,FNDC10		:SEARCH FOR FREE CHANNEL
	AIS	R14,4			:NONE FREE HERE TRY AGAIN
	AIS	R15,4
	AHI	CHN,20			:BUMP # OF CHANNEL
	CLH	R15,LKCSND,KN,KN	:AT LAST HW YET?
	JLEBS	FNDC09			:NO, LOOK SOME MORE
	J	FNDC40			:YES, NONE FREE
FNDC10  HS	0
	AR	R1,CHN			:FOUND ONE, GET CHANNEL NUMBER
	EI	:ESYNC
	LM	R14,LNKRGS		:RESTORE REGISTERS.
	LB	R0,MASTKN,KN,		:ARE WE THE MASTER ON THIS LINK?
	JNFS	FNDC20			:YES
	LR	CHN,R1			:NO, SINCE WE WORK FROM BOTTOM UP,
	JFS	FNDC30			: R1 HAS LINK RELATIVE CHANNEL NUMBER
FNDC20	LHL	CHN,NCHN,KD		:NUMBER OF CHANNELS ALLOCATED TO LINK
	SIS	CHN,1			:CHN HAS HIGHEST ALLOCATD CHAN FOR LINK
	SR	CHN,R1			:HIGHEST AVAILABLE CHANNEL
FNDC30	AH	CHN,LKZFKN,KN,KN	:CONVERT TO ABSOLUTE CHANNEL
	LH	R0,IOTAB,CHN,CHN	:IS CHANNEL REALLY FREE?
	JE	4,R9			:YES - SKIP RETURN
	CRASH.(.FNCH0)
FNDC40	LM	R14,LNKRGS		:RESTORE REGS
	SKIP(0,R9)			:NORMAL RETURN FOR NO CHANNEL FOUND


::*********************************************************************
::
::	SUBROUTINE:	CNTPRT	(CouNT PoRT)
::	FUNCTION:	Counts number of available ports in a port range
::	CALLING SEQ:	JAL	R10,CNTPRT
::	INPUT:		R5	=	Beginning of range
::			R1	=	Number of ports to consider
::	OUTPUT:		R3	=	Number of available ports
::	RETURNS:	JR	R10
::
::*********************************************************************

CNTPRT	HS	0
	LIS	R3,0			:Intitialize counter
CNT00	LHL	R0,IOTAB,CHN,CHN	:Check table entry
	JNFS	CNT01			:If not empty, don't count
	AIS	R3,1			:Else equal to zero - available
CNT01	AIS	CHN,1			:Next channel
	SIS	R1,1			:Done yet?
	JGBS	CNT00			:Check again
	JR	R10			:RETURN


	SUBTTL	UTIL (ACCOUNTING)

	IF	ACCT!T2GATE!INTACC      :###EV                         !###sdw

::*********************************************************************
::
::	SUBROUTINE:	AASTRT:
::	FUNCTION:	Initiates session accounting - puts invoice 
::			number in circuit accounting block - puts
::			zeroes in count fields.
::	CALLING SEQ:	JAL  R8,AASTRT
::	INPUT:		CHN = terminating channel number
::	DESTROYED:	R3, R11, R0
::	CALLS:		JAL  R9,AAMKPT	:Make pointer to accounting block
::
::*********************************************************************

AASTRT	HS	0		:Begin accounting record
	LR	R3,CHN		:Terminating channel # (CHN is R5)
	CLHI	R3,MNACHN	:Compare with  lowest accountable chn#
	JL	AASER1		:If lower, is channel error
	CLHI	R3,MXACHN	:Compare with max  accountable channel
	JL	AASPR1		:If within, process!
AASER1	HS	0		:Circuit consistency error
:	Posssibly add some error stuff  ###ev
	JR	R8
AASPR1	HS	0		:Initiate accounting block
	SHI	R3,MNACHN	:Make accounting port index from chn #
	JAL	R9,AAMKPT	:Get FW pointer to circuit's block
GASTR1	HS	0		:Entry point for Gateway start
   IF	ACCT2
	LIS	R0,0
	STH	R0,AAIC+4,R11
    ELSE
	LI	R0,80000000
   EI		:ACCT2
	ST	R0,AAIC,R11	:Init to zeroes and acc'ting message type
   IF	ACCT2
	LIS	R0,0
	STH	R0,AAOC+4,R11
    ELSE
	LI	R0,90000000
   EI		:ACCT2
	ST	R0,AAOC,R11	:Init to zeroes and message type
   IF	ACCT2
	LH	R0,CQINV+4
	STH	R0,AAINV+4,R11
   EI	:ACCT2
	L	R0,CQINV
	ST	R0,AAINV,R11	:Store Invoice number
	JR	R8		:###wjl


::*********************************************************************
::
::	SUBROUTINE:	AAMKPT
::	FUNCTION:	Gets a fullword pointer to the accounting block
::			from the array of pointers AABPNT.
::	CALLING SEQ:	JAL	R9,AAMKPT
::	INPUT:		R3 = Terminating port index
::	OUTPUT:		R11 = Fullword pointer to accounting block
::	DESTROYED:	R3
::	RETURNS:	JR	R9
::*********************************************************************

AAMKPT	HS	0
	SLHLS	R3,2		:Make fullword index
	L	R11,AABPNT,R3	:Retrieve pointer from table
	JR	R9

	EI	:T2GATE!INTACC!ACCT                             ###EV!sdw

	IF	ACCT!INTACC     :                                       ###sdw
::*********************************************************************
::
::	SUBROUTINE:	AARDIC:
::	FUNCTION:	Receive an incremental data count into a
::			host process and accumulate it in the AAIC field
::			for that circuit's accounting block.
::	CALLING SEQ:	JAL	R8,AARDIC
::	INPUT:		R0 =  Count to accumulate in AARDIC
::			R3 =  Internal host port index
::	DESTROYED:	R0, R3, R9, R11
::	CALLS:		JAL	R9,AAMKPT
::	RETURNS:	JR	R8
::
::*********************************************************************
AARDI1	HS	0		:Entry point for adding only one char
	LIS	R0,1
AARDIC	HS	0		:Expects port index in R3
	JAL	R9,AAMKPT	:Get FW pointer to acctng block
   IF	ACCT2
	AHM	R0,AAIC+4,R11	:Low halfword first if expanded field
	JNCR	R8		:Exit if no carry
	LIS	R0,1
   EI	:ACCT2
	AM	R0,AAIC,R11	:Add to count
	JR	R8		:And return



::*********************************************************************
::
::	SUBROUTINE:	AARDOC:
::	FUNCTION:	Receive an incremental data count out of a
::			host process and accumulate it in the AAOC field
::			for that circuit's accounting block.
::	CALLING SEQ:	JAL	R8,AARDOC
::	INPUT:		R0 =  Count to accumulate in AARDOC
::			R3 =  Port index
::	DESTROYED:	R0, R3, R9, R11
::	CALLS:		JAL	R9,AAMKPT
::	RETURNS:	JR	R8
::
::*********************************************************************
AARDO1	HS	0		:Entry point for adding only one char
	LIS	R0,1
AARDOC	HS	0		:Expects port index in R3
	JAL	R9,AAMKPT	:Get FW pointer to acctng block
   IF	ACCT2
	AHM	R0,AAOC+4,R11	:Low halfword first if expanded field
	JNCR	R8		:Exit if no carry
	LIS	R0,1
   EI	:ACCT2
	AM	R0,AAOC,R11	:Add to count
	JR	R8		:And return


::**********************************************************************
::
::	SUBROUTINE:	AANCZP:
::	FUNCTION:	Receives Node Code Zap reason and sends it.
::	CALLING SEQ:	JAL	R8,AANCZP
::	INPUT:		R1 = Invoice number from CQINV
::			R0 = Logout reason, for Addendum message
::	CALLS:		JAL	R9,AAMKPT	:Make pointer to acct. blk
::			JAL	R9,AAPIR	:Provides and sends inv #
::			JAL	R9,AADNDM	:Sends Addendum to accounting
::	RETURNS:	JR	R8
::
::*********************************************************************

AANCZP	HS	0		:Receive Zap reason and process
	STM	R1,AARGSV	:Save registers here
	ST	R0,AAREAS	:Save logout reason for AADNDM
	JAL	R9,AAPIR	:Provides and sends invoice number
	L	R0,AAREAS	:Get logout reason for Adendum message
	JAL	R9,AADNDM	:Sends Addendum to accounting
	LM	R1,AARGSV	:Restore registers here
	JR	R8


::**********************************************************************
::
::	SUBROUTINE:	AARLO:
::	FUNCTION:	Receives logout reason and sends final counts.
::	CALLING SEQ:	JAL	R8,AARLO
::	INPUT:		R3 = Internal host port index
::			R0 = Logout reason, for Addendum message
::	CALLS:		JAL	R9,AAMKPT	:Make pointer to acct. blk
::			JAL	R9,AAMIR	:Sends invoice number
::			JAL	R9,AACNTS	:Sends input and output counts
::			JAL	R9,AADNDM	:Sends Addendum to accounting
::	RETURNS:	JR	R8
::
::*********************************************************************

AARLO	HS	0		:Receive logout and process
	STM	R1,AARGSV	:Save registers here
	ST	R0,AAREAS	:Save logout reason for AADNDM
	JAL	R9,AAMKPT	:Make pointer to acct. blk
	JAL	R9,AAMIR	:Sends invoice number
	JAL	R9,AACNTS	:Sends input and output counts
	LIS	R0,0		:Now to reset inv # area
   IF	ACCT2
	STH	R0,AAINV+4,R11	:Put zeroes back in inv# field
   EI	:ACCT2
	ST	R0,AAINV,R11
	L	R0,AAREAS	:Get logout reason for Adendum message
	JAL	R9,AADNDM	:Sends Addendum to accounting
	LM	R1,AARGSV	:Restore registers here
	JR	R8





::*********************************************************************
::
::	SUBROUTINE:	AAMIR:	GAMIR:
::	FUNCTION:	Makes an Invoice record and sends it if necessary
::	CALLING SEQ:	JAL	R9,AAMIR
::			JAL	R9,AAPIR	: Entry for Inv # provided
::	INPUT:		R11 = Pointer to circuit's Accounting block
::			or    R1 = Invoice number from CRQ routine
::	CALLS:		JAL	R10,SUP14A
::	RETURNS:	JR	R9	:Normal return
::			JE	R8	:ERROR -- skip accounting if
::					 inv # is zero
::	:###ev (acct2 stuff to be added)
::*********************************************************************
::Gateway requires  R10 return to  skip AASWAP
GAMIR	HS	0		:Make an Accounting Invoice record
	L	R1,AAINV,R11	:Get invoice number
	JER	R10		:Error -  Skip accounting (Gateway return)
	JFS	AAPIR
AAMIR	HS	0		:Make an Accounting Invoice record
	L	R1,AAINV,R11	:Get invoice number
        JNFS    AAPIR           :okay, do accouting
        LM      R1,AARGSV       :restore registers before returning
        JR      R8
AAPIR	ST	R9,AAR1SV	:Save return address
	C	R1,AALINS	:Compare with last inv# sent
	JER	R9		:No need to send same inv# twice
	ST	R1,AALINS	:If new, store for reference
	OI	R1,070000000	:and make a new record
	NI	R1,07FFFFFFF	:
	JAL	R10,SUP14A,,	:to send to Supervisor
	L	R9,AAR1SV	:Restore return address
	JR	R9		:  .. and return

::*********************************************************************
::
::	SUBROUTINE:	AACNTS:
::	FUNCTION:	Gets input and output counts and sends to Sup
::	CALLING SEQ:	JAL	R9,AACNTS
::	INPUT:		R11 = Pointer to circuit's accounting block
::	CALLS:		JAL	R10,SUP14A
::	RETURNS:	JR	R9
::
::*********************************************************************

AACNTS	HS	0		:Send input and ouput counts
	ST	R9,AAR1SV	:Save return register
	L	R1,AAIC,R11	:Get input count
   IF	ACCT2
	SRLS	R1,8		:Examine HO HW
	JEFS	AACNT1		:Nything there? if not skip ahead
	OI	R1,8F000000	:else build HO message
	JAL	R10,SUP14A	:and send to Sup
AACNT1	L	R1,AAIC+2,R11	:Now get low order count field
	NI	R1,00FFFFFF	:and get bits not already sent
	OI	R1,8E000000	:formulate message
   EI	:ACCT2
	JAL	R10,SUP14A,,	:and send to Sup 

	L	R1,AAOC,R11	:Get output count
   IF	ACCT2
	SRLS	R1,8		:Examine HO HW
	JEFS	AACNT2		:Nything there? if not skip ahead
	OI	R1,9F000000	:else build HO message
	JAL	R10,SUP14A,,	:and send to Sup
AACNT2	L	R1,AAOC+2,R11	:Now get low order count field
	NI	R1,00FFFFFF	:and get bits not already sent
	OI	R1,9E000000	:formulate message
   EI	:ACCT2
	JAL	R10,SUP14A,,	:and send to Sup 
	L	R9,AAR1SV	:Restore return register
	JR	R9		:and return


::*********************************************************************
::
::	SUBROUTINE:	AADNDM:
::	FUNCTION:	Sends Addendum to Accounting message
::	CALLING SEQ:	JAL	R9,AADNDM
::	INPUT:		R0 = logout reason for Addendum message
::			R11= pointer to crcuit's accounting block
::	CALLS:		JAL	R10,SUP14A,,
::	RETURNS:	JR	R9
::
::*********************************************************************

AADNDM	HS	0		:Send Addendum to Accounting
	ST	R9,AAR1SV	:Save return address
	LI	R1,0E0000000	:Load Addendum message type 
	OR	R1,R0		:Put in logout reason
	NI	R1,0F0FFFFFF	:Ensure Addendum subtype zero
	JAL	R10,SUP14A,,	:Send to Sup
	L	R9,AAR1SV	:Restore return
	JR	R9



::*********************************************************************
::
::	SUBROUTINE:	AATIME:
::	FUNCTION:	Provides periodic reporting of accounting
::	CALLING SEQ:	JAL	R11,AATIME,,
::	CALLS:		JAL	R9,AAMKPT
::			JAL	R9,AAPIR
::			JAL	R9,AACNTS
::	RETURNS:	JR	R11
::
::*********************************************************************
AATIME	HS	0			:Perform periodic accounting
	ST	R11,AAR2SV		:Save return
	LHI	R3,NACCTS-1		:R3 used for  port index
AATM01	ST	R3,AASVCT		:Got to save R3
	JAL	R9,AAMKPT		:Get pointer to accounting block
	L	R1,AAINV,R11		:Check inv # - see if active	
	JEFS	AATM02			:If inactive go to next port
	LR	R0,R1
	NI	R0,80000000		:Is high order bit set?
	JL	AATM02			:If so, skip reporting
	JAL	R9,AAPIR		:Else make invoice record
	JAL	R9,AACNTS		:  ... and send counts
AATM02	L	R3,AASVCT		:What was that count of ports?
	SHI	R3,1			:Decrement counter to nxt port ndx
	JGE	AATM01			:Repeat until port 0 completed
	L	R11,AAR2SV		:Restore return
	JR	R11

	IF	T2GATE
::*********************************************************************
::
::	SUBROUTINE:	AASWAP:
::	FUNCTION:	Swaps invoice numbers between networks
::	CALLING SEQ:	JAL	R10,AASWAP,,
::	INPUT:		CHN	=  Relative Dispatcher port to send
::			ININV	=  Invoice number from INET
::	CALLS:	AAMIR,SUP14A,DIZSMS
::	DESTROYED:	R8,R9,R1,R3,R4
::	RETURNS:
::
::*********************************************************************

AASWAP	HS	0
	ST	R10,AAR2SV		:SAVE RETURN
        SHI     CHN,DISZFL
        STH     CHN,GDB7L               :SAVE CHN
        ahi     chn,diszfl              :restore for upcoming routines
:	SEND DATA TO HNET
	JAL	R9,GAMIR		:SEND INVOICE RECORD
	L	R1,ININV		:GET PRIMARY INVOICE#
	OI	R1,0E9000000		:ADD ACCT MSG TYPE
	JAL	R10,SUP14A,,		:Send to HNET sup
:	NOW SEND DATA TO INET
	L	R4,AAINV,R11		:GET SECONDARY NET INVOICE#
	OI	R4,0E9000000		:ADD MSG TYPE
	ST	R4,GB7INV		:STORE IN CANNED MSG
	LA	R1,GDB7M		:ADDR OF CANNED MSG
	LHI	R3,GDB7L
	LHL	CHN,GB7PRT		:for insertion into message
	JAL	R8,DIZSMS,,		:Output to dispatcher
	L	R10,AAR2SV		:RESTORE RETURN
	JR	R10			:RETURN
	EI	:T2GATE	

        ELSE    :not ACCT!INTACC

:       Gateway has numerous calls to accounting not under the ACCT switch.
:       provide a null routine to prevent assembly errors               ###sdw
AARLO
AARDIC  JR      R8                      :nothing to do when no accouting

	EI	:ACCT!INTACC  		###EV

        SUBTTL X.409 UTILITY ROUTINES
       IF       LOGII

::*****************************************************************
::
::      X4GTLN  Get x.409 length.  Return it in R0.  caller should
::              make sure R3 points to a length field.  
::
::              Links on R9.  Calls IGPCIE.
::
::*****************************************************************

X4GTLN  ST      R9,GTLNSV               :save link reg
        LIS     R0,0                    :clear it for ORing
X4GTL0  JAL     R9,IGPCIE,,             :get first byte of len
        CLHI    R1,MO.LFM+1             :more to follow?
        JLFS    X4GTL2                  :done (have len byte)
        JEFS    X4GTL1                  :short form (just a byte of length)
        JAL     R9,IGPCIE,,             :do two len bytes
        EXBR    R0,R1                   :move len to high byte
X4GTL1  JAL     R9,IGPCIE,,             :last byte of len
X4GTL2  OR      R0,R1                   :make it len field
        L       R9,GTLNSV
        JR      R9



::***************************************************
:
:       X4WTEL  writes element pointed to by R6 from the parse table
:               to buffer in R2.  Links on R9.
::***************************************************

X4WTEL  ST      R7,X4WTSV               :save link register
        LB      R1,X4T.ID,R6            :get ID
        LB      R0,X4T.AP,R6            :get application/constructor bits
        CLHI    R1,IDBITS               :one or two byte header
        JLFS    X4WTE2
        EXBR    R0,R0                   :move bits to high byte
        AHI     R0,IDBITS^8             :add in two byte indicator
        AR      R1,R0                   :add to ID
        JAL     R9,W2CI,,
        AIS     R10,2                   :count of written chars
        JFS     X4WTE3
X4WTE2  AR      R1,R0                   :add in bits
        JAL     R9,WCIE,,
        AIS     R10,1                   :count of written chars
X4WTE3  LHL     R4,X4T.LN,R6            :get len of MO
        AR      R10,R4
        AIS     R10,1                   :min len of len
        CLHI    R4,80
        JLFS    X4WTE4
        AIS     R10,1                   :min len of len is now 2
        CLHI    R4,100                  :two byte long form?
        JLFS    X4WTE4
        AIS     R10,1
X4WTE4  JAL     R9,X4BWLN               :write len to buffer
        LR      R7,R4                   :null element?
        JEFS    X4WTEX                  :if yes then no data to copy
        L       R4,X4T.DB,R6            :where data begins
X4WTE6  JAL     R9,PCIER4               :PCIE that uses R4 instead of R3
        JAL     R9,WCIE,,
        SIS     R7,1
        JGBS    X4WTE6
X4WTEX  L       R7,X4WTSV
        JR      R7                      :done

PCIER4  JAL     R8,PCIR4
        LR      R1,R1
        JNR     R9
        JAL     R8,PCIR4
        JR      R9

PCIR4   LB      R1,0,R4                 :get char
        AIS     R4,1
        THI     R4,CBSZ-1               :at end of bflet?
        JNR     R8
        LHL     R4,0,R4                 :get next bflet
        SLLS    R4,CBSZL
        ais     R4,cbptsz
        JR      R8

::*************************************************
:
:       X4GTNM  gets R0 bytes and gets it as a number (right justified)
:               returns number in r4.  links on r7, trashes r0,r1,r8,r9
::*************************************************

X4GTNM  LIS     R4,0
X4GTN1  SLLS    R4,8                    :move current over a byte
        JAL     R9,IGPCIE,,             :get first byte of number
        AR      R4,R1
        SIS     R0,1
        JGBS    X4GTN1
        JR      R7


::*****************************************************************
::
::      X4PARS  Parse X.409.  Searchs from current R3 bufadr to
::              the end of the first element.  Thus, R3 should point
::              to a constructor or this is a waste.  Creates a table
::              of parsed elements indexed by R6.  Table contains all
::              elements upto and including the found element.
::
::              Link on R7.  Trashes R0, R1, R8, R9.  R3 points to
::              data after length.  R0 has the length.  R6 points to
::              table containing ID, len, address, relative position
::              and the application/constructor bits.
::              Note: that IDs 10,11 are parsed for being application
::              IDs and not universal.  Thus, it cannot find the RMO or
::              SMO ids, but it can find the ID.NNL (app MO-11).
::*****************************************************************

X4PARS  LIS     R0,0
        ST      R0,X4TBPT               :init pointer
        STH     R0,ELEDIS               :first element has pos 0
        LA      R6,X4TBBG,,             :address of start fo table
        ST      R3,ELEPOS               :Tell X4NEXT where to begin
X4PRS0  ST      R3,X4T.BB,R6            :put address in table
        LHL     R0,ELEDIS               :dis from start of ID
        STH     R0,X4T.DI,R6            :Distance of Id
        JAL     R9,X4NXID               :get the next ID and length
        STH     R0,X4T.LN,R6            :save the length
        LHL     R1,ELEDIS               :save the displacement into table
        STH     R1,X4T.DD,R6            :dis from start of data (this+len=nxtid
        L       R1,X4NXVL               :get bits, ID, LEN
        ST      R1,X4T.AP,R6            :store bits, ID, LEN
        ST      R3,X4T.DB,R6            :address within Buffer of ele's Data
        L       R1,X4NXVL+4             :address within Buffer of ele's Length
        ST      R1,X4T.LB,R6
        ST      R6,X4TBPT               :pointer to deepest element read
        LB      R1,X4NXVL+1             :get the ID
        CR      R4,R1                   :match the ID looking for?
        JNFS    X4PRS1                  :not a match
        LHI     R1,MO.C                 :make sure it isn't a universal constr
        CLB     R1,X4T.AP,R6
        JN      4,R7                    :a smo or rmo

X4PRS1  JAL     R9,X4NXEL               :get next element
        ST      R3,X4T.EB,R6            :address of end of element
        LHL     R1,ELEDIS               :end of this constructor?
        SH      R1,X4TBBG+X4T.LN,,      :length of this construction
        SH      R1,X4TBBG+X4T.DD,,      :and dis to the above len
        JGEFS   X4PRS4                  :done if cur pos > length of constr
        CI      R6,X4TBEN               :end of table?
        JE      X4PRS0                  :last entry in full table is for cur ID
        AHI     R6,X4TBSZ
        J       X4PRS0                  :next table entry for next MO

X4PRS4  SKIP(0,R7)

::*****************************************************************
::
::      X4PARC  Same function as X4PARS except it checks the table entries
::              before continuing search.
::
::*****************************************************************

X4PARC  LA      R6,X4TBBG,,             :get address of beginning of table
        C       R6,X4TBPT               :compare to pointer
        JG      X4PARS                  :no table entries, do parse from scratch
X4PRC1  CLB     R4,X4T.ID,R6            :this ID what we looking for?
        JNFS    X4PRC3
        LHI     R1,MO.C
        CLB     R1,X4T.AP,R6            :make sure not RMO/SMO
        JEFS    X4PRC3                  :(they have same ID as ID.NNL & ID.REV)
        L       R3,X4T.DB,R6            :get R3 (address of data)
        LHL     R0,X4T.LN,R6            :get length
        J       4,R7                    :found match in table

X4PRC3  AHI     R6,X4TBSZ               :next entry in table
        C       R6,X4TBPT               :compare to present pointer
        JLE     X4PRC1                  :next entry in tble
        SHI     R6,X4TBSZ
        LHL     R3,X4T.LN,R6            :don't continue if constructor
        AH      R3,X4T.DD,R6            :is fully parsed in table
        SH      R3,X4TBBG+X4T.LN,,      :R3 had pos of end of last element
        SH      R3,X4TBBG+X4T.DD,,      :and subtracting pos of end of constr
        JLFS    X4PRC5
        SKIP(0,R7)                      :last element already in table
X4PRC5  L       R3,X4T.DB,R6            :and be setup for normal parse logic
        J       X4PRS1                  :and continue with normal parse logic

::*****************************************************************
::
::      X4NXID  it and X4NXEL are like bookends.  X4NXID gets the ID and
::              length and stores it.  X4NXEL takes this info and finds the
::              next potentially interesting MO.
::
::*****************************************************************

X4INUN  HC      0,0C000,0,0             :look inside SET and SEQUENCE constr
X4INAP  HC      4000                    :these appl constructor MOs have
        HC      0005                    :other MOs which we are to look at
        HC      2020                    :id.nch id.ccn
        HC      2AB8                    :id.dis and the xCRI, xCRM, ICRS series
        HC      8000                    :ID.NDT  40-4F
        HC      0,0,0,0,0,0,0,0,0,0     :no other appl constructors known

X4NXID  ST      R9,X4NXSV               :save link reg
        L       R3,ELEPOS               :start from where X4NXEL left off
        JAL     R9,IGPCIE,,             :get ID
        LR      R0,R1                   :save high bits
        NHI     R1,IDBITS               :get ID bits
        CLHI    R1,1F                   :ID here or in next
        JLFS    X4NXI1                  :>1f means ID is next char
        JAL     R9,IGPCIE,,             :get the ID
X4NXI1  NHI     R0,@IDBITS              :make it only application bits
        STB     R0,X4NXVL
        STB     R1,X4NXVL+1             :store the bits and ID
        ST      R3,X4NXVL+4             :save address of length
        JAL     R9,X4GTLN               :get the length field
        STH     R0,X4NXVL+2             :and save length
        ST      R3,ELEPOS               :tell X4NXEL where we left off
        L       R9,X4NXSV
        JR      R9

X4NXEL  ST      R9,X4NXSV               :save our link reg
        L       R3,ELEPOS               :take up where X4NXID left off
        LB      R1,X4NXVL               :get appl bits
        THI     R1,MO.C                 :is this a constructor?
        JN      X4NXE3                  :check if we care about dis one
X4NXE0  LHL     R0,X4NXVL+2             :get len of curr ele
X4NXE1  SIS     R0,1                    :read that many and to get to next ele
        JLFS    X4NXE2                  :and done
        JAL     R9,IGPCIE,,
        JBS     X4NXE1

X4NXE2  ST      R3,ELEPOS               :tell X4NXID where we left off
        L       R9,X4NXSV
        JR      R9

X4NXE3  LB      R0,X4NXVL+1             :get ID back
        THI     R1,MO.A                 :40 is application MOs
        JEFS    X4NXE4                  :some universal MO
        TBT     R0,X4INAP               :interesting application?
        JN      X4NXE2                  :yes, let X4PARS find MOs
        J       X4NXE0                  :no gobble entire construction
X4NXE4  TBT     R0,X4INUN               :univ constr contain interesting MOs?
        JN      X4NXE2                  :yes
        J       X4NXE0

::*****************************************************************
:
:       X4CRIZ  initialize X.409 MO creation table.  The table
:               has the ID with header bits, data length, length
:               of header (len of len and ID) and a word of data.
:               The word of data either contains the MO data or the
:               address of the data (either in bufferlets or normal).
:
::*****************************************************************

X4CRIZ  LA      R6,X4CTBG-X4CTSZ,,      :pointer when table empty
        ST      R6,X4CPTR               :save create table's pointer
        LHI     R1,X4CTSZ*X4NENT-4      :all of table
        LIS     R0,0
X4CRZ1  ST      R0,X4CTBG,R1,
        SIS     R1,4
        JGBS    X4CRZ1
        JR      R8

::*****************************************************************
:
:       X4CRID  X.409 create MO from Register.  ID in R4, R1 has
:               data.  Length is calculated from how many leading
:               zeros in R1.  R1 is corrupted (shifted left).
::*****************************************************************

X4CRID  L       R6,X4CPTR       :get pointer into create table
        AIS     R6,X4CTSZ       :get next entry
        ST      R6,X4CPTR       :save new entry pointer
        LIS     R0,4            :max number of bytes in a register
X4CRI2  TI      R1,0FF000000    :high byte nonzero?
        JNFS    X4CRI4          :yes, save len
        SLLS    R1,8            :try next byte in r1
        SIS     R0,1            :len is also shorter
        JGBS    X4CRI2
        LIS     R0,1            :if r1=0 then still have len 1
X4CRI4  STH     R0,X4CLEN,R6    :save len of this element
        STH     R4,X4CID,R6     :Save ID of this element
        ST      R1,X4CDTA,R6    :save the data for this element
        LIS     R4,X4C.DT       :indicate that the data is in table
X4CRI6  STB     R4,X4CFLG,R6    :save what type is in data field
        LIS     R0,2            :min len of len and ID
        LHI     R4,100
        CLH     R4,X4CID,R6     :one or two byte ID
        JGFS    X4CRI7          :one byte
        AIS     R0,1            :Id took two bytes
X4CRI7  CLH     R4,X4CLEN,R6    :one or two bytes of len
        JGFS    X4CRI8
        AIS     R0,2
        JFS     X4CRI9
X4CRI8  SRHLS   R4,1            :len >=80
        CLH     R4,X4CLEN,R6
        JGFS    X4CRI9
        AIS     R0,1
X4CRI9  STB     R0,X4CHLN,R6    :save len of header
        JR      R8

::*****************************************************************
:
:       X4CMID  put entry into MO create table.  r4 has ID.  R0 has
:               length of data.  R1 has address where data begins.
:               The actual address used is after leading zeros are
:               skipped over.
::*****************************************************************

X4CMID  L       R6,X4CPTR       :get pointer into create table
        AIS     R6,X4CTSZ       :get next entry
        ST      R6,X4CPTR       :save new entry pointer
        STH     R4,X4CID,R6     :save ID
X4CMI1  LB      R4,0,R1         :skip over leading zeros
        JNFS    X4CMI2
        AIS     R1,1
        SIS     R0,1            :len is shorter too
        JGBS    X4CMI1
        ST      R4,X4CDTA,R6    :store zero as data
        LIS     R0,1
        STH     R0,X4CLEN,R6
        J       X4CRI6          :finish as a register create element
X4CMI2  STH     R0,X4CLEN,R6    :save len
        ST      R1,X4CDTA,R6    :save address of data
        LIS     R4,X4C.MM       :mark that data is in memory
        J       X4CRI6

::*****************************************************************
:
:       X4CBOL  create true boolean element.  preprocessor for
:               X4CBOL.  Link on R8. trash r0,r1,r3
:
::*****************************************************************

X4CBOL  LA      R1,X4CBOV       :load address of FF
        LIS     R0,1            :length of 1
        J       X4CMID

X4CBOV  HC      -1              :FF for boolean element



::*****************************************************************
:
:       X4CBID  Address of data is in bufferlets.  R4 is ID.
:               R3 is address in buffers.  R0 is len.  Data is
:               NOT checked for leading zeros.
:
::*****************************************************************

X4CBID  L       R6,X4CPTR       :get pointer into create table
        AIS     R6,X4CTSZ       :get next entry
        ST      R6,X4CPTR       :save new entry pointer
        STH     R4,X4CID,R6
        ST      R3,X4CDTA,R6
        STH     R0,X4CLEN,R6
        LIS     R4,X4C.BF       :mark that data is address into bufflet
        J       X4CRI6

::*****************************************************************
:
:       X4CCID  create entry for constructor.  R4 has ID.  Everything
:               else (ie len) will be calculated later
::*****************************************************************

X4CCID  L       R6,X4CPTR       :get pointer into create table
        AIS     R6,X4CTSZ       :get next entry
        ST      R6,X4CPTR       :save new entry pointer
        STH     R4,X4CID,R6     :save ID
        LIS     R4,X4C.UC       :mark as unfinished constructor
        STB     R4,X4CFLG,R6    :mark this is a constructor
        JR      R8

::*****************************************************************
:
:       X4CNUL  create entry for null element (len of 0)
::*****************************************************************

X4CNUL  L       R6,X4CPTR       :get pointer into create table
        AIS     R6,X4CTSZ       :get next entry
        ST      R6,X4CPTR       :save new entry pointer
        STH     R4,X4CID,R6
        LIS     R4,0
        STH     R4,X4CLEN,R6
        J       X4CRI6          :finish off with header

::*****************************************************************
:
:       X4FXCN  finish constructor.  Link on R8.
:               The constructor is considerred to be from the end
:               back to the last unfinished constructor
::*****************************************************************

X4FXCN  LIS     R0,0            :len of constructor
        L       R6,X4CPTR       :last entry in table
        LIS     R1,1            :bit if unfinished constructor
X4FXC1  CLB     R1,X4CFLG,R6    :is this the unfini construct
        JE      X4FXC7          :yes, prepare for exi
        LB      R4,X4CHLN,R6    :add in len of len and id
        AR      R0,R4
        LB      R4,X4CFLG,R6    :test if finished con (don't do its len)
        THI     R4,X4C.CC       :completed constructor?
        JNFS    X4FXC2
        AH      R0,X4CLEN,R6    :add in len of element
X4FXC2  SIS     R6,X4CTSZ       :back upto previous element
        CI      R6,X4CTBG       :end of table?
        JGE     X4FXC1
        JR      R8              :done with no constructor found
X4FXC7  STH     R0,X4CLEN,R6    :save len
        LIS     R4,X4C.CC       :mark as finished constructor
        J       X4CRI6          :do len of len and id (mark if fini con also)

::*****************************************************************
:
:       X4CDWR  write MOs in table into dispatcher.  Link on R8
:               r0, r1, r3, r4 ,r9 trashed.
::*****************************************************************

       IF       1-NCSLOT

X4CDWR  ST      R8,X4CWSV
        LA      R6,X4CTBG,,     :start of table
X4CDW1  LHL     R1,X4CID,R6     :get id
        THI     R1,0FF00        :two byte id?
        JEFS    X4CDW2
        EXBR    R1,R1
        JAL     R8,X4DWCH,,     :write char to dispi
        EXBR    R1,R1           :back to low byte
X4CDW2  JAL     R8,X4DWCH,,     :write ID
        LHL     R4,X4CLEN,R6    :get len
        JAL     R9,X4DWLN,,     :write len to dispi
        LB      R1,X4CFLG,R6    :where is our data?
        JNFS    X4CDW4          :if 0 then in data field
        LIS     R3,0
X4CDW3  SIS     R4,1
        JL      X4CDW9          :all data copied (handle null element too)
        LB      R1,X4CDTA,R6,R3 :data byte
        JAL     R8,X4DWCH,,     :write to dispi
        AIS     R3,1
        JBS     X4CDW3

X4CDW4  THI     R1,X4C.CC       :finished constructor?
        JN      X4CDW9          :it's data is other entries
        THI     R1,X4C.BF       :data in buffer?
        JN      X4CDW7
        THI     R1,X4C.MM
        JE      X4CDW9          :only other legal is data in memory
        L       R3,X4CDTA,R6    :get address of data
        LIS     R4,0            :offset into data
X4CDW5  CLH     R4,X4CLEN,R6    :done?
        JGE     X4CDW9          :done with element
        LB      R1,0,R3,R4      :get data byte
        JAL     R8,X4DWCH,,
        AIS     R4,1
        JBS     X4CDW5

X4CDW7  LIS     R4,0            :count of how many read
        L       R3,X4CDTA,R6
X4CDW8  CLH     R4,X4CLEN,R6    :done?
        JGE     X4CDW9
        JAL     R8,PCI,,        :ignore signals
        CLHI    R1,7
        JG      X4CD12
        CLHI    R1,4
        JGE     X4CDW8          :signal 4-7 are one byte long
        LR      R1,R1
        JEFS    X4CD11
        JAL     R8,PCI,,
        J       X4CDW8          :two byte signal
X4CD11  JAL     R8,PCI,,
X4CD12  JAL     R8,X4DWCH,,     :write char from buffer to dispi
        AIS     R4,1
        J       X4CDW8
X4CDW9  AIS     R6,X4CTSZ       :do next entry
        C       R6,X4CPTR       :completely done?
        JLE     X4CDW1          :do element
        L       R8,X4CWSV       :get back link
        JR      R8

       EI       :1-NCSLOT

::*********************************************************************
::
::	SUBROUTINE:     X4BWLN
::	FUNCTION:       write number in R4 as len into buffer in R2
::	CALLING SEQ:    link on R9
::	INPUT:          R2, R4
::      DESTROYED:      R0, R1, R3, R8
::
::*********************************************************************


X4BWLN  ST      R9,GTLNSV               :save link register
        CLHI    R4,MO.LFM-1             :short form?
        JLE     X4BWL6                  :yes, short form
        CLHI    R4,100                  :one or two bytes of long form
        JGEFS   X4BWL2                  :long long form
        LHI     R1,MO.LFM+1
        JAL     R8,WCI,,
        JFS     X4BWL6
X4BWL2  LHI     R1,MO.LFM+2             :two byte of long form
        JAL     R8,WCI,,
        EXBR    R1,R4                   :write high byte first
        JAL     R9,WCIE,,
X4BWL6  LR      R1,R4                   :last byte of length
        JAL     R9,WCIE,,
        L       R9,GTLNSV               :retrieve link reg
        JR      R9


::*****************************************************************
:
:       X4CBWR  writes MOs enterred in MO creation table.  link on r8
:               trash r0,r1,r3,r4,r6,r9
::*****************************************************************

X4CBWR  ST      R8,X4CWSV       :save link reg
        ST      R5,X4CWS1       :save a scratch reg
        LA      R6,X4CTBG,,     :start of table
X4CBW1  LHL     R1,X4CID,R6     :get id
        THI     R1,0FF00        :two byte id?
        JEFS    X4CBW2
        EXBR    R1,R1
        JAL     R9,WCIE,,       :write char to buffer
        EXBR    R1,R1           :back to low byte
X4CBW2  JAL     R9,WCIE,,       :write ID
        LHL     R4,X4CLEN,R6    :get len
        JAL     R9,X4BWLN       :write len to buffer
        LB      R1,X4CFLG,R6    :where is our data?
        JNFS    X4CBW4          :if 0 then in data field
        LIS     R5,0
X4CBW3  SIS     R4,1
        JL      X4CBW9          :all data copied (handle null element too)
        LB      R1,X4CDTA,R6,R5 :data byte
        JAL     R9,WCIE,,       :write to buffer
        AIS     R5,1
        JBS     X4CBW3

X4CBW4  THI     R1,X4C.CC       :finished constructor?
        JN      X4CBW9          :it's data is other entries
        THI     R1,X4C.BF       :data in buffer?
        JN      X4CBW7
        THI     R1,X4C.MM       :data in memory
        JE      X4CBW9          :only other legal is data in memory
        L       R5,X4CDTA,R6    :get address of data
        LIS     R4,0            :offset into data
X4CBW5  CLH     R4,X4CLEN,R6    :done?
        JGE     X4CBW9          :done with element
        LB      R1,0,R4,R5      :get data byte
        JAL     R9,WCIE,,
        AIS     R4,1
        JBS     X4CBW5

X4CBW7  LIS     R5,0            :count of how many read
        L       R4,X4CDTA,R6
X4CBW8  CLH     R5,X4CLEN,R6    :done?
        JGE     X4CBW9
        JAL     R8,PCIR4,,      :ignore signals
        CLHI    R1,7
        JG      X4CB12
        CLHI    R1,4
        JGE     X4CBW8          :signal 4-7 are one byte long
        LR      R1,R1
        JEFS    X4CB11
        JAL     R8,PCIR4,,
        J       X4CBW8          :two byte signal
X4CB11  JAL     R8,PCIR4,,
X4CB12  JAL     R9,WCIE,,       :write char from buffer to buffer
        AIS     R5,1
        J       X4CBW8
X4CBW9  AIS     R6,X4CTSZ       :do next entry
        C       R6,X4CPTR       :completely done?
        JLE     X4CBW1          :do element
        L       R5,X4CWS1       :restore scratched reg
        L       R8,X4CWSV       :get back link
        JR      R8



       EI       :LOGII

	ENDMO.(UTIL)
	EI	:1-KILLIT
	KILMSG(UTIL)

:	***NOTHING PAST THIS POINT***


        SUBTTL GATWAY (Gateway Dispatcher routines)

:       ****     *    ***** *   *    *    *   *
:      *        * *     *   *   *   * *    * *
:      *  **   *****    *   *   *  *****    *
:      *   *   *   *    *   * * *  *   *    *
:       ****   *   *    *    * *   *   *    *

::####################################################################
::
::	MODULE:		GATWAY
::
::	SUBTTLS:
::		GATWAY (Gateway Dispatcher routines)
::		GATWAY (RCRINC Node Code generated Log2 Logon Failures)
::		GATWAY (Logon successfully built to HNET)
::
::####################################################################

        IF      1-KILLIT
        BEGMO.
        SEG  1

::*********************************************************************
::
::		Miscellaneous Gateway Utility routines
::		GDOMES:	GBYHOM:
::
::*********************************************************************

CRLF    SC      /"8D"8A/                :redefined to avoid needless RX3s

	IF	T2GATE
GDOMES	HS	0
	LR	R1,R1
GDOM1	JE	GDOM8
	JAL	R8,WCI,,
	SRHLS	R1,8
	JBS	GDOM1
GDOM8	JR	R9

::********************

GBYHOM	HS	0
	ST	R8,GDSAVE		:Save return 
	TBT	CHN,GORGPT		:Should be destination
	JE	GBYSKP			:from terminal and
	TBT	CHN,LOGING		:not in log-in mode and
	JN	GBYSKP			:not a transparent circuit
	TBT	CHN,GTTRNS		:if we're going to send the
	JN	GBYSKP			:"inter-link cleared" message
	LA	R4,GNGONE,,		:back to the terminal
	JAL	R9,BUFCAN,,
	ROUTE(HOMEN,ISISN)
	LA	R4,CRLF
	JAL	R9,BUFCAN,,
	L	R8,GDSAVE
GBYSKP	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	GSOZW7:
::	FUNCTION:	DETACH CIRCUIT.
::	REMOVE DISPATCHER PERMUTER TABLE ENTRY FROM DIOTAB,
::	FIND AVAILABLE CHANNEL TO DISPATCH PROCESS IN CIOTAB (STARTING WITH
::	DETZFL). CONNECT NETWORK HALF-CIRCUIT TO DETACH PROCESS FOR SENDING
::	APPROPRIATE TEXT TO USER, BOUNCING YELLOW BALL, AND TIMING OUT CIRCUIT
::	IF NO ORANGE BALL RETURNED.
::
::*********************************************************************

GSOZW7	HS	0			:DONE WITH ACCT. DETACH PORT
	LHL	R2,DIOTAB,R4,R4		:GET EXISTING PERMUTER TABLE ENTRY TO
	NHI	R2,-4			: MOVE TO CIOTAB.
:	FIND NEXT AVAILABLE CHANNEL TO DETACH PROCESS...
       IF       t2gate                  :gateway has a no message option
        lis     r3,8
        tbt     chn,gttrns
        jefs    gsozp1
        lcs     r3,1
gsozp1
       ei       :t2gate
	L	R4,DETACP,,		:DETACH PORT AVAILABLE ?
	JFFO	R4,GSOZW8		:FOUND ONE
	J	4,R10			:NO DETACH PORTS, ZAP CIRC TO NETWORK

GSOZW8	HS	0
:	CAUSE ZAPX TO PUT CR/LF INTO BUFFER INSTEAD OF ZAPPER. THIS WILL
:	CAUSE DISPATCHER PORT TO BE FREED UP WITHOUT ZAPPING EXISTING CIRCUIT.
	LHI	R1,0D0A			:MAKE ZAPX PUT 'CRLF' INTO BUFFER
       if       t2gate
        stb     r3,detmty,chn
       else     :normal
	LIS	R0,8			:Load "inter-link cleared" message
	STB	R0,DETMTY,CHN		:and store for Detatch process
       ei       :t2gate
	JAL	R9,ZAPX			:'ZAP' THE DISPI SIDE OF CIR.
	AHI	CHN,DETZFL		:CONVERT TO ABSOLUTE CHANNEL NUMBER AND
	JAL	R9,CRQHCR		:BUILD 2ND HALF OF CKT TO DETACH PROCES

:	SEND NEEDLE POINT TO DETACH PROCESS TO ALERT IT TO NEW PORT.
	XHI	R2,4			:INDEX FOR BUFF TOWARDS DETACH PROCESS
	LIS	R1,3
	JAL	R8,WCI,,
	LHI	R1,NEEDP
	JAL	R8,WCI,,		:WRITE NEEDLE POINT IN BUFFER
        SHI     CHN,DETZFL              :restore channel number		 ##sdw
	SKIP(0,R10)			:IMMEDIATE RETURN - CONTINUE	###wjl





::*********************************************************************
::
::	POINT OF DEPARTURE:	GDB2:	Gateway Dispatcher B2 Message	
::	FUNCTION:		Gateway gets a B2 (pseudo needle) on
::			CHN in response to a request for a Log-in.  It
::			sets up the buffer and arrays with given CHN, and
::			if transparent log-on will send username in B3
::			messages  to dispatcher
::	CALLING SEQ:	Jump to from DISKIP.  for Gateway only.
::	INPUT:		CHN	=  relative dispatcher port number
::			PRD	=  pointer to message in ISIS ring 
::			R2	=  buffer number gotten from the Local Key
::				   field in B2.  Must be in Log-on state. 
::	CALLS:		JAL	R8,GCI
::			JAL	R9,GHWI
::			JAL	R9,AAMKPT
::			JAL	R8,WLOCDR
::			JAL	R9,BUFCAN,,
::			JAL	R9,ZAPV1
::	RETURNS:	Jumps directly to DSOIRP to continue Dispatcher  pro.
::
::*********************************************************************

:       Little routine for LOG I and LOG II gateway to setup chn
GDB2FG	LHL	R0,BF,R2,	:Now get Flag pointer for this buffer
	CLHI	R0,LOGMAX	:Should be marked as a Log-in buffer
	JG	DSOCRH,,
	CLHI	R0,LOGMIN
	JL	DSOCRH,,
::                      We are in Log-in mode.  Is there really a circuit?
	XHI	R2,4
	LHL	R0,BF,R2,	:Get Hnet channel number
	JLE	DSOIRP,,	:If dead, just flush this
	XHI	R2,4		:Return to F.T. buffer
	LHI	R0,LGSNT.	:Mark as TID accepted by Sup
	STH	R0,BF,R2,	:for future processing / timeout
	SBT	CHN,LOGING
	SBT	CHN,GDSTPT	:This is a circuit destination.
	RBT	CHN,GORGPT
	SBT	CHN,DISBPV	:Relieve backpressure
	SBT	CHN,DISBPX	:and we haven't BPed mr dispatcher
	SBT	CHN,LOGDAT	:allow log-on processing to begin
	SBT	CHN,GLGDAT	:first delimiter not yet sent
::                      Initialize the rest of the arrays
	RBT	CHN,GTAUX
	RBT	CHN,GTHDX
	SBT	CHN,GTASCI
	SBT	CHN,GTECHO
	SBT	CHN,GTLGEC
	RBT	CHN,GTTRNS
	RBT	CHN,GIIXCT
	LIS	R0,0
	STB	R0,GLGCNT,CHN,	:Init logon character counter

::                      Install a scratch table entry for future reference
	STH	R2,GDLGTB,CHN,CHN	:and store it in our scratch table

::              Connect dispatcher port IOTAB to outbound (to terminal) buffer
::      We mark the IOTAB so that our CHN will not be selected for another
::      circuit.  We must keep track of login and complete circuit.
	AHI	CHN,DISZFL	:Make absolute channel number
	XHI	R2,4		:flip to outbound buffer #
	STH	R2,IOTAB,CHN,CHN	:chan marked as in use
	RBT	CHN,ACP,,	:Reset ACP bits
	LCS	R0,1
	SR	R0,CHN
	RBT	R0,ACP,,
        SHI     CHN,DISZFL              :back to disp chn number
::                      Turn on output to the Network
	LHL	R3,BF,R2,		:Get the channel number
	SBT	R3,BPSVCP-LNKZFL/8,,	:Enable RMAKE service of this channel
	SBT	R3,LNKBPV-LNKZFL/8,,
	RBT	R3,PRIRTY-LNKZFL/8,,
	RBT	R3,CMDCTS-LNKZFL/8,,
        lhi     r1,200
        sth     r1,bpscnt-2*lnkzfl,r3,r3
	XHI	R2,4		:Now get from terminal buffer 
	LHI	R0,INXLIM
	STH	R0,DIXLIM,CHN,CHN	:7/29/86	###EV
        JR      R8              :done with setup

::*****************************************************************
:       the actual GDB2 routine
::*****************************************************************

GDB2	HS	0		:Gateway handler for Pseudo Needle (type B2)
	AIS	PRD,4
	NR	PRD,TC		:Advance pointer to Local Key
	LHL	R2,DORNG,PRD,	:Get Local Key
	AIS	PRD,2
	NR	PRD,TC		:Fix up pointer
        JAL     R8,GDB2FG       :initialize flags for chn and build circuit
       IF       LOGII
        RBT     CHN,DISLG2      :not a LOG II login
       EI       :LOGII
::              Now get items of information from our still intact Needle.
	JAL	R8,GCI,,	:Skip Needle point
	JAL	R8,GCI,,
	JAL	R8,GCI,,		:Get length of Needle
	JAL	R8,GCI,,
	STB	R1,GDNLEN	:and store for possible flush
	JAL	R8,GCI,,	:Skip escape
	JAL	R8,GCI,,	:Read link count and toss
	JAL	R9,GHWI,,	:Get 2 bytes of Invoice number
	STH	R1,GDNINV
	JAL	R9,GHWI,,	:Get remaining two
	STH	R1,GDNINV+2	:Store the Invoice Number
        AHI     CHN,DISZFL      :make real for accounting
::      Time to initialize the accounting block for this circuit termination
	LIS	R1,1
	AHM	R1,NC.CRC	:Count circuit completion for CRQ
	JAL	R8,AASTRT
GDB205	SHI	CHN,DISZFL	:Restore relative dispatcher port number
::      Now get Needle Flags field and store for possible future use
	JAL	R9,GHWI,,
	STH	R1,GDFLGS
	THI	R1,NF.SMC	:If IIX circuit - mark as such
	JE	GDB215
	SBT	CHN,GIIXCT
GDB215	NHI	R1,030		:Get speed bits
	SRHLS	R1,4		:Put in low order nibble
	STB	R1,GDSPED	:and store for later
	JAL	R9,GHWI,,	:Skip origin node
	JAL	R9,GHWI,,	:Skip origin port
::      Now toss the node list
GDB206	JAL	R9,GHWI,,
	CI	R1,0FFFF
	JEBS	GDB206
	TI	R1,8000
	JN	GDB207		:At end of node list - proceed
	J	GDZAP		:Some error - Zap both sides of circuit
::      Get User Flags field and examine username
GDB207	HS	0
	JAL	R9,GHWI,,	:User flags
	STH	R1,GDUSRF	:Store temporarily
	SRLS	R1,8		:Get rid of extra bits
	NHI	R1,1F		:Get the CCT itself
	LBR	R1,R1
	JE	GDBAUX		:Aux circuit if CCT is 0
	THI	R1,20		:Test Half Duplex bit
	JEFS	GDB208		:No
	SBT	CHN,GTHDX	:Else set as Half duplex
	RBT	CHN,GTECHO	:No echo for Half duplex terminals
::                      Test for 2741 terminal type
GDB208	SIS	R1,8
	JL	GDB209
	SIS	R1,9-8
	JGEFS	GDB209
	SBT	CHN,GTHDX	:Yes this is a 2741 type
	RBT	CHN,GTECHO	:No echo for this terminal
	RBT	CHN,GTASCI	:Special distinction as HDX Ascii
	JFS	GDB209
GDBAUX	SBT	CHN,GTAUX	:Marker as an Auxilliary circuit
	RBT	CHN,GTECHO	:No echo for Aux circuits	###per Kopfj
                                :the ###per KOPFj refers that it was commented
                                :out to allow echoing of username for aux cirs.
                                :that prevent loadii from working.  maybe later
                                :##### sdw
GDB209	JAL	R9,GHWI,,	:Pass requesting host
::                      Now check for Transparent Log-on
	JAL	R8,GCI,,	:First username character
	CLHI	R1,GXPRNT	:Is it a "?" ..? (transparent indicator)
	JN	GDB216		:No - flush username and proceed
::                      Transparent user - set up appropriately
	SBT	CHN,GTTRNS	:Set Transparent circuit flag
	TBT	CHN,GTHDX	:Is this a HDX circuit?
	JEFS	GDB210		:NO
	LHI	R1,0B308	:Set up for Log-on character
	JAL	R8,DIRMES,,	:and send to dispatcher
GDB210	LB	R1,GDSPED	:Get throughput class
	LB	R1,TPTBL,R1	:Get control character from table
	LHI	R0,0B3
	EXBR	R0,R0
	AR	R1,R0		:Make B3 message
	JAL	R8,DIRMES,,	:and send it
::      Now we've prepared the username with the right controls, so enter name
	LHI	R7,LGCHMX
GDB212	SIS	R7,1
	JL	GD2MNY		:Zap buffer and tell user "too many.."
	JAL	R8,GCI,,	:Get a username character
	OHI	R1,0B380                :make char into a B3 msg        ###sdw
	JAL	R8,DIRMES,,	: .. and write it to dispatcher
	NHI	R1,0FF
	CHI	R1,8D		:Is it a <cr>?
	JEFS	GDB214
	CHI	R1,0BB		:Is it a semi-colon?
	JN	GDB212		:If not either, then get more characters
:                               Finished sending Log-on string to Sup
GDB214	RBT	CHN,LOGDAT	:log-in in wait state
        THI     R7,1            :odd len username? (1,3,5,,,)
        JN      GDB220          :nope (count is one off from real (look above))
        LHL     R1,BCT,R2,      :remove null after last char in username
        JE      GDB220          :make sure null is there
        JAL     R8,GCI,,        :remove null
	J	GDB220		:Continue

::      Here if non-transparent and need to flush username
GDB216	HS	0		
	IF	0:EV1	(possible future implementation)
	LB	R1,GDSPED	:Get throughput class
	LB	R1,TPTBL,R1	:Get control character from table
	LHI	R0,0B3
	EXBR	R0,R0
	AR	R1,R0		:Make B3 message
	JAL	R8,DIRMES,,	:and send it
	EI	:EV1
	LHI	R7,7F		:Flush username
GDB217	SIS	R7,1
	JAL	R8,GCI,,		:may not be a good idea to continue here
	CHI	R1,8D
	JEFS	GDB218
	CHI	R1,0BB
	JN	GDB217
GDB218  THI     R7,1                    :fill char after username? (odd len)
        jefs    gdb220                  :nope
        lhl     r1,bct,r2,              :make sure it is there
        jefs    gdb220
        jal     r9,gcie,,               :it could be escaped
GDB220	XHI	R2,4		:Flip to outbound (to terminal) buffer
	TBT	CHN,GIIXCT	:An IIX circuit?
	JEFS	GDB222		:NO
	LA	R4,GIIXGW	:Send "reached IIX Gateway"
	JAL	R9,BUFCAN,,
GDB222	TBT	CHN,GTTRNS	:Transparent log-on?
	JN	GDB226		:Yes - don't send banner

GDB224	LA	R4,GNETOK,,	:Load 'inter-link connected'
	JAL	R9,BUFCAN,,	:Send it
	ROUTE(HOMEN,ISISN)
	LA	R4,CRLF
	JAL	R9,BUFCAN,,
	LA	R4,LTX000,,	:Load 'Please log in'
	TBT	CHN,GIIXCT	:IIX circuit?
	JEFS	GDB225		:NO
	LA	R4,GIXPLI	:Load IIX PLI message	
GDB225	JAL	R9,BUFCAN,,
::      Give network the desired transmit capability
GDB226	LHL	R3,BF,R2,		:get network channel number
	LHL	R7,GDFLGS		:Get needle flags
	THI	R7,NF.PRI		:Is this a priority circuit?
	JEFS	GDB228			:No
	SBT	R3,PRIRTY-LNKZFL/8,,	:Set priority circuit flag
GDB228	LB	R1,GDSPED		:Get speed bits from temp storage
	LHL	R0,IOTAB,R3,R3
	OR	R0,R1			:Merge into perm table entry
	STH	R0,IOTAB,R3,R3		:And restore outbound table entry
:                                       Load port counters and etc.
	LHL	R1,HNPORT
	AIS	R1,1
	CLH	R1,MXPORT
	JLEFS	GDB230
	STH	R1,MXPORT
GDB230	STH	R1,HNPORT
	STH	R1,DHSTIX,CHN,CHN
::                      Now send Needle  ack
	LHL	R2,TVRBUF	:Load up 'To Sup' buffer
	JE	GDB240		:No Sup? .. oh well ..
	JAL	R10,SUPMHD,,
	LBR	R1,CHN		:Get relative Dispatcher port #
	OHI	R1,1500		:Type 15 message
	JAL	R9,WHWI,,
	LH	R1,GDNINV
	JAL	R9,WHWI,,
	LH	R1,GDNINV+2
	JAL	R9,WHWI,,	:Followed by invoice number
GDB240	J	DSOIRP,,	:Return to Dispatcher mainline


::**********************************************************************
::
::	GD2MNY:	Sends message "too man log-on characters" to terminl user,
::		then Zaps the circuit.
GD2MNY	HS	0
	XHI	R2,4		:Flip to outbound buffer(to terminal)
	LA	R4,TOMANY,,	:Get message
	JAL	R9,BUFCAN,,	:and put it out
	LA	R4,LSMX08,,	:"please see your rep ... "
	JAL	R9,BUFCAN,,
:NOW FALL THROUGH AND ZAP THE CIRCUIT IN BOTH DIRECTIONS

::**************************************************
::
::	GDZAP:	Zaps a Log-in circuit not fully built
::		from HNET  to INET.
::	EXPECTS:	CHN	=  Rel. Dispatcher chn
::			R2	=  From Terminal buffer
::
GDZAP	HS	0		:Zap Gateway Log-in circuit
	LHI	R1,09F00	:Load a hard Zapper
	JAL	R8,DIRMES,,	:Send to Dispatcher on CHN
	LIS	R0,0		:Zero out scratch permuter table
	STH	R0,GDLGTB,CHN,CHN
	STH	R0,BF,R2,	:Zero our previously marked as Log-in BF
	XHI	R2,4		:Flip to To Termnal buffer, set up via CRQ
	LHI	R1,ZAPPN
	JAL	R9,W2CI,,	:Zap network side of circuit
	RBT	CHN,LOGING		:reset..
	RBT	CHN,DISFLG		:no more input to dispatcher
	RBT	CHN,DISZNK		:prepare for GLZPV
       if       acct
        lis     r0,aalr02
        sth     r0,aareas
        rbt     chn,disznk
        lr      r3,chn
        jal     r8,aarlo,,
        lis     r0,0
        sth     r0,aareas
       ei       :acct
        j       dsoirp,,

::*****************************************************************
:
:       this is the LOGSUP logic for GATEWAY.
:
:
:	Here for login-buffer that has not timed out.
:	If the supe and node code bits are both set in the buffer's BF,
:	we continue.  Otherwise, we go on to the next buffer (LOG1) and
:	return this buffer to the LOGGER list.
::*****************************************************************

GLOG9	HS	0
	LHL	R1,BF,R2,		:ARE WE IN XMIT MODE (SUP & NC)
	NHI	R1,@LG.TID		:(TID DOESN'T COUNT)
	CLHI	R1,LOGMIN+LOGSUP	:CMP WITH 14H
	JN	LOG1,,			:NO, BACK TO THE LIST

:	Here for buffer with BF set ready to transmit.
:	If there is data in the buffer, continue.  Otherwise,
:	go on to next buffer (LOG1).
	LHL	R1,BCT,R2,
	JLE	LOG1,,			:RETURN TO LOGGER LIST

	L	R3,BB,R2,		:INIT PCI
	XHI	R2,4			:BUF TO TERM, TO GET CHN
	LHL	CHN,BF,R2,		:Get to-terminal channel
	SHI	CHN,DISZFL		:Make to relative dispatcher port
	XHI	R2,4			:FROM TERM FOR PCI
       IF       LOGII                   :for LOG II dispi
        TBT     CHN,DISLG2
        JE      LOG010                  :only do log ii for logii origs
        JAL     R8,CBCCT,,
        LR      CD,R1
        J       GDLCCH                  :process logon chars
       EI       :LOGII
LOG010	TBT	CHN,GMSG0F		:0F MSG ALREADY SENT?
	JE	LOG020		  	:YES
        JAL     R9,PHWI,,
	STH	R1,GDSAVE
	CLI	R1,HHOST+8000
	JN	LOGZAP
        L       R3,BB,R2,
LOG020
        lb      r9,glgcnt,chn,
	JAL	R8,CBCCT,,		:CHECK CHAR CT. in buffer now
	STB	R1,GLGCNT,CHN,		:STORE NEW CT
        LR      R0,r9                   :how many chars (total) scanned
	LR	R4,r1			:New count into work reg
	SR	R4,R0			:DIFF. IN R4
	JLE	LOG1,,			:NO NEW CHAR
	LR	R0,R0
	JE	LOG027			:If buffer had been empty, go from BB
LOG023	JAL	R8,NCI,,		:INC R3 PTR ONLY,NO PEEK
	SIS	R0,1			:DEC OLD CT 	
	JGBS	LOG023
LOG027	JAL	R8,PCI,,		:PEAK EACH CHAR. & ANALIZE
        CLHI    R1,07                   :escaped char? ##sdw
        JG      LOG033                 :yes
        LR      R1,R1                   :escaped char?
        JE      LOG030
        SIS     R1,03                   :IS a ZAPPER in The buffer
	Jg	LOG043                  :not a zapper sig and 1 byte
        AIS     R9,1                    :one closer to the end
        SIS     R4,1                    :another one peeked
        lr      r1,r1                   :zapper type or just some signal
        jefs    log028
        jal     r8,pci,,                :each the don't care about signal
        j       log043
log028  jal     r8,pci,,
	CLHI	R1,03
	JLE	LOG047			:..IF SO , SEND DIRECTLY TO SUP
        J       LOG043                  :let the nonzapper just sit
LOG030  JAL     R8,PCI,,                :read escaped byte
        AIS     R9,1                    :one closer to too many
        SIS     R4,1                    :reduce unread count by one
LOG033	OHI	R1,80			:HO-BIT SET FOR CHAR
	XHI	R2,4			:TO TERM. BUF#
	CLHI	R1,88			:Is char. ctl-H?
	JNFS	LOG037			:No
	RBT	CHN,GTECHO		:Turn off echo for this guy
	SBT	CHN,GTHDX		:Make sure were thinging HDX
LOG037	CLHI	R1,09F			:Is char. printable?
	JLEFS	LOG040			:No
	TBT	CHN,GTLGEC		:Should this be echoed?
	JEFS	LOG040			:No
	TBT	CHN,GTECHO		:Echo for this term. type?
	JEFS	LOG040			:No
	LR	R10,R3
	JAL	R8,WCI,,		:Echo back to term.
	LR	R3,R10
LOG040	XHI	R2,4			:FROM TERM. BUF#
	CLHI	R1,9B			:ESC KEY?
	JE	LOG053			:YES, HANDLE ESCAPE
	CHI	R1,8D			:= 'CR' ?
	JE	LOG047			:YES, SET NODE CODE TO OK
	CHI	R1,0BB			: IF IT IS SEMI-:
	JNFS	LOG043
	RBT	CHN,GTLGEC		: NO ECHO AFTER SEMI-:
	J	LOG047
LOG043  AIS     R9,1                    :one closer to too many
        CLHI    R9,LGCHMX               :made it to too many?
        JG      LOG050                   :jump more than 48 log chars
	SIS	R4,1			:EMPTY BUFFER YET ?
	JG	LOG027			:No .. get more characters
	J	LOG1,,			:and go to next port
:	SET BF TO 'NODE CODE = YES' IF CHARACTER IS CR OR SEMI-:
LOG047	HS	0
	LHL	R8,BF,R2,		:GET BF
	OHI	R8,LOGNDC		:SET 'NODE CODE = OK' BIT
	STH	R8,BF,R2,
	J	LOG101			:GO TO COPY TO SUP BUF

:	MORE THEN 48 CHAR.S ENTRY
LOG050 	HS	0
	LIS	R1,0			:SET TO 0 FOR NO ESC CHAR
:	ESCAPE KEY HANDLER
LOG053	LIS	R0,0			:COMMON ENTRY POINT FOR ESCAPE
					: & BUFFER FULL
	ST	R0,DSOLGH  		:CLEAR TEMPORARY SAVE AREA
	GL	DSOLGH
	STB	R1,DSOLGH+3		:STORE R1 (EITHER ESCAPE CHAR OR 0)
	LIS	R0,0F
	TBT	R0,BF,R2,		:IS TID IN THE BUFFER?
	JEFS	LOG057			:NO
	JAL	R9,GHWI,,			:YES, GET HOST NUMBER
	STH	R1,DSOLGH		:AND SAVE IT
	JAL	R8,GCI,,			:ALSO GET TID
	OHI	R1,80			:HO-BIT SET FOR CHAR
	STB	R1,DSOLGH+2		:SAVE IT ALSO
LOG057  LB	R1,DSOLGH+3		:ESCAPE OR BUFFER FULL?
	JE	LOG080			:BUFFER FULL, GO CLEAR IT

LOG060  LHL	R0,BCT,R2,		:ESCAPE TYPED...ANYTHING IN BUFFER?
	JEFS	LOG063			:NO, BUFFER EMPTY
	JAL	R9,GCIE,,		:YES, GET A CHARACTER, ESCAPE STRIPPED
	GL	GCIE
	NHI	R1,7F			:STRIP OFF MSB
	CLHI	R1,01F			:CONTROL CHARACTER?
	JGBS	LOG060			:NO, GET ANOTHER CHARACTER
	SBT	R1,DSOSPC		:CONTROL CHARACTER, NOTE IT
	GL	DSOSPC
	JBS	LOG060			:AND KEEP EMPTYING BUFFER
LOG063  LHL	R1,DSOLGH		:GET HOST NUMBER
	JEFS	LOG070			:NO HOST NUMBER IN BUFFER
	JAL	R9,WHWI,,		:DEPOSIT HOST NUMBER
	GL	WHWI
	LB	R1,DSOLGH+2
	JAL	R8,WCI,,		:AND TID
LOG070	LHI	R4,01F			:SEND SUP ALL CONTROL CHARACTERS
LOG073   RBT	R4,DSOSPC		:WAS THIS ONE IN BUFFER?
	JEFS	LOG076			:NO
	LHI	R1,80,R4		:YES, APPEND 80-BIT...
	JAL	R9,WCIE,,		:AND, WRITE IT IN
	GL	WCIE
LOG076   SIS	R4,1
	JGEBS	LOG073			:LOOP OVER ALL CONTROL CHARACTERS
         LB	R1,DSOLGH+3		:GET THE ESCAPE CHAR
	JAL	R8,WCI,,		:AND WRITE IT IN
	LIS	R0,0E
	SBT	R0,BF,R2,		:SET NODE CODE TO GO AHEAD
	J	LOG101			:GO TO COPY TO SUP. BUF
::Too many login characters .... abort login
LOG080	JAL	R8,CBCLR,,		:CLEAR BUFFER
	LIS	R0,0E
	SBT	R0,BF,R2,		:SET NODE CODE TO GO AHEAD
	XHI	R2,4
	LHL	CHN,BF,R2,
	SHI	CHN,DISZFL
	XHI	R2,4
	LHL	R1,DSOLGH		:IS HOST NUMBER IN BUFFER
	JE	LOG083			:GO TO COPY TO SUP. BUF
	JAL	R9,WHWI,,		:YES, REDEPOSIT IT
	LB	R1,DSOLGH+2		:AND ALSO THE TID
	JAL	R8,WCI,,
LOG083	LA	R1,TOMANY,,
	JAL	R8,DIMMES,,
	LA	R1,PSRMSG,,
	JAL	R8,DIMMES,,		:Output "pls see your rep.."
	TBT	R5,GTTRNS
	JN	LOG087
	LA	R1,GNGONE,,
	JAL	R8,DIMMES,,
	DROUTE(ISISN,HOMEN)		:If non-transparent send
	LA	R1,CRLF			:"inter-link cleared .."
	JAL	R8,DIMMES,,
LOG087	TBT	CHN,GMSG0F		:Has  TID etc. been sent to sup ?
	JE	LOG090			:Yes .. continue processing login

	LHI	R1,09E00		:In this case, just Zap circuit
	JAL	R8,DIRMES,,
	LIS	R1,0			:and let dispatcher Zapper ack
	STH	R1,BF,R2,		:Set bf to Zero for RFCBUF
	SBT	CHN,DISZNK		:And set up for Zapv to clean up
	J	LOG0,,			:also ensure LOGCLR

LOG090	LHI	R1,ZAPPH		:Abort login in progress 
	JAL	R9,W2CI,,		:WRITE ZAPPER TO BUFFER
					:and continue ... send Zapper to sup
LOG101	LR	R6,R2			:MOVE CHARS TO THE LEP BUFFER
	LHL	R10,BF,R2,		:GET LOGIN STATUS (16 OR 17 HEX)

:	Get the login status from BF and convert to proper sup message type
:	(0E=login string continuation, 0F=TID+login string).  
:	Create a login string message in the sup buffer (TVRBUF)
:	get logon status from BF and convert to NEW or not depending on TID
:	in buffer or not.  Send a type 0C message in either case.
	SHI	R10,08			:CONVERT TO MESSAGE TYPE (0E OR 0F HEX)
	LHL	R2,TVRBUF		:init R2 to hold to-SUP buffer number
	LR	R7,R2			:R7 holds sup buffer while we work
	LHI	R1,MACHNM+8000		:MAKE SUP RECORD
	JAL	R9,WHWI,,
	LR	R1,R10			:MESSAGE TYPE '0E' OR '0F'
	JAL	R8,WCI,,

	IF	LPGDBG 			:DEBUGFGER		###LSH 
	L	R1,BE,R7,
	ST	R1,LPGSSV		:save ptr to use in cpying data
	EI	:LPGDBG

	LIS	R1,0
	JAL	R8,WCI,,		:ASSUME CHAR COUNT NEEDS ESCAPING
	JAL	R8,WCI,,		:ESCAPED CHAR CNT WILL GO HERE IN BUFF
	L	R10,BE,R2,		:SAVE POINTER TO IT
	LR	R1,R6
	XHI	R1,4			:GET THE PORT #
	LHL	R1,BF,R1,
	OHI	R1,8000			:SET FOR SUP
	JAL	R9,WHWI,,
	GL	WHWI
	LHI	LRC,80			:NUMB OF CHARACTERS TO BE SENT.
:	80-bit means not SIQ circuit. May be reset below.
		
:	If the TID is still in the buffer, include the host number.
:	Else skip to LOG130.
	LIS	R2,0F			:LAST (TID) BIT IN HW
	TBT	R2,BF,R6,		:TID WAITING TO BE SENT ?
	JE	LOG130			:NO, SKIP HOST NUMBER
:	If we're sending the intial login string (msg type 0F),
:	we have to check for a smart (SIQ) circuit and inform the sup if so.
:	We know a circuit is SIQ if the LO bit of the orginating channel's
:	permuter table entry is set (i.e., the LO gouging bit).  We tell
:	the supe a circuit is SIQ by resetting the HO bit of the count field
:	(1 byte) in the type-0F message.
	RBT	CHN,GMSG0F		:SET FLAG TO 0 WHEN SENDING 0F
	XHI	R6,4
	LHL	R9,BF,R6,		:GET ORIGINATING CHANNEL
	XHI	R6,4
	LHL	R0,IOTAB,R9,R9		:PERMUTER TABLE ENTRY FOR CIRCUIT ORIG
	THI	R0,IIXLOG		:SIQ CIRCUIT?
	JEFS	LOG120			:NO
	LIS	LRC,0			:ABSENCE OF 80 BIT INDICATES SIQ TO SUP
LOG120	HS	0			:Type 0F msg. Include host number+8000.
	LR	R2,R6			:GET PORT BUFFER
	LHL	R0,BCT,R2,		:check for more data
	JE	LOG150			:IT'S EMPTY NOW
	JAL	R9,GHWI,,		:GET 8000+HOST NUMBER
	LR	R2,R7			:GET SUP BUFFER
	JAL	R9,WHWI,,		:WRITE HOST NUMBER

:	Supe message header complete.  Now append login string from login
:	buffer to it (escaping as necessary) until login buffer is depleted or
:	a terminator or escape char is detected.  (See LOGDLM for escape
:	characters-- there are several.)  Bump the count in LRC as we go.
:	Skip to LOG150 if the buffer empties.
LOG130	HS	0
	LR	R2,R6			:port buffer
	LHL	R0,BCT,R2,		:check for more data
	JE	LOG150			:IT'S EMPTY NOW
	JAL	R8,PCIS,,
	CLHI	R1,03
	JN	LOG137	
	JAL	R8,PCI,,
	CLHI	R1,01
	JE	LG11ZP
	JFS	LOG137
LOG133	LR	R2,R6			:port buffer
	LHL	R0,BCT,R2,		:check for more data
	JE	LOG150			:IT'S EMPTY NOW
LOG137	JAL	R8,GCI,,		:read out a byte
	LR	R2,R7			:sup buffer
	CLHI	R1,8			:ESCAPE IF NEEDED (00-07)
	JGE	LOG140

        lr      r1,r1                   :escaped byte?
        jefs    log138
        sis     r1,3                    :two byte char pair?
        jg      log130
        lr      r2,r6                   :source reg
        jal     r8,gci,,                :get second byte of signal pair
        lr      r2,r7                   :dest reg
        j       log130
log138  lr      r2,r6
        jal     r8,gci,,                :get second byte of char pair
        lr      r2,r7
LOG140	HS	0
	OHI	R1,80			:Must set high order bit for sup
	JAL	R8,WCI,,		:and write in data byte
	AIS	LRC,1			:INC STRING COUNT (don't count escapes)
	AIS	R4,1			:STOP WHEN CR, SEMI-:, OR ESC IS FOUND
	TBT	R1,LOGDLM-10		:DELIMITER = 'CR', "SEMI-:", 'ESC' ?
	JE	LOG133			:no, continue at top of loop
	J	LOG150

::	Detected Zapper in buffer.  Just send a Zapper to sup.
LG11ZP	HS	0
	LR	R2,R7
	LHI	R1,ZAPPH
	JAL	R9,WHWI,,		:Write Zapper directly to sup buffer
	AIS	LRC,2
	AIS	R4,2
	XHI	R6,4
	LHL	R1,BF,R6,		:Get return channel (to terminal port)
	SHI	R1,DISZFL		:Make relative dispatcher port
	RBT	R1,DISFLG		:and disable  servic of null buffer
	XHI	R6,4			:Return to previous state

::Now continue and send to sup
:	Detected terminator (semi-:, CR) or escape in login string or
:	Login buffer emptied while we were transfering it to the sup buffer.
:	Close out the supe message, mark the login buffer's BF to show TID has
:	been sent, then go on to next buffer (LOG1).
LOG150	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,3			:CASE # 3
	JAL	R14,LGGDB2,,
	LR	R2,R7			:R2 = TVRBUF
        gl      lggdb3
	JAL	R14,LGGDB3,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	LIS	R0,0
	STB	R0,GLGCNT,CHN,		:Reinit. log-on buffer count
	STB	LRC,0,R10		:EMPTY BUFF - PUT AWAY COUNT
	LR	R2,R6
	LHI	R1,LG.SNT		:set to wait
	STH	R1,BF,R2,
	J	LOG1,,			:PUT HIM BACK ON QUEUE

:	(CR) (ESC,FS,GS,RS,US) (SEMI:) ({,|,},TILDA)
:	Bit array (80x bits) marks ASCII codes that are to be considered
:	"escapes" in a login string.
LOGDLM	HS	0
	HC	0004,001F,0000,0010,0000,0000,0000,001E

::	Here to zap a login circuit because LOGGER found no sup or recent
::	takeover (in either case we can't process any more login data now,
::	and because we can't be sure of the status of any login data 
::	already sent to the (a) sup, we have to ask every one to start over
::	again).  We zap a port in login mode by sending it a
::	login-error-character-pair (0313).  If ISIS, DISPI will send the
::	dispatcher a B5 message and a zapper, and will call ZAPV when it gets
::	the corresponding zapper ack.  In a CONSAT, the port will be hung and
::	a zapper sent back to the node code by ASYNC.
::	For Gateway, we must send a zapper (to invoke an ISIS detatch)
::	and let the zap ack invoke Zapv to clear circuit - because we are not
::	talking to a terminal in Log-in mode, but to an active circuit in
::	another network.
LOGZAP	HS	0

	IF	LPGDBG			:DEBUGGER		###LSH
	STM	R0,REGST
	LIS	R1,1			:CASE # 1
	JAL	R14,LGGDB2,,
	LM	R0,REGST		:restore regs		###sdw
	EI	:LPGDBG

	XHI	R2,4			:ZAP CIRCUIT
LGZA1	LIS	R1,3
	JAL	R8,WCI,,
	LHI	R1,ZAPPH&0FF		:having placed char pr 0303
	JAL	R8,WCI,,
LGZPCN	XHI	R2,4			:Continuation point in either case

:	Set this guy's BF back to 0 (nothing doing) and go on to the next
:	buffer (LOG0).
	LIS	R1,0			:ZERO BUFFER FLAG
	STH	R1,BF,R2,
	
	J	LOG0,,			:DONT PUT HIM BACK

:	LOGGER exit point.  Mark the 'has-ther-been-a-recent-takeover" flag
:	to "no" before returning to SWITCH exec loop (LOGRET).
LOGXIT	HS	0
	LIS	R0,0			:FORCE THIS TO NORMAL STATE
	STH	R0,LOGZPF
	J	LOGRET,,




::*********************************************************************
::
::	SUBROUTINE:	GDB3IN:  Gateway Dispatcher B3 INput handler.
::	FUNCTION:	Invoked for ports in Log-in mode.  Formulates
::			characters from HNET terminal into B3 for ISI.
::	CALLING SEQ:	JAL	R10,GDB3IN
::	CALLS:
::	RETURNS:
::
::*********************************************************************
GDB3IN	HS	0
	ST	R10,DSSVRT		:SAVE RETURN
:	PREVENT HOGGING CPU IN DISPATCHER PROCESS. DIDTIM WILL CONTAIN
:	FASTC TIME TO DISMISS BACK TO EXEC 500MS EVEN IF WORK TO DO.
	L	R0,FASTC,,
	AHI	R0,RATE/10		:DON'T RUN FOR MORE THAN 1/16TH SECOND
	ST	R0,DIDTIM

::      Should we dismiss after servicing each Log-in port?
GDINXT	HS	0
	L	R0,DIDTIM		:GET TIME TO DISMISS
	S	R0,FASTC,,		:LATER THAN CURRENT TIME?
	JGFS	GDLNX1			:YES - CONTINUE FILLING DISPATCHER RING
	LIS	R0,1			:NO - COUNT NUMBER OF FORCED DISMISSES
	AHM	R0,DIDISM
	J	GDLORT			:..RETURN

GDLNX1	LIS	TYC,7			:SET UP CONSTANTS
	LHI	TC,DRSZ-1
	LH	PRD,DRIF,,		:COMPUTE ROOM AVAILABLE
	LH	PRC,DRIE,,
	SR	PRC,PRD			:DRIE - DRIF
	JGFS	GDB305			:NO RING WRAP
	AHI	PRC,DRSZ		:RING WRAP
GDB305	CLHI	PRC,10			:MINIMUM ROOM CONSIDERED
	JGFS	GDB310			:PRC = ROOM AVAILABLE

:	HERE TO RETURN MAIN
GDLORT	L	R10,DSSVRT	
	JR	R10

:	LOCATE PORTS WITH INBOUND DATA
GDB310	LHI	R7,((NDP-1)/20)*4       :number of words to check
GDB320	L	R1,LOGING,R7
	N	R1,LOGDAT,R7		:Only ports in log-in WITH data
	N	R1,GDSTPT,R7		:Service only destination ports
	N	R1,DISBPV,R7		:MASK OUT BP'ED PORTS
	N	R1,GISSVD,R7		:AND SERVICED PORTS
	JFFO	R1,GDB342		:GO TO SERVICE

	SIS	R7,4			:POINT TO  NEXT WORD OF BIT ARRAYS
	JGEBS	GDB320			:PROCESS THIS GROUP IF NOT

:	ALL PORTS SERVICED ONCE
	LCS	R2,1		
	LHI	R7,((NDP-1)/20)*4
GDB330	ST	R2,GISSVD,R7		:RESTORE SERVICE FLAGS
	SIS	R7,4
	JGEBS	GDB330			:LOOP FOR NEXT GROUP
	J	GDLORT			:ALL DONE AND SPLIT

:	THIS IS THE MAIN WORK LOOP-- MOVE DATA FROM BUFFERLETS INTO RING
:	FOR THE PORTS MARKED IN R1'S BIT ARRAY.
GDB342	LR	CHN,R7			:CHANNEL OFFSET FOR WORD OF BIT ARRAY
        SLLS    CHN,3
	AR	CHN,R2			:ADD CHAN OFFSET WITHIN THE GROUP
					:CHN = RELATIVE DISPI CHN NUMBER
	RBT	CHN,GISSVD		:THIS PORT SERVICED
	LHL	R2,DIOTAB,CHN,CHN	:IOTAB ENTRY (OUTBOUND BUFF #)
	NHI	R2,-4			:STRIP GOUGING BITS FROM BUFFER NUMBER
	JNFS	GDB350
	CRASH.(.DISI0)			:DISPI FOUND NO DISPATCHER CIRCUIT
	J	GDB320			:GO TO SEE NEXT PORT
::Proceed
GDB350	XHI	R2,4			:Switch to inbound(from term) buffer
::      Check to ensure that we're in Log-in mode!
	LHL	R1,BF,R2,		:The BF should indicate Log-in
	CLHI	R1,LOGMAX
	JG	GB3CRH
	CLHI	R1,LOGMIN
	JL	GB3CRH

::	JAL	R8,CBCCT		:GET COUNT, RETURN IN R1
	
	HC	3A12
	HC	BB/4
	HC	BBSIZE
	LR	R1,R1
	JE	GDB320			:If NO  data, go service next port

GDB356	LR	LRC,R1			:MINIMUM AGAIN
	LR	CD,LRC			:WORKING COUNT

::      Now read Log-in characters, acting on zappers and passing on the rest
GDB360  HS      0
       IF       LOGII                   :log II logon chars
        TBT     CHN,DISLG2              :for only log 2 ports
        JN      GDLCCH
       EI       :LOGII
	JAL	R8,GCI,,		:MOVE CHARACTERS FROM BUFFER
	CR	R1,TYC			:Is it a Tymnet Control Character?
	JG	GDB3PR
        LR      R1,R1                   :escaped char?
        JNFS    GDB361
        SIS     CD,1                    :reduce count by the escape
        JAL     R8,GCI,,                :get the escaped char
        J       GDB3PR                  :and process it  ###sdw
GDB361	CLHI	R1,03			:Is it a Zapper
	JN	GDB403			:No, continue processing
	JAL	R8,PCIS,,
	CLHI	R1,01
	JE	GDB362
	CLHI	R1,02
	JE	GDB362
	CLHI	R1,03
	JN	GDB403

::      Clean up logon aspects of circuit - Zapper ack will clean up Hnet side
GDB362	HS	0
	RBT	CHN,LOGING		:No longer login mode
	RBT	CHN,DISZNK		:Expect zap ack - prepare for GLZPV
	LIS	R0,0
	STH	R0,GDLGTB,CHN,CHN	:Zero out scratch table
	JAL	R8,RFCBUF,,		:And in this case must return buffer
::      ZAPX will have cleared out the H-Net side of the 
::      circuit and done accounting
::              Send Zapper to ISIS side of circuit
	STH	CHN,DIRNG,PRD,		:Put channel number into ring
	LHI	R1,ISZAPR		:Load ISIS  ZAPPER
	STB	R1,DIRNG+2,PRD,		:Store to dispatcher ring
	AIS	PRD,4
	NR	PRD,TC
        STH     PRD,DRIF,,              :save ring pointer
       IF       ACCT                    :must do termination accounting ###sdw
        LIS     R0,AALR03               :zapped by user
        LHI     R3,DISZFL-MNACHN,CHN    :convert to accounting chn
        JAL     R8,AARLO,,
        LIS     R0,0
        STH     R0,AAREAS               :clear reason
       EI       :ACCT                   :accounting logic               ###sdw
        J       GDINXT,,                :and done with port


::              End point for each iteration of this routine
GDB390	HS	0
	IF	ACCT
::              Perform character counts for this destination
	TBT	CHN,GDSTPT		:Destination port?
	JE	GDB396			:Not destination, no count
	LR	R0,LRC			:Get count
	LR	R3,CHN			:Move Channel # to work reg
	AHI	R3,DISZFL		:Get absolute channel number
	SHI	R3,MNACHN		:Make an accounting index
	JAL	R8,AARDIC,,		:Now add to accumulator
	EI	:ACCT
GDB396	AIS	PRD,3		:Round off pointer
	NHI	PRD,DRSZ-4
	STH	PRD,DRIF,,	:and restore
	J	GDINXT		:Process next port

::                      Or process other control characters
GDB403	HS	0
	LIS	LRC,0			:For accounting, don't count controls
	CLHI	R1,05			:Is a green ball
	JE	GB3C01			:Yes
	CLHI	R1,06			:Is a red ball
	JE	GB3C01			:Yes
        sis     r1,3                    :this sig a pair or a byte?
        jg      gdb390                  :a signal byte signal
        lhl     r0,bct,r2,              :make sure another byte is there
        je      gdb390
        jal     r8,gci,,                :get second byte
        clhi    r1,0ff                  :yellow ball?
	JE	GB3C02
	J	GDB390			:Continue processing

::      Bounce green and red balls, reflect orange for yellow
GB3C01	XHI	R2,4			:Flip to terminal bound buffer
	JAL	R8,WCI,,		:And bounce it
	XHI	R2,4			:Return to net bound buffer
	J	GDB390
GB3C02	XHI	R2,4			:Flip again
	LHI	R1,0FE
	JAL	R8,WCI,,		:bounce orange ball
	XHI	R2,4			:Flip back
	J	GDB390

::      Else, process Log-on characters - sending each one in a
::       B3 message to ISIS
::      Enter here for next character
GDB3PR	LB	R9,GLGCNT,CHN,		:Current acumulated count
::            Test for Half Duplex
GDB3P1	OHI	R1,80			:Set high order bit
	LR	R6,R1			:Save copy of character
	CLHI	R1,88			:Is character control-H
	JNFS	GL3C1			:NO
	RBT	CHN,GTECHO		:Turn off echo for this guy
	SBT	CHN,GTHDX		:Make sure were thinking HDX
GL3C1	CLHI	R1,09F			:Is character printable
	JLE	GL3CH1			:NO
	TBT	CHN,GTLGEC		:Should this be echoed
	JE	GL3CH1			:NO
	TBT	CHN,GTECHO		:Echo for this terminal type?
	JE	GL3CH1			:NO
	XHI	R2,4			:Flip to terminal bound buffer
	JAL	R8,WCI,,		:Echo back to terminal
	XHI	R2,4			:Flip buffer back
::      Now write character to ISIS using B3 format.
GL3CH1	HS	0
	LBR	R1,R6			:ensure char is 1 byte
	STH	CHN,DIRNG,PRD,
	LHI	R0,0B300,R1		:Make B3 message
	STH	R0,DIRNG+2,PRD,		:Put into ring
	AIS	PRD,4
	NR	PRD,TC
::                                      Now check for terminators
	CHI	R1,8D			:= 'CR' ?
	JEFS	GB3CH0			:YES, SET NODE CODE TO OK
	CHI	R1,0BB			:= "SEMI :" ?
	JN	GDB3PP			:Do next character
	RBT	CHN,GTLGEC		:No echo allowed after semi-colon
GB3CH0	RBT	CHN,LOGDAT		:Put log-in in wait state
	LIS	R1,0
	STB	R1,GLGCNT,CHN,		:Reinit counter
	RBT	CHN,GLGDAT	
	J	GDB390			:Return for next port
::                                      Not delimiter .. get next character
GDB3PP	AIS	R9,1		:too many characters yet?
	TBT	CHN,GLGDAT
	JEFS	GDPP2
	CHI	R9,LGCHMX-3
	JFS	GDPP3
GDPP2	CHI	R9,LGCHMX
GDPP3	JLE	GDPP4		:Not too many .. continue
	XHI	R2,4
	LA	R4,TOMANY,,		:Sent "to many login characters"
	JAL	R9,BUFCAN,,		:back to the terminal user
	XHI	R2,4
	J	GDB390			:and go to next port
GDPP4	STB	R9,GLGCNT,CHN,	:Else .. store count so far
        SIS     CD,1
	JLE	GDB390		:and go to next port
	JAL	R8,GCI,,
        LR      R1,R1           :escaped char?
        JN      GDB3P1
        SIS     CD,1            :another char gone
        JAL     R8,GCI,,        :get the char
	J	GDB3P1		:Get next character

GB3CRH	HS	0		:Come here when circuit is inconsistent
	CI	R1,DEAD		:Could be special case of circular login
	JE	GB3CR1
	CRASH.(.DISI0)
GB3CR1	XHI	R2,4		:If so, other should be too
	LHL	R1,BF,R2,
	CI	R1,DEAD
	JE	GB3CR2		:If so, clear table entries
	CRASH.(.DISI0)
GB3CR2	RBT	CHN,LOGING
	AHI	CHN,DISZFL
	LHL	R1,IOTAB,CHN,CHN
	CR	R1,R2		:Consistency check
	JE	GB3CR3
	CRASH.(.DISI0)	
GB3CR3  HS      0
        IF      CBZDBG                  :debug this too (like ZAPV)
        STM     R0,REGST
        JAL     R14,GPZDB3,,
        GL      GPZDB3
        LM      R0,REGST                :new debug does all regs###sdw
        EI   :CBZDBG

	LIS	R0,0		:End of same circuit, so clear tables
	STH	R0,IOTAB,CHN,CHN
	SBT	CHN,ACP,,
	RBT	CHN,CHS,,
	SBT	CHN,CHS1,,
	LCS	R0,1
	SR	R0,CHN
	SBT	R0,ACP,,
	RBT	R0,CHS,,
	SBT	R0,CHS1,,
	J	GDB320

::*********************************************************************
::
::	ENTRY POINT:	GLP0DD:	Gateway LeP type 0D handler
::	FUNCTION:	Handles the Gateway variations of the Node
::			response to the Log-on response type 0D from Sup
::	INPUT:		R2	=  Buffer from terminal
::			CHN	=  Channel number (absolute)
::	OUTPUT:		Outputs a text and possible control characters.
::			Gateway must interpret and send any text due to its
::			capacity during log-in as a virtual terminal interface.
::			It must do this based on several possible general
::			terminal profile characteristics.  ie. Transparent
::			Log-on, IIX, HDX or just plain Ascii.
::	CALLS:		JAL	R8,GCI
::			JAL	R8,WCI  
::			JAL	R9,BUFCAN
::	RETURNS:	Jumps back to end of LEP0D routine to finish up
::			and return to further Lep processing.
::
::*********************************************************************

: rewritten GLP0dd to prevent any ports from going in cleanup.
: ###sdw

GLP0DD  LR      R10,R7          :make copy of status byte
        NHI     R7,1F           :r7 has message type
        SHI     CHN,DISZFL      :use relative (dispatcher) channel

        SBT     CHN,GTLGEC      :echo on
        THI     R10,40          :unless told to turn it off
        JNFS    GLP41
        RBT     CHN,GTLGEC      :told to turn off

GLP41   THI     R10,20          :flush port bound buffer?
        JEFS    GLP42           :nope
        XHI     R2,4            :port bound buffer
        JAL     R8,CBCLR,,      :flush
        XHI     R2,4            :return back to supe bound buffer

GLP42   CLHI    R7,11           :is the hang that ends the supe session?
        JE      GLP30Z          :yes handle it (nothing else matters)
        THI     R10,80          :clear supe bound buffer?
        JE      GLP42D          :nope
        JAL     R8,CBCCT,,      :count to clear
        LR      R1,R1           :any to clear?
        JLE     GLP42D          :nope
        JAL     R8,GCI,,        :make sure we don't clear a supe bound zap
        SIS     R1,3            :first byte of a zapper?
        JNFS    GLP42C          :nope, so ok to empty buffer
        LIS     R1,3            :put back that zapper byte
        JAL     R8,WCD,,        :put it back on the about to be read side
        LHI     R4,LOGMIN+LOGSUP :set status so LOGGER will sind it to supe
        STH     R4,BF,R2,       :loging status is stored in BF field
        J       LEP1,,          :done with this message

GLP42C  JAL     R8,GLBCLR,,     :empty login buffer (special empty routine)

GLP42D  XHI     R2,4            :flip back to terminal buffer
        TBT     R7,LGCHZZ       :should we reinit our to supe char count?
        JEFS    GLP42E          :nope
        LIS     R0,0
        STH     R0,GDLGTB,CHN,CHN :reinit count

GLP42E  SHI     R7,8            :bias down to 0
        TBT     CHN,GIIXCT      :iix circuit
        JN      GL30J           :yes special messages

        TBT     R7,GXLGMG       :a message for us to expand?
        JNFS    GLP0D2
        CLHI    R7,8            :message with supe text? (unbiased 10)
        JN      LEP0DA,,        :nothing for us to do (msg 12x 8x)
        J       GLPEI4,,        :expand routine

GLP0D2  LA      R4,CRLF         :new line
        JAL     R9,BUFCAN,,
    IF NETNAM
        TBT     CHN,GTTRNS      :transparent?
        JEFS    GL30F           :nope
        LA      R4,HOMEN,,      :name of home net
        JAL     R9,BUFCAN,,
        LA      R4,SPAC         :a space
        JAL     R9,BUFCAN,,
GL30F
     EI :NETNAM

        LIS     R8,0            :starting table index
        TBT     CHN,GTTRNS      :transparent table?
        JEFS    GL30G           :nope
        LHI     R8,LSMSTZ       :moves up a table index
GL30G   TBT     CHN,GTASCI      :asci?
        JEFS    GL30H           :nope
        AHI     R8,LSMSZ        :bump up a table index
        TBT     CHN,GTHDX       :half duplex?
        JNFS    GL30D           :yes
        TBT     CHN,GTAUX       :aux get same table as halfduplex ???
        JEFS    GL30H           :not aux circuit
GL30D   AHI     R8,LSMSZ        :bump up another table index
GL30H   SLHLS   R7,2            :word index
        L       R4,LSMS27,R7,R8 :get the message
        SRHLS   R7,2            :restore r7
        JAL     R9,BUFCAN,,     :output the message

GL30N   LR      R7,R7           :reentry for gl30j
        JLFS    GL30H1          :good messages are 0-5 (before bias 8-D)
        CLHI    R7,5
        JGFS    GL30H1          :not a good one
        LR      R8,R2           :poke into supe buffer flag
        XHI     R8,4            :supe buffer
        LHI     R4,LOGMIN+LOGSUP :set status
        STH     R4,BF,R8,

GL30H1  TBT     CHN,GTTRNS      :transparent?
        JE      LEP0DA,,        :nothing else to do
        TBT     R7,NLSOK        :hang this transparent user?
        JN      LEP0DA,,        :nope
        LHI     R1,1F0          :the hang char
        JAL     R9,W2CI,,
        J       LEP0DA,,        :continue at normal lep finish

:       IIX Subroutine for GLP0DD
:       returns GL30N or LEPIE4 (if supe text)

GL30J   HS      0
    IF NETNAM
: why can a transparent IIX receive CRLF while normal IIX cannot?????
        TBT     CHN,GTTRNS      :transparent user?
        JE      GLPIX2          :nope
        LR      R7,R7           :continue msg?
        JLE     GLPIX2          :yes
        LA      R4,CRLF
        JAL     R9,BUFCAN,,     :new line
        LA      R4,HOMEN,,      :home net name (to an IIX? guess so)
        JAL     R9,BUFCAN,,
        LA      R4,SPAC
        JAL     R9,BUFCAN,,
GLPIX2
    EI :netnam

        LA      R4,IIXLMS,,     :the IIX login status message
        GL      IIXLMS
        JAL     R9,BUFCAN,,     :has everything except the status
        CLHI    R7,8            :unbiased 10 (supe has sent text)
        JNFS    GLPIX3          :nope
        LIS     R1,0            :the null message (means continue)
        JAL     R9,W2CI,,       :0 is continue for the IIX status and esc it
        J       GLPEI4,,        :and now the lep processing does the text

GLPIX3  LB      R1,IXB4TB,R7    :send the proper code (isis style)
        JAL     R9,WCIE,,       :write and maybe escape
        J       GL30N           :done with IIX stuff

GLP30Z                          :r2 starts pointing to supe buffer
        LIS     R0,0            :not talking to supe any more
        STH     R0,BF,R2,       :not flags
        LR      R6,R2           :remove this from logger list
        JAL     R9,LOGCLR,,
: but do not reset LOGING because if DISPI were to read a zapper immediately
: after this routine we would send out accounting and ISIS would crash us.
: The zapper in the outbound buffer is how this port is going to be cleared.
: ###sdw

        XHI     R2,4            :back to port bound buffer
        LHI     R1,ZAPPN        :non gobbling zapper
        JAL     R9,W2CI,,
        J       LEP1,,          :really done



IXB4TB	BC	00,01,02,03,04,05,00,00,00,00,00,08,09,0A,0B,0C,0D,0E,0F
	BC	10,11,12,13		:Translate Node codes to Isis codes

LGCHZZ	HC	0000,0FFE: (> Msg 13x)	:RE-INIT CHARACTER COUNTER?
GXLGMG  HC      7E1F,0FE00 :(09-1E)     :expand for gateway log-in response
NLSOK	HC	$2 1001010111111111,-1
SPAC	SC	/ /;



::*********************************************************************
::
::	ENTRY POINT:	GDB4:	Gateway Dispatcher B4 Message Handler
::	FUNCTION:	Handles the B4 Log-on response.
::	INPUT:		CHN	=  Relative Dispatcher port number
::			R2	=  Buffer number of outbound (to terminal)
::	CALLS:		JAL	R8,GCI
::			JAL	R8,DIMMES
::			JAL	R8,DIRMES
::	RETURNS:	Jumps directly back to DISOUT processing.
::
::*********************************************************************

GDB4	HS	0		:Handle B4 Messages for Gateway
::      First, check to ensure that this is the correct circuit
	LB	R1,DORNG,PRD,	:PRD updated by DISOUT routine
	STB	R1,GLGSTA	:Store away status byte
	TBT	CHN,LOGING	:This channel should be in Log-in mode
	JE	DSKP3,,		:Jump out to DISKIP's error handling
::      Now double check to ensure that the right buffer is used
	XHI	R2,4		:Flip to incoming (from terminal)buffer
	LHL	R1,GDLGTB,CHN,CHN	:Get previously stored buffer #
	CR	R1,R2		:These should match
	JE	GDB402		:They do - proceed
	J	DSOCRH,,
::      As a triple check, the BF should indiciate Log-in state
GDB402	LHL	R1,BF,R2,	:Get flags field
	CLHI	R1,LOGMAX
	JG	DSOCRH,,
	CLHI	R1,LOGMIN
	JL	DSOCRH,,
::      Proceed with login message interpretation
	SBT	CHN,LOGDAT		:Remove log-in wait state
	LB	R10,GLGSTA		:GET STATUS
	THI	R10,40			:CHECK FOR ECHO-ON
	JNFS	GDB41			:SET IF ON
	RBT	CHN,GTLGEC		:ELSE RESET ECHOING
	JFS	GDB41A
GDB41	SBT	CHN,GTLGEC
GDB41A	THI	R10,20			:CHECK IF WE SHOULD FLUSH OUTPUT BUFFER
	JEFS	GDB42			:SKIP IF NOT
	XHI	R2,4			:FLIP TO (to terminal) buffer
	JAL	R8,CBCLR,,		:ELSE DO IT
	XHI	R2,4			:YES, flip to from terminal buffer
GDB42	THI	R10,80			:SHOULD WE EMPTY INPUT BUFFER?
	JE	GDB42B			:NO
	LHL	R0,BCT,R2,		:ANYTHING IN THE BUFFER?
	JLEFS	GDB42B			:NO, ALREADY EMPTY
	JAL	R8,GCI,,		:YES, GET 1ST CHAR
	SIS	R1,3			:IS 1ST CHAR A ZAPPER?
	JNFS	GDB42A			:NO, SKIP
	J	GDZAP			:If so Zap both sides of circuit	
GDB42A	JAL	R8,GLBCLR,,		:Clear buffer (special log-on clear)
GDB42B	XHI	R2,4			:Back to inputed R2
	LHI	R11,1F			:SET MASK FOR STATUS BITS
	NR	R11,R10			:EXTRACT MSG #
	TBT	CHN,GIIXCT		:IIX REQUESTED FOR THIS CKT?
	JN	GDB46			:YES
	LR	R11,R11			:CONTINUE?
	JE	DSOIRP,,		:RETURN IF 'CONTINUE'
::	LIS	R0,3		:###EV
::	STB	R0,GLGCNT,CHN,		:Reset character counter
:	CHN  = TYMNET PORT
:	R2  = TO TERMINAL BUFFER
:	R10 = STATUS
:	R11 = MESSAGE INDEX
	LA	R4,CRLF			:OUTPUT C/R L/F
	JAL	R9,BUFCAN,,

	IF	NETNAME
	TBT	CHN,GTTRNS		:TRANSPARENT USER?
	JE	GDB42C			:NO, SKIP
	LA	R4,ISISN,,		:OUTPUT NET NAME
	JAL	R9,BUFCAN,,
	LA	R4,SPAC,,		:...FOLLOWED BY A SPACE
	JAL	R9,BUFCAN,,
GDB42C	EI	:(NETNAME)

	LIS	R8,0			:INIT MSG TABLE INDEX
	TBT	CHN,GTTRNS		:TRANSPARENT USER?
	JEFS	GDB43A			:NO, SKIP
	AHI	R8,LSMSTZ		:MOVE INDEX TO TRANSPARENT MSGS
GDB43A	TBT	CHN,GTASCI		:IS IT REALLY ASCII TERMINAL?
	JEFS	GDB44			:SKIP IF NOT
	AHI	R8,LSMSZ		:MOVE INDEX TO ASCII MSGS
	TBT	CHN,GTHDX		:HALF-DUPLEX TERMINAL?
	JNFS	GDB43			:SKIP IF SO
	TBT	CHN,GTAUX		:AUX CIRCUIT?
	JEFS	GDB44			:SKIP IF NOT
GDB43	AHI	R8,LSMSZ		:MOVE INDEX TO HDX MSGS
GDB44	
	CHI	R11,5			:MSG#>5, USE SAME LSMS27 TABLE+3
	JLEFS	GDB44A			:<=5, NO+3
	Ais	R11,3
GDB44A	SLLS	R11,2			:FW BOUNDARY OF 4 BYTES
	L	R4,LSMS27,R11,R8	:GET ADDR OF MSG
	JAL	R9,BUFCAN,,		:OUTPUT MSG TO PORT
	SRLS	R11,2

GDB45	TBT	CHN,GTTRNS		:TRANSPARENT USER?
	JE	DSOIRP,,		:NO, SKIP
	TBT	R11,NLSOK		:SHOULD MSG BE FOLLOWED BY DETACH?
	JN	DSOIRP,,		:NO RETURN TO MAINLINE
        J       GLGZP                   :go to all in one logon zap routine

:	IIX CKT - SEND LOGIN STATUS BACK TO ORIGIN OF CKT
GDB46	NHI	R10,0BF			:DONT SEND ECHO ON

:	IIX LOGIN STATUS - RETURNS NETNAME (IF NON-TRANSPARENT) AND IIX
:	LOGIN STATUS MSG
:	REQUIRES	R2 = BUFF INDEX
:			CHN = Relative Dispatcher port #
:			R10 = LOGIN STATUS BYTE
	IF	NETNAM
	TBT	CHN,GTTRNS		:Transparent user?
	JE	GB4DX1			:NO, SKIP
	LR	R11,R11			:CHECK MSG TYPE
	JE	GB4DX1			:IF 'CONTINUE', SKIP
	LA	R4,CRLF			:OUTPUT CR, LF
	JAL	R9,BUFCAN,,			:/
	LA	R4,ISISN,,		:OUTPUT NETNAME
	JAL	R9,BUFCAN,,			:/
	LA	R4,SPAC,,		:...AND A SPACE
	JAL	R9,BUFCAN,,			:/
GB4DX1	HS	0
	EI	:(NETNAM)
	LA	R4,IIXLMS		:BEGINNING OF IIX LOGIN STATUS MSG
	JAL	R9,BUFCAN,,			:OUTPUT IT
GB4DX4	LR      R1,R11
	JAL	R9,WCIE,,		:/
	J	GDB45


::*********************************************************************
::
::	ENTRY POINT:	GDB5:	Gateway Dispatcher B5 Message Handler
::	FUNCTION:	Handles the B5 Log-on response.
::	INPUT:		CHN	=  Relative Dispatcher port number
::			R2	=  Buffer number of outbound (to terminal)
::	CALLS:		JAL	R8,GCI
::			JAL	R8,DIMMES
::			JAL	R8,DIRMES
::	RETURNS:	Jumps directly back to DISOUT processing.
::
::*********************************************************************

GDB5	HS	0		:Handle B5 Messages for Gateway
::      First, check to ensure that this is the correct circuit
	TBT	CHN,LOGING	:This channel should be in Log-in mode
	JE	GDB5SK		:Small Error, just skip it.
::      Now double check to ensure that the right buffer is used
	XHI	R2,4		:Flip to incoming (from terminal)buffer
	LHL	R1,GDLGTB,CHN,CHN	:Get previously stored buffer
	CR	R1,R2		:These should match
	JE	GDB5SK		:They do - proceed
	J	DSOCRH,,	:No match  .. big problem
::      As a triple check, the BF should indiciate Log-in state
GDB5SK	LHL	R1,BF,R2,	:Get flags field
	CLHI	R1,LOGMAX
	JG	DSOCRH,,
	CLHI	R1,LOGMIN
	JL	DSOCRH,,
::      A zapper will follow this but we will implant a nongobl zap 
::      and clean up dispatcher side right now
        XHI     R2,4                    :point R2 back to term direction
        TBT     CHN,GTTRNS
        JN      GLGZP                   :don't send why on transparent
        LA      R4,LTX103,,             :interlink lost msg
        JAL     R9,BUFCAN,,
        J       GLGZP                   :and zap


::*********************************************************************
::
::	SUBROUTINE:	GDB6:	Gateway B6 message handler
::	FUNCTION:	Completes the Gateway LOg-in from HNET to INET.
::	CALLS:
::	RETURNS:	Jumps directly to DSOIRP.
::
::*********************************************************************
GDB6	HS	0		:Gateway B6 message handler
::      First, check to ensure that this is the correct circuit
	TBT	CHN,LOGING	:This channel should be in Log-in mode
	JE	DSKP3,,		:Jump out to DISKIP's error handling
::      Now double check to ensure that the right buffer is used
	XHI	R2,4		:Flip to incoming (from terminal)buffer
	LHL	R1,GDLGTB,CHN,CHN	:Get previously stored buffer
	CR	R1,R2		:These should match
	JE	GDB602		:They do - proceed
	J	DSOCRH,,		:Crash
::      As a triple check, the BF should indicate Log-in state
GDB602	LHL	R1,BF,R2,	:Get flags field
	CLHI	R1,LOGMAX
	JG	DSOCRH,,	:Crash
	CLHI	R1,LOGMIN
	JL	DSOCRH,,
::	SUCESSFUL LOGON
	LB	R1,DORNG,PRD,		:GET IIX FIELD (PRD advanced prior)
	LBR	R13,R1			:SAVE IIX BIT
	AIS	PRD,1
	NR	PRD,TC			:Move ring pointer to invoice number
	L	R1,DORNG,PRD,
	ST	R1,ININV		:SAVE ISIS-NET NET INVOICE #
	AIS	PRD,4
	NR	PRD,TC			:Advance pointer again
::      Now each Network must send the other its Invoice number
	IF	ACCT
	STM	R1,AARGSV
	AHI	CHN,DISZFL		:Make absolute - AASWAP will rtrn rel
	LR	R3,CHN			:Load  chan number in wrk reg
	CLHI	R3,MNACHN		:Do accounting range check
	JL	GDBSKP
	CLHI	R3,MXACHN
	JG	GDBSKP
	SHI	R3,MNACHN		:Make an accounting chan index
	JAL	R9,AAMKPT		:Get the block pointer (R11)
	JAL	R10,AASWAP		:EXCHANGE INVOICE #'S
GDBSKP	HS	0
	LM	R1,AARGSV
	EI	:(ACCT)
::      Toss originating host number, we don't need it
	AIS	PRD,2
	NR	PRD,TC
	RBT	CHN,LOGING		:NO LONGER IN LOGIN MODE
	TBT	CHN,GIIXCT		:WAS IIX REQUESTED?
	JEFS	GDB62			:NO
	LA	R4,IIXGRS		:YES, ASSUME GW REACHED SMART HOST
	SRLS	R13,1			:IIX BIT SET?
	JCFS	GDB61			:YES
	LA	R4,IIXGRD		:NO, GW REACHED DUMB HOST
GDB61	XHI	R2,4			:FLIP TO TO-TERM BUFFER
	JAL	R9,BUFCAN,,		:RETURN MSG TO ORIGIN
	XHI	R2,4			:FLIP BACK TO F. T. BUFFER	###EV
::      Now connect the circuit and let data flow.
GDB62	LR	R1,R2			:Use work register
	SRLS	R1,1			:Make fullword index
	L	R0,FASTC,,
	ST	R0,BUFTIM,R1,		:Store Needle origination time
	LIS	R0,0
	STH	R0,GDLGTB,CHN,CHN	:Zero out scratch table
::      Turn on Dispatcher port
	SBT	CHN,DISBPV		:Relieve backpressure,
	RBT	CHN,LOGING		:remove from Log-in status
	LHI	R0,INXLIM		:and set up intital
	STH	R0,DIXLIM,CHN,CHN	:transmit capacity
	AHI	CHN,DISZFL		:Make absolute channel number

::                                      Continue circuit building 
	XHI	R2,4			:and get outbound (to term) buf#
	JAL	R9,CRQHCR		:Complete actual circuit
::                                      Report IRC to Inet sup
	IF	IRC
	LHL	R3,BF,R2,		:ABSOLUTE CHAN#
	JAL	R9,FCHLNK		:FIND LINK# IN R0
	SKIPAD(GDB63)			:immed return, Error return	###wjl
	LR	R1,R0			:+4 return, For indexing purposes
	LB	R7,IRCTBL,R1		:IS THERE IRC VALUE THIS LINK?
	JE	GDB63			:NO REPORT IF NO IRC VALUE
	STB	R7,GB7REA		:STORE INTO CANNED GB7 MSG.
	LHI	R1,-DISZFL,CHN		:GET RPORT
	STH	R1,GB7PRT
	LHI	R1,0E00E		:MSG.# 14 FOR IRC LOCATN DEFINED
	STH	R1,GB7INV		:Renew message type
	LIS	R1,0
	STB	R1,GB7INV+2		:(may have been previously used)
	LA	R1,GDB7M		:IRC ACCT.MSG. REPORT
	LHI	R3,GDB7L		:LENGTH BYTE
	JAL	R8,DIZSMS		:TO DISPATCHER PORT 0
GDB63
	EI	(IRC)
::      Merge speed bits from origin side of circuit
	LHL	R1,BF,R2,		:Get other channel number
	LHL	R1,IOTAB,R1,R1		:Get permuter table entry
	NHI	R1,3			:Get speed bits
	LHL	R0,IOTAB,CHN,CHN	:Get table entry for circuit completion
	OR	R0,R1			:Install speed bits
	STH	R0,IOTAB,CHN,CHN	:Replace table entry
::                      Report to crypto log 
GDBC64	LHL	R0,BF,R2,		:Log first port
	EXHR	R0,R0
	XHI	R2,4
	LHL	R8,BF,R2,		:Then the other one
	AR	R0,R8
	JAL	R8,CRYPTO,,
	HC	CRYE0B
	LHL	R1,BCT,R2,		:Anything in F.T. buffer?
	JE	GDB573
	LHL	R1,BF,R2,
	SBT	R1,NFLAGS		:Set attention flag

GDB573	J	DSOIRP,,		:and continue

IIXGRS	XC	0401F68082		:SIIX + GW Reached smart host
IIXGRD	XC	0401F68083		:SIIX + GW Reached dumb host

::*****************************************************************
:
:       GDASLP  upon receiving the ASLP gateway builds the dispatcher chn
:               and initializes all of the flags.  DISFLG is set to have
:               needle routine make sure the entire has arrived before
:               trying to parse it (happens for converted needles followed
:               by needle body which travels as data.
:
::*****************************************************************

       IF       LOGII

GDASLP  AIS     PRD,6
        NR      PRD,TC                  :point to Local Key
        LHL     R2,DORNG,PRD,
        JAL     R8,GDB2FG               :initialize flags
        JAL     R9,PHWI,,
        CLHI    R1,NEEDBD               :make sure we still have needle
        JN      GDZAP                   :zap if lost needle
        SBT     CHN,DISFLG              :notify needle routines that a needle
        J       DSOIRP,,                :is pending.

::*****************************************************************
:
:       GDBODY  Processes the LOG II needle body and sets all the dispatcher
:               flags.  If the port is transparent then it writes the
:               XCRM from the needle.  If the port isn't transparent then
:               gateway sends Gateway IIX dialect, the reached gateway msg
:               and the PLI. IIX circuits don't send raw text but send the
:               the text and PLI within IIX messages.
:
::*****************************************************************

GDBODY  JAL     R9,GHWI,,               :len of body
        LR      R4,R1
        JAL     R8,CBCCT,,              :entire needle body there?
        CR      R4,R1
        JGE     GDBO01                  :process needle body
        JAL     R9,WCDE,,               :not there, try again next time
        EXBR    R1,R1
        JAL     R9,WCDE,,               :write back len
        LHI     R1,NEEDBD
        JAL     R8,WCD,,                :so we reenter same place next time
        EXBR    R1,R1
        JAL     R8,WCD,,
        J       DSINXT,,                :nothing written
GDBO01  STH     R4,GDNLEN               :save physical len
        SBT     CHN,LOGDAT              :look for logon chars
        SBT     CHN,DISLG2              :a log 2 port
        LHI     R4,ID.INV               :get invoice number
        JAL     R7,X4PARS               :initial parse
        SKIPAD(GLGZP)                  :should never happen
        JAL     R7,X4GTNM,,             :get invoice number into r4
        ST      R4,GDNINV               :save invoice number
        AHI     CHN,DISZFL              :make real port for accounting
        JAL     R8,AASTRT
        SHI     CHN,DISZFL              :back to dispi chn
:       alt entry for needles from INET
GDBONE  LHI     R4,ID.RIX               :orig IIX?
        JAL     R7,X4PARC  
        SKIPAD(GDBO03)                  :if not there then not IIX
        JAL     R9,PCIE,,
        LR      R1,R1                   :boolean true if nonzero
        JEFS    GDBO03
        SBT     CHN,GIIXCT              :iix circuit
GDBO03  LHI     R4,ID.HDX               :halfduplex indication
        JAL     R7,X4PARC
        SKIPAD(GDBO04)                  :not there so not HDX
        JAL     R9,PCIE,,
        LR      R1,R1
        JEFS    GDBO04                  :only true if nonzero
        SBT     CHN,GTHDX
GDBO04  LHI     R4,ID.TPC               :thorughput class
        JAL     R7,X4PARC
        SKIPAD(GDBO06)
        JAL     R7,X4GTNM
        JFS     GDBO05                  :have our throughput class
GDBO05  LIS     R4,0                    :if not there then assume class A
GDBO06  STB     R4,GDSPED               :save it
        LHI     R4,ID.CCT               :get CCT
        JAL     R7,X4PARC
        SKIPAD(GLGZP)                  :has to be there
        JAL     R7,X4GTNM
        STB     R4,CCTTBL,CHN           :save it
        LR      R1,R1
        JNFS    GDBO11                  :not aux circuit
        SBT     CHN,GTAUX               :they are aux circuit
        RBT     CHN,GTECHO              :and don't echo uname
        LIS     R1,0E                   :tid used for aux circuits
        STB     R1,CCTTBL,CHN
        JFS     GDBO13
GDBO11  SIS     R1,8                    :the 2741 terminals (cct = 8,9)
        JNFS    GDBO13                  :not 2741
        SIS     R1,9-8                  :too big?
        JGFS    GDBO13                  :not 2741
        SBT     CHN,GTHDX               :2741 is hdx, not ascii
        RBT     CHN,GTECHO              :don't echo any thine

GDBO13  LHI     R4,ID.TLI               :transparent circuit?
        JAL     R7,X4PARC
        SKIPAD(GDBO30)                  :easy, not transparent
        JAL     R9,PCIE,,
        LR      R1,R1                   :boolean variable
        JE      GDBO30                  :not transparent
:       TRANSPARENT LOGON create XCRM and send it within ICRS
        JAL     R8,X4CRIZ               :initialize create table
        LHI     R4,IDICRM+MO.AC2        :ICRM constructor
        TBT     CHN,GORGPT              :true if Inet to Hnet
        JEFS    GDBO14
        LHI     R4,IDNCRM+MO.AC2        :NCRM if to Hnet logon
GDBO14  JAL     R8,X4CCID               :Constructor
        LHI     R4,RMOID                :First element is RMO
        JAL     R8,X4CCID               :also a constructor
        LHI     R4,ID.IMF+MO.A2         :ICRM flags
        TBT     CHN,GORGPT
        JEFS    GDBO15
        LHI     R4,ID.NMF+MO.AC2        :NCRM flags if to INET
GDBO15  LHI     R1,0600                 :not an aux circuit request
        JAL     R8,X4CRID
        LHI     R4,ID.OHS+MO.A1         :our orig host
        LI      R1,IHOST                :LI so don't propogate high bit
        TBT     CHN,GORGPT              :put in correct host number
        JEFS    GDBO17
        LI      R1,HHOST
GDBO17  JAL     R8,X4CRID
        LHI     R4,ID.CCT+MO.A1         :Next is CCT
        LB      R1,CCTTBL,CHN           :get into memory
        JAL     R8,X4CRID
        TBT     CHN,GORGPT              :NCRM must have port number
        JEFS    GDBO19
        LR      R1,CHN
        LHI     R4,ID.PRT+MO.A1         :orig port ID
        JAL     R8,X4CRID
GDBO19  JAL     R8,X4FXCN               :RMO finished
        LHI     R4,SMOID                :now comes SMO
        JAL     R8,X4CCID
        LHI     R4,ID.UNM               :find username in buffer
        JAL     R7,X4PARC
        LHI     R4,ID.ULC+MO.A1         :they are logon characters
        JAL     R8,X4CBID               :data is in bufferlet
        LHI     R4,ID.PWD               :password
        JAL     R7,X4PARC
        SKIPAD(GDBO21)                  :no problem if not there
        LHI     R4,ID.PWD+MO.A1
        JAL     R8,X4CBID               :password is in buffers
GDBO21  LB      R1,GDSPED
        LHI     R4,ID.TPC+MO.A1         :next MO is throughput class
        JAL     R8,X4CRID
        TBT     CHN,GTHDX               :send HDX MO?
        JEFS    GDBO24                  :not HDX so no need to send
        LHI     R4,ID.HDX+MO.A1
        LHI     R1,0FF                  :indicate boolean true
        JAL     R8,X4CRID
GDBO24  TBT     CHN,GIIXCT              :iix capable?
        JEFS    GDBO26                  :not iix so no send
        LHI     R4,ID.RIX+MO.A1         :request iix if orig iix
        LHI     R1,0FF
        JAL     R8,X4CRID
GDBO26  JAL     R8,X4FXCN               :end of SMO constructor
        JAL     R8,X4FXCN               :end of ICRM constructor
        TBT     CHN,GORGPT              :true if from INET
        JN      GDIS20                  :return to ISN only logic
        LHL     R0,X4CTBG+X4CLEN,,      :GET len of icrm mo
        AIS     R0,0A                   :len of ICRS and XCRS headers
        JAL     R8,DIROOM,,             :make sure enough room in ring
        LHL     PRD,DROF,,              :get ring pointer
        STH     CHN,DIRNG,PRD,,         :save chn #
        LHI     R1,0C400                :ICRS with no continue
        STH     R1,DIRNG+2,PRD,
        AIS     PRD,4
        NR      PRD,TC
        STH     PRD,RPSAV               :save where to put len
        AIS     PRD,2                   :where to put MOs
        LIS     LRC,0                   :init length
        JAL     R8,X4CDWR               :write it into dispatcher
        LHL     R1,RPSAV
        STH     LRC,DIRNG,R1,           :save len of msg
        AM      LRC,DISICC              :add count
        AIS     PRD,3
        NR      PRD,TC
        STH     PRD,DRIF,,              :save ring pointer
        RBT     CHN,LOGDAT              :wait for response before sending more
        RBT     CHN,GMSG0F              :sent 1st msg

:       back to both transparent and normal case.  Now eat needle and
:       do iix and text sending to orig
GDBO30  LHL     R4,GDNLEN               :remove needle from buffer
GDBO31  JAL     R8,GCI,,
        SIS     R4,1
        JGBS    GDBO31                  :eat all of the needle

        XHI     R2,4                    :everything now back to orig
        TBT     CHN,GIIXCT              :iix?
        JEFS    GDBO34
        LA      R4,GIIXG2               :gateway iix dialect for LOG II
        JAL     R9,BUFCAN,,
GDBO34  TBT     CHN,GTTRNS              :transparent?
        JN      GDBO40                  :skip messages for transparent
        LA      R4,GNETOK,,             :interlink connected fr hnet to inet
        JAL     R9,BUFCAN,,             :gateway log 2 msg (it does iix stuff)
        ROUTE(ISISN,HOMEN)
        LHI     R1,0D0A                 :CR LF
        JAL     R9,W2CI,,               :output it to buffer
GDBO40  TBT     CHN,GORGPT              :if INET then no network chn
        JN      GDIS40                  :return to ISN logic
        LHL     R3,BF,R2,
        LB      R1,GDSPED               :get speed bits
        NHI     R1,3                    :only 2 bits
        OH      R1,IOTAB,R3,R3          :add in speed bits
        STH     R1,IOTAB,R3,R3
        LHL     R1,HNPORT               :ports in use
        AIS     R1,1
        CLH     R1,MXPORT               :new max?
        JLEFS   GDBO44
        STH     R1,MXPORT
GDBO44  STH     R1,HNPORT
        J       DSINXT,,

::*****************************************************************
:       GDRCRI  handle Logon response for LOG II Gateway.  Get msg
:               into buffer in order to parse it.  Convert response
:               into text if not IIX, if IIX then send it as PTOI.
:               Don'tt worry about reject since NC will follow it with
:               a detach.  Also don't send pli if logon limit exceeded.
::*****************************************************************

GDRCRI  JAL     R7,GDL2BG               :move into buffer and setup for parse
        LHI     R4,ID.NRJ               :Node ocde reject reason
        JAL     R7,X4PARS  
        SKIPAD(GDRC10)
        TBT     CHN,GIIXCT              :no text for iix
        JN      GL2LZP                  :no text, just zap
        TBT     CHN,GTTRNS              :these errors confuse transparent
        JN      GL2LZP
        JAL     R9,PCIE,,               :get reason
        CLHI    R1,LM24NM               :known error code?
        JG      GL2LZP                  :nope
        LHL     R4,LM24TB,R1,R1         :text for node reject MO24
        AI      R4,LM04TB               :standard base for all logon text
        JAL     R9,BUFCAN,,             :send it
        J       GDRCEX                  :and ready to exit

GDRC10  TBT     CHN,GIIXCT              :no convert text string for IIX
        JN      GDRC30                  :IIX only care about empty/echo status
        LHI     R4,ID.MSG               :logon port msg
        JAL     R7,X4PARC
        SKIPAD(GDRC20)                  :message not there
        LR      R6,R0                   :working copy of len
        LR      R4,R3                   :set up PCIER4 
GDRC19  JAL     R9,PCIER4,,             :get byte in string
        JAL     R9,WCIE,,               :rite it
        SIS     R6,1
        JGBS    GDRC19
GDRC20  LHI     R4,ID.SRJ               :contain reject code
        JAL     R7,X4PARC   
        SKIPAD(GDRC30)                  :not there, look for normal failure
        JAL     R9,PCIE,,               :get code
        CLHI    R1,LM27NM               :is this code known to gateway?
        JG      GDRCEX                  :no, just exit
        AR      R1,R1
        LHL     R4,LM27TB,R1,R1         :get reject code text
        AI      R4,LM04TB               :make address
        JAL     R9,BUFCAN,,
        J       GDRCEX                  :done, NC puts a detach behind it

GDRC30  LHI     R4,ID.LGS               :logon status
        JAL     R7,X4PARC   
        SKIPAD(GDRCEX)                  :know of no other MOs to find
        JAL     R9,PCIE,,               :get code
        LR      R7,R1                   :save msg code
        TBT     CHN,GIIXCT              :no text for iix
        JN      GDRC52
        LIS     R8,0                    :start at 0
        TBT     CHN,GTTRNS              :skip to transparent set of table?
        JEFS    GDRC36
        LHI     R8,LM04TZ               :get to transparent circuit's tables
GDRC36  TBT     CHN,GTASCI              :use the 2741 table?
        JEFS    GDRC40                  :not ascii is 2741
        AHI     R8,LM04SZ               :move up to ascii table MO-04
GDRC40  TBT     CHN,GTHDX               :use hdx table?
        JEFS    GDRC44
        AHI     R8,LM04SZ
GDRC44  LR      R4,R7
        AR      R4,R4
        LHL     R4,LM04TB,R8,R4         :get offset of logon status msg
        AI      R4,LM04TB               :get address of msg
        JAL     R9,BUFCAN,,             :send msg
        TBT     CHN,GTTRNS              :transparent never gets appended pli
        JN      GDRC52
        TBT     R7,L2MPLI               :append a PLI?
        JEFS    GDRC48                  :nope
        LA      R4,LTX000,,
        JAL     R9,BUFCAN,,             :send PLI text
GDRC48  TBT     CHN,GTASCI              :if 2741 then append GB
        JNFS    GDRC52
        LIS     R1,05                   :Green Ball
        JAL     R8,WCI,,
GDRC52  TBT     CHN,GTTRNS              :is okay for transparent to continue?
        JEFS    GDRC54
        TBT     R7,L2MTRN               :if set then zap
        JE      GDRC54                  :everything okay
        TBT     CHN,GORGPT              :start in INET?
        JN      RCRI60                  :return to INET logic
        J       GL2LZP                  :zap with HNET logic
GDRC54  TBT     R7,L2MECH               :start echoing?
        JEFS    GDRC56
        SBT     CHN,GTLGEC              :enable echo
GDRC56  TBT     R7,L2MCI                :flush logon chars
        JE      GDRC60
        LHL     R2,DIOTAB,CHN,CHN
        XHI     R2,4                    :back to dispatcher direction
        NHI     R2,-4                   :remove speed bits
        LHL     R0,BCT,R2,              :any chars to remove?
        JEFS    GDRC60
        JAL     R8,PCIS,,               :zapper waiting
        SIS     R1,3
        JEFS    GDRC60                  :don't remove zapper (i
        JAL     R8,CBCLR,,              :empty buffer
GDRCEX                                  :general exit point
GDRC60  LIS     R0,0                    :have looked at no logon chars
        STB     R0,GLGCNT,CHN,
        TBT     CHN,GORGPT              :start in INET?
        JN      RCRI50                  :finish off wiht INET logic
        SBT     CHN,LOGDAT              :and look for logon chars
        TBT     CHN,GIIXCT              :did we grab a buffer for parsing?
        JE      DSOIRP,,
        LHL     R2,GDBUFT               :get our temp buffer
        JAL     R8,RFCBUF,,             :return our temp buffer
        J       DSOIRP,,                :and done!

GDLSKP  AR      PRD,PRC
        J       DSOIRP,,


:       following are table on tuning echo on, clear input, clear output
:       and send 'please log in: after message MO 04 (norm supe response)
L2MECH  HC      $2 1110011111111100     :turn on echo after these responses
L2MCI   HC      $2 1010111111111100     :empty input towards supe
L2MCO   HC      $2 1000010000000000     :clear output (invalid logon char, esc)
L2MPLI  HC      $2 0000011111111000     :send PLI msg after these response
L2MTRN  HC      $2 1110011111111110     :zap transparent user

        SUBTTL	GATWAY (RCRINC Node Code generated Log2 Logon Failures)

::*****************************************************************
::
::      RCRINC  Node code generated rejects to Log2 logons
::              (0315)
::
::*****************************************************************

       IF       LOGII

RCRINC  JAL     R8,GCI,,                :get reject reason
        LR      R6,R1
        TBT     CHN,GIIXCT              :convert to text or SRRM
        JE      RCRIN4
        LHI     R0,20                   :RCRI followed by zap
        JAL     R8,DIROOM,,             :make sure room for detach
        SIS     PRD,1                   :back to type byte
        LHI     R1,0BF00                :start of IIX
        STH     R1,DIRNG+2,PRD,         :RCRI
        AIS     PRD,2
        NR      PRD,TC
        LIS     R1,0
        STH     CHN,DIRNG,PRD,          :now comes data message with the reason
        AIS     PRD,2
ICRSN2  LB      R0,ICRSRM,R1
        STB     R0,DIRNG,PRD,           :copy canned RCRI
        AIS     PRD,1
        NR      PRD,TC
        AIS     R1,1
        CLHI    R1,RCRISZ
        JLBS    ICRSN2
        AHI     R6,0100                 :len of type
        STH     R6,DIRNG,PRD,
        AIS     PRD,4
        NR      PRD,TC
        STH     PRD,DRIF,,              :message completely written
        LIS     R0,1
        STH     R0,ICRMS1
        J       RCRI27                  :go handle zap type in paralell

RCRIN4  LHL     R4,LM24TB,R6,R6         :get text for this reason
        JAL     R9,BUFCAN,,
        LIS     R1,1
        STH     R1,ICRMS1
        J       RCRI27                  :and zap handling


ICRSRM  HC      1480,8900               :len, iix, first byte of iix len
        BC      10,7F,32,0D,30,0B,5F    :RCRI ID, len, SMOseqID,len
        BC      3E,02,07,00,31,04,5F,24 :RCRI flags, SMOseq id,len
RCRISZ  EQ      .-ICRSRM
        HS      0

       EI       :LOGII
::*************************************************************
:
:       RCRI    writes logon response to dispatcher.  Have to remove
:       (0316)  our orig port, change ID and flagsID, and see if supe
:               sent MO saying this is end of logon session.
:
::*************************************************************

       IF       LOGII

RCRI    TBT     CHN,GIIXCT              :convert to text or leave as is?
        JE      RCRI40                  :go handle non IIX
        SIS     PRD,1                   :given PRD of odd byte
        LHI     R1,0BF00                :send start of IIX
        STH     R1,DIRNG,PRD,
        AIS     PRD,2
        NR      PRD,TC
        STH     CHN,DIRNG,PRD,          :now right iix msg containing RCRI
        AIS     PRD,2
        STH     PRD,RPSAV               :save len of ISIS msg
        LHI     R1,80                   :first byte of IIX msg type 8089
        STH     R1,DIRNG,PRD,
        AIS     PRD,2
        NR      PRD,TC
        LHI     R1,8900                 :2nd byte of 8089
        STH     R1,DIRNG,PRD,           :and clear hisg byte of len
        AIS     PRD,3                   :skip over two bytes of len
        JAL     R9,GHWI,,               :get length of MOs
        LR      PRC,R1                  :save it so we know when to end
        STH     PRD,RPSAV               :save where to write len
        LIS     LRC,0                   :start off with none written
        AIS     PRD,2
        LR      R0,PRC
        JAL     R8,DIROOM,,             :make sure enough room

        JAL     R8,X4CRIZ,,             :init table
        GL      X4CRIZ,X4CCID
        LHI     R4,ID.GOM+MO.AC2
        JAL     R8,X4CCID,,
        LHI     R4,RMOID                :rmo
        JAL     R8,X4CCID,,
        L       R3,BB,R2,,              :start of RCRM
        LHI     R4,ID.RMF               :RCRM flags
        JAL     R7,X4PARS,,
        SKIPAD(RCRI10)
        LHI     R4,ID.RIF               :RCRI flags
        JAL     R8,X4CBID,,             :len in r0, data in buffer
        GL      X4CBID
RCRI10  JAL     R8,X4FXCN,,             :finished with RMO
        LHI     R4,ID.SRJ               :supe rejecting it?
        JAL     R7,X4PARC,,             :continue parsing
        GL      X4PARC
        SKIPAD(RCRI15)
        LIS     R0,1
        JFS     RCRI16
RCRI15  LIS     R0,0
RCRI16  STH     R0,ICRMS1               :save whether we are to zap
        LHI     R4,2011                 :constuctor bit and SMOID
        L       R6,X4TBBG+4*X4TBSZ,,    :find SMO element
RCRI20  AHI     R6,X4TBSZ
        CH      R4,X4T.AP,R6
        JNBS    RCRI20
        L       R3,X4T.DB,R6            :address of beginning of data
        LHL     R0,X4T.LN,R6            :len of SMO
        LHI     R4,SMOID
        JAL     R8,X4CBID,,             :put entire smoset into table
        JAL     R8,X4FXCN,,             :finish RCRI constructor
        JAL     R8,X4CDWR,,             :write element to dispatcher
        GL      X4CDWR,X4FXCN
        JAL     R8,CBCLR,,              :and nothing in the buffer

        LHL     R1,RPSAV
        AIS     LRC,4                   :and include len of IIX header
        STB     LRC,DIRNG,R1,           :save len of written MO
        SIS     LRC,4
        AIS     R1,4                    :find len for IIX msg
        STB     LRC,DIRNG,R1,
RCRI25  LH      R0,ICRMS1               :are we to zap this guy?
        JE      DISI90,,                :no, we are done
        AIS     PRD,3
        NHI     PRD,DRSZ-4              :make fullword pointer for 9F
        STH     PRD,DRIF,,
        TBT     CHN,GTTRNS              :interlink cleared?
        JN      RCRI27                  :not for transparent
        LA      R4,GNGONE,,
        JAL     R9,BUFCAN,,
        ROUTE(ISISN,HOMEN)
        LHI     R1,0D0A
        JAL     R9,W2CI,,
RCRI27  LHI     R1,ZAPPN                :nongobbling zapper
        JAL     R9,W2CI,,
        LIS     R0,0                    :make ZAPV not crash
        STH     R0,GDLGTB,CHN,CHN
        RBT     CHN,DISFLG              :and nothing more to send
        XHI     R2,4
        STH     R0,BF,R2,               :take port out of logon mode
        AIS     LRC,4                   :add in len of zap
        J       DISI90,,

:       down here to handle case of not iix (convert msg to text)

       EI       :LOGII

RCRI40  JAL     R9,GHWI,,               :get len of IIX msg
        LR      PRC,R1                  :know how much to gobble
        LHI     R4,ID.SRJ               :have to know whether to zap
        L       R3,BB,R2,
        JAL     R7,X4PARS
        SKIPAD(RCRI43)
        LIS     R0,1
        JFS     RCRI44
RCRI43  LIS     R0,0
RCRI44  STH     R0,ICRMS1               :indicates whether to zap
        J       GDRC10                  :use logic for other direction

:       RCRI50  return here if everything okay
RCRI50  LH      R0,ICRMS1               :supposed zap this one?
        JN      RCRI25                  :zap
        LHI     R1,LOGMIN+LOGSUP        :got an okay response so setup flags
        STH     R1,BF,R2,
        XHI     R2,4                    :flip to from HNET direction
RCRI53  LR      R0,PRC                  :eat processed RCRM msg
        JAL     R8,RTBFTS,,
        J       DSINXT,,                :done with RCRM msg

:       RCRI60  return here if going to zap transparent
RCRI60  LR      R0,PRC                  :eat RCRM msg
        JAL     R8,RTBFTS,,
        J       RCRI25                  :and do zap


::*****************************************************************
:
:       GDL2BG  a simple routine to move data from the dispatcher to either
:               the IIX msg or to the temp buffer for parsing.  Only for ports
:               in logon mode accepting logon data.
:
::*****************************************************************

GDL2BG  AIS     PRD,2                   :get len
        NR      PRD,TC
        LHL     PRC,DORNG,PRD,          :get len
        AIS     PRD,2
        TBT     CHN,LOGING              :only for ports in login mode
        JE      GDLSKP
        XHI     R2,4                    :back from term direction
        LHL     R1,BF,R2,               :port in login mode
        CLHI    R1,LOGMAX               :this is illegal on a complete circuit
        JG      DSOCRH,,
        CLHI    R1,LOGMIN               :we still want this message?
        JL      GDLSKP                  :ignore message
        XHI     R2,4                    :back to term direction
        TBT     CHN,GIIXCT              :IIX circuit
        JNFS    GDL202
        JAL     R8,GFCBUF,,             :just a place to put msg
        STH     R2,GDBUFT               :save the scratch buffer
        J       GDL204
GDL202  LHI     R1,01F6                 :start IIX
        JAL     R9,W2CI,,
        LHI     R1,8089                 :PTIO
        JAL     R9,W2CI,,
        EXBR    R1,PRC                  :high byte of length
        JAL     R9,WCIE,,
        LR      R1,PRC                  :low byte of len
        JAL     R9,WCIE,,
GDL204  JAL     R8,X4DGCH,,
        JAL     R8,WCI,,
        L       R4,BE,R2,               :where to begin parse
GDL206  JAL     R8,X4DGCH,,             :copy MOs
        JAL     R9,WCIE,,
        LR      PRC,PRC                 :done yet?
        JGBS    GDL206
        LHL     R2,DIOTAB,CHN,CHN       :make sure have to term buffer
        NHI     R2,-4
        LR      R3,R4                   :setup for parse
        JR      R7

        SUBTTL  GATWAY (Logon successfully built to HNET)

::****************************************************************
:
:       LGSC    gateway logon to HNET successfull.  Do accounting Invoice
:       (0317)  number stuff.  If IIX return the LGSC inside the gateway
:               to origination IIX msg.  This routine is written so no
:               gateway switches are needed in LEP0A (log II needle)
:
::****************************************************************

       IF       LOGII

LGSC    JAL     R9,GCIE,,               :indication of LOG II intranode
        L       R7,BB,R2,               :where to begin parse
        LR      R1,R1
        JEFS    LGSC04
        XHI     R2,4                    :internal alerts CRQ of needle after
        JAL     R9,CRQALT,,             :sending LGSC (ISIS dispatcher depends
        XHI     R2,4                    :on receiving LGSC then ISN if internal
LGSC04  TBT     CHN,GIIXCT              :if iix then send info back
        JE      LGSC20                  :not iix, only do accounting
        LHI     R1,8089                 :iix msg from gateway
        JAL     R8,WCD,,
        EXBR    R1,R1
        JAL     R8,WCD,,
        LHI     R1,01F6                 :the start of IIX signal
        JAL     R8,WCD,,
        EXBR    R1,R1
        JAL     R8,WCD,,
LGSC20
       IF       ACCT
	ST	R2,GASTOR
        LR      R3,R7                   :setup for parse
        LHI     R4,ID.INV
        JAL     R7,X4PARS
        SKIPAD(LGSC40)
        JAL     R7,X4GTNM               :get the invoice number
        ST      R4,CQINV
        LHI     R3,DISZFL-MNACHN
	JL	LGSC40
	CLHI	R3,MXACHN-MNACHN
	JG	LGSC40		:Range check on the absolute chan
	JAL	R9,AAMKPT,,	:Make pointer to the accounting block
	L	R0,AAINV,R11	:Get previously stored  Invoice number
	ST	R0,ININV	:Store temporarily
	XI	R0,80000000	:Check high order bit (should be set)
	JL	LGSC40
	JAL	R8,GASTR1,,	:Initiate accounting
	NOP			:Need this 4 bytes for the normal return
	JAL	R10,AASWAP,,	:and swap invoice numbers
	L	R0,AAINV,R11	:R11 still hold accounting pointer, get inv#
	OI	R0,0C0000000	:Mark as origin circuit - do not report
	ST	R0,AAINV,R11
LGSC40	HS	0
	L	R2,GASTOR
	EI	:ACCT

        J       DSINXT,,                :don't actually write anything to ring

       EI       :LOGII


::*****************************************************************
:
:       GDLGSC  Gateway logon succesful.  Do accounting, IRC stuff, and
:               circuit complete stuff.
:
::*****************************************************************

GDLGSC  JAL     R7,GDL2BG               :move into buffer and setup for parse
        LHI     R4,ID.INV               :get invoice number
        JAL     R7,X4PARS
        SKIPAD(GLGZP)                  :invoice number must be there
        JAL     R7,X4GTNM               :get it
        ST      R4,ININV                :save it
       IF       ACCT
        STM     R1,AARGSV
        AHI     CHN,DISZFL              :same routine as in middleof GDB6
        LR      R3,CHN                  :work chn
        CLHI    R3,MNACHN
        JL      GDSC20                  :port number too low
        CLHI    R3,MXACHN               :port number too high?
        JG      GDSC20
        SHI     R3,MNACHN               :account chn
        JAL     R9,AAMKPT               `;:get block pointer
        JAL     R10,AASWAP
GDSC20  LM      R1,AARGSV               :get back regs
       EI       :ACCT
        XHI     R2,4                    :if IIX it will be from terminal dir
        TBT     CHN,GIIXCT              :if not iix then retrun work buffer
        JN      GDB62                   :use old B6 logic to do rest
        LHL     R2,GDBUFT
        JAL     R8,RFCBUF,,             :return work buffer
        LHL     R2,DIOTAB,CHN,CHN       :get back old buffer
        NHI     R2,-4
        XHI     R2,4                    :make it from terminal direction
        J       GDB62


::*****************************************************************
:
:       GDCIMH  Gateway create ICRM header (all MOs upto SMO constructor)
:               Links on R9 and trashes r8,r0,r1,r4
:
::*****************************************************************
 
GDCIMH  JAL     R8,X4CRIZ               :going to have to create XCRM MO
        LHI     R4,IDICRM+MO.AC2
        TBT     CHN,GORGPT              :ICRM or NCRM
        JEFS    GDICM1
        LHI     R4,IDNCRM+MO.AC2
GDICM1  JAL     R8,X4CCID               :create constructor element
        LHI     R4,RMOID                :write RMO id
        JAL     R8,X4CCID
        LHI     R4,ID.IMF+MO.A2         :then come flags
        LHI     R1,0600                 :not an aux request and is initial NCRM
        TBT     CHN,GORGPT
        JEFS    GDCIM3                  :0 if doing INET logon
        LHI     R4,ID.NMF+MO.A2
        TBT     CHN,GMSG0F              :initial msg
        JNFS    GDCIM3
        LHI     R1,0640                 :the 40 is 2nd bit is secondary NCRM
GDCIM3  JAL     R8,X4CRID               :create MO with data in r1
        LHI     R4,ID.OHS+MO.A1         :our orig host
        LHI     R1,IHOST
        TBT     CHN,GORGPT              :0 if INET and use INET host
        JEFS    GDCIM4
        LHI     R1,HHOST
GDCIM4  JAL     R8,X4CRID
        LHI     R4,ID.CCT+MO.A1
        LB      R1,CCTTBL,CHN
        JAL     R8,X4CRID               :add in CCT MO
        TBT     CHN,GORGPT
        JEFS    GDCIM5
        LHI     R4,ID.PRT+MO.A1
        LR      R1,R5                   :and chn number
        JAL     R8,X4CRID
GDCIM5  JAL     R8,X4FXCN               :finish RMO element
        JR      R9
 
::*****************************************************************
:
:       GDCICS  create dispatcher header part of ICRS.  max len in
:               r0, link on r9
::*****************************************************************
 
GDCICS  JAL     R8,DIROOM,,             :make sure enough room
        LHL     PRD,DRIF,,              :get fill pointer
        STH     CHN,DIRNG,PRD,
        LHI     R0,0C400                :ICRS type
        STH     R0,DIRNG+2,PRD,
        AIS     PRD,4
        NR      PRD,TC
        STH     PRD,RPSAV               :save pos for len
        AIS     PRD,2                   :where to start putting the MO
        JR      R9                      :and return
 
 
::*****************************************************************
:
:       GDLCCH  handle logon characters for log 2.  Basic idea is to
:               check first char for zapper, then see if should echo
:               new char (count of already processed in glccnt), if term
:               then create XCRM/ICRS MO, if ball then echo.  If first char
:               IIX then we got OPTI with all MOs already there.
:               Is written to handle logons chars from either INET of HNET
:
::*****************************************************************
 
GDLCCH  LIS     PRC,0                   :enterred from GDB360
        LIS     LRC,0                   :logical char count
        JAL     R8,PCIS,,
        LR      R1,R1                   :escape?
        JE      GDLC30                  :not a signal, go to char logic
        SIS     R1,3                    :is this a zapper type
        JG      GDLC30                  :go to normal char logic
        AIS     R1,3-1                  :is this a SIIX?
        JE      GDLC04                  :go handle OPTI ICRS
:       first char a 03.  only for GDB3IN since LOGSUP already looked
        JAL     R8,PCI,,                :is this a zapper
        CLHI    R1,3                    :03, 00-03 are zappers
        JLE     GDB362                  :goto B3 zap logic
        JAL     R9,G2CI,,               :must have been a gobbler
        J       GDLC99                  :go to handle next port
 
GDLC04  JAL     R8,PCI,,                :is this SIIX or some other signal
        CLHI    R1,0F6                  :SIIX is 01 F6
        JN      GDLC30                  :go handle normal signal
        SIS     CD,4                    :len of SIIX and IIX type
        JL      GDLC99                  :wait on msg to arrive
        JAL     R9,PHWI,,               :better be opti iix msg
        CI      R1,808A                 :opti msg?
        JE      GDLC08                  :yes
        CI      R1,8081                 :dialect selected msg?
        JNFS    GDLC06                  :some weird one, just eat it
        SIS     CD,2                    :type arrived yet?
        JL      GDLC99                  :no, wait for it
        JAL     R9,G2CI,,               :2 for dialect
GDLC06  JAL     R9,G2CI,,               :2 for iix signal
        JAL     R9,G2CI,,               :2 for type
        J       GDLC99                  :and reenter a bit later
 
GDLC08  JAL     R9,PHWI,,               :get len of PTOI
        SIS     CD,3                    :first byte escaped, 2nd byte not
        JL      DSINXT,,                :wait for it to arrive
        CR      R1,CD                   :longer len than arrived?
        JL      DSINXT,,
        STH     R1,GDNLEN               :save len
        LR      R4,R1                   :make working copy
GDLC14  JAL     R9,PCIE,,               :count chars to see if all of ptoi here
        SIS     R1,7
        JGFS    GDLC15
        SIS     CD,1                    :was a two byte len
GDLC15  SIS     CD,1                    :that the physical len is there
        JL      GDLC99
        SIS     R4,1                    :when they haven't arrived yet
        JGBS    GDLC14
 
        JAL     R9,G2CI,,               :remove SIIX signal
        JAL     R9,G2CI,,               :remove iix msg type
        JAL     R9,G2CI,,               :remove iix len
        LIS     LRC,0
        LHL     CD,GDNLEN               :len of msg
        TBT     CHN,GORGPT              :for LOGSUP always like XCRM
        JN      GDLC20
        LR      R0,CD
        AHI     R0,12                   :maximum amount longer
        JAL     R9,GDCICS               :write ISIS ICRS head, max len in r0
        LHL     R1,BF,R2,               :sent XCRM yet?
        THI     R1,LG.TID
        JN      GDLC20
GDLC17  JAL     R9,GCIE,,
        JAL     R8,X4DGCH,,             :transfer characters
        SIS     CD,1
        JGBS    GDLC17
GDLC18  TBT     CHN,GORGPT              :ring stuff only for GDB3IN
        JN      GDLC19
        LHL     R1,RPSAV                :put in len of ISIS msg into msg
        STH     LRC,DIRNG,R1,
        AIS     PRD,3
        NR      PRD,TC
        NHI     PRD,-4                  :fix up pointer
        STH     PRD,DRIF,,
GDLC19  RBT     CHN,LOGDAT              :wait until logon response
        RBT     CHN,GMSG0F              :and we have sent initial msg to supe
        NHI     R1,LOGMIN               :knock off lg.tid and no send
        STH     R1,BF,R2,
        J       GDLC99                  :and done
 
GDLC20  JAL     R9,GDCIMH               :going to have to create XCRM MO
        LHI     R4,ID.UNM               :parse justt to get SMO into table
        L       R3,BB,R2,               :find smo element
        ST      R3,ELEPOS               :use X4PARS's subroutines
        JAL     R9,X4NXID,,             :get ID
        JAL     R9,X4NXEL,,             :point to next element
        JAL     R9,X4NXID,,             :this is SMO element
        LHI     R4,SMOID
        JAL     R8,X4CBID               :element from buffer
        JAL     R8,X4FXCN               :finish constructor
        TBT     CHN,GORGPT              :LOGSUP NCRM or GDB3 ICRS
        JNFS    GDLC25                  :skip to LOGUSP
        JAL     R8,X4CDWR
        J       GDLC27

GDLC25  ST      R2,GESAVE               :write NCRM to supe buffer
        LHL     R2,TVRBUF               :get supe buf
        LR      R7,R2                   :make a copy to prepare for copy
        LHI     R1,MACHNM
        JAL     R9,WHWI,,               :our node #
        LIS     R1,08                   :NCRM is type 8 msg
        JAL     R8,WCI,,
        LB      R1,X4CHLN+X4CTBG,,      :get len of id and len
        AH      R1,X4CLEN+X4CTBG,,      :plus len of elements
        JAL     R9,WHWI,,               :write len of NCRM
        JAL     R8,X4CBWR               :write MOs into supe buffer
        L       R2,GESAVE               :restore buffer with log chars
 
GDLC27  LHL     CD,GDNLEN               :remove forwarded chars from buff
        JE      GDLC18                  :if nothing to remove
GDLC28  JAL     R9,GCIE,,
        SIS     CD,1
        JGBS    GDLC28                  :remove from buffer
        J       GDLC18                  :and setup exit
 
:       GDLC30  handles logon chars for log 2.  Have count of how far
:               peeked into buffer in GLGCNT.  look for terminator and
:               esc and if there then make MO and send to supe.
GDLC30  CLB     CD,GLGCNT,CHN,          :any more new chars?
        JLE     GDLC99                  :nothing new happening
        LB      R4,GLGCNT,CHN,          :count of chars already read
        L       R3,BB,R2,               :first pos in buffer
GDLC32  SIS     R4,1                    :ignore already looked at chars
        JL      GDLC38                  :done ignoring
        JAL     R8,PCI,,
        AIS     LRC,1                   :MO element then logical chars
        SIS     R1,7                    :how many logical chars in buffer
        JGBS    GDLC32
        AIS     R1,7                    :originally an escape?
        JNFS    GDLC34
GDLC33  JAL     R8,PCI,,                :then get escaped char
        SIS     R4,1
        J       GDLC32
GDLC34  SIS     LRC,1                   :some signal
        SIS     R1,3
        JG      GDLC32                  :a one byte signal
        JBS     GDLC33                  :remove 2nd byte
 
:       finally made it to a place to look at new chars
GDLC38  LB      R0,GLGCNT,CHN,          :how many previously looked at
        LR      PRC,CD                  :number in buffer
        SR      PRC,R0                  :count of max new ones to check
:       where to loop for next chars
GDLC39  SIS     PRC,1                   :make sure not out of chars yet
        JGEFS   GDLC40
        STB     CD,GLGCNT,CHN,          :moved all that was in buffer
        J       GDLC99
GDLC40  JAL     R8,PCI,,                :get new char
        CLHI    R1,7
        JG      GDLC42
        LR      R1,R1                   :check if it really is char
        JN      GDLC60                  :go handle the signal
        JAL     R8,PCI,,
        SIS     PRC,1
GDLC42  AIS     LRC,1                   :another logical char
        LR      R7,R1                   :make a copy to retain parity
        NHI     R7,7F                   :knock off high bit
        CLHI    R7,1F                   :a char we might echo?
        JLE     GDLC45
        TBT     CHN,GTECHO              :we got an echoable terminal?
        JE      GDLC44
        TBT     CHN,GTLGEC              :in an echoing state?
        JEFS    GDLC44
        XHI     R2,4
        JAL     R9,WCIE,,
        XHI     R2,4
GDLC44  CLHI    R7,3B                   :is this a semi colon?
        JN      GDLC39                  :nope get next char
        RBT     CHN,GTLGEC              :remember not to print 'password'
        J       GDLC39                  :LOG II waits until CR or ESC term
 
GDLC45  CLHI    R7,0D                   :a carriage return?
        JE      GDLC72                  :go handle terminating char
        CLHI    R1,1B                   :an esc?
        JE      GDLC70                  :another type of terminating char
        CLHI    R1,08                   :control-h?
        JNFS    GDLC47
        SBT     CHN,GTHDX               :halfduplex
        RBT     CHN,GTECHO              :no more echoing
        J       GDLC39
GDLC47  CLHI    R1,4
        JG      GDLC39                  :a gouging char?
        SIS     R1,1
        OH      R1,DIOTAB,CHN,CHN       :save gouging level 00-03
        STH     R1,DIOTAB,CHN,CHN
        J       GDLC39
 
:       here to handle signals.  Echo red and green balls, bounce orange
:       for yellow.
GDLC60  CLHI    R1,5                    :green ball
        JEFS    GDLC61
        CLHI    R1,6                    :red ball
        JNFS    GDLC62
GDLC61  XHI     R2,4
        JAL     R8,WCI,,
        XHI     R2,4
        J       GDLC39                  :bounced ball, return for next char
GDLC62  CLHI    R1,3
        JG      GDLC39                  :ignore other 1 byte signals
        SIS     R1,1                    :could this be the yellow ball
        JN      GDB362                  :go handle zapper types
        JAL     R8,PCI,,                :get second byte of 01 type
        SIS     CD,1                    :mark another char read
        CLHI    R1,0FF                  :yellow ball?
        JN      GDLC39                  :ignore other signals
        XHI     R2,4
        LHI     R1,01FE                 :the orange ball signal
        JAL     R9,W2CI,,
        XHI     R2,4                    :bounced orange for yellow
        J       GDLC39                  :get next char
 
:       GDLC70 GDLC72   handle when termination.  Write XCRM head if not sent
:               yet, else send ICRS MO.  Put logon chars (or ESC indication)
:               HDX, throughput class, IIX if XCRM and then send it
 
:       Handle ESC to send ESC indication
GDLC70  LIS     LRC,0                   :ESC has no logical len
:       handle CR and sent logon data
GDLC72  LR      CD,R3                   :remember to eat chars upto this point
        TBT     CHN,GORGPT              :LOGSUP NCRM always need GDCIMH
        JNFS    GDLC74
        LHL     R1,BF,R2,               :sent CCT with initial stuff yet
        THI     R1,LG.TID
        JEFS    GDLC75                  :not initial msg
GDLC74  JAL     R9,GDCIMH               :write XCRM and it's RMOs
        JFS     GDLC77                  :and go on to write SMOset
GDLC75  JAL     R8,X4CRIZ
        LHI     R4,IDICRS+MO.AC2        :write ICRS constructor
        JAL     R8,X4CCID               :as a constructor
GDLC77  LHI     R4,SMOID
        JAL     R8,X4CCID               :write SMO constructor
        LR      LRC,LRC                 :esc or logon chars
        JE      GDLC80                  :if esc then go to it
        L       R3,BB,R2,               :chars start at beg of buffer
        LR      R0,LRC                  :LRC has number of chars
        LHI     R4,ID.ULC+MO.A1         :logon chars id
        JAL     R8,X4CBID               :add to create element table
        LHL     R1,DIOTAB,CHN,CHN       :get speed bits
        NHI     R1,3                    :only two bits for speed
        LHI     R4,ID.TPC+MO.A1
        JAL     R8,X4CRID               :write Tclass element
        TBT     CHN,GTHDX               :if hdx then send hdx indication
        JE      GDLC81
        LHI     R4,ID.HDX+MO.A1         :write HDX element
        JAL     R8,X4CBOL
GDLC80  LHI     R4,ID.ESC               :esc indication
        JAL     R8,X4CBOL               :boolean and true
GDLC81  LHL     R1,BF,R2,               :send IIX if initial msg
        THI     R1,LG.TID
        JEFS    GDLC83                  :not initial
        TBT     CHN,GIIXCT              :IIX circuit
        JEFS    GDLC83
        LHI     R4,ID.RIX+MO.A1         :request iix element
        JAL     R8,X4CBOL
GDLC83  JAL     R8,X4FXCN               :finish SMO constructor
        JAL     R8,X4FXCN               :finish overall constructor
        LR      R3,CD                   :remove used chars from buffer
        JAL     R9,TRUNC,,
        LIS     CD,0                    :nothing for GDLC25 to remove
        STH     CD,GDNLEN
        TBT     CHN,GORGPT              :1 if logsup
        JN      GDLC25                  :let it write supe NCRM msg

        LHL     R0,X4CTBG+X4CLEN,,      :get len of MOs
        AHI     R0,0C                   :max len of stuff upto len field
        JAL     R9,GDCICS               :write ICRS isis msg
        JAL     R8,X4CDWR               :write MOs from buffer
        J       GDLC18                  :and general exit routine
:       exit to correct direction

GDLC99  TBT     CHN,GORGPT              :1 if INET home
        JE      GDINXT                  :GDB3IN return
        J       LOGXIT                  :LOGSUP return



       EI       :LOGII
::*****************************************************************
:
:       GL2LZP  handles if we now want to zap circuit after a logon response
:       GLGZP   is called by GDB4 and GDB5 when they want to zap a circuit in
:               logon mode.
:
::*****************************************************************

       IF       LOGII                   :just the top few lines

GL2LZP  TBT     CHN,GIIXCT              :return temp buffer
        JEFS    GL2LZ1
        LHL     R2,GDBUFT
        JAL     R8,RFCBUF,,
GL2LZ1  LHL     R2,DIOTAB,CHN,CHN
        NHI     R2,-4                   :make sure have orig buffer
        XHI     R2,4                    :point back to term direction

       EI       :LOGII                  :just fall through if log ii

:       following is entry for LOG I gateways
GLGZP   TBT     CHN,GTTRNS              :transparent get no cleared msg
        JE      GLGZP1
        LA      R4,GNGONE,,
        JAL     R9,BUFCAN,,             :interlink cleared
        ROUTE(HOMEN,ISISN)
        LHI     R1,0D0A
        JAL     R9,W2CI,,
GLGZP1  LHI     R1,ZAPPN                :don't eat that wonderful msg
        JAL     R9,W2CI,,               :write non gobbling back to user
        LHI     R1,9F00                 :kill isis side immediately
        JAL     R8,DIRMES,,
        LIS     R0,0
        STH     R0,GDLGTB,CHN,CHN       :pass one of our checks
        lis     r0,aalr02               :zapped by host
        sth     r0,aareas,,             :save reason for termanation
        lhi     r3,diszfl-mnachn,chn    :get absolute accounting chn
        jal     r8,aarlo,,              :do termation accounting
        lis     r0,0                    :clear accounting reason area
        sth     r0,aareas,,
        XHI     R2,4                    :flip to from term side
        STH     R0,BF,R2,
        RBT     CHN,LOGING              :clean up dispi side
        JAL     R9,GLZPV,,              :really clear it
        lcs     r0,1
        ahm     r0,hnport               :fewer ports in use
        J       DSOIRP,,                :and contiue processing


::*********************************************************************
::
::	ENTRY POINT	GLZ9:
::	FUNCTION:	Handles a Pseudo Needle Reject (Type 09) for Gateway.
::	CALLS:		JAL	R9,BUFCAN
::			JAL	R9,ZAPX,,
::	RETURNS:	J	DSOIRP,,
::
::*********************************************************************
GLZ9	HS	0			:Pseudo Needle reject
	AIS	PRD,4           :Advance ring pointer
	NR	PRD,TC		:Move pointer to local key
::                       First, check to ensure that this is the correct circuit
	LHL	R2,DORNG,PRD,	:Local key should be buffer number
:                               :The BF should indicate Log-in state
	AIS	PRD,3
	NR	PRD,TC
	LHL	R1,BF,R2,	:Get flags field
	CLHI	R1,LOGMAX
	JG	DSOCRH,,
::BF shows in Log-in state .. proceede
: Since host shuts when we don't have INET supe this can only happen to
: needles built before HNET got our shut msg.
        jal     r9,g2ci,,               :needle point
        jal     r9,g2ci,,               :length
        jal     r9,g2ci,,               :link count
        jal     r9,ghwi,,               :start of invoice number
        sth     r1,cqinv                :save 1st 1/2 of inv
        jal     r9,ghwi,,               :2nd hw of inv
        sth     r1,cqinv+2
        lhi     r5,diszfl               :dispatcher port 0 is never used
                                        :so momentarily use its accounting
                                        :block.
        jal     r8,aastrt,,             :initialize accounting
        j       glz9p9
        lis     r0,aalr02               :zapped by host
        sth     r0,aareas
        jal     r8,aarlo,,              :send termination accounting
glz9p9  
	XHI	R2,4			:Point to outbound (to terminal) buf
        LHI     R1,ZAPPN                :
        JAL     R9,ZAPX,,
	LIS	R1,1
	AHM	R1,NC.CRZ		:Count uncompleted circuit for CRQ
	J	DSOIRP,,		:AND QUIT FOR NOW

::*****************************************************************
:       GDECRI  handle reject of ICRM.  Simply convert into text
:               and follow with a nongobbling zapper
:
::*****************************************************************

       IF       LOGII                   :Only for log ii
GDECRI  AIS     PRD,1
        NR      PRD,TC                  :hw of len
        LHL     PRC,DORNG,PRD,
        AIS     PRD,4                   :Point to local key
        NR      PRD,TC
        LHL     R2,DORNG,PRD,           :it was our buffer number
        AR      PRD,PRC
        SIS     PRD,4                   :have PRD to end of msg
        LHL     R0,BF,R2,
        CLHI    R0,LOGMAX               :on some unbuilt port
        JG      DSOCRH,,
        XHI     R2,4
        LA      R4,GNONET,,
        JAL     R9,BUFCAN,,
        LHI     R1,ZAPPN                :detach
        JAL     R9,ZAPX,,
        LIS     R1,1
        AHM     R1,NC.CRZ               :another unable to complete
        J       DSOIRP,,

       EI       :LOGII


::*********************************************************************
::
::	ENTRY POINT	G02NUP:	##AL
::	FUNCTION:	Handles INET node taken up. (Type 02) for Gateway.
::	CALLS:		JAL	R10,SUP11
::	RETURNS:	J	DSOIRP
::
::*********************************************************************
G02NUP	HS	0
        LB      R1,DORNG+3,PRD,         :new supe number
        JNFS    G02NU1                  :ISIS 5.08 puts a zero here
        LHI     R1,7F                   :not a real supe # but nonzero
G02NU1  STB     R1,G0DFG                :save supe
	AIS	PRD,4			:ADVANCE MSG LENGTH IN PTR
	NR	PRD,TC			:WRAP TO A HW
        LIS     R10,0                   :init answerred
        LHL     R1,TVRBUF               :have Hnet supe?
        JNFS    G02NU2                  :yes
        LIS     R10,2                   :shut if not
G02NU2  LB      R1,HSTAT                :what was old host stat
        STB     R10,HSTAT               :save host status
        CR      R1,R10                  :find if any changes
        JE      DSOIRP,,                :no changes to report
	JAL	R10,SUP11,,		:HST RPT FROM GW TO HNET SUP
        LB      R3,HSTAT                :it wants our status.
        JAL     R10,GHSTST              :tell inet about us
	J	DSOIRP,,

::*********************************************************************
::
::	ENTRY POINT	G0DNSP:	##AL
::	FUNCTION:	Handles INET no sup. (Type 0d) for Gateway.
::	CALLS:		JAL	R10,SUP11
::	RETURNS:	J	DSOIRP
::
::*********************************************************************
G0DNSP	HS	0
	AIS	PRD,4			:ADVANCE MSG LENGTH IN PTR
	NR	PRD,TC			:WRAP TO A HW
	LIS	R1,2			:set host shut
	STB	R1,HSTAT
	LIS	R1,0                    :no supe on INET side
	STB	R1,G0DFG		:SET A FLAG FOR NODE TAKEN AGAIN
	JAL	R10,SUP11,,		:HST RPT FROM GW TO HNET SUP
	J	DSOIRP,,

IIXGW	XC	0801F68080808201F7	:IIX REACHED GATEWAY MSG (SELECT GW DIALECT)
IIXMS1	XC	0601F680840001		:IIX 'PLEASE LOG IN' MSG
IIXLMS	XC	0401F68084		:START OF IIX LOGIN STATUS MSG


::*********************************************************************
::	DIRECT ENTRY-
::	SUBROUTINE:	GNEDIN:	Gateway NEDle IN
::	FUNCTION:	Gateway Needle front end handler.  Called from
::			DISKIP+0A when a Needle is received on an un-
::			assigned Dispatcher port.  (This is only legal
::			for the Gateway.)  This routine serves to initiate
::			Gateway Log-on processing from the INET side.
::	CALLING SEQ:	JE	GNEDIN	:(based on getting Type 00 on port)
::	INPUT:		CHN	=  Dispatcher Port Number
::			PRD	=  Pointer to data in ring (empty cursor)
::	CALLS:		
::	RETURNS:	Returns to previously stored R8 return address
::			to jump to DSONXT.
::
::*********************************************************************

GNEDIN	HS	0		:Gateway gets Needle from Dispatcher on port #
	ST	R8,GDSAVE	:Save return address 
	STH	PRD,GDPRD	:Save PRD for restoration of ring pointer
	LB	R8,DORNG+3,PRD,	:Gets length of total Needle
	STB	R8,GDNLEN
	AIS	PRD,4
	NR	PRD,TC		:Now we're pointing to Invoice number
	L	R1,DORNG,PRD,	:Get INvoice #
	ST	R1,GDNINV	:Save this temporarily
	AIS	PRD,4
	NR	PRD,TC		:Now we're pointing at Dest. Host #
	LHL	R1,DORNG,PRD,	:Get Desination Host number (should
	CHI	R1,IHOST	: be IHOST for Gateway)
	JN	GDNERR		: Error, zap circuit
        JAL     R7,GNEIZ        :initialize flags and arrays and logon  ###sdw
	IF	ACCT
::Store invoice number for internet exchange
        LHI     R3,DISZFL-MNACHN,CHN  :convert to relative account chn
	JL	GNED01 
	CLHI	R3,MXACHN
	JG	GNED01
	JAL	R9,AAMKPT	:Get pointer to accounting block
	L	R0,GDNINV	:Get previously stored invoice number
	OI	R0,80000000	:Set HO bit to indicate primary inv #
	ST	R0,AAINV,R11	:Store in Acct. blk
	EI	:(ACCT)

::Now begin to fill log-on buffer, starting with Host number
GNED01	LHI	R1,HHOST	:This log-on is from INET toward HNET
	OHI	R1,8000		:Prepare host # for Sup message
	JAL	R9,WHWI,,	:Write into login buffer
	
	AIS	PRD,08
	NR	PRD,TC		:Now pointing to word with TPC at end
	LB	R1,DORNG+3,PRD,	:Get TPC
	STB	R1,GDTPC	: and store for later use
	AIS 	PRD,4
	NR	PRD,TC		:Now pointing to Dialect and TID
	LHL	R1,DORNG,PRD,	:Get dialect field
	STH	R1,GDDIAL	:Store for later

::Determine intelligence of circuit
	EXHR	R1,R1		:Less than 0 = HO bit set
	JGEFS	GNED02		:Not IIX, proceed
	SBT	CHN,GIIXCT	:Indicate as IIX circuit
	
GNED02	LHL	R1,DORNG+2,PRD,	:Get CCT and usrname size
	STH	R1,GDCCT	:and store for later
	EXBR	R1,R1		:Get CCT byte
	STB	R1,CCTTBL,CHN	:and table it for possible future reference???
	AIS	PRD,4
	NR	PRD,TC		:Now points to beginning of username

::Write whatever TID we have into buffer with Cntrl chars if needed
	LBR	R6,R1		:Save TID
	NHI	R1,1F		:Mask to get TID
	JE	GNEAUX		:If Aux-circuit TID (00)
	THI	R6,20		:If Half-Duplex TID
	JEFS	GNE010		:Not Hdx, more tests ...
	SBT	CHN,GTHDX	:Mark this one as Half dux
	J	GNE020
GNE010	LHI	R0,-8,R1	:If not Hdx then what about oddball 2741 etc.
	JL	GNE020		:Test for 2741 or 3767 terminal types
	SIS	R0,9-8
	JGFS	GNE020
	SBT	CHN,GTHDX	:This oddball is HDX
	RBT	CHN,GTECHO	:No echo allowed
	RBT	CHN,GTASCI	:A special distinction as HDX ascii 2741
	JFS	GNE020		:Now write it to buffer
GNEAUX	SBT	CHN,GTAUX	:Mark this one as Aux circuit
	RBT	CHN,GTECHO	:Suppress echo for Aux circuit
	LHI	R1,GAXTID	:Exchange for Gateway Aux TID '0E'
	JFS	GNE021
GNE020	LBR	R1,R6		:Get TID again
	OHI	R1,0C0		:Restore mask

GNE021	JAL	R8,WCI,,	:Write TID into buffer
        JAL     R8,CBCCT,,      :how many already in buffer
        STB     R1,GLGCNT,CHN,

::Continue processing with Username treatment
	TBT	CHN,GTHDX
	JEFS	GNE024
	LHI	R1,88		:For Half Duplex terminal
	JAL	R8,WCI,,	:Put CNTRL-H into buffer
GNE024	LB	R4,GDUNSZ	:Load username counter
	LB	R0,DORNG,PRD,	:First username character
	CLHI	R0,GXPRNT	:Is it "?" (0BF) ? (Transparent gateway user)
	JN	GNE026		:If not, flush name and continue

::For Transparent user, just copy Username
	AIS	PRD,1
	NR	PRD,TC		:Discard ?(BF) preceeding username
	SBT	CHN,GTTRNS	:Set as Transparent user
	RBT	CHN,GTLGEC	:Turn echo off
	LB	R1,GDTPC	:Get Througput class
	NHI	R1,3		:ONLY 2 bits on
	LB	R1,TPTBL,R1	:Get ascii from table
	JAL	R8,WCI,,	:Write cntrl-char for tput class to buffer

GNE025	SIS	R4,1		:Decrement counter (from usrnm+1)
	JEFS	GNE030		:Finished? then continue logon

	LB	R1,DORNG,PRD,	:Get Username character
	JAL	R8,WCI,,	:Put into log-on buffer
	AIS	PRD,1
	NR	PRD,TC
	J	GNE025		: until all characters transferred

GNE026	LB	R0,GDUNSZ
	AR	PRD,R0
	NR	PRD,TC		:Flush Username
	IF	0:EV1	(possible future implementation)
	LB	R1,GDTPC	:Get Througput class
	NHI	R1,3		:ONLY 2 bits on
	LB	R1,TPTBL,R1	:Get ascii from table
	JAL	R8,WCI,,	:Write cntrl-char for tput class to buffer
	EI	:EV1
GNE030	HS	0		:Send banners etc. to terminal
	XHI	R2,4		:Flip to terminal bound buffer
	TBT	CHN,GIIXCT	:If IIX circuit
	JEFS	GNE032		:No
	LA	R4,GIIXGW	:If IIX, send 'reached IIX Gateway"
	JAL	R9,BUFCAN,,	:Send it
GNE032	TBT	CHN,GTTRNS
	JN	GNE035		:Yes, don't send banner

GNE033	LA	R4,GNETOK,,	:If not Xprnt nor IIX send 'interlink' banner
	JAL	R9,BUFCAN,,
	ROUTE(ISISN,HOMEN)
	LA	R4,CRLF
	JAL	R9,BUFCAN,,
	LA	R4,LTX000,,
	TBT	CHN,GIIXCT
	JEFS	GNE034
	LA	R4,GIXPLI	:If IIX load IIX PLI message
GNE034	JAL	R9,BUFCAN,,


GNE035	TBT	CHN,GIIXCT	:See if 'smart' bit is set
	JEFS	GNE037		:No bit set, proceeed
	LHL	R4,BF,R2,
	LHL	R1,IOTAB,R4,R4
	AIS	R1,1		:'Gouging --  bit in LOg-in mode
	STH	R1,IOTAB,R4,R4	:means 'smart' 

GNE037	XHI	R2,4		:back to logon (to sup) buffer
        J       GNEXIT

::*********************************************************************
::
::	ENTRY POINT:	GDNERR:	Gateway Dispatcher NEedle ERRor
::	FUNCTION:	Sends Zap back on Dispatcher port which had 
::			sent a Needle on an unassigned port - due to
::			some circuit building error.
::	CALLING SEQ:	JUMP directly to GDNERR
::	INPUT:		CHN 	= Channel (relative dispatcher port)
::	RETURNS:	Jumps directly to GNEDIN exit point.
::
::*********************************************************************
GDNERR	HS	0
	LHI	R1,9F00
	JAL	R8,DIRMES,,		:Send zapper on Dispatcher port
	J	GNEXIT			:And finish turn off


::*********************************************************************
::
::	GNOSUP:		Sends "unable to complete inter-link" to terminal 
::			user -  due to no Supervisor on the HNET side
::	CALLING SEQ:	JUMP directly to GNOSUP
::	INPUT:		CHN 	= Channel (relative dispatcher port)
::	RETURNS:	Jumps directly to GNEDIN exit point.
::
::*********************************************************************
GNOSUP	HS	0		:put nonet towards dispatcher
	LA	R1,GNONET,,
	JAL	R8,DIMMES,,
	LHI	R1,9E00		:Must Zap incoming circuit
	JAL	R8,DIRMES,,

::Now all Needle front end for Log-on buffer is complete - restore
::ring pointer and return exit to DSONXT

GNEXIT	HS	0
	LB	R0,GDNLEN	:Get additional length of needle
	AIS	R0,4		:Make it total length
	LHL	PRD,GDPRD	:Restore pre-needle ring pointer
	AR	PRD,R0		:..and do virtual flush of needle
	NR	PRD,TC
	STH	PRD,DROE,,	:Update ring pointer
	L	R8,GDSAVE	:Restore return address
	JR	R8		:Return to Dispatcher processing


::*****************************************************************
:
:       GDISN   Received a log II needle (the ISN).  Do normal needle
:               setup then go to GDBONE (BOdy NEedle processing)
:
::*****************************************************************

       IF       LOGII

GDISN   ST      R8,GDSAVE               :our return(always DSONXT)
        AIS     PRD,4
        NR      PRD,TC                  :point to len
        LHL     PRC,DORNG,PRD,          :get len
        SIS     PRD,2                   :setup so if GNEIZ wants to zap
        STH     PRC,GDNLEN
        STH     PRD,GDPRD
        LB      R1,NEWSUP               :log II HNET supe?
        JE      GNOSUP                  :tell them no supe
        JAL     R7,GNEIZ                :initialize everything
        SBT     CHN,DISLG2
        AIS     PRD,6                   :point to the first MO
        NR      PRD,TC
:       Copy ISN into buffer so it can easily be parsed
GDIS01  JAL     R8,X4DGCH,,             :get char
        JAL     R9,WCIE,,               :write it to buffer
        SIS     PRC,1
        JGBS    GDIS01
        AIS     PRD,3                   :flush from dispatcher ring
        NR      PRD,TC
        NHI     PRD,-3                  :round up to next word
        STH     PRD,DROE,,
        JAL     R8,CBCCT,,              :get len (for GDBONE)
        STH     R1,GDNLEN               :save len into buffer
        L       R3,BB,R2,
        LHI     R4,ID.INV
        JAL     R7,X4PARS               :get invoice number
        SKIPAD(GDISZP)                  :zap (some error)
        JAL     R7,X4GTNM,,             :get actual invoice number
        ST      R4,GDNINV
	IF	ACCT
::Store invoice number for internet exchange
        LHI     R3,DISZFL-MNACHN,CHN  :convert to relative account chn
	JL	GNED01 
	CLHI	R3,MXACHN
	JG	GNED01
	JAL	R9,AAMKPT	:Get pointer to accounting block
	L	R0,GDNINV	:Get previously stored invoice number
	OI	R0,80000000	:Set HO bit to indicate primary inv #
	ST	R0,AAINV,R11	:Store in Acct. blk
	EI	:(ACCT)

        J       GDBONE                  :go to generalized needle handling

GDIS20  LHL     R2,TVRBUF               :get supe buffer to write NCRM
        LHI     R1,MACHNM
        JAL     R9,WHWI,,               :write machine number
        LHI     R1,0880                 :type 08 with fill byte 80
        JAL     R9,W2CI,,
        LB      R1,X4CTBG+X4CHLN,,      :get len of NCRM ID and len
        AH      R1,X4CTBG+X4CLEN,,      :add in len of constructor
        JAL     R9,WHWI,,               :NCRM msg now has HW of len
        JAL     R8,X4CBWR               :write element into buffer
        RBT     CHN,GMSG0F              :first msg sent
        LHI     R1,LOGMIN+LOGSUP
        LHL     R2,DIOTAB,CHN,CHN       :get back our buffer
        NHI     R2,-4
        STH     R1,BF,R2,               :set flags as msg sent
        J       DSONXT,,                :done

GDIS40  LA      R4,GNETOK,,             :interlink est
        JAL     R9,BUFCAN,,
        ROUTE(HOMEN,ISISN)
        LHI     R1,0D0A
        JAL     R9,W2CI,,
        J       DSONXT,,

:       handle needle error after having done CRQHCR and GFCBUF
GDISZP  JAL     R8,RFCBUF,,             :return buffer
        RBT     CHN,DISZNK              :expect zap ack
        LHI     R1,9F00
        JAL     R8,DIRMES,,
        J       DSONXT,,


       EI       :LOGII


::*****************************************************************
:
:       GNEIZ   initialize all of the flags and arrays for a INET needle
:               (both LOG I and LOG II INET needles).  Link on R7,      ###sdw
:
::*****************************************************************

GNEIZ   HS      0
:       Check to see if Sup exists -- either proceeed or abort
	LHL	R3,TVRBUF
	JE	GNOSUP		:Output "NO Net" message to INET user
:       Now set up Log-on buffer
	JAL	R8,GFCBUF,,	:Get a free buffer (returned in R2)
	SKIPAD(GDNERR)		:immed return - Error, zap circuit	###wjl
	AHI	CHN,DISZFL	:Make Dispatcher port into absolute CHN
	JAL	R9,CRQHCR,,	:+4 return - Build half circuit to buffer
        SHI     CHN,DISZFL      :back to rel dis chn

:       Initialize all log-on related bit arrays
	RBT	CHN,GTAUX	:Aux circuit thru Gateway
	RBT	CHN,GTHDX	:For Half-Duplex terminals
	SBT	CHN,GTASCI	:Not a 2741 TID
	SBT	CHN,GTECHO	:Echo permitted for this terminal
	SBT	CHN,GTLGEC	:Start log-in in Echo mode
	RBT	CHN,GTTRNS	:Assume non-transparent user
	RBT	CHN,GIIXCT	:Assume non-IIX circuit
	RBT	CHN,DISELS	:Not Extended log-on status (for node code)
	RBT	CHN,DISAUX	:Not Aux circuit (for node code)
	LIS	R0,0		:Initialize logon character counter
	STH	R0,GDLGTB,CHN,CHN
	SBT	CHN,DISBPV	:Release back pressure
	SBT	CHN,LOGING	:Mark as in Log-on state
	SBT	CHN,GMSG0F	:..and having data for the Log-in
	LHI	R0,INXLIM
	STH	R0,DIXLIM,CHN,CHN	:Set up transmit limit
	SBT	CHN,GORGPT	:Mark channel as an originating port
	RBT	CHN,GDSTPT
	LR	R1,R2
	LIS	R2,LOGBUF	:Put buffer on LOGGER's list
	JAL	R9,WHWI0,,
	LHI	R0,LGST.N	:Init N.C. & TID ready flag
	STH	R0,BF,R1,	:Set BF to log-on state
	LR	R2,R1
	SRLS	R2,1		:Set buffer timer index
	L	R9,SLOWC,,
	AHI	R9,GLGTMR	:Set 2 minute timer
	ST	R9,BUFTIM,R2,
	SLLS	R2,1		:restore buffer index

	LHL	R1,HNPORT	:Increment  port counter
	AIS	R1,1
	CLH	R1,MXPORT
	JLEFS	GNEMXP		:Not a new peak
	STH	R1,MXPORT	:otherwise store it
GNEMXP	STH	R1,HNPORT
	LHI	R1,HHOST	:Housekeeping - store host number for
	STH	R1,DHSTIX,CHN,CHN	:possible circuit trace
        JR      R7              :and done




::Throughput class table indexed by TPCLASS field in ISIS Needle
TPTBL	BC	81,82,83,84	:CNTRL-A, B, C, D.

::Various messages for Log-on processing from INET to HNET

GIIXGW	XC	0801F68080808201F7	:IIX reached Gateway(select GW dialect)
GIIXG2	XC	0801F68080809401F7	:LOG II Gateway dialect
GIXPLI	XC	0601F680840001		:IIX 'Please Log In'



::*********************************************************************
::
::	SUBROUTINE:	DIZSMS:
::	FUNCTION:	Moves canned control messages to dispatcher input
::			ring on Dispatcher Port, toward Slot 0. (for Gateway)
::			Port is supplied to message template or defaulted to 0.
::	CALLING SEQ:	JAL	R8,DIZSMS
::	INPUT:		R3 = length of string
::			R1 = address of message 
::	REGISTER USAGE:	
::			R0 = character being moved
::			R14 = work register
::			R15 = drif ( DISPI input ring fill pointer)
::
::*********************************************************************

DIZSMS	HS	0
	STM	R14,DIMMSV		:SAVE WORKING REGISTERS
	LR	R14,R8			:SAVE RETURN REGISTER
	LR	R0,R3			:GET LENGTH
	ST	R3,DZLEN		:Store length for a while
	AIS	R0,6			:ALLOW FOR MAXIMUM MESSAGE SIZE
	JAL	R8,DIROOM,,		:WAIT FOR ROOM
	LHL	R15,DRIF,,		:GET FILL POINTER
	L	R3,DZLEN		:Get length to initialize
DIZS01	HS	0
	LB	R0,0,R1			:GET CHARACTER
	STB	R0,DIRNG,R15,		:PUT IT IN RING
	AIS	R1,1			:UPDATE MESSAGE POINTER
	AIS	R15,1			:MOVE FILL POINTER
	NHI	R15,DRSZ-1
	SIS	R3,1			:DONE?
	JN	DIZS01			:NO, CONTINUE
	AIS	R15,3
	NHI	R15,DRSZ-4
	STH	R15,DRIF,,		:DONE
	LR	R8,R14			:RESTORE LINK REG
	LM	R14,DIMMSV		:RESTORE WORKING REGS
	JR	R8			:RETURN


::*********************************************************************
::
::	SUBROUTINE:	GCKPST:
::	FUNCTION:	Informs Slot 0 if Gateway has port sts changed,
::			Also informs Hnet sup when out of ports.
::	CALLING SEQ:	JAL	R10,GCKPST	
::	INPUT:		R3	=  current port value
::	OUTPUT:		Message on Port 0 to Dispacher  (Type 0A)
::	RETURNS:	JR	R10
::
::*********************************************************************

GCKPST	HS	0		:
	LR	R3,R3		:GAVPTS=0?
	JN	GCKP01
	LR	R4,R3		:SAVE R3
	LHL	R2,TVRBUF	:SUP PRESENT?
	JE	GCKP02		:SKIP IF NO SUP BUF
	LHI	R1,8000+MACHNM	:SENT 148F OUT OF PORTS TO HNET SUP
	JAL	R9,WHWI,,	: 6 BYTES MSG
	LHI	R1,148F		:GW TO SUP MSG
	JAL	R9,WHWI,,
	LHL	R1,HOSTN	:GW SLOT HOST NO.
	JAL	R9,WHWI,,
	LHI	R1,1
	STB	R1,MG148F	:SET SENT FLAG
	LR	R3,R4		:RESTORE R3
	J	GCKP02
GCKP01	LB	R1,MG148F	:CHECK 148F SENT FLAG
	JE	GCKP02		:SKIP IF IT'S NOT SENT
	LHL	R2,TVRBUF	:SUP PRESENT?
	JE	GCKP02		:SKIP IF NO SUP BUF
	LR	R4,R3		:SAVE R3
	LHI	R1,8000+MACHNM	:SENT 1490 HST HAS PORTS TO HNET SUP
	JAL	R9,WHWI,,	: 6 BYTES MSG
	LHI	R1,1490		:GW TO SUP MSG
	JAL	R9,WHWI,,
	LHL	R1,HOSTN	:GW SLOT HOST NO.
	JAL	R9,WHWI,,
	LHI	R1,0
	STB	R1,MG148F	:RESET SENT FLAG
	LR	R3,R4		:RESTORE R3
GCKP02	CLH	R3,DZ0APT	:Compare with the last port value
	JER	R10		:Return if same port,no change
	STH	R3,DZ0APT	:Insert new port value in message
	LA	R1,GDZ0AM,,	:Get address of message
	LHI	R3,GDZ0AL	:and get length of message
	JAL	R8,DIZSMS	:Output to Dispatcher on port Zero
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	GHSTCT:
::	FUNCTION:	Informs Slot 0 that Gateway Inet host has cost
::	CALLING SEQ:	JAL	R10,GHSTCT
::	INPUT:		None
::	OUTPUT:		Message to Port 0 of Dispacher  (Type 0C)
::	RETURNS:	JR	R10
::
::*********************************************************************

GHSTCT	HS	0
	LA	R1,GDZ0CM	:Get address of message
	LIS	R3,GDZ0CL	:and get length of message
	JAL	R8,DIZSMS	:Output to Dispatcher on port Zero
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	GHSTST:
::	FUNCTION:	Informs Slot 0 that Gateway has host and status
::	CALLING SEQ:	JAL	R10,GHSTST	
::	INPUT:		R3	=  Status of host
::	OUTPUT:		Message on Port 0 to Dispacher  (Type 10)
::	RETURNS:	JR	R10
::
::*********************************************************************

GHSTST	HS	0		:Send Host Status Message to Dispatcher
	STB	R3,DZ10ST	:Insert status bits in message
	LHL	R3,GAVPTS	:The latest no. of ports
	STH	R3,DZ10PT	:stored
	LA	R1,GDZ10M	:Get address of message
	LIS	R3,GDZ10L	:and get length of message
	JAL	R8,DIZSMS	:Output to Dispatcher on port Zero
	JR	R10

	EI	:T2GATE		:###ev

        ENDMO.(GATWAY)
       EI       :KILLIT

:	***NOTHING PAST THIS POINT***

	SUBTTL XRAY

:			*   *  ****     *   *   *
:			 * *   *   *   * *   * *
:			  *    ****   *****   *
:			 * *   *  *   *   *   *
:			*   *  *   *  *   *   *

::#####################################################################
::
::	MODULE:		XRAY
::
::	FUNCTION:	TYMNET-II NODE OPERATIONS MONITOR
::
::	REGISTER CONVENTIONS:
::		KX  = R11	:pointer to linK descriptor (Xray)
::		XD  = R15	:pointer to Xray user block Descriptor
::	ROUTINES:
::		XRAY command table
::		XRYSCH:  Scheduler
::		Utility routines for scheduling remote XRAY
::		Main command loop
::		Commands
::		Utility routines
::
::#####################################################################

	IF	1-KILLIT		:TO ASSEMBLE OR NOT TO ASSEMBLE

	BEGMO.

      IF	NAD68
	SEG	1			:Xray in SEG1 in 68K environment###wjl
SEGD	HS	0			:SEGD used as a label only!	###wjl
      ELSE	:Engine
	SEG	0D			:XRAY RUNS IN SEGD
:  remove ORG SEGD to prevent overwriting of data already assembled in SEG D#sw
      EI	:NAD68

:	XRSZLV switch provides three major assembly size level for XRAY.
:	XRSZLV=1:  ND,NS,KD,KS,PQ,DC,CO			
:	XRSZLV=2:  1 AND GP,CD,CL,CM,SM,BZ,TL/TN/TM,AC,QC,TC/TD/TE/TA,
:		DB/DD/DE/DL/PM,WM,PQ,R,RS,SA,SY,IS,IR,HS
:	XRSZLV=3:  1,2 AND ALL OTHER COMMANDS (DEFAULT)

:	>>CRYPTOGRAM values now defined in DATA for structured reference<<
:	>>SRESER - Symbol Reserved area moved to end of SEGD (FIN)<<

	SUBTTL	XRAY (Cryptogram data)

::*********************************************************************
::
::	BIT ARRAYS:	CRYPRY:/CRYPDF:
::	FUNCTION:	CRYPTO MESSAGE PRIORITY BIT ARRAYS
::
::*********************************************************************

	IF 	PRIMSG
CRYPRY	HS	0	:EACH BIT SET FOR A PRIORITY MSG. ON (MSG# 0-7FH)
	HC	$2 0000001000000000,0000000100011000 (0-1FH)
	HC	$2 0000001100000000,1000000001000000 (20H-3FH)
	HC	$2 0000000000000001,0000111100000000 (40H-5FH)
	HC	$2 0000000000000000,1010011100000000 (60H-7FH)
	HC	0,0,0,0,0,0,0,0 (RESERVED TILL 0FFH)
CRYPRE	HS	0 :DEFAULT PRIORITY CRYPTO. MSGS:06,17,1B,1C,26,27,30,39,54
CRYPDF	HS	0 :DEFAULT BIT SET FOR A PRIORITY MSG. ON (MSG# 0-7FH)
	HC	$2 0000001000000000,0000000100011000 (0-1FH)
	HC	$2 0000001100000000,1000000001000000 (20H-3FH)
	HC	$2 0000000000000001,0000111100000000 (40H-5FH)
	HC	$2 0000000000000000,1010011100000000 (60H-7FH)
	HC	0,0,0,0,0,0,0,0 (RESERVED TILL 0FFH)
CRYPDE	HS	0
	EI	:PRIMSG
:	HC	$2 00010000,10000000,00001000,00000100,00000011
:	HC	$2 01100000,11010011,11000000,00000000,00000000
:	HC	$2 10011011,00000110,11011000,11001100,00000000
:	HC	0,0,0,0,0

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	BIT ARRAY:	SHCRYP:
::	FUNCTION:	DEFAULT ENABLE/DISABLE OF CRYPTO MESSAGES
::
::*********************************************************************

:	REDEFINE SOME SYMBOLS FOR CONVENIENCE
Q	EQ	0
	RE	10
CRYE|Q|	EQ	CRYE0|Q|
Q	EQ	Q+1
	ER

:	DEFINE BIT ARRAY BASED ON BIT 4 OF CRYEXX (0=> DISPLAY, 1=> NO DISPLAY)
:	AND ALSO ON BASIS OF TYME-FILE OPTIONS
QINDEX  EQ      0
QVALUE  EQ      0
SHCRYP	HS	0		:BEGINNING OF CRYPTO-ENABLE BIT ARRAY
	RE	73		:DO FOR 128 POSSIBLE CRYPTO MESSAGES
QQ	EQ	0		:DEFAULT TO DISPLAY ON
	IF	\CE|QINDEX|	:IF THERE IS A TYMFILE OVER-RIDE
QQ	EQ	0		:ENABLE THE MESSAGE
	ELSE
	IF	\CD|QINDEX|	:IF THERE IS A TYMFILE SHUT
QQ	EQ	1		:DISABLE THE MESSAGE
	ELSE
	IF	CRYE|QINDEX|&800:IF NEITHER, GO WITH DEFAULT
QQ	EQ	1		:IF BIT 4 = 1, DON'T DISPLAY
	EI
	EI
	EI
QVALUE	EQ	QVALUE*2+QQ		:SET THE CORRESPONDING BIT IN THE ARRAY
QINDEX	EQ	QINDEX+1		:ADVANCE INDEX TO NEXT CRYPTO MESSAGE
	IF	QINDEX&0F
	ELSE
	HC	QVALUE			:ELSE ENTER ONE HW OF THE BIT ARRAY
QVALUE	EQ	0			:AND CLEAR THE TEMPORARY VALUE
	EI
	ER

::*********************************************************************
::
::	BIT ARRAY:	MOCRYP:
::	FUNCTION:	PERMITS CRYPTO MESSAGES TO BE DYNAMICALLY
::	ENABLED AND DISABLED WITH AN X-RAY COMMAND. THIS INFO IS STORED
::	IN BIT 5 OF CRYE-XX (1=>CAN BE MODIFIED, 0=>CANNOT BE MODIFIED)
::
::*********************************************************************

QINDEX	EQ	0
QVALUD	EQ	0
MOCRYP	HS	0
	RE	72
QQ	EQ	0			:DEFAULT TO CANNOT BE MODIFIED
	IF	CRYE|QINDEX|&400	:PICK OUT BIT 5
QQ	EQ	1
	EI
QVALUE	EQ	QVALUE*2+QQ
QINDEX	EQ	QINDEX+1
	IF	QINDEX&0F
	ELSE
	HC	QVALUE
QVALUE	EQ	0
	EI	:QINDEX&0F
	ER

	EI	:(XRSZLV-1)		:##AL

::*********************************************************************
::
::	CRYPTOGRAMS:
::
::*********************************************************************

	IF	(XRSZLV-1)		:##AL
	NOLIST
CRYM00	DEFASC(00: CRASH - TYPE= ,HH,ADDRESS= ,HH,,HH)
CRYM01	DEFASC(01: LINK UP   - KN= ,BD,NEIG= ,O5)
CRYM02	DEFASC(02: LINK DOWN - KN= ,BD,NEIG= ,O5)
CRYM03	DEFASC(03: LINK ERR (NO P.T.) - KN = ,BD,NEIG= ,O5)
CRYM04	DEFASC(04: LINE DETACHED - REASON= ,BH,LN= ,BD,NEIG= ,O5)
CRYM05	DEFASC(05: TAKEOVER - SUPERVISOR= ,BH)
CRYM06	DEFASC(06: SUP STOP)
CRYM07	DEFASC(07: SUP CRQ LOST - SUPERVISOR= ,BH)
CRYM08	DEFASC(08: CRQ GOBBLED NEEDLE - CHAR PAIR= ,HH,NEIG= ,O5)
CRYM09	DEFASC(09: ZAP ON UNASSIGNED CHANNEL - CHAN= ,HH,NEIG= ,O5)
CRYM0A	DEFASC(0A: NO NEIGHBOR - NEIG= ,O5)
CRYM0B	DEFASC(0B: CRQ BUILT - PORTS= ,HH,,HH)
CRYM0C	DEFASC(0C: CRQ ZAP   - PORTS= ,HH,,HH)
CRYM0D	DEFASC(0D: NO HOST - HOST#= ,D5)				:###CWC
CRYM0E	DEFASC(0E: NEEDLE ZAPPED - CHAN= ,HH,NEIG= ,O5)
CRYM0F	DEFASC(0F: CRQ TIMEOUT - CHANNEL = ,HH)
CRYM10	DEFASC(10: CHAN IN USE - LIFETIME= ,HH,ABS CHAN= ,HH)
CRYM11	DEFASC(11: REBUILD REQ - CHAN= ,HH,HSEQN= ,HH,,HH)
CRYM12	DEFASC(12: REB COMPLETE - CHN= ,HH,HSEQN= ,HH,,HH)
CRYM13	DEFASC(13: BAD REBUILD INVOICE NUMBER - ,HH,,HH)		:###wjl
CRYM14	DEFASC(14: REB DATA LOST. CHAN= ,HH)
CRYM15	DEFASC(15: HOST STAT - STATUS= ,BH,HOST= ,D5)			:###CWC
CRYM16	DEFASC(16: LINE ATTACHED - NLAT= ,BD,LN= ,BD,NEIG= ,O5)
CRYM17	DEFASC(17: NO COMMAND PORTS - INVOICE#= ,HH,,HH)
CRYM18	DEFASC(18: EARLY ZAPPER - CHAN= ,HH,NEIG= ,O5)
CRYM19	DEFASC(19: OUT OF CHANNELS - NEIG= ,O5)
CRYM1A	DEFASC(1A: NEEDLE POINT GARBAGE - FIRST 2 BYTES= ,HH)
CRYM1B	DEFASC(1B: NO KERNEL PORTS)
CRYM1C	DEFASC(1C: OUT OF DISPATCHER PORTS - NDP= ,HD,HOST=,D5)		:###CWC
CRYM1D	DEFASC(1D: SIO INT. - STAT= ,BH,CCODE= ,BH,LN= ,BD,NEIG= ,O5)	:###al
CRYM1E	DEFASC(1E: 4 SEC'S WITH NO REC'S RECVD - LN= ,BD,NEIG= ,O5)
CRYM1F	DEFASC(1F: NON-GOBBLING ZAPPER - NEIG= ,O5)			:###wjl
CRYM20	DEFASC(20: LINE SUSPENDED - SEC'S= ,HD,LN= ,BD,NEIG= ,O5)
CRYM21	DEFASC(21: LINK SHRINK - NCHN= ,HD, NEIG= ,O5)
CRYM22	DEFASC(22: LINK BUBBLE - NCHN= ,HD, NEIG= ,O5)
CRYM23	DEFASC(23: INV LOGGER ENTRY - BUFFER= ,HH,BF= ,HH)		:###TZ
CRYM24	DEFASC(24: SUP DATA ON UNASSIGNED CHN - CHAN= ,HH)
CRYM25	DEFASC(25: SUP ZAP ON UNASSIGNED CHN - CHAN= ,HH)
CRYM26	DEFASC(26: INV MACHNM ON CMD CIRCUIT - ERR CNT= ,HD,NODE= ,O5)
CRYM27	DEFASC(27: INV CMD ON CMD CIRCUIT - COMMAND= ,HH,ERR CNT= ,HD)
CRYM28	DEFASC(28: DATA ON UNASSIGNED CHANNEL - CHAN= ,HH,NEIG= ,O5)
CRYM29	DEFASC(29: NEEDLE ON ASSIGNED CHANNEL - CHAN= ,HH,NEIG= ,O5)
CRYM2A	DEFASC(2A: INV. 03 CHARACTER PAIR - CHAR= ,BH,CHAN= ,HH)
CRYM2B	DEFASC(2B: INT HOST CRQ TIMEOUT - CHAN= ,HH)
CRYM2C	DEFASC(2C: NEW DWL CHN - CHAN= ,HH,LN= ,BD)
CRYM2D	DEFASC(2D: DWL LINE ZAP - REASON= ,BH,LN= ,BD)
CRYM2E	DEFASC(2E: OUT OF INTERNAL HOST PORTS)
CRYM2F	DEFASC(2F: ISIS HOST OUT OF PORTS - INVOICE#= ,HH,,HH)
CRYM30	DEFASC(30: SYNC SCAN ERROR - LINE*2= ,BD,OFFSET= ,HH)
CRYM31	DEFASC(31: NETDGN CALLING ERROR)
CRYM32	DEFASC(32: SIO BUFFER CNT ERR - LINE*2= ,BD,COUNT= ,HH)
CRYM33	DEFASC(33: M-BOARD TIMEOUT - LINE= ,BD,REASON= ,BH)
CRYM34	DEFASC(34: CIRCUIT ERRORS - LEP= ,HD,CRQ= ,HD)
CRYM35	DEFASC(35: CIRCUIT INCONSISTENCIES - MAGNITUDE= ,HH,COUNT= ,HD)
CRYM36	DEFASC(36: LINK OVERLOADED - COUNT= ,HH,NEIG= ,O5)		:###OAS
CRYM37	DEFASC(37: LINK SATURATED - COUNT= ,HH,NEIG= ,O5)		:###OAS
CRYM38	DEFASC(38: ILC BUF ZERO - NEIG= ,O5)
CRYM39	DEFASC(39: LINK SNIP - TYPE=,HH,NEIG=,O5)
CRYM3A	DEFASC(3A: SIO CARD BUSY - CMD= ,HH)
CRYM3B	DEFASC(3B: SIO RING INTERRUPT - STATUS= ,HH)
CRYM3C	DEFASC(3C: TID RECEIVED - PORT= ,HO,CCT= ,BD)			:###wjl
CRYM3D	DEFASC(3D: NEEDLE EYE RECEIVED - PORT= ,HO,CHAN= ,HH)
CRYM3E	DEFASC(3E: "87"87"87BCKTAL ERROR - CHAN= ,HH,PORT= ,HO)
CRYM3F	DEFASC(3F: ASYNC PORT STATUS - STATUS= ,HD,PORT= ,HO)
CRYM40	DEFASC(40: TOT PKTS - RECD= ,HH,SENT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM41	DEFASC(41: BAD BORI. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM42	DEFASC(42: BAD ACK. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM43	DEFASC(43: BAD RECORD NUMBER. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM44	DEFASC(44: BAD CHECKSUM. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM45	DEFASC(45: RE-XMISSIONS REC'D. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM46	DEFASC(46: RE-XMISSIONS SENT. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM47	DEFASC(47: 4-SECOND GAPS. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM48	DEFASC(48: CROSSTALK. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM49	DEFASC(49: SPACING ON INPUT. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM4A	DEFASC(4A: HDLC CKSM ERRORS. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM4B	DEFASC(4B: HDLC ABORTS. COUNT= ,HH,LN= ,BD,NEIG= ,O5)
CRYM4C	DEFASC(4C: UNTAKER - NEIG= ,O5)
CRYM4D	DEFASC(4D: CIRCUITS ZAPPED= ,HD,KN= ,BD,NEIG= ,O5)
CRYM4E	DEFASC(4E: CMD CTS  ZAPPED= ,HD,KN= ,BD,NEIG= ,O5)
CRYM4F	DEFASC(4F: ASYNC RING WRAP. MAX= ,HH,WRAP= ,HH)			:###wjl
CRYM50	DEFASC(50: BAD INT. HOST FUNCTION. VALUE = ,HH)
CRYM51	DEFASC(51: LINK FROZEN - NEIG= ,O5)
CRYM52	DEFASC(52: LINK THAWED - NEIG= ,O5)
CRYM53	DEFASC(53: BAD SIO REC LENGTH - LN= ,BD,NEIG= ,O5)
CRYM54	DEFASC(54: XRAY AUDIT - TYPE= ,HH,NAME= ,HH,,HH,,HH)
CRYM55	DEFASC(55: SIO LINE TIMEOUT ON OUTPUT. MSEC= ,HD,LN= ,BD)
CRYM56	DEFASC(56: RECOVERY FROM MAC ERROR AT ADDRESS  1,HH)
CRYM57	DEFASC(57: DMA TIMEOUT. MAC STATUS= ,HH)
CRYM58	DEFASC(58: REPORT LIMIT EXCEEDED - SLOT= ,BD,LIMIT= ,HD)
CRYM59	DEFASC(59: DATA ON DISABLED ASYNC PORT. PN= ,HO)
CRYM5A	DEFASC(5A: CIRCUIT LIMIT EXCEEDED - SLOT= ,BD, HOST= ,D5)	:###CWC
CRYM5B	DEFASC(5B: INVALID HOST FOR RESTRICTED NODE - SLOT= ,BD,HOST= ,D5) :###CWC
CRYM5C	DEFASC(5C: INV. 03-PAIR ON T-I CMD CIRCUIT - DATA= ,HH, NEIG= ,O5)
CRYM5D	DEFASC(5D: INV. LENGTH ON T-I SUP RECORD - DATA= ,HH, NEIG= ,O5)
CRYM5E	DEFASC(5E: INV. 03-PAIR ON CMD CIRCUIT - DATA= ,HH)
CRYM5F	DEFASC(5F: CHAN IN USE - REL CHAN= ,HH,NEIG= ,O5)
CRYM60	DEFASC(60: BUFFER ZAP - COUNT= ,HH,CHAN= ,HH,BUFFER= ,HH)
CRYM61	DEFASC(61: SLOT OUT OF PORTS - NBR PORTS= ,HD,HOST= ,D5)	:###CWC
CRYM62	DEFASC(62: IMPOSTER HOST - SLOTS= ,HH,HOST= ,D5)		:###CWC
CRYM63	DEFASC(63: SQA ERROR - DIF= ,HH,PORT= ,HH)
CRYM64	DEFASC(64: KERNEL FAILED TO ZAP PORT - KERNEL PORT = ,HH)
CRYM65	DEFASC(65: SQFIX - CHN= ,HH,NET= ,HH,VALUE= ,HH,,HH)
CRYM66	DEFASC(66: SQACK - CHN= ,HH,HW SEQN= ,HH,HSEQN= ,HH,,HH)
CRYM67	DEFASC(67: REB NEEDLE - SENDING= ,HH,,HH,WANT= ,HH,,HH)
CRYM68	DEFASC(68: NO PERMUTER TABLES FOR NEW LINK - LN= ,BD,NEIG= ,O5)
CRYM69	DEFASC(69: NO LINK FOR NEW LINE - LN= ,BD,NEIG= ,O5)
CRYM6A	DEFASC(6A: CHAN STATUS - CHN= ,HH,HSEQN= ,HH,,HH)
CRYM6B	DEFASC(6B: REBUILD DISABLED ON CHAN= ,HH)
CRYM6C	DEFASC(6C: EARLY REBUILD NEEDLE. CHAN= ,HH)
CRYM6D	DEFASC(6D: INTERCEPT ABANDONED--NO STUB FOR INVOICE= ,HH,,HH)
CRYM6E	DEFASC(6E: CHAN STATUS - XSEQN= ,HH,,HH,VSEQN= ,HH,,HH)
CRYM6F	DEFASC(6F: SQF SENT - CHN= ,HH,XSEQN= ,HH,,HH)
CRYM70	DEFASC(70: SIO MBOARD ERROR - LINE= ,BD,NEIG= ,O5)  		:###OAS
CRYM71	DEFASC(71: WILDCARD - ADDRESS= ,HH,,HH,HW2= ,HH,HW3= ,HH)
CRYM72	DEFASC(72: SIO PORT UNAVAILABLE - LINE= ,BD)			:###OAS
CRYM73	DEFASC(73: BAD ZAP FROM ISIS - REASON = ,BH)			:###GT
CRYM74	DEFASC(74: TAKEOVER RESP. ERR - #NBRS= ,HH,NALINK= ,HH)		:###AL
CRYM75	DEFASC(75: NETID MISMATCH - LINE= ,BD,NETID= ,HD)		:###wjl
CRYM76	DEFASC(76: WSIZ MATCH DOWN - LINE= ,BD,WSIZ= ,HD)		:###wjl
CRYM77	DEFASC(77: XRAY NETID CHANGE - LINE= ,BD,NETID= ,HD)		:###wjl
CRYM78	DEFASC(78: UNRECOGNIZED SIGNAL RECEIVED - OUTGOING CHN = ,HH)	:###LSH
CRYM79	DEFASC(79: STARLINK REMOTE RESET FAILURE - LN= ,BD,NEIG= ,O5)	:###EV
CRYM7A	DEFASC(7A: STAR REMOTE NBR# MISMATCH - KEY= ,HH,,HH,NEIG= ,O5)	:###AL
CRYM7B	DEFASC(7B: SIO INIT SOFTWARE TIMEOUT - LN= ,BD)			:###wjl
CRYM7C	DEFASC(7C: NODE IN NETWK RECVED BOOT CMD FROM - NEIG= ,O5)	:###AL
CRYM7D	DEFASC(7D: NO REC'S RECVD FOR ,BD,SEC'S - LN= ,BD,NEIG= ,O5)	:###AL
CRYM7E	DEFASC(7E: I/O QUERY CONFIGURATION ERROR - TYPE = ,BH) 		:###wjl
CRYM7F	DEFASC(7F: BAD RETURN CODE - TRAP= ,HD,RC= ,HH,,HH) 		:###wjl
:					crym## for tymtunnel begin	###cwc
CRYM80	DEFASC(80: BUILDING TUNNEL - TYPE= ,A3,THST= ,D5,NEIG= ,O5)
CRYM81	DEFASC(81: TUNL BLD ERR= ,BH,SAUSE=,HH,THST=,D5,NEIG=,O5)
CRYM82	DEFASC(82: TUNNEL OPENED - TYPE= ,A3,THST= ,D5,NEIG= ,O5)
CRYM83	DEFASC(83: TUNL CALL ERROR= ,BH,THST= ,D5,NEIG= ,O5)
CRYM84	DEFASC(84: TUNNEL CLOSED - TYPE= ,A3,THST= ,D5,NEIG= ,O5)
:
CRYM85	DEFASC(85: CONSISTENCY CHECK ERROR - RESIDENT= ,BH)
	EI	:(XRSZLV-1)

::*********************************************************************
::
::	TABLE:		CRYMTB:
::	FUNCTION:	CRYPTO MESSAGE TABLE
::
::*********************************************************************

	IF	(XRSZLV-1)		:##AL

CRYMTB	HC	CRYM00-SEGD,CRYM01-SEGD,CRYM02-SEGD,CRYM03-SEGD
	HC	CRYM04-SEGD,CRYM05-SEGD,CRYM06-SEGD,CRYM07-SEGD
	HC	CRYM08-SEGD,CRYM09-SEGD,CRYM0A-SEGD,CRYM0B-SEGD
	HC	CRYM0C-SEGD,CRYM0D-SEGD,CRYM0E-SEGD,CRYM0F-SEGD
	HC	CRYM10-SEGD,CRYM11-SEGD,CRYM12-SEGD,CRYM13-SEGD
	HC	CRYM14-SEGD,CRYM15-SEGD,CRYM16-SEGD,CRYM17-SEGD
	HC	CRYM18-SEGD,CRYM19-SEGD,CRYM1A-SEGD,CRYM1B-SEGD
	HC	CRYM1C-SEGD,CRYM1D-SEGD,CRYM1E-SEGD,CRYM1F-SEGD
	HC	CRYM20-SEGD,CRYM21-SEGD,CRYM22-SEGD,CRYM23-SEGD
	HC	CRYM24-SEGD,CRYM25-SEGD,CRYM26-SEGD,CRYM27-SEGD
	HC	CRYM28-SEGD,CRYM29-SEGD,CRYM2A-SEGD,CRYM2B-SEGD
	HC	CRYM2C-SEGD,CRYM2D-SEGD,CRYM2E-SEGD,CRYM2F-SEGD
	HC	CRYM30-SEGD,CRYM31-SEGD,CRYM32-SEGD,CRYM33-SEGD
	HC	CRYM34-SEGD,CRYM35-SEGD,CRYM36-SEGD,CRYM37-SEGD
	HC	CRYM38-SEGD,CRYM39-SEGD,CRYM3A-SEGD,CRYM3B-SEGD
	HC	CRYM3C-SEGD,CRYM3D-SEGD,CRYM3E-SEGD,CRYM3F-SEGD
	HC	CRYM40-SEGD
	HC	CRYM41-SEGD,CRYM42-SEGD,CRYM43-SEGD,CRYM44-SEGD
	HC	CRYM45-SEGD,CRYM46-SEGD,CRYM47-SEGD,CRYM48-SEGD
	HC	CRYM49-SEGD,CRYM4A-SEGD,CRYM4B-SEGD,CRYM4C-SEGD
	HC	CRYM4D-SEGD,CRYM4E-SEGD,CRYM4F-SEGD,CRYM50-SEGD
	HC	CRYM51-SEGD,CRYM52-SEGD,CRYM53-SEGD,CRYM54-SEGD
	HC	CRYM55-SEGD,CRYM56-SEGD,CRYM57-SEGD,CRYM58-SEGD
	HC	CRYM59-SEGD,CRYM5A-SEGD,CRYM5B-SEGD,CRYM5C-SEGD
	HC	CRYM5D-SEGD,CRYM5E-SEGD,CRYM5F-SEGD,CRYM60-SEGD
	HC	CRYM61-SEGD,CRYM62-SEGD,CRYM63-SEGD,CRYM64-SEGD
	HC	CRYM65-SEGD,CRYM66-SEGD,CRYM67-SEGD,CRYM68-SEGD
	HC	CRYM69-SEGD,CRYM6A-SEGD,CRYM6B-SEGD,CRYM6C-SEGD
	HC	CRYM6D-SEGD,CRYM6E-SEGD,CRYM6F-SEGD,CRYM70-SEGD	:###OAS
	HC	CRYM71-SEGD,CRYM72-SEGD,CRYM73-SEGD,CRYM74-SEGD :###OAS###AL
	HC	CRYM75-SEGD,CRYM76-SEGD,CRYM77-SEGD,CRYM78-SEGD :###LSH###wjl
	HC	CRYM79-SEGD,CRYM7A-SEGD,CRYM7B-SEGD		:###ev ##AL#wjl
	HC	CRYM7C-SEGD,CRYM7D-SEGD,CRYM7E-SEGD,CRYM7F-SEGD	:###AL/###cwc
	HC	CRYM80-SEGD,CRYM81-SEGD,CRYM82-SEGD,CRYM83-SEGD		:###cwc
	HC	CRYM84-SEGD,CRYM85-SEGD				:###cwc	:###wjl

	LIST

CRYMTZ	EQ	.-CRYMTB-2		:SIZE OF TABLE - 2
	EI	:(XRSZLV-1)		:##AL

	SUBTTL	XRAY (Xray EQuates and Data)
 
ADBOOT	EQ	5A			:vector address for boot

:	ISIS SVC MASKS
XSG1WA	EQ	10007		:ISIS SVC MASK GIVES XRAY SEG1 WRITE ACCESS
XSG1WP	EQ	10005		:ISIS SVC MASK RESTORES SEG1 WRITE PROTECT
XSGDWA	EQ	0D0007		:ISIS SVC MASK GIVES XRAY SEGD WRITE ACCESS
XSGDWP	EQ	0D0005		:ISIS SVC MASK RESTORES SEGD WRITE PROTECT

XINDDT	HS	1
XOUDDT	HC	100		:DATA AREAS FOR ISIS DDT-DRIVEN XRAY

::*********************************************************************
::
::	TABLE:		CHKDAT:
::	FUNCTION:	DETERMINE VALIDITY OF USER-SUPPLIED ADDRESS
::
::*********************************************************************

	GL	S0SZ,S1SZ,S2SZ,S3SZ,S4SZ,S5SZ,S6SZ,S7SZ
	GL	S8SZ,S9SZ,SBSZ,SCSZ,SDSZ,SESZ
SEGASZ	EQ	0

CHKDAT	WS	0
	WC	S0SZ-1,S1SZ-1,S2SZ-1,S3SZ-1
	WC	S4SZ-1,S5SZ-1,S6SZ-1,S7SZ-1
	WC	S8SZ-1,S9SZ-1,SASZ-1,SBSZ-1
	WC	SCSZ-1,SDSZ-1,SESZ-1
	WC	4FF			:SIZE OF SEG F
	HC	0

::*****************************************************************
::
::       XRNTXT(txt,num,nsiz,txt,num,numsiz,txt)  defines a SC string with text
::       intermixed with numbers.  The numbers fields can be expressions
::       and the value (not the expression) will be put into the text.
::       the nsiz field is the number of bytes for the number.  The number
::       is truncated if too big or padded with spaces on the left.
::
::******************************************************************

XRNTXT  MACRO(T1,N1,N1S,T2,N2,N2S,T3,N3,N3S,T4)[
QXRN    BC      0 		:where to put len
	AC      /T1/
	.XRNTX(N1,N1S)
	AC      /T2/
       IF       N2S     	:only do num if given len
	.XRNTX(N2,N2S)
       EI       :N2S
	AC      /T3/
       IF       N3S
	.XRNTX(N3,N3S)
       EI       :N3S
	AC      /T4/
QQ      EQ      .
       IF       .-QXRN-1	:any message at all?
	ORG     QXRN
	BC      QQ-QXRN-1
	ORG     QQ
       ELSE       		:null string
	BC      01,00
       EI
]


:       .XRNTX  gives N2 bytes of N1 (number) in text right justified
.XRNTX  MACRO(N1,N2)[
Q       EQ      N1		:handles when N1 is an expression

	BS      N2+1    	:extra so backwards march really starts BS N2
	RE      N2		:backwards march
	ORG     .-2     	:previous to current byte
       IF       Q
Q2      EQ      Q-10*(Q/10)     :current digit
Q       EQ      Q/10
       IF       Q2-9
	BC      $0 Q2+0B7       :A-F
       ELSE
	BC      $A Q2+176       :0-9
       EI
       ELSE     :Q=0
	AC      / /
       EI
	ER
	ORG     .+N2-1  	:back to point after last digit
]

	SUBTTL	XRAY (Host status text and tables)

::*******************************************************************
::
::      Host Status text and tables
::
::*******************************************************************

      IF	XRSZLV-1
      IF	1-T2GATE
      IF	1-NAD68		:not used in 68K environment		###wjl

HSTDS1	HS	0			:HOST SLOT PRODUCT DESCRIPTIONS
	NOLIST
ASAT	SC	/TYMSAT/
ACOM	SC	/TYMCOM/
XCOM	SC	/X25-X75/
PBH	SC	/3270 HOST INTERFACE/
PBT	SC	/3270 TERMINAL INTERFACE/
MSAT	SC	/MICRONODE KERNEL/
I21S	SC	/ISIS KERNEL/
TIINC	SC	/TYMNET-II NODE CODE/
XXB	SC	/2020 BASE/
BBXS	SC	/X780-MULTILEAVING/
ELF	SC	/ELF/
I2G1	SC	/ISIS GATEWAY/
I2T1	SC	/ISIS TYMNET-I NODE CODE/
LDII	SC	/LOADII/
MRLN	SC	/MERLIN/
ONTM	SC	/ONTYME/
PRB	SC	/PROBE/
RAM	SC	/RAM/
SPVSR	SC	/SUPERVISOR/
NVAL	SC	/VAL-NETVAL/
ISCS	SC	/ISIS CONSAT/
BOOT	SC	/ENGINE BOOT/
SAKER	SC	/STAND-ALONE KERNEL/
SPKER	SC	/SPLIT STAND-ALONE KERNEL/
SDLC	SC	/SDLC INTERFACE/
TNTT	SC	/TINET INTERFACE/
UTSH	SC	/UTS 4000 INTERFACE/
NTRH	SC	/NTR INTERFACE/
VMB	SC	/VMB INTERFACE/
EWS	SC	/ENGINE WORK STATION/
NEM	SC	/NETWORK EVENT MONITOR/
TMCS	SC	/TMCS/
OUTDIA	SC	/OUTDIAL/
CMTI	SC	/3270 VIRTUAL HOST DRIVER/
TRSW	SC	/TRANSACTION SWITCH/
ITI	SC	/SLIGOS TRANSACTION SERV/
UTST	SC	/UTS VIRTUAL HOST DRIVER/
TOM	SC	/TYMCOM OPERATIONS MON/
LEM	SC	/LEMCOM 370 BASE/
MUX	SC	/MULTIPLEXOR/
UTIL	SC	/SUPERVISOR UTIL SLAVE/
PBOM	SC	/POLLED BISYNC OPS MON/
SOM	SC	/SDLC OPERATIONS MON/
PAOM	SC	/POLLED ASYNC OPS MON/
CRED	SC	/CIRCUIT REDIRECT/
TLXG	SC	/TELEX GATEWAY/
XOM	SC	/X25-X75 OPERATIONS MON/
NTRT	SC	/NTR TERMINAL INTERFACE/
XPC	SC	/X.PC SERVER/
SNAT	SC	/SNA TERMINAL INTERFACE/
SNAH	SC	/SNA HOST INTERFACE/
TNTH	SC	/TINET HOST INTERFACE/
CMTU	SC	/UTS CHAR MODE TRMNL/
PRACCT	SC	/ACCOUNT SLAVE/
ELSV	SC	/ELF SLAVE/
ERLG	SC	/ERLOG SLAVE/
NAD	SC	/NAD ASSEMBLER/
NTCN	SC	/NETWORK CONSOLE/
SYSM	SC	/SYSMSG1 SLAVE/
UN2	SC	/UN2 SLAVE/
ISRM	SC	/ISIS SYSTEM RECOVERY MOD/
ONTR	SC	/ONTYME DB RESTORE PGM/
OBJN	SC	/PASCAL OBJECT-NIB CNVRTR/
CPAS	SC	/CONCURRNT PASCAL COMPILER/
STAR	SC	/PASCAL STTMNT ADDR GNRTR/
TMDM	SC	/TMCS DISK MAINT PGM/
TMRE	SC	/TMCS RESOURCE EST PGM/
NMDM	SC	/NEM DISK MAINT PGM/
NMRE	SC	/NEM RESOURCE EST PGM/
NCDM	SC	/NETCON DISK MAINT PGM/
NCRE	SC	/NETCON RESOURCE ESTIMATOR/
NVDM	SC	/NETVAL DISK MAINT PGM/
MSRV	SC	/MENU SERVER/
SHMN    SC      /SHAMAN/
XPI	SC	/XPI/
CPPP	SC	/CPPP/
ATC	SC	/ATC/
ODNU	SC	/OUTDIAL NUCLEUS/
OPAS	SC	/OUTDIAL PASCAL COMPILER/
ACUS	SC	/AUTO CALL UNIT SERVER/
X25	SC	/XCOM - X.25/
X75	SC	/XCOM - X.75/
IHSA	SC	/IHSA/
DMAC	SC	/MAC DIAGNOSTIC/
MLI	SC	/MLI-MULTILEAVING BISYNC/
ISRS	SC	/ISIS SLOT RECOVER SYSTEM/
MXPI	SC	/MXP/
CICL	SC	/ICL PROTOCOL/
HICL	SC	/ICL PROTOCOL - HOST/
TICL	SC	/ICL PROTOCOL - TERMINAL/
T2G2	SC	/TYMNET II GATEWAY/
DMEM	SC	/ENGINE MEMORY DIAGNOSTIC/

HSTDS2	SC	/"0D"0AHOST NO.  SLOT  PID   PRODUCT DESCRIPTION       STAT  TIME OF STAT  CT  DOPIL"0D"0A/
HSTDS3	SC	/--------  ----  ----  ------------------------  ----  ------------  --  -----"0D"0A/
HSTDS4	AC	/ UP /		:HOST STATUS TEXT
	AC	/DOWN/
	AC	/SHUT/
	AC	/GONE/
HSTDS6	SC	/"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20"20/			:26 SPACES
	LIST

BSEPID	EQ	31			:###jhl
PIDTBL	HS	0			:pointer table for PID strings
PID31	HC	ASAT-SEGD
PID32	HC	ACOM-SEGD
PID33	HC	XCOM-SEGD
PID34	HC	PBH-SEGD
PID35	HC	PBT-SEGD
PID36	HC	MSAT-SEGD
PID37	HC	I21S-SEGD
PID38	HC	TIINC-SEGD
PID39	HC	XXB-SEGD
PID3A	HC	BBXS-SEGD
PID3B	HC	ELF-SEGD
PID3C	HC	I2G1-SEGD
PID3D	HC	I2T1-SEGD
PID3E	HC	LDII-SEGD
PID3F	HC	MRLN-SEGD
PID40	HC	ONTM-SEGD
PID41	HC	PRB-SEGD
PID42	HC	RAM-SEGD
PID43	HC	SPVSR-SEGD
PID44	HC	NVAL-SEGD
PID45	HC	ISCS-SEGD
PID46	HC	BOOT-SEGD
PID47	HC	SAKER-SEGD
PID48	HC	SPKER-SEGD
PID49	HC	SDLC-SEGD
PID4A	HC	TNTT-SEGD
PID4B	HC	UTSH-SEGD
PID4C	HC	NTRH-SEGD
PID4D	HC	VMB-SEGD
PID4E	HC	EWS-SEGD
PID4F	HC	NEM-SEGD
PID50	HC	TMCS-SEGD
PID51	HC	OUTDIA-SEGD
PID52	HC	CMTI-SEGD
PID53	HC	TRSW-SEGD
PID54	HC	ITI-SEGD
PID55	HC	UTST-SEGD
PID56	HC	TOM-SEGD
PID57	HC	LEM-SEGD
PID58	HC	MUX-SEGD
PID59	HC	UTIL-SEGD
PID5A	HC	PBOM-SEGD
PID5B	HC	SOM-SEGD
PID5C	HC	PAOM-SEGD
PID5D	HC	CRED-SEGD		:###LH
PID5E	HC	TLXG-SEGD		:###LH
PID5F	HC	XOM-SEGD		:###LH
PID60	HC	NTRT-SEGD		:###LH
PID61	HC	XPC-SEGD		:###LH
PID62	HC	SNAT-SEGD		:###LH
PID63	HC	SNAH-SEGD		:###LH
PID64	HC	TNTH-SEGD		:###LH
PID65	HC	CMTU-SEGD		:###LH
PID66	HC	PRACCT-SEGD		:###LH
PID67	HC	ELSV-SEGD		:###LH
PID68	HC	ERLG-SEGD		:###LH
PID69	HC	NAD-SEGD		:###LH
PID6A	HC	NTCN-SEGD		:###LH
PID6B	HC	SYSM-SEGD		:###LH
PID6C	HC	UN2-SEGD		:###LH
PID6D	HC	ISRM-SEGD		:###LH
PID6E	HC	ONTR-SEGD		:###LH
PID6F	HC	OBJN-SEGD		:Pascal Object to Nib Converter
PID70	HC	CPAS-SEGD		:Concurrent Pascal Compiler
PID71	HC	STAR-SEGD		:Pascal Statement Address Generator
PID72	HC	TMDM-SEGD		:TMCS Disk Maintenance Program
PID73	HC	TMRE-SEGD		:TMCS Resource Estimation Program
PID74	HC	NMDM-SEGD		:NEM Disk Maintenance Program
PID75	HC	NMRE-SEGD		:NEM Resource Estimation Program
PID76	HC	NCDM-SEGD		:Network Console Disk Maint Program
PID77	HC	NCRE-SEGD		:Network Console Resource Estimator
PID78	HC	NVDM-SEGD		:Netval Disk Maintenance Program
PID79	HC	MSRV-SEGD		:Menu Server
PID7A   HC      SHMN-SEGD 		:Shaman				###LH
PID7B	HC	XPI-SEGD		:Extended Processor Interface	###wjl
PID7C	HC	CPPP-SEGD		:Concurrent Pascal Preprocessor	###wjl
PID7D	HC	ATC-SEGD		:Asynchronous Terminal Concentrator
PID7E	HC	ODNU-SEGD		:Outdial Concurrent Pascal Nucleus#wjl
PID7F	HC	OPAS-SEGD		:Outdial Pascal Compiler	###wjl
PID80	HC	ACUS-SEGD		:Outdial/Bisync Auto Call Unit Server
PID81	HC	X25-SEGD		:XCOM - X.25			###wjl
PID82	HC	X75-SEGD		:XCOM - X.75			###wjl
PID83	HC	IHSA-SEGD		:IHSA				###wjl
PID84	HC	DMAC-SEGD		:Universal Engine MAC Diagnostic###wjl
PID85	HC	MLI-SEGD		:DOS/MLI-Multileaving Bisync-DOS/VSE
PID86	HC	ISRS-SEGD		:ISIS Slot Recovery System	###wjl
PID87	HC	MXPI-SEGD		:MXP				###wjl
PID88	HC	CICL-SEGD		:ICL Protocol			###wjl
PID89	HC	HICL-SEGD		:ICL Protocol - Host		###wjl
PID8A	HC	TICL-SEGD		:ICL Protocol - Terminal	###wjl
PID8B	HC	T2G2-SEGD		:Tymnet II Gateway		###wjl
PID8C	HC	DMEM-SEGD		:Engine Memory Diagnostic	###wjl
PIDTBZ	EQ	.-PIDTBL

      EI	:1-NAD68	
      EI	:T2GATE
      EI	:XRSZLV-1

	SUBTTL	XRAY (ASCII messages)

::*********************************************************************
::
::	ASCII MESSAGES:
::
::*********************************************************************

ASCXRY	SC	/"0D"0AX-RAY"0D"0A/
ASCNOD	SC	/NODE : /
ASCHST	SC	/"0D"0AHOST : /
ASCTIM	SC	/"0D"0ATIME : /
ASC02	SC	/"0D"0A??/
ASPRMT	SC	/"0D"0A>/
ASCCAR	SC	/"0D"00/
ASCSLH	SC	.\  .
ASCOER	SC	/ *ODD"0A"0D/
ASWRER	SC	/ADDRESS NOT ON HW OR FW BOUNDARY"0D"0A/
ASCZIP	SC	/ZIP"0D"0A/
ASCZAP	SC	/ ZAP? /
ASCPF	SC	/"0D"0A**PWR FAILURE/
ASCCRH	SC	/"0D"0A**CRASH  /
ASCERT	SC	/"0D"0A**ILL INST  /
ASCMCR	SC	/"0D"0A**MAC ERR  /
DMAERR	SC	/"0D"0A**DMA TIMEOUT/
ASCMMR	SC	/"0D"0A**PARITY ERR  /
ASCHLT	SC	/"0D"0A**HALT/
ASCRUN	SC	/"0D"0A**RUN"0D"0A/
BADRDX	SC	/"07"0D"0A**BAD RADIX/
BADCON	SC	/"0D"0ACOMMAND NOT AVAILABLE IN THIS CONFIGURATION/
ASMCER	SC	/"07"0D"0A**BAD ADDRESS"0D"0A/
AUMG3	SC	/"0D"0ANEED THREE ARGUMENTS/			:###AL
SSMSG1	SC	/"0D"0AWRONG LINE NUMBER/			:###LSH
ASCTRP	SC	/"0D"0ATRAP  /
PRFILL	SC	/"0ABYTE FILL: /
PRTINT	SC	/"0ARATE (0-6): /
PRNODE	SC	/"0AT-II NODE LIST: /
PRPRTY	SC	/"0APRIORITY: /
DERMSG	SC	/OUT OF INT HST CHAN OR INDEX ALREADY IN USE"0A"0D/
ASPWER	SC	/"0ANOT AUTHORIZED/
ASCOMU	SC	/  BUSY"0A"0D/

::________________________________________________________________	###cwc


XNDHD0	SC	/"0D"0A"0ACRASH STATUS:  COUNT    TYPE    ADDRESS"0D"0A/
	IF	T2GATE			:##AL
XNDHD1	SC	/"0D"0A"0AGWNODE   HNHOST   INHOST    VERSION   H-WARE   S-WARE  SUPR    MEMORY"0D"0A/  :###CWC
	ELSE	:NOT T2GATE
XNDHD1	SC	/"0D"0A"0ANODE   KHOST   VERSION   H-WARE   S-WARE  SUPR    MEMORY"0D"0A/		:###CWC
	EI	:T2GATE

XNDHD2	SC	/KB"0D"0A"0APORTS  PASSTHRUS  CMD CTS  ALNK  TLNK  XLNK   LINES  SYNC  SIO"0D"0A/

XNDHD3	SC	/    NODE LAST CAME UP AT /
XNDHD5	SC	/"0A"0D"0ANODE FIRST CAME UP AT /
XNDHD6	SC	/"0A"0D"0ALAST CRASH:     TIME       CC   TYPE  PSW   ADDRESS"0A"0D            /
XNDHD4	SC	+"0D"0A"0A**LINE**  ***--LINK--****    LINE    LINK  LINE   LINK  LINE          LINE"0D"0ANO. TYPE  NEIG   NO. TYPE    STATUS  WSIZ  SPEED  CRQS  TIME ATT/DET  ERRATE"0D"0A+
NONEIG	SC	/                   UNUSED/	:
XDWLDS	SC	/                   DWLOAD/
XDWLBR	SC	/ DWLOAD  /
XNDLUP	SC	/ UP      /
XNDLOT	SC	/ *DOWN*  /
XNDSUS	SC	/ *SUSP*  /
XNDLUN	SC	/UNUSED/
XNDTKD	SC	/TII /:
XNDXKD	SC	/XLNK/:
XNDMLL	SC	/-M /
XNDHSY	SC	/SYNC  /
	IF	SILINS
XNDHSI	SC	/SIO   /
	EI	:SILINS
ASTER1	SC	/  *    /
ASTER2	SC	/  **   /
ASTER3	SC	/  ***  /
ASTER4	SC	/  **** /
	SC	/  **** /
XNDLG2  SC      /LG2  / 	:print after supe number                ###sdw
XNDER0	SC	/    /
XNDER1	SC	/*   /
XNDER2	SC	/**  /
XNDER3	SC	/*** /
XNDER4	SC	/***S*/
XNDWDN	SC	/"0D"0ATIILNK NEIGHBORS DOWN - /

XKSM01	SC	/"0D"0A"0ALOGICAL LINK CHARACTERS/
XKSM02	SC	/"0D"0APHYSICAL LINK CHARACTERS/
XKSM03	SC	/"0D"0A    CPS IN : /
XKSM04	SC	/"0D"0A    CPS OUT: /
XKSM05	SC	/HWM : /
XKSM06	SC	/"0D"0APACKET OVERHEAD                 BANDWIDTH UTILIZATION"0D"0A/
XKSM07	SC	/    IN : /
XKSM08	SC	/    OUT : /
XKSM12	SC	?"0D"0APACKET STATISTICS"0D"0A    PACKETS/SEC : ?
XKSM10	SC	/"0D"0AOVERLOAD COUNT   SATURATED COUNT   BACKLOG COUNT   PACKETS MADE   IDLE CALLS"0D"0A      /
XKSM13	SC	?"0D"0A    RECORDS/PACKET : ?	:###JHL FOR REL 5.02
XKSM14	SC	/   AVERAGE SIZE : /
XKSM15	SC	/"0D"0ALINK DELAY (MS)"0D"0A    IN QUEUE    RTEAR    BUFFER   OUT QUEUE   XMIT     TOTAL"0D"0A      /
XKSM16	SC	/BYTES/
XKSM17	SC	+"0D"0A"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0  MARKING"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0REXMISSIONS"A0"A0"A0"A0XMISSIONS+
XKSM18	SC	+"0D"0ALINE +
XKSM20	SC	+:    +
XKSM19	SC	/"0D"0A"0ALINK : /
XKSM22	SC	?"0D"0ACHAR/SEC PER CIRCUIT"0D"0A    IN : ?
XKSM23	SC	/  OUT : /
XKSM24	SC	/ CIRCUITS : /
XKSM25	SC	/ STATISTICS CLEARED/

XSTHD1	SC	/"0D"0AEXCT  EXLW  EXHW  EDHW  EEHW  SYHW  NEHW  NECT  MPRT  MPAS  MLNK"0D"0A/
xsthd2 sc   /"0d"0aRMK XCT  RMK NMK  PKTS OUT RECS OUT PKTS IN  RECS IN"0d"0a/
XSTHD3	SC	/"0D"0A"0ANODE LINKS' TOTAL LOGICAL CPS RATES/		:###wjl
XSTHDB	SC	/"0D"0A"0ANODE LINKS' TOTAL PHYSICAL CPS RATES/		:###wjl
XSTHD6	SC	/    WRAP : /
XSTHD7	SC	/"0D"0A"0ACODE DELAY    H-WARE DELAY     TOTAL       EFFICIENCY"0D"0A    /
XSTHD8	SC	/"0D"0A  CPSO     CPSI     HWMO     HWMI"0D"0A/

XISHD1	SC	/"0D"0A"0ADRIF  DRIE  DROF  DROE  MXIN  MOUT  ICHN  ICON  OHST  ILLG  IDSM  ODSM"0D"0A/
XISHD2  SC      /"0D"0A  RANGE       COUNT   COUNT        PEAK OUT:/
XISHD3	SC	/ AT  /
	RA      0A      :change radix so text numbers are decimal
XISHD4	XRNTXT("0D"0A        ISIS RING UTILIZATION     RING SIZE:,$ADRSZ,5,"0D"0A)
XISHD6	SC	/"0D"0A"0ARING POINTER TO ISIS  FROM ISIS    PEAK IN :/
XISHD7  XRNTXT("0D"0AUNDER ,$ADRSZ/8,5,  )
	XRNTXT("0D"0A,$ADRSZ/8+1,5,-,$ADRSZ/4,5,  )
	XRNTXT("0D"0A,$ADRSZ/4+1,5,-,$A3*DRSZ/8,5,  )
	XRNTXT("0D"0A,$A3*DRSZ/8+1,5,-,$A4*DRSZ/8,5,  )
	XRNTXT("0D"0A,$A4*DRSZ/8+1,5,-,$A5*DRSZ/8,5,  )
	XRNTXT("0D"0A,$A5*DRSZ/8+1,5,-,$A6*DRSZ/8,5,  )
	XRNTXT("0D"0A,$A6*DRSZ/8+1,5,-,$A7*DRSZ/8,5,  )
	XRNTXT("0D"0A,$A7*DRSZ/8+1,5,-,$A8*DRSZ/8,5,  )
	RA      0       :back to normal

XTLMS1	SC	/"0D"0ATRACE LINK: /
XTNMS1	SC	/"0D"0ATRACE LINE: /

NEIMS1	SC	+NODE  TPBO  NLWS  SPNM  NCHN  ISEC  NRTR  AMSK"0D"0A+
NEIMS2	SC	+"0D"0AOSEC  NRMK  NRXM  LRT   LAS   LRM   LAR   NAS "0D"0A+
NEIMS3	SC	+"0D"0ABNOD  CHN0  B.PT  E.PT  ACHN  VERS  LINES"0D"0A+
NEIMS4	SC	+NETID  HOST  LINE"0D"0A+		:		###cwc
XBTMSG	SC	/"0D"0A"0A**ERROR AT 5A**"0D"0A/
DLDMS0	SC	/"0A**** TIME, AVE1, AVE2 AND DATA FIELDS ARE DECIMAL MS ****"0D/
DLDMS1	SC 	/"0A"0ATIME  CPS   STAT  FLAG  HWF   PTR   AVE1  AVE2"0D"0A/
DLDMS2	SC	/"0ANODES : /
DLDMS3	SC	/"0D"0A"0ADATA  :"0D"0A/

XSTMS0	SC	/"0D"0A"0APROCESS: SYLVR SPIDR SWICH LINKR Q-SEC H-SEC DWLIN SOURC X-RAY 1SEC"0D"0APERCENT: /
XSTMS1	SC	/"0D"0AMAX(MS): /
XNST01  SC      /"0D"0A***--LINE--***  ***--LINK-----***  LOGICAL  LOGICAL PHYSICAL PHYSICAL"0D"0A/
XNST02  SC      /NO. TYPE SPEED  NEIG  SPEED  CRQS  CPS IN   CPS OUT  CPS IN   CPS OUT"0D"0A/

	IF	TSTSZE
XTSFOR	SC	/"0D"0A"0A EVENT     LINE  HEAD  ACK   RECN     FASTC"0D"0A"0A/
XTSBAK	SC	/"0D"0A"0A EVENT     VA1   VA2   VA3   VA4      FASTC"0D"0A"0A/
XTSMSG	AC	/ZERO BIT/
	AC	/RESET   /
	AC	/DUMMYREC/
	AC	/CKSM ERR/
	AC	/BAD ACK /
	AC	/REXMISSN/
	AC	/BAD RECN/
	AC	/GOOD REC/
	AC	/RAW DATA/
TSNBTO	EQ	.-XTSMSG		:BEGINNNG OF BACKGROUND TEXT
	AC	/PKT MADE/
	AC	/PKT TORN/
	AC	/DETACH  /
	AC	/ATTACH  /
	AC	/ERROR!!!ERROR!!!ERROR!!!/
	EI      :TSTSZE


	SUBTTL	XRAY (Pointers)

TSPBAK	HS	1			:SAVE AREA FOR TMF/TMB POINTER

XDXN	HS	0		:POINT (XD) TO X-USER BLOCKS BY SLOT NO.
Q	EQ	XUBLK
TTYXD	EQ	XUBLK
	RE	NXUBLK
	if	alhub
	WC	Q			:MOVE XUBLK FROM SEG0		###AL
	else
	HC	Q
	ei
Q	EQ	Q+XUBSZ
	ER
	SYAD(XDXN  )			:ADD XDXN TO XRAY SYMBOL TABLE

	SUBTTL	XRAY (Link related save areas and tables)

:	LINK DESCRIPTOR SAVE AREA FOR 'KS'QUERY
	WS      0
XKSSKD  EQ      .-KS.PCO 		:ENABLE REFERENCE WITH KD EQUATES
	WS      (KSSZ+3)/4      :LINK DESCRIPTOR SAVE AREA FOR 'KS' QUERY
XKSZFG	HS	1		:KS STATS ZERO FLAG (FOR KS NGHBR# Z)	###OAS

XLUPFL  HS      1
TDMODE	HS	1		:CONTROLS ASCII/HEX OUTPUT MODE IN TD COMMAND
TDESFL	HS	1			:ESCAPE FLIPPER FOR TD, TE COMMANDS
XDLTMP  HS      1
XTDXCT  HS      1         		:EXECUTION COUNT FOR TD, PROTECTS
					: AGAINST FATAL LOOP
XTDFLG  HS      1         		:FLAG TELLS IF XRAY IS IN TD INST
XTSSAV  WC      0000FFFF         		:SAME FOR TM INSTRUCTION ###AL
XCRSAV  HS      5         		:SAVE AREA FOR COMMAND CLOBBERED BY SC
XCRADD  WS      1         		:SAVE AREA FOR CRASH ADDRESS
RWADDR  WS      1			:read/write routine address	###wjl
SYMASC  WS      2
LASTCL  WS      1         		:ADDR OF LAST CELL OPENED

TRMASK  HS      TRRSIZ/10 		:BIT ARRAY TO MASK TRC DATA

XABSSV	WS	1			:SAVE AREA FOR MISC ABS MEMORY STUFF
TRABSV	WS	1			:SAVE AREA FOR TRAP STUFF FROM ABSOLUTE

::*********************************************************************
::
::	TABLE:		HSPEED
::	FUNCTION:	CONVERTS LINE'S BAUDRT VALUE INTO HUMAN-READABLE FORM
::
::*********************************************************************

:	THE VALUES ARE CONVERTED AS FOLLOWS:
:	BAUDRT   HSPEED
:	0	 BLANKS (FOR TIILNK DOWN LINES)
:	1	 2.4
:	2	 4.8
:	3	 7.2
:	4 - 5	 9.6
:	6 - 7	 14.4
:	8 - B	 19.2
:	C - F	 28.8
:	10 - 13	 38.4
:	14 - 16	 48
:	17 - 1E	 56
:	1F	 MS

HSPEED	HS	0

	NOLIST

	RE	1
	SC	/      "00/
	ER
	RE	1
	SC	/2.4   "00/
	ER
	RE	1
	SC	/4.8   "00/
	ER
	RE	1
	SC	/7.2   "00/
	ER
	RE	2
	SC	/9.6   "00/
	ER
	RE	2
	SC	/14.4  "00/
	ER
	RE	4
	SC	/19.2  "00/
	ER
	RE	4
	SC	/28.8  "00/
	ER
	RE	4
	SC	/38.4  "00/
	ER
	RE	3
	SC	/48    "00/
	ER
	RE	8
	SC	/56    "00/
	ER
	SC	/MS    "00/

	LIST


	IF	(XRSZLV)		:##AL
::*********************************************************************
::
::	TABLE:		KSPCPS
::	FUNCTION:	DERIVE MAXIMUM CHARACTERS PER SECOND BASED ON
::			LINK SPEED VALUE IN 'KSPD' LINK DESCRIPTOR FIELD.
::
::*********************************************************************

:	EACH FW ENTRY CONSISTS OF A HW ENTRY GIVING LINK SPEED IN CPS AND
:	A HW ENTRY GIVING SPEED IN CHAR/FASTC. THE LATTER IS USED IN THE
:	MTRFIC ROUTINE

KSPCPS	WS	0
KSPCPF	EQ	KSPCPS+2		:CHARACTERS/FASTC
	RA	0A			:DECIMAL RADIX
Q	EQ	0
	RE	22		:FIRST 22 ENTRIES SPEED IS 2400 * KSPD VALUE
	HC	Q*2400/8
	HC	(Q*4)/8
Q	EQ	Q+1
	ER
	RE	9			:NEXT 9 AS 56 KB...
	HC	56000/8
	HC	12			:56 KBPS IS ABOUT 12 CHAR/FASTC
	ER
	HC	100000/8		:CALL MS 100KB
	HC	21			:21 CHAR/FASTC =>100.8KB

	RA	0			:RESTORE HEX RADIX

	EI	:(XRSZLV)		:##AL

	SUBTTL	XRAY (XRAY command table)

::*********************************************************************
::
::	TABLE:		COMTBL
::	FUNCTION:	XRAY COMMAND TABLE
::
::*********************************************************************

:	XCOMP. macro defaults to not audited, not read-own-args,
:	regular prompt.

DFXCM.	MACRO(NAME,MNEM,POWER,ARG1,ARG2,ARG3)[
	AC	/MNEM/
	HC	NAME/10000,NAME&0FFFF
	KILL	Q1.,Q2.,Q3.
Q1.`ARG1 EQ	0
Q2.`ARG2 EQ	0
Q3.`ARG3 EQ	0
.QQ.	EQ	0
	IF	1-\Q1.
.QQ.	EQ	.QQ.!ARG1
	EI
	IF	1-\Q2.
.QQ.	EQ	.QQ.!ARG2
	EI
	IF	1-\Q3.
.QQ.	EQ	.QQ.!ARG3
	EI
	HC	.QQ.
	KILL	Q.
Q.`POWER EQ	0
	IF	\Q.
	HC	1
	ELSE
	HC	POWER
	EI
	]

X.PWR	EQ	0			:requires power 1
X.NPWR	EQ	1			:non-privileged
X.SPWR	EQ	0FFFF			:SUPER-PRIVILEGED
X.RAR	EQ	1			:reads own args
X.AUD	EQ	2			:AUDIT TYPE COMMAND
X.EXPR	EQ	4			:CLOSE WITH BANNER AND TIMESTAMP



COMTBL	WS	0			:COMMANDS AND THEIR ADRESSES

	IF	(XRSZLV)		:LOWEST LEVEL COMMANDS##AL
	DFXCM.(PTCQRY,PQ,X.NPWR)	:DISPLAY PATCH HISTORY TABLE	###OAS
	DFXCM.(XNEIGB,KD,X.NPWR,X.EXPR)	:DISPLAY LINK DESCRIPTOR
	DFXCM.(XCROPT,CO,X.NPWR,X.EXPR)	:DISPLAY/SET CRSH OPTION	###OAS
	DFXCM.(XSTATS,NS,X.NPWR,X.EXPR)	:DISPLAY NODE STATISTICS
	DFXCM.(XDCRSH,DC,X.NPWR,X.RAR,X.EXPR)	:DISPLAY CRASH TABLE DATA
	DFXCM.(XND,ND,X.NPWR,X.EXPR)	:NODE SNAP
	DFXCM.(XKS,KS,X.NPWR,X.EXPR)	:LINK STATISTICS
	EI	:(XRSZLV)

	IF	(XRSZLV-1)		:XRSZLV DEFAULT=3##AL
	DFXCM.(XTYPE,R ,X.NPWR,X.RAR)	:READ
	DFXCM.(READS,RS,X.NPWR,X.RAR)	:READ SYMBOLIC
	DFXCM.(DISADR,SA,X.NPWR,X.RAR)	:DISPLAY SYMBOL ADDRESS
	DFXCM.(GETPWR,GP,X.NPWR,X.RAR)
	DFXCM.(XWRMSG,WM,X.NPWR,X.RAR)	:WARNING MESSAGE
	DFXCM.(SETMES,SM,X.SPWR,X.AUD,X.RAR) :ENABLE/DISABLE CRYPTO MSGS###OAS
	DFXCM.(XRYPFM,PM,X.PWR)		:DO PERFORMANCE MONITORING ON CHAN
	DFXCM.(XCRMOD,CD,X.NPWR,X.EXPR)	:SET CRYPTO DISPLAY MODE
	DFXCM.(CRYLST,CL,X.NPWR,X.EXPR)	:DISPLAY CRYPTO LOG
	DFXCM.(SYMBAD,SY,X.NPWR,X.RAR)	:DISPLAY SYMBOL ADDRESSES
	DFXCM.(CRYMSG,CM,X.NPWR,X.RAR,X.EXPR)	:DISPLAY CRYPTO MSGS BY TYPE
	DFXCM.(XCHTRC,TC,X.PWR)		:SET CHANNEL DATA TRACE
	DFXCM.(TRCDAT,TD,X.NPWR,X.EXPR)	:DISPLAY CHANNEL TRACE DATA
	DFXCM.(TRCDES,TE,X.NPWR,X.EXPR)	:DISPLAY CHANNEL TRACE DATA W/ ESCAPES
	DFXCM.(TRCASC,TA,X.NPWR,X.EXPR)	:DISPLAY CHANNEL TRACE DATA ASCII
	DFXCM.(XLUPBK,DL,X.SPWR)	:CYCLOTRON
	DFXCM.(DBEGIN,DB,X.NPWR)	:BEGIN DELAY MEASUREMENT
	DFXCM.(DLYEND,DE,X.NPWR)	:END DELAY MEASUREMENT
	DFXCM.(DLDATA,DD,X.NPWR,X.EXPR)	:DISPLAY DELAY MEASUREMENT DATA
	DFXCM.(XBRZAP,BZ,X.PWR,X.AUD,X.EXPR)	:BORI ZAP A LINK
	DFXCM.(QRYCHN,QC,X.NPWR,X.EXPR)	:QUERY CHANNEL
	DFXCM.(XACHAN,AC,X.NPWR,X.EXPR)	:DISPLAY ACTIVE CHANNELS	###OAS
	DFXCM.(XRCFIG,FG,X.NPWR)	:Display enabled flags		###sdw
       if       1-swtchr
	DFXCM.(ISSTAT,IS,X.NPWR,X.EXPR)	:ISIS STATUS
       ei       :1-swtchr

	IF	1-T2GATE
	DFXCM.(HSTDS,HS,X.NPWR,X.EXPR)	:DISPLAY EXPANDED HOST INFO	###OAS
	EI	:1-T2GATE

	IF	TSTSZE
	DFXCM.(XTLINK,TL,X.NPWR)	:TRACE LINK
	DFXCM.(XTSDAT,TM,X.NPWR)	:DISPLAY TRACE LINK DATA
	DFXCM.(XTLINE,TN,X.NPWR)	:TRACE UNASSIGNED LINE		###OAS
	EI	:TSTSZE

	EI	:(XRSZLV-1)		:##AL


	IF	(XRSZLV-2)		:##AL
	DFXCM.(WRITES,WS,X.NPWR,X.RAR,X.AUD)	:WRITE SYMBOLIC, DOES ITS OWN
						:SECURITY CHECK.
	DFXCM.(CHNBFL,CB,X.PWR,X.RAR)	:CHAIN THROUGH BUFFERLETS 	###wjl
	DFXCM.(XRMTCH,MA,X.PWR,X.EXPR)	:FIND MATCH IN MEMORY
	DFXCM.(XSIOST,SS,X.NPWR)	:DISPLAY SIO LINE STATUS	###wjl
	DFXCM.(SETTRP,ST,X.SPWR)	:SET TRAP
	DFXCM.(REMTRP,RT,X.SPWR)	:REMOVE TRAP
	DFXCM.(DISTRP,DT,X.NPWR,X.EXPR)	:DISPLAY TRAPS
	DFXCM.(WRITE,W ,X.SPWR,X.AUD)	:WRITE HALFWORD
	DFXCM.(WRITEF,WF,X.SPWR,X.AUD)	:WRITE FULLWORD
	DFXCM.(REGIST,RR,X.NPWR,X.EXPR)	:READ CRASH REGISTERS
	DFXCM.(XDCOCT,DO,X.NPWR)	:CONVERT DECIMAL TO OCTAL	###OAS
	DFXCM.(XOCDEC,OD,X.NPWR)	:CONVERT OCTAL TO DECIMAL	###OAS
	DFXCM.(XHXOCT,HO,X.NPWR)	:CONVERT HEX TO OCTAL
	DFXCM.(XOCHEX,OH,X.NPWR)	:CONVERT OCTAL TO HEX
	DFXCM.(XDCHEX,DH,X.NPWR)	:CONVERT DECIMAL TO HEX
	DFXCM.(XHXDEC,HD,X.NPWR)	:CONVERT HEX TO DECIMAL
	DFXCM.(XLECHO,LE,X.NPWR)	:SET LOCAL ECHO
	DFXCM.(XRECHO,RE,X.NPWR)	:SET REMOTE ECHO
	DFXCM.(SETCRS,SC,X.SPWR,X.EXPR)	:SET CRASH
	DFXCM.(SETBP,SB,X.SPWR,X.EXPR)	:SET BREAKPOINT
	DFXCM.(REMCRS,RC,X.SPWR)	:REMOVE CRASH OR BREAKPOINT
	DFXCM.(XRDBUF,RB,X.PWR,X.EXPR)	:READ BUFFER			###OAS
	DFXCM.(XWRBUF,WB,X.SPWR,X.EXPR)	:WRITE BUFFER
	DFXCM.(XGGMOD,XG,X.NPWR,X.AUD,X.EXPR)	:DISPLY/MODFY XRAY GOODGUY LIST
	DFXCM.(XBUFLT,BS,X.NPWR,X.EXPR)	:DISPLAY BUFFERLET USE HISTOGRAMS
	DFXCM.(XBGLST,BG,X.NPWR,X.AUD)	:MODIFY BADGUY LIST
					:SUPPLIES IT'S OWN SECURITY	###OAS
	DFXCM.(XNID,NI,X.SPWR,X.RAR,X.AUD) :allow neig with diff NETID	###wjl
	DFXCM.(XRYWSZ,WZ,X.SPWR,X.EXPR,X.AUD)  :CHANGE WINDOW SIZE
	DFXCM.(XCHNEI,CN,X.SPWR,X.EXPR,X.AUD)  :CHANGE neighbor

       IF       1-NCSLOT
	DFXCM.(DRINGS,DR,X.PWR)		:DUMP DISPATCHER RINGS		###wjl
	DFXCM.(DSRNGS,DS,X.PWR)		:DUMP SAVED RINGS		###wjl
       EI       :1-NCSLOT

	IF	.PROF.
	DFXCM.(PROFILE,PR,X.NPWR,X.RAR)	: PROFILE			###JOK
	EI	: .PROF.

	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl	
	DFXCM.(XTRACE,TR,X.SPWR)	:SET TRACER ON/OFF FOR SPECIFIED RANGE
	DFXCM.(TYPTRC,TT,X.NPWR,X.EXPR)	:DISPLAY UPSW TRACE TABLE
	EI	:DB.TRC

	IF	BFLTMR			:###jhl
	DFXCM.(XBDSET,BD,X.PWR)		:set buffer delay timing method
	EI	:BFLTMR

	IF	SILINS
	DFXCM.(RSSILN,SI,X.SPWR,X.AUD)	:Initialize an SIO line.	###LSH
	EI      :SILINS

      IF        XRYRMK
	DFXCM.(XRYWPK,PK,X.NPWR,X.EXPR) 	:histogram on packetsize###sdw
      EI	:XRYRMK

	IF	PRIMSG
	DFXCM.(SETPRI,AP,X.PWR,X.AUD,X.RAR) :EN/DISA CRYPTO priority MSGS##AL
	DFXCM.(CRYLTP,CP,X.NPWR,X.EXPR)	:DISPLAY CRYPTO priority LOG	###al
	EI	:PRIMSG

	EI	:(XRSZLV-2)		:##AL



	IF	LNFDBG 	:**********************************************
	DFXCM.(LGXRDB,LG,X.SPWR)	:DISPLAY PORT LOGON/LOGOFF HISTORY RING
	GL	LGXRDB
	EI	:LNFDBG

	IF	CBZDBG
	DFXCM.(CZXRDB,CZ,X.SPWR)	:DISPLAY CIRCUIT BUILDING/ZAPPING
	GL	CZXRDB
	EI	:CBZDBG		 HISTORY RING

       IF       LNKDBG    		:line/link debugger by          ###sdw
	DFXCM.(LHXRDB,LH,X.SPWR)	:DISPLAY LINK/LINE HISTORY RING
	GL	LHXRDB
       EI  :LNKDBG

	IF	BFSDBG
	DFXCM.(BFXRDB,BF,X.SPWR)	:DISPLAY BUFFER STRUCTURE HISTORY RING
	GL	BFXRDB
	EI	:BFSDBG

	IF	LPGDBG
	DFXCM.(LLXRDB,LL,X.SPWR)	:DISPLAY NODE CODE -SUPERVISOR
	GL	LLXRDB
	EI	:LPGDBG		 COMMUNICATION HISTORY RING

	IF	DBGON	
	DFXCM.(THXRDB,TH,X.SPWR,X.AUD)	:TURN ON/OFF HISTORY TRACE
	GL	THXRDB
	EI	:DBGON	**********************************************


XNCMND	EQ	(.-COMTBL)/0A		:TOTAL NUMBER OF XRAY COMMANDS###wjl

	SUBTTL	XRAY (Scheduler)

::*********************************************************************
::
::	PROCESS:	XRYSCH:
::	FUNCTION:	SCHEDULER FOR REMOTE XRAY USER
::	SCHEDULED:	On demand by G500MS if XRAY has trap output to dump,
::	on demand by any calls to output real-time CRYPTO messages to a 
::	remote XRAY user, and on demand by INTHST requesting processing
::	of remote XRAY data.
::	YIELDS:		Between long processing loops in XRAY code,
::	during performance measurment calculations and between every
::	160 characters output by XRAY.  After yielding XRYSCH is re-
::	scheduled on a 125 MS periodic basis.
::	DISMISSES:	To the EXEC loop if no command data, if all output
::	is complete and no more input is available.
::	CALLS:		JAL	R11,XWRITE
::			JAL	R11,XPRTKT
::
::*********************************************************************

:	THE CURRENT USER PC IS STORED AT XRYADR. XRYSCH VERIFIES THAT
:	XRAY IS IN REMOTE MODE BEFORE TRANSFERING CONTROL. FOR AN ISIS
:	MACHINE THIS MEANS INTXRF > 0.

XRYSCH	HS	0
	LIS	R0,0
	STH	R0,XRYRUN		:CLEAR XRAY RUN FLAG IN CASE IT WAS SET
	LHI	R0,01F-PXRAY
	RBT	R0,T125MS
XRYSC0	LHL	R0,XQUEC		:GET CURRENT XRAY USER QUESER QUEUE
	NHI	R0,7FFF			:IN CASE TTY XRAY GOT SCHEDULED
	JFFOH	R0,XRYSC1		:GO DO IT TO IT
	JFS	XRYSC2
XRYSC1	if	alhub
	SLLS	R1,1			:2*R1
	L	XD,XDXN,R1,R1		:XUBLK POINTER BY FULLWORD	###AL
	SRLS	R1,1
	else
	LHL	XD,XDXN,R1,R1		:XUBLK POINTER
	ei
	JAL	R11,XWRITE		:GIVE XRAY WRITE ACCESS TO SEGD
	L	R0,XRYADR,XD		:GET USER PC
	JR	R0			:AND DISPATCH
XRYSC2	LHL	R0,XQUEM		:NO ONE IN CURRENT QUEUE, SO GET
	JE	EXDISM,,		:MASTER QUEUE
	STH	R0,XQUEC		:AND MAKE IT CURRENT
	LIS	R0,0			:ZERO OUT MASTER QUEUE
	STH	R0,XQUEM		:
	J	XRYSC0			:TRY AGAIN

XRYDIS	HS	0
	ST	R0,XRYADR,XD		:SAVE USER PC
	LHL	XN,XUSLTN,XD		:XRAY USER SLOT NUMBER
	RBT	XN,XQUEC		:TAKE OUT OF QUEUECURRENT
	JAL	R11,XPRTKT		:RESTORE SEGD WRITE PROTECT
	LHL	R0,XQUEC
	OH	R0,XQUEM
	JE	EXDISM,,
	JFS	XRYYL1

XRYYLD	HS	0
	ST	R0,XRYADR,XD		:SAVE USER PC
	LHL	R0,XUSLTN,XD		:XRAY USER SLOT NO.
	RBT	R0,XQUEC		:TAKE OUT OF QUEUECURRENT
	SBT	R0,XQUEM		:RESCHEDULE IN QUEUEMASTER
	JAL	R11,XPRTKT		:RESTORE SEGD WRITE PROTECT
XRYYL1	LHI	R0,1F-PXRAY		:RESCHEDULE XRAY IN 1/8 SEC
	SBT	R0,T125MS		:BY SETTING APPROPRIATE TIMEOUT BIT
	J	EXDISM,,		:DISMISS

	SUBTTL	XRAY (Utility routines for scheduling remote XRAY)

::*********************************************************************
::
::	SUBROUTINE:	XWRITE:
::	FUNCTION:	Give XRAY write access
::	CALLING SEQ:	JAL	R11,XWRITE
::
::*********************************************************************

XWRITE	HS	0
	LI	R0,XSG1WA		:ISIS SVC FOR WRITE ENABLE
	SVC	SYS,$A17
      IF	1-NAD68
	LI	R0,XSGDWA		:NEED SEGD WRITE ENABLE ALSO
	SVC	SYS,$A17
      EI	:NAD68
	JR	R11			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	XPRTKT:
::	FUNCTION:	Restore write protect
::	CALLING SEQ:	JAL	R11,XPRTKT
::
::*********************************************************************

XPRTKT	HS	0
	LI	R0,XSG1WP		:ISIS SVC FOR WRITE PROTECT
	SVC	SYS,$A17
      IF	1-NAD68
	LI	R0,XSGDWP		:ALSO RESTORE SEGD WRITE PROTECT
	SVC	SYS,$A17
      EI	:NAD68
	JR	R11			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	XCLEAN:
::	FUNCTION:	CLEANS UP X-RAY STATUS FOLLOWING ^C OR LOGOUT
::	CALLING SEQ:	JAL	R11,XCLEAN
::
::*********************************************************************

XCLEAN	HS	0
	CLH	XD,XWMCIU
	JNFS	XCLEA0
	LIS	R0,0
	STH	R0,XWMCIU
XCLEA0	C	XD,XKSCIU		:IN MIDDLE OF KS?
	JNFS	XCLEA1			:NO
	LIS	R0,0
	ST	R0,XKSCIU		:KS COMMAND NOT IN USE ANY MORE
XCLEA1	TS	XTDFLG			:IN MIDDLE OF TD INST WHEN ^C STRUCK?
	JLFS	XCLEA7			:NO
	LHI	R0,208			:YES
	STH	R0,CHRTRC,,		:RE-ENABLE TRACE
XCLEA7	HS	0
	IF	TSTSZE
	L	R0,XTSSAV		:IN TM INST WHEN ^C STRUCK?	###OAS
	CI	R0,0000FFFF		:INIT VALUE, NO UPDATING	###AL
	JE	XCLEA8			:NO				###wjl
	STH	R0,TSLINE		:YES, RESTORE TSLINE		###OAS
	EXHR	R0,R0			:AND				###OAS
	STH	R0,TSLINK		:RESTORE TSLINK TO REENABLE TSN
	LI	R0,0000FFFF		:CLEAR TO INIT VALUE		###AL
	ST	R0,XTSSAV		:AND CLEAR OUT XTSSAV SO WE DONT REPEAT
	EI	:TSTSZE			:###OAS

XCLEA8	HS	0
	JR	R11			:RETURN TO CALLER

	SUBTTL	XRAY (Main command loop)

::*********************************************************************
::
::	MAIN COMMAND LOOP:	XLOOP:
::	ENTRY POINTS:	XRCRLF/XRPRMT/XPRMPT
::			XRAY	:SHEDULED BY SOLO CONTEXT SWITCHER OR ISIS DDT
::			XRAYIS	:REMOTE USER LOGGING IN OR TYPING ^C
::
::*********************************************************************

XRCRLF	HS	0
	JAL	R7,TYPCRL,,
XRPRMT	HS	0
XPRMPT	HS	0
	L	R11,XPRTTP,XD
	JE	XNRPRT
	JR	R11

:	subroutine which waits for background to complete a task for XDDT
:	that would corrupt data if XDDT and background job were both in that
:	area of code.  Main case is bufferlet pool.			###sdw
:	the background is checked to make sure that a crash doesn't
:	put this into a loop since BG will never do requested task

XDDTWT	SVC	KIO,8			:background running?
	J	0,R8			:null return - BG not running, return
	L	R0,XDDTAD		:did background complete task?
	JER	R8			:yes, return to caller
	SVC	DISMIS			:wait a little more
	J	XDDTWT			:and check again

:	ENTRY POINT - XRAY SCHEDULED BY ISIS DDT (?STAT)

XRAY	HS	0
	JAL	R11,XWRITE		:allow write to any seg
	LI	XD,TTYXD		:POINTER TO SPECIAL USER BLOCK
	LIS	R0,0			:tty fits in XRAY slot 0
	STH	R0,XUSLTN,XD		:			###sdw

:	ENTRY POINT - REMOTE XRAY USER LOGGING IN OR TYPING ^C

XRAYIS	HS	0
	JAL	R7,TYPASI,,
	IF	T2GATE
	SC	/"0D"0A**GATEWAY OPERATION MANAGER** /
	ELSE	:NOT T2GATE
	SC	/"0D"0A**X-RAY** /
	EI	:T2GATE##AL
	JAL	R7,TYPASI,,
	SC	/NODE: /
	LHI	R3,MACHNM		:GET NODE NUMBER IN HEX		###SHM
	JAL	R9,HEXOCT,,		:CONVERT TO OCTAL		###SHM
	JAL	R9,TYP5CH,,		:TYPE 5 OCTAL DIGIT NODE #	###SHM
	JAL	R7,TYPASI,,
	SC	/HOST: /
	LHI	R3,HST0			:get kernel host number		###wjl
	JAL	R9,TYP5DD,,		:type it in decimal		###cwc
	JAL	R7,TYPASI,,
	SC	/TIME: /
	JAL	R9,GMTCAL,,
	L	R2,GMTNOW
	JAL	R9,GMTCNV,,
	IF	(XRSZLV-1)		:##AL
	LHL	R0,CRYPRI		:CLEAR CRYPTO BUFFER
	STH	R0,CRYPTU,XD
	LIS	R0,1			:init auto crypto off		###sdw
	STH	R0,CRYMOD,XD
	EI	:(XRSZLV-1)		:##AL
	IF	(XRSZLV-2)		:##AL
	IF	PRIMSG
	LHL	R0,CRYPPI		:CLEAR CRYPTO priority BUFFER	###al
	STH	R0,CRYPPU,XD		:				###al
	EI	:PRIMSG
	EI	:(XRSZLV-2)		:##AL
	LHI	R0,$A16*4		:INITIALIZE TO 8 ARGUMENTS MAX
	STH	R0,ARGMAX,XD
	JAL	R11,XCLEAN		:DO CLEANUP
	IF	(XRSZLV-1)		:##AL
	LHL	R0,XUINTH,XD
	RBT	R0,XWMFLG,,
	JEFS	COMCLR
	LB	R0,XWMSGB
	JEFS	COMCLR
	JAL	R5,XWMDIS
	EI	:(XRSZLV-1)		:##AL

COMCLR	HS	0
	lhl     r0,xusltn,xd
	rbt     r0,xtdato,,     	:disable auto tracing
	LIS	R0,0			:RESTORE SIMPLE PROMPT JUST IN CASE
	ST	R0,XPRTTP,XD		:	SO WE DON'T GET TWO HEADERS
	LHL	R0,XRYPTF,XD		:CLEAR INPUT RING
	STH	R0,XRYPTE,XD
	J	XRPRMT

XEXPRT	HS	0
	JAL	R7,TYPASI,,
	IF	T2GATE			:##AL
	SC	/"0D"0A**GATEWAY OPERATION MANAGER** /
	ELSE	:NOT T2GATE
	SC	/"0D"0A**X-RAY** /
	EI	:T2GATE
	JAL	R7,TYPASI,,
	SC	/NODE: /
	LHI	R3,MACHNM		:GET NODE NUMBER IN HEX		###SHM
	JAL	R9,HEXOCT,,		:CONVERT TO OCTAL		###SHM
	JAL	R9,TYP5CH,,		:TYPE 5 OCTAL DIGIT NODE #	###SHM
	JAL	R7,TYPASI,,
	SC	/HOST: /
	LHI	R3,HST0			:get kernel host number		###wjl
	JAL	R9,TYP5DD,,		:type it in decimal		###cwc
	JAL	R7,TYPASI,,
	SC	/TIME: /
	JAL	R9,GMTCAL,,
	L	R2,GMTNOW
	JAL	R9,GMTCNV,,

XNRPRT	LA	R2,ASPRMT		:TYPE PROMPT
	JAL	R7,TYPASC,,
	LIS	R0,0
	ST	R0,XPRTTP,XD		:RESTORE NORMAL PROMPT

:	MAIN COMMAND LOOP - XRAY LOOPS HERE UNTIL IT RECEIVES A
:	COMMAND TO EXECUTE OR IS RESTARTED

XLOOP	HS	0
	IF	(XRSZLV-2)		:##AL
	LHL	R4,TRPFLG,,		:HAVE ANY TRAPS COME IN?
	JN	TRPDOR			:YES, DISPLAY TRAPS
	EI	:(XRSZLV-2)		:##AL

	lhl     r8,xusltn,xd    	:get xray user #
xlop00  tbt     r8,xtdato 		:port doing continous display?
	je      xloop0
	lhl     r5,xtdcpt,r8,r8 	:any new msgs to display?
	clh     r5,trrix
	je      xloop0    		:nothing to display
	jal     r7,typcrl,,
	lis     r11,0     		:display input and output
	lhi     r10,(trrsiz/8)-4
xlop33  sth     r11,trmask,r10,
	sis     r10,4
	jgebs   xlop33
	lr      r10,r5    		:make sure >0 cause checked
	lis     r13,0f    		:max # of msgs to display
	j       trcd49,,

XLOOP0	HS	0
	IF	(XRSZLV-1)		:##AL
	LHL	R0,CRYPRI		:TEST FOR CRYPTO...GET IN-POINTER
	LHL	R1,CRYMOD,XD		:ARE WE AUTOMATICALLY DISPLAYING?
	JEFS	XLOOPA			:YES
	STH	R0,CRYPTU,XD		:NO, DON'T LET THEM PILE UP
	IF	(XRSZLV-2)		:##AL
	IF	PRIMSG
	LHL	R2,CRYPPI		:TEST FOR CRYPTO...GET IN-POINTER##al
	STH	R2,CRYPPU,XD		:NO PILE UP			###AL
	EI	:PRIMSG
	EI	:(XRSZLV-2)		:##AL

XLOOPA	CLH	R0,CRYPTU,XD		:ANY CRYPTO MESSAGES?
	JE	XLOOP2			:NONE CAME IN
	JAL	R7,TYPCRL,,		:LOOK PRETTY
	LCS	R14,4			:OUTPUT MESSAGES ONE AT A TIME
	LCS	R12,1			:ENABLE ALL MESSAGES
	JAL	R8,XCRYPT		:OUTPUT CRYPTO MESSAGES
	CI	XD,TTYXD		:TTY USER?
	JE	XLOOP3			:YES
	LHL	R0,CRYPTU,XD		:REMOTE USER...
	CLH	R0,CRYPRI		:HAVE WE TYPED ALL MESSAGES?
	JEFS	XLOOP3			:YES
	TS	XRYRUN			:NO, RESCHEDULE IN 1 SECOND
	LHL	R0,XUSLTN,XD		:GET THIS USER'S SLOT #
	SBT	R0,XQUEM		:SET THIS USER IN MASTER QUEUE

XLOOP3	LA	R2,ASPRMT
	JAL	R7,TYPASC,,		:TYPE PROMPT
	EI	:(XRSZLV-1)		:##AL

XLOOP2	HS	0
	JAL	R13,XRYTST,,		:IS THERE DATA IN TTY BUFF?
	SKIPAD(XRYGET)			:YES, GET COMMAND AND ARGUMENTS

XLOOP1	HS	0
	CI	XD,TTYXD		:+4 return, TTY USER?
	JNFS	XLOOP4			:NO
	SVC	DISMIS,1		:ISIS DISMISS FOR 1 SEC
	J	XLOOP			:REPEAT WHEN RESCHEDULED
XLOOP4	JAL	R0,XRYDIS		:REMOTE DISMISS
	J	XLOOP

XRYGET	JAL	R9,RDCOMD,,		:RETURNS COMMAND IN R0		###jhl

COMDSP	HS	0
	LH	R5,XPOWER,XD		:THIS USER'S ACCESS POWER	###TZ
	LHI	R14,XNCMND*0A		:				###wjl
COMDS1	SIS	R14,0A			:				###wjl
	JL	COMEC1
	LHL	R2,COMTBL,R14		:IS THIS THE COMMAND?
	CR	R0,R2
	JNBS	COMDS1			:NO, TRY NEXT ONE
:	GOT THE RIGHT COMMAND
	LR	R5,R5			:SUPER POWER?			###TZ
	JLFS	COMDS6			:YES, USER CAN DO ANYTHING	###TZ
	CLH	R5,COMTBL+8,R14		:IS THIS USER AUTHORIZED?	###wjl
	JG	XPWERR			:NO, TELL HIM SO
COMDS6	LIS	R5,0E			:TEST '2' BIT			###TZ
	TBT	R5,COMTBL+6,R14		:AUDIT TYPE COMMAND?		###wjl
	JE	XAUSKP			:NO, SKIP OVER

	LHL	R8,XUNAME,XD		:GET USER'S INDEX INTO GGLIST
	L	R5,XRAYGG+XGGNAM+2,R8,	:GET CHARS 3,4,5,6 OF USERNAME
	ST	R5,CRYSBF		:FOR CRYPTO MESSAGE
	EXHR	R0,R0			:MOVE COMMAND TYPE TO HO HW
	LHL	R5,XRAYGG+XGGNAM,R8,	:AND COMBINE
	AR	R0,R5			:WITH CHARS 1,2 OF USERNAME

	JAL	R8,CRYPTO,,		:R0 CONVENIENTLY HOLDS THE COMMAND
	HC	CRYE54			:TYPE = COMMAND AUDIT
XAUSKP	HS	0
	LIS	R0,0			:assume regular prompt
	LIS	R5,0D			:test '4' bit
	TBT	R5,COMTBL+6,R14		:				###wjl
	JEFS	COMDS5
	LI	R0,XEXPRT		:expanded prompt
COMDS5	HS	0
	ST	R0,XPRTTP,XD		:end of command return address
	CLHI	R1,ASCCR+80		:DID USER CLOSE WITH <CR>?
	JE	COMDS3			:YES, PRESUME HE KNOWS WHAT HE DO
	LIS	R5,0F			:TEST '1' BIT
	TBT	R5,COMTBL+6,R14		:DEFAULT ARGUMENT CALL?		###wjl
	JN	COMDS2			:NO, COMMAND WILL READ ITS OWN ARGS
	JAL	R9,RDARGS,,		:YES, READ THE ARGUMENTS	###jhl
COMDS3	LR	R8,R1			:SAVE LAST CHAR THAT USER TYPED
	JAL	R7,TYPCRL,,		:TYPE CR-LF
	LR	R1,R8			:RECOVER LAST CHAR USER TYPED
COMDS2	L	R14,COMTBL+2,R14	:GET THE ADDRESS		###wjl
	JR	R14			:AND DISPATCH			###wjl

XPWERR	JAL	R13,XRYIN,,		:WAIT FOR CR
	NHI	R1,ASC7BT		:mask to seven bits
	SIS	R1,ASCCR		:is it a <cr>?
	JNBS	XPWERR
XPWER1	HS	0		:ENTRY POINT THAT DOESN'T WAIT FOR CR###OAS
	LA	R2,ASPWER		:INFORM USER
	JAL	R7,TYPASC,,
	J	COMCLR			:AND RETURN TO TOP

XCOMIU	LA	R2,ASCOMU		:COMMAND IN USE
	JAL	R7,TYPASC,,
	J	COMCLR

COMECR	JAL	R13,XRYIN,,		:WAIT FOR <CR> TO INDICATE TERMINATION
COMEC1	NHI	R1,ASC7BT		:STRIP OFF HOB
	SIS	R1,ASCCR		:CR?
	JNBS	COMECR			:NO,KEEP LOOPING
COMERR	LA	R2,ASC02		:INVALID COMMAND, TYPE ??
	JAL	R7,TYPASC,,
	J	XRCRLF,,			

	SUBTTL	XRAY (Read, Write - WM, W , WF, RG, RA, WA, R , CB)

	IF	XRYMES			:IF XRAY MESSAGE PROVIDED IN TYMFILE
					:FILL IN CONFIGURED MESSAGE
XWMSGB	XRYMS0				:(SEE XRYMSG/XRYMS0 MACROS)
	ELSE	:XRYMES			:ELSE, NO MESSAGE PROVIDED IN TYMFILE
XWMSGB	BS	1
	BC	0D,0A			:LEADING CR/LF
	EI	:XRYMES

	ORG	XWMSGB+47		:LEAVE 44 FOR MESSAGE BUFFER
XWMSGT	WS	1			:XRAY WARNING MESSAGE TIME
XWMCIU	HS	1			:COMMAND IN USE FLAG

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	XWRMSG:	WM
::	FUNCTION:	XRAY WARNING MESSAGE
::	INPUT:		WM<cr> - PROMPTS FOR MESSAGE
::			WM1 - DISPLAYS WARNING MESSAGE BUFFER
::			WM0 - ERASES WARNING MESSAGE BUFFER
::
::*********************************************************************

MXWMSG	EQ	40			:max warning msg length

XWRMSG	HS	0
	JAL	R13,XRYIN,,
	CLHI	R1,ASCCR		:CARRIAGE RETURN?
	JN	XWRM00			:NO

	LB	R2,XWMSGB		:MAKE SURE BUFFER IS EMPTY
	JE	XWRM01			:OK

	JAL	R7,TYPASI,,
	SC	/"0D"0AMESSAGE BUFFER IN USE"0D"0A/
XWRM02	HS	0
	LB	R2,XWMSGB		:ANYTHING THERE?
	JE	XRPRMT
	JAL	R5,XWMDIS
	J	XRPRMT

XWMDIS	HS	0
	LA	R2,XWMSGB
	JAL	R7,TYPASC,,			:DISPLAY CURRENT MESSAGE
	JAL	R7,TYPASI,,
	SC	/"0D"0AMESSAGE ENTERED: /
	L	R2,XWMSGT		:AND MESSAGE TIME
	JEFS	XWMDS9
	ST	R2,GMTNOW
	JAL	R9,GMTCNV,,		:###jhl
	JR	R5
XWMDS9	JAL	R7,TYPASI,,		:INDICATE MESSAGE ENTERED AT ASSEMBLY TIME
	SC	/AT ASSEMBLY TIME/
	JR	R5

XWRM00	HS	0		:USER WANTS TO DISPLAY OR CLEAR MESSAGE BUFFER
	NHI	R1,ASC7BT		:STRIP PARITY
	CLHI	R1,ASCONE		:'1' = DISPLAY MESSAGE?
	JE	XWRM02			:YES

	CLHI	R1,ASCZRO		:'0' = CLEAR MESSAGE BUFFER?
	JN	COMERR

XWRM03	HS	0
	LIS	R1,0			:ZERO OUT MESSAGE BUFFER COUNT
	STB	R1,XWMSGB
	JAL	R7,TYPASI,,
	SC	/"0D"0AMESSAGE BUFFER CLEARED"0D"0A/
	J	XRPRMT

XWRM01	HS	0
	LHL	R2,XWMCIU
	JE	XWRM11
	JAL	R7,TYPASI,,
	SC	/"0D"0ABUSY"0D"0A/
	J	XRPRMT
XWRM11	HS	0
	STH	XD,XWMCIU
	JAL	R7,TYPASI,,
	SC	/"0D"0AENTER MESSAGE (<60 BYTES):"0D"0A/
	LIS	R5,2			:INIT MESSAGE LENGTH COUNT
XWRM10	JAL	R13,XRYIN,,
	NHI	R1,ASC7BT		:STRIP PARITY
	CLHI	R1,ASCCR		:<CR>?
	JE	XWRM04			:YES

	CLHI	R5,40
	JLE	XWRM12

	JAL	R7,TYPASI,,
	SC	/"0D"0AMESSAGE TOO LONG - TYPE <CR>"0D"0A/
	J	XWRM10

XWRM12	HS	0
	STB	R1,XWMSGB+3,R5		:STORE CHAR. IN MESSAGE BUFFER
	AIS	R5,1			:INC. MSG LENGTH COUNT
	J	XWRM10

XWRM04	HS	0
	CLHI	R5,MXWMSG
	JLEFS	XWRM41
	LIS	R1,0
	STH	R1,XWMCIU
	J	XWRM03

XWRM41	HS	0
	LIS	R1,0D
	STB	R1,XWMSGB+3,R5
	LIS	R1,0A
	STB	R1,XWMSGB+4,R5
	AIS	R5,2
	STB	R5,XWMSGB

	JAL	R9,GMTCAL,,
	L	R2,GMTNOW
	ST	R2,XWMSGT

	LIS	R0,0
	STH	R0,XWMCIU

	J	XRPRMT

	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	WRITE:	W
::	FUNCTION:	SIMILAR TO OPEN
::	INPUT:		VALUE1 = STARTING ADDRESS
::			VALUE1+4 = BYTE COUNT (OPTIONAL, DEFAULT = 2)
::
::*********************************************************************

WRITE	HS	0
	LHL	R2,ARGCT,XD
	JE	COMERR			:NO ZERO ARGUMENTS
	LIS	R12,0
	CLHI	R2,8
	JG	COMERR			:OR MORE THAN 2
	JL	WRITE5			:SINGLE ARGUMENT IS ADDRESS
	L	R12,VALUE1+4,XD		:SECOND VALUE IS COUNT

WRITE5	L	R11,VALUE1,XD		:ADDRESS
	THI	R11,1			:ONLY EVEN ADDRESSES
	JN	WRERR
WRITE4	LR	R3,R11
	JAL	R9,CHKMAC		:GET MAC APPROVAL
	J	CHKMA1			:ERROR IF IMMEDIATE RETURN
	CI      R11,0E0000		:SEG E OR F?
	JGE     CHKMA1    		:CAN'T WRITE THERE
	JAL	R9,TYPADD,,		:TYP OUT ADDRESS
	LHL	R3,0,R11
	JAL	R9,TYPHW,,
	JAL	R9,RDARGS,,		:GET NEW VALUE
	CLHI	R2,4
	JG	COMERR			:0 OR 1 ARGUMENT ONLY
	JE	WRITE2			:1 ARG
	CLHI	R1,ASCBSL
	JE	WRITE3			: '\'
	CLHI	R1,ASCFSL		: '/'
	JEFS	WRITE3
	CLHI	R1,ASCCR
	JN	COMERR
	JAL	R7,TYPCRL,,		:A CR EXITS US
	J	XRPRMT
WRITE2	STH	R3,0,R11		:STORE THE VALUE
WRITE3	JAL	R7,TYPCRL,,		:CR-LF
	AIS	R11,2
	SIS	R12,2			:DECREMENT COUNT
	JG	WRITE4			:SOME LEFT
	J	XRPRMT

::*********************************************************************
::
::	COMMAND:	WRITEF:	WF
::	FUNCTION:	WRITES A FULLWORD INTO MEMORY
::			IDENTICAL TO WRITE EXCEPT THAT A FW IS WRITTEN
::
::*********************************************************************

WRITEF	HS	0
	LHL	R2,ARGCT,XD
	JE	COMERR			:NO ZERO ARGUMENTS
	LIS	R12,0
	CLHI	R2,8
	JG	COMERR			:OR MORE THAN 2
	JL	WRITF5			:SINGLE ARGUMENT IS ADDRESS
	L	R12,VALUE1+4,XD		:SECOND VALUE IS COUNT

WRITF5	L	R11,VALUE1,XD		:ADDRESS
	THI	R11,1			:ONLY EVEN ADDRESSES
	JN	WRERR
WRITF4	LR	R3,R11
	JAL	R9,CHKMAC		:GET MAC APPROVAL
	J	CHKMA1			:ERROR IF IMMEDIATE RETURN
	CI      R11,0E0000
	JGE     CHKMA1    		:CAN'T WRITE TO SEG E OR F
	JAL	R9,TYPADD,,		:TYP OUT ADDRESS
	L	R3,0,R11	
	JAL	R9,TYPFW,,
	JAL	R9,RDARGS,,		:GET NEW VALUE IN R3
	CLHI	R2,4
	JG	COMERR			:0 OR 1 ARGUMENT ONLY
	JE	WRITF2			:1 ARG
	CLHI	R1,ASCBSL
	JE	WRITF3			: '\'
	CLHI	R1,ASCFSL		: '/'
	JEFS	WRITF3
	CLHI	R1,ASCCR
	JN	COMERR
	JAL	R7,TYPCRL,,		:A CR EXITS US
	J	XRPRMT
WRITF2	ST	R3,0,R11		:STORE THE VALUE
WRITF3	JAL	R7,TYPCRL,,		:CR-LF
	AIS	R11,4
	SIS	R12,4			:DECREMENT COUNT
	JG	WRITF4			:SOME LEFT
	J	XRPRMT

	EI	:(XRSZLV-2)		:##AL

	IF	(XRSZLV-1)		:##AL
WRERR	LA	R2,ASWRER		:THIS ENTRY MOVED TO THIS LEVEL
	JAL	R7,TYPASC,,
	J	XRPRMT

::*********************************************************************
::
::	COMMAND:	XTYPE:/TYPE:	R
::	FUNCTION:	TYPE BLOCK OF STORAGE AS 8 HW PER LINE
::			PRECEEDED BY ADDRESS
::	INPUT:		VALUE1=STARTING ADDRESS
::			VALUE1+4=BYTE COUNT (OPTIONAL,DEFAULT=16)
::
::*********************************************************************

XTYPE	HS	0
	LHI	R2,$A2*4		:2 ARGUMENTS MAX
	STH	R2,ARGMAX,XD		:TAKE 2 ARGUMENTS MAX
	JAL	R9,RDARGS,,

TYPE	HS	0
	JAL	R12,TYPE0
	J	XRCRLF

::*********************************************************************
::
::	SUBROUTINE:	TYPE0:
::	CALLING SEQ:	JAL	R12,TYPE0
::
::*********************************************************************

TYPE0	HS	0
	LHI	R11,10			:DEFAULT TO 16 BYTES
	LHL	R2,ARGCT,XD		:TAKES 0,1, OR 2 ARGUMENTS
	JE	TYPE1
	L	R0,VALUE1,XD		:FIRST ARGUMENT IS ADDRESS
	ST	R0,LASTCL
	CLHI	R2,4
	JEFS	TYPE1			:ONE ARGUMENT (ADDRESS)
	CLHI	R2,8
	JN	COMERR,,
	L	R11,VALUE1+4,XD		:SECOND ARG IS COUNT
TYPE1	L	R10,LASTCL
	THI	R10,1			:MUST BE EVEN ADDR
	JN	WRERR

	JAL	R7,TYPCRL,,

TYPE2	LR	R3,R10			:TYPE ADDRESS
	JAL	R9,TYPADD,,		:TYP OUT ADDRESS
	LIS	R5,8			:EIGHT HW PER LINE
TYPE5	LR	R3,R10
	JAL	R9,CHKMAC
	J	CHKMA1			:ADDRESS OUT OF RANGE, REJECT!
	LHL	R3,0,R10		:TYPE H-WORD
	JAL	R9,TYPHW,,
	AIS	R10,2
	SIS	R11,2			:DECREMENT BYTE COUNT
	JLE	TYPE3			:ALL DONE
	SIS	R5,1
	JG	TYPE5			:NOT DONE WITH PRESENT LINE YET
	JAL	R7,TYPCRL,,		:DONE WITH THIS LINE - TYPE CR-LF

	J	TYPE2			:AND MOVE ON TO NEXT LINE

TYPE3	ST	R10,LASTCL
	JR	R12			:RETURN
	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	CHNBFL:	CB
::	FUNCTION:	Chain Through Bufferlets
::			Type as 8 HW Line Preceeded by	Address	 ###wjl
::
::*********************************************************************

CHNBFL	HS	0
	LHI	R2,$A2*4		:2 ARGUMENTS
	STH	R2,ARGMAX,XD		:MAXIMUM
	JAL	R9,RDARGS,,		:GO READ ARGUMENTS
	LHL	R2,ARGCT,XD		:TAKES 2 ARGUMENTS
	CLHI	R2,8			:CHECK FOR THEM
	JN	COMERR			:IF NOT GO TYPE ??
	L	R10,VALUE1,XD		:FIRST ARGUMENT IS BUFFERLET NUMBER
	slls    r10,cbszl
	ais     r10,cbptsz
	L	R11,VALUE1+4,XD		:2ND ARG IS CNT OF BFFRLTS TO BE CHND
	JAL	R7,TYPCRL,,		:GO TYPE CR/LF
CHNBF2	LR	R3,R10			:(TYPADD NEEDS ADDRESS IN R3)
	JAL	R9,TYPADD,,		:GO TYPE BUFFERLET ADDRESS
	LHI     R6,CBSZ/10		:NUMBER OF LINES
CHNBF3	LIS	R5,8			:8 HW/LINE
CHNBF4	LR	R3,R10			:(CHKMAC NEEDS ADDRESS IN R3, TOO)
	JAL	R9,CHKMAC		:SKIP RETURN IF ADDRESS IS OK
	J	CHKMA1			:ADDRESS OUT OF RANGE!  ERROR MESSAGE
	LHL	R3,0,R10		:(TYPHW NEEDS HW IN R3)
	JAL	R9,TYPHW,,		:GO TYPE H-WORD
	AIS	R10,2			:INCREMENT ADDRESS
	SIS	R5,1			:DECREMENT H-WORD COUNT
	JG	CHNBF4			:NOT DONE WITH PRESENT LINE YET
	JAL	R7,TYPCRL,,		:DONE WITH THIS LINE - GO TYPE CR/LF
	SIS     R6,1
	JG      CHNBF3
	SIS	R11,1			:DECREMENT COUNT OF BUFFERLETS
	JLE	XRCRLF			:ALL DONE - RETURN WITH CR/LF

	lr	r10,r3		:CALCULATE NEXT BUFFERLET ADDRESS
	slls    r10,cbszl
	ais     r10,cbptsz
	J	CHNBF2			:AND MOVE ON TO NEXT LINE

	EI	:(XRSZLV-2)		:##AL

::*********************************************************************
::
::	SUBROUTINE:	CHKMAC:
::	FUNCTION:	CHECK WITH MAC BEFORE DOING MEMORY REFERENCE
::	CALLING SEQ:	JAL	R9,CHKMAC
::	INPUT:		R3 =	POTENTIAL ADDRESS
::	DESTROYED:	R0, R4
::	RETURNS:	SKIP RETURNS IF ADDRESS IS OK, ELSE DIRECT RETURN
::
::*********************************************************************

CHKMAC	HS	0
	LR	R4,R3			:move address to work register
	EXHR	R4,R4			:exchange seg # and seg offset hw's
	NI	R4,0FFFF		:ISOLATE SEGMENT NUMBER
	CLHI	R4,0F			:MAX SEG. NUMBER IS 15
	JGR	R9			:straight (error) return if TOO BIG
	LR	R0,R3			:move address to work register
	NI	R0,0FFFF		:ISOLATE PAGE NUMBER
	SLLS	R4,2			:FORM FW OFFSET
	C	R0,CHKDAT,R4,		:COMPARE AGAINST ALLOWABLE SEG. SIZE
	JLE	4,R9			:skip return if ADDRESS IS OK
	JR	R9			:straight return if ADDRESS IS NOT OK

CHKMA1	LA	R2,ASMCER
	JAL	R7,TYPASC,,		:TYPE OUT ERROR MESSAGE
	J	XPRMPT,,

	SUBTTL	XRAY (Crash info display routines - DC, DCS, DCD)

	IF	(XRSZLV)		:##AL
::*********************************************************************
::
::	COMMAND:	XDCRSH:	DC, DCS, DCD
::	FUNCTION:	DISPLAY CRASH SUMMARY OR DETAIL TABLE OR BOTH
::
::*********************************************************************

	NOLIST
XDCSH1	SC	/"0D"0ACRASH SUMMARY TABLE/
XDCDH1	SC	/"0D"0ACRASH DETAIL TABLE/
XDCHDR	SC	/"0D"0ATIME"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0CC"A0"A0"A0TYPE"A0"A0PSW"A0"A0"A0ADDRESS"0D"0A/

XDCDH3	SC	/"0D"0AUSER REGISTER SET:/
	LIST

XDCRSH	HS	0
	JAL	R13,XRYIN,,
	NHI	R1,ASCAP		:STRIP PARITY AND LOWER CASE BIT(x5F)
	CLHI	R1,ASCD			:DID USER END WITH 'D'?
	JE	XDCRDT			:YES, GO DO DETAIL TABLE
	CLHI	R1,ASCS			:DID USER END WITH 'S'(x53)?
	JNFS	XDCRS1			:NO
	LI	R11,XRCRLF		:FINISHED AFTER DOING SUMMARY TABLE
	JFS	XDCRSM			:GO DO SUMMARY TABLE
XDCRS1	CLHI	R1,ASCCR		:DID USER END WITH C/R (x0D)?
	JN	COMERR			:NO, ERROR
	LI	R11,XDCRDT		:GO DO DETAIL AFTER DOING SUMMARY

XDCRSM	HS	0			:DISPLAY CRASH SUMMARY TABLE
	LI	R10,XDCRS3		:CONTINUATION POINT
	LIS	R12,0			:INDEX TO SUMMARY TABLE ENTRIES
	LI	R14,CSMTBL		:POINTER TO SUMMARY TABLE
	LA	R2,XDCSH1		:GET HEADER
	JAL	R7,TYPASC,,		:TYPE IT
XDCRS4	LA	R2,XDCHDR
	JAL	R7,TYPASC,,
	LHL	R6,CSMCNT		:NUMBER OF SUMMARY ENTRIES
	JER	R11			:RETURN IF NONE
XDCRS2	HS	0
	L	R2,CS.TIM,R14,R12	:GET CRASH TIME
	JAL	R9,GMTCNX,,		:DISPLAY IT
	JAL	R7,TYP2SP,,
	LHL	R3,CS.CNT,R14,R12	:CRASH COUNT
	JAL	R9,TYPHWD,,
	LHL	R3,CS.CID,R14,R12	:CRASH ID
	JAL	R9,TYPHW,,
	LHL	R3,CS.PSD+2,R14,R12	:CRASH PSW
	JAL	R9,TYPHW,,
	L	R3,CS.PSD+4,R14,R12	:CRASH PC
	JAL	R9,TYPFW,,
	JAL	R7,TYPCRL,,
	JR	R10
XDCRS3	AHI	R12,CS.SIZ		:NEXT ENTRY
	CLHI	R12,CSMTBS		:DONE?
	JGER	R11			:YES, DONE
	SIS	R6,1			:DEC COUNT OF ENTRIES
	JG	XDCRS2			:NO, DO NEXT ENTRY
	JR	R11			:DONE

XDCRDT	HS	0
	LI	R14,CDTTBL		:POINT TO DETAIL TABLE
	LIS	R12,0			:INDEX INTO DETAIL TABLE
	LA	R2,XDCDH1		:HEADER
	JAL	R7,TYPASC,,
XDCRD2	LI	R11,XRCRLF		:GO HERE WHEN ALL DONE
	LHL	R6,CDTCNT		:load count of detail entries
	JER	R11			:none, all done			###wjl
	LI	R10,XDCRD1		:SET UP RETURN POINTER
	J	XDCRS4
XDCRD1	HS	0	:RETURN HERE FROM XDCRS2 AFTER TYPING FIRST LINE
	AR	R14,R12
	LR	R6,R14
	AHI	R6,CD.RSF		:POINT TO REG SET F SAVE AREA
	LA	R2,XDCDH3		:"USER REGISTER SET"
	JAL	R7,TYPASC,,
	LHI	R5,10			:TYPE 16D REGISTERS
	JAL	R8,TYPNFW

	LR	R12,R12
	JN	XPRMPT
	AHI	R12,CD.SIZ		:NEXT DETAIL ENTRY
	LHL	R6,CDTCNT		:# OF DETAIL ENTRIES - 1 OR MORE?###GT
	SIS	R6,1
	JER	R11			:NO, ALL DONE
	J	XDCRD2

	SUBTTL	XRAY (Node statistics - NS)

::*********************************************************************
::
::	COMMAND:	XSTATS:	NS
::	FUNCTION:	DISPLAY NODE STATUS DATA
::
::*********************************************************************

XSTATS	HS	0
	clhi    r1,asch   		:close with H (clear highwater?)
	jn      xst64
	lis     r0,0
	sth     r0,nscpho 		:clear hghwtr log out
	sth     r0,nscphi 		:clear hghwtr log in
	sth     r0,ns.pho 		:clear hghwtr phys out
	sth     r0,ns.phi 		:clear hghwtr phys in
	jfs     xst65
xst64	CLHI	R1,ASCZ			:DID USER CLOSE WITH 'Z'(x5A)?
	JN	XST44			:NO, JUST DISPLAY ALL DATA
xst65	LIS	R0,0			:YES, CLEAR PROCESS HW-MARKS
	LHI	R10,$A60		:CLEAR FOR 15 PROCESSES
XST66	ST	R0,PROHWM,R10
	CLHI	R10,0C			:REACHED INDEX FOR EXLAVG YET?
	JGFS	XST63			:NO
	ST	R0,EXLAVG,R10		:YES, CLEAR VARIOUS COUNTERS
XST63	SIS	R10,4
	JGEBS	XST66

	LHI	R0,$A9999		:reset EXLALW to max on "NSZ"
	STH	R0,EXLALW		:SET LOW WATER MARK TO MAX
	LHL	R0,PASTHR
	STH	R0,MXPASS		:INITIALIZE MAX NUMBER OF PASS-THRUS
	LHL	R0,HNPORT
	STH	R0,MXPORT		:MAXIMUM NUMBER OF PORTS IN USE
	LHL	R0,NALINK
	STH	R0,MXLINK		:AND MAXIMUM NUMBER OF LINKS

XST44   clhi    r1,ascl   		:asking for lines?
	je      xnsl00    		:yes goto that routine
	LA	R2,XSTHD1		:DISPLAY LINE OF HEADER INFORMATION
	JAL	R7,TYPASC,,
	LIS	R10,8			:8 HW OF STATISTICS
	LIS	R11,0
XSTAT3	LHL	R3,EXLAVG,R11
	JAL	R9,TYPHWD,,
	AIS	R11,2
	SIS	R10,1
	JGBS	XSTAT3
	LHL	R3,MXPORT
	JAL	R9,TYPHWD,,		:DISPLAY MAXIMUM NUMBER OF PORTS 
	LHL	R3,MXPASS
	JAL	R9,TYPHWD,,		:DISPLAY MAX NUMBER OF PASSTHRUS
	LHL	R3,MXLINK		:DISPLAY MAXIMUM NUMBER OF LINKS
	JAL	R9,TYPHWD,,
	JAL	R7,TYPCRL,,

	LA	R2,XSTHD2		:HEADER FOR RMAKE STATS
	JAL	R7,TYPASC,,

	L	R3,RMKRMS		:NUMBER OF RMAKE CALLS LAST MINUTE
	JAL	R9,TYPFWD,,
	L	R3,RMKNRS		:RMAKE CALLS FOR WHICH NO RECORD MADE
	JAL	R9,TYPFWD,,
	L	R3,RMKRMS
	S	R3,RMKNRS		:DIFFERENCE IS NUMBER OF PACKETS MADE
	JAL	R9,TYPFWD,,
	l       r3,rmklrs
	jal     r9,typfwd,,     	:logical records made
	l       r3,rtdpks 		:packets torn
	jal     r9,typfwd,,
	l       r3,rtdlrs 		:records torn
	jal     r9,typfwd,,

	LA	R2,XSTHD3		:HEADER FOR CPS STATS
	JAL	R7,TYPASC,,
	LA	R2,XSTHD8
	JAL	R7,TYPASC,,
	LHL	R3,NSCPSO		:CPS OUT
	JAL	R9,TYPFWD,,		:DISPLAY
	LHL	R3,NSCPSI		:CPS IN
	JAL	R9,TYPFWD,,
	LHL	R3,NSCPHO		:HI-WATER MARK OUT
	JAL	R9,TYPFWD,,
	LHL	R3,NSCPHI		:HI-WATER MARK IN
	JAL	R9,TYPFWD,,

:	NODE LINKS' TOTAL PHYSICAL CPS RATES				###wjl
	LA	R2,XSTHDB		:header for physical CPS stats	###wjl
	JAL	R7,TYPASC,,		:				###wjl
	LA	R2,XSTHD8		:				###wjl
	JAL	R7,TYPASC,,		:				###wjl
	LHL	R3,NS.PCO+2		:Physical CPS Out, HW value	###wjl
	JAL	R9,TYPFWD,,		:stored in FW location		###wjl
	LHL	R3,NS.PCI+2		:Physical CPS In, HW value	###wjl
	JAL	R9,TYPFWD,,		:stored in FW location		###wjl
	LHL	R3,NS.PHO		:Physical HWM Out		###wjl
	JAL	R9,TYPFWD,,		:				###wjl
	LHL	R3,NS.PHI		:Physical HWM In		###wjl
	JAL	R9,TYPFWD,,		:				###wjl

XNSPER	LA	R2,XSTHD7		:PERFORMANCE HEADER
	JAL	R7,TYPASC,,
	LIS	R10,0			:CLEAR ACCUMULATOR REGISTERS
	LIS	R11,0
	L	R12,TOTCHR		:TOTAL # LOGICAL CHARACTERS THRU NODE
	SRLS	R12,7			:SCALE DOWN TO PREVENT TRUNCATION ERROR
:	VERY EFFICIENT!	THIS WILL BE NUMERATOR OF TICKS TO MS CONVERSION
	JE	XNSPE3			:ZERO TRAFFIC, DON'T DIVIDE BY ZERO!
	LHI	R4,NLINKS*2-2		:SET UP LOOP INDEX
XNSPE1	L	R14,KDKN,R4,R4		:GET LINK DESCRIPTOR
	LB	R0,NLAT,R14		:ANY LINES ATTACHED?
	JE	XNSPE2			:NO, LINK NOT UP, IGNORE IT
	L	R8,KS.LMI,R14		:LOGICAL CHARS IN ON LINK
	A	R8,KS.LMO,R14		:GET TOTAL CHARS ON LINK
	DHR	R8,R12			:GET LINK'S TRAFFIC AS PERCENT OF TOTAL

	LHL	R6,KS.XMT,R14		:AVERAGE TRANSMISSION TIME
	AH	R6,KS.AQU,R14		:PLUS AVERAGE QUEUE TIME=HARDWARE DELAY
	MHR	R6,R9			:MULTIPLY BY APPROPRIATE % OF TRAFFIC
	LHL	R7,KS.RRT,R14		:GET BUFFER DELAY
	AH	R7,KS.SRA,R14		:PLUS SYLVEX-RTEAR DELAY
	AH	R7,SYLXAV		:PLUS AVE SYLVEX DELAY=SOFTWARE DELAY
	MHR	R7,R9			:WEIGH WITH PERCENT OF TRAFFIC
	AR	R10,R6			:ACCUMULATE H-WARE DELAY
	AR	R11,R7			:AND CODE DELAY
XNSPE2	SIS	R4,2			:DECREMENT LINK NUMBER INDEX
	JGE	XNSPE1			:LOOP IF MORE LINKS

XNSPE3	LHI	R14,$A80		:DENOMINATOR OF TICKS TO MSEC
					:CONVERSION (128/80)
	LR	R2,R11
	DHR	R2,R14			:GET RESULT IN MILLISECONDS
	JAL	R9,TYPHWD,,
	JAL	R7,TYP8SP,,		:TYPE 8 SPACES
	LR	R2,R10			:SAME FOR H-WARE DELAY
	DHR	R2,R14
	JAL	R9,TYPHWD,,		:DISPLAY DECIMAL RESULT IN MS
	JAL	R7,TYP8SP,,		:TYPE 8 SPACES
	AR	R10,R11			:FORM COMBINED RESULT...
	LR	R2,R10
	DHR	R2,R14
	JAL	R9,TYPHWD,,
	JAL	R7,TYP8SP,,		:TYPE 8 SPACES
	LIS	R3,0			:TAKE PRECAUTION AGAINST ZERO DIVIDE
	SLLS	R12,8			:RESCALE AND DOUBLE		###JHL
	JEFS	XNSPE5			:DON'T DIVIDE BY ZERO

					:OUT QUEUE DELAYS FOR US
	DHR	R12,R10			:COMPUTE EFFICIENCY FOR ISIS NODE
	LR	R3,R13
XNSPE5	JAL	R9,TYPHWD,,

	LA	R2,XSTMS0		:HEADER
	JAL	R7,TYPASC,,
	LIS	R10,$A 10		:DISPLAY time for 10 processes
	LIS	R11,0
	LHL	R12,MININT		:EXACT MEASUREMENT INTERVAL
	LHI	R14,$A100
XNS22	JAL	R7,TYP2SP,,		:2 SPACES FOR NEAT DISPLAY
	LHL	R2,PSVTIM+2,R11,	:SKIP THE BUFFER-ZAP PROCESS
	MHR	R2,R14			:MULTIPLY BY 100
	DHR	R2,R12			:DIVIDE BY TIME INTERVAL TO GET PERCENT
	JAL	R9,HEXDEC,,
	JAL	R9,TYPBYT,,		:DISPLAY IT
	AIS	R11,2
	SIS	R10,1
	JG	XNS22
	LA	R2,XSTMS1
	JAL	R7,TYPASC,,
	LIS	R10,$A 10		:DISPLAY time for 10 PROCESSES
	LIS	R11,0
XNS33	LHL	R2,PROHWM+6,R11		:SKIP THE BUFFER-ZAP PROCESS
	JAL	R9,FSTMSC,,		:convert FASTC to MSEC		###wjl
	JAL	R9,TYPHWD,,		:DISPLAY PEAK TIME IN MILLISECONDS
	AIS	R11,4
	SIS	R10,1
	JGBS	XNS33

	J	XRCRLF			:DONE


XNSL00  LA      R2,XNST01 		:user wants statistics for all lines
	JAL     R7,TYPASC,,
	LA      R2,XNST02
	JAL     R7,TYPASC,,
	LCS     LN,1      		:for all active lines
XNSL03  AIS     LN,1      		:do next line
	CLHI    LN,NLINES
	JGE     XRCRLF
	LH      R1,NGSVLN,LN,LN 	:it is active?
	JGEBS   XNSL03    		:nope
	LR      R3,LN     		:print line #
	JAL     R9,TYPBYD,,
	LA      R2,XNDHSY 		:print lne type
	IF      SILINS
	CLHI    LN,NLINES-SILINS
	JLFS    XNSL07    		:is still a sync line
	LA      R2,XNDHSI 		:is a sio line
      EI	:SILINS
XNSL07  JAL     R7,TYPASC,,     	:line type
	LHL     R3,BAUDRT,LN,LN 	:get line speed
	SLLS    R3,3
	LA      R2,HSPEED,R3    	:get text string
	JAL     R7,TYPASC,,
	LHL     R3,NGSVLN,LN,LN

	NHI     R3,7FFF   		:just the node number
	JAL     R9,HEXOCT,,
	JAL     R9,TYP5CH,,     	:print node number
	LR      KX,LN     		:setup KX as link descriptor
	SLLS    KX,1
	L       KX,KDLN,KX,KX   	:and KX is link descriptor
	ST      KX,XKDSAV,XD    	:setup for other xray routines
	LB      R0,LKNM,KX
	STH     R0,XKNSAV,XD
	LB      R3,KSPD,KX		:get link speed
	NHI     R3,1F     		:only the speed
	SLLS    R3,3      		:index into text table of speeds
	LA      R2,HSPEED,R3
	JAL     R7,TYPASC,,
	JAL     R8,CHNCNT 		:then how amny channels
	JAL     R9,TYPHWD,,     	:in decimal
	LHL     R6,MTTINT 		:Atime interval
	L       R2,KS.LMI,KX    	:last minute's logical input cps
	DHR     R2,R6
	JAL     R9,TYPFWD,,
	L       R2,KS.LMO,KX    	:last minute's logical output cps
	DHR     R2,R6
	JAL     R9,TYPFWD,,
	L       R2,KS.PMI,KX    	:last minute's physical input cps
	DHR     R2,R6
	JAL     R9,TYPFWD,,
	L       R2,KS.PMO,KX
	DHR     R2,R6     		:last minute's physical output cps
	JAL     R9,TYPFWD,,
	JAL     R7,TYPCRL,,
	J       XNSL03    		:next line

	EI	:(XRSZLV)		:##AL

	SUBTTL	XRAY (Link statistics - KS)

	IF	(XRSZLV)		:##AL

::*********************************************************************
::
::	COMMAND:	XKS:	KS
::	FUNCTION:	DISPLAY LINK STATISTICS
::
::*********************************************************************

:	NODE CODE ROUTINE MTRFIC GATHERS LINK TRAFFIC COUNTS FOR LOGICAL
:	AND PHYSICAL COUNTS. COUNT INTERVAL IS NUMBER OF SECONDS IN MTTINT

XKSCIU	WS	1			:0 IF KS NOT IN USE, ELSE XD OF USER
xkstmp  ws      1         		:save for display ks data routine

XKS	HS	0
	LHL	R2,XKSCIU+2		:ANYBODY HERE ALREADY?
	JN	XCOMIU			:YES, COMMAND IN USE MESSAGE
	ST	XD,XKSCIU		:MARK IT IN USE
	LIS	R2,0			:CLEAR STATS ZERO FLAG		###OAS
	STH	R2,XKSZFG		:FOR KSZ COMMAND		###OAS
	CLHI	R1,ASCS			:IS LAST CHAR AN 'S'(x53)?
	JEFS	XKSSS0			:YES, DISPLAY ALL LINKS		###OAS
	CLHI	R1,ASCZ			:IS LAST CHAR A 'Z'(x5A)?	###OAS
	JN	XKS00			:NO				###OAS
	TS	XKSZFG			:YES, FLAG FOR STATS CLEAR	###OAS
	J	XKS00			:AND CONTINUE			###OAS
XKSSS0	LHI	R14,(NLINKS-1)*2	:count of links to do
XKSSS
	L	R10,KDKN,R14,R14	:GET LINK DESCRIPTOR POINTER
	LB	R0,NLAT,R10		:ANY LINES ATTACHED TO THIS LINK?
	JEFS	XKSSS1			:NO, GO ON TO NEXT LINK
	LHL	R3,NDID,R10		:YES, GET THE NEIGHBOR
	JAL	R9,HEXOCT,,		:##AL
	sth     r14,argct,xd   	:save number left to do
	jal     r8,xksdis
	lhl     r14,argct,xd
XKSSS1	SIS	R14,2			:ADVANCE TO NEXT LINK
	JGE	XKSSS
	lis     r2,0
	st      r2,xksciu 		:command no longer in use
	j       xrcrlf    		:and done

:       here if given a list of node numbers
XKS00	LHL	R2,ARGCT,XD		:GET ARG COUNT
	JNFS	XKS01
	ST	R2,XKSCIU		:MARK COMMAND NOT IN USE
	J	XRCRLF			:ALLDONE
XKS01	SIS	R2,4			:DEC ARG COUNT
	STH	R2,ARGCT,XD		:AND RESTORE
	L	R3,VALUE1,R2,XD		:GET NEXT NEIGHBOR		###SHM
	jal     r8,xksdis 		:display fo rthis line
	j       xks00

:       xksdis displays the KS data for the octal node number in r3
xksdis  st      r8,xkstmp 		:save return
	LR	R10,R3			:AND SAVE IT
	JAL	R9,OCTHXR,,		:AND GO HEX
	LR	R1,R3
	JAL	R9,XFNDLK		:FIND LINK REQUESTED
	SKIPAD(XKS03)			:immed ret, NO SUCH LINK, GO HANDLE
	JFS	XKS02			:+4 RETURN - LINK VALID, GO DISPLAY
XKS03	LIS	R2,0
	ST	R2,XKSCIU		:RESET BUSY FLAG AND
	J	COMERR			:LINK NOT THERE, COMPLAIN
XKS02	LR	R3,R10			:RECOVER NEIGHBOR
	LA	R2,XKSM19		:TYPE HEADER
	JAL	R7,TYPASC,,
	JAL	R9,TYP5CH,,		:AND DISPLAY IT
	L	KX,XKDSAV,XD		:RECOVER KD INTO KX FOR THIS NGHBR##OAS

:	CHECK FOR STATISTICS CLEAR COMMAND AND ZERO THE LINK DESCRIPTOR STATS
:	HIGH WATER MARKS FOR THE SPECIFIED LINK(S) IF CLEAR FLAG IS NON-ZERO

	LH	R1,XKSZFG		:CHECK STATS CLEAR FLAG		###OAS
	JE	XKS09			:NO 'Z' SPECIFIED		###OAS
	LIS	R2,0			:				###OAS
	ST	R2,KS.PHO,KX		:CLEAR PACKET CHARS OUT HWM	###OAS
	ST	R2,KS.PHI,KX		:CLEAR PACKET CHARS IN HWM	###OAS
	ST	R2,KS.LHO,KX		:CLEAR LOGICAL CHARS OUT HWM	###OAS
	ST	R2,KS.LHI,KX		:CLEAR LOGICAL CHARS IN HWM	###OAS
	ST	R2,KS.NPH,KX		:CLEAR #PACKETS MADE HWM	###OAS
	LA	R2,XKSM25		:DISPLAY 'STATISTICS CLEARED'	###OAS
	JAL	R7,TYPASC,,		:FOR THIS NEIGHBOR		###OAS
	l       r8,xkstmp
	jr      r8        		:process next neighbor

:	COPY RELEVANT FIELDS FROM LINK DESCRIPTOR TO SAVE AREA SO
:	KS DISPLAY USES CONSISTENT DATA
XKS09	LHI	R1,KSSZ-4		:7 GROUPS OF 12 BYTES EACH	###OAS
XKS10	L	R0,KS.PCO,KX,R1
	ST	R0,KS.PCO+XKSSKD,R1 	:SAVE AREA
	SIS	R1,4
	JGEBS	XKS10

:	COMPUTE LINK'S CPM RATE OVER REPORTING INTERVAL
	LB	R1,KSPD,KX
	NHI	R1,1F			:ISOLATE LINK SPEED AND
	SLLS	R1,2			: MULTIPLY TIMES 4 FOR FW TABLE LOOKUP
	LHL	R14,MTTINT		:MEASUREMENT INTERVAL IN SECS IN R14
	LIS	R3,0
	LHL	R4,KSPCPS,R1		:GET LINK'S CPS RATE,
	MR	R3,R14			: COMPUTE NUMBER OF CHARACTERS OVER 
	ST	R4,KS.PCO+XKSSKD	: REPORTING INTERVAL AND SAVE

	LA	R2,XKSM01		:'LOGICAL LINK CHARACTERS'
	JAL	R7,TYPASC,,		:HEADER LINE
	LA	R2,XKSM03		:'CPS IN :'
	JAL	R7,TYPASC,,
	L	R2,KS.LMI+XKSSKD	:LAST MINUTE'S LOGICAL CHARS IN
	DHR	R2,R14			:COMPUTE NUMBER PER SECOND
	LR	R10,R3			:SAVE FOR LATER
	JAL	R9,TYPFWD,,		: AND DISPLAY
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPASC,,
	L	R2,KS.LHI+XKSSKD	:LOGICAL CHARS IN HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	LA	R2,XKSM04		:'CPS OUT:'
	JAL	R7,TYPASC,,
	L	R2,KS.LMO+XKSSKD	:LAST MINUTE'S LOGICAL CHARS OUT
	DHR	R2,R14
	LR	R12,R3			:SAVE CPS OUT
	JAL	R9,TYPFWD,,
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPASC,,
	L	R2,KS.LHO+XKSSKD	:LOGICAL CHARS OUT HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,

	LA	R2,XKSM02		:'PHYSICAL LINK CHARACTERS'
	JAL	R7,TYPASC,,
	LA	R2,XKSM03		:'CPS IN :'
	JAL	R7,TYPASC,,
	L	R2,KS.PMI+XKSSKD	:LAST MINUTE'S PHYSICAL CHARS IN
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPASC,,
	L	R2,KS.PHI+XKSSKD	:PHYSICAL CHARS IN HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	LA	R2,XKSM04		:'CPS OUT:'
	JAL	R7,TYPASC,,
	L	R2,KS.PMO+XKSSKD	:LAST MINUTE'S PHYSICAL CHARS OUT
	DHR	R2,R14
	JAL	R9,TYPFWD,,
	LA	R2,XKSM05		:'HWM :'
	JAL	R7,TYPASC,,
	L	R2,KS.PHO+XKSSKD	:PHYSICAL CHARS OUT HI-WATER MARK
	DHR	R2,R14
	JAL	R9,TYPFWD,,

	LA	R2,XKSM06		:'PACKET OVERHEAD   BANDWIDTH UTIL'
	JAL	R7,TYPASC,,
	LA	R2,XKSM07		:'IN :'
	JAL	R7,TYPASC,,
	L	R3,KS.PMI+XKSSKD	:PACKET CHARACTERS IN
	LR	R4,R3
	S	R3,KS.LMI+XKSSKD	:PACKET - LOGICAL = OVERHEAD CHARACTERS
	JAL	R9,DECPER,,		:COMPUTE PACKET OVERHEAD IN
	LA	R2,XKSM08		:'OUT :'
	JAL	R7,TYPASC,,
	L	R3,KS.PMO+XKSSKD	:PACKET CHARACTERS OUT
	LR	R4,R3
	S	R3,KS.LMO+XKSSKD
	JAL	R9,DECPER,,		:COMPUTE PACKET OVERHEAD OUT

	LA	R2,XKSM07		:'IN :'
	JAL	R7,TYPASC,,
	L	R4,KS.PCO+XKSSKD	:RETRIEVE LINK'S CPM RATE
	L	R3,KS.PMI+XKSSKD	:LAST MINUTE'S CHARS IN
	JAL	R9,DECPER,,		:COMPUTE BANDWIDTH UTILIZATION IN
	LA	R2,XKSM08		:'OUT :'
	JAL	R7,TYPASC,,
	L	R4,KS.PCO+XKSSKD
	L	R3,KS.PMO+XKSSKD	:LAST MINUTE'S CHARS OUT
	JAL	R9,DECPER,,		:COMPUTE BANDWIDTH UTILIZATION OUT

	LA	R2,XKSM22		:'CHAR/SEC PER CIRCUIT'
	JAL	R7,TYPASC,,
	JAL	R8,CHNCNT		:COUNT NUMBER OF CHANS ACTIVE ON LINK
	LR	R14,R3			:SAVE IT
	JEFS	XKS11			:DONT DIVIDE BY ZERO		###OAS
	LR	R2,R10			:MOVE OVER CPS IN
	DHR	R2,R14			:GET CPS PER CHANNEL
XKS11	JAL	R9,TYPHWD,,		:AND DISPLAY##AL
	LA	R2,XKSM23		:'OUT :'
	JAL	R7,TYPASC,,
	LR	R3,R14			:DONT DIVIDE BY ZERO		###OAS
	JEFS	XKS12			:				###OAS
	LR	R2,R14			:round to closest number	###sdw
	SRLS	R2,1			:add in half of the divisor	###sdw
	AR	R2,R12
	DHR	R2,R14			:GET CPS PER CHANNEL OUT
XKS12	JAL	R9,TYPHWD,,		:DISPLAY##AL
	LA	R2,XKSM24		:'CIRCUITS :'
	JAL	R7,TYPASC,,
	LR	R3,R14
	JAL	R9,TYPHWD,,		:DISPLAY NUMBER OF ACTIVE CHANNELS

	LA	R2,XKSM12		:'PACKET STATISTICS'
	JAL	R7,TYPASC,,		:'PACKETS/SEC :'
	LHL	R2,KS.PKM+XKSSKD
	LHL	R14,MTTINT		:GET PRECISE MEASUREMENT INTERVAL
	LR	R7,R14			:round instead of truncate	###sdw
	SRLS	R7,1
	AR	R2,R7			:add half the divisor before dividing
	DHR	R2,R14			:FORM PACKETS/SEC
	JAL	R9,TYPHWD,,		:AND DISPLAY##AL

	LA	R2,XKSM14		:'AVERAGE SIZE :'
	JAL	R7,TYPASC,,
	LHL	R3,KS.ASZ+XKSSKD
	JAL	R9,TYPHWD,,		:DISPLAY AVERAGE PACKET SIZE
	LA	R2,XKSM16		:FOLLOW IT WITH 'BYTES'
	JAL	R7,TYPASC,,

	LA	R2,XKSM13		:'RECORDS/PACKET : '		###JHL
	JAL	R7,TYPASC,,		:TYPE THE STRING		###JHL
	LHL	R3,KS.LRA+XKSSKD	:				###JHL
	JAL	R9,TYPHWD,,		:DISPLAY AVE NUMBER OF RECDS PER PKT

:	LINK DELAY (MS)
	LA	R2,XKSM15		:'LINK DELAY (MS)'
	JAL	R7,TYPASC,,	
XSSYLV	LHL	R2,SYLXAV		:GET AVE INTERVAL BETWEEN SYLVER RUNS
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	LR	R10,R3			:SAVE RESULT...
	JAL	R9,TYPHWD,,		:AND DISPLAY 'IN QUEUE' DELAY
	
XSRTD	LHL	R2,KS.SRA+XKSSKD	:average time between SYLVER & RTEAR
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:ADD IN RESULT
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:DISPLAY DECIMAL 'RTEAR' delay IN MS

	IF	BFLTMR
	LHL	R2,BFDOPT,,		:test control cell for dly calc method
	JN	XSRRT			:must be set non-zero for old method
:	compute avg timing pair delay, and output it
	LHL	R2,KS.BFC,KX		:must check for zero divisor
	JNFS	XS100
	LIS	R3,0
	JFS	XS110
XS100	LHL	R1,KS.BFD,KX		:read acc'ed buffer delay
	DHR	R1,R2			:quotient in R2	, remainder in R1
	JAL	R9,FSTMSC		:convert to milliseconds (ret in R3)
XS110	AR	R10,R3			:add into total delay
	JAL	R7,TYP4SP,,		:space on out...
	JAL	R9,TYPHWD,,		:and output delay time (dec ms)
	JFS	XSAQU			:jump to output outqueue delay
	EI	:BFLTMR

XSRRT	LHL	R2,KS.RRT+XKSSKD	:average time per round robin in FASTC
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:SAVE RESULT...
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:DISPLAY RMAKE 'BUFFER' DELAY

XSAQU	LHL	R2,KS.AQU+XKSSKD	:average queueing delay, RMAKE-SYLVEX
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:ACCUMULATE DELAY
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:DISPLAY 'OUT QUEUE' delay

XSXMIT	LHL	R2,KS.XMT+XKSSKD	:average packet transmission time
	JAL	R9,FSTMSC		:CONVERT TO MILLISECONDS
	AR	R10,R3			:ACCUMULATE DELAY
	JAL	R7,TYP4SP,,		:FOUR SPACES
	JAL	R9,TYPHWD,,		:display 'XMIT' delay

XSTOTL	LR	R3,R10			:GET 'TOTAL' DELAY
	JAL	R7,TYP4SP,,	
	JAL	R9,TYPHWD,,		:AND DISPLAY

	LA	R2,XKSM10		:'OVERLOAD COUNT'
	JAL	R7,TYPASC,,	
	LHL	R3,KS.OVL+XKSSKD
	JAL	R9,TYP5DD,,		:DISPLAY OVERLOAD COUNT
	JAL	R7,TYP9SP,,		:9 SPACES
	LHL	R3,KS.SAT+XKSSKD
	JAL	R9,TYP5DD,,		:DISPLAY SATURATED COUNT
	JAL	R7,TYP9SP,,
	LHL	R3,KS.BAM+XKSSKD
	JAL	R9,TYP5DD,,		:DISPLAY BACKLOG COUNT
	JAL	R7,TYP9SP,,
	LHL	R3,KS.PKM+XKSSKD
	JAL	R9,TYP5DD,,		:DISPLAY NUMBER OF PACKETS MADE
	JAL	R7,TYP7SP,,
	L	R3,KS.NPM+XKSSKD
	JAL	R9,TYPFWD,,		:DISPLAY IDLE CALLS	

	LA	R2,XKSM17		:GET ADDRESS OF HEADER
	JAL	R7,TYPASC,,		:AND OUTPUT TO SCREEN

:	KN(R11) HAS THE LINK DESC PTR FOR LINK WE'RE QUERYING
	LIS	R6,0			:STEP THROUGH LINES
XKSRX2	SLLS	R6,1
	L	R3,KDLN,R6,R6		:LOOK AT LINE'S LINK DESC
	SRLS	R6,1
	CR	R3,KN			:THIS IS HOW WE TELL COUSINS
	JE	XKSRX4
XKSRX6	AIS	R6,1			:NEXT LINE NUMBER
	CLHI	R6,NLINES
	JN	XKSRX2
	JAL	R7,TYPCRL,,		:FALL THROUGH WHEN ALL LINES CHECKED
	l       r8,xkstmp
	Jr	r8			:REPEAT "KS" FOR REMAINING ARGUMENTS
XKSRX4
	LA	R2,XKSM18		:ADDRESS OF 'LINE' STRING
	JAL	R7,TYPASC,,		:OUTPUT HEADER STRING
	LR	R3,R6			:GET LINE NUMBER FOR SCREEN
XKSRX7	JAL	R9,TYPHWD,,		:OUTPUT IT TO SCREEN AFTER 'LINE'
	LA	R2,XKSM20		:ADDRESS OF ':'
	JAL	R7,TYPASC,,		:OUTPUT THE STRING
	JAL	R7,TYP4SP,,		:SPACE OUT...

	CLHI	R6,NLINES-SILINS	:CHECK FOR SIO LINE
	JLFS	XKSSYN			:BRANCH IF STILL IN SYNC RANGE
	LA	R2,SINMRK		:PTR TO 'N/A' STRING FOR SIO LINE
	JAL	R7,TYPASC,,		:FILL MARKING FIELD WITH TEXT
	JFS	XKSCNT			:REST OF FIELDS ARE THE SAME
XKSSYN	LHL	R3,KL.LSV,R6,R6		:GET MINUTE'S WORTH OF "MARKING"
	JAL	R9,TYPHWD,,
XKSCNT	JAL	R7,TYP4SP,,		:MOVE OVER ONCE...
	JAL	R7,TYP8SP,,		:MOVE OVER TWICE...
XKSCN1	LHL	R3,KL.TSV,R6,R6		:GET MINUTE'S WORTH OF "RXMT"
	JAL	R9,TYPHWD,,
	JAL	R7,TYP8SP,,		:SPACE OVER
	LHL	R3,KL.RSV,R6,R6		:GET MINUTE'S WORTH OF "XMT"
	JAL	R9,TYP5DD,,     	:sio can do 10000+ packets per min#sdw
	J	XKSRX6			:GO BACK FOR MORE LINES ON THIS LINK

SINMRK	SC	+N/A"20"20"20+		:MARKING FIELD FOR SIO LINE

	EI	:(XRSZLV)		:##AL

::*********************************************************************
::
::	SUBROUTINE:	CHNCNT:
::	FUNCTION:	COUNT NUMBER OF ACTIVE CHANNELS ON LINK
::	THIS VALUE IS IDENTICAL TO THE CELL 'ANCHN' FOR T-II LINKS.
::	FOR T-I LINKS, 'ANCHN' IS FREQUENTLY IN ERROR, AND JAL R8,CNTCHN
::	SHOULD BE USED
::	CALLING SEQ:	JAL	R8,CHNCNT
::	INPUT:		XKNSAV, XKDSAV = KN AND KD FOR LINK
::	OUTPUT:		R3 = COUNT
::	DESTROYED:	R0,R1,R2,R4,R9
::
::*********************************************************************

CHNCNT	HS	0
	LHL	R2,XKNSAV,XD		:GET LINK NUMBER
	LHL	R2,LKZFKN,R2,R2 	:GET ABS CHANNEL 0
	SRLS	R2,3			:DIVIDE BY 8
	LA	R4,ACP,R2,		:GET BEGIN OF ACP ARRAY FOR THIS LINK
	L	R2,XKDSAV,XD		:GET LINK DESCRIPTOR
	LHL	R2,NCHN,R2,		:GET NUMBER OF CHANNELS ASSIGNED
	SRLS	R2,4			:DIVIDE BY 16
	JAL	R9,COUNT0		:GET NUMBER OF ACTIVE CHANNELS ON LINK
	JR	R8

	SUBTTL	XRAY (Trace link/line events - TL, TN, TM)

	IF	(XRSZLV-1)		:##AL
	IF	TSTSZE

::*********************************************************************
::
::	COMMAND:	XTLINK:	TL
::	FUNCTION:	SET/RESET TSLINK TO ENABLE/DISABLE LINK TRACE FUNCTION
::	INPUT:		LINK TO BE TRACED IS SINGLE ARGUMENT, ENTERED IN OCTAL.
::			IF NO ARGUMENT, JUST DISPLAY CURRENT CONTENTS.
::
::*********************************************************************

XTLINK	HS	0
	LHL	R2,ARGCT,XD		:ANY ARGUMENTS?
	SIS	R2,4
	JL	XTLDSP			:NO, GO DISPLAY

	L	R1,VALUE1,XD		:ARGUMENT=0?			###wjl
	JE	XTLIN1			:YES, TURN OFF TRACE
	LHL	R1,TSLINK		:ARGUMENT NOT 0, MAKE SURE WE'RE NOT
	JN	XTLDSP			:ALREADY TRACING,SHOW LINK BEING TRACED
	L	R3,VALUE1,XD		:GET NODE NUMBER		###SHM
	JAL	R9,OCTHXR		:CONVERT TO HEX			###SHM
	LR	R1,R3			:				###wjl
	JAL	R9,XFNDLK		:make sure the neighbor is there###wjl
	SKIPAD(COMERR)			:(immed) it isn't		###wjl
XTLIN1	STH	R1,TSLINK		:(+4) STORE IN TSLINK

XTLDSP	LA	R2,XTLMS1
	JAL	R7,TYPASC,,		:IDENTIFY VALUE BEING DISPLAYED
	LHL	R3,TSLINK
	JAL	R9,HEXOCT		:CONVERT TSLINK VALUE TO OCTAL AND
	JAL	R9,TYP5CH,,		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
	JAL	R7,TYPCRL,,		:CR/LF
	J	XRPRMT			:DONE

::*********************************************************************
::
::	COMMAND:	XTLINE:	TN
::	FUNCTION:	SET/RESET TSLINE TO ENABLE/DISABLE LINE TRACE FUNCTION
::	TRACE LINE WILL TRACE ONLY HEADER OF RECEIVED EVENTS ON UNASSIGNED
::	LINES (ONLY IN FOREGROUND TABLE)	###OAS
::	INPUT:		LINE TO BE TRACED IS SINGLE ARGUMENT, IN DECIMAL.
::			IF NO ARGUMENT, JUST DISPLAY CURRENT CONTENTS.
::
::*********************************************************************

XTLINE	HS	0
	LHL	R2,ARGCT,XD		:ANY ARGUMENTS?
	SIS	R2,4
	JL	XTNDSP			:NO, GO DISPLAY

	LH	R3,VALUE1+2,XD		:GET ARGUMENT
	CI	R3,0FFFFFFFF		:ARGUMENT = FFFFFFFF
	JE	XTNIN1			:YES, TURN OFF TRACE
	LH	R1,TSLINE		:ARGUMENT NOT FFFF, MAKE SURE WE'RE NOT
	JGE	XTNDSP			:TRACING - SHOW LINE BEING TRACED
	JAL	R9,DECHEX		:CONVERT TO HEX
					:J to DHXBAD for BAD RADIX	###wjl
	CLHI	R3,NLINES-1		:compare with number of lines	###wjl
	JG	COMERR			:greater??			###wjl
	SLLS	R3,1			:STORE 2*LINE#
XTNIN1	STH	R3,TSLINE		:STORE IT IN TSLINE

XTNDSP	LA	R2,XTNMS1
	JAL	R7,TYPASC,,		:IDENTIFY VALUE BEING DISPLAYED
	LH	R3,TSLINE
	JLFS	XTNIN2			:VALUE IS FFFF
	SRLS	R3,1			:DISPLAY TRUE LINE#
	JAL	R9,HEXDEC		:CONVERT TSLINE VALUE TO DECIMAL AND
XTNIN2	JAL	R9,TYPHW,,		: DISPLAY
	JAL	R7,TYPCRL,,		:CR/LF
	J	XRPRMT			:DONE

::*********************************************************************
::
::	COMMAND:	XTSDAT:	TM
::	FUNCTION:	DISPLAY DATA GATHERED FROM TSLINK/TSLINE OPTION
::	INPUT:	IF TERMINATED WITH 'F' (TM F) DISPLAYS FOREGROUND (TSFTBL)
::		IF TERMINATED WITH 'B' (TM B) DISPLAYS BACKGROUND (TSBTBL)
::
::*********************************************************************

XTSDAT	HS	0
	LHL	R14,TSLINK		:SAVE POTENTIAL NEIGHBOR NUMBER
	EXHR	R14,R14			:IN HO HW			###OAS
	LHL	R2,TSLINE		:AND TRACED LINE		###OAS
	OR	R14,R2			:IN LO HW			###OAS
	CLHI	R3,0F			:LAST ARGUMENT ENTERED = 0F?
	JE	XTSDA9			:YES
	CLHI	R3,0B			:NO,TEST FOR 0B
	JN	COMERR			:NO,ERROR

	LA	R2,XTSBAK		:YES, BACKGROUND MESSAGE
	LHL	R12,TSBPTR		:R12 = BACKGROUND TABLE POINTER
	STH	R12,TSPBAK		:TABLE POINTER BACKUP
	LI	R11,TSBTBL		:R11 = BACKGROUND TABLE ADDRESS
	LHI	R10,TSNBTO		:R10 = BACKGROUND TEXT OFFSET
	JFS	XTSDA8

XTSDA9	LA	R2,XTSFOR		:FOREGROUND MESSAGE
	LHL	R12,TSFPTR		:R12 = FOREGROUND POINTER
	STH	R12,TSPBAK
	LI	R11,TSFTBL		:R11 = FOREGROUND TABLE ADDRESS
	LIS	R10,0			:R10 = FOREGROUND TEXT OFFSET

XTSDA8	ST	R14,XTSSAV		:SAVE NEIGHBOR AND LINE # IN CASE OF ^C
	LCS	R0,1			:###OAS
	STH	R0,TSLINE		:TURN OFF LINE TRACE WHILE DISPLAYING
	LIS	R0,0			:###OAS
	STH	R0,TSLINK		:TURN OFF LINK TRACE WHILE DISPLAYING
	JAL	R7,TYPASC,,		:DISPLAY HEADER

XTSDA1	LB	R1,0,R12,R11		:GET EVENT BYTE
	NHI	R1,0F			:KEEP JUST 4 BITS FOR SAFETY
	SLLS	R1,3			:FORM 2-WORD INDEX
	LA	R2,XTSMSG-1,R1,R10	:GET APPROPRIATE ASCII TEXT
	LIS	R0,8			:MESSAGE LENGTH
	JAL	R7,TYPAS1,,
	JAL	R7,TYP4SP,,		:ALSO TYPE 4 SPACES
:	changed following to print the 3 bytes of FASTC as a number without
:	four spaces between 1st byte and 2 & 3 bytes.  Much prettier    ###sdw
	LIS	R5,4			:TYPE 4 BYTES
	LA	R6,1,R11,R12
	JAL	R8,TYPNBY,,
	JAL	R7,TYP2SP		:little extra to seperate FastC
	LB	R3,5,R11,R12		:first 1 of FASTC
	JAL	R9,TYPBYT,,
	LHL	R3,6,R11,R12		:GET FASTC
	JAL	R9,TYPHNS		:AND TYPE IT
	JAL	R7,TYPCRL,,		:TYP CR-LF

	SIS	R12,TSESZE		:BACK UP ONE ENTRY
	JGEFS	XTSDA7			:NON-NEGATIVE
	AHI	R12,TSTSZE		:NEGATIVE, CORRECT FOR WRAP
XTSDA7	CLH	R12,TSPBAK		:COME FULL CIRCLE?
	JEFS	XTSDA2			:YES
	J	XTSDA1			:NO, KEEP DISPLAYING

XTSDA2	L	R14,XTSSAV		:RECOVER NEIGHBOR NUMBER	###OAS
	STH	R14,TSLINE		:RESTORE TSLINE CELL		###OAS
	EXHR	R14,R14			:AND				###OAS
	STH	R14,TSLINK		:RESTORE TSLINK CELL
	LI	R14,0000FFFF		:CLEAR TO INIT VALUE		###AL
	ST	R14,XTSSAV		:CLEAR SAVE CELL		###OAS
	J	XRCRLF			:AND RETURN TO MAIN LOOP

	EI	:TSTSZE
	EI	:(XRSZLV-1)		:##AL

	SUBTTL	XRAY (Patch query - PQ)

	IF	(XRSZLV)		:##AL

::*********************************************************************
::
::	COMMAND:	PTCQRY:	PQ
::	FUNCTION:	DISPLAY PATCH HISTORY TABLE	  	###OAS
::
::*********************************************************************

	NOLIST
PCQDS1	SC	/"0D"0APATCH HISTORY TABLE   VERSION - /
PCQDS2	SC	/"0D"0A"0AYEAR  MODY  TIME  NAME"0D"0A----  ----  ----  ----------/
	LIST
PTCQRY	HS	0
	LR	R2,R2			:ZERO ARGS?
	JN	COMERR			:NO, ERROR
	LA	R2,PCQDS1
	JAL	R7,TYPASC,,		:BANNER
	LHI	R3,VERSION		:DISPLAY NODE CODE
	JAL	R9,HEXOCT		:VERSION NUMBER IN OCTAL
	JAL	R9,TYPFW	
	LA	R2,PCQDS2		:TABLE HEADERS
	JAL	R7,TYPASC,,
	LIS	R14,0			:PATCH HISTORY TABLE INDEX
PTCQR1	JAL	R7,TYPCRL,,		:CR/LF
	CLHI	R14,PHSIZE		:AT END OF TABLE?
	JGE	XPRMPT			:YES, EXIT.
	LB	R0,PATHIS+1,R14,	:CHECK FOR YEAR 1900 (NULL ENTRY)
	JE	XPRMPT			:END, EXIT.

	LHL	R3,PATHIS,R14,		:GET YEAR (19XX)
	JAL	R9,TYPHW
	LHL	R3,PATHIS+2,R14,	:GET DATE (MODY)
	JAL	R9,TYPHW
	LHL	R3,PATHIS+4,R14,	:GET TIME (HHMM)
	JAL	R9,TYPHW
	LA	R2,PATHIS+5,R14,	:POINT TO USERNAME-1
	LIS	R0,0A			:10 CHAR USERNAME
	JAL	R7,TYPAS1,,		:DISPLAY USERNAME

	AHI	R14,10			:POINT TO NEXT PATHIS CELL
	J	PTCQR1			:AND TRY AGAIN

	EI	:(XRSZLV)		:##AL

	SUBTTL	XRAY (Interface statistics commands - HS, IS, IR)

	IF	(XRSZLV-1)		:##AL

::*********************************************************************
::
::	COMMAND:	HSTDS:	HS
::	FUNCTION:	DISPLAY HOST INFORMATION
::	INPUT:	HS - DISPLAY, HS <HOST#1.. HOST#7> H - DISPLAY CERTAIN HOSTS
::		HS <SLOT#1..SLOT#7> S - DISPLAY CERTAIN SLOTS, 
::		HS U - DISPLAY ONLY UP OR SHUT HOSTS
::	###OAS
::
::*********************************************************************

      IF	1-T2GATE	:GATEWAY NO >HS CMD##AL

HSTDS5	SC	/N/		:IIX, ORG/DEST ONLY, PORTS AVAILABLE INDICATORS
	SC	/Y/

HSTDS	HS	0
	LR	R12,R1			:SAVE LAST CHAR ENTERED FOR LATER STUDY
	LR	R14,R2			:GET ARG COUNT
	JEFS	HSTDI0			:WITHOUT ARGS, CAN CLOSE WITH ANYTHING
	CLHI	R12,ASCH		:DID USER CLOSE WITH AN H(x48)?
	JEFS	HSTDI0			:YES, VALID
	CLHI	R12,ASCS		:DID USER CLOSE WITH AN S(x53)?
	JN	COMERR			:ONLY H OR S ARE VALID WITH ARGS
HSTDI0	LA	R2,HSTDS2,,		:DISPLAY HEADER BANNERS
	JAL	R7,TYPASC,,
	LA	R2,HSTDS3,,
	JAL	R7,TYPASC,,

HSTDI1	LIS	R11,0			:INIT HOST INDEX
HSTDI2	LHL	R1,HOSTN,R11,R11	:CHECK HOST ENTRY
	JE	HSTDI6			:NO ENTRY 
	LR	R14,R14			:ANY ARGS
	JE	HSTDI4			:NO ARGS, DON'T CHECK HOST OR SLOT #
	L	R3,VALUE1-4,R14,XD	:GET THIS ARG
	CLHI	R12,ASCH		:USER CLOSE WITH H(x48)?
	JNFS	HSTDI5			:NO, MUST HAVE BEEN AN S
	JAL	R9,DECHEX		:CONVERT ENTERED DECIMAL VALUE
					:J to DHXBAD for RADIX VIOLATION###wjl
	CLH	R3,HOSTN,R11,R11	:DOES ENTRY HOST NUMBER MATCH ?
	JE	HSTDI9			:YES, DISPLAY THIS ENTRY
	JFS	HSTDI7
HSTDI5	SLLS	R3,2			:FORM 4*SLOT NUMBER
	CLB	R3,HSTKEY,R11		:COMPARE SLOT KEY FOR THIS HOST ENTRY
	JE	HSTDI8			:MATCH, DISPLAY THIS ENTRY
HSTDI7	AIS	R11,1			:BUMP HOST INDEX, CHECK FOR MATCH AGAIN
	CLHI	R11,NHOSTS		:ALL ENTRIES CHECKED?
	JL	HSTDI2			:NO, TRY FOR MATCH
	J	HSTDI3			:GIVE UP ON THIS ARG

HSTDI4	CLHI	R12,ASCU		:DID USER CLOSE WITH U(x55)?
	JNFS	HSTDI8			:NO, DISPLAY ALL ENTRIES
	LB	R2,HSTATN,R11		:CHECK STATUS
	NHI	R2,EHDOWN		:CHECK IF BIT 1 OF LO BYTE IS SET
	JN	HSTDI6			:DOWN OR GONE (BIT 1 SET) DON'T DISPLAY
	JFS	HSTDI8

HSTDI9	OI	R14,80000000		:FLAG END PASS (BIT 0 OF R14)

HSTDI8	LHL	R3,HOSTN,R11,R11	:DISPLAY HOST NUMBER
	JAL	R9,TYPFWD
	JAL	R7,TYP1SP,,
					:DISPLAY SLOT NUMBER		###LH
	LB	R3,HSTKEY,R11		:SLOT# * 4 IF NON-MXP.  (00SS)	###LH
					:SLOT#,MACHINE# IF MXP. (00SM)	###LH
	IF      MXPNM 			:IF MXP, CONVERT (00SM) TO (0M0S)##LH
	EXBR    R2,R3     		: R2 = (SM00)			###LH
	NHI     R2,0F00   		: R2 = (0M00)			###LH
	SRHLS   R3,4      		: R3 = (000S)			###LH
	OR      R3,R2     		: R3 = (0M0S)			###LH
	ELSE	:not MXPNM		:IF NON-MXP, COMPUTE SLOT#	###LH
	SRLS	R3,2			:(TRUE SLOT#. NOT SLOT# * 4)	###LH
	EI      :MXPNM
	JAL     R9,TYPHW		:TYPE 4 DIGITS AS (00SS) IF NON-MXP.
	                         		:TYPE 4 DIGITS AS (0M0S) IF MXP.###LH
	LB	R3,HSTYPE,R11,		:DISPLAY PID CODE
	JAL	R9,TYPHW
	SHI	R3,BSEPID		:ensure PID range is OK		###jhl
	JL	HSTD12			:no. Too low
	CLHI	R3,PIDTBZ/2
	JG	HSTD12			:no. Too high
	LHL	R2,PIDTBL,R3,R3		:get offset to PID string descriptor
	LI	R2,SEGD,R2		:add in base offset (SEGD)
	LR	R3,R2			:save pointer to string character count
	JAL	R7,TYPASC
	LHI	R0,1A			:COMPUTE 26 - CHARACTERS
	LB	R2,0,R3			:get byte count of PID string	###jhl
	SR	R0,R2			:subtract length from field size $A26
	LA	R2,HSTDS6,,		:26 BLANKS
	JAL	R7,TYPAS1		:BYTE COUNT IN R0
	JFS	HSTD13
HSTD12	LA	R2,HSTDS6,,		:NO KNOWN PID, DISPLAY 26 BLANKS
	JAL	R7,TYPASC
HSTD13	LB	R1,HSTATN,R11		:GET EXPANDED HOST STATUS
	NHI	R1,00C0			:ISOLATE HOST STATUS (BITS 0,1-LO BYTE)
	SRLS	R1,4			:FORM INDEX (FW)
	LIS	R0,4			:4 CHARACTERS ALWAYS
	LA	R2,HSTDS4-1,R1,,		:DISPLAY HOST STATUS TEXT
	JAL	R7,TYPAS1		:BYTE COUNT IN R0
	JAL	R7,TYP2SP
	SLLS	R11,1			:FORM FULLWORD INDEX
	L	R2,HSTTIM,R11,R11	:INTO HOST STATUS TIME
	ST	R2,GMTNOW		:STORE FOR GMTCNV
	JAL	R9,GMTCNV		:TYPE IT
	JAL	R7,TYP2SP
	SRLS	R11,1			:RESTORE R11
	LB	R3,HSTCST,R11,		:GET HOST COST AND DISPLAY IT
	JAL	R9,TYPBYT,,		:FOLLOWED BY 2 SPACES
	LB	R0,HSTATN,R11		:GET EXPANDED HOST STATUS
	NHI	R0,000C			:ISOLATE ORG/DEST BITS (4,5 OF LO BYTE)
	JE	HSTD20			:BOTH NO
	CLHI	R0,000C			:ARE BOTH BITS SET?
	JE	HSTD20			:YES, BOTH NO
	LIS	R3,2			:ASSUME Y N (DEST ORG ONLY)
	NHI	R0,0008			:WHICH ONE IS SET?
	JEFS	HSTD21			:DESTINATION ONLY HOST
	XHI	R3,2			:MAKE IT N Y (DEST ORG ONLY)
HSTD21	LA	R2,HSTDS5,R3,,		:DISPLAY 'Y' DEST ONLY
	JAL	R7,TYPASC
	XHI	R3,2			:TOGGLE NEXT ONE
	LA	R2,HSTDS5,R3,,
	JAL	R7,TYPASC
	JFS	HSTD22
HSTD20	LA	R2,HSTDS5,,		:N N (DEST ORG ONLY)
	JAL	R7,TYPASC
	LA	R2,HSTDS5,,
	JAL	R7,TYPASC

HSTD22	LIS	R3,0			:INDEX FOR 'N'
	LB	R0,HSTATN,R11		:CHECK IF OUT OF PORTS
	THI	R0,0020			:(BIT 2 OF OF LO BYTE)
	JNFS	HSTD23			:OUT OF PORTS 'N'
	LIS	R3,2			:INDEX FOR 'Y'
HSTD23	LA	R2,HSTDS5,R3,,		:DISPLAY IT
	JAL	R7,TYPASC
	LB	R0,HSTATN,R11		:CHECK IF IIX
	LIS	R3,0			:INDEX FOR 'N'
	THI	R0,0010			:CHECK IF IIX HOST
	JEFS	HSTD24			:NOT IIX
	LIS	R3,2			:INDEX FOR 'Y'
HSTD24	LA	R2,HSTDS5,R3,,		:DISPLAY IT
	JAL	R7,TYPASC

	LIS     R3,0      		:Say if LOG II host (always)
	LB      R0,HSTAT3,R11   	:LOG II capable bit is 40
	THI     R0,40     		:is it log II host?
	JEFS    HSTD30
	LIS     R3,2
HSTD30  LA      R2,HSTDS5,R3,,  	:0 = N  2=Y
	JAL     R7,TYPASC 		:send it

	JAL     R7,TYPCRL 		:done with this line

HSTDI6	LR	R14,R14			:CHECK FOR FORCED END OF PASS
	JGEFS	HSTD25			:DUE TO MATCH FOUND (HO BIT SET)
	NI	R14,7FFFFFFF		:CLEAR HO BIT
	JFS	HSTDI3
HSTD25	AIS	R11,1			:BUMP HOST INDEX
	CLHI	R11,NHOSTS		:ALL ENTRIES DISPLAYED?
	JL	HSTDI2			:NO, TRY SOME MORE
HSTDI3	SIS	R14,4			:DECREMENT ARG COUNT, ANY LEFT?
	JG	HSTDI1			:YES, TRY SOME MORE
	J	XRCRLF			:RETURN TO MAIN LOOP

      EI	:1-T2GATE

::*********************************************************************
::
::	COMMAND:	ISSTAT:	IS
::	FUNCTION:	DISPLAY RELEVANT ISIS/DISPATCHER INTERFACE DATA
::
::*********************************************************************

       if       1-swtchr

ISSTAT
	CLHI    R1,ASCZ   		:clear statistics?
	JE      XISS70    		:yes, clear them
	LA      R2,XISHD4 		:ring utilization header
	JAL     R7,TYPASC
	LHL     R14,MTTINT		:interval of statistical collection
	LIS     R6,0      		:0- DORNG stats, 4-DIRNG stats
	LA      R2,XKSM04 		:CPS OUT:
	JAL     R7,TYPASC
XISS02  L       R2,DISOCM,R6
	DHR     R2,R14    		:make it per second
	JAL     R9,TYPFWD 		:type it in decimal
	LA      R2,XKSM05 		:HWM :
	JAL     R7,TYPASC
	L       R2,DISOCH,R6    	:high water mark
	DHR     R2,R14
	JAL     R9,TYPFWD 		:type highwater mark
	LA      R2,XISHD3 		:now the time of HWM
	JAL     R7,TYPASC
	L       R2,DISOCT,R6
	JAL     R9,GMTCNX 		:and type it
	LR      R6,R6
	JNFS    XISS04    		:did it both times
	LA      R2,XKSM03 		:CPS IN
	JAL     R7,TYPASC
	LIS     R6,4      		:and then do it in other direction
	J       XISS02    		:do DIRING

XISS04  LA      R2,XISHD6 		:TO ISIS  FROM ISIS  PEAK IN :
	JAL     R7,TYPASC
	LHL     R3,DISICP 		:get value of peak in
	JAL     R9,TYP5DD 		:in decimal
	LA      R2,XISHD2 		:'RANGE COUNT COUNT PEAK OUT:'
	JAL     R7,TYPASC
	LHL     R3,DISOCP 		:get value of peak out
	JAL     R9,TYP5DD
:       now the histogram
	LIS     R10,0     		:how far into histogram
	LIS     R11,0     		:index into messages (all 16 byte long)
XISS08  LA      R2,XISHD7,R11
	JAL     R7,TYPASC 		:type range
	L       R3,DSIHGM,R10   	:get DIRING (to ISIS)value
	JAL     R9,TYPFW
	L       R3,DSOHGM,R10   	:get DORING (from ISIS) value
	JAL     R9,TYPFW
	AHI     R11,10
	AIS     R10,4
	CLHI    R10,4*8   		:8 entries in table
	JL      XISS08

	LA	R2,XISHD1		:EXPLANATORY HEADER
	JAL	R7,TYPASC
	LHL     R3,DRIF,, 		:fill to ISIS
	JAL     R9,TYPHW
	LHL     R3,DRIE,, 		:empty to ISIS
	JAL     R9,TYPHW
	LHL     R3,DROF,,
	JAL     R9,TYPHW
	LHL     R3,DROE,, 		:from ISIS
	JAL     R9,TYPHW
	LA	R10,DISICP		:8 HALFWORD FIELDS,
	JAL	R8,TYP8HW		: DISPLAYED WITH SPACES TO SEPARATE
	J	XPRMPT			:DONE

XISS70  LIS     R2,0      		:clear statistics
	ST      R2,DISOCM 		:output CPS
	ST      R2,DISICM 		:input CPS
	ST      R2,DISOCH 		:highwater output 
	ST      R2,DISICH 		:highwater input
	ST      R2,DISOCT 		:time of highwater out
	ST      R2,DISICT 		:time of highwater in
	STH     R2,DISICP 		:peak in
	STH     R2,DISOCP 		:peak out
	LHI     R3,4*8-4  		:last entry in histogram
XISS74  ST      R2,DSOHGM,R3    	:clear output histogram
	ST      R2,DSIHGM,R3    	:clear input histogram
	SIS     R3,4
	JGEBS   XISS74
	LIS     R3,2*8-2  		:clear the 8 HW fields
XISS76  STH     R2,DISICP,R3
	SIS     R3,2
	JGEBS   XISS76
	LA      R2,XKSM25,,     	:display statistics cleared
	JAL     R7,TYPASC
	J       XPRMPT,,

       ei       :1-swtchr

::************************************************************
::
::      XRCFIG  Prints out flags where are equated to true (>0)
::
::************************************************************

XRCFMS  HS      0
	IF      CFMCNT
QQ      EQ      0         		:count of nonzero enties
Q       EQ      0         		:counter for all potential entries
	RE      CFMCNT
	CFM|Q|
QQ      EQ      QQ+QQQ    		:QQQ is setup by CFM|q|
       IF       QQQ       		:only for new entries
	 IF     (8*QQ)/8-(QQ/8)*8       :multiple of 8? (per line)
	AC      /   /     		:nope, so put in spaces
	 ELSE             		:not a mult of 8
	BC      8D,8A
	 EI               		:mult of 8
       EI  :QQQ
Q       EQ      Q+1
	ER
	ELSE    :CFMCNT         (HANDLE IF ALL FLAGS 0)
	BC      8D,8A
	EI  :CFMCNT

XRCFCT  EQ      .-XRCFMS  		:size of the message

XRCFIG  LHI     R0,XRCFCT
	LA      R2,XRCFMS-1     	:TYPAS1 expects address -1
	JAL     R7,TYPAS1 		:this entry has the count in R0
	J       XRCRLF,,


	EI	:(XRSZLV-1)		:##AL

	SUBTTL	XRAY (Node snap - ND)

	IF	(XRSZLV)		:##AL

::*********************************************************************
::
::	COMMAND:	XND:	ND
::	FUNCTION:	FORMAT NODE SNAP FOR DISPLAY
::
::*********************************************************************

XCROPM	SC	/RESTART/
	SC	/STOP   /
	SC	/BOOT   /
	SC	/HALT   /
	SC	/PATCH  /

XND	HS	0
	LA	R2,XNDHD1		:HEADER LINE 1
	JAL	R7,TYPASC
	LHI	R3,MACHNM
	JAL	R9,HEXOCT		:CONVERT NODE NUMBER TO OCTAL
	JAL	R9,TYP5CH		:TYPE FIVE DIGIT NODE NUMBER###SHM
	IF	T2GATE			:GATEWAY PUT 2 SIDE HOST NO.##AL
	JAL	R7,TYP2SP		:###cwc
	LHI	R3,HHOST		:FROM TYMFILE, HOME NET HOST NO.
	JAL	R9,TYP5DD,,		:###cwc
	JAL	R7,TYP2SP		:###cwc	
	LHI	R3,IHOST		:ISIS NET HOST NO.
	JAL	R9,TYP5DD,,		:###cwc
	JAL	R7,TYP2SP		:##AL
	ELSE	:NOT T2GATE
	LHI	R3,HST0			:				###wjl
	JAL	R9,TYP5DD,,		:KERNEL HOST IN DECIMAL		###cwc
	EI	:T2GATE
	LHI	R3,VERSION
	JAL	R9,HEXOCT		:CONVERT VERSION TO OCTAL
	JAL	R9,TYPFW
	JAL	R7,TYP2SP
	LB	R2,CRACTN,,
	SLLS	R2,3
	LA	R2,XCROPM,R2		:CRASH OPTION
	JAL	R7,TYPASC
	JAL	R7,TYP2SP
	LB	R2,CRACTN+1,,
	SLLS	R2,3
	LA	R2,XCROPM,R2		:CRASH OPTION
	JAL	R7,TYPASC
	JAL	R7,TYP2SP
	LHL	R3,TVRSUP		:SUP NUMBER
	JAL	R9,HEXDEC 		:convert to decimal
	LR      R1,R3     		:do a type byte without any spaces
	SRLS    R1,4
	JAL     R7,TYPHEX
	LR      R1,R3
	JAL     R7,TYPHEX 		:second hex digit
	                  		:if LOG II then print 'LG2' after sup #
	LB      R0,NEWSUP 		:first byte is 1 if log II supe
	JEFS    XND005
	LA      R2,XNDLG2
	JAL     R7,TYPASC 		:'LG2'
	JFS     XND006
XND005  JAL     R7,TYP5SP 		:else print four spaces
XND006
	IF	T2GATE			:###AL
	LHI	R3,MEMORY		:GATEWAY SLOT SIZE
	ELSE	:NOT T2GATE
	LHI	R3,S0CORE		:IF ISIS, JUST USE S0CORE FROM TYMFILE
	EI	:T2GATE
	JAL	R9,HEXDEC		:GO DECIMAL
	JAL	R9,TYPHNS		:AND DISPLAY
	LA	R2,XNDHD2		:HEADER LINE 2
	JAL	R7,TYPASC

:	COMPUTE NUMBER OF PORTS FOR KERNEL, DISPI INTERFACES. RUNNING
:	COUNT IS MAINTAINED IN 'HNPORT', BUT MAY NOT BE TOTALLY ACCURATE
:	DUE TO LOGIN RACE CONDITIONS.
	LIS	R0,0			:CUMULATIVE PORT COUNT
	IF	NKU
	LA	R2,KIOTAB,,		:KERNEL PORT PERMUTER TABLE
	LHI	R1,NKU			: AND NUMBER OF KERNEL PORTS
XNDAP1	LHL	R3,0,R2			:GET PERMUTER TABLE ENTRY
	JEFS	XNDAP2			:PORT NOT IN USE
	AIS	R0,1			:INCREMENT ACTIVE PORT COUNT
XNDAP2	AIS	R2,2
	SIS	R1,1			:ANY MORE TO DO?
	JGBS	XNDAP1			:YES - CONTINUE
	EI	:NKU
XNDAP3	HS	0
	IF	NDP
	LA	R2,DIOTAB,,		:DISPI PORT PERMUTER TABLE
	LHI	R1,NDP			: AND NUMBER OF DISPATCHER PORTS
XNDAP4	LHL	R3,0,R2			:GET PERMUTER TABLE ENTRY
	JEFS	XNDAP5			:PORT NOT IN USE
	AIS	R0,1			:INCREMENT ACTIVE PORT COUNT
XNDAP5	AIS	R2,2
	SIS	R1,1			:ANY MORE TO DO?
	JGBS	XNDAP4			:YES - CONTINUE
	EI	:NDP
	STH	R0,HNPORT		:UPDATE WITH MOST ACCURATE COUNT

	LHL	R3,HNPORT		:NUMBER OF PORTS IN USE
XNDTY1	JAL	R9,TYPHWD
	JAL	R7,TYP2SP		:COUPLE SPACES
	LHL	R3,PASTHR		:NUMBER OF PASSTHROUGHS IN USE
	JAL	R9,TYPHWD
	jal     r7,typ5sp
	lhl     r3,nbrcmd 		:number of passthru cmd cts
	lh      r0,tvrbuf
	jefs    xnd14
	ais     r3,1      		:+1 for our cmd cir
xnd14   jal     r9,typhwd
	JAL	R7,TYP2SP
	LHL	R3,NALINK		:NUMBER OF ACTIVE LINKS
	JAL	R9,TYPHWD
	LHI	R3,NLINKS		:TOTAL NUMBER OF LINKS DEFINED
	JAL	R9,TYPHWD
	LHI	R3,XLINKS		:NUMBER OF XLINKS DEFINED
	JAL	R9,TYPHWD
	JAL	R7,TYP2SP		:MORE SPACES
	LHI	R3,NLINES		:NUMBER OF LINES (SYNC+SIO) DEFINED
	JAL	R9,TYPHWD
	LHI	R3,NLINES-SILINS	:NUMBER OF SYNC LINES DEFINED
	JAL	R9,TYPHWD
	LHI	R3,SILINS		:NUMBER OF SIO LINES DEFINED
	JAL	R9,TYPHWD

	LA	R2,XNDHD5		:TELL WHEN WE FIRST CAME UP
	JAL	R7,TYPASC
	L	R2,XFIRST		:GET TIME OF FIRST TIME UP
	ST	R2,GMTNOW		:SAVE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE

	LA	R2,XNDHD3		:TELL HOW LONG WE'VE BEEN UP
	JAL	R7,TYPASC
	L	R2,XLCRSH		:GET TIME OF LAST CRASH
	ST	R2,GMTNOW		:SAVE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE

	LA	R2,XNDHD6
	JAL	R7,TYPASC
	L	R2,CS.TIM+CSMTBL	:GET CRASH TIME
	JAL	R9,GMTCNX,,		:DISPLAY IT
	JAL	R7,TYP2SP
	LHL	R3,CS.CNT+CSMTBL	:CRASH COUNT
	JAL	R9,TYPHWD
	LHL	R3,CS.CID+CSMTBL	:CRASH ID
	JAL	R9,TYPHW
	LHL	R3,CS.PSD+2+CSMTBL	:CRASH PSW
	JAL	R9,TYPHW
	L	R3,CS.PSD+4+CSMTBL	:CRASH PC
	JAL	R9,TYPFW

	LA	R2,XNDHD4		:HEADER TO DISPLAY LINK/LINE STATUS
	JAL	R7,TYPASC

	LIS	LN,0			:DO FOR ALL LINES, STARTING WITH 0
XND20	HS	0
	LR	R3,LN			:GET LINE NO.
	JAL	R9,TYPBYD		:TYPE IT
	IF	SILINS			:TEST FOR SYNC OR SIO LINE
	CLHI	LN,NLINES-SILINS	:SYNC LINE?
	JLFS	XND22			:YES
	LA	R2,XNDHSI		:NO - DISPLAY 'SIO LINE'
	JFS	XND24
	EI	:SILINS
XND22	LA	R2,XNDHSY		:DISPLAY 'SYNC LINE'
XND24	JAL	R7,TYPASC
	LHL	R3,NGSVLN,LN,LN 	:NEIGHBOR NUMBER - 
	JN	XND25			:NEIGHBOR HAS BEEN THERE, GO FIGURE.
	LR	R2,LN			:line no.
	AR	R2,R2			:times 2
	TBT	R2,DWLDSP		:check for DWL in progress
	JEFS	XND23			:no
	LA	R2,XDWLDS		:yes, say it
	JFS	XND21
XND23	LA	R2,NONEIG		:CANNED DISPLAY FOR UNUSED LINE
XND21	JAL	R7,TYPASC		:TYPE IT
	J	XND40			:NEXT LINE
XND25	NHI	R3,7FFF			:STRIP HO UP/DOWN INDICATOR BIT	###SHM 
	STH	R3,XNDSAV		:SAVE NODE NUMBER(IN HEX)	###SHM
	JAL	R9,HEXOCT		:CONVERT (R3) TO OCTAL		###SHM
	JAL	R9,TYP5CH		:TYPE FIVE DIGITS OF NODE #	###SHM
	LHL	R1,XNDSAV		:LOAD HEX NODE # FOR XFNDLK	###SHM
	JAL	R9,XFNDLK		:RETURNS KN AND KX (-1 IF NOT FOUND)
	SKIPAD(XND28)			:immediate return, NOP		###wjl
XND28	LHL	R3,XKNSAV,XD		:+4 return, LINK# FOR TYPBYT
	JAL	R9,TYPBYT,,		:TYPE LINK NO.

::	SEE IF NEIGHBOR IS TIILNK OR XLINK. 
::
	L	KX,XKDSAV,XD		:LINK DESC.
	JL	XND30			:IF <0 XLINK DOWN
	LH	R3,ONDID,KX		:XLINK?
	JEFS	XND30			:YES
	LA	R2,XNDTKD		:TII NEIGHBOR
	JFS	XND32
XND30	LA	R2,XNDXKD		:XLINK
XND32	JAL	R7,TYPASC		:DISPLAY TII OR XLNK
	LR	KX,KX			:CHECK FOR -1
	JLFS	XND31
	LB	R3,NLAT,KX		:NUMBER OF LINES ON LINK
	SIS	R3,1			:MORE THAN ONE LINE?
	JLEFS	XND31			:NO
	LA	R2,XNDMLL		:YES - DISPLAY 'MULTI-LINE LINK'
	JAL	R7,TYPASC
	JFS	XND33
XND31	JAL	R7,TYP3SP

:	LINE IS ACTIVE. DISPLAY 'UP', WINDOW SIZE, SPEED, AND NUMBER
:	OF ACTIVE CHANNELS ON LINK.
XND33
	LH	R3,NGSVLN,LN,LN		:LINE ATTACHED TO UP LINK IF HO BIT SET
	JGEFS	XND50			:NOT SET
	LA	R2,XNDLUP		:'UP'
	J	XND26			:GO TYPE IT
XND50	SLL	LN,1
	L	R3,KDLN,LN,LN		:GET LINK DESC ADDRESS
	SRL	LN,1
	AIS	R3,1			:IF 'FFFF' LINE IS SUSPENDED, ELSE DOWN
	JEFS	XND51			:LINE IS SUSPENDED
	LR	R2,LN			:line number...
	AR	R2,R2			:...times 2
	TBT	R2,DWLDSP		:see if DWL in progress
	JEFS	XND52			:no
	LA	R2,XDWLBR		:yes, say it
	JFS	XND26
XND52	LA	R2,XNDLOT		:'*DOWN*'
	JFS	XND26			:DISPLAY IT
XND51	LA	R2,XNDSUS		:'*SUSP*'
XND26	JAL	R7,TYPASC
	L	KX,XKDSAV,XD		:LINK DESC.
	JL	XND35
	LB	R3,WSIZ,KX		:PICKUP LINK WINDOWSIZE		###OAS
	JAL	R9,HEXDEC		:CONVERT TO DECIMAL		###OAS
	JAL	R9,TYPHNS		:TYPE FOUR DIGITS(NO SPACES)	###OAS
	JAL	R7,TYP1SP		:				###OAS
	LHL	R3,BAUDRT,LN,LN		:PICKUP LINE SPEED		###OAS
	LHL	R4,XKNSAV,XD		:GET LINK NUMBER
	TBT	R4,KNCNSP,,		:IS SPEED SPEC IN TYMFILE?
	JEFS	XND29			:NO, DISPLAY CALCULATED SPEED
	LB	R3,KSPD,KX		:H-SPEED CALC AND SPEC, GET LINK SPEED
	NHI	R3,1F			:ISOLATE SPEED BITS
XND29	LB	R4,KSPD,KX		:PICKUP LINK SPEED FOR SAT BIT	###OAS
	LA	R2,ASC2SP		:ASSUME TERRESTIAL LINE		###OAS
	THI	R4,20			:CHECK FOR SAT BIT SET		###OAS
	JEFS	XND27			:NO, LEAVE BLANK		###OAS
	LA	R2,ASCSAT		:YES, PUT @ BEFORE SPEED	###OAS
XND27	JAL	R7,TYPASC		:TYPE IT			###OAS

	SLLS	R3,3			: *8 FOR TABLE LOOK-UP
	LA	R2,HSPEED,R3
	JAL	R7,TYPASC		:DISPLAY HUMAN READABLE LINE SPEED
	JAL	R8,CHNCNT
	JAL	R9,TYPHWD		:DISPLAY NUMBER OF ACTIVE CHNS FOR LINK
	JFS	XND34

XND35	JAL	R7,TYPASP		:PAD IN 19 SPACES		###OAS
	JAL	R7,TYP8SP		:8 MORE
	JAL	R7,TYP1SP		:1 MORE
XND34	LR	R1,LN			:LINE NO.
	SLLS	R1,2			:TIMES 4
	L	R2,LINTIM,R1		:TIME OF LAST ATT/DET
	JE	XND40			:IGNORE IF 0
	ST	R2,GMTNOW		:STORE FOR GMTCNV
	JAL	R9,GMTCNV		:TYPE IT

	LIS	R2,1			:*FOR COUNT1 - NO. HW'S TO SCAN
	LA	R4,LDARLN,LN,LN		:*LD ARRAY FOR LINE -
	JAL	R9,COUNT1		:*HOW MANY 1'S - ANSWER IN R3
	LR	R3,R3			:*NO 1'S?
	JEFS	XND40			:*RIGHT, SO SKIP
	SRLS	R3,2			:*DIVIDE BY 4
	SLLS	R3,3			:*DW INDEX
	LA	R2,ASTER1,R3		:*GET APPROPRIATE NO. OF ASTERISKS
	JAL	R7,TYPASC		:*AND DISPLAY
	
XND40	JAL	R7,TYPCRL
	AIS	LN,1			:ADVANCE TO NEXT LINE NUMBER
	CLHI	LN,NLINES		:MORE TO DO?
	JL	XND20			:YES - CONTINUE
					:no 

:	FIND ALL TIILNK LINKS AND DISPLAY THOSE NOT UP...
XND70	HS	0
	LA	R2,XNDWDN		:DISPLAY 'TIILNK NEIGHBORS DOWN - '
	JAL	R7,TYPASC
	LHI	KN,(NLINKS-1)*2
	LIS	R5,0			:CUMULATIVE COUNT OF DOWN LINKS
XND72	STH	KN,XKNSAV,XD		:SAVE LINK#
	L	KX,KDKN,KN,KN		:GET LINK DESCRIPTOR INDEX
	LH	R3,ONDID,KX		:IS THIS AN XLINK?
	JE	XND80			:YES - BYPASS
	LB	R1,NLAT,KX		:ARE ANY LINES ATTACHED TO LINK?
	JN	XND80			:YES - LINK UP
	AIS	R5,1			:LINK DOWN - COUNT IT,
	JAL	R9,HEXOCT		: CONVERT TO OCTAL,
	JAL	R9,TYP5CH		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
	CHI	R5,8			:8 NBRS DISPLAYED 1ST LINE ##AL
	JEFS	XND80
:	JAL	R7,TYPCRL		:##AL
:	JFS	XND80
XND73	CHI	R5,8+0B			:11 NBRS DISPLAYED 2ND LINE ##AL
	JNFS	XND80			:GOOD ENOUGH FOR 32 NBRS
	JAL	R7,TYPCRL
XND80	LHL	KN,XKNSAV,XD		:RECOVER LINK#
	SIS	KN,2			:CHECK NEXT LINK
	JGE	XND72
:	DONE WITH ALL LINKS - WERE ANY DOWN?
	LR	R5,R5
	JN	XRCRLF			:YES, DONE WITH DISPLAY
	LA	R2,ASCZIP,,		:NO, ALL TIILNK LINKS UP. DISPLAY 'ZIP'
	JAL	R7,TYPASC
	J	XRCRLF			:DONE WITH ND DISPLAY

:	starline/starlink display


	SUBTTL	XRAY (Link descriptor - KD)


::*********************************************************************
::
::	COMMAND:	XNEIGB:	KD
::	FUNCTION:	DISPLAY LINK DESCRIPTOR TO GIVEN NEIGHBOR
::
::*********************************************************************

XNEIGB	HS	0
        clhi    r1,53                   :an 'S'?
        jn      xnei04
        lhi     r1,(nlinks-1)*2         :do all links
        sth     r1,argct,xd             :remember how many to do
xnei00  lh      r11,argct,xd
        jl      xprmpt                  :did all so done
        lr      r1,r11
        sis     r1,2
        sth     r1,argct,xd             :and remember we did link
        srls    r11,1
        sth     r11,xknsav,xd
        ar      r11,r11                 :restore to kn*2
        l       r9,kdkn,r11,r11         :set up like xfndlk
        st      r9,xkdsav,xd
        j       xnei06                  :and do output
xnei04	LHL	R2,ARGCT,XD		:ARGUMENT COUNT
	SIS	2,4			:MUST HAVE SINGLE ARG
	JN	COMERR
	JAL	R9,OCTHXR		:CONVERT ARGUMENT IN R3 TO HEX
        ts      argct,xd                :mark that only doing 1 link
	LR	R1,R3
	JE	COMERR			:FNDLNK WILL ACCEPT NEIGHBOR # OF 0
	JAL	R9,XFNDLK
	SKIPAD(COMERR)			:immediate return, NOT FOUND	###wjl
xnei06	JAL	R7,TYPCRL		:+4 return, TYP CR-LF
	L	KX,XKDSAV,XD		:LINK DESC.
	LA	R10,NDID,KX		:POINTS TO FIRST HW OF LNK DESCRIPTOR
	LA	R2,NEIMS1
	JAL	R7,TYPASC
	LIS	R5,0
XNEIG0	HS	0
	LHL	R3,0,R10
	CLHI	R5,4
	JGFS	XNEIGA
	JAL	R9,TYPHW
	AIS	R10,2
	AIS	R5,2
	JBS	XNEIG0
XNEIGA	LHL	KN,XKNSAV,XD
	TBT	KN,KNCNSP,,
	JNFS	XNEIG1
	NHI	R3,7FFF
XNEIG1	HS	0
	L	KX,XKDSAV,XD
	JAL	R9,TYPHW
	AIS	R10,2
	LIS	R5,4
	JAL	R8,TYPNHW

	LA	R2,NEIMS2
	JAL	R7,TYPASC
	ST	KX,XRSAVE,XD		:SAVE LINK DESCRIPTOR
	ST	R10,XRSAVE+4,XD		:AND POINTER
	LR	R8,XD			:SAVE USER BLOCK POINTER
	LM	R12,0,R10		:COPY DYNAMIC DATA
	STM	R12,XRSAVE+8,R8,	:TO STATIC AREA FOR ACCURATE READING
	LR	XD,R8			:RESTORE XD
	LA	R10,XRSAVE+8,XD
	JAL	R8,TYP8HW
	L	KX,XRSAVE,XD		:RECOVER LINK DESCRIPTOR
	L	R10,XRSAVE+4,XD		:AND POINTER
	AHI	R10,10			:ADVANCE POINTER
	LA	R2,NEIMS3
	JAL	R7,TYPASC
	LHL	R3,0,R10
	JAL	R9,TYPHW
	LHL	KN,XKNSAV,XD		:RECOVER LINK#
	LHL	R3,LKZFKN,KN,KN		:DISPLAY ABSOLUTE CHN FOR CHANNEL 0
	JAL	R9,TYPHW
	LHL	R3,TBDPKN,KN,KN		:DISPLAY BEGINNING OF PERMUTER TABLE
	JAL	R9,TYPHW
	LHL	R3,EBDPKN,KN,KN		:DISPLAY END OF PERMUTER TABLE
	JAL	R9,TYPHW
	L	KX,XKDSAV,XD		:RECOVER LINK DESC.
	LHL	R3,ANCHN,KX		:NO. OF ACTIVE CHANNELS
	JAL	R9,TYPHW
	LHL	R3,KVERNO,KX		:NEIGHBOR VERSION NUMBER
	JAL	R9,TYPHW

:	DISPLAY ALL LINES ATTACHED TO LINK

	lcs     r8,1      		:in case line drops, don't crash
	LB	R0,NLAT,KX
	JNFS	XNEIG2			:GOT SOME
TXNEI2	LA	R2,ASCZIP,,
	JAL	R7,TYPASC		:NO LINES ATTACHED - SAY 'ZIP'
	LCS	R8,1			:don't display NETID, HOST0, LINE###wjl
	J	XNEIG7
XNEIG2	LHI	LN,(NLINES-1)*2
XNEIG3
	LH	R1,NGSVLN,LN		:SEE IF THIS LINE ATTACHED TO LINK
	JGEFS	XNEIG4			:8000 BIT SET IF LINE ATTACHED
XNEI3B	NHI	R1,7FFF
	CLH	R1,NDID,KX		:IS LINE ATTACHED TO THIS LINK?
	JEFS	XNEIG6			:YES - DISPLAY IT
XNEIG4	SIS	LN,2
	JGE	XNEIG3			:CHECK ALL LINES
	JAL	R7,TYPCRL
	JFS	XNEIG7
XNEIG6	HS	0
	LR	R8,LN			:save LN for later		###wjl
	LR	R3,LN
	SRLS	R3,1
	JAL	R9,TYPBYT		:DISPLAY LINE NUMBER
	JBS	XNEIG4

XNEIG7	HS	0	:See how many of the active circuits are command
			:circuits and display.
	JAL	R7,TYPASI		:Type following string
	SC	/"0D"0ACMD CKTS = /
	LIS	R3,0			:Init count
	LHL	R4,NCHN,KX,		:# channels allocated to this link
	JE	XNEIG8			:none
	SRLS	R4,3			:number of bytes of bits to check
	LHL	KN,XKNSAV,XD,		:recover link number		###wjl
	LHL	R7,FLDPKN,KN,KN		:beginning of link's bit arrays	###wjl
XNEI7A	LH      R0,LNKACP,R7,   	:only test active circuits      ###sdw
	XHI     R0,-1     		:bits now 1 if active           ##sdw
	NH      R0,CMDCTS,R7,   	:active command circuits        ##sdw
XNEI7B  JFFOH   R0,XNEI7C
	AIS     R7,2      		:next HW
	SIS     R4,2      		:reach end yet?
	JGEBS   XNEI7A    		:do another pair of bytes       ###sdw
	JFS     XNEIG8    		:counted them all
XNEI7C  AIS     R3,1      		:found a set bit
:       R1 now has bit # of set bit (0-F), shift this bit off our hw    ###sdw
	SLL     R0,1,R1   		:R1 is one less than needed     ###sdw
	JBS     XNEI7B
XNEIG8	HS	0
	JAL	R9,TYPHW		:type out count in hex		###wjl
	JAL	R7,TYPCRL

	L	KX,XKDSAV,XD,		:recover link descriptor	###wjl
:	DISPLAY NEIGHBOR'S NETID, HOST0, AND FIRST LINE ATTACHED	###wjl
        lhl     r0,kverno,kx         :when it was up, was it on expanded reset
        clhi    r0,$8 520               :if after 5.20 then yes
	Jl	XNEIG9			:no, done...		###wjl/cwc
	JAL	R7,TYPCRL		:				###wjl
	LA	R2,NEIMS4		:heading for netid, host#, 1st-up line#
	JAL	R7,TYPASC		:			###wjl/cwc
	LHL	R3,KNETID,KX,		:				###wjl
	JAL	R9,TYPHW		:type neighbor's NETID		###wjl
	LA	R2,ASC1SP		:make 1 more blank to match up heading
	JAL	R7,TYPASC		:			###wjl/cwc
	L	R3,KHOST0,KX,		:			###wjl/cwc
	JAL	R9,TYPHW		:type neighbor's HOST0	###wjl/cwc
	LB	R3,KLINE,KX,		:				###wjl
	JAL	R9,TYPBYT		:type neighbor's 1st ln attached###wjl
	JAL	R7,TYPCRL		:				###wjl
XNEIG9					:important to have this label for tunl

	J	xnei00			:All done.

	EI	:(XRSZLV)		:##AL

	SUBTTL	XRAY (Scan memory for halfword match - MA)

	IF	(XRSZLV-2)		:##AL

::*********************************************************************
::
::	COMMAND:	XRMTCH:	MA
::	FUNCTION:	ENABLES THE USER TO FIND THE ADDRESSES OF ALL
::	OCCURENCES OF A SPECIFIED HALFWORD STRING IN A SPECIFIED
::	MEMORY RANGE.
::	INPUT:		MA <hex string> <start address> <end address>
::	IF THE COMMAND IS TERMINATED BY THE LETTER "N" THE ROUTINE
::	WILL SEARCH FOR ALL OCCURRENCES OF THE SECOND BYTE OF THE
::	STRING WHICH ARE NOT PRECEDED WITH THE FIRST BYTE OF THE
::	STRING.  FOR EXAMPLE,  
::		MA 0322 10000 1FFFFN
::	WILL FIND ALL OCCURRENCES OF 22 NOT PRECEDED WITH 03 IN
::	SEGMENT 1. 	###JHL
::
::*********************************************************************

TIMDSM	EQ	18			:NUMBER OF LOOPS AT ONE SHOT

XRMTCH	HS	0
	ST	R1,XRSAVE,XD		:SAVE LAST CHARACTER ENTERED FOR LATER
	LHL	R1,VALUE1+4,XD		:LIFT SEG # FROM START ADDRESS
	LHL	R2,VALUE1+8,XD		:LIFT SEG # FROM END ADDRESS
	CR	R1,R2			:DON'T READ ACROSS SEG BNDRY
	JN	XRMER1			:TELL USER TO STAY IN ONE SEGMENT
:	FALL THROUGH IF SAME SEG #'S.  NEXT CHECK WE DON'T GO 
:	BEYOND SEGMENT END.
	L	R4,VALUE1+4,XD		:READ START ADDRESS
	L	R0,VALUE1+8,XD		:READ END ADDRESS
	SLLS	R1,2			:MULT TIMES 4 TO GET WORD OFFSET 
	L	R2,SGLTBL,R1		:READ SEG LENGTH FOR THIS SEGMENT
	SRLS	R1,2			:BACK TO NORMAL
	EXHR	R1,R1			:GET SEG # IN HO HW
	AR	R1,R2			:VIRTUAL ADDR OF SEG END
	CR	R0,R1			:END ADDR - SEG END ADDR
	JLE	XRMT05			:OK--REQUESTED END IS WITHIN RANGE
	LR	R0,R1			:OTHERWISE ADOPT THE REAL END
XRMT05	SR	R0,R4			:R0 GETS END ADDR - START ADDR
	JLE	XRMER2			:TELL USER HIS RANGE IS NO GOOD
:	SET UP FOR PROCESSING.  R0 = END OFFSET, R1 = DISMISS TIME COUNTER,
:	R2 = R3 = SCRATCH, R4 = MATCH STRING, R5 = OFFSET COUNTER,
:	R6 = EVEN HALFWORD HOLDER, R7 USED TO LINK TO SUBROUTINES.
	LHI	R1,TIMDSM		:COUNTER FOR DISMISS
	L	R2,VALUE1+4,XD		:GET START ADDR OF SEARCH REGION
	NI	R2,0FFFFFFFE		:MAKE SURE THIS IS AN EVEN ADDRESS
	ST	R2,VALUE1+4,XD		:AND MAKE SURE WE USE IT
	LIS	R5,0			:INITIALIZE RUNNING OFFSET PTR
	L	R4,VALUE1,XD		:FIRST ARG IS MATCH-STRING
	LHL	R6,XRSAVE+2,XD		:DID USER END WITH AN "N"?
	CLHI	R6,ASCN			:IF HE DID IT'S NON-MATCH ON 1ST BYTE
	JE	XRNMFS			:GO TO NON-MATCH FIRST BYTE ROUTINE

:	WE'RE SET UP NOW FOR HW MATCH.  HERE IS THE MAIN MATCHING LOOP.
	LHL	R6,0,R2,R5		:READ FIRST (EVEN) HW
XRMT10	LR	R3,R6			:READ THE EVEN HW
	CLR	R3,R4			:SAME AS OUT STRING?
	JNFS	NMEVN			:SKIP NEXT IF NO MATCH
	L	R2,VALUE1+4,XD		:RESTORE START ADDR FOR FND CALLS
	JAL	R7,FNDEVN		:FOUND A MATCH AT EVEN BOUNDARY
	JAL	R7,TIMOUT		:OUTPUT ROUTINE TAKES A LONG TIME
NMEVN	EXBR	R3,R3			:SHIFT RIGHT BYTE TO LEFT
	NHI	R3,0FF00		:GET RID OF OLD LEFT BYTE
	AIS	R5,2			:BUMP OFFSET PTR TO NEXT HW
	CR	R5,R0			:HAS OFFSET REACHED END OF RANGE?
	JGE	XPRMPT			:IF SO, WE'RE FINALLY DONE CHECKING
	L	R2,VALUE1+4,XD		:GET START OF OUR SEARCH REGION
	LHL	R6,0,R2,R5		:READ NEXT (EVEN) HW
	LR	R2,R6			:MOVE TO A WORKING REGISTER
	EXBR	R2,R2			:WE WANT THE LEFT BYTE OF HW
	NHI	R2,0FF			:GET RID OF RIGHT HW FOR NOW
	OR	R3,R2			:COMBINE ODD-ADDR/ODD-ADDR+1
	CLR	R3,R4			:MATCH AGAINST OUR STRING
	JNFS	NMODD			:SKIP NEXT IF NO MATCH
	L	R2,VALUE1+4,XD		:RESTORE START ADDR FOR FND CALLS
	JAL	R7,FNDODD
	JAL	R7,TIMOUT		:OUTPUT ROUTINE TAKES A LONG TIME
NMODD	SIS	R1,1			:COUNT DOWN OUR DISMISS TIME
	JG	XRMT10			:NOT TIME TO YIELD YET--CONTINUE
	JAL	R7,TIMOUT		:TIME TO GIVE NODE CODE SOME CPU
	J	XRMT10			:CONTINUE MATCH/SHIFT/MATCH

:	SEARCH FOR A BYTE PRECEDED BY ANYTHING BUT A GIVEN BYTE.
:	REGISTER USAGE SAME AS FOR FOR STRAIGHT HW MATCH,
:	EXCEPT R4 = MATCH BYTE (SECOND), R6 = NON-MATCH BYTE. 
XRNMFS	HS	0
	LB	R4,VALUE1+3,XD		:PUT MATCH BYTE (SECOND ONE) IN R4
	LB	R6,VALUE1+2,XD		:PUT NON-MATCH BYTE IN R6
:	THIS WOULD BE A GOOD PLACE TO CHECK FOR 1ST BYTE XX TO DO BYTE COMPARE
NOMF10	AIS	R5,1			:INC THE OFFSET PTR
	CR	R5,R0			:REACHED END OF READ RANGE?
	JGE	XPRMPT			:IF WE HAVE, THEN EXIT
	SIS	R1,1			:DEC THE TIMEOUT COUNTER
	JG	NOMF20			:CONTINUE IF NOT DOWN TO ZERO
	JAL	R7,TIMOUT		:ELSE TIME TO YIELD TO NODE CODE
NOMF20	L	R2,VALUE1+4,XD		:SET UP PTR TO START ADDRESS
	LB	R3,0,R2,R5		:READ BYTE LOOKING FOR MATCH 
	CLR	R3,R4			:DOES IT MATCH OUR SECOND BYTE?
	JN	NOMF10			:IF NOT, MOVE TO NEXT PAIR
	SIS	R5,1			:IT DOES--CHECK PREV BYTE FOR NON-MATCH
	LB	R2,0,R2,R5		:READ THAT PREV BYTE, SAVE R3 FOR LATER
	CLR	R2,R6			:CHECK FOR NON-MATCH
	JE	NOMF30			:BUMP OFSET SO WE DON'T LOOP FOREVER
:	WE FOUND AN APPROPRIATE HW STRING--NOTIFY THE USER
	EXBR	R2,R2
	NHI	R2,0FF00
	OR	R3,R2			:NOW R3 HAS THE STRING
	L	R2,VALUE1+4,XD		:FND ROUTINES REQUIRE START ADDR IN R2
	JAL	R7,FNDEVN		:OUTPUT THE INFORMATION
NOMF30	AIS	R5,1			:RESTORE BYTE OFFSET FOR MORE CHECKS
	J	NOMF10			:AND LOOP AGAIN

:	**UTILITY ROUTINES FOR MATCH COMMAND**

::*********************************************************************
::
::	SUBROUTINE:	TIMOUT:
::	FUNCTION:	TIME OUT
::	CALLING SEQ:	JAL	R7,TIMOUT
::	CALLS:		JAL	R0,XRYYLD
::
::*********************************************************************

TIMOUT	HS	0
	CI	XD,TTYXD		:IS THIS A TTY USER?
	JER	R7			:FOR LOCAL USER, LET IT EAT TIME SLICE
	ST	R0,XRSAVE,XD		:SAVE RANGE FOR RESTORATION LATER
	ST	R5,XRSAVE+4,XD		:DITTO FOR OFFSET PTR
	STH	R6,XRSAVE+8,XD		:DITTO FOR THE LAST HW WE READ
	ST	R7,XRSAVE+0C,XD		:DITTO FOR THE LINK REGISTER
	JAL	R0,XRYYLD		:LET THE NODE CODE RUN
MTCRES	L	R0,XRSAVE,XD		:RESTORE RANGE OF OUR REGION TO CHECK
	LHI	R1,TIMDSM		:RESET COUNTDOWN TICKER	
	LHL	R4,VALUE1+2,XD		:RESTORE HW MATCH-STRING
	L	R5,XRSAVE+4,XD		:RESTORE OFFSET PTR
	LHL	R6,XRSAVE+8,XD		:RESTORE LAST HW WE READ
	L	R7,XRSAVE+0C,XD		:RESTORE THE LINK REGISTER
	JR	R7			:AND TAKE UP WHERE WE LEFT OFF

::*********************************************************************
::
::	SUBROUTINES:	FNDODD:/FNDEVN:
::	FUNCTION:	FOUND A MATCH.  OUTPUT THE ADDRESS AND STRING
::	TO THE USER, AND RESUME MATCH/SHIFT/MATCH.
::
::*********************************************************************

FNDODD	SIS	R2,1			:UPDATE OFFSET FOR ODD HALFWORD
FNDEVN	AR	R2,R5			:NOW R2 HAS THE ADDRESS OF THE MATCH
:	SAVE REGISTERS 0,1,2,3,4,7, AND OUTPUT THE ADDRESS TO THE USER
	ST	R0,XRSAVE,XD
	ST	R1,XRSAVE+4,XD
	ST	R2,XRSAVE+8,XD
	ST	R3,XRSAVE+0C,XD
	ST	R4,XRSAVE+10,XD
	ST	R7,XRSAVE+14,XD
	LR	R3,R2			:SET UP FOR SUBROUTINE CALL
	JAL	R9,TYPADD		:OUTPUT THE FULL WORD ADDRESS
	LHL	R3,XRSAVE+0E,XD		:GET HW STRING AT ABOVE ADDRESS
	JAL	R9,TYPHW		:AND OUTPUT TO THE USER
	JAL	R7,TYPCRL		:GIVE USER A NICE LINE TERMINATOR
:	RESTORE THE REGISTERS AND RETURN TO MATCH LOOP
	L	R0,XRSAVE,XD
	L	R1,XRSAVE+4,XD
	L	R2,XRSAVE+8,XD
	L	R3,XRSAVE+0C,XD
	L	R4,XRSAVE+10,XD
	L	R7,XRSAVE+14,XD
	AIS	R2,1			:BUMP IN CASE WE DEC'ED FOR ODDNESS
	NI	R2,0FFFFFFFE		:ENSURE WE'RE BACK TO AN EVEN OFFSET
	JR	R7

:	**ERROR MESSAGES**
XRMER1	HS	0
	LA	R2,XRMES1		:LOAD ADDRESS OF ERROR STRING
	JAL	R7,TYPASC		:TELL THE USER HOW HE ERRED.
	J	XRCRLF			:THEN WAIT FOR FURTHER INSTRUCTIONS

XRMER2	HS	0
	LA	R2,XRMES2		:LOAD ADDRESS OF ERROR STRING
	JAL	R7,TYPASC		:TELL THE USER HOW HE ERRED.
	J	XRCRLF			:THEN WAIT FOR FURTHER INSTRUCTIONS

	NOLIST
XRMES1	SC	/"0AYOU CAN'T READ ACROSS SEGMENT BOUNDARIES./
XRMES2	SC	/"0ASPECIFIED RANGE IS UNACCEPTABLE./
	LIST

::*********************************************************************
::
::	TABLE:		SGLTBL:
::	FUNCTION:	SEGMENT LENGTH TABLE
::
::*********************************************************************

SGLTBL	WS	0
	WC	S0SIZE
	WC	S1SIZE
	GL	S1SIZE
	GL	S2SIZE,S3SIZE,S4SIZE,S5SIZE,S6SIZE
	GL	S7SIZE,S8SIZE,S9SIZE,SASIZE,SBSIZE
	WC	S2SIZE
	WC	S3SIZE
	WC	S4SIZE
	WC	S5SIZE
	WC	S6SIZE
	WC	S7SIZE
	WC	S8SIZE
	WC	S9SIZE
	WC	SASIZE
	WC	SBSIZE
	WC	SCSIZE
	GL	SCSIZE
	WC	SDSIZE
	WC	SESIZE
	GL	SDSIZE,SESIZE
	WC	500			:SFSIZE IS NOTHING TO US

	SUBTTL	XRAY (Read crash registers - RR)

::*********************************************************************
::
::	COMMAND:	REGIST:	RR
::	FUNCTION:	TYPE THE REGISTERS SAVED IN ERRREG AFTER AN ERROR
::
::*********************************************************************

REGIST	HS	0
	LA	R6,ERRREG
	LHI	R5,10
	JAL	R8,TYPNFW
	J	XPRMPT

	EI	:(XRSZLV-2)		:##AL

::*********************************************************************
::
::	SUBROUTINE:	TYPNFW:
::	FUNCTION:	TYPE N FULLWORDS
::	CALLING SEQ:	JAL	R8,TYPNFW
::	INPUT:		R5 = NUMBER OF FULLWORDS
::			R6 = STARTING ADDRESS
::
::*********************************************************************

TYPNFW	HS	0 
REGS1	THI	R5,7
	JNFS	REGS3
	JAL	R7,TYPCRL
REGS3	L	R3,0,R6
	JAL	R9,TYPFW
	AIS	R6,4
	SIS	R5,1
	JGBS	REGS1
	JAL	R7,TYPCRL
	JR	R8

	SUBTTL	XRAY (CRYPTO message commands - CL, CP, CM, AP, SM)


::*********************************************************************
::
::	COMMAND:	CRYLST:	CL
::	FUNCTION:	TYPE LAST N CRYPTO MESSAGES
::
::*********************************************************************

	IF	(XRSZLV-1)		:##AL

CRYLST	HS	0
	LR	R2,R2			:check for no arguments		###wjl
	JE	CRYLS6			:no arguments			###wjl
	L	R3,VALUE1,XD		:ARGUMENT
	CLHI	R1,ASCH			:Ended with 'H' (x48)?
	JNFS	CRYLS0			:No

	LHI	R6,$A3600		:User wants last N hours worth
	JFS	CRYLS4

CRYLS0	HS	0
	CLHI	R1,ASCM			:Ended with 'M'?
	JN	CRYLS2			:No
	
	LHI	R6,$A60			:User wants last N minutes worth
CRYLS4	HS	0
	JAL	R7,CRYPTR		:Go compute out pointer
	JFS	CRYLS1			:Found beginning of time frame

CRYLS6	LHI	R3,10			:default number of args is 16	###wjl
CRYLS2	HS	0
	LHL	R2,CRYPRI
	SLLS	R3,4			:User wants last N messages
	clhi    r3,cryprs
	jlfs    cryls5
	lhi     r3,cryprs-10
cryls5
	SR	R2,R3
	JGEFS	CRYLS1
	AHI	R2,CRYPRS
CRYLS1	STH	R2,CRYPTU,XD
	LIS	R14,0			:OUTPUT ALL MESSAGES
	LCS	R12,1			:ENABLE ALL MESSAGES
CRYLS3	JAL	R7,TYPCRL
	JAL	R8,XCRYPT
	J	XPRMPT
	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	CRYLTP:	CP
::	FUNCTION:	TYPE LAST N CRYPTO priority MESSAGES ###AL1/4/85
::
::*********************************************************************

	IF 	PRIMSG

CRYLTP	HS	0
	lr      r2,r2     		:any args?
	jnfs    CRYLP7
	lhi     r3,10     		:if none then 16d messages
	j       crylp2
CRYLP7	L	R3,VALUE1,XD		:ARGUMENT
	CLHI	R1,ASCH			:Ended with 'H' (x48)?
	JNFS	CRYLP0			:No

	LHI	R6,$A3600		:User wants last N hours worth
	JFS	CRYLP4

CRYLP0	HS	0
	CLHI	R1,ASCM			:Ended with 'M'?
	JN	CRYLP2			:No

	LHI	R6,$A60			:User wants last N minutes worth
CRYLP4	HS	0
	JAL	R7,CRPPTR		:Go compute out pointer		###AL
	JFS	CRYLP1			:Found beginning of time frame

CRYLP2	HS	0
	LHL	R2,CRYPPI
	SLLS	R3,4			:User wants last N messages
	clhi    r3,crypps
	jlfs    crylp5
	lhi     r3,crypps-10
crylp5
	NHI	R3,CRYPPS-10
	SR	R2,R3
	JGEFS	CRYLP1
	AHI	R2,CRYPPS
CRYLP1	STH	R2,CRYPPU,XD
	LIS	R14,0			:OUTPUT ALL MESSAGES
	LCS	R12,1			:ENABLE ALL MESSAGES
CRYLP3	JAL	R7,TYPCRL
	JAL	R8,XCRPPT		:###AL
	J	XPRMPT

::*********************************************************************
::
::	SUBROUTINE:	CRPPTR:
::	FUNCTION:	Computes CRYPPU for CRYLTP and CRYMSG.###AL1/4/85
::	CALLING SEQ:	JAL	R7,CRPPTR
::	INPUT:		R3 = argument in minutes or hours, decimal
::			R6 = $A60, if minutes - $A3600 if hours
::	OUTPUT:		R2 = CRYPPU
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R9
::	CALLS:		JAL	R9,DECHEX
::
::*********************************************************************

CRPPTR	HS	0
	JAL	R9,DECHEX		:Argument is decimal, convert to hex
					:J to DHXBAD for Radix error	###wjl
	LHL	R2,CRYPPI		:Get crypto pointer
	MHR	R6,R3			:Convert to seconds
	JAL	R9,GMTCAL,,		:Get current time to GMTNOW
	L	R3,GMTNOW		:Current time + 7 bits of FASTC
	SRLS	R3,7			:Get rid of FASTC
	SR	R3,R6			:We want to go back to this time
	JGE	CPPTR0			:OK

	JAL	R7,TYPASI
	SC	/REQUESTED TIME OUT OF RANGE/
	J	COMERR

CPPTR0	HS	0
	SHI	R2,10			:Look at next oldest message
	JGEFS	CPPTR1

	AHI	R2,CRYPPS		:Wrapped

CPPTR1	HS	0
	CLH	R2,CRYPPI		:Back to where we started?
	JE	XPRMPT			:Yes, no message in time frame

	L	R5,CRYPPB+CRYGMT,R2,	:Get message timestamp
	AIS	R5,1			:Make sure it's not -1
	JEFS	CPPTR2			:It is, done
	SIS	R5,1			:Restore timestamp
	SRLS	R5,7			:Dump FASTC
	CLHI	R5,$A1440		:At least a day's worth
	JL	CPPTR0			:No, keep trying
	CR	R3,R5			:Are we in our time frame?
	JL	CPPTR0			:No, keep trying

CPPTR2	AHI	R2,10			:Move forward one
	NHI	R2,CRYPPS-1		:Correct for wrap
	JR	R7			:RET

	EI	:PRIMSG
	EI	:(XRSZLV-2)

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	SUBROUTINE:	CRYPTR:
::	FUNCTION:	Computes CRYPTU for CRYLST and CRYMSG.
::	CALLING SEQ:	JAL	R7,CRYPT
::	INPUT:		R3 = argument in minutes or hours, decimal
::			R6 = $A60, if minutes - $A3600 if hours
::	OUTPUT:		R2 = CRYPTU
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R9
::	CALLS:		JAL	R9,DECHEX
::
::*********************************************************************

CRYPTR	HS	0
	JAL	R9,DECHEX		:Argument is decimal, convert to hex
					:J to DHXBAD for Radix error	###wjl
	LHL	R2,CRYPRI		:Get crypto pointer
	MHR	R6,R3			:Convert to seconds
	JAL	R9,GMTCAL,,		:Get current time to GMTNOW
	L	R3,GMTNOW		:Current time + 7 bits of FASTC
	SRLS	R3,7			:Get rid of FASTC
	SR	R3,R6			:We want to go back to this time
	JGE	CRPTR0			:OK

	JAL	R7,TYPASI
	SC	/REQUESTED TIME OUT OF RANGE/
	J	COMERR

CRPTR0	HS	0
	SHI	R2,10			:Look at next oldest message
	JGEFS	CRPTR1

	AHI	R2,CRYPRS		:Wrapped

CRPTR1	HS	0
	CLH	R2,CRYPRI		:Back to where we started?
	JE	XPRMPT			:Yes, no message in time frame

	L	R5,CRYPRB+CRYGMT,R2,	:Get message timestamp
	AIS	R5,1			:Make sure it's not -1
	JEFS	CRPTR2			:It is, done
	SIS	R5,1			:Restore timestamp
	SRLS	R5,7			:Dump FASTC
	CLHI	R5,$A1440		:At least a day's worth
	JL	CRPTR0			:No, keep trying
	CR	R3,R5			:Are we in our time frame?
	JL	CRPTR0			:No, keep trying

CRPTR2	AHI	R2,10			:Move forward one
	NHI	R2,CRYPRS-1		:Correct for wrap
	JR	R7			:RETURN

::*********************************************************************
::
::	COMMAND:	SETMES:	SM
::	FUNCTION:	TURN UP TO 7 CRYPTO MESSAGES ON OR OFF
::
::*********************************************************************

SETMES	HS	0
	JAL	R9,RDARGS,,		:GET ARGUMENTS

	LR	R2,R2			:CHECK FOR NO ARGUMENTS
	JNFS	SETME9			:ARGS PRESENT, PROCESS THEM
	LIS	R0,0			:CLEAR ALL BITS (ENABLE ALL MSGS)
	LIS	R1,0F			:CLEAR 10 HW
SETME8	STH	R0,CRYARY,R1,R1,	:ENABLE ALL MESSAGES
	SIS	R1,1			:NEXT HW
	JGEBS	SETME8			:DO MORE
	J	XRPRMT			:ALL DONE

SETME9	SIS	R3,1
	JG	COMERR			:LAST ARGUMENT MUST BE 1/ON OR 0/0FF

SETME0	SIS	R2,4			:NUMBER OF ARGUMENTS MINUS 1
	JLE	XRPRMT			:DONE

	L	R0,VALUE1-4,XD,R2	:GET A MESSAGE NUMBER
	jl      comerr
	CLHI	R0,100			:RANGE CHECK
	JGEBS	SETME0			:TOO BIG

	LR	R3,R3			:ON OR OFF?
	JLFS	SETME2			:OFF

	RBT	R0,CRYARY,,		:ON
	J	SETME0

SETME2	SBT	R0,CRYARY,,		:OFF
	J	SETME0
	EI	:(XRSZLV-1)

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	SETPRI:	AP
::	FUNCTION:	TURN UP TO 7 CRYPTO priority MESSAGES ON OR OFF###AL
::
::*********************************************************************

	IF	PRIMSG

SETPRI	HS	0
	JAL	R9,RDARGS,,		:GET ARGUMENTS

	LR	R2,R2			:CHECK FOR NO ARGUMENTS
	JNFS	SETPR9			:ARGS PRESENT, PROCESS THEM
					:IF NO ARG, BACK TO DEFAUL PRIO. TABLE	
	LA	R0,CRYPDE-2,,		:COPY DEFAULT PRIO. TABLE TO ACTING TAB
	LA	R1,CRYPRE-2,,		:ENDING HW ADDR. R0 SOURCE,R1 DESTINATN
	LHI	R2,10*((CRYPDE-CRYPDF)/2-1)	:SIZE OF HW'S
	COPY	R0,R2
	J	XRPRMT			:ALL DONE

SETPR9	SIS	R3,1
	JG	COMERR			:LAST ARGUMENT MUST BE 1/ON OR 0/0FF

SETPR0	SIS	R2,4			:NUMBER OF ARGUMENTS MINUS 1
	JLE	XRPRMT			:DONE

	L	R0,VALUE1-4,XD,R2	:GET A MESSAGE NUMBER
	jl      comerr
	CLHI	R0,100			:RANGE CHECK
	JGEBS	SETPR0			:TOO BIG

	LR	R3,R3			:ON OR OFF?
	JLFS	SETPR2			:OFF

	SBT	R0,CRYPRY,,		:ON 
	J	SETPR0

SETPR2	RBT	R0,CRYPRY,,		:OFF
	J	SETPR0

	EI	:PRIMSG
	EI	:(XRSZLV-2)

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	CRYMSG:	CM
::	FUNCTION:	DISPLAY ALL MESSAGES OF A PARTICULAR TYPE
::
::*********************************************************************

CRYMSG	HS	0
	JAL	R9,RDARGS,,		:GET ARGUMENTS

	CLHI	R1,ASCH			:End with 'H' (x48)?
	JNFS	CRYMS0			:No

	LHI	R6,$A3600		:Wants an hour's worth
	JFS	CRYMS5

CRYMS0	HS	0
	CLHI	R1,ASCM			:End with 'M' (x4D)?
	JNFS	CRYMS3			:No

	LHI	R6,$A60			:Wants a minute's worth
CRYMS5	HS	0
	LCS	R2,4			:Decrement arg count since last arg
	AHM	R2,ARGCT,XD		:was time parameter
	JAL	R7,CRYPTR		:Get CRYPTU to R2
	JFS	CRYMS4

CRYMS3	HS	0
	LHL	R2,CRYPRI		:Do all messages
	AHI	R2,10
	NHI	R2,CRYPRS-1
CRYMS4	HS	0
	STH	R2,CRYPTU,XD
	JAL	R7,TYPCRL
	LI	R1,CRYMSK,XD		:Destination pointer
	LHI	R2,10			:16d HW's of CRYMSK to zero
	JAL	R8,HCLEAR,,		:CLEAR THE MASK ARRAY
	LH	R2,ARGCT,XD		:				###wjl
CRYMS2	LR	R2,R2
	JLEFS	CRYMS1			:AT END OF ARGUMENT LIST	###wjl

	LHL	R1,VALUE1-2,R2,XD	:GET AN ARGUMENT
	NHI	R1,$A255
	SBT	R1,CRYMSK,XD		:ENABLE THE MESSAGE TYPE
	SIS	R2,4
	JBS	CRYMS2

CRYMS1	LIS	R12,1			:INDICATOR TO XCRYPT TO USE MASK
	LHI	R14,0			:TYPE AS MANY AS NEEDED
	JAL	R8,XCRYPT
	J	XPRMPT

	EI	:XRSZLV-1 ###wjl

::*********************************************************************
::
::	SUBROUTINE:	XCRYPT:
::	FUNCTION:	PRINT CONTENTS OF CRYPTOGRAM BUFFER
::	CALLING SEQ:	JAL	R8,XCRYPT
::	INPUT:		R12 =	DISPLAY ONLY MESSAGES MASKED IN CRYMSK
::			ALL MESSAGES  ENABLED IF <0
::			R14 =	-(NUMBER OF MESSAGES TO TYPE). IF >= 0
::			MESSAGES TYPED UNTIL EMPTY PTR = FILL PTR
::
::*********************************************************************

	IF	XRSZLV-1		:###wjl

XCRYPT	HS	0
	LHL	R10,CRYPTU,XD		:GET THE OUT PTR
XCRYP1	CLH	R10,CRYPRI		:EQUAL IN PTR?
	JER	R8			:YES,RETURN

	LB	R11,CRYPRB+CRYTYP,R10,	:Get message type

	LR	R12,R12			:DISPLAY ALL MESSAGES?
	JLFS	XCRYP2			:YES

	TBT	R11,CRYMSK,XD		:NO,ONLY THOSE ENABLED IN CRYMSK ARRAY
	JE	XCRYP3			:THIS ISNT ONE

XCRYP2	CLHI	R11,CRYMTZ/2		:AVOID CRASH,CHECK FOR VALID INDEX
	JG	XCRYP3

XCRYP4	SLLS	R11,1			:FORM HW INDEX
	L	R2,CRYPRB+CRYGMT,R10,	:GET CRYPTOGRAM TIME AND
	ST	R2,GMTNOW		:STORE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE
	JAL	R7,TYP1SP
	LHL	R3,CRYPRB+CRYFAS,R10,	:16 BITS OF FASTC
	JAL	R9,TYPHW		:AND TYPE IT
	LHL	R2,CRYMTB,R11,		:GET MESSAGE POINTER
	AI	R2,SEGD			:IN CASE NEEDED BELOW.
	LB	R9,CRYPRB+CRYFLG,R10,	:CHECK FOR 0 FLAGS
	JE	XCRY19			:NO DATA
	LIS	R9,0			:INITIALIZE INDEX INTO DATA FLAG ARRAY
XCRY10	TBT	R9,CRYPRB+CRYFLG,R10,	:TYPE THE (R2+1)TH HW OF DATA?
	JE	XCRY12			:NO
	JAL	R7,TYPASC		:R2 HAS POINTER TO NEXT ASCII STRING
					:HW FOLLOWING POINTS TO CONVERSION RTN
	AIS	R2,2			:MAKE SURE ON 
	NHI	R2,-2			:HW BOUNDARY
	ST	R2,XRSAVE+4,XD

	SLLS	R9,1			:HW INDEX
	LHL	R2,0,R2			:GET SEGD.1 DISP TO APPROP CONVERSN RTN
	LHL	R3,CRYPRB+CRYHW0,R10,R9	:HW OF DATA
	STH	R9,XRSAVE,XD		:SAVE R9 BECAUSE OF TYPHW
	JAL	R9,SEGD.1,R2,		:TYPE IT, SEGD.1 is displacement###wjl
	L	R2,XRSAVE+4,XD
	LHL	R9,XRSAVE,XD		:RESTORE FLAG INDEX
	SRLS	R9,1			:RESTORE FLAG INDEX
	AIS	R2,2			:POINTER TO NEXT ASCII STRING
XCRY12	AIS	R9,1			:NEXT HW
	CLHI	R9,4			:CHECKING ONLY BITS 0-3
	JL	XCRY10			:NEXT
	JFS	XCRY20			:ALL DONE
XCRY19	JAL	R7,TYPASC		:TEXT ONLY, NO DATA
XCRY20	JAL	R7,TYPCRL		:TYPE CR/LF

XCRYP3	HS	0
	LHL	R10,CRYPTU,XD
	AHI	R10,10
	NHI	R10,CRYPRS-1		:UPDATE INDEX
	STH	R10,CRYPTU,XD
	AIS	R14,1			:INCREMENT NUMBER OF MESSAGED TYPED
	JER	R8			:IF 0, ALL DONE
	J	XCRYP1
	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	SUBROUTINE:	XCRPPT:
::	FUNCTION:	PRINT CONTENTS OF CRYPTOGRAM priority BUFFER###al
::	CALLING SEQ:	JAL	R8,XCRPPT
::	INPUT:		R12 =	DISPLAY ONLY MESSAGES MASKED IN CRYMSK
::			ALL MESSAGES  ENABLED IF <0
::			R1 =	-(NUMBER OF MESSAGES TO TYPE). IF >= 0
::			MESSAGES TYPED UNTIL EMPTY PTR = FILL PTR
::
::*********************************************************************

	IF	PRIMSG

XCRPPT	HS	0
	LHL	R10,CRYPPU,XD		:GET THE OUT PTR
XCRPP1	CLH	R10,CRYPPI		:EQUAL IN PTR?
	JER	R8			:YES,RETURN

	LB	R11,CRYPPB+CRYTYP,R10,	:Get message type

XCRPP2	CLHI	R11,CRYMTZ/2		:AVOID CRASH,CHECK FOR VALID INDEX
	JG	XCRPP3

XCRPP4	SLLS	R11,1			:FORM HW INDEX
	L	R2,CRYPPB+CRYGMT,R10,	:GET CRYPTOGRAM TIME AND
	ST	R2,GMTNOW		:STORE IT FOR GMTCNV
	JAL	R9,GMTCNV		:CONVERT AND TYPE
	JAL	R7,TYP1SP
	LHL	R3,CRYPPB+CRYFAS,R10,	:16 BITS OF FASTC
	JAL	R9,TYPHW		:AND TYPE IT
	LHL	R2,CRYMTB,R11,		:GET MESSAGE POINTER
	AI	R2,SEGD			:IN CASE NEEDED BELOW.
	LB	R9,CRYPPB+CRYFLG,R10,	:CHECK FOR 0 FLAGS
	JE	XCRP19			:NO DATA
	LIS	R9,0			:INITIALIZE INDEX INTO DATA FLAG ARRAY
XCRP10	TBT	R9,CRYPPB+CRYFLG,R10,	:TYPE THE (R2+1)TH HW OF DATA?
	JE	XCRP12			:NO
	JAL	R7,TYPASC		:R2 HAS POINTER TO NEXT ASCII STRING
					:HW FOLLOWING POINTS TO CONVERSION RTN
	AIS	R2,2			:MAKE SURE ON 
	NHI	R2,-2			:HW BOUNDARY
	ST	R2,XRSAVE+4,XD

	SLLS	R9,1			:HW INDEX
	LHL	R2,0,R2			:GET SEGD.1 DISP TO APPROP CONVERSN RTN
	LHL	R3,CRYPPB+CRYHW0,R10,R9	:HW OF DATA
	STH	R9,XRSAVE,XD		:SAVE R9 BECAUSE OF TYPHW
	JAL	R9,SEGD.1,R2,		:TYPE IT, SEGD.1 is displacement###wjl
	L	R2,XRSAVE+4,XD
	LHL	R9,XRSAVE,XD		:RESTORE FLAG INDEX
	SRLS	R9,1			:RESTORE FLAG INDEX
	AIS	R2,2			:POINTER TO NEXT ASCII STRING
XCRP12	AIS	R9,1			:NEXT HW
	CLHI	R9,4			:CHECKING ONLY BITS 0-3
	JL	XCRP10			:NEXT
	JFS	XCRP20			:ALL DONE
XCRP19	JAL	R7,TYPASC		:TEXT ONLY, NO DATA
XCRP20	JAL	R7,TYPCRL		:TYPE CR/LF

XCRPP3	HS	0
	LHL	R10,CRYPPU,XD
	AHI	R10,10
	NHI	R10,CRYPPS-1		:UPDATE INDEX
	STH	R10,CRYPPU,XD
	AIS	R14,1			:INCREMENT NUMBER OF MESSAGED TYPED
	JER	R8			:IF 0, ALL DONE
	J	XCRPP1

	EI	:PRIMSG
	EI	:(XRSZLV-2)		:##AL


	IF	(XRSZLV-2)

::*********************************************************************
::
::      Command:        XCHNEI - CN
::      Function:       Change Neighbor number.  prompts for rest of
::                      arguements.  (old neighbor, new neighbor, link
::			speed and windowsize (if want smaller than existing)
::
::*********************************************************************
xcnms1	sc	/"0d"0aCurrent Neighbor (0 for XLINK):/
xcnms2	sc	/"0d"0aNew Neighbor (0 to make an XLINK):/
xcnms3	sc	/"0d"0aNew Link Speed in KBPS (100 for MS):/
xcnms4	sc	/"0d"0aWindow Size for this link is /
xcnms5	sc	/."0d"0a/
xcnms9	bc	2,4,7,9,14,19,28,38,48,56	:speeds
xcnms8	bc	1,2,3,4, 6, 8,0c,10,14,17	:internal speed
xchnei	la	r2,xcnms1		:ask for old neighbor
	jal	r7,typasc
	jal	r8,rdexp		:get it
	lr	r4,r4			:anything typed?
	je	comerr
	jal	r9,octhxr		:get it to hex
	lr	r1,r3			:get node number
	jal	r9,xfndlk,,		:find it
	skipad(comerr)			:not there
	la	r2,xcnms2		:ask for new value
	jal	r7,typasc
	jal	r8,rdexp		:get new node number
	lr	r4,r4			:anything typed?
	je	comerr
	jal	r9,octhxr		:convert to hex
	lhl	kn,xknsav,xd		:set up by xfndlk
:       borzap inverted by sdw
	rBT	kn,borzap		:drop link if up
	sth	r3,neikn,kn,kn		:save it to be there if restart
	l	r4,xkdsav,xd		:get link descriptor
	sth	r3,ndid,r4		:for current
	sth	r3,ondid,r4		:still be there if link drops
xchne2	la	r2,xcnms3
	jal	r7,typasc		:get new link speed
	jal	r8,rdexp
	lr	r4,r4
	je	xprmpt			:don't want to change it
	lis	r6,0			:not satelite
	nhi	r1,7f			:end in @ means satelite
	clhi	r1,40
	jnfs	xchne1
	lhi	r6,20			:add in satelite bit	
	lhl     r8,xknsav,xd
	sbt     r8,kncnst,,     	:set satelite bit
xchne1	clhi	r3,100
	jg	xchne2
	jnfs	xchne4			:not ms
	lhi	r1,1f
	jfs	xchne5
xchne4	lis	r1,9			:nine speeds possible
xchne3	clb	r3,xcnms9,r1		:match?
	jefs	xchne6
	sis	r1,1
	jgebs	xchne3			:find a match
	j	xchne2
xchne6	lb	r1,xcnms8,r1		:get internal speed
xchne5	lhl	kn,xknsav,xd		:set up by xfndlk
	l	r4,xkdsav,xd		:get link descriptor
	or	r1,r6			:add in satelite bit
	stb	r1,kspd,kd		:save speed
	stb	r1,knsat,kn,		:and into initial table	
        sbt     kn,kncnsp,,             :indicate to use speed in table
	j	xprmpt,,

::*********************************************************************
::
::      Command:        XRYWSZ - WZ
::      Function:       Change window size.  Must BORIZAP link so that
::                      new size can come up.
::
::*********************************************************************

XRYWSZ
	SIS     R2,8      		:two arguments?
	JN      COMERR,,  		:if not then error
	L       R3,VALUE1,XD    	:get node number
	JAL     R9,OCTHXR 		:get node number in hex
	LR      R1,R3     		:setup to find link
	JAL     R9,XFNDLK,,     	:find it
	SKIPAD(COMERR)    		:not there, error
	L       R3,VALUE1+4,XD  	:get desired window size
	JAL     R9,DECHEX
	CLHI    R3,100    		:way too big?
	JGE     COMERR    		:bigger than the next compare
	LHL     KN,XKNSAV,XD    	:get link number
	CLH     R3,XWSZKN,KN,KN 	:can't be bigger than assembled size
	JG      COMERR,
	CLHI    R3,MINWSZ 		:no smaller than 4
	JL      COMERR
	STB     R3,WSZKN+1,KN,KN	:save new window size
	rBT     KN,BORZAP 		:link will come up with new window
	J       XPRMPT,,  		:and done



::*********************************************************************
::
::      Command:        XRYWPK - PK
::      Function:       display size of packets being made for that neighbor
::                      to determine why packets are small so often
::
::*********************************************************************

       IF       XRYRMK    		:enabled
XRYWPK  SIS     R2,4      		:we have a node # or give display
	JG      COMERR,,
	JL      XRYWP0    		:skip to give display
	JAL     R9,OCTHXR,,     	:convert node #
	STH     R3,XRMKNE,,     	:node to monitor
	LIS     R0,0      		:zero out old entries
	LIS     R1,0
XRYWP9  ST      R0,XRMKHS,R1,
	AIS     R1,4
	CLHI    R1,$A128*2		:HW per packet size
	JLEBS   XRYWP9
	J       XPRMPT,,  		:and done

XRYWP0  LIS     R5,0      		:how far into histogram
	LHI     R6,$A128  		:value at 0 pos of histogram
XRYWP1  LR      R3,R6     		:output range
	JAL     R9,TYPHWD,,
	L       R3,XRMKHS,R5,R5 	:value
	JAL     R9,TYPFW
	LHI     R3,$A-32,R6
	JAL     R9,TYPHWD 		:rnange of next column
	L       R3,XRMKHS+$A32*2,R5,R5  :value for next column
	JAL     R9,TYPFW
	LHI     R3,$A-64,R6
	JAL     R9,TYPHWD
	L       R3,XRMKHS+$A64*2,R5,R5  :value next column
	JAL     R9,TYPFW
	LHI     R3,$A-96,R6
	JAL     R9,TYPHWD
	L       R3,XRMKHS+$A96*2,R5,R5
	JAL     R9,TYPFW
	JAL     R7,TYPCRL 		:new lin
	AIS     R5,2
	SIS     R6,2
	CLHI    R6,$A96
	JG      XRYWP1
	J       XPRMPT,,

      EI	:XRYRMK


::*********************************************************************
::
::	COMMAND:	RSSILN:	SI				###LSH
::	FUNCTION:	INITIALIZE AN SIO LINE
::
::*********************************************************************

	IF	SILINS 
RSSILN	HS	0
	CLHI	R2,4		:MUST BE SINGLE ARG
	JN	COMERR
	L	R3,VALUE1,XD	:GET LINE# IN DECIMAL
	JAL	R9,DECHEX	:CHANGE TO HEX
				:J to DHXBAD for bad radix		###wjl
	CLHI	R3,NLINES	:MUST BE IN THE SIO LINE#'S RANGE	##AL
	JGFS	SSHS3
	SHI	R3,NLINES-SILINS:CHECK IF IN SIO LINE RANGE
	JGEFS	SSHS1		:YES, 
SSHS3	LA	R2,SSMSG1,,	:NOT A SIO LINE
	JAL	R7,TYPASC,,
	J	XPRMPT
SSHS1	CLHI	R3,SILINS	:CHECK IF IT IS TOO BIG
	JGE	SSHS3		:WRONG LINE #
	SLLS	R3,4		:16*LINE#
	LCS	R2,2
	STH	R2,SIOSTT+8,R3,	:-2 INDICATES SOFTWARE INIT
	J	XPRMPT		
	EI	:SILINS	
	EI	:(XRSZLV-2)		:##AL



	SUBTTL	XRAY (Miscellaneous - SY, BD)

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	SYMBAD:	SY
::	FUNCTION:	TYPES OUT ADDRESSES OF SYMBOLS FROM THE SYMBOL TABLE
::
::*********************************************************************

SYMBAD	HS	0
	JAL	R13,XRYIN
	NHI	R1,ASC7BT		:STRIP HOB (x7F)
	CLHI	R1,ASCSPC		:MUST BE SPACE (x20)
	JN	COMERR			:SORRY...
	JAL	R13,XRYIN		:GET KEY TO TABLE
	LR	R6,R1
	JAL	R7,TYPCRL		:TYP CR-LF
	OHI	R6,80			:SET HOB
	LIS	R5,0

	GL	SYMTBL

SYMBA1	CLHI	R6,ASCAST+80		:ASTERISK (x20) = DISPLAY ENTIRE TABLE
	JEFS	SYMBA3

	NHI	R6,ASCUC		:ASSUME ALPHABETIC,ENSURE UPPERCASE/xDF
	LB	R2,SYMTBL+1,R5,		:GET FIRST CHARACTER
	CR	R2,R6
	JN	SYMBA2			:NOT A MATCH

SYMBA3	LA	R2,SYMTBL,R5,		:SYMBOLIC NAME
	JAL	R7,TYPASC
	JAL	R7,TYP2SP		:2 SPACES
	L	R3,SYMTBL+8,R5,		:SYMBOL ADDRESS
	JAL	R9,TYPFW		:TYPE IT OUT
	JAL	R7,TYPCRL

SYMBA2	AHI	R5,ADRESZ	
	CLHI	R5,SYMTSZ		:AT END OF TABLE?
	GL	SYMTSZ
	JL	SYMBA1
	J	XPRMPT			:FINISHED

	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	XBDSET:	BD	###JHL
::	FUNCTION:	BD sets or displays buffer delay timing method.
::	INPUT:		BD displays current method
::			BDP sets timing by char pairs (COMETS 0314)
::			BDR sets timing based on round robin frequency
::
::*********************************************************************

	IF	BFLTMR
XBDPR0	SC	/"0D"0ABUFFER DELAY BY TIMING PAIRS"0D"0A/
XBDPR1	SC	/"0D"0ABUFFER DELAY BY RMK FREQUENCY"0D"0A/

XBDSET	HS	0
	CLHI	R1,ASCP			:DID USER END WITH P?
	JE	XBDSTP			:ZERO OUT THE CELL
	CLHI	R1,ASCR			:DID USER END WITH R?
	JE	XBDSTR			:STORE NON-ZERO IN THE CELL
XBDDSP	LHL	R1,BFDOPT,,		:READ THE CELL
	JEFS	XBDCPR			:GET CHAR PAIR STRING
	LA	R2,XBDPR1		:POINT TO RMK FREQ STRING
	JFS	XBDS10
XBDCPR	LA	R2,XBDPR0		:POINT TO CHAR PAIR STRING
XBDS10	JAL	R7,TYPASC		:OUTPUT THE STRING
	J	XPRMPT			:BACK TO TOP LEVEL

XBDSTP	LIS	R1,0			:FOR CHAR TIMING
XBDS20	STH	R1,BFDOPT,,		:STORE SELECTED VALUE
	J	XBDDSP			:DISPLAY CURRET OPTION TO USER
XBDSTR	LIS	R1,1			:FOR TIMING BY RMK FREQ
	JBS	XBDS20
	EI	:BFLTMR
	EI	:(XRSZLV-2)		:##AL

	SUBTTL 	XRAY (Delay measurement - DL, DB, DD, DE)

	IF	(XRSZLV-1)		:##AL

::*********************************************************************
::
::	COMMAND:	XLUPBK:	DL
::	FUNCTION:	CONSTRUCTS A CLOSED CIRCUIT THAT PASSES THROUGH
::			ALL NODES IN THE ARGUMENT LIST.
::
::*********************************************************************

:	INITIAL 'FILL' BYTES ARE PUT IN THE OUTBOUND BUFFER, AND THEY
:	SUBSEQUENTLY MOVE 'ROUND AND 'ROUND THE LOOP.
:	THE CPS RATE THEY GENERATE (MEASURED WITH THE KS AND NS COMMANDS)
:	INDICATE THE PROCESSING SPEEDS OF THE NODES INCLUDED IN THE CIRCUIT.

:	local equates for needle flag bits
PRTYBT	EQ	100			:priority bit
TPCLA	EQ	00			:throughput class A
TPCLB	EQ	10			:throughput class B
TPCLC	EQ	20			:throughput class C
TPCLD	EQ	30			:throughput class D

TPCLAS	SC	/"0D"0ATHROUGHPUT CLASS (0-3): /

XLUPBK	HS	0
	LHL	R0,INTLPF		:CURRENTLY ONLY 1 LOOPBACK IS SUPPORTED
	JN	COMERR			:ALREADY ONE THERE, ERROR
	TS	XLUPFL			:SET FLAG AND FALL THRU TO DBEGIN CODE

::*********************************************************************
::
::	COMMAND:	DBEGIN:	DB
::	FUNCTION:	COMMAND HANDLER TO INPUT PARAMETERS FOR ROUND-TRIP
::			DELAY MEASUREMENT
::
::*********************************************************************

DBEGIN	HS	0
	SIS	R2,4			:IF NO ARG'S, INDEX = 0.
	JGEFS	DBEG02			:AT LEAST 1 ARG.
	LIS	R6,0			:DEFAULT INDEX = 0
	JFS	DBEG07
DBEG02	LHL	R6,VALUE1+2,XD		:GET DB-INDEX FROM CMD LINE	###JHL
	LH	R13,XPOWER,XD		:GET USER'S POWER		###TZ
	JLEFS	DBEG05			:OK
	LR	R6,R6
	JN	XPWER1			:ONLY INDEX 0 FOR NON-POWER
DBEG05	CLHI	R6,TINTCH/2
	JGE	COMERR			:ARGUMENT IS TOO LARGE
DBEG07	LHL	R13,INTUSE		:MAKE SURE WE HAVE A CHANNEL
	XHI	R13,0FFFF
	JFFOH	R13,DBEG10
	J	DBERR			:NO,NONE
DBEG10	CLHI	R14,TINTCH		:MAKE SURE CHANNEL NUMBER'S IN RANGE
	JGE	DBERR			:NO, WE HAVE NO CHANNELS
	STH	R6,INTNDX,R14,R14	:STORE DB-INDEX BY INTHST CHAN#
	LR	R7,R6			:SAVE INDEX
	LHI	R6,DLYBSZ		:SIZE OF DLY DATA AREA
	MHR	R6,R7			:TIMES INDEX = OFFSET INTO TABLE AREA
	AI	R6,DLYBSE		:FORM OFFSET TO THIS INDEX
	LH	R2,DLSTAT,R6		:MAKE SURE IT IS AVAILABLE
	JG	DBERR			:STATUS OF 1 MEANS IT IS IN USE
	LI      R2,-DLYBSE,R6   	:DLYCHN is now offset from DLYBSE###sdw
	STH	R14,DLYCHN,R7,R7	:DELAY # TO INT HST CHN# PERMUTER TBL
	STH	R2,CHNDLY,R14,R14	:CHN # TO DELAY ADDRESS PERMUTER TABLE
	LHI	R2,8080+TPCLD		:MAKE SURE FLAGS ARE NEVER ZERO
	OH	R2,DLYFLG,R6
	STH	R2,DLYFLG,R6
	LR	R7,R7			:DLY CHN INDEX 0?
	JNFS	DBEG13			:NO, GO PROMPT
	LHI	R2,8080+TPCLD		:PRIORITY 0 FLAGS--THRUPUT CLASS 3
	STH	R2,DLYFLG,R6
	LIS	R2,0
	STH	R2,DLYFIL,R6		:DEFAULT 0 HW FILL
	LIS	R2,7
	STH	R2,DLYINT,r14,r14	:DEFAULT RATE = 3 (1 SEC)
	J	DBEG25			:GO ASK FOR NODE LIST.
DBEG13	LA	R2,PRPRTY,,		:PROMPT FOR PRIORITY
	JAL	R7,TYPASC
	JAL	R9,RDARGS,,
	SIS	R1,ASCCR
	JN	COMERR			:MUST TERMINATE ON CR, ELSE ERROR
	LR	R2,R2
	JEFS	DBEG18			:NO ARGUMENT,LEAVE PRIORITY UNCHANGED
	LHI	R2,8080+TPCLD		:DEFAULT FLAGS (HIGH-SPEED)
	LR	R3,R3			:TEST ARGUMENT
	JLEFS	DBEG16			:<= 0 MEANS NOT PRIORITY
	OHI	R2,PRTYBT		:SET PRIORITY BIT
DBEG16	STH	R2,DLYFLG,R6		:AND STORE FLAG
DBEG18	HS	0
:	set TP class limit for delay msmt circuits	###jhl
	LA	R2,TPCLAS		:pointer to "TP CLASS?" string
	JAL	R7,TYPASC		:output string to user
	JAL	R9,RDARGS,,		:get response from user
	SIS	R1,ASCCR		:insure user ended with <cr>
	JN	COMERR			:output the witty "??"
:	now R2 has # args, R3 has last number entered
	LR	R2,R2			:check # args
	JE	DBEG20			:no args--TP class is default
	SLLS	R3,4			:shift arg into speed bits position
	CLHI	R3,TPCLA		:can't be less than class A (0)
	JL	COMERR
	CLHI	R3,TPCLD		:nor more than class D (3)
	JG	COMERR
	LHL	R2,DLYFLG,R6
	NHI	R2,0FFFF-30		:clear the speed bits field
	AR	R3,R2			:add in the new speed bits
	STH	R3,DLYFLG,R6		:and write the new needle flags

DBEG20	LA	R2,PRFILL,,		:PROMPT FOR NUMBER OF FILL HWS
	JAL	R7,TYPASC
	JAL	R9,RDARGS
	SIS	R1,ASCCR		:MUST TERMINATE WITH CR
	JN	COMERR			:ELSE ABORT
	LR	R2,R2
	JEFS	DBEG23			:NO ARGUMENT,LEAVE FILL UNCHANGED
	SRLS	R3,1			:CONVERT BYTES TO HW
	CLHI    R3,100    		:DON'T LET THEM PICK TOO BIG A NUM
	JLEFS   DBEG24
	LHI     R3,100    		:512 BYTES OF FILL IS BIG ENOUGH
DBEG24	STH	R3,DLYFIL,R6
DBEG23	LA	R2,PRTINT,,
	LH	R0,XLUPFL		:IS THIS SPECIAL LOOPBACK CRQ?
	JL	DBEG25			:YES, LEAVE TIME INTERVAL ALONE
	JAL	R7,TYPASC		:PROMPT FOR TIME INTERVAL
	JAL 	R9,RDARGS		:AND READ IN THE VALUE
	SIS	R1,ASCCR
	JN	COMERR			:MUST TERMINATE ON CR
	LR	R2,R2			:CHECK FOR ZERO ARGUMENTS
	JEFS	DBEG25			:YES,LEAVE TIME INTERVAL UNCHANGED
	CLHI	R3,7			:KEEP JUST LOWER 3 BITS
	JGE     COMERR    		:only values 0-6
	lhi     r0,3f
	SRL     R0,0,R3
	STH	R0,DLYINT,r14,r14	:STORE AWAY RATE
DBEG25	LA	R2,PRNODE,,		:PROMPT FOR NODES
	JAL	R7,TYPASC
	lhi     r1,$a4*16 		:max arg count
	sth     r1,ARGMAX,xd
	JAL	R9,RDARGS		:READ IN UP TO 8 NODES
	CLHI	R1,ASCR			:ENDED IN 'R' (x52)?
	JN	DBEG30			:NO...
	LHI	R2,$A12			:YES, INITIALIZE INDEX       ###SHM
	JAL	R9,OCTHXR		:CONVERT LAST NODE(R3) TO HEX###SHM
	LHI	R4,MACHNM		:GET OUR NODE NUMBER IN HEX  ###SHM
DBEG28	STH	R3,NODLST,R2,R6		:STORE DESIRED NODE          ###SHM
	STH	R4,NODLST+2,R2,R6	:STORE OUR NODE              ###SHM
	SIS	R2,4			:DECREMENT NODE COUNT        ###SHM
	JGEBS	DBEG28			:DONE?                       ###SHM
	LHI	R2,$A16			:LOAD 2 X NUMBER OF NODES    ###SHM
	STH	R2,NODCNT,R6		:STORE IN NODCNT             ###SHM
	JAL	R7,TYPCRL		:ECHO CRLF                   ###SHM
	J	DBEG35			:GO PROCESS NODLST           ###SHM
DBEG30	JAL	R7,TYPCRL		:ECHO CRLF
	LHL	R2,ARGCT,XD		:4 x NUMBER OF NODES IN ONE-WAY PATH
	SRLS	R2,1			:MAKE IT TWICE # OF NODES
	JE	DBEG35			:NO ARGS, LEAVE NODE LIST UNCHANGED

	STH	R2,NODCNT,R6		:STORE IN NODE COUNT FIELD
	LIS	R4,0			:INITIALIZE OFFSET              ###SHM
DBEGI4	L	R3,VALUE1,R4,XD		:LOAD FW NODE NUMBER            ###SHM
	JAL	R9,OCTHXR		:CONVERT TO HEX		        ###SHM
	SRLS	R4,1			:CONVERT TO HW INDEX            ###SHM
	STH	R3,NODLST,R4,R6		:STORE HEX NODE NUMBER IN NODLST###SHM
	AR	R4,R4			:BACK TO FW INDEX               ###SHM
	AIS     R4,4			:INCREMENT INDEX                ###SHM
	SIS	R2,2			:DECREMENT NODE COUNT           ###SHM
	JGBS	DBEGI4			:MORE?                          ###SHM
DBEG35	LIS	R4,1
	STH	R4,DLSTAT,R6		:MARK NEW STATUS : NEEDLE REQUESTED
	LIS	R0,0
	STH	R0,DLYPTF,R6		:ZERO THE FILL POINTER
	STH	R0,DLYAV1,R6
	STH	R0,DLYAV2,R6
	LHI	R2,20			:CLEAR SAMPLE AREA SO AS NOT TO
	LI	R1,DLYTBL,R6		:NOT TO CONFUSE POOR USER IN THE
	JAL	R8,HCLEAR,,		:EARLY GOING.
	SBT	R14,INTUSE		:MARK THE CHANNEL IN USE
	rbt     r14,intxrf		:fix potential crash
	LHI	CHN,INTZFL,R14		:PASS ABSOLUTE CHANNEL NUMBER TO MAKNDL

:       if XDDT then prevent XDDT/background potential bufferpool corruption
:       by storing address of troublesome subroutine

	CLI     XD,TTYXD  		:tty user?
	JN      DBEG40    		:nope
	LA      R8,DBEG45 		:
	ST      R8,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT 		:wait until BG finishes task
	J       XPRMPT
DBEG40  JAL     R8,DBEG47 		:just call subroutine
	J       XPRMPT    		:and done
:       here for background doing a task for XDDT
DBEG45  ST      R8,XDDTSV+4*R8  	:so overwrite link reg with link reg
	LM      R0,XDDTSV 		:get back registers

:       only background can run this area of code.
DBEG47  ST      R8,DBEGS1 		:save link register
	JAL	R10,MAKNDL,,		:GO MAKE THE NEEDLE
	LH	R0,XLUPFL		:IS THIS A LOOPBACK CRQ?
	JL	DBEG50			:YES

	LHI	R0,DLYREC-SEG1.2	:GET DISPATCH ADDRESS FOR THIS CHN#wjl
	STH	R0,INTDSP,R14,R14	:AND STORE INTO INTHST DISPATCH ARRAY
	SBT	R14,INTDRF		:SET THE DELAY RECEIVER CRQ FLAG
	LHI	R1,ASCD			:WRITE FUNCTION BYTE AFTER NEEDLE
	JAL	R8,WCI,,		:...BUFFER # WAS SET UP IN MAKNDL
	LHL	R1,DLYFIL,R6		:ALSO GET #OF FILL HW
	JAL	R9,WCIE,,		:AND SEND AFTER NEEDLE
	EXBR	R1,R1			:move high order byte for WCI	###JHL
	JAL	R9,WCIE,,		:and send after needle		###JHL
	lhl     r1,dlyint,r14,r14
	jal     r9,wcie,, 		:and now send rate
:	CREATOR OF DLY MSMT CIRCUIT IS OWNER				###JHL
	LHL	R6,INTNDX,R14,R14	:READ DB-INDEX FROM ARRAY BY CHAN#
	AR	R6,R6			:DOUBLE FOR HW OFFSET
	ST	XD,DB0USE,R6,R6		:IDENTIFY CREATOR IN WORD ARRAY

	L       R8,DBEGS1 		:restore link reg
	JR      R8        		:now all done

DBEG50	LHI	R0,DLYERR-SEG1.2	:				###wjl
	STH	R0,INTDSP,R14,R14	:DISPATCH ADDRESS = BIT BUCKET
	SBT	R14,INTLPF		:MARK THIS CHANNEL AS LOOPBACK ONE
	LHI	R1,ASCL^8+ASCL		:function byte and fillchars = 'L'
	JAL	R8,WCI,,		:R2 WAS SET UP IN MAKNDL
	LHL	R10,DLYFIL,R6		:FILL NUMBER OF HW
DBEG55	JAL	R9,WHWI,,		:WRITE INTO BUFFER AFTER NEEDLE
	SIS	R10,1
	JGBS	DBEG55
	LIS	R0,0
	STH	R0,XLUPFL		:CLEAR FLAG
:	CREATOR OF DLY MSMT CIRCUIT IS OWNER				###JHL
	LHL	R6,INTNDX,R14,R14	:RECOVER DLY CHN INDEX
	AR	R6,R6			:DOUBLE TO HW OFFSET
	ST	XD,DB0USE,R6,R6		:IDENTIFY CREATOR IN WORD ARRAY

	L       R8,DBEGS1 		:restore link
	JR      R8        		:done with Background only area ###sdw

DBERR	LI	R2,DERMSG		:###TZ
	JAL	R7,TYPASC
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	DLDATA:	DD
::	FUNCTION:	DISPLAY DELAY MEASUREMENT STATISITCS
::
::*********************************************************************

DLDATA	HS	0
	SIS	R2,4			:1 ARG?
	JGEFS	DLDAT5			:YES
	LIS	R6,0			:DEFAULT ARG = 0.
	JFS	DLDAT6
DLDAT5	LR	R6,R3			:SAVE ARGUMENT
	JL	COMERR
	CLHI	R6,TINTCH/2		:CHECK SIZE
	JGE	COMERR			:TOO LARGE
DLDAT6	LR	R7,R6			:SAVE INDEX
	lr      r5,r6
	LHI	R6,DLYBSZ		:SIZE OF DLY DATA AREA
	MHR	R6,R7			:TIMES INDEX = OFFSET INTO TABLE AREA
	AI	R6,DLYBSE		:ADDRESS OF DATA BLOCK
	LA	R2,DLDMS0,,		:HEADER 0
	JAL	R7,TYPASC
	LA	R2,DLDMS1,,		:HEADER 1
	JAL	R7,TYPASC
	lh      r5,dlychn,r5,r5 	:get the chn
	LH	R1,DLYINT,r5,r5		:GET TIME INERVAL
	LHL	R10,DLYFIL,R6		:GET FILL
	JEFS	DLDAT4			:SKIP IF ZERO
	AIS	R10,1			:IF NON-ZERO, ADD IN CLOCK
DLDAT4	AIS	R10,1
	SLLS	R10,5			:MULT BY 32
	LIS	R0,0
	AIS	R1,1
	slls    r1,1
	Sth	R1,XDLTMP
	LHL	R3,XDLTMP
	slls    r3,6
	JAL	R9,TYPHWD
	LR	R2,R10
	DH	R2,XDLTMP
	JAL	R9,TYPHWD

	LIS	R5,0			:TYPE 4 HW
DLDLP3	LHL	R3,DLSTAT,R6,R5		:STAT, FLAG,HWF,PTR
	JAL	R9,TYPHW
	AIS	R5,2
	THI	R5,7			:DONE?
	JNBS	DLDLP3			:NO
	LHL	R2,DLYAV1,R6		:GET FIRST AVERAGE
	JAL	R9,FSTMSC		:CONVERT TO MS (IN R3)
	JAL	R9,TYPHWD		:DISPLAY IN DECIMAL
	LHL	R2,DLYAV2,R6		:SAME FOR SECOND AVERAGE
	JAL	R9,FSTMSC
	JAL	R9,TYPHWD
	JAL	R7,TYPCRL		:CR-LF
	LA	R2,DLDMS2,,
	JAL	R7,TYPASC		:SECOND HEADER
	LHL	R5,NODCNT,R6		:NUMBER OF NODES
	LR	R10,R6
DLDAT3	LHL	R3,NODLST,R10		:NEXT NODE
	AIS	R10,2
	SIS	R5,2			:DECREMENT
	JLFS	DLDAT2			:ALL DONE
	JAL	R9,HEXOCT		:CONVERT TO OCT
	JAL	R9,TYP5CH		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
	JBS	DLDAT3
DLDAT2	LA	R2,DLDMS3,,		:THIRD HEADER
	JAL	R7,TYPASC
:	CONVERT TO MS AND TYP DECIMAL 32 SAMPLES, 8 AT A TIME
	LIS	R11,0			:TO COUNT NO. HW'S TYPED
	JFS	DLDLP2
DLDLP1	JAL	R7,TYPCRL
DLDLP2	LHL	R2,DLYTBL,R6,R11	:GET A SAMPLE VALUE (FASTC)
	JAL	R9,FSTMSC		:CONVERT TO MS (R3)
	JAL	R9,TYPHWD		:DISPLAY
	AIS	R11,2			:POINT TO NEXT HW
	THI	R11,3F			:DONE 64 BYTES (32 HW)?
	JEFS	DLDDON			:ALL DONE
	THI	R11,0F			:DONE 16 BYTES (8 HW) = 1 LINE?
	JE	DLDLP1			:YES, DO NEXT LINE
	J	DLDLP2			:NO, DO NEXT HW
DLDDON	JAL	R7,TYPCRL
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	DLYEND:	DE
::	FUNCTION:	TERMINATE DELAY MEASUREMENT OPERATION ON A CHANNEL
::
::*********************************************************************

:	THE CRQ IS ZAPPED IN THE DIRECTION THAT THE NEEDLE ORIGINALLY TOOK

DLYEND	HS	0
	LHL	R2,ARGCT,XD		:IF NO ARG'S, INDEX = 0.
	JGFS	DLYENA			:AT LEAST 1 ARG.
	C	XD,DB0USE		:DID THIS USER SET IT UP?
	JN	COMERR			:NO, CAN'T END IT.
	LIS	R6,0			:DEFAULT INDEX = 0
	JFS	DLYENB
DLYENA	LHL	R6,VALUE1+2,XD
	LH	R4,XPOWER,XD		:				###TZ
	JG	XPWER1			:SECURITY VIOLATION		###TZ
DLYEN2	CLHI	R6,TINTCH/2
	JGE	COMERR			:TOO BIG
DLYENB	HS	0
:	CREATOR OF DLY MSMT CIRCUIT IS THE OWNER			###JHL
	AR	R6,R6			:BYTE INDEX TO HW INDEX
	C	XD,DB0USE,R6,R6		:INDX TO FW TBL--WHO OWNS THIS CHAN
	JN	COMERR			:ONLY THE CREATOR CAN ZAP IT
	SRLS	R6,1			:BACK TO BYTE INDEX

	LR	R5,R6			:SET UP TO GET DELAY CIRCUIT STATUS
	LHI	R6,DLYBSZ		:SIZE OF DELAY DATA AREA
	MHR	R6,R5			:R6=OFFSET INTO TABLE AREA
	AI	R6,DLYBSE		:R6=POINTS TO DATA AREA FOR THIS INDEX
	LH	R4,DLSTAT,R6		:CIRCUIT UP (STAT = 1)?
	JLE	COMERR			:NO
	LH	R5,DLYCHN,R5,R5		:INT HST CHANNEL INDEX
	TBT	R5,INTDRF		:MAKE SURE THIS CHN IS BEING USED
	JNFS	DLYEN9			:OK
	TBT	R5,INTLPF		:NOT DELAY MEASRMENT, PERHAPS LOOPBACK
	JE	COMERR			:NO, NOTHING THERE
DLYEN9	LR	R4,R5			:PUT INT HST CHAN INDEX IN R4
	AHI	R5,INTZFL		:ABSOLUTE CH # IN R5
	LHL	R2,IOTAB,R5,R5		:AND THE OUTGOING BUFFER IN R2
	JE	COMERR			:NOTHING THERE, ALREADY BEEN ZAPPED

	CLI     XD,TTYXD  		:tty user?
	JN      DLYEN4    		:nope
	LA      R8,DLYEN7 		:
	ST      R8,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT 		:wait until BG finishes task
	J       XPRMPT
DLYEN4  JAL     R8,DLYEN8 		:just call subroutine
	J       XPRMPT    		:and done

DLYEN7  ST      R8,XDDTSV+4*R8  	:save link so get it back when LM
	LM      R0,XDDTSV 		:get back XDDT's regs
DLYEN8  ST      R8,DLYES1 		:store link register
	NHI	R2,-4			:STRIP SIGN BITS--SWITCH TO INCOMING
	XHI	R2,4			:BUFFER (INTZAP WILL SWITCH BACK)
	JAL	R10,INTZAP,,		:ZAP THE INT HOST CRQ
	LCS	R0,2
	STH	R0,DLSTAT,R6		:NOTE WE'VE DONE THE ZAP
	L       R8,DLYES1 		:get back link register
	JR      R8        		:and return

	EI	:(XRSZLV-1)		:##AL

	SUBTTL	XRAY (Echo mode - RE, LE)

	IF	(XRSZLV-2)		:##AL

::*********************************************************************
::
::	COMMAND:	XRECHO:	RE
::	FUNCTION:	SET DEFERRED OR REMOTE ECHO MODE (XRAY ECHOS)
::
::*********************************************************************

XRECHO	HS	0
	LIS	R0,0
	STH	R0,EKOTYP,XD
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	XLECHO:	LE
::	FUNCTION:	SET LOCAL ECHO MODE ( USER IS DOING ECHOING)
::
::*********************************************************************

XLECHO	HS	0
	TS	EKOTYP,XD
	J	XPRMPT

	SUBTTL	XRAY (Set, remove and display traps - ST, RT, DT)


::	ISIS traps rewritten with an added capability of definable
::	(NTRAP) number of setable traps.
:: NOTE:  ISIS traps require 3 halfwords to be overwritten at the
::        patch location as compared to the solo's 2 halfwords and the
::        current condition codes are trashed. (ie don't trap a JE or JN
::        instruction and make sure that no one jumps to any of the three
::        halfwords after the trap). Also, no check is made to
::        make sure a valid instruction is being trapped.  ###sdw
::        Also, ISIS traps must remove write protection because they
::        cannot know whether the trapped routine had write protection.
::        (write protection has to be removed in order to restore the
::        instruction).   ###sdw

::*********************************************************************
::
::	COMMAND:	SETTRP:	ST (ISIS)
::	FUNCTION:	SETS A TRAP AT A PARTICULAR LOCATION
::
::*********************************************************************

SETTRP	HS	0
	CLHI    R2,0C     		:MAX OF 3 ARGS
	JG	COMERR			:TOO BIG
	CLHI    R2,8      		:test for 2 args
	JL	COMERR			:must give trap number
	JGFS    SETTR1    		:if only 2 then give count of 0
	LIS     R1,0      		:repeat count will be 0
	ST      R1,VALUE1+8,XD  	:by acting as if 0 was typed
SETTR1  L       R1,VALUE1,XD    	:get address to trap
	TI      R1,10000  		:only trap seg 1?
	JE      COMERR    		:could trap some of seg D?
	LHI     R3,4*(NTRAP-1)  	:word index to trap addresses
SETTR2  C       R1,TRPADR,R3,   	:address already trapped?
	JE      COMERR
	SIS     R3,4      		:check all traps
	JGEBS   SETTR2
	L       R2,VALUE1+4,XD  	:trap number
	CLHI    R2,NTRAP  		:less than the maximum number of traps
	JGE     COMERR    		:(NTRAP=2 then traps numbers are 0 1)
	SLLS    R2,2      		:trap number as a FW index
	L       R3,TRPSAV,R2,R2 	:where we save the overwritten ininstr
	JN      COMERR    		:instruction already there so error
	L       R0,0,R1   		:get instr to trap on
	ST      R1,TRPADR,R2,   	:save location of trap
	ST      R0,TRPSAV,R2,R2 	:TRPSAV is 2 words
	LHL     R0,4,R1   		:get the 3rd halfword
	STH     R0,TRPSAV+4,R2,R2       :save the instruction
	LHI     R0,4300   		:the J instruction
	STH     R0,0,R1
	L       R0,TRPINX,R2    	:where the jump should jump
	AI      R0,40000000     	:the RX3 bit
	ST      R0,2,R1   		:put where the jump (trap) handler is
	L       R0,VALUE1+8,XD  	:what was the count?
	NHI     R0,7FFF   		:max trap count
	SRLS    R2,1      		:R2 is back to HW index
	STH     R0,TRPCNT,R2,
	ST      XD,TRPXD,R2,R2  	:store the xray user for this trap
	J       XRCRLF    		:done with this

::*********************************************************************
::
::	COMMAND:	REMTRP:	RT (ISIS)
::	FUNCTION:	REMOVES THE TRAP
::
::*********************************************************************

REMTRP	HS	0
	CLHI    R2,4      		:must have at least one arg
	JL      COMERR
	SIS     R2,4      		:index into values
REMTR1  L       R1,VALUE1,XD,R2 	:trap number to remove
	JL      COMERR
	CLHI    R1,NTRAP  		:make sure a valid trap number
	JGE     COMERR
	JAL     R4,REMTR3 		:subroutine which removes traps
	SIS     R2,4      		:next value
	JGE     REMTR1
	J       XRCRLF    		:done with the XRAY RT command

:  REMTR0 is entry from xray zap logic (on R9) to clear all traps for this
:  zapped user.

REMTR0  LHI     R1,NTRAP-1		:remove all traps
REMTR9  JAL     R4,REMTR3 		:try to remove this trap
	SIS     R1,1
	JGEBS   REMTR9
	JR      R9

: REMTR3 removes the trap in R1 if the trap belongs to the user (XD).
:routine also must not destroy R2 or R9 and links on R4.

REMTR3  LR      R5,R1
	SLLS    R5,2      		:make R5 a fullword index
	C       XD,TRPXD,R5,    	:trap belong to this user?
	JNR     R4        		:cannot remove someone elses trap
	L       R3,TRPADR,R5,,  	:address of trap
	JLER    R4        		:this trap was not in use
	L       R0,TRPSAV,R5,R5 	:restore the instruction
	ST      R0,0,R3
	LHL     R0,TRPSAV+4,R5,R5       :last halfword of instruciton
	STH     R0,4,R3
	LIS     R0,0      		:clean out the trap
	ST      R0,TRPADR,R5,   	:no address of a trap
	ST      R0,TRPSAV,R5,R5 	:no instruction is saved
	                  		:leave other info in case of bug
	JR      R4        		:trap removed


::*********************************************************************
::
::	ROUTINE:	TRAPIS:	(ISIS)
::	FUNCTION:	WHERE THE TRAP IS SPRUNG
::
::*********************************************************************

Q       EQ      0
	RE      NTRAP
TRPI|Q| STM     R0,TRPREG+40*Q,,
	LHI     R0,Q
	J       TRAPIS
Q       EQ      Q+1
	ER

TRPINX  WS      0       :table for each trap number
Q       EQ      0
	RE      NTRAP
	WC      TRPI|Q|
Q       EQ      Q+1
	ER

TRAPIS	HS	0
	SBT     R0,TRPFLG,,
	LR      R12,R0  	:let R12 keep track of trap number
	LR      R13,R12 	:R13 is going to be 4*trap
	SLLS    R13,2
	L       R0,FASTC,,
	ST      R0,TRPTIM,R13,  :save time of trap spring
	LHI     R0,1F-PXRAY     :sched xray to display trap
	SBT     R0,SQUEUE
	L       R1,TRPXD,R13,   :and schedule the xray owner of trap
	LHL     R1,XUSLTN,R1    :the xray user number
	SBT     R1,XQUEM	:sched the user that gets trap info
	JAL     R11,XWRITE      :remove write protection
	L       R1,TRPADR,R13,  :get the address of the trap
	L       R0,TRPSAV,R13,R13 :get 1st 4 bytes of instruction
	ST      R0,0,R1 	:restore it
	LHL     R0,TRPSAV+4,R13,R13 :get last two bytes of instruction
	STH     R0,4,R1 	:restore it
	ST      R1,TRPPSW+4,,   :save where we are to return to
	SLLS    R13,4   	:get displacement into saved regs
	LM      R0,TRPREG,R13,  :restore regs
	UPSW    TRPPSW,,	:return to the instruction

::*********************************************************************
::
::	ROUTINE:	TRPDOR:	(ISIS)
::	FUNCTION:	DISPLAYS THE TRAP
::
::*********************************************************************

TRPDOR  HS      0
	JFFOH   R4,TRPDO1 		:R4 is TRPFLG which is which trap
	J       COMERR    		:can never get here but just in case
TRPDO1
	SLLS    R5,1      		:is HW index for trap
	C       XD,TRPXD,R5,R5  	:check if trap belongs to this user
	JN      XLOOP0    		:nope but handle this screwup too
	LA	R2,ASCTRP,,     	:the TRAP message
	JAL	R7,TYPASC		:HEADER
	LR      R3,R5     		:get 2*trap number
	SRLS    R3,1      		:make it trap number
	RBT     R3,TRPFLG,,     	:no longer dis trap have output pending
	JAL     R9,TYPHW  		:output trap number
	L       R3,TRPADR,R5,R5 	:output trap address
	JAL     R9,TYPFW
	L       R3,TRPTIM,R5,R5 	:output time it sprung
	JAL     R9,TYPFW
	LHL     R3,TRPCNT,R5,   	:count of springs left
	JAL     R9,TYPHW  		:tell them how many left
	LR      R6,R5                   
	SLLS    R6,5      		:make 40 byte index
	LIS     R11,2     		:two lines of 8 FWs
TRPDO4  LIS     R10,8     		:the 8 FWs
	JAL     R7,TYPCRL
TRPDO5  L       R3,TRPREG,R6,   	:get a FW
	JAL     R9,TYPFW
	AIS     R6,4      		:move up the pointer
	SIS     R10,1
	JGBS    TRPDO5    		:still within line
	SIS     R11,1     		:how many lines
	JG      TRPDO4
	LHL     R0,TRPCNT,R5,   	:how many times to reset trap
	JG      TRPDO6    		:go if must reset trap
	LIS     R0,0
	ST      R0,TRPADR,R5,R5 	:no more trap address
	SLLS    R5,1
	ST      R0,TRPSAV,R5,R5 	:no more saved instruction
	J       XRCRLF    		:finished with trap

TRPDO6  SIS     R0,1
	STH     R0,TRPCNT,R5,   	:reduce count by one
	L       R1,TRPADR,R5,R5 	:get address of instruction
	LHI     R2,4300   		:get back trap
	STH     R2,0,R1   		:restore instruction
	L       R2,TRPINX,R5,R5 	:last 2 bytes of instr
	AI      R2,40000000
	ST      R2,2,R1
	JAL	R7,TYPCRL
	J       XRCRLF

::*********************************************************************
::
::	COMMAND:	DISTRP:	DT (ISIS)
::	FUNCTION:	DISPLAY CURRENT TRAP LOCATION
::
::*********************************************************************

DISTRP	HS	0
	LHI     R12,2*(NTRAP-1) 	:all traps
DISTR1  L       R11,TRPADR,R12,R12      :address of trap
	JE      DISTR2    		:not in use so skip
	LR      R3,R12    		:get trap number
	SRLS    R3,1      		:make back to real number
	JAL     R9,TYPHW
	LR      R3,R11    		:get back trap address
	JAL     R9,TYPFW
	LHL     R3,TRPCNT,R12,  	:number of times it will be reset
	JAL     R9,TYPHW
	JAL     R7,TYPCRL 		:finish the line
DISTR2  SIS     R12,2     		:decrement the count
	JGE     DISTR1
	J       XRCRLF


	SUBTTL	XRAY (Debugging aids - SC, SB, RC)

::*********************************************************************
::
::	COMMAND:	SETCRS:	SC
::	FUNCTION:	SETS A J OOPS AT GIVEN LOCATION
::
::*********************************************************************

SETCRS	HS	0
	CLHI	R2,4			:EXACTLY 1 ARG
	JN	COMERR			:NO
	L	R1,XCRADD,,		:MAKE SURE WE MAY
	JG	COMERR			:NO, A CRASH  OR BP IS THERE ALREADY
	L	R1,0,R3			:R3 is the address of the crash to be
	ST	R1,XCRSAV,,		:save the d10 bytes for restoration
	LHL	R1,4,R3
	STH	R1,XCRSAV+4,,
	L	R1,6,R3
	ST	R1,XCRSAV+6,,
	ST	R3,XCRADD,,
	LHI	R1,4100			:store JAL OOPS, .XRSCH and 0408
	STH	R1,0,R3
	LI	R1,40000000+OOPS
	ST	R1,2,R3
	LI	R1,.XSCRH^10+0408	:crash code and R1, R2		###JHL
	ST	R1,6,R3
	J	XPRMPT			:AND RETURN

::*********************************************************************
::
::	COMMAND:	SETBP:	SB
::	FUNCTION:	SET A BREAKPOINT (ILL INST) AT GIVEN LOCATION
::
::*********************************************************************

SETBP	HS	0
	CLHI	R2,4			:EXACTLY ONE ARG?
	JN	COMERR			:NO
	L	R1,XCRADD,,		:MAKE SURE WE MAY
	JG	COMERR			:NO, A CRASH  OR BP IS THERE ALREADY
	L	R1,0,R3			:SAVE CONTENTS
	ST	R1,XCRSAV,,
	ST	R3,XCRADD,,		:SAVE CRASH ADDRESS
	LIS	R1,0			:ILL INST
	ST	R1,0,R3
	J	XPRMPT

::*********************************************************************
::
::	COMMAND:	REMCRS:	RC
::	FUNCTION:	REMOVES THE CRASH OR BREAKPOINT
::
::*********************************************************************

REMCRS	HS	0
	L	R1,XCRADD,,		:ADDRESS
	JLE	COMERR			:NO CRASH SET
	L	R0,XCRSAV,,		:COMMAND
	ST	R0,0,R1			:RESTORE IT
	LHL	R0,XCRSAV+4,,
	STH	R0,4,R1
	L	R0,XCRSAV+6,,
	ST	R0,6,R1
	LCS	R0,1
	ST	R0,XCRADD,,		:NOTE THERE IS NO CRASH SET
	J	XPRMPT			:AND RETURN

	SUBTTL	XRAY (Miscellaneous - XG,GP,NR,RB,WB,BZ,BG,NI)

::*********************************************************************
::
::	COMMAND:	XGGMOD:	XG
::	FUNCTION:	DISPLAY, MODIFY, ADD OR DELETE XRAY GOODGUY ENTRIES
::	INPUT:		GG =DISPLAY,  GG A =ADD, GG # M =MODIFY, GG # D =DELETE
::
::*********************************************************************

	NOLIST
XGGDS1	SC	/"0D"0AXRAY GOODGUY LIST"0D"0A/
XGGDS2	SC	/"0D"0ANO.   PRIV  OVER         TARGET               NAME/
XGGDS3	SC	/"0D"0A----  ----  ----  ------------------------  -----------  "0D"0A/
XGGDS4	SC	/"0D"0A"0AENTER NEW PRIVILEGE AND OVERRIDE - /
XGGDS5	SC	/"0D"0AENTER UP TO 12(D) CHARS OF USERNAME"0D"0A/
XGGDS6	SC	/"0D"0AXRAY GOODGUY LIST ALREADY FULL"0D"0A/
XGGDS7	SC	/"0D"0A"0AENTER NEW TARGET - /
XGGDS8  SC      /(XRAY)              /
XGGDS9  SC      /(Net Console XRAY)  /
XGGDSA  SC      /(DLine Engin Load)  /
XGGDSB  SC      /(DLine T-Eng Load)  /
XGGDSC  SC      /(ALFRED Debugger)   /
	LIST
XGGDST  WC      XGGDS8,XGGDS9,XGGDSA,XGGDSB :target value to targ name  ###sdw

XGGMOD	HS	0
	LR	R2,R2			:ZERO ARGS?
	JE	XGGM01			:YES
	SIS	R2,4			:ONE ARG?
	JG	COMERR			:NO, TOO MANY
	LH	R13,XPOWER,XD		:IS USER EMPOWERED?
	JGE	XPWER1			:NO, TELL HER SO
	LR	R3,R3			:ENTRY NUMBER = 0?
	JE	COMERR			:YES, NOT VALID
	CLHI	R3,XGGLEN/XGGSIZ	:WITHIN GGLIST TABLE RANGE?	###wjl
	JG	COMERR			:NO 
	LHI	R0,XGGSIZ		:GET GGLIST CELL SIZE
	SIS	R3,1			:MAKE ENTRIES BEGIN AT 1
	MR	R2,R0			:FORM GGLIST INDEX (R2 HAS 0 ALREADY)
	CLHI	R1,ASCP			:USER CLOSE WITH "P" (x50)
	JE	XGGDEL			:YES, DELETE ENTRY
	CLHI	R1,ASCM			:USER CLOSE WITH "M" (x4D)
	JE	XGGMDD			:YES, MODIFY ENTRY
	J	COMERR			:NOT CLOSED WITH D OR M
XGGM01	CLHI	R1,ASCI			:USER CLOSE WITH "I" (x49)
	JE	XGGADD			:YES, ADD ENTRY

XGGDSP	LA	R2,XGGDS1		:TYPE OUT DISPLAY HEADER
	JAL	R7,TYPASC
	LA	R2,XGGDS2
	JAL	R7,TYPASC
	LA	R2,XGGDS3
	JAL	R7,TYPASC
	LIS	R11,0			:INIT GGLIST INDEX
XGGDP1	LB	R3,XRAYGG+XGGNAM,R11,	:CHECK FOR ANY ENTRY HERE	###wjl
	JE	XGGDP2			:NO ENTRY, TRY NEXT GGLIST INDEX

	LIS	R2,0
	LR	R3,R11			:COMPUTE ENTRY NUMBER FROM GGLIST INDEX
	LHI	R0,XGGSIZ		:BY DIVIDING BY GGLIST CELL SIZE
	DR	R2,R0
	AIS	R3,1
	JAL	R9,TYPHW

	LB	R3,XRAYGG+XGGPRV,R11,	:GET USERS PRIVILEGE CAPABILITY	###wjl
	JAL	R9,TYPHW		:DISPLAY FOLLOWED BY 2 SPACES
	LB	R3,XRAYGG+XGGOVR,R11,	:GET USERS OVERRIDE CAPABLILTY	###wjl
	JAL	R9,TYPHW		:AND DISPLAY

	L	R3,XRAYGG+XGGTARG,R11,	:get user's target address	###wjl
	JGEFS   XGGM03    		:alfred debugger is not inthst  ###sdw
	LIS     R3,4      		:target value
	J       XGGM08    		:display value                  ###sdw
XGGM03	CLI	R3,INTXRY		:xray??				###wjl
	JNFS	XGGM02			:no				###wjl
	LIS	R3,0			:yes				###wjl
	JFS	XGGM08			:				###wjl
XGGM02	CLI	R3,INTIIX		:iixray??			###wjl
	JNFS	XGGM04			:no				###wjl
	LIS	R3,1			:yes				###wjl
	JFS	XGGM08			:				###wjl
XGGM04	CLI	R3,INTDWL		:dload??			###wjl
	JNFS	XGGM06			:no				###wjl
	LIS	R3,2			:yes				###wjl
	JFS	XGGM08			:				###wjl
XGGM06	LIS	R3,3			:assume sload...		###wjl
XGGM08  LR      R10,R3    		:save value                     ###sdw
	JAL	R9,TYPHW		:display TARGet			###wjl
	SLLS    R10,2     		:get index for name of target   ###sdw
	L       R2,XGGDST,R10   	:get name of target             ###sdw
	JAL     R7,TYPASC 		:                               ###sdw

	LA	R2,XRAYGG+XGGNAM-1,R11,	:DISPLAY USERNAME		###wjl
	LIS	R0,0C			:12(D) CHARACTERS
	JAL	R7,TYPAS1
	JAL	R7,TYPCRL		:CR/LF AND CHECK NEXT GGLIST ENTRY
XGGDP2	AHI	R11,XGGSIZ		:BUMP GGLIST INDEX
	CLHI	R11,XGGLEN		:DONE?				###wjl
	JL	XGGDP1			:NO, DISPLAY SOME MORE ENTRIES
	J	XPRMPT			:YES, EXIT

XGGDEL	LIS	R0,0			:CLEAR OUT
	STH	R0,XRAYGG+XGGPRV,R3,	:BYTE OF PRIV, BYTE OF OVERRIDE	###wjl
	ST	R0,XRAYGG+XGGTARG,R3,	:fw target address		###wjl
	ST	R0,XRAYGG+XGGNAM,R3,	:3 FW OF USERNAME		###wjl
	ST	R0,XRAYGG+XGGNAM+4,R3,	:IN				###wjl
	ST	R0,XRAYGG+XGGNAM+8,R3,	:XRAY GOODGUY LIST		###wjl
	J	XPRMPT			:AND EXIT

XGGMDD	LR	R14,R3			:SAVE GGLIST INDEX
	LA	R2,XGGDS4		:PROMPT FOR PRIV, OVERRIDE
	JAL	R7,TYPASC
	JAL	R9,RDARGS		:GET PRIV, OVERRIDE
	LR	R2,R2			:ANY ARGS?
	JE	COMERR			:NO, ERROR
	CLHI	R2,8			:TWO ARGS?
	JN	COMERR			:NO
	STB	R3,XRAYGG+XGGOVR,R14,	:REPLACE OVERRIDE CAPABILITY	###wjl
	LH	R3,VALUE1+2,XD		:GET FIRST ARGUMENT (PRIV)
	JGEFS	XGGMD8
	LIS	R3,0			:LOW LIMIT TO 0
XGGMD8	CLHI	R3,0002			:HIGH LIMIT TO 2
	JLEFS	XGGMD7
	LIS	R3,2
XGGMD7	STB	R3,XRAYGG+XGGPRV,R14,	:REPLACE PRIVILEGE CAPABILITY	###wjl

	LA	R2,XGGDS7		:prompt for target		###wjl
	JAL	R7,TYPASC		:				###wjl
	JAL	R9,RDARGS		:get target			###wjl
	LR	R2,R2			:any args?			###wjl
	JE	XGGM10			:no, error, default xray address###wjl
	CLHI	R2,4			:one arg?			###wjl
	JN	XGGM10			:no, error, default xray address###wjl
	CLHI	R3,0			:xray?				###wjl
	JNFS	XGGM12			:no				###wjl
XGGM10	LA	R3,INTXRY,,		:yes				###wjl
	J	XGGM18			:				###wjl
XGGM12	CLHI	R3,1			:iixray?			###wjl
	JNFS	XGGM14			:no				###wjl
	LA	R3,INTIIX,,		:yes				###wjl
	J	XGGM18			:				###wjl
XGGM14	CLHI	R3,2			:dload?				###wjl
	JNFS	XGGM16			:no				###wjl
	LA	R3,INTDWL,,		:yes				###wjl
	J	XGGM18			:				###wjl
XGGM16	CLHI	R3,3			:sload?				###wjl
	JNFS	XGGM17			:no				###wjl
	LA	R3,INTSKY,,		:yes				###wjl
	JFS     XGGM18
XGGM17  CLHI    R3,4      		:turbo debugger?                ###sdw
	JN      XGGM10    		:otherwise give em XRAY         ###sdw
	LCS     R3,1      		:give them debugger             ###sdw
XGGM18	ST	R3,XRAYGG+XGGTARG,R14,	:replace target address		###wjl

	J	XPRMPT			:EXIT

XGGADD	LH	R13,XPOWER,XD		:IS USER EMPOWERED?
	JGE	XPWER1			:NO, TELL HER SO
	LIS	R11,0			:INIT XRAY GGLIST INDEX
XGGAD1	LB	R3,XRAYGG+XGGNAM,R11,	:CHECK FOR NULL IN BYTE 1 OF UNAME#wjl
	JEFS	XGGAD2			:NULL ENTRY FOUND
	AHI	R11,XGGSIZ		:BUMP GGLIST INDEX
	CLHI	R11,XGGLEN		:END OF GGLIST			###wjl
	JLBS	XGGAD1			:NO, KEEP LOOKING FOR EMPTY ENTRY
	LA	R2,XGGDS6		:INFORM HER OF NO GGLIST SPACE
	JAL	R7,TYPASC
	J	XPRMPT			:AND EXIT

XGGAD2	LA	R2,XGGDS5		:PROMPT FOR USERNAME
	JAL	R7,TYPASC
	LA      R0,INTXRY,,     	:no target will cause a crash and##sdw
	ST      R0,XRAYGG+XGGTAR,R11,   :user can abort XG before target stuff
	LIS	R14,0			:COUNT USERNAME CHARACTERS
XGGAD4	JAL	R13,XRYIN		:GET A CHARACTER OF INPUT
	NHI	R1,ASC7BT		:strip high order bit
	CLHI	R1,40			:blanks, numbers don't get masked
	JlEFS	XGGAD9			:non alpha char
	NHI	R1,ASCUC		:ENSURE UPPERCASE(x0DF)
XGGAD9	CLHI	R1,ASCCR		:CR (x0D)?
	JEFS	XGGAD3			:YES
	STB	R1,XRAYGG+XGGNAM,R11,R14	:STORE CHAR INTO GGLIST	###wjl
	AIS	R14,1			:BUMP CHAR COUNT
	CLHI	R14,0C			:UP TO 12(D) YET?
	JL	XGGAD4			:NO, GET NEXT CHARACTER
XGGAD3	LR	R3,R11			:GET GGLIST INDEX FOR XGGMDD
	J	XGGMDD			:AND GET PRIV AND OVERRIDE

	EI	:(XRSZLV-2)		:##AL

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	GETPWR:	GP
::	FUNCTION:	GET POWER
::
::*********************************************************************

GETPWR	HS	0
	LHL	R10,EKOTYP,XD
	LCS	R0,1
	STH	R0,EKOTYP,XD
	JAL	R9,RDARGS
	STH	R10,EKOTYP,XD
	SIS	R2,8			:2 ARGUMENTS
	JN	COMERR
	c       r3,hst0.p 		:have a match
	jn      comerr
	LHL	R0,VALUE1+2,XD
	NHI	R0,1
	JN	GETPW0			:###TZ

	CI	XD,TTYXD		:TTY?
	JEFS	GETPW2			:YES, MAKE SUPER PRIVELEGED
	LHL	R9,XUNAME,XD		:GET USER'S INDEX INTO XRAY GGLIST
	LB	R0,XRAYGG+XGGPRV,R9,	:AND GET USER'S PRIVILEGE CAPABILITY
	JE	COMERR			:NOT PRIV, THIS COMMAND NOT ALLOWED
	SIS	R0,1			:IS CAPABILITY 1?
	JEFS	GETPW3			:YES, MAKE NORMAL PRIV

GETPW2	LCS	R0,1			:FLAG SUPER PRIVELEGED
	JFS	GETPW0
GETPW3	LIS	R0,0			:FLAG NORMAL PRIVILEGE

GETPW0	HS	0			:###TZ
	STH	R0,XUINTH+2,XD
	CI	XD,TTYXD		:TTY?
	JN	XPRMPT,,		:NO
	LCS	R0,1			:TEMP KLUDGE. LET TTY PORT HAVE SUPER-P
	STH	R0,XUINTH+2,XD		:###TZ
	DEFAULT(TTYLAB,0)		:###wjl
	IF	TTYLAB			:###wjl
	LHI	R0,$A6000		:give LAB user a break at the TTY port
	ELSE	:NOT TTYLAB
	LHI	R0,$A60			:2 MINUTES MAX
	EI	:TTYLAB
	STH	R0,XPWRCT,,
	J	XPRMPT,,

hst0.p  bc      0         		:save it in decimal form
	ra      0a
q1      eq      10000
q2      eq      hst0
	re      3
q3      eq      (q2/(q1*10))
q2      eq      q2-(q3*q1*10)
q4      eq      (q2/q1)
q2      eq      q2-(q4*q1)
q1      eq      q1/100
	bc      q3^4+q4
	er
	ra      0
	hs      0

	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL

::*********************************************************************
::
::	COMMAND:	XRDBUF:	RB
::	FUNCTION:	READS THE CONTENTS OF A BUFFER
::
::*********************************************************************

XRDBUF	HS	0
	LR	R2,R3			:LAST ARG IS BUFFER NUMBER
	JL      COMERR,,  		:ILLEGAL
	NHI	R2,-4			:STRIP SPPEED BITS IN CASE
	ci      r2,lbufn
	jg      comerr
	JAL	R8,CBCCT,,		:CHAR COUNT
	LR	R1,R1
	JE	XPRMPT,,		:BUFFER EMPTY
	LR	R10,R1			:SAVE COUNT
	LIS	R11,0F			:CHAR COUNT ON LINE
	JAL	R8,PCIS,,		:START THINGS OFF
XRDBU1	LR	R12,R2			:SAVE BUFFER NUMBER
	LR	R14,R3			:AND POINTER
	LR	R3,R1
	JAL	R9,TYPBYT
	SIS	R10,1
	JE	XRDBF4			:char count depleted--wrap it up
	SIS	R11,1
	JGEFS	XRDBF2			:zero means end of line--crlf
	JAL	R7,TYPCRL
	LIS	R11,0F
XRDBF2	LR	R2,R12			:restore buffer number
	LR	R3,R14			:restore peek pointer
	JAL	R8,PCI,,
	J	XRDBU1
XRDBF4  HS      0
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XWRBUF:	WB
::	FUNCTION:	Write ASCII into buffer
::	FORMAT:		WB <buff#> <data in hex> (up to seven bytes)
::
::*********************************************************************

XWRBUF	HS	0
	LR	R10,R2			:SAVE ARGUMENT COUNT
	JE	XRCRLF,,		:NO ARGS, BOOGIE
	LHL	R2,VALUE1+2,XD		:BUFFER NUMBER WAS 1ST ARG	###jhl
	nhi     r2,-4
	ci      r2,lbufn
	jg      comerr
	CLHI	R2,4	
	JlE	COMERR			:SAME GOES FOR BUFFER 4

	CLI     XD,TTYXD  		:tty user?
	JN      XWRBU4    		:nope
	SVC     KIO,8     		:is background running?
	J       DLYEN4    		:make command work when not running
	LA      R8,XWRBU7 		:
	ST      R8,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT 		:wait until BG finishes task
	J       XRCRLF
XWRBU4  JAL     R8,XWRBU8 		:just call subroutine
	J       XRCRLF    		:and done

XWRBU7  ST      R8,XDDTSV+4*R8  	:save link so get it back when LM
	LM      R0,XDDTSV 		:get back XDDT's regs
XWRBU8  ST      R8,XWRBS1 		:store link register

	LIS	R11,3			:INDEX INTO ARG LIST		###jhl
XWRBU1	SIS	R10,4			:DECREMENT ARG COUNT
	JGFS    XWRBU2    		:more to do
	L       R8,XWRBS1 		:get link
	JR      R8        		:and done

XWRBU2	AIS	R11,4			:ADVANCE INDEX
	LB	R1,VALUE1,XD,R11	:GET NEXT BYTE			###jhl
	JAL	R8,WCI,,		:AND WRITE IN
	JBS	XWRBU1			:LOOP BACK TILL DONE
	EI	:(XRSZLV-2)		:##AL

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	XBRZAP:	BZ
::	FUNCTION:	SETS BIT IN BORZAP ARRAY CORRESPONDING TO THE
::			NEIGHBOR NUMBER ARGUMENT
::
::*********************************************************************

XBRZAP	HS	0
	L	R3,VALUE1,XD		:LOAD NODE NUMBER		###SHM
	JAL	R9,OCTHXR		:CONVERT TO HEX			###SHM
	LR	R1,R3			:STORE IN R1 FOR XFNDLK		###SHM
	JAL	R9,XFNDLK		:FIND LINK NUMBER
	SKIPAD(COMERR)			:immediate return, NOT THERE	###wjl
	LHL	KN,XKNSAV,XD		:+4 return, RECOVER LINK#
:       borzap inverted by sdw
	rBT	KN,BORZAP		:SET THE ZAP BIT
	J	XPRMPT,,		:AND RETURN

	EI	:(XRSZLV-1)		:##AL

	IF	(XRSZLV-2)		:##AL
::*********************************************************************
::
::	COMMAND:	XBGLST:	BG
::	FUNCTION:	MAKES CHANGES TO, AND DISPLAYS, THE BAD-GUY LIST
::	FORMAT: 	BG <NODE1>...<NODE7> [R OR I]
::			R REMOVES FROM LIST, I INCLUDES INTO LIST
::			IF NO ARGS, JUST DISPLAY BAD GUY LIST
::
::*********************************************************************

XBGLST	HS	0
	LR	R10,R2			:SAVE ARG COUNT
	JE	XBGSHO			:NO ARGS, JUST DISPLAY
	LH	R3,XPOWER,XD		:IF CHANGING, MUST HAVE POWER	###OAS
	JG	XPWERR			:NOPE, NOT AUTHORIZED		###OAS
	CLHI	R1,ASCR			:WAS LAST ARG A 'R'?
	JE	XBGRMV			:YES, REMOVE FROM LIST
	CLHI	R1,ASCI			:WAS LAST ARG AN 'I'?
	JN	COMERR			:BAD ARGUMENT
XBGLS1  L	R3,VALUE1-4,R10,XD	:GET NODE NUMBER           ###SHM
	TI	R3,88888888		:SEE IF VALID OCTAL	   ###SHM
	JN	XBGLS4			:NON-OCTAL, CHECK NEXT ARG	###OAS
	JAL	R9,OCTHXR		:GO HEX
	LR	R1,R3

	LHI	R5,(BGLSIZ-1)*2
XBGLS2	LH	R0,BGLIST,R5
	JEFS	XBGLS3
	CR	R1,R0			:SEE IF THIS IS DUPLICATE	###OAS
	JEFS	XBGLS4			:DUPLICATE, CHECK NEXT ARG	###OAS
	SIS	R5,2			:THIS ENTRY IN USE		###OAS
	JGBS	XBGLS2			:CHECK NEXT ENTRY		###OAS
	J	XBGSHO			:NO ENTRIES, EXIT		###OAS

XBGLS3	STH	R1,BGLIST,R5		:MAKE ENTRY			###OAS
XBGLS4	SIS	R10,4			:DECREMENT ARGUMENT COUNT	###OAS
	JG	XBGLS1			:LOOK AT NEXT ARG		###OAS
	J	XBGSHO			:NO MORE ARGS, DISPLAY		###OAS

XBGRMV	L	R3,VALUE1-4,R10,XD	:GET NODE NUMBER         ###SHM
	JAL	R9,OCTHXR
	LR	R1,R3

	LIS	R0,0
	LHI	R5,(BGLSIZ-1)*2
XBGS20	CLH	R1,BGLIST,R5
	JNFS	XBGS10			:.+6
	STH	R0,BGLIST,R5
XBGS10	SIS	R5,2
	JGEBS	XBGS20			:.-0C
	SIS	R10,4			:DECREMENT ARG COUNT
	JG	XBGRMV			:MORE ARGS

XBGSHO	JAL	R7,TYPCRL
	LI	R10,BGLIST
	LI	R11,BGLSIZ		:DISPLAY THE LIST
XBGSH1	LHL	R3,0,R10		:GET AN ENTRY
	JEFS	XBGSH2			:NO ENTRY
	JAL	R9,HEXOCT
	JAL	R9,TYP5CH		:TYPE FIVE OCTAL DIGIT NODE # ###SHM
XBGSH2	AIS	R10,2			:ADVANCE POINTE
	SIS	R11,1			:DECREMENT COUNT
	JGBS	XBGSH1			:CONTINUE TYPING
	J	XRCRLF,,


::*********************************************************************
::
::	COMMAND:	XNID:	NI				###wjl
::	FUNCTION:	Allow nodes from two different networks to be
::			connected in an emergency situation.
::	FORMAT:		NI <line #> <desired NETID>
::
::*********************************************************************
:	NETWORKS AS OF 7/20/88

	net(TYMNET,1)
	net(BUBBNET,2)
	net(TRWNET,$A 3)
	net(DECNET,$A 4)
	net(ITALNET,$A 5)
	net(SWEDNET,$A 6)
	net(NETHERNET,$A 7)
	net(SUNNET,$A 8)
	net(SWISSNET$A 9)
	net(UCCPAC,$A 10)
	net(XEROXNET,$A 11)
	net(BOFANET,$A 12)
	net(VANET,$A 13)
	net(CHASENET,$A 14)
	net(CODAN,$A 15)
	net(BPNET,$A 16)
	net(DUNET,$A 17)
	net(LENET,$A 18)
	net(AVISO,$A 19)
	net(DIALOG,$A 20)
	net(MGT,$A 21)
	net(STAGENET,$A 22)
	net(GEONET,$A 23)
	net(ALASCOM,$A 24)
	net(CASNET,$A 25)
	net(EXXON,$A 26)
	net(INSNET,$A 27)
	net(HSBCNET,$A 28)
	net(FIRNNET,$A 29)
	net(DOLNET,$A 30)
	net(CTS,$A 31)
	net(SWBNET,$A 32)
	net(ITALCABLE,$A 34)
	net(TELEVERKET,$A 36)
	net(PHILIPS,$A 37)
	net(UKLAB,$A 38)
	net(EASTNETLAB,$A 39)
	net(DATAPAC,$A 40)
	net(TRAINING,$A 41)
	net(LENG,$A 42)
	net(SLIGOS,$A 43)
	net(WESTREGLAB,$A 44)
	net(REPAIRDEPOT,$A 45)
	net(WESTPUB,$A 46)
	net(WYNET,$A 47)
	net(HGNET,$A 48)
	net(MDISINET,$A 49)
	net(NISNET,$A 50)
	net(BABYLON,$A 52)
	net(ANZNET,$A 53)
	net(FTS2000,$A 54)
	net(CONNNET,$A 55)
	net(NTSNET,$A 56)
	net(MERCURYNET,$A 57)
	net(DEVNET,$A 58)
	net(WTSLAB,$A 63)
	net(TELERATE,$A 64)
	net(TESTNET,$A 99)

	if      1-netdok	:if didn't find a known netid
	remark%%%       NETID is ;
 number $a netid ; remark d.  This NETID is unknown.
	remark%%        Please make sure this NETID is correct.%%%
mnetid  macro[ ac /Unknown/ ]
       ei       :not a known netid.



XNID	HS	0			:###wjl
	JAL	R9,RDARGS,,		:go read arguments
	LHL	R2,ARGCT,XD		:takes 3 arguments
	sis	R2,8			:check for them
	JN	xnid20
	LH	R3,VALUE1+2,XD		:first argument is line number
	JAL	R9,DECHEX		:convert to hex
					:J to DHXBAD for bad radix
	CLHI	R3,NLINES-1		:check for valid line number
	JG	COMERR
	LR	LN,R3			:
	LH	R3,VALUE1+6,XD		:2nd arg is NETID
	JAL	R9,DECHEX		:convert to hex
					:J to DHXBAD for bad radix
	STH	R3,LNETID,LN,LN		:store NETID 

	CLI     XD,TTYXD  		:tty user?
	JN      XNID04    		:nope
	LA      R8,XNID07 		:
	ST      R8,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT 		:wait until BG finishes task
	J       xnid30
XNID04  JAL     R8,XNID08 		:just call subroutine
	j       xnid30    		:display lines
xnid20  ais     r2,8      		:if no args then okay
	jn      comerr,,  		:gave some arguments, syntax error
xnid30  la      r2,xnidh0 		:get address of header
	jal     r7,typasc 		:print it
	lhi     r3,netid
	jal     r9,typhwd
	la      r2,xnidh1
	jal     r7,typasc
	lis     r5,0      		:line number
xnid33  lr      r10,r5    		:last line number displayed
	lh      r6,lnetid,r5,r5 	:last netid displayed
	lr      r3,r5
	jal     r9,typbyd  		:print line #
xnid36  clh     r6,lnetid+2,r5,r5       :netid of next line
	jnfs    xnid50
	ais     r5,1
	clhi    r5,nlines
	jlbs    xnid36    		:see how many match
	sis     r5,1      		:let display discover this is last line
xnid50  cr      r5,r10    		:a range of just one line
	jnfs    xnid53
	jal     r7,typ8sp
	j       xnid56
xnid53  lhi     r1,ascdsh 		:print '-'
	jal     r13,xryout,,
	jal     r7,typ2sp
	lr      r3,r5     		:high end of range
	jal     r9,typbyd,,
	la      r2,asc1sp
	jal     r7,typasc
xnid56  jal     r7,typ8sp
	lr      r3,r6     		:print the netid
	jal     r9,typhwd,,
	jal     r7,typcrl 		:new line
	ais     r5,1      		:see if at end
	clhi    r5,nlines
	jl      xnid33    		:do remaining lines
	j       xrcrlf,,  		:otherwise done

xnidh0  sc      /"8d"8aAssembled in NETID: /
xnidh1  bc      0
	ac      /(decimal)  /
q       eq      .         		:limit network name to 10d bytes
	mnetid
	if      .-q-0a    		:if more than 10 bytes
	org     q+0a
	re .-q-0a ; bc 0 ; er   	:clear excess
	org     q+0a
	ei                		:handling of overwrite
	ac      /'s NETID."8d"8a  LINES           NETID (in decimal)"8d"8a/
q       eq      .
	org     xnidh1
	bc      q-xnidh1-1		:length (not includind length field)
	org     q         		:restore pc
	hs      0

XNID07  ST      R8,XDDTSV+4*R8  	:save link
	LM      R0,XDDTSV 		:get back XDDT's regs
XNID08  ST      R8,XNIDS1 		:save link register

	LHI	R0,NR.XID
	STH	R0,SUPMBF		:indicate XRAY NETID change in HW0
	OHI	LN,8000			:avoid escapes
	STH	LN,SUPMBF+2		:include line# in HW1
	OHI	R3,8000
	STH	R3,SUPMBF+4		:include NETID in HW2
	JAL	R10,SUP12,,		:send msg to Sup and CRYPTO Logs

	L       R8,XNIDS1
	JR      R8        		:done
	EI	:(XRSZLV-2)		:##AL

	SUBTTL	XRAY (Channel status - QC)

	IF	(XRSZLV-1)		:##AL

::*********************************************************************
::
::	COMMAND:	QRYCHN:	QC
::	FUNCTION:	QUERY CHANNEL STATUS
::	INPUT:		START ABS CHAN NUMBER, END CHAN, (U ACTIVE ONLY)
::
::*********************************************************************

QRYCHN	HS	0
	SHI	R1,ASCU			:DID USER CLOSE WITH A 'U'(x55)	###OAS
	LR	R12,R1			:SAVE FOR LATER STUDY		###OAS
	LR	R2,R2			:CHECK ARG COUNT
	JE	COMERR			:NONE ERROR			###OAS
	SIS	R2,4			:ONE ARGUMENT			###OAS
	JE	QRYCH1			:YES				###OAS
	CLHI	R3,ENDZFL		:CHECK LAST CHANNEL NO.		###OAS
	JGE	COMERR			:TOO BIG			###OAS
	LR	R14,R3
	L	R3,VALUE1,XD		:BEGIN CHANNEL NUMBER		###OAS
	CLHI	R3,ENDZFL		:CHECK				###OAS
	JGE	COMERR			:TOO BIG			###OAS
	SR	R14,R3			:COUNT = END CHAN#-START CHAN#
	AIS	R14,1			:+1				###OAS
	JL	COMERR			:START CHAN > END CHAN		###OAS
	LR	CHN,R3			:CHN = START CHANNEL NO.	###OAS
	JFS	QRYCH2			:START DISPLAYING		###OAS

QRYCH1	CLHI	R3,ENDZFL		:DO RANGE CHECK ON CHANNEL NUMBER
	JGE	COMERR			:TOO BIG
	LIS	R14,1			:ONLY DISPLAY ONE CHANNEL	###OAS
	LR	CHN,R3			:CHN = START CHANNEL NO.	###OAS

QRYCH2	HS	0			:DISPLAY LOOP			###OAS

	LR	R12,R12			:DISP ONLY CHANS WITH BF<>0	###OAS
	JN	QRYCH3			:NO, DISP ALL CHANNELS REQUESTED###OAS
	TBT	CHN,ACP,,		:IS CHANNEL ACTIVE		###OAS
	JN	QRYCH5			:CHAN NOT ACTIVE, DON'T DISPLAY	###OAS

QRYCH3	LA	R2,QRYMS0
	JAL	R7,TYPASC		:HEADER
	LR	R3,CHN			:TYPE CHANNEL NUMBER		###OAS
	JAL	R9,TYPHW
	JAL	R8,CHNLNK		:GET LINK
	SKIPAD(QRYCH0)			:(immed) NEIGHBOR NOT FOUND	###wjl
	SKIPAD(QRYCH4)			:(+4) INTERNAL, GET NODE NUMBER	###wjl
QRYCH8	JAL	R9,HEXOCT		:(+8) CONVERT NEIGHBOR TO OCT	###wjl
QRYCH9  JAL	R9,TYP5CH		:TYPE FIVE OCTAL DIGIT NODE #	###SHM
	LHL	R3,IOTAB,CHN,CHN	:DESTINATION BUFFER
	LR	R10,R3			:SAVE IT
	NHI	R3,3			:ISOLATE SPEED BITS
	JAL	R9,TYPBYT		:AND DISPLAY THEM
	NHI	R10,-4			:STRIP SPEED BITS
	LHL	R3,BF,R10,		:TYPE TERMINATION CHANNEL
	JAL	R9,TYPHW
	JAL	R7,TYP2SP
	LR	R3,R10
	JAL	R9,TYPHW		:TYPE DESTINATION BUFFER
	JAL	R7,TYP2SP
	XHI	R3,4
	JAL	R9,TYPHW		:TYPE SOURCE BUFFER
	XHI	R10,4
	L	R3,BB,R10,		:BB FLAG
	JAL	R9,TYPFW
	L	R3,BE,R10,		:BE FLAG
	JAL	R9,TYPFW
	LHL	R3,BF,R10,		:AND BF
	JAL	R9,TYPHW
	LR	R2,R10
	JAL	R8,CBCCT,,
	LR	R3,R1			:GET BYTE COUNT
	JAL	R9,TYPHW
	LR	R11,R10
	SRLS	R11,1
	NHI	R11,-4			:1/2 BUFFER INDEX FOR BUFTIM
	L	R3,SLOWC,,
	S	R3,BUFTIM,R11,		:CIRCUIT TIME
	JAL	R9,TYPFW

	IF	REBILD
	LA	R2,QRYMS1
	JAL	R7,TYPASC		:REBUILD-TYPE HEADER
	LI	R3,HBUFN,R11		:DISPLAY HISTORY BUFFER INDEX
	JAL	R9,TYPHW
	L	R3,HSEQN+HBUFN,R11,
	JAL	R9,TYPFW		:DISPLAY CURRENT HISTORY BUFFER SEQN
	XHI	R10,4
	L	R3,XSEQN,R10,		:DISPLAY CURRENT TRANSMITTED SEQUENCE#
	JAL	R9,TYPFW
	XHI	R10,4
	L	R3,VSEQN,R10,
	JAL	R9,TYPFW
	LA	R2,QRYMS2		:ASSUME REBUILD ON
	SRLS	R10,3
	TBT	R10,CRQBSY
	JNFS	XQRYR0
	LA	R2,QRYMS3
XQRYR0	JAL	R7,TYPASC
	EI	:REBILD

QRYCH5	HS	0			:DISPLAY LOOP END		###OAS
	AIS	CHN,1			:INCREMENT CHANNEL INDEX	###OAS
	SIS	R14,1			:DECREMENT CHANNEL COUNT	###OAS
	JG	QRYCH2			:MORE TO DO			###OAS

	J	XRCRLF,,		:DONE

QRYCH0	LCS	R3,2			:NEIGHBOR NOT FOUND		###wjl
	J	QRYCH9			:continue			###wjl
QRYCH4	LHI	R3,MACHNM		:INTERNAL, GET NODE NUMBER	###wjl
	J	QRYCH8			:continue			###wjl

	NOLIST
QRYMS0	SC	/"0D"0A"0D"0ACHAN  LINK   SP  O-CHN  O-BUF   S-BUF     BB       BE     BF   COUNT SEC(HEX)"0D"0A/
QRYMS2	SC	/   ON/
QRYMS3	SC	/  OFF/
QRYMS1	SC	/"0D"0A"0AH-BUF   HSEQN    XSEQN    VSEQN   REBUILD"0D"0A/
	LIST

	SUBTTL	XRAY (Symbol commands - SA, RS, WS)

::*********************************************************************
::
::	COMMAND:	DISADR:	SA
::	FUNCTION:	Display Symbol Address
::
::*********************************************************************

DISADR	HS	0
	JAL	R13,XRYIN		:read char from user
	OHI	R1,80			:set high order bit
	CLHI	R1,ASCSPC+80		:is it a space?
	JN	COMERR,,		:must separate symbol with space
	JAL	R10,RDSYMB		:read ASCII into SYMASC
	JAL	R10,SYMVAL		:look for it in symbol table
	SKIPAD(COMER1)			:(immed) found no match		###wjl
	JAL	R7,TYPCRL		:(+4) found a match--show on next line
	JAL	R7,TYPLF
	JAL	R9,TYPFW		:output the fullword value
	JAL	R7,TYPCRL		:look pretty
	J	XPRMPT,,		:and skedaddle...

::*********************************************************************
::
::	COMMANDS:	READS:/WRITES:	RS/WS
::	FUNCTION:	Read/write symbolic
::
::*********************************************************************

READS	HS	0
	LI	R1,TYPE			:Read comes here		###wjl
	ST	R1,RWADDR,,		:				###wjl
	IF	(XRSZLV-2)		:##AL
	JFS	RDWRIT
WRITES	HS	0
	LI	R1,WRITE		:Write comes here		###wjl
	ST	R1,RWADDR,,		:				###wjl
	EI	:(XRSZLV-2)
RDWRIT	JAL	R13,XRYIN		:get that space in and out of the way
	OHI	R1,80
	CLHI	R1,ASCSPC+80
	JN	COMERR,,
	JAL	R10,RDSYMB
	LR	R11,R1			:SAVE LAST CHAR TYPED
	JAL	R10,SYMVAL
	SKIPAD(COMER1)			:(immed) NO MATCH		###wjl
	ST	R3,VALUE1,XD		:(+4) STORE THE SYMBOL VALUE
	CLHI	R11,ASCCR+80		:A CR WITH HOB?			###wjl
	JEFS	RDWRI0			:YES				###wjl
	CLHI	R11,ASCCR		:A CR?
	JNFS	RDWRI1			:NO
RDWRI0	LIS	R0,0
	ST	R0,VALUE1+4,XD		:ZERO SECOND ARG
	LIS	R0,4
	STH	R0,ARGCT,XD
	J	RDWRI2

COMER1	J	COMERR,,		:Whenever it needs		###al

RDWRI1	L	R0,VALUE1,XD
	JAL	R9,RDARGS
	ST	R0,VALUE1,XD
	AIS	R2,4
	STH	R2,ARGCT,XD
	ST	R3,VALUE1+4,XD
RDWRI2	JAL	R7,TYPCRL
	L	R1,RWADDR,,		:				###wjl
	CI	R1,TYPE			:READ ONLY?			###wjl
	JER	R1			:YES, GO AHEAD			###wjl

	LH	R7,XPOWER,XD		:HAVE POWER?			###TZ
	JLER	R1			:YES, GO AHEAD			###TZ

:	IF TRYING TO WRITE WITHOUT POWER, MUST BE ONE OF FOLLOWING SYMBOLS
	LIS	R7,2			:ALLOW ONLY 2 BYTES TO BE WRITTEN
	ST	R7,VALUE1+4,XD		:AS SO
	L	R7,VALUE1,XD		:GET THE WRITE ADDRESS
	CI	R7,CRYDIS
	JER	R1			:				###wjl
	CI	R7,REBDIS
	JER	R1			:				###wjl

	J	COMERR,,		:NONE OF THE ABOVE, SECURITY VIOLATION

	SUBTTL	XRAY (Channel commands - AC, TC, TD, TE, TA)

::*********************************************************************
::
::	COMMAND:	XACHAN:	AC
::	FUNCTION:	DISPLAY ACTIVE CHANNELS
::	INPUT:		ABS CHAN NUMBER, RANGE
::	###OAS
::*********************************************************************

XACHAN	HS	0
	LR	R2,R2			:ZERO ARGS
	JE	COMERR,,		:YES,ERROR
	SIS	R2,4			:ONE ARG
	JE	COMERR,,		:YES,ERROR
	CLHI	R3,ENDZFL		:LAST ARG (RANGE) VALID
	JGE	COMERR,,		:NO
	LR	R3,R3			:RANGE = 0?
	JE	COMERR,,		:YES, ERROR
	LR	R14,R3			:OKAY, SAVE RANGE
	L	R3,VALUE1,XD		:GET FIRST ARG (START CHAN)
	CLHI	R3,ENDZFL		:START CHAN VALID
	JGE	COMERR,,		:NO
	LR	CHN,R3			:SAVE START CHANNEL
	AR	R14,CHN			:COMPUTE END CHANNEL
	SIS	R14,1
	CLHI	R14,ENDZFL		:TRUNCATE END CHANNEL?
	JLFS	XACHN1			:NO
	LHI	R14,ENDZFL		:YES

XACHN1	HS	0
	LIS	R12,0C			:12 HW'S PER LINE
	JAL	R7,TYPCRL
XACHN2	HS	0
	TBT	CHN,ACP,,		:CHANNEL ACTIVE?
	JNFS	XACHN3			:NO, DON'T DISPLAY
	LR	R3,CHN			:YES, DISPLAY CHANNEL NUMBER
	JAL	R9,TYPHW
	SIS	R12,1			:COUNT THIS ITEM ON THIS LINE
XACHN3	HS	0
	AIS	CHN,1			:BUMP CHANNEL NO.
	CR	CHN,R14			:UPPER LIMIT YET?
	JG	XRCRLF,,		:YES
	LR	R12,R12			:NOT DONE, CHECK FOR NEXT LINE
	JE	XACHN1			:LINE FULL, USE NEXT LINE
	J	XACHN2			:NOT FULL, CHECK FOR NEXT ACTIVE CHAN

::*********************************************************************
::
::	COMMAND:	XCHTRC:	TC
::	FUNCTION:	SET CHANNEL DATA TRACE
::	INPUT:		ARG 2 =	START/END TRACE SELECT
::			ARG 1 =	ABS CHANNEL NO
::
::*********************************************************************

XCHTRC	HS	0
	LR	R2,R2
	JE	XCHTR2
	SIS	R2,8
	JN	COMERR,,
	LHL	R1,VALUE1+2,XD		:ABS CHANNEL TO TRACE
	CLHI	R1,ENDZFL		:LARGEST ALLOWABLE CHANNEL
	JG	COMERR,,			:TOO BIG
	LR	R3,R3			:0=> END TRACE, 1=> START TRACE
	JN	XCHTR1
	RBT	R1,TRCHAN,,
	J	XCHTR2
XCHTR1	SIS	R3,1
	JN 	COMERR,,
	SBT	R1,TRCHAN,,
XCHTR2	LIS	R10,0
XCHTR4	LHL	R12,TRCHAN,R10,
XCHTR6	JFFOH	R12,XCHTR3
	JFS	XCHTR5			:DONE WITH THIS H-WORD
XCHTR3	XH	R12,HMSK,R13,R13
	LR	R3,R10
	SLLS	R3,3
	AR	R3,R13
	JAL	R9,TYPHW
	JBS	XCHTR6
XCHTR5	AIS	R10,2
	CLHI	R10,ENDZFL/8
	JL	XCHTR4
	J	XRCRLF,,

::*********************************************************************
::
::	COMMANDS:	TRCDAT:/TRCDES:/TRCASC:	TD, TE, TA
::	FUNCTION:	DISPLAY DATA FROM THE CHANNEL TRACE BUFFERS
::
::*********************************************************************

TRCMS0	SC	?"0D"0AI/O  CHN  TIME"0D"0A"0A?	:###wjl
TRCMS1	SC	/OUT /
TRCMS2	SC	/IN  /

TRCASC	HS	0			:SAME AS TRCDAT, BUT DISPLAYS IN ASCII
	LHI	R4,$A44			:INDICATE ASCII DISPLAY MODE
	JFS	TRCD00

TRCDES	HS	0			:SAME AS TRCDAT, BUT DISPLAYS ESCAPES
	LIS	R4,0			:INDICATE HEX DISPLAY MODE
	LIS	R0,0			:INDICATE DISPLAY ESCAPES
	JFS	TRCD00

TRCDAT	HS	0
	LIS	R4,0			:INDICATE HEX DISPLAY MODE
	LIS	R0,1			:INDICATE SUPPRESS ESCAPES
TRCD00	STH	R0,TDESFL,,		:SAVE VALUE IN ESCAPE FLIPPER
trcd00  lhl     r8,xusltn,xd    	:get xray user number
	rbt     r8,xtdasc 		:init to not ascii (one of the hexmodes
	lr      r4,r4     		:0 if one of hex modes
	jefs    trcd40
	sbt     r8,xtdasc
trcd40  ais     r4,0c     		:hex line size is 12 bytes, ascii is 56
	sth     r4,xtdlnz,r8,r8 	:save line size
	rbt     r8,xtdesc 		:see if want to display escaping
	lr      r0,r0     		:0 if they want to see escs
	jnfs    trcd41
	sbt     r8,xtdesc
trcd41  lis     r11,0     		:for display mode -1 is output only
	                  		:-2 is input only, 0 is both
	sth     r11,xtdmsn,r8,r8	:# of msgs to display
	lhi     r5,(trrsiz/8)-4 	:init to not data masked
trcd42  st      r11,trmask,r5,
	sis     r5,4
	jgebs   trcd42
	shi     r1,asci   		:I option?
	jnfs    trcd43
	lcs     r11,2     		:input only is -2 in r11
trcd43  sis     r1,ascO-ascI    	:out only option?
	jnfs    trcd44
	lcs     r11,1     		:output only is -1 in r11
trcd44  sbt     r8,xtdato 		:init doing continous display
trcd68  sis     r1,ascY-ascO    	:Y is continous display
	jefs    trcd45    		:doing continous
	rbt     r8,xtdato
	lhi     r1,0308   		:turn off tracing log
	sth     r1,chrtrc,,     	:(jr r8 at start of trace log)
	sth     r1,xtdflg,,     	:remember that tracind disabled
trcd45  lr      r12,r3    		:r3 has # of msgs user wants to see
	je      trcd90    		:show no msgs if they want no msgs
	la      r2,trcms0 		:header
	jal     r7,typasc
	lr      r7,r11    		:save whether doing input or output
	lis     r11,0     		:count all msgs in ring
	lis     r13,0     		:set counter of msgs to 0
	lcs     r10,1     		:if found any and where it is in ring
	lhl     r5,trrix  		:get current pointer

trcd46  sis     r5,8      		:hunt msgs from newest to oldest
	nhi     r5,trrsiz-1
	clh     r5,trrix  		:back to the start?
	jefs    trcd48
	jal     r9,trctst 		:is it a msg
	j       trcd46    		:null return is a no msg
	lr      r10,r5    		:save location of oldest found so far
	lr      r7,r7     		:they want all msgs?
	jefs    trcd47    		:yes
	cr      r7,r4     		:want this msg?
	jefs    trcd47    		:like this msg
	ais     r12,1     		:have to scan this many to display
	                  		:desired number of msgs.
trcd47  ais     r13,1     		:another msg found
	cr      r13,r12   		:equal to number user wanted?
	jn      trcd46
trcd48  lr      r11,r7    		:restore input/output masking
	lr      r5,r10    		:any found and where is oldest msg
	jl      trcd90    		:none found exit
trcd49  sth     r13,xtdmsn,r8,r8	:max number of msgs to process

:       here to print a msg
trcd50  jal     r10,trcsup		:if a msg then do pwd masking
	j       trcd82    		:if user requested only IN or OUT msgs
	la      r2,trcms1 		:output msg? (r4 = -1)
	ais     r4,1      		:so, is it output msg
	jefs    trcd51
	la      r2,trcms2 		:input msg (I)
trcd51  jal     r7,typasc
	jal     r9,typhw  		:print chn # (in r3)
	lhl     r3,trring+4,r5, 	:get time
	jal     r9,typhw
	ais     r5,8
	nhi     r5,trrsiz-1     	:to start of data

:       here to print a line (or as many as it takes) of the data
trcd53  lhl     r12,xtdlnz,r8,r8	:get line size
:       here to print next byte
trcd54  lb      r3,trring,r5,   	:get the byte
	jnfs    trcd55    		:it is 00
	tbt     r8,xtdesc 		:escaping desired?
	jnfs    trcd55    		:want to see the escaping
	ais     r5,1      		:get escaped byte
	nhi     r5,trrsiz-1
	lb      r3,trring,r5,   	:get it
	sis     r6,1      		:one fewer byte to display
trcd55  tbt     r5,trmask,,     	:can we show this byte?
	jn      trcd70    		:don't show it
	tbt     r8,xtdasc 		:printing in ascii?
	jefs    trcd57
:       doing display in ascii
	nhi     r3,7f     		:knock off high bit
	clhi    r3,20     		:printable?
	jgefs   trcd56
	lhi     r3,ascdot 		:print a dot instead
trcd56  lr      r1,r3
	jal     r13,xryout		:print it
	jfs     trcd58
:       doing display in hex
trcd57  jal     r9,typbyt 		:print a byte of hex
:       printed something out
trcd58  sis     r12,1     		:printed something on the line
:       read a byte from the ring
trcd70  ais     r5,1
	nhi     r5,trrsiz-1
	sis     r6,1      		:this msg is closer to being done
	jlefs   trcd80
	lr      r12,r12   		:this line finished?
	jg      trcd54    		:nope do next byte
	jal     r7,typcrl
	jal     r7,typ8sp 		:format the next line
	jal     r7,typ8sp
	j       trcd53

:       here to do next msg
trcd80  jal     r7,typcrl
	jfs     trcd85
:       next msg when previous wasn't displayed
trcd82  lr      r6,r6     		:did we find a msg?
	jlefs   trcd84    		:no msg,try next boundary
	clhi    r6,$a 121 		:too big to have been a packet
	jgfs    trcd84
	ar      r5,r6     		:add len of undisplayed msg
trcd84  ais     r5,8      		:skip over the header stuff

:       here whether previous msg was displayed or not
trcd85  ais     r5,7      		:next msg starts on a dw boundary
	nhi     r5,trrsiz-8
	lhl     r0,xtdmsn,r8,r8 	:count of msgs displayed
	sis     r0,1
	sth     r0,xtdmsn,r8,r8
	jl      trcd90    		:printed all msgs we wanted to
	clh     r5,trrix  		:have printed all msgs?
	jn      trcd50
:       here when either ring pointers matched up or printed as much as wanted
trcd90  tbt     r8,xtdato 		:do they want continous display?
	jnfs    trcd94
	lhi     r1,0208   		:nop
	sth     r1,chrtrc,,
	ts      xtdflg,,  		:tracing has been restored
	j       xprmpt,,  		:done
:       auto display exit, handle if msgs still left to display or no msgs
:       were displayed.
trcd94  lr      r5,r5     		:r5<0 if no msgs to display
	jgefs   trcd95
	lhl     r5,trrix  		:ring was empty, so caught up
trcd95  sth     r5,xtdcpt,r8,r8 	:save current position
	clh     r5,trrix  		:have we caught up?
	jefs    trcd97
	ts      xryrun    		:go again to do any forgot msgs
	sbt     r8,xquem,,		:sched this user
trcd97  lhi     r1,3e     		:the '>' for a prompt
	jal     r13,xryout
	j       xloop0,,

::*********************************************************************
::
::	SUBROUTINE:	TRCTST:
::	FUNCTION:	DOES RANGE CHECK ON BYTE COUNT AND CHANNEL NUMBER,
::			TESTS BIT IN TRCHAN, AND MASKS THE I/O INDICATOR.
::	CALLING SEQ:	JAL	R9,TRCTST
::	INPUT:		R5 = POINTER TO ENTRY IN TRRING
::			R11= MASK TO SELECT INPUT(-2),OUTPUT(-1),OR ALL(0) MSGS
::	OUTPUT:		R6 = BYTE COUNT
::	RETURNS:	DIRECT RETURN	=>	NOT SATISFACTORY
::			SKIP RETURN	=>	SATISFCTORY
::
::*********************************************************************

TRCTST	HS	0
	LH	R6,TRRING+6,R5,,	:PRESUMED BYTE COUNT
	JLE	TRCTXI			:NON-POSITIVE => INVALID, DIRECT RETURN
	CLHI	R6,$A121		:TEST FOR MAXIMUM SIZE
	JG	TRCTXI			:TOO BIG => INVALID, DIRECT RETURN#wjl
	LHL	R3,TRRING+2,,R5		:POSSIBLE CHANNEL
	CLHI	R3,ENDZFL		:WITHIN RANGE?
	JG	TRCTXI			:NO,DIRECT RETURN		###wjl
	TBT	R3,TRCHAN,,		:BIT SET?
	JE	TRCTXI			:NO,DIRECT RETURN		###wjl
	LH	R4,TRRING,,R5		:I/O INDICATOR
	CR	R4,R11			:MATCH WITH R11?
	JE	4,R9			:YES,SKIP RETURN
	LR	R11,R11			:ALL MESSAGES ENABLED?
	JN	TRCTXI			:NO, THIS ISNT A VALID MESSAGE	###wjl
	LR	R2,R4			:YES, VALID MESSAGE IF I/O INDICATOR OK
	AIS	R2,1			:IS R2 = -1 ?
	JE	4,R9			:YES, SKIP RETURN
	AIS	R2,1			:NO, IS R2 = -2 ?
	JE	4,R9			:YES,SKIP RETURN
TRCTXI	SKIP(0,R9)			:NO, DIRECT RETURN		###wjl

::*********************************************************************
::
::	SUBROUTINE:	TRCSUP:
::	FUNCTION:	TRACE DISPLAY SET-UP
::	CALLING SEQ:	JAL	R10,TRCSUP
::	PRESERVED:	R3, R4, R5, R6, R9, AND R11
::	RETURNS:	IMMEDIATE = NOT PRINTABLE
::			+4	  = FOUND APPARENTLY VALID ENTRY
::
::*********************************************************************

:	CHECK FOR COMMAND CIRCUIT TRACING. IF TRUE, MASK OUT PASSWORDS.
:	THE BIT ARRAY 'TRMASK' HAS A BIT POSITION FOR EACH BYTE OF TRRING.
:	TRCSUP CLEARS THE BIT ARRAY, AND THEN SETS BITS FOR PASSWORD
:	CHARACTERS. TRMASK IS TESTED IN 'TRCD10', AND BYTES ARE NOT
:	OUTPUT FOR SET BITS.
	
TRCSUP	HS	0
	JAL	R9,TRCTST		:TEST FOR PRINTABLE MESSAGE
	SKIPAD(TRCSXI)			:NO - NON-SKIP RETURN		###wjl


:	IS THIS POSSIBLY A COMMAND CIRCUIT?
	CLHI	R3,LEPZFL		:+4 return from TRCTST
	JL	4,R10			:NO - TOO LOW
	CLHI	R3,DISZFL 		:(diszfl for when supe base)
	JGE     4,R10     		:not a cmd circuit
	lh      r0,trring,r5,   	:only if sent from node unless supe
       if       super
	ais     r0,1      		:input message
       else     :interface machin
	ais     r0,2      		:input message
       ei
	je      4,r10

:	SET UP TO SCAN FOR SUP MESSAGES WHICH MAY CONTAIN PASSWORDS. LOOK
:	FOR THE SEQUENCE:
:		MACHNM+8000
:		0E,80+N
:		PORT NUMBER+8000
:		X,X
:		X,X
:	WHERE N IS THE NUMBER OF PASSWORD CHARACTERS X.
:       also check for log II logon msg.                        ###sdw
:       8000+MACHNM, 08 80      (NCRM)
:       if it is NCRM then display the first 16d chars (password can't be
:       earlier in msg than that)

TRCS07	LR	R13,R6			:SET R13 AS # OF CHARACTERS TO SCAN
	LHI	R12,TRRSIZ-1		:R12 IS RING WRAP MASK

	LR	R1,R5			:R1 POINTS TO BEGIN OF STRING TO SCAN
	AIS	R1,7
TRCS10	AIS	R1,1			:BEGIN NEW SCAN FOR PASSWORD MESSAGE
	NR	R1,R12
	SIS	R13,1			:DONE?
	JL	4,R10			:YES - GO DISPLAY

	LB	R0,TRRING,R1,
	OHI     R0,80     		:make sure the bit is set
	CLHI	R0,(MACHNM+8000)/100
	JNBS	TRCS10			:NO MATCH - TRY NEXT BYTE
	LR	R2,R1			:POTENTIAL SUP MSG W/PASSWORD,PRESRV R1
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,
	JNFS    TRCS13    		:low byte of node # not escaped
	AIS     R2,1
	NR      R2,R12
	SIS     R13,1     		:ANOTHER BYTE CHECKED
	LB      R0,TRRING,R2,   	:GET ESCAPED CHAR
TRCS13	CLHI	R0,MACHNM&0FF		:OUR NODE NUMBER?
	JN	TRCS10			:NO
	AIS	R2,1
	NR	R2,R12
	SIS	R13,1
	LB	R0,TRRING,R2,
	CLHI    R0,08     		:08 (LOG II NCRM)
	JE      TRCS40
	CLHI	R0,0E			:0E MESSAGE TYPE?
	JN	TRCS10			:NO
:	YES - GOT A PASSWORD MESSAGE...
	AIS	R2,2
	NR	R2,R12	
	LB	LRC,TRRING,R2,		:GET CHARACTER COUNT
	NHI	LRC,7F			: AND ISOLATE
	SHI	R13,2,LRC		:DECREMENT COUNT OF CHARACTERS TO SCAN
	AIS	R2,2			:ADVANCE INDEX PAST PORT NUMBER
	LR	R1,R2
	AR	R1,LRC			:POINT PAST PASSWORD MSG FOR NEXT SCAN
	NR	R1,R12
	NR	R2,R12
TRCS20	AIS	R2,1			:INDEX TO		###sn###wjl
	NR	R2,R12			:  PASSWORD CHARACTER	###sn###wjl
	SBT	R2,TRMASK,,		:PREVENT DISPLAY OF PASSWORD CHARACTERS
	CR	R2,R1			:DONE MASKING PASSWORD?
	JNBS	TRCS20			:NOT YET
	J	TRCS10			:YES - LOOK FOR MORE TO DO

TRCS40  AIS     R2,2      		:point past 80 to first byte of len
	NR      R2,R12
	LB      LRC,TRRING,R2,  	:get 1st byte of len
	JNFS    TRCS42    		:not escaped
	AIS     R2,1
	NR      R2,R12
	SIS     R13,1     		:get next char
	LB      LRC,TRRING,R2,  	:get escaped char
TRCS42  EXBR    LRC,LRC   		:put first byte of len into high byte
	AIS     R2,1
	NR      R2,R12
	LB      R0,TRRING,R2,   	:get low byte of len
	JNFS    TRCS45
	AIS     R2,1
	NR      R2,R12
	SIS     R13,1
	LB      R0,TRRING,R2,   	:get escaped low byte of len
TRCS45  NHI     LRC,300   		:max value of high byte
	AR      LRC,R0    		:the biggest the msg could ever get
	SHI     R13,3,LRC 		:(2 for len+1 to skip over the 80)
	                  		:reduce count of chars to scan
	LR      R1,R2     		:point to end of msg
	AR      R1,LRC    		:r1 now points to next msg
	NR      R1,R12    		:handle wrap
	AHI     R2,10     		:no harm in first 10 byte of NCRM
	NR      R2,R12
	SHI     LRC,10    		:further into msg
TRCS49  SBT     R2,TRMASK,,     	:don't display this byte
	AIS     R2,1
	NR      R2,R12    		:next byte
	SIS     LRC,1
	JGBS    TRCS49    		:mask out next byte
	J       TRCS10    		:done masking

TRCSXI	SKIP(0,R10)			:immediate return		###wjl

	SUBTTL	XRAY (CRYPTO display mode - CD)

::*********************************************************************
::
::	COMMAND:	XCRMOD:	CD
::	FUNCTION:	CD Y TURNS DISPLAY ON
::			CD N TURNS DISPLAY OFF
::
::*********************************************************************

XCRMOD	HS	0
	LR	R2,R2			:DETERMINE NUMBER OF ARGS
	JN	COMERR,,		:NON-ZERO,ERROR!
	CLHI	R1,ASCY			:LAST CHAR = 'Y'(x59)?
	JEFS	XCRMO3			:YES, TURN ON
	CLHI	R1,ASCN			:LAST CHAR = 'N'(x4E)?
	JNFS	XCRMO1			:NO, JUST DISPLAY
	LIS	R2,1
XCRMO3	STH	R2,CRYMOD,XD		:MAKE ENTRY
XCRMO1	LA	R2,CRYPON		:PRESUME ON
	LHL	R1,CRYMOD,XD		:VERIFY GUESS
	JEFS	XCRMO2			:RIGHT
	LA	R2,CRYPOF		:WRONG
XCRMO2	JAL	R7,TYPASC		:DISPLAY MODE
	J	XPRMPT,,		:AND RETURN

	NOLIST
CRYPON	SC	/"0D"0A AUTO CRYPTO ON"0D"0A/
CRYPOF	SC	/"0D"0A AUTO CRYPTO OFF"0D"0A/
	LIST

	EI	:(XRSZLV-1)		:##AL

	SUBTTL	XRAY (Conversion routines - HO, OH, HD, DH, OD, DO)

	IF	(XRSZLV-2)		:##AL

::*********************************************************************
::
::	COMMAND:	XHXOCT:	HO
::	FUNCTION:	CONVERT HEX TO OCTAL
::
::*********************************************************************

XHXOCT	HS	0
	NI	R3,0FFFF		:STRIP TOP HW
	JAL	R9,HEXOCT
	JAL	R9,TYPFW		:5 DIGIT NODE# NEEDS FW		###AL
:	JAL	R9,TYPHW
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XOCHEX:	OH
::	FUNCTION:	CONVERT OCTAL TO HEX
::
::*********************************************************************

XOCHEX	HS	0
	JAL	R9,OCTHXR
	JAL	R9,TYPFW		:		###shm
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XHXDEC:	HD
::	FUNCTION:	HEX TO DECIMAL
::
::*********************************************************************

XHXDEC	HS	0
	JAL	R9,HEXDEC
	CLI	R3,10000
	JGEFS	XHXDE1
	JAL	R9,TYPHW
	J	XRCRLF,,
XHXDE1	JAL	R9,TYPFW
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XDCHEX:	DH
::	FUNCTION:	DECIMAL TO HEX
::
::*********************************************************************

XDCHEX	HS	0
	JAL	R9,DECHEX		:convert decimal to hex
					:J to DHXBAD for RADIX VIOLATION###wjl
	JAL	R9,TYPHW		:DISPLAY
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XOCDEC:	OD
::	FUNCTIOPN:	OCTAL TO DECIMAL
::
::*********************************************************************

XOCDEC	HS	0
	TI	R3,88888888		:CHECK FOR VALID OCTAL		###OAS
	JN	DHXBAD			:RADIX VIOLATION		###OAS
	JAL	R9,OCTHXR		:CONVERT TO HEX
	JAL	R9,HEXDEC		:CONVERT HEX TO DECIMAL
	JAL	R9,TYPFW
	J	XRCRLF,,

::*********************************************************************
::
::	COMMAND:	XDCOCT:	DO
::	FUNCTION:	DECIMAL TO OCTAL
::
::*********************************************************************

XDCOCT	HS	0
	JAL	R9,DECHEX		:CONVERT DECIMAL TO HEX		###OAS
					:J to DHXBAD for BAD RADIX	###OAS
	JAL	R9,HEXOCT		:CONVERT HEX TO OCTAL		###OAS
	JAL	R9,TYPHW
	J	XRCRLF,,

	EI	:(XRSZLV-2)		:##AL

	SUBTTL	XRAY (Miscellaneous - CO, PM)

	IF	(XRSZLV)		:##AL

::*********************************************************************
::
::	COMMAND:	XCROPT:	CO
::	FUNCTION:	SELECTS CRASH RESPONSE
::
::*********************************************************************

XCROPT	HS	0
	LR	R2,R2
	JEFS	XCROP1			:NO ARGS, DISPLAY CURRENT MODE
	LH	R2,XPOWER,XD		:IF CHANGING, MUST HAVE POWER	###TZ
	JG	XPWERR,,		:NOPE, NOT AUTHORIZED		###TZ
	NHI	R3,303
	STH	R3,CRACTN,,
XCROP1	LB	R3,CRACTN,,
	SLLS	R3,3
	LA	R2,XCROPM,R3
	JAL	R7,TYPASC
	JAL	R7,TYP2SP
	LB	R3,CRACTN+1,,
	SLLS	R3,3
	LA	R2,XCROPM,R3
	JAL	R7,TYPASC
	J	XRCRLF,,
	SLLS	R3,3			:FORM TWO-WORD INDEX
	LA	R2,XCROPM,R3		:GET CURRENT MODE
	JAL	R7,TYPASC
	J	XRCRLF,,

	EI	:(XRSZLV)		:##AL

	IF	(XRSZLV-1)		:##AL
::*********************************************************************
::
::	COMMAND:	XRYPFM:	PM
::	FUNCTION:	PERFORMANCE MONITORING ROUTINE FOR USER CHANNELS
::	INPUT:		ACCEPTS A TERMINATING CHANNEL NUMBER
::
::*********************************************************************

:	SENDS 16 XLAXS AND TIMERS TOWARDS THE OTHER END, AND COMPUTES THE
:	AVERAGE ROUND-TRIP DELAY WHEN THE XLAX ACKS AND TIMER ACKS RETURN

	NOLIST
XRYPM1	SC	/"0AROUND TRIP DELAY (MS)   TIMER : /
XRYPM2	SC	/  XLAX : /
XRYPM3	SC	/"0ABAD CHANNEL OR TIMEOUT"0D"0A/
	LIST

XRYPFM	HS	0
	CLHI	R3,LNKZFL		:R3 IS CHAN NUMBER, CHECK RANGE
	JGE	XRYPFR			:ONLY LEGAL FOR TERMINATING CHANNELS
	LHL	R2,IOTAB,R3,R3		:GET BUFFER NUMBER
	JE	XRYPFR			:ERROR, NO CIRCUIT THERE
	NHI	R2,-4			:STRIP SPEED BITS

	LR	R13,R3			:SAVE CHANNEL NUMBER IN R13
	LHL	R5,BF,R2,		:GET CHANNEL ON OUT SIDE
	JAL	R8,CHNLNK		:RETURNS NEIGHBOR ON OUT CHANNEL
	SKIPAD(XRYPFR)			:IMMEDIATE RETURN--NO NEIGHBOR	###wjl
	SKIPAD(XRYPFR)			:+4 RETURN--INTERNAL TERMINATION###wjl
					:+8 RETURN--NEIGHBOR NUMBER IN R3##TZ
	LIS	R10,0			:ACCUMULATOR FOR TIMERS 	###TZ
	LIS	R11,0			:CLEAR R11 (ACCUMULATOR FOR XLAXS) 
	LIS	R14,0F			:DO 16 TIMES
XRYPFL	LIS	R0,0
:	XLAX'S AND TIMERS ARE SENT OUT IN PAIRS	##TZ
	ST	R0,ARRIVX		:CLEAR TIME-OF ARRIVAL CELLS
	ST	R0,ARRIVT		:CLEAR TIME-OF ARRIVAL CELLS

	LHL	R2,IOTAB,R13,R13	:GET BUFFER NUMBER
	JE	XRYPFR			:SOMETHING WRONG, NO CHANNEL

	JAL     R7,XRPF02 		:write xlack/timer

XRYPF2  CLI     XD,TTYXD  		:tty user?
	JNFS    XRYPF3    		:no, a remote user
	SVC     DISMIS    		:wait for it to arrive
	JFS     XRYPF4
XRYPF3	JAL	R0,XRYYLD,,		:AND YIELD TO EXEC LOOP
XRYPF4	L	R9,XREGSV,XD		:RECOVER TIME OF ORIGINAL STARTUP
	L	R3,ARRIVT		:HAS A TIMER ACK RETURNED?
	JNFS	XRYPFA			:YES, GO PROCESS DATA
	L	R3,FASTC,,		:NO, HAVE WE TIMED OUT?
	SR	R3,R9			:COMPUTE DELTA TIME SINCE STARTUP
	CLHI	R3,18C0			:ALLOW APPROX 12 SECONDS PER TRIP###OAS
	JG	XRYPFR			:ERROR, TIMED OUT
	J	XRYPF2			:STILL TICKING, DISMISS AND RETRY
XRYPFA	HS	0
	L	R3,ARRIVX		:WE GOT TIMER ACK,BETTER HAVE XLACK##TZ
	JE	XRYPFR			:SOMETHINGS WRONG		###TZ
	LM	R10,XREGSV+4,XD		:RECOVER REGISTERS
	SR	R3,R9			:GET TRAVEL TIME XLAX
	AR	R11,R3			:ACCUMULATE IN R11
	L	R3,ARRIVT		:TIMER ACK TIME			##TZ
	SR	R3,R9			:TRAVEL TIME TIMER		##TZ
	AR	R10,R3			:ACCUM TIMER TIME IN R10	##TZ
	SIS	R14,1			:DO THIS 16 TIMES
	JGE	XRYPFL			:MORE LEFT

	LA	R2,XRYPM1		:DONE FOR BOTH TIMER AND XLAX
	JAL	R7,TYPASC		:HEADER
	LHI	R12,$A10
	LR	R2,R10			:GET TIMER (IN R10) TIME	##TZ
	DHR	R2,R12			:AVERAGE AND GO DECIMAL...	##TZ
	JAL	R9,TYPHWD
	LA	R2,XRYPM2		:HEADER
	JAL	R7,TYPASC
	LR	R2,R11			:GET XLAX TIME (IN R11)
	DHR	R2,R12			:AVERAGE AND GO DECIMAL		##TZ
	JAL	R9,TYPHWD		:DISPLAY
	J	XRCRLF,,		:RETURN TO LOOP

XRYPFR	LA	R2,XRYPM3
	JAL	R7,TYPASC		:TYPE ERROR MESSAGE OUT
	J	XRCRLF,,


:       Subroutine to handle writting of XLACK/timer since if xddt then
:       job collision sensitive.
XRPF02  CLI     XD,TTYXD  		:tty user?
	JN      XRPF04    		:nope
	LA      R8,XRPF07 		:
	ST      R8,XDDTAD 		:Address of task being passed to BG
	STM     R0,XDDTSV 		:save registers
	JAL     R8,XDDTWT 		:wait until BG finishes task
	JR      R7        		:and return
XRPF04  JAL     R8,XRPF08 		:just call subroutine
	JR      R7        		:and return

XRPF07  ST      R8,XDDTSV+4*R8  	:save link so get it back when LM
	LM      R0,XDDTSV 		:get back XDDT's regs
XRPF08  ST      R8,XRPFS1 		:store link register
	NHI	R2,-4			:STRIP SPEED BITS
	L	R9,FASTC,,		:GET CURRENT TIME

	LIS	R1,3			:FORM '03'
	JAL	R8,WCI,,		:TIMER, WRITE IN '03'
	LHI	R1,TIMER		:AND TIMER
	JAL	R8,WCI,,

	LHI	R1,XLAX			:XLAX, GET XLAX
	JAL	R8,WCD,,		: AND PREFIX IT IN
	LIS	R1,03
	JAL	R8,WCD,,		:PREFIX THE '03'

	STM	R9,XREGSV,XD		:SAVE REGISTERS
	L       R8,XRPFS1 		:get link register
	JR      R8        		:return from collision sensitive code

	EI	:(XRSZLV-1)		:##AL

	SUBTTL	XRAY (UPSW trace option - TR, TT)

	IF	(XRSZLV-2)		:##AL

	IF	DB.TRC			:OPTION(UTRC) in Tymfile	###wjl

::*********************************************************************
::
::	COMMAND:	XTRACE:	TR
::	FUNCTION:	TURNS UPSW TRACER OFF (IF NO ARGUMENTS)
::			OR ON (FOR RANGE ARG1 - ARG2).  IF ARG1=ARG2=0,
::			TRACE IS ON FOR ALL OF MEMORY.
::
::*********************************************************************

XTRACE	HS	0
	LR	R2,R2			:ANY ARGUMENTS?
	JG	XTRAC0			:YES

					:REQUEST TO TURN TRACER OFF
	LH	R1,TRCRRQ,,		:IS TRACER ON?
	JL	XTROFF			:YES, GO TURN IT OFF

	JAL	R7,TYPASI			:TRACER NOT ON...
	SC	/TRACER NOT ON/		:...COMPLAIN
	J	COMERR,,

XTRAC0	HS	0			:REQUEST TO TURN ON TRACER
	LH	R1,TRCRRQ,,		:IS TRACER ON?
	JGE	XTRON			:NO, GO TURN IT ON

	JAL	R7,TYPASI			:TRACER ALREADY ON...
	SC	/TRACER ALREADY ON/
	J	COMERR,,

XTRON	HS	0		:VALIDATE REQUEST TO TURN SPECIAL TRACER ON
	SIS	R2,4			:ONE ARGUMENT?
	JE	XTRON0			:YES, OK

	SIS	R2,4			:MORE THAN 2 ARGUMENTS?
	JE	XTRON1			:NO, OK

	JAL	R7,TYPASI			:TOO MANY ARG'S...
	SC	/TOO MANY ARG'S/	:...COMPLAIN
	J	COMERR,,

XTRON0	HS	0			:ONLY 1 ARG
	LI	R5,0DFFFE		:DEFAULT UPPER LIMIT
	JFS	XTRON2

XTRON1	HS	0			:VALIDATE 2 ARGUMENTS
	L	R5,VALUE1+4,XD		:2ND ARGUMENT
XTRON2	HS	0			:2ND ARGUMENT IS IN R5
	L	R3,VALUE1,XD		:GET 1ST ARGUMENT
	CR	R3,R5			:R3 MUST BE < R5
	JL	XTRON3

	JAL	R7,TYPASI			:1ST ARG >= 2ND ARG...
	SC	/RANGE ERROR/		:...COMPLAIN
	J	COMERR,,

XTRON3	HS	0			:R3= LOWER LIMIT, R5= UPPER LIMIT
	ST	R3,TRCBEG,,		:SET TRACER LOWER LIMIT
	JAL	R7,TYPASI	
	SC	/TRACER ON FOR RANGE: /
	JAL	R9,TYPFW		:LOWER LIMIT
	LR	R3,R5			:GET UPPER LIMIT TO R3
	ST	R3,TRCEND,,		:SET TRACER UPPER LIMIT
	JAL	R9,TYPFW		:AND TYPE IT

	LHL	R1,EXEPSW+2,,		:GET CURRENT STATE OF TRACER BIT IN PSW
	STH	R1,EXPSSV		:SAVE IT
	LHI	R1,1000			:TURN TRACER ON NEXT EXEC LOOP TOP...
	STH	R1,EXEPSW+2,,		:...AND...
	STH	R1,TRCRRQ,,		:...FORCE TRACER OFF FOR NOW (TRCRRQ>0)
:	CLEAR TRACER TABLE
	LA	R1,TRCTAB,,		:DESTINATION ADDRESS FOR HCLEAR
	LHI	R2,TRTBSZ/2		:HW SIZE OF TRACER TABLE
	JAL	R8,HCLEAR,,		:CLEAR IT
	STH	R0,TRNDEX,,		:SET TRACER INDEX TO 0
	TS	TRCRRQ,,		:TELL TRACER SPECIAL REQUEST
	J	XPRMPT,,		:DONE

XTROFF	HS	0			:TURN SPECIAL TRACER OFF
	LIS	R3,1			:FORCE TRACER OFF...
	STH	R3,TRCRRQ,,		:... UNCONDITIONALLY
	JAL	R7,TYPASI
	SC	/TRACER INDEX: /	:HEADER INFORMATION
	LHL	R3,TRNDEX,,		:GET THE INDEX
	JAL	R9,TYPHW		:TYPE IT
	JAL	R7,TYPASI
	SC	/RANGE: /		:RANGE
	L	R3,TRCBEG,,		:RANGE LOWER LIMIT
	JAL	R9,TYPFW
	L	R3,TRCEND,,		:UPPER LIMIT
	JAL	R9,TYPFW
	JAL	R7,TYPCRL		:TYPE CR/LF

:	COPY CONTENTS OF TRACER TABLE TO SAVE AREA
	LA	R0,TRCTAB+(TRTBSZ-2),,	:ADDRESS OF LAST SOURCE HW
	LA	R1,TRSTAB+(TRTBSZ-2),,	:ADDRESS OF LAST DESTINATION HW
	LHI	R2,(TRTBSZ/2-1)*10	:AMOUNT TO COPY
	COPY	R0,R2			:COPY IT

:	RESTORE ORIGINAL STATE OF TRACE BIT AND ENABLE NORMAL TRACER
	LIS	R0,0
	STH	R0,TRCRRQ,,		:LET TRACER GO
	LHL	R0,EXPSSV		:GET ORIGINAL STATE OF TRACE BIT
	STH	R0,EXEPSW+2,,		:RESTORE
:	OUTPUT TRACER TABLE
	LIS	R0,8			:SET UP FOR TYPE0
	STH	R0,ARGCT,XD		:ARG COUNT = 2
	LA	R0,TRSTAB,,		:START ADDRESS
	ST	R0,VALUE1,XD		:1ST ARG
	LHI	R0,TRTBSZ		:NO. OF BYTES
	ST	R0,VALUE1+4,XD		:2ND ARGUMENT
	JAL	R12,TYPE0,,		:PRINT OUT THE TRACER TABLE
	J	XPRMPT,,

::*********************************************************************
::
::	COMMAND:	TYPTRC:	TT
::	FUNCTION:	WITH NO ARGUMENT:  IDENTICAL TO R C0800,100
::			WITH 1 ARGUMENT :  TYPES OUT THE LAST N JUMP ADDRESSES
::
::*********************************************************************

TYPTRC	HS	0
	LI	R0,TRSTAB
	LR	R2,R2			:ZERO ARGS?
	JNFS	TYPTR1			:NO
	ST	R0,VALUE1,XD
	LHI	R0,TRTBSZ
	ST	R0,VALUE1+4,XD
	JFS	TYPTR2
TYPTR1	L	R1,VALUE1,XD		:NUMBER OF JUMPS TO DISPLAY
	SLLS	R1,1			:TWO BYTES PER ENTRY
	ST	R1,VALUE1+4,XD		:STORE IN COUNT FIELD
	SR	R0,R1
	AHI	R0,TRTBSZ		:STARTING ADDRESS
	ST	R0,VALUE1,XD
TYPTR2	LIS	R0,8
	STH	R0,ARGCT,XD
	J	TYPE,,

	EI	:DB.TRC


	SUBTTL	XRAY (Miscellaneous - SS, BS)

::*********************************************************************
::
::	COMMAND:	XSIOST:	SS
::	FUNCTION:	DISPLAY SIO LINE STATUS
::
::*********************************************************************

	IF	SILINS
	IF	HMICRO		:display four halfwords for HDLC MICRO
XSIOH1	SC	/"0D"0ALN  MBOARD        REG0            REG1      IDL CRC HDLC  A R I T Rx  TIME OF/
XSIOH2	SC	/"0D"0ANO  NO  PO  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 LIN ERR ABRT  1 C L C OVR INTERUPT"0D"0A/
	ELSE	:ENGINE		:display three halfwords for engine
XSIOH1	SC	/"0D"0ALN  MBOARD        REG0            REG1      IDL CRC HDLC  A R I T TIME OF/
XSIOH2	SC	/"0D"0ANO  NO  PO  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 LIN ERR ABRT  1 C L C INTERUPT"0D"0A/
	EI	:HMICRO

       IF       1-T2GATE  		:NOT FOR GATEWAY
XSIOTA  HS      0
Q       EQ      NLINES-SILINS
	RE      SILINS
	BC      (0ff&S0L|$Aq|)
Q       EQ      Q+1
	ER
	hs      0
       EI       :T2GATE

XSIOST	HS	0
	LR	R2,R2			:zero args?
	JNFS	XSIO02			:no
	LHI	R12,SILINS		:counter
	LIS	R14,0			:relative SIO line number
	J	XSIO04
XSIO02	JAL	R9,DECHEX		:convert line number to hex
					:J to DHXBAD for bad radix
	LR	R14,R3			:save line number
	CLHI	R14,NLINES
	JGE	COMERR,,		:too big to be a line number
	SHI	R14,NLINES-SILINS	:compute relative SIO line number
	JL	COMERR,,		:to small for SIO line
	SLLS	R14,4			:line number*10x
	LIS	R12,1			:counter
XSIO04	LA	R11,SIOSTT,,		:pointer to SIO status blocks
	LA	R2,XSIOH1
	JAL	R7,TYPASC		:type header 1
	LA	R2,XSIOH2
	JAL	R7,TYPASC		:type header 2

XSIOLN	LR	R3,R14
	SRLS	R3,4			:relative SIO line number
	AHI	R3,NLINES-SILINS	:compute absolute line number
	JAL	R9,TYPBYD		:display line number
	srls    r14,4     		:line # times 1
	LB      R3,XSIOTA,R14
	SRLS    R3,4      		:mother board number
	ohi     r3,$a 80  		:mboard 0 has address 80
	JAL     R9,TYPBYD
	LB      R3,XSIOTA,R14
	slls    r14,4     		:back to line # *10
	NHI     R3,0F     		:line on the board
	jal     r9,typbyd
	LHL	R3,SS.REG,R11,R14
	LHI	R4,10			:set up number of bits
	JAL	R9,TYPBIT		:display SIO read REGs 0 and 1
	LB	R3,SS.IDL,R11,R14
	JAL	R9,TYPBYT		:display idle line counter
	LB	R3,SS.CRC,R11,R14
	JAL	R9,TYPBYT		:display CRC error counter
	LHL	R3,SS.ABR,R11,R14
	SRLS	R3,4			:isolate HDLC abort counter
	JAL	R9,TYPHW		:display HDLC abort counter
	LHL	R3,SS.ABR,R11,R14
	SLLS	R3,0C			:shift bits 44-47 into position
	LIS	R4,4			:set up number of bits
	JAL	R9,TYPBIT		:display bits 44-47	
	IF	HMICRO			:HDLC MICRO-engine only
	LB	R3,SS.HM1,R11,R14
	JAL	R9,TYPBYT		:display receive overrrun counter
	EI	:HMICRO

	l       r3,0a,r11,r14   	:time of interupt
	jal     r9,typfw

	JAL	R7,TYPCRL		:CR-LF
	AHI	R14,10			:advance line pointer
	SIS	R12,1			:decrement counter
	JG	XSIOLN			:keep displaying
	J	XRCRLF,,		:return
	ELSE	:NO SILINS
XSIOST	LA	R2,BADCON,,
	JAL	R7,TYPASC		:TYPE OUT ERROR MESSAGE
	J	XRCRLF,,		:AND RETURN
	EI	:SILINS

::*********************************************************************
::
::	COMMAND:	XBUFLT:	BS
::	FUNCTION:	DISPLAYS HISTOGRAMS OF BUFFERLET USE
::	DATA DISPLAYED REPRESENTS BYTES IN ALLOCATED BUFFERLETS
::	IF TERMINATED WITH 'Z', CLEARS OUT HISTOGRAMS AND MAX COUNTER
::
::*********************************************************************

	NOLIST
	IF	REBILD
XBUFH0	SC	/"0D"0ABUFFER STATUS (BYTES):/
XBUFH3	SC	/"0D"0A            TOTAL    TOTAL   HISTORY  HISTORY   TOTAL/
XBUFH4	SC	/"0D"0A   BUFFERS  IN USE    PEAK    IN USE    PEAK  AVAILABLE  ZAPS"0D"0A  /
	ELSE	:REBILD
XBUFH0	SC	/"0D"0ABUFFER STATUS (BYTES):"0D"0A    TOTAL   IN USE    PEAK   AVAILABLE  ZAPS"0D"0A  /
	EI	:REBILD

XBUFH1	SC	/"0A"0D"0ARANGE	COUNT(HEX)"0A"0D"0A/
	LIST

:	SIX DIFFERENT DISPLAYS ARE POSSIBLE, DEPENDING UPON HOW MANY
:	BUFFERLETS THE NODE IS CONFIGURED FOR. THIS INFORMATION IS
:	CONTAINED IN THE VARIABLE 'ISCALE'

XBUFH2	HS	$A42			:ACTUAL DISPLAY DEFINED IN FIN FOR NAD

XBUFLT	HS	0
	CLHI	R1,ASCZ			:DID USER CLOSE WITH 'Z'(x5A)?
	JE	XBUFLZ			:YES, GO INITIALIZE
	LA	R2,XBUFH0		:TYPE FIRST HEADERS		###OAS
	JAL	R7,TYPASC

	IF	REBILD

	LA	R2,XBUFH3		:TYPE FIRST HEADERS		###OAS
	JAL	R7,TYPASC
	LA	R2,XBUFH4		:TYPE FIRST HEADERS		###OAS
	JAL	R7,TYPASC


	EI	:REBILD

	LI	R3,NBFLE2		:CONFIGURED NUMBER OF BUFFERLET BYTES
	GL	NBFLE2
	LR	R10,R3			:SAVE
	JAL	R9,TYPFWD		:TYPE OUT CONFIGURED NUMBER OF BYTES
	L	R3,BFLTSV		:CURRENT COUNT
	SR	R10,R3			:GET NUMBER OF BYTES AVAILABLE
	JAL	R9,TYPFWD		:TYPE NUMBER OF BYTES CURRENTLY IN USE
	L	R3,BFLTMX
	JAL	R9,TYPFWD		:TYPE MAX NUMBER OF BYTES EVER IN USE

	IF	REBILD
	L	R3,HBFTSV		:GET CURRENT HISTORY BUFFER USAGE##OAS
	JAL	R9,TYPFWD
	L	R3,HBFTMX		:GET PEAK HISTORY BUFFER USAGE	###OAS
	JAL	R9,TYPFWD
	EI	:REBILD

	LR	R3,R10
	JAL	R9,TYPFWD		:TYPE NUMBER OF BYTES STORAGE LEFT
	JAL	R7,TYP2SP		:TYPE TWO SPACES
	LHL	R3,BZAPCT		:GET NUMBER OF BUFFER ZAPS TO DATE...
	JAL	R9,TYPHWD		:AND DISPLAY IN DECIMAL
	LA	R2,XBUFH1		:SECOND HEADER
	JAL	R7,TYPASC
	LIS	R10,0			:DO FOR 'NSTEPS' SAMPLES HISTOGRAM DATA
	LHI	R11,$A(8-1)*10		:FORM STARTING INDEX FOR HEADER
XBUFL2	L	R3,BFLTHG,R10		:READ ONE DATA VALUD
	LA	R2,XBUFH2,R11		:GET APPROPRIATE HEADER
	JAL	R7,TYPASC		:TYPE TEXT
	JAL	R7,TYP2SP		:TYPE TWO SPACES
	JAL	R9,TYPFW		:AND HEX DATA
	JAL	R7,TYPCRL
	SIS	R11,0A			:GET NEXT HEADER
	AIS	R10,4
	CLHI	R10,(NSTEPS-1)*4	:DO FOR 'NSTEPS' VALUES
	GL	NSTEPS
	JLE	XBUFL2			:MORE LEFT
	J	XPRMPT,,		:###jhl

XBUFLZ	LIS	R0,0			:CLEAR ALL VALUES
	ST	R0,BFLTMX		:CLEAR TOTAL BUFFER USAGE
	STH	R0,BZAPCT

	IF	REBILD
	ST	R0,HBFTMX		:CLEAR HISTORY PEAK BUFFER USAGE###OAS
	EI	REBILD

	LHI	R10,$A4*7
XBFLE2	ST	R0,BFLTHG,R10
	SIS	R10,4
	JGEBS	XBFLE2
	J	XPRMPT,,		:###jhl

	SUBTTL	XRAY (Dump dispatcher rings - DR, DS)

::*********************************************************************
::
::	COMMANDS:	DRINGS:/DSRNGS:	DR/DS			###wjl
::	FUNCTION:	IRING/ORING DUMP ROUTINE
::	INTERPRETS THE ISIS MESSAGE TYPE AND DUMPS THE CONTENTS IN HEX
::	AND ASCII.  MAKES A GUESS AT THE FIRST MESSAGE IN THE RING.
::	'DR' DUMPS DISPATCHER RINGS, 'DS' DUMPS RINGS SAVED AFTER A CRASH.
::
::*********************************************************************
       IF       1-NCSLOT


::	IRING/ORING TRACE MESSAGES AND TABLES
:	-------------------------------------
SIAASC	AC	/0123456789ABCDEF/
M.I	SC	/I /
M.O	SC	/O /
XDRMS4	SC	/NDL/			:NEEDLE
XDRMS3	SC	/DTA/			:DATA
XDRASC	SC	/  *                */	:ASCII MESSAGE DUMP STORAGE

	BND	2
XDRECH	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
XDRVL	HC	0082,6000		:VARIABLE LENGTH MESSAGE FLAGS

::	ISIS CONTROL MESSAGES
:	---------------------
	BND	2
XDRICA	HS	0
	SC	/DET/		:DETACH MESSAGE TYPE
	SC	/ZAP/		:DISCONNECT MESSAGE
	SC	/NOS/		:APPLY BACK-PRESSURE (NO SEND)
	SC	/SND/		:RELEASE BACK-PRESSURE (SEND)
	SC	/ICM/		:FLUSH OUTPUT (GOBBLER)
	SC	/BKG/		:FLUSH INPUT (BACK GOBBLER)
	SC	/BLK/		:DATA LOST IN THIS DIRECTION (BLACK BALL)
	SC	/GRY/		:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	SC	/EDE/		:ENTER DEFERED ECHO MESSAGE
	SC	/LDE/		:LEAVE DEFERED ECHO MESSAGE
	SC	/ETM/		:ENTER TRANSPARENCY MODE
	SC	/LTM/		:LEAVE TRANSPARENCY MODE
	SC	/GB /		:GREEN BALL
	SC	/RB /		:RED BALL
	SC	/YB /		:YELLOW BALL
	SC	/OB /		:ORANGE BALL
	SC	/BRK/		:BREAK DETECTED
	SC	/HNG/		:HANG UP
	SC	/QTP/		:QUERY TERMINAL PARAMETER
	SC	/STP/		:SET TERMINAL PARAMETER
	SC	/PSN/		:PSEUDO NEEDLE
	SC	/NLC/		:NORMAL LOGON CHAR
	SC	/NLS/		:NORMAL LOGON STATUS
	SC	/LOF/		:LOG ON FAILURE
	SC	/NCC/		:NORMAL CIRCUIT COMPLETE
	SC	/ADA/		:ADDENDUM TO ACCOUNTING
	SC	/SHG/		:SUPER-HANG UP
	SC	/TLM/		:SET TRANSMIT LIMIT
	SC	/EBK/		:END OF BREAK
	SC	/ZAK/		:ZAP ACK
	SC	/EAO/		:ENTER ALTERNATE OUTPUT DEVICE MODE
	SC	/LAO/		:LEAVE ALTERNATE OUTPUT DEVICE MODE
	SC	/ZAR/		:ZAP WITH REASON
	SC	/SIX/		:START INTERFACE INFORMATION EXCHANGE
	SC	/TIX/		:TERMINATE INTERFACE INFORMATION EXCHANGE
	SC	/UUN/		:UUN msg
	SC      /ISN/   	:Log II Needle
	SC      /RCR/   	:Log II logon status
	SC      /ICR/   	:Log II logon data (C4)
	SC      /ASL/   	:Log II assign logon port
	SC      /LGS/   	:Log II logon success
	SC      /***/   	:text when displaying unknown msgs
	          		:last defined msg is C6                 ###sdw

::	ISIS CONTROL MESSAGE LENGTHS
:	----------------------------
	BND	2
XDRILA	HS	0
	BC	3		:DETACH MESSAGE TYPE
	BC	3		:DISCONNECT MESSAGE
	BC	3		:APPLY BACK-PRESSURE (NO SEND)
	BC	3		:RELEASE BACK-PRESSURE (SEND)
	BC	3		:FLUSH OUTPUT (GOBBLER)
	BC	3		:FLUSH INPUT (BACK GOBBLER)
	BC	3		:DATA LOST IN THIS DIRECTION (BLACK BALL)
	BC	3		:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	BC	3		:ENTER DEFERED ECHO MESSAGE
	BC	3		:LEAVE DEFERED ECHO MESSAGE
	BC	3		:ENTER TRANSPARENCY MODE
	BC	3		:LEAVE TRANSPARENCY MODE
	BC	3		:GREEN BALL
	BC	3		:RED BALL
	BC	3		:YELLOW BALL
	BC	3		:ORANGE BALL
	BC	3		:BREAK DETECTED
	BC	3		:HANG UP
	BC	4		:QUERY TERMINAL PARAMETER
	BC	5		:SET TERMINAL PARAMETER
	BC	6		:PSEUDO NEEDLE
	BC	3		:NORMAL LOGON CHAR (hide logon char)    ###sdw
	BC	4		:NORMAL LOGON STATUS
	BC	4		:LOG ON FAILURE
	BC	0A		:NORMAL CIRCUIT COMPLETE
	BC	8		:ADDENDUM TO ACCOUNTING
	BC	3		:SUPER-HANG UP
	BC	4		:SET TRANSMIT LIMIT
	BC	3		:END OF BREAK
	BC	3		:ZAP ACK
	BC	3		:ENTER ALTERNATE OUTPUT DEVICE MODE
	BC	3		:LEAVE ALTERNATE OUTPUT DEVICE MODE
	BC	4		:ZAP WITH REASON
	BC	3		:START INTERFACE INFORMATION EXCHANGE
	BC	3		:TERMINATE INTERFACE INFORMATION EXCHANGE
	BC      8 		:UUN msg                                ###sdw
	BC      0 		:Log II Needle (C2)                     ###sdw
	BC      0 		:Log II RCRI (C3)
	BC      0 		:Log II ICRS (C4)
	BC      8 		:Log II ASLP (C5)
	BC      0 		:Log II LGSC (C6)
	          		:all of the log II msgs with len 0 are variable
L.ISCT  EQ      .-XDRILA	:how many valid messages

::	INTRANODE MESSAGES
:	-------------------
	BND	2
XDRICB	HS	0
	SC	/RQR/		:RESTART REQUEST
	SC	/RST/		:RESTART INTERFACE
	SC	/NTO/		:NODE HAS BEEN TAKEN OVER
	SC	/REP/		:REPORT TO SUPERVISOR'S LOG
	SC	/RHS/		:REPORT HOST STATUS (OBSOLETE)
	SC	/RAC/		:REPORT ACCOUNTING
	SC	/TIM/		:GMT TIME
	SC	/RNP/		:REQUEST FOR NORMAL PSEUDO NEEDLE
	SC	/RAP/		:REQUEST AUX PSEUDO-NEEDLE
	SC	/PSR/		:PSEUDO-NEEDLE REJECTED
	SC	/HPA/		:HOST PORT AVAILABILITY
	SC	/HNA/		:HOST NOT ACCEPTABLE
	SC	/RHC/		:REPORT HOST COST
	SC	/NSU/		:NO SUPERVISOR
	SC	/ODN/		:1-DOWN TEXT
	SC	/RAH/		:REPORT ALL HOSTS
	SC	/HSR/		:HOST STATUS REPORT
	SC	/CRM/		:Log II Circuit Request Msg          ###sdw
	SC	/ECR/		:Log II Reject Request Msg          ###sdw
	SC      /***/   	:text for unknown message

::	INTRANODE MESSAGE LENGTHS
:	-------------------------
	BND	2
XDRILB	HS	0
	BC	3		:RESTART REQUEST
	BC	3		:RESTART INTERFACE
	BC	4		:NODE HAS BEEN TAKEN OVER
	BC	9		:REPORT TO SUPERVISOR'S LOG
	BC	0C		:REPORT HOST STATUS (OBSOLETE)
	BC	8		:REPORT ACCOUNTING
	BC	8		:GMT TIME
	BC	0B		:REQUEST FOR NORMAL PSEUDO NEEDLE
	BC	0A		:REQUEST AUX PSEUDO-NEEDLE
	BC	7		:PSEUDO-NEEDLE REJECTED
	BC	0A		:HOST PORT AVAILABILITY
	BC	07		:HOST NOT ACCEPTABLE
	BC	0A		:REPORT HOST COST
	BC	3		:NO SUPERVISOR
	BC	0A		:1-DOWN TEXT
	BC	3		:REPORT ALL HOSTS
	BC	0E		:HOST STATUS REPORT
	BC	4 		:ICRM
	BC      4 		:ECRI
MAXINM  EQ      .-XDRILB

::	UTILITY SUBROUTINE:	XDTPUT
::	OUTPUT A BYTE AS 2 DIGITS
:	-------------------------
:	CALLING SEQ:	JAL	R11,XDTPUT
:	INPUT:		R4  = BYTE TO BE OUTPUT
:			R12 = BYTE COUNTER
:	PRESERVED:	R4,R5
:	DESTROYED:	R0, R1, R2, R4, R7, R13
XDTPUT	HS	0
	LBR	R1,R4			:COPY IT
	LR	R7,R1			:COPY AGAIN
	SRHLS	R1,4			:LEFT NIBBLE
	LB	R1,SIAASC,R1		:CONVERT TO ASCII
	JAL	R13,XRYOUT		:PUT IT OUT
	NHI	R7,0F			:RIGHT NIBBLE
	LB	R1,SIAASC,R7		:CONVERT TO ASCII
	JAL	R13,XRYOUT		:PUT IT OUT
	THI	R13,1			:EVERY OTHER BYTE, PUT OUT EXTRA SPACE
	JER	R11			:IF EVEN
	JAL	R7,TYP1SP		:PUT IT OUT
	JR	R11			:RETURN

::	ENTRY POINTS:	DSRNGS/DRINGS
::	DUMP I/O RINGS
:	--------------
NFMI	EQ	0			:OFFSET TO NEXT FILL MESSAGE INDEX
RING	EQ	4			:OFFSET TO THE RING ITSELF
RR	EQ	0E			:REGISTER FOR ADDRESS OF RING
RS	EQ	3			:REGISTER FOR RING SIZE

DSRNGS	HS	0			:ENTRY POINT FOR DS COMMAND
	LH	R0,DIRSAV,,		:INITED TO -1, IF NO CRASHES YET
	JL	COMERR,,		:RETURN WITH ??
	LA	R1,DIRSAV+DRSZ+2,,	:ADDRESS OF DIRSAVS END TO R1
	LA	R4,DORSAV+DRSZ+2,, 	:ADDRESS OF DORSAVS END TO R4
	JFS	XDR010
DRINGS	HS	0			:ENTRY POINT FOR DR COMMAND
	LA	R1,DIRING+DRSZ+2,, 	:ADDRESS OF DIRINGS END TO R1
	LA	R4,DORING+DRSZ+2,, 	:ADDRESS OF DORINGS END TO R4
XDR010	LA	R2,IRING+DRSZ+2,,  	:ADDRESS OF DESTINATION END TO R1+1
	LHI	R3,10*(DRSZ/2+1)   	:10*(NUMBER OF HW'S -1)
	COPY	R1,R3		   	:COPY IRING TO DATA STORAGE
	LA	R5,ORING+DRSZ+2,,  	:ADDRESS OF DESTINATION END TO R4+1
	LHI	R3,10*(DRSZ/2+1)   	:COUNTER FOR COPY INSTRUCTION
	COPY	R4,R3		   	:COPY ORING
XDR020	LA	RR,IRING,,		:HANDLE IRING
	LHI	RS,DRSZ-1		:RING SIZE
	LIS	R7,0			:INIT COUNTER FOR EMPTY RING CHECK
	LH	R8,NFMI,RR		:GET CURRENT POINTER, USE OLDEST ENTRY
	JAL	R10,BEGMSG		:GUESS AT FIRST MESSAGE
	JAL	R7,TYPCRL,,		:TYPE CR/LF
	J	XDR0A4

XDR090	AIS	R8,3			:ROUND UP TO FULL WORD
	NHI	R8,-4			:AND I.E., NEXT MESSAGE
	NR	R8,RS			:TO END OF RING ??
	JAL	R7,TYPCRL,,		:CR LF
XDR0A1	CLH	R8,NFMI,RR		:CAUGHT UP ?
	JN	XDR0A4			:NOT YET
	CLI	RR,IRING		:SEE IF JUST FINISHED IRING
	JN	XDR0FF			:FINISHED!

	LA	RR,ORING,,		:GET SET TO DO ORING
	LHI	RS,DRSZ-1		:RING SIZE
	LIS	R7,0			:REINITIALIZE COUNTER
	LH	R8,NFMI,RR		:USE OLDEST ENTRY
	JAL	R10,BEGMSG		:GUESS AT FIRST MESSAGE
:	J	XDR0A1	:GO DO IT bug if NFMI points to valid msg ###sdw

XDR0A4	CLI	RR,ORING		:IS THIS THE ORING?
	JEFS	XDR0A6			:JUMP IF SO, ELSE
	LA	R2,M.I	 		:OUTPUT "I "
	JFS	XDR0A8
XDR0A6	LA	R2,M.O	 		:OUTPUT "O "
XDR0A8	JAL	R7,TYPASC
	LB	R9,RING+2,R8,RR		:GET MESSAGE CODE
	LHL	R10,RING,R8,RR		:GET PORT #
	JE	XDR0C0			:IF INTRANODE MESSAGE
	LR	R9,R9			:CHECK FOR NEEDLE
	JE	XDR0F0			:IF SO
	CLHI	R9,9E			:DATA MESSAGE ??
	JL	XDR0B0			:IF SO
	SHI	R9,9E			:BIAS TO 0
	CLHI	R9,L.ISCT		:CHECK MAX MSG TYPE
	JLE	XDR0A9			:IF OK
	LHI	R9,L.ISCT+1		:GET "UNDEFINED" MESSAGE
XDR0A9	LR	R4,R9			:FOR INDEXING	
	SLHLS   R4,2
	LA	R2,XDRICA,R4   		:ASCII MESSAGE LABEL
	JAL	R7,TYPASC		:TYPE IT
	JAL     R7,TYP1SP 		:and a space
	LB      R6,XDRILA,R9    	:Get len
	JEFS    XDR0AB    		:0 means variable len LOG II msgs
XDR0AA  JAL     R10,XDRISE
	J	XDR090			:GO TO NEXT MESSAGE
XDR0AB  LR      R4,R8     		:get len of variable len msg
	AIS     R4,4
	NR      R4,RS     		:handle wrap
	LHL     R6,RING,RR,R4   	:get len
	AIS     R6,6      		:len of LEN and header
	CLHI    R9,0C4    		:if ICRS then hide UNAME/PW
	JN      XDR0AA    		:just go print it
	LR      R5,R6
	SIS     R5,8
	LIS     R6,8      		:only show first 8 bytes of ICRS
	JAL     R10,XDRISE
	AR      R6,R5
	J       XDR090

XDR0B0	LA	R2,XDRMS3		:"DATA" MESSAGE HEADER
	JAL	R7,TYPASC		:TYPE IT
	JAL	R10,XDRISA		:GO DUMP ISIS DATA MSG
	J	XDR090			:GO TO NEXT MESSAGE

:       here for PORT 0 msg
XDR0C0	CLHI	R9,MAXINM		:CHECK MAX MSG TYPE
	JLE	XDR0C1			:IF OK
	LHI	R9,MAXINM+1		:GET "UNDEFINED" MESSAGE
XDR0C1	LR	R4,R9			:FOR INDEXING
	SLHLS   R4,2
	LA	R2,XDRICB,R4    	:ASCII MESSAGE LABEL
	JAL	R7,TYPASC		:TYPE IT
	TBT	R9,XDRVL  		:VARIABLE LENGTH MESSAGE ??
	JNFS	XDR0D0			:IF SO BECAUSE CAN'T HANDLE YET
	JAL	R10,XDRISC		:GO DUMP ISIS INTRANODE MESSAGE
	J	XDR090			:GO TO NEXT MESSAGE

:       here for variable len port 0 msg
XDR0D0	CLHI	R9,11			:AUX CIRCUIT REQUEST/1-DOWN
	JGE	XDR0E0			:MUST BE ICRM/ECRI LOGII MSGS
	LB	R0,XDRILB,R9		:STEP TO SIZE BYTE
	LR      R4,R0
	AR      R4,R8     		:get address of size byte
	NR	R4,RS			:CHECK FOR WRAP AROUND
	LB	R6,RING,RR,R4		:GET VARIABLE STRING SIZE
	AR      R6,R0     		:get add in header len
	AIS     R6,1      		:plus 1 for the len byte
	JAL	R7,TYP1SP		:TYPE IT
	JAL	R10,XDRISE		:TO PUT OUT MESSAGE
	J	XDR090

XDR0E0	LB	R0,XDRILB,R9		:Do ICRM/ECRI
	LR      R4,R0
	AR      R4,R8
	NR	R4,RS			:CHECK FOR WRAP AROUND
	LHL	R6,RING,RR,R4		:GET VARIABLE MESSAGE SIZE
	AR	R6,R0			:ADD FIXED MESSAGE LENGTH
	AIS     R6,2      		:len of len is two bytes
	JAL	R7,TYP1SP
	CLHI    R9,11     		:if ICRS hide uname/password
	JEFS    XDR0E4
XDR0E2	JAL	R10,XDRISE		:TO PUT OUT MESSAGE
	J	XDR090			:TO CONTINUD

XDR0E4  CLHI    R6,1E
	JLEBS   XDR0E2
	LHI     R5,-1E,R6
	LHI     R6,1E
	JAL     R10,XDRISE
	AR      R8,R5     		:add in unprinted len
	J       XDR090    		:and done

XDR0F0	LA	R2,XDRMS4,,		:NEEDLE MESSAGE
	JAL	R7,TYPASC		:TYPE IT
	LB	R6,RING+3,R8,RR		:GET ADDITIONAL LENGTH
	AIS	R6,4			:ADD FIXED PORTION
	JAL	R7,TYP1SP		:INSERT A BLANK
	JAL	R10,XDRISE		:TO PUT REST OF MESSAGE
	J	XDR090

XDR0FF	J	XRCRLF,,		:RETURN WITH CR/LF

::	SUBROUTINE:	BEGMSG
::	GUESS AT FIRST MESSAGE IN RING
:	------------------------------
:	CALLING SEQ:	JAL	R10,BEGMSG
:	INPUT:		R3  = RS = RING SIZE
:			R7  = COUNTER
:			R8  = CURRENT POINTER
BEGMSG  NHI     R8,-4
	J       BEG010    		:make sure start on even boundary

BEG000	AIS	R8,4			:BUMP POINTER
	AIS	R7,4			:BUMP POINTER
	CR	R7,RS			:SEE IF GONE AROUND RING COMPLETELY
	JGE	XDR0FF			:WE HAVE!  JUMP TO CR/LF
	NR	R8,RS			:SEE IF AT END OF RING
BEG010	HS	0
	LHL     R9,RING,R8,RR   	:VALID DPORT?
	CLHI    R9,NDP    		:MAXIMUM DPORT
	JG      BEG000
	L	R9,RING,R8,RR		:IS WHOLE WORD NONZERO?
	JNR	R10			:IF SO, SHOULD DO FOR A GUESS!
	J	BEG000			:TEST NEXT WORD 

::	SUBROUTINES:	XDRISA/XDRISB/XDRISC/XDRISE
::	DUMP A MESSAGE
:	--------------
:	LINKS:	R10
:	INPUT:	R8 - RING INDEX
:		R9 - MSG CODE TYPE
:		RS - RING SIZE
:		RR - RING START
:	DATA MESSAGE
XDRISA	HS	0
	LA	R6,3,R9			:MESSAGE LENGTH=MESSAGE TYPE+3
	J	XDRISL
:	INTRANODE MESSAGE TYPE
XDRISC	HS	0
	LB	R6,XDRILB,R9		:MESSAGE LENGTH FROM TABLE

XDRISL  JAL     R7,TYP1SP
	J       XDRISE

XDRISD	LA	R2,XDRASC,,		:ASCII EQUIVALENT OF LINE
	JAL	R7,TYPASC
	JAL	R7,TYPCRL,,		:NEW LINE
	JAL	R7,TYP6SP
XDRISE	LIS	R12,0			:LINE LENGTH COUNTER
XDRISF	LB	R4,RING,R8,RR		:NEXT BYTE FROM RING
	JAL	R11,XDTPUT  		:PUT IT OUT IN HEX NOW
	LR      R0,R4
	LR      R0,R4
	TBT	R4,XDRECH		:PRINTABLE ??
	JNFS	XDRISH			:IF NOT, USE BLANK
	LHI	R0,ASCSPC		:ELSE IF OK TO PRINT IT
XDRISH	LR	R4,R12			:COMPUTE WHERE TO PLUG INTO LINE
	NHI	R4,0F			:16 BYTES PER LINE
	STB	R0,XDRASC+4,R4,,	:PUT 'ER THERE FOR ASCII OUTPUT LATER
	AIS	R8,1			:BUMP RING INDEX
	NR	R8,RS			:END OF RING ??
	AIS	R12,1			:LINE LENGTH
	CLH	R8,NFMI,RR		:SEE IF AT RING POINTER
	JE	XDRISI			:IF SO GET OUT
	SIS	R6,1			:CHECK FOR END OF MSG
	JLE	XDRISI			:FINISH BLANKING AND PRINT	
	THI	R12,0F			:END OF LINE
	JE	XDRISD			:IF SO
	THI	R12,1			:END OF HALFWORD
	JN	XDRISF			:IF NOT TO CONTINUE
	JAL	R7,TYP1SP		:TO FORMAT WORDS
	J	XDRISF
XDRISI	LHI	R0,ASCSPC		:BLANK
XDRISJ	NHI	R12,0F			:LINE LENGTH OF 16
	JEFS	XDRISK			:IF TO END OF LINE
	STB	R0,XDRASC+4,R12,,	:PUT IN A BLANK
	AIS	R12,1			:COUNT ON UP
	JBS	XDRISJ			:AND SEE IF DONE
XDRISK	LA	R2,XDRASC,,		:PUT IT OUT
	JAL	R7,TYPASC
	JR	R10			:DONE
       EI       :1-NCSLOT

	EI	:(XRSZLV-2)		:##AL

	SUBTTL	XRAY (Utility routines)

::*********************************************************************
::
::	SUBROUTINE:	FSTMSC:
::	FUNCTION:	CONVERT FASTC TO MILLISECONDS
::	CALLING SEQ:	JAL	R9,FSTMSC
::	INPUT:		R2  = FASTC VALUE
::	OUTPUT:		R3  = RETURNED MILLISECOND VALUE 
::	DESTROYED:	R0
::
::*********************************************************************

FSTMSC	HS	0
	LR	R0,R2
	SLLS	R0,2
	AR	R2,R0			:MULTIPLY R2 BY 5
	LIS	R0,3
	DHR	R2,R0			:AND DIVIDE BY 3 ( I.E., BY 1000/600)
	SIS	R2,1			:R2 IS REMAINDER (0,1 OR 2)
	JLER	R9			:0 OR 1, LEAVE RESULT ALONE
	AIS	R3,1			:REMAINDER = 2, ROUND UP
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	XFNDLK:
::	FUNCTION:	LIKE FNDLNK, BUT STORES KN AND KD IN THE XKNSAV
::	AND XKDSAV FIELDS OF THE REMOTE XRAY USER BLOCK.
::	CALLING SEQ:	JAL	R9,XFNDLK
::	INPUT:		R1  = NEIGHBOR NUMBER
::	NOTE:		R11 IS USED AS KN OR KX (KD) THROUGHOUT	XRAY.
::	RETURNS:	IMMEDIATE = NOT FOUND
::			+4 = FOUND
::
::*********************************************************************

XFNDLK	HS	0
	ST	R9,XFNDSV		:SAVE RETURN
	LHI	R11,NLINKS-1		:HIGHEST LINK#
XFNDL1	SLL	R11,1
	L	R9,KDKN,R11,R11		:LINK DESC.
	SRL	R11,1
	CLH	R1,NDID,R9		:THIS IT?
	JEFS	XFNDL2			:YES
	SIS	R11,1			:NO, TRY AGAIN
	JGEBS	XFNDL1
	ST	R11,XKDSAV,XD		:LINK DESC<0
	STH	R11,XKNSAV,XD		:KN=-1
	L	R9,XFNDSV		:RECOVER RETURN
	SKIP(0,R9)			:STRAIGHT RETURN		###wjl
XFNDL2	ST	R9,XKDSAV,XD		:FOUND KD
	STH	R11,XKNSAV,XD		:AND KN
	L	R9,XFNDSV		:RECOVER RETURN
	J	4,R9			:SKIP RETURN

::*********************************************************************
::
::	SUBROUTINE:	CHNLNK:
::	FUNCTION:	FINDS THE NEIGHBOR CONNECTED TO A CHANNEL
::	CALLING SEQ:	JAL	R8,CHNLNK
::	INPUT:		R5(CHN)	= CHANNEL
::	OUTPUT:		R3	= RETURNS NEIGHBOR NUMBER
::	DESTROYED:	R1, R9
::	RETURNS:	IMMEDIATE IF NO NEIGHBOR
::			+4 IF INTERNAL TERMINATION
::			+8 IF NEIGHBOR FOUND
::
::*********************************************************************

CHNLNK	HS	0
	LCS	R3,4
CHNLN1	AIS	R3,4
	CLH	CHN,CHNMAP,R3		:CHNMAP ORGANIZED IN DESCENDING ORDER
	JLBS	CHNLN1			:CHN IS STILL TOO LOW
	LHL	R3,CHNMAP+2,R3		:CHNMAP+2 IS POINTER TO NEIGHBOR NUMBER
	THI	R3,8000			:HOB SET MEANS INTERNAL TERMINATION
	JN	CHNLN4			:IT IS				###wjl
	LHL	R3,CHNMPD,R3		:IT ISN'T, LOOK UP NEIGHBOR
CHNLN2	LR	R1,R3
	ST	R11,XRSAVE,XD
	JAL	R9,XFNDLK		:MAKE SURE THE NEIGHBOR IS THERE
	SKIPAD(CHNLN3)			:immed, IT ISN'T, do IMMED RET	###wjl
	L	R11,XRSAVE,XD		:+4 return, IT IS, do +8 RETURN	###wjl
	J	8,R8			:				###wjl

CHNLN3	L	R11,XRSAVE,XD
	SKIP(0,R8)			:immediate return for no neighbor##wjl

CHNLN4	SKIP(4,R8)			:+4 return for internal term	###wjl

::*********************************************************************
::
::	SUBROUTINE:	COUNT0:/COUNT1:
::	FUNCTION:	COUNTS NUMBER OF 0'S/1'S IN A SERIES OF CONTIGIOUS HW
::	CALLING SEQ:	JAL	R9,COUNT0
::	INPUT:		R2  = HW COUNT
::			R4  = POINTER TO FIRST HW
::	OUTPUT:		R3  = RESULT
::	DESTROYED:	R0, R1
::
::*********************************************************************

COUNT1	HS	0
	LIS	R3,0			:SO XOR HAS NO EFFECT BELOW.
	JFS	COUNTD
COUNT0	HS	0
	LCS	R3,1			:TO INVERT BITS IN XOR BELOW.
COUNTD	STH	R3,CNTXOR
	LIS	R3,0			:CLEAR RESULT
	LR	R2,R2			:VERIFY NON-ZERO COUNT
	JER	R9			:ZERO COUNT, RETURN
COUNTA	LHL	R0,0,R4			:GET A HW
	XH	R0,CNTXOR		:COMPLEMENT (0'S) OR NOT (1'S)
COUNTB	JFFOH	R0,COUNTC		:FIND FIRST 1
	JFS	NOONE			:NO MORE ONES
COUNTC	AIS	R3,1			:INCREMENT COUNT IN R3
	XH	R0,HMSK,R1,R1		:COUNT EACH 1 ONLY ONCE
	JBS	COUNTB			:AND KEEP SEARCHING
NOONE	AIS	R4,2			:INCREMENT HW INDEX
	SIS	R2,1			:DECREMENT HW COUNT
	JGBS	COUNTA			:MORE HW, CONTINUE
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	RDSYMB:
::	FUNCTION:	READS UP TO 6 ASCII CHARACTERS INTO SYMASC+1
::	CALLING SEQ:	JAL	R10,RDSYMB
::	DESTROYED:	R1, R2
::
::*********************************************************************

RDSYMB	HS	0
	LI	R1,0A0A0A0		:INITIALIZE SYMASC TO SPACES
	ST	R1,SYMASC,,
	LI	R1,0A0A0A000
	ST	R1,SYMASC+4,,
	LIS	R2,1
RDSYM1	JAL	R13,XRYIN		:READ A CHAR
	OHI	R1,80			:SET HOB
	CLHI	R1,ASCSPC+80		:IF SPACE ASSUME USER IS DONE
	JER	R10
	CLHI	R1,ASCCR+80		:SAME FOR CR
	JER	R10
	CLHI	R1,ASCCOM+80		:SAME FOR COMMA			###wjl
	JER	R10			:				###wjl
	CLHI	R1,ASCNIN+80		:ASSUME A DIGIT			###wjl
	JLEFS	RDSYM2			:				###wjl
	NHI	R1,ASCUC		:ASSUME ALPHABETIC,ENSURE UPPERCASE,0DF
RDSYM2	STB	R1,SYMASC,R2,
	AIS	R2,1
	CLHI	R2,6
	JLE	RDSYM1
	JR	R10

::*********************************************************************
::
::	SUBROUTINE:	SYMVAL:
::	FUNCTION:	FINDS THE VALUE OF A SYMBOL IN THE SYMBOL TABLE
::	CALLING SEQ:	JAL	R10,SYMVAL
::	OUTPUT:		R3  = RETURNS THE VALUE
::	DESTROYED:	R2
::	RETURNS:	IMMEDIATE = NO MATCH
::			+4 = MATCH
::
::*********************************************************************

SYMVAL	HS	0
	LIS	R2,0			:init index into symbol table
SYMVA2	L	R3,SYMTBL,R2,		:read 3 chars of first symbol
	NI	R3,0FFFFFF		:mask to three chars worth
	C	R3,SYMASC,,		:is it what we're looking for?
	JN	SYMVA1			:not is first 3 chars
	L	R3,SYMTBL+4,R2,		:partial match.  Confirm rest.
	NHI	R3,0FF00		:mask off 4 lobs
	C	R3,SYMASC+4,,		:compare more
	JN	SYMVA1
	L	R3,SYMTBL+8,R2,		:etc. (this isn't clear to jhl)
	J	4,R10			:FOUND A MATCH, SKIP RETURN
SYMVA1	AHI	R2,ADRESZ		:NAD'S INADEQUACIES PREVENT USE OF AIS
	CLHI	R2,SYMTSZ
	JL	SYMVA2
	SKIP(0,R10)			:NO MATCH, IMMEDIATE RETURN	###wjl

::*********************************************************************
::
::	SUBROUTINE:	OCTHXR:
::	FUNCTION:	CONVERTS A VALUE IN R3 FROM OCTAL TO HEX
::	CALLING SEQ:	JAL	R9,OCTHXR
::	INPUT/OUPUT:	R3  = ARGUMENT AND RESULT
::	DESTROYED:	R0, R1
::
::*********************************************************************

OCTHXR	HS	0
	LR	R1,R3
	LR	R0,R3
	NHI	R1,7			:FIRST OCTAL DIGIT
	NHI	R3,70			:SECOND OCTAL DIGIT
	SRLS	R3,1
	AR	R1,R3
	LR	R3,R0
	NHI	R3,700			:THIRD OCTAL DIGIT
	SRLS	R3,2
	AR	R1,R3
	LR	R3,R0			:FOURTH OCTAL DIGIT
	NHI	R3,7000
	SRLS	R3,3
	AR	R1,R3 			:				###SHM
	LR	R3,R0			:				###SHM
	NI	R3,070000  		:FIFTH OCTAL DIGIT		###SHM
	SRLS	R3,4			:				###SHM
	AR	R1,R3			:				###SHM
	LR	R3,R0			:				###SHM
	NI	R3,0700000		:SIXTH OCTAL DIGIT		###SHM
	SRLS	R3,5			:				###SHM
	AR	R1,R3			:				###SHM
	LR	R3,R0			:				###SHM
	NI	R3,07000000     	:SEVENTH OCTAL DIGIT		###SHM
	SRLS	R3,6			:				###SHM
	AR	R1,R3			:				###SHM
	LR	R3,R0			:				###SHM
	NI	R3,70000000     	:EIGTH OCTAL DIGIT		###SHM
	SRLS	R3,7			:				###SHM
	AR	R3,R1			:				###SHM
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	OCTHEX:
::	FUNCTION:	CONVERTS A SERIES OF MEMORY LOCATIONS FROM OCTAL TO HEX
::	CALLING SEQ:	JAL	R9,OCTHEX
::	INPUT:		R0  = 2 X NUMBER OF HW TO BE CONVERTED
::			R1  = ADDRESS OF FIRST HW
::	DESTROYED:	R0, R1
::
::*********************************************************************

OCTHEX	HS	0
	ST	R2,XREGSV,XD		:SAVE REGS FOR PROGRAMMING CONVENIENCE
	ST	R3,XREGSV+4,XD
	ST	R4,XREGSV+8,XD
OCTHE1	LHL	R2,0,R1			:GET A HW
	LR	R4,R2
	NHI	R2,7			:FIRST OCTAL DIGIT
	LR	R3,R4
	NHI	R3,70			:SECOND OCTAL DIGIT
	SRLS	R3,1
	AR	R2,R3
	LR	R3,R4
	NHI	R3,700			:THIRD OCTAL DIGIT
	SRLS	R3,2
	AR	R2,R3
	LR	R3,R4			:FOURTH OCTAL DIGIT
	NHI	R3,7000
	SRLS	R3,3
	AR	R2,R3
	STH	R2,0,R1			:STORE RESULT
	SIS	R0,2
	JLEFS	OCTHE2			:ALL DONE
	AIS	R1,2			:GET NEXT VALUE
	J	OCTHE1			:AND REPEAT
OCTHE2	L	R2,XREGSV,XD		:RESTORE REGS
	L	R3,XREGSV+4,XD
	L	R4,XREGSV+8,XD
	JR	R9			:AND RETURN

::*********************************************************************
::
::	SUBROUTINE:	HEXOCT:
::	FUNCTION:	CONVERT VALUE FROM HEX TO OCTAL.
::	CALLING SEQ:	JAL	R9,HEXOCT
::	INPUT/OUTPUT:	CALLING ROUTINE PASSES HEX VALUE IN LOW-ORDER
::	2 BYTES OF R3 -- OCTAL VALUE RETURNED IN LOW-ORDER 3 BYTES OF R3.
::	HEX VALUES OF FFF OR LESS RESULT IN OCTAL VALUE OF 7777 OR LESS,
::	AND CAN BE DISPLAYED BY HALFWORD DISPLAY ROUTINES. HEX VALUES
::	GREATER THAN FFF ARE FULLY DISPLAYED BY FULLWORD DISPLAY ROUTINES.
::	DESTROYED:	R1, R2
::
::*********************************************************************

HEXOCT	HS	0
	EXHR	R3,R3		:MOVE VALUE TO HIGH-ORDER HALFWORD. WE CONVERT
	LIS	R1,4		:TO OCTAL BY DOING A SERIES OF 3-BIT SHIFTS AND
HEXOC2	SRLS	R3,3		: ZERO-BIT INSERTS. EACH TRI-BIT FIELD CONVERTS
	SRHLS	R3,1		: TO A QUAD-BIT FIELD WITH A HIGH-ORDER ZERO.
	SIS	R1,1
	JGBS	HEXOC2			:GET 4 OCTAL NIBBLES IN LOW-ORDER HW
	LR	R2,R3
	SRLS	R2,3			:CONVERT NEXT OCTAL NIBBLE
	SRHLS	R2,1
	SRLS	R2,0C			:SHIFT OUT LEFT-OVER AND
	EXHR	R2,R2			:	ALIGN HIGH-ORDER 2 NIBBLES,
	NHI	R3,7FFF			:	ISOLATE LOW-ORDER 4 NIBBLES,
	OR	R3,R2			:	AND COMBINE.
	JR	R9			:DONE - OCTAL VALUE IN R3

::*********************************************************************
::
::	SUBROUTINE:	DECHEX:
::	FUNCTION:	DECIMAL TO HEX CONVERSION ROUTINE
::	CALLING SEQ:	JAL	R9,DECHEX
::	INPUT/OUTPUT:	HALF-WORD ARGUMENT PASSED AND RETURNED IN R3
::	DESTROYED:	R0-R4
::
::*********************************************************************

DHXTBL	HC	$A 1
	HC	$A 10
	HC	$A 100
	HC	$A 1000

DECHEX	HS	0
	NI	R3,0FFFF		:KEEP ONLY L-O HW
	LIS	R1,6			:LOOP INDEX
	LR	R2,R3			:SAVE OFF ARGUMENT
	LIS	R3,0			:CLEAR RESULT
	EXHR	R2,R2			:MOVE ARGUMENT TO HO HW
DECHE1	LHL	R0,DHXTBL,R1		:GET POWER OF 10
	RLL	R2,4			:ISOLATE TOP NIBBLE
	LHR	R4,R2			:MOVE IT TO R4
	CLHI	R4,9			:CHECK FOR RADIX VIOLATION	###wjl
	JGFS	DHXBAD			:YES, output error message	###wjl
	MHR	R4,R0			:MULTIPLY BY POWER OF 10
	AR	R3,R4			:ACCUMULATE RESULT
	NHI	R2,0FFF0		:STRIP OFF NIBBLE
	SIS	R1,2			:DECREMENT LOOP INDEX
	JGEBS	DECHE1	
	JR	R9			:DONE				###wjl

DHXBAD	LA	R2,BADRDX,,		:**BAD RADIX
	JAL	R7,TYPASC		:ERROR CONDITION
	J	XRCRLF,,		:###jhl

::*********************************************************************
::
::	SUBROUTINE:	HEXDEC:
::	FUNCTION:	CONVERT VALUE FROM HEX TO DECIMAL.
::	CALLING SEQ:	JAL	R9,HEXDEC
::	INPUT/OUTPUT:	Calling Routine Passes Hex Value in R3 -- Decimal
::				value returned in R3.
::	NOTE:  Maximum Value convertable is 99999999d (5F5E0FF HEX).
::	DESTROYED:	R0 - R4
::
::*********************************************************************

HEXDEC	HS	0
	LIS	R0,$A10			: Divisor for Radix Conversion
	LR	R2,R3			: copy (HEX) value
	LIS	R3,0			: Clear decimal accumulator
	LIS	R4,7			: 8 loops, once for each digit/nibble
HEXDC2	LIS	R1,0			: extend operand to 64-bits
	DR	R1,R0
	OR	R3,R1			: accumulate remainder as new digit
	RRL	R3,4			: make room for next digit
	SIS	R4,1			: (aligned after 8 loops)
	JGEBS	HEXDC2
	JR	R9			: RETURN WITH DECIMAL VALUE IN R3

::*********************************************************************
::
::	SUBROUTINE:	DECPER:
::	FUNCTION:	COMPUTE AND DISPLAY DECIMAL PERCENTAGE OF
::	PASSED VALUES AS:	A/B=NN%
::	WHERE A IS PASSED IN R3, B IS PASSED IN R4, AND NN IS A DECIMAL
::	VALUE. THE VALUE IS DISPLAYED FOLLOWED BY A '%'.
::	CALLING SEQ:	JAL	R9,DECPER
::	DESTROYED:	R0, R2
::	CALLS:	 	HEXDEC, TYPBYT, AND TYPASC
::
::*********************************************************************

DECPER	HS	0
	ST	R9,DPRSAV,XD		:SAVE RETURN LINK
	LHI	R0,$A100
	MR	R2,R0			:MULTIPLY DIVIDEND BY 100
	LR	R4,R4	
	JLEFS	DECPR1			:NO DIVIDE BY ZERO...
	DR	R2,R4			:(A/B), QUOTIENT IN R3
	JFS	DECPR2
DECPR1	LIS	R3,0			:DIVIDE BY ZERO, GIVE ZERO RESULT
DECPR2	JAL	R9,HEXDEC		:CONVERT TO DECIMAL AND
	JAL	R9,TYPBYT		:	DISPLAY
	LA	R2,ASCPCT,,
	JAL	R7,TYPASC		:DISPLAY PERCENT SIGN (%)
	L	R9,DPRSAV,XD
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	RDCOMD:
::	FUNCTION:	READS A TWO-CHARACTER COMMAND 
::	CALLING SEQ:	JAL	R9,RDCOMD
::	OUTPUT:		R0  = RETURNS COMMAND
::			R1  = RETURNS LAST CHARACTER TYPED
::
::*********************************************************************

RDCOMD	HS	0
	LIS	R0,0
	STH	R0,ARGCT,XD		:ZERO OUT ARGUMENT COUNT
XCMSPC	JAL	R13,XRYIN		:GET FIRST CHARACTER
	OHI	R1,80			:SET MSB
	CLHI	R1,ASCCR+80		:CARRIAGE RETURN?
	JE	XRCRLF,,		:YES, RETURN TO XLOOP WITH CR-LF###jhl 
	CLHI	R1,ASCLF+80		:HOW ABOUT LINE-FEED?
	JE	XRCRLF,,		:RETURN TO COMMAND LOOP
	CLHI	R1,ASCSPC+80		:LEADING SPACE?
	JE	XCMSPC			:YES, STRIP LEADING SPACES
	clhi    r1,08+80  		:backspace?
	je      xcmspc

	NHI	R1,ASCUC		:ASSUME ALPHABETIC,ENSURE UPPERCASE,0DF
	EXBR	R0,R1			:MOVE TO R0
	OHI	R0,ASCSPC+80		:SET SECOND CHAR TO SPACE
	JAL	R13,XRYIN		:GET SECOND BYTE
	OHI	R1,80			:SET MSB
	CLHI	R1,ASCCR+80		:CR?
	JER	R9			:YES,RETURN
	CLHI	R1,ASCCOM+80		:COMMA?
	JER	R9			:YES,RETURN
	CLHI	R1,ASCSPC+80		:SPACE?
	JER	R9			:YES,RETURN
	clhi    r1,08+80  		:backspace?
	jnfs    rdcom2
	lis     r1,08     		:and keep display correct
	jal     r13,xryout
	j       xcmspc    		:go back for first char
RDCOM2	NHI	R1,ASCUC		:ASSUME ALPHABETIC,ENSURE UPPERCASE,0DF
	NHI	R0,0FF00		:STRIP SPACE
	OR	R0,R1			:AND MOVE TO R0
	JR	R9			:AND RETURN

::*********************************************************************
::
::	SUBROUTINE:	RDARGS:
::	FUNCTION:	READS A STRING OF ARGS UNTIL A <CR> IS TYPED OR
::	UNTIL ARGMAX/4 ARGS ARE ENTERED.  THE FW ARGS GO INTO VALUE1
::	AND 4*(# OF ARGS TYPED) GOES INTO 'ARGCT'.
::	CALLING SEQ:	JAL	R9,RDARGS
::	OUTPUT:		R1=RETURNS LAST NON-DIGIT TYPED
::			R2=RETURNS 4*(# OR ARGS TYPED)
::			R3=RETURNS LAST NUMBER TYPED
::	DESTROYED:	R4, R8
::
::*********************************************************************

RDARGS	HS	0
	LIS	R2,0			:CLEAR ARGUMENT COUNT
	STH	R2,ARGCT,XD
RDAR1	JAL	R8,RDEXP		:READ AN EXPRESSION
	LR	R4,R4
	JEFS	RDAR2			:NO DIGITS TYPED, PROCESS NON-DIGIT
	AIS	R2,4			:GOT A DIGIT, INC ARG COUNT
	STH	R2,ARGCT,XD
	ST	R3,VALUE1-4,2,XD	:SAVE ARG
RDAR2	CLHI	R1,ASCCR		:CR?
	JEFS	RDAR5			:YES
	CLHI	R1,ASCSPC		:SPACE?
	JEFS	RDAR4			:YES
	CLHI	R1,ASCCOM		:IS IT A COMMA?
	JNFS	RDAR5			:NO, RETURN
RDAR4	CLH	R2,ARGMAX,XD		:ARE WE AT THE MAX NO OF ARGS?
	JN	RDAR1			:NO,GO BACK FOR MORE
RDAR5	LHI	R13,$A16*4
	STH	R13,ARGMAX,XD		:FALL BACK TO 64 ARGS
	L	R3,VALUE1-4,R2,XD	:RECOVER R3 = LAST ARGUMENT ENTERED
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	RDEXP:
::	FUNCTION:	READ A NUMERICAL VALUE
::	CALLING SEQ:	JAL	R8,RDEXP
::	OUTPUT:		R1=LAST NON-DIGIT TYPED
::			R3=RETURNS NUMERICAL VALUE
::			R4=RETURNS COUNT OF DIGITS TYPED
::
::*********************************************************************

RDEXP	HS	0
	LIS	R4,0			:CLEAR COUNT AND VALUE
	LIS	R3,0
RDNU1
	JAL	R13,XRYIN		:READ CHAR INTO R1
	NHI	R1,ASC7BT		:GOT A CHAR, CLEAR PARITY
	clhi    r1,08     		:backspace
	jnfs    rdhe4
	sis     r4,1      		:back up a digit
	jgefs   rdhe3
	lis     r4,0
	jbs     rdnu1     		:retry first char
rdhe3   srls    r3,4      		:eat previous digit
	jal     r13,xryout		:fix display
	j       rdnu1
rdhe4
	CLHI	R1,ASCZRO
	JLR	R8			:< 30, NOT A DIGIT		###wjl
	CLHI	R1,ASCNIN
	JLEFS	RDHE1			:0 - 9
	CLHI	R1,ASCA
	JLR	R8			:< A, NOT A DIGIT		###wjl
	NHI	R1,ASCAP		:ENSURE UPPERCASE(x5F)
	CLHI	R1,ASCF
	JGR	R8			:> F				###wjl
	AIS	R1,9			:A - F, JUST ADD 9 AND TRUNCATE
RDHE1	NHI	R1,0F
	AIS	R4,1			:(+4) INC COUNT
	SLLS	R3,4			:SHIFT IN DIGIT
	AR	R3,R1
	J	RDNU1

::*********************************************************************
::
::	SUBROUTINE:	TYPHEX:
::	FUNCTION:	TYPE A SINGLE HEX DIGIT
::	CALLING SEQ:	JAL	R7,TYPHEX
::	INPUT:		R1=DIGIT
::
::*********************************************************************

TYPHEX	HS	0
	NHI	R1,0F			:TRUNCATE
	OHI	R1,30			:IF > 39, ADD 7
	CLHI	R1,ASCNIN
	JLEFS	TYPH10			:.+4
	AIS	R1,7
TYPH10	JAL	R13,XRYOUT
	JR	R7

::*********************************************************************
::
::	SUBROUTINE:	TYPFWD:
::	FUNCTION:	IDENTICAL TO TYPHWD FOR A FULL-WORD
::	CALLING SEQ:	JAL	R9,TYPFWD
::
::*********************************************************************

TYPFWD	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXDEC
	JAL	R9,TYPFW		:DISPLAY
	L	R9,XHDSAV,XD
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TYPFW:
::	FUNCTION:	TYPE 8 DIGITS FOLLOWED BY SPACES
::	CALLING SEQ:	JAL	 R9,TYPFW
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7
::
::*********************************************************************

TYPFW	HS	0
	LIS	R4,8			:init counter
	LR	R0,R3			:move R3 to work register
TYPF1	RLL	R0,4			:rotate four bits (hex digit's worth)
	LR	R1,R0			:and get it into R1 for TYPHEX
	JAL	R7,TYPHEX		:type out ASCII for a hex digit
	SIS	R4,1			:decrement the counter
	JGBS	TYPF1			:loop until zero
	JAL	R7,TYP1SP		:output a space
	JR	R9			:return to caller

::*********************************************************************
::
::	TABLE:	  BCDTBL:
::	FUNCTION: HEX INDEX INTO BYTE TABLE RETURNS DECIMAL VALUE OF INDEX
::
::*********************************************************************

BCDTBL	HS	0
Q	EQ	0
	RE	$A10			:TEN'S
	RE	$A10			:ONE'S
	BC	Q
Q	EQ	Q+1
	ER				:ONE'S
Q	EQ	Q+6
	ER				:TEN'S

::*********************************************************************
::
::	SUBROUTINE:	GMTCAL:
::	FUNCTION:	GET THE CURRENT GMT FOR STORAGE OR DISPLAY.
::	CALLING SEQ:	JAL	R9,GMTCAL
::	OUTPUT:		R2 = 25 BITS OF HEX SEC'S SINCE START OF CURRENT YEAR
::			PLUS BITS 22-28 OF FASTC
::	DESTROYED:	R1,R3,R4
::
::*********************************************************************

GMTCAL	HS	0
	ST	R2,XYSAVE,		:SAVE REGISTER 2
	L	R2,SLOWC,,		:GET CURRENT NODE TIME.
	LHL	R1,FASTC+2,,		:GET LO HW OF FASTC.
	LH	R3,GETGMT		:SEE IF WE'VE GOT GMT YET

	JNFS	GMTCA2			:RECEIVED GMT, NO NEED TO ADJUST###OAS
	S	R2,NODSLC		:NO GMT RECEIVED YET, ADJUST FROM SLOWC
					:AT TIME OF NSTART,SOFTWARE RESTART#OAS
	J	GMTCA1			:AND SKIP ADJUSTMENTS		###OAS

GMTCA2	LR	R3,R2			:SAVE IT IN CASE WE GO TO GMTUPD
	S	R2,GMTSLC		:SUBTRACT BASE NODE TIME
	A	R2,GMTHEX		:ADD BASE GMT TIME TO GET NO. SEC'S
					:	SINCE START OF CURRENT YEAR
	C	R2,CYRMAX		:PAST END OF CURRENT YEAR?
	JLE	GMTCA1			:NO, SKIP
GMTUPD	HS	0
	ST	R3,GMTSLC		:NEW BASE NODE TIME
	S	R2,CYRMAX		:HOW MUCH INTO NEW YEAR?
	AI	R2,$A24*3600		:EXTRA DAY'S WORTH TO NIX DAY 0
	LI	R3,$A366*24*3600	:# SECS IN NORMAL YEAR+1 DAY FOR CYRMAX
	LHL	R4,CYRCOD		:OLD CURRENT YEAR CODE
	AIS	R4,1			:BUMP IT 1
	NHI	R4,3			:MOD 4
	STH	R4,CYRCOD		:SAVE NEW CURRENT YEAR CODE
	JNFS	GMTUP1			:NOT LEAPYEAR, SKIP
	AI	R3,$A24*3600		:add day's sec's for leapyear
GMTUP1	ST	R3,CYRMAX		:NEW CURRENT YEAR MAX SEC'S
	ST	R2,GMTHEX		:NEW GMT BASE TIME

GMTCA1	SRLS	R1,3			:LOSE LO BITS OF FASTC
	NHI	R1,7F			:SAVE LO 7 BITS
	SLLS	R2,7			:ALIGN SEC'S AND
	OR	R2,R1			:COMBINE WITH FASTC INTO R2
	ST	R2,GMTNOW		:SAVE IT
	L	R2,XYSAVE		:RESTORE REGISTER2
	JR	R9			:RETURN FOR DEPOSIT

::*********************************************************************
::
::	SUBROUTINE:	GMTCNV:
::	FUNCTION:	CONVERTS GMT SEC'S+FASTC IN R2 INTO DDD:HH:MM:SS.FF
::			AND DISPLAYS IT.
::	CALLING SEQ:	JAL	R9,GMTCNV
::
::*********************************************************************

GMTCNV	HS	0	
	L	R2,GMTNOW		:GET TIME
GMTCNX	ST	R0,XRSAVE,XD		:SAVE REGISTER
	LR	R0,R2			:SAVE R2 TO GET FASTC LATER
	SRLS	R2,7			:STRIP FASTC BITS
	LI	R3,$A24*1800		:NO. SEC'S IN HALF DAY (FOR HW DIVIDE)
	DHR	R2,R3			:R3=NO. HALFDAYS ELAPSED, R2=NO. SEC'S
					:INTO CURRENT HALFDAY
	SRLS	R3,1			:R3=NO. DAYS ELAPSED
	JNCFS	GMTCN1			:NO CARRY, SKIP
	AI	R2,$A24*1800		:ADJUST R2 FOR HALFDAY CARRY
GMTCN1	CHI	R3,$A300		:DDD>=300?
	JLFS	GMTCN2			:NO, TRY 200
	LIS	R1,3			:HO DIGIT OF DDD
	JAL	R7,TYPHEX		:TYPE IT
	SHI	R3,$A300		:R3=0-66
	J	GMTCN4
GMTCN2	CHI	R3,$A200		:DDD>=200?
	JLFS	GMTCN3			:NO, TRY 100
	LIS	R1,2			:HO DIGIT OF DDD
	JAL	R7,TYPHEX		:TYPE IT
	SHI	R3,$A200		:R3=0-99
	J	GMTCN4
GMTCN3	CHI	R3,$A100		:DDD>=100?
	JLFS	GMTCN0			:NO, DDD<=99
	LIS	R1,1			:HO DIGIT OF DDD
	JAL	R7,TYPHEX		:TYPE IT
	SHI	R3,$A100		:R3=0-99
	JFS	GMTCN4
GMTCN0	LIS	R1,0			:HO DIGIT
	JAL	R7,TYPHEX
GMTCN4	LB	R4,BCDTBL,R3,		:GET DD IN DECIMAL
	SLL	R4,$A24			:R4=DD000000
	LHI	R3,$A60*60		:SEC'S IN HOUR
	DHR	R2,R3			:R2=SEC'S INTO CURRENT HOUR
					:R3=CURRENT HOUR
	LB	R3,BCDTBL,R3,		:HH INDECIMAL
	SLL	R3,$A16			:R3=00HH0000
	OR	R4,R3			:R3=DDHH0000
	LHI	R3,$A60			:SEC'S IN MINUTE
	DHR	R2,R3			:R3=CURRENT MIN, R2=CURRENT SEC
	LB	R3,BCDTBL,R3,		:R3=000000MM
	SLLS	R3,8			:R3=0000MM00
	OR	R4,R3			:R4=DDHHMM00
	LB	R3,BCDTBL,R2,		:R3=000000SS
	OR	R4,R3			:R4=DDHHMMSS

::*********************************************************************
::
::	SUBROUTINE:	TYPGMT:
::	FUNCTION:	TYPES DD:HH:MM:SS.FF FROM DDHHMMSS IN R4 
::			AND FF (7 BITS FASTC) IN R0
::	CALLING SEQ:	JAL	R9,TYPGMT
::
::*********************************************************************

TYPGMT	HS	0
	LIS	R3,3			:FOUR PAIRS OF DIGITS TO TYPE,
					: 3 FOLLOWED BY ':'
TYPGM2	LIS	R2,2			:TWO DIGITS PER PAIR
TYPGM1	RLL	R4,4			:NEXT DIGIT TO LO NIBBLE OF R4
	LR	R1,R4			:R1 PASSES DIGIT TO BE TYPED
	JAL	R7,TYPHEX		:TYPE DIGIT
	SIS	R2,1			:1 DIGIT DOWN
	JGBS	TYPGM1			:NEXT DIGIT IN PAIR IF MORE
	LBR	R3,R3			:ALL DONE WITH PAIRS?
	JEFS	TYPGM3			:DON'T TYPE ':' AFTER SS. GO TYPE .FF
	LHI	R1,3A			:ASCII ':'
	JAL	R13,XRYOUT		:TYPE IT
	SIS	R3,1			:A PAIR DOWN
	JBS	TYPGM2			:NEXT PAIR

TYPGM3	HS	0
	L	R0,XRSAVE,XD		:RESTORE REG
	JR	R9			:RETURN TO THE SOURCE

::***************************************************************
::
::    	SUBROUTINE:	TYP5CH:
::	FUNCTION:	TYPE FIVE DIGITS FOLLOWED BY TWO SPACES
::	CALL SEQ:	JAL R9,TYP5CH
::	INPUT:		R3= ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7
::
::***************************************************************

TYP5CH	HS	0			
	LIS	R4,4			:LOAD CHARCOUNT-1         ###SHM
	LR	R0,R3			:LOAD ARGUMENT INTO R0    ###SHM
TYPCH1	EXHR	R1,R0			:LOAD FIRST DIGIT INTO LOWER
					:NIBBLE OF R1             ###SHM
	JAL	R7,TYPHEX		:TYPE DIGIT		  ###SHM
TYPCH2	SLLS	R0,4			:SHIFT IN NEXT DIGIT FROM LOWER
					:HALF WORD OF R0          ###SHM
	EXHR	R1,R0			:LOAD NEXT DIGIT INTO LOWER
					:NIBBLE OF R1		  ###SHM
	JAL	R7,TYPHEX		:TYPE DIGIT		  ###SHM
	SIS	R4,1			:DECREMENT R4             ###SHM
	JGBS	TYPCH2			:MORE DIGITS?		  ###SHM
	JAL	R7,TYP2SP		:TYPE TWO SPACES	  ###SHM
	JR	R9			:RETURN TO CALLER         ###SHM

::*********************************************************************
::
::	SUBROUTINE:	TYPNBY:
::	FUNCTION:	TYP N BYTES FOLLOWED BY 4 SPACES
::	CALLING SEQ:	JAL	R8,TYPNBY
::	INPUT:		R6  = ADDRESS OF FIRST BYTE
::			R5  = BYTE COUNT
::	DESTROYED:	R0,R1,R2,R3,R4,R7,R9
::
::*********************************************************************

TYPNBY	HS	0
	LIS	R4,0
TYPNB1	CR	R4,R5
	JER	R8			:DONE

	LB	R3,0,R6,R4		:GET A BYTE
	JAL	R9,TYPBYT		:AND TYPE IT
	JAL     R9,TYP2SP 		:print two extra spaces
	AIS	R4,1			:INC INDEX
	JBS	TYPNB1			:AND LOOP

::*********************************************************************
::
::	SUBROUTINE:	TYPADD:
::	FUNCTION:	TYPE A 5-DIGIT ADDRESS FOLLOWED BY A ":"
::	CALLING SEQ:	JAL	R9,TYPADD
::	INPUT:		R3=ADDRESS
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R4,R7
::
::*********************************************************************

TYPADD	HS	0
	LIS	R4,5
	LR	R0,R3
TYPA1	EXHR	R1,R0
	JAL	R7,TYPHEX
	SLLS	R0,4
	SIS	R4,1
	JGBS	TYPA1
	LA	R2,ASCCLN
	JAL	R7,TYPASC		:TYPE ':'
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	TYPOCT:
::	FUNCTION:	TYPE 3 OCTAL DIGITS
::	CALLING SEQ:	JAL	R9,TYPOCT
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R4,R7
::
::*********************************************************************

TYPOCT	HS	0
	LIS	R4,3
	LR	R0,3
	SLLS	R0,7
TYPOC1	SLLS	R0,3
	EXHR	R1,R0
	NHI	R1,7
	JAL	R7,TYPHEX
	SIS	R4,1
	JGBS	TYPOC1
	JAL	R7,TYP2SP
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	TYP8HW/TYP8HS/TYPNHW
::	ENTRY POINT:	TYP8HW:  TYPES 8 HW WITH 2 SPACES BETWEEN EACH
::			TYP8HS:  PRECEEDS FIRST HW WITH 4 SPACES
::			TYPNHW:  TYPES AS MANY HW AS COUNT IN R5
::	LINK:		R8
::	INPUT:		R10 = STARTING ADDRESS
::	DESTROYED:	R0,R1,R2,R3,R4,R5,R6,R7,R9
::
::*********************************************************************

TYP8SV	WS	1			:LINK SAVE AREA FOR TYP8H

TYP8HD	ST	R8,TYP8SV
	LI	R8,TYPHWD		:DECIMAL DISPLAY
	JAL	R7,TYP4SP
	LIS	R5,8
	JFS	TYPNH1
TYP8HS	JAL	R7,TYP4SP
TYP8HW	LIS	R5,8
TYPNHW	ST	R8,TYP8SV		:SAVE LINK
	LI	R8,TYPHW		:HEX DISPLAY
TYPNH1	SIS	R5,1			:DONE?
	JLFS	TYP8H1			:YES
	LHL	R3,0,R10
	AIS	R10,2
	JALR	R9,R8			:TYPHW OR TYPHWD
	JBS	TYPNH1
TYP8H1	JAL	R7,TYPCRL
	L	R8,TYP8SV		:RESTORE LINK REG
	JR	R8

::*********************************************************************
::
::	SUBROUTINE:	TYPCRL/TYPLF
::	ENTRY POINT:	TYPCRL:  TYPES A CR-LF
::			TYPLF:   TYPES LINE FEED
::	LINK:		R7
::	DESTROYED:	R1
::
::*********************************************************************

TYPCRL	HS	0
	LIS	R1,0D
	JAL	R13,XRYOUT
TYPLF	HS	0
	LIS	R1,0A
	JAL	R13,XRYOUT
	JR	R7

::*********************************************************************
::
::	SUBROUTINE:	TYPBIT:
::	FUNCTION:	TYPES BIT ARRAY
::	CALLING SEQ:	JAL	R9,TYPBIT
::	INPUT:		R3 = HWD OF BIT ARRAY
::			R4 = NUMBER OF BITS TO TYPE
::	DESTROYED:	R0, R1, R2, R5
::
::*********************************************************************

TYPSAV	HS	1			:save area for HW of bit array

TYPBIT	HS	0			:				###wjl
	LIS	R5,0			:initialize pointer/counter
	STH	R3,TYPSAV		:store HW of bit array
TYPB02	TBT	R5,TYPSAV		:bit set??
	JNFS	TYPB04			:yes
	JAL	R7,TYP0			:no, type a 0
	JFS	TYPB06
TYPB04	JAL	R7,TYP1			:type a 1
TYPB06	AIS	R5,1			:increment pointer/counter
	CR	R5,R4			:finished??
	JL	TYPB02			:no
	JR	R9			:yes, return

::*********************************************************************
::
::	SUBROUTINE:	TYPASC:
::	ENTRY POINTS:	TYP2SP,TYP4SP,TYP8SP,TYPASP,TYPASC,TYPAS1
::	LINK:		R7
::	INPUT:		R2=PTR TO STRING
::	DESTROYED:	R0,R1
::
::*********************************************************************

ASCSAT	SC	/@-/			:SATELITE FLAG FOR "ND"		###OAS
ASCPCT	SC	/%"A0/
ASC0	SC	/0"A0/			:ASCII 0 for TYPBIT		###wjl
ASC1	SC	/1"A0/			:ASCII 1 for TYPBIT		###wjl
ASC1SP	SC	/"A0/
ASC2SP	SC	/"A0"A0/
ASC3SP	SC	/"A0"A0"A0/
ASC4SP	SC	/"A0"A0"A0"A0/
ASC5SP	SC	/"A0"A0"A0"A0"A0/
ASC6SP	SC	/"A0"A0"A0"A0"A0"A0/
ASC7SP	SC	/"A0"A0"A0"A0"A0"A0"A0/
ASC8SP	SC	/"A0"A0"A0"A0"A0"A0"A0"A0/
ASC9SP	SC	/"A0"A0"A0"A0"A0"A0"A0"A0"A0/
ASCASP	SC	/"A0"A0"A0"A0"A0"A0"A0"A0"A0"A0/
ASCCLN	SC	/:"A0"A0/
ASCRLF	SC	/"0D"0A/

:	TYP0:	TYPE AN ASCII 0						###wjl
TYP0	LA	R2,ASC0
	J	TYPASC

:	TYP1:	TYPE AN ASCII 1						###wjl
TYP1	LA	R2,ASC1
	J	TYPASC

:       TYP1SP  type 1 space
TYP1SP  LA      R2,ASC1SP
	J       TYPASC
:	TYP2SP:
TYP2SP	LA	R2,ASC2SP
	J	TYPASC

TYP3SP  LA      R2,ASC3SP
	J       TYPASC

TYP5SP  LA      R2,ASC5SP
	J       TYPASC

TYP6SP  LA      R2,ASC6SP
	J       TYPASC

TYP7SP  LA      R2,ASC7SP
	J       TYPASC

TYP9SP  LA      R2,ASC9SP
	J       TYPASC


:	TYP4SP: TYPES 4 SPACES
TYP4SP	LA	R2,ASC4SP
	JFS	TYPASC

:	TYP8SP: TYPES 8 SPACES
TYP8SP	LA	R2,ASC8SP
	JFS	TYPASC

:	TYPASP: TYPES 10 SPACES
TYPASP	LA	R2,ASCASP		:FALL THRU TO TYPASC

:	TYPASC:	TYPE ASCII STRING
:	TYPAS1:	ALTERNATE ENTRY POINT HAS BYTE COUNT PASSED IN R0
TYPASC	HS	0
	LB	R0,0,R2			:BYTE COUNT
	JER	R7			:NULL LENGTH
TYPAS1	HS	0
	LB	R1,1,R2			:CHAR
	JAL	R13,XRYOUT
	AIS	R2,1
	SIS	R0,1
	JGBS	TYPAS1
	JR	R7

::*********************************************************************
::
::	SUBROUTINE:	TYPASI:
::	FUNCTION:	TYPE ASCII STRING IMMEDIATELY FOLLOWING CALL
::	LINKS ON:	R7 (WHICH ALSO POINTS TO BEGINNING OF STRING)
::	DESTROYED:	R0,R1
::
::*********************************************************************

TYPASI	HS	0
	LB	R2,0,R7			:LENGTH OF STRING
TYASI0	HS	0
	AIS	R7,1			:POINT TO NEXT CHAR
	LB	R1,0,R7			:GET THE CHAR
	JAL	R13,XRYOUT		:PUT IT OUT
	SIS	R2,1			:DECREMENT COUNT OF REMAINING CHAR'S
	JGBS	TYASI0			:MORE TO DO
	AIS	R7,2			:ADJUST RETURN TO NEXT HW
	NHI	R7,0FFFE		:...AS SO
	JR	R7			:RETURN TO INSTRUCTION FOLLOWING STRING

	SUBTTL	XRAY (CRYPTO OUTPUT ROUTINES)

:	THE FOLLOWING SYMBOL IS USED AS A BASE ADDRESS TO ALLOW ROUTINE
:	ADDRESSES TO BE STORED AS HALF-WORDS IN THE CRYPTO MESSAGE TABLE
SEGD.1	HS	0

::*********************************************************************
::
::	SUBROUTINE:	TYPHWD:
::	FUNCTION:	CONVERTS TO DECIMAL AND TYPES A HW
::	CALLING SEQ:	JAL	R9,TYPHWD
::	INPUT:		R3  = VALUE
::	DESTROYED:	R3
::	OTHER REGISTERS IDENTICAL TO TYPHW
::
::*********************************************************************

TYPHWD	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXDEC		:GO DECIMAL
	JAL	R9,TYPHW		:DISPLAY
	L	R9,XHDSAV,XD
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TYPHWO:
::	FUNCTION:	CONVERTS TO OCTAL AND TYPES A HW
::	CALLING SEQ:	JAL	R9,TYPHWO
::	INPUT:		R3  = VALUE
::	DESTROYED:	R3
::	OTHER REGISTERS IDENTICAL TO TYPHW
::
::*********************************************************************

TYPHWO	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXOCT		:GO OCTAL
	JAL	R9,TYPHW		:DISPLAY
	L	R9,XHDSAV,XD
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TYPHW:
::	FUNCTION:	TYPE 4 DIGITS FOLLOWED BY SPACES
::	CALLING SEQ:	JAL	R9,TYPHW
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7
::
::*********************************************************************

TYPHWS	JAL	R7,TYP2SP		:TYPE 2 SPACES
	JFS	TYPHW
TYPHNS	LIS     R2,0
	JFS	TYPH2
TYPHW	LIS     R2,1
TYPH2	LIS	R4,4
	LR	R0,R3
TYPH1	SLLS	R0,4
	EXHR	R1,0
	JAL	R7,TYPHEX
	SIS	R4,1
	JGBS	TYPH1
	LR      R2,R2
	JER     R9
	JAL	R7,TYP2SP
	JR	R9

::**************************************************************************
::
::	SUBROUTINE:	TYP5O:
::	FUNCTION:	CONVERTS TO OCTAL AND TYPES FIVE DIGITS
::	CALLING SEQ:	JAL	R9,TYP5O
::	INPUT:		R3= ARGUMENT
::	DESTROYED:	R0,R1,R2,R3,R4,R7			###SHM
::	
::**************************************************************************

TYP5O	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK		
	JAL	R9,HEXOCT		:CONVERT TO HEX
	JAL	R9,TYP5CH		:TYPE FIVE CHARACTERS
	L	R9,XHDSAV,XD		:RESTORE LINK
	JR	R9			:RETURN

::**************************************************************************
::
::	SUBROUTINE:	TYP5DD:
::	FUNCTION:	CONVERTS A HALFWORD HEX TO DECIMAL AND DISPLAYS IT
::			IN 5-DIGIT FORMAT FOLLOWED BY 2 SPACES
::	CALLING SEQ:	JAL	R9,TYP5DD
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7,R13
::
::**************************************************************************

TYP5DD		ST	R9,XHDSAV,XD		:SAVE THE RETURN ADDR 	###cwc
		JAL	R9,HEXDEC		:TURN R3 TO DECIMAL	###cwc
		JAL	R9,TYP5CH		:DISPLAY 5 DIGITS	###cwc
		L	R9,XHDSAV,XD		:RETRIEVE RETURN ADDR	###cwc
		JR	R9			:RTS			###cwc


::**************************************************************************
::
::	SUBROUTINE:	TYP3AS:						###cwc
::	FUNCTION:	MAPS A HALFWORD INTO A DISPLAY STRING TABLE FOR
::			TYMTUNNEL TYPE -- REFER TO THE TABLE, TNTYTB
::			3-CHAR STRING WILL BE DISPLAYED FOLLOWED BY 2 SPACES
::	CALLING SEQ:	JAL	R9,TYP3AS
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R4,R7,R13
::
::**************************************************************************

TYP3AS	LR	R1,R3
	SLLS	R1,2			:adjust the index
	LA	R2,TNTYTB,R1
	JAL	R7,TYPASC
	JAL	R7,TYP2SP
	JR	R9
:
:	The following is the string table for TYP3AS
:	Denotation for the three characters:  
:		D=Dedicated 		B=Backup 
:		O=Origination node 	E=Destination node
:		P=PVC			S=SVC
	WS	0
TNTYTB	SC	/DOS/
	SC	/DOP/
	SC	/DES/
	SC	/DEP/
	SC	/BOS/
	SC	/BOP/
	SC	/BES/
	SC	/BEP/
:	TNTYTB ENDS							###cwc	


::*********************************************************************
::
::	SUBROUTINE:	TYPBYT:
::	FUNCTION:	TYPE 2 DIGITS FOLLOWED BY 2 SPACES
::	CALLING SEQ:	JAL	R9,TYPBYT
::	INPUT:		R3=ARGUMENT
::	PRESERVED:	R3
::	DESTROYED:	R0,R1,R2,R7
::
::*********************************************************************

TYPBYT	HS	0
	LR	R1,R3			:ENTRY POINT FOR TYPNBY ROUTINE
	SRLS	R1,4			:SLIDE FIRST HEX DIGIT TO LO NIBBLE
	JAL	R7,TYPHEX		:	AND DISPLAY
	LR	R1,R3
	JAL	R7,TYPHEX		:DISPLAY SECOND HEX DIGIT
	JAL	R7,TYP2SP		:DISPLAY 2 SPACES
	JR	R9			:RETURN

::*********************************************************************
::
::	SUBROUTINE:	TYPBYO:
::	FUNCTION:	CONVERT LO HW IN R3 TO OCTAL AND TYPE LO BYTE
::	CALLING SEQ:	JAL	R9,TYPBYO
::
::*********************************************************************

TYPBYO	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXOCT
	JAL	R9,TYPBYT
	L	R9,XHDSAV,XD
	JR	R9

::*********************************************************************
::
::	SUBROUTINE:	TYPBYD:
::	FUNCTION:	CONVERT LO HW IN R3 TO DECIMAL AND TYPE LO BYTE
::	CALLING SEQ:	JAL	R9,TYPBYD
::
::*********************************************************************

TYPBYD	HS	0
	ST	R9,XHDSAV,XD		:SAVE LINK
	JAL	R9,HEXDEC
	JAL	R9,TYPBYT
	L	R9,XHDSAV,XD
	JR	R9

::*********************************************************************
::
::	EQUATES FOR CRYPTOGRAMS
::
::*********************************************************************

BH	EQ	TYPBYT-SEGD.1		:###wjl
BO	EQ	TYPBYO-SEGD.1		:###wjl
BD	EQ	TYPBYD-SEGD.1		:###wjl
HH	EQ	TYPHW-SEGD.1		:###wjl
HO	EQ	TYPHWO-SEGD.1		:###wjl
HD	EQ	TYPHWD-SEGD.1		:###wjl
O5	EQ	TYP5O-SEGD.1		:###wjl
D5	EQ	TYP5DD-SEGD.1		:###cwc###wjl
A3	EQ	TYP3AS-SEGD.1		:###cwc###wjl


	SUBTTL	XRAY (XRAY INPUT/OUTPUT ROUTINES)

::*********************************************************************
::
::	SUBROUTINE:	XRYTST:
::	FUNCTION:	CHECK IF THERE IS ANY INPUT DATA FOR XRAY
::	CALLING SEQ:	JAL	R13,XRYTST
::	DESTROYED:	R0, R2
::	RETURNS:	IMMEDIATE = USER DATA
::			+4 = NO DATA
::
::*********************************************************************

XRYTST	HS	0
	CI	XD,TTYXD		:TTY USER?
	JE	XRYTS1			:TTY XRAY USER
	LHL	R0,XRYPTF,XD		:REMOTE USER. IS FILL POINTER EQUAL
	CLH	R0,XRYPTE,XD		:TO EMPTY POINTER?
	JE	4,R13			:YES, NO DATA. DO +4 RETURN	###wjl
	SKIP(0,R13)			:REMOTE USER DATA. IMMEDIATE RETURN

XRYTS1	HS	0
	SVC	0A,0200			:ISIS SVC READS 1 CHAR INTO R2
	J	NODATA			:DIRECT RETURN IF NO DATA
	STH	R2,XINDDT,,		:GOT A CHAR, SAVE IT
	NHI     R2,7F     		:see if logout chars
	CLHI    R2,1A     		:control z?
	JE      XRISZP    		:yes, zap
	CLHI    R2,18     		:control x?
	JE      XRISEX    		:yes, exit to DDT
	CLHI    R2,02     		:Control^B resets
	JE      XRISGB    		:Gobbler then reset
	SKIP(0,R13)			:RETURN IMMEDIATE		###wjl
NODATA	TS	XINDDT,,		:NO DATA...FLAG CELL AS EMPTY
	J	4,R13			:AND DO +4 RETURN		###wjl

::*********************************************************************
::
::	SUBROUTINE:	XRYIN:
::	FUNCTION:	READ A SINGLE CHARACTER FROM THE TTY OR
::			A NODE CODE BUFFER
::	XRYIN RETURNS WITH A CHARACTER IN R1. IF THERE IS NO DATA
::	AVAILABLE IT DISMISSES XRAY AND TRIES AGAIN WHEN RESCHEDULED
::
::*********************************************************************

::      Only echo chars which are printable (or move cursor in a known manner)
XRPABL  HC      0FE80     		:echo ^G thru ^O (^N ^O are shifts
	HC      -1,0,0,0,0,0,0  	:for katakana/kanji)            ###sdw

XRYIN	HS	0
	STM	R0,XREGSV,XD		:SAVE ALL REGISTERS
XRYIN8	CI	XD,TTYXD		:TTY USER?
	JE	XRYIN1			:YES
	LHL	R4,XRYPTE,XD		:REMOTE, GET BUFFER EMPTY POINTER
	CLH	R4,XRYPTF,XD		:IS THERE DATA?
	JNFS	XRYIN9			:YES, GET IT
	JAL	R0,XRYDIS,,		:NO,DISMISS
	JBS	XRYIN8			:AND RETRY WHEN RESCHEDULED

XRYIN9	LB	R1,XRYBFI,R4,XD		:GET A CHARACTER
	NHI	R1,7F			:STRIP PARITY BIT
	LH	R2,EKOTYP,XD		:CHECK ECHO MODE
	JLFS	XRYIN2			:LOCAL ECHO, SKIP THE REST
	TBT     R1,XRPABL 		:printable char?                ###sdw
	JNFS    XRYIN2    		:not nice to echo ^S or ESCs    ###sdw
	LHL	R2,XRYBFO,XD		:GET OUTBOUND BUFFER NUMBER
	JAL	R9,WCIE,,		:AND ECHO TO USER
XRYIN2	AIS	R4,1			:INCREMENT EMPTY POINTER
	NHI	R4,XBFSZE-1		:MOD THE BUFFER SIZE
	STH	R4,XRYPTE,XD		:AND STORE BACK

XRYIN6	L	R0,XREGSV,XD
	LM	R2,XREGSV+8,XD		:RECOVER REGISTERS
	JR	R13			:AND RETURN

XRYIN1	HS	0			:HERE IF XRAY IN TTY MODE
	LH	R1,XINDDT,,		:IS THERE A CHAR IN THE XINDDT CELL?
	JLFS	XRYIN7			:NO
	TS	XINDDT,,		:YES, FLAG XINDDT AS BEEN READ
	J	XRYIN6			:AND RETURN WITH CHAR IN R1

XRYIN7	SVC	0A,01FF			:DO A SVC TO READ A CHAR INTO R1
	                  		:FF so ISIS waits for char which takes
	                  		:much less CPU than looping without
	                  		:waiting.                       ###sdw
	J	XRYIN7			:NO DATA, DO MERCILESS LOOP
	LR      R0,R1     		:work reg (just in case someone cares)
	NHI     R0,7F
	CLHI    R0,1A     		:contro Z for tty (through ISIS DDT)
	JE      XRISZP    		:handle zap
	CLHI    R0,18     		:^X returns to ISIS DDT
	JE      XRISEX    		:goto xray isis exit
	CLHI    R0,02     		:^B is like ^C (resets and gobbles)
	JEFS    XRISGB
	J	XRYIN6			:GOT CHAR INTO R1, RETURN

:       ISIS handler for CONTROL B
XRISGB  SVC     KIO,5     		:emit gobbler
	J       XRAY,,    		:and start over

:	ISIS EXIT FOR CONTROL X
XRISEX  JAL     R12,REMZAI,,    	:remove traps and whatever for dis one
	SVC     0D,1      		:return them to DDT
	J       XRAY,,    		:in case they hit P in DDT

:	ISIS EXIT FOR CONTROL Z
XRISZP  JAL     R12,REMZAI,,    	:prepare to zap them
	SVC     0D,0      		:disconnect them
	J       XPRMPT,,  		:DDT type P comes here??


::*********************************************************************
::
::	SUBROUTINE:	XRYOUT:
::	FUNCTION:	CHARACTER OUTPUT UTILITY ROUTINE
::	IN REMOTE MODE , XRAY MAY WRITE INTO ITS
::	OUTBOUND BUFFER ONLY IF THERE ARE LESS THAN XRONSZ (100) CHARACTERS IN
::	IT.  ELSE, XRAY SCHEDULES ITSELF OFF THE HALF-SEC PROCESS
::	(XRYRUN = 1 ) AND DISMISSES TO THE EXEC LOOP. 	IN TTY MODE
::	(TTYXD) THE OUTPUT GOES TO THE TTY ALONE 
::
::*********************************************************************

XRYOUT	HS	0
	STM	R0,XREGSV,XD		:SAVE ALL REGISTERS
XRYOU8	CI	XD,TTYXD		:TTY USER?
	JE	XRYOU1			:YES
	LHL	R2,XRYBFO,XD		:GET BUFFER NUMBER
	LHL	R0,BCT,R2,		:GET ESTIMATE OF BYTE COUNT
XRYSPD	CLHI	R0,XRONSZ		:ARE WE AT OUR LIMIT? (label by ###sdw)
	JLEFS	XRYOU4			:NO, WE MAY ADD ANOTHER CHARACTER
XRYOU5	JAL	R0,XRYYLD,,
	J	XRYOU8			:RETRY WHEN RESCHEDULED
xryou4  l       r0,fastc,,		:see if taking too much time
	sis     r0,ticxry 		:xray's quantum
	s       r0,protim+((1f-pxray)*4) :since xray started
	jgebs   xryou5

XRYOU3	L	R1,XREGSV+4,XD		:CHARACTER TO BE WRITTEN
	JAL	R9,WCIE,,		:DEPOSIT INTO BUFFER
	IF	INTACC			:###EV
	LHL	R3,XUINTH,XD		:Get internal host port index
	JAL	R8,AARDO1,,		:Count one character
	EI	:INTACC			:###EV
	LM	R0,XREGSV,XD		:RECOVER ALL OUR REGISTERS
	JR	R13			:RETURN

XRYOU1	HS	0
	STB	R1,XOUDDT+1,,		:SET UP CELL FOR DDT
	SVC	0B,XOUDDT,,
	LM	R0,XREGSV,XD		:RECOVER RREGISTERS
	JR	R13			:AND RETURN

	ENDMO.(XRAY)
	EI	:1-KILLIT
	KILMSG(XRAY)

:	***NOTHING PAST THIS POINT***


 	SUBTTL DEBUG
:
:		***   ***** ****   *   *   ***
:		*   * *     *   *  *   *  *
:		*   * ****  ****   *   *  *  **
:		*   * *     *   *  *   *  *   *
:		***   ***** ****    ***    ***

::#####################################################################
::
::	MODULE:			DEBUG
::
::	FUNCTION:		DEBUGGERS
::
::	SUBTTLS:		UTILITIES
::				PORT LOGON/LOGOFF DEBUGGER <LNFDBG>
::				CRQ BUILDING/ZAPPING DEBUGGER <CBZDBG>
::				BUFFER STRUCTURE DEBUGGER <BFSDBG>
::				NODE CODE - SUPE COMM. DEBUGGER <LPGDBG>
::				LINE/LINK DEBUGGER <LNKDBG>     ###sdw
::				OTHER DEBUGGING AIDS
::				XRAY COMMANDS
::
::	###LSH	THIS DEBUGGER IS IMPLEMENTED BY LOUISA HSU  
::
::#####################################################################

	IF	1-KILLIT		:TO ASSEMBLE OR NOT 

	BEGMO.

      IF	NAD68
	SEG	1			:DEBUG in SEG1 in 68K environment###wjl
      ELSE	:Engine
	SEG	0D			:DEBUGGER  RUNS IN SEGD
      EI	:NAD68

	SUBTTL DEBUG ( UTILITIES )

       IF      DBGON
::*********************************************************************
::
::      SUBROUTINE:     DBSVRG:                                 ###sdw
::      FUNCTION:       SAVES ALL REGS IN REGST TO GIVEN DEBUGGER RING
::      CALLING SEQ:    JAL     R4,INLNFB
::      INPUT:          R6 - RING POINTER
::                      R5 - RING SIZE
::                      R7 - RING ADDRESS
::      OUTPUT          R6 - RING POINTER
::*********************************************************************

DBSVRG  LA      R8,REGST        :finish setting up DBMOVE
        LHI     R9,$A 4*16      :save 16 regs of data
        JAL     R3,DBMOVE       :save data into ring
        JR      R4

::*********************************************************************
::
::	SUBROUTINE:	DBMOVE                                          :###sdw
::	FUNCTION:	MOVE DATA INTO SPECIFIED HISTORY RING
::	CALLING SEQ:	JAL	R3,DBMOVE
::	INPUT:		R5 - RING SIZE
::			R6 - POINTER INTO RING
::			R7 - RING ADDRESS
::			R8 - DATA ADDRESS
::			R9 - BYTES OF DATA TO MOVE (MINIMUM OF 2)
::
::*********************************************************************


DBMOVE  LIS     R1,0            :how far along
DBMOV1  LHL     R0,0,R1,R8      :get the halfword
        STH     R0,0,R6,R7      :store into ring
        AIS     R6,2            :bump pointer
        CR      R6,R5           :check wrap
        JLFS    DBMOV2          :no wrap
        LIS     R6,0
DBMOV2  AIS     R1,2            :bump pointer into data
        CR      R1,R9           :move enough data yet?
        JLBS    DBMOV1          :more to do
        JR      R3

       EI      :DBGON

	IF	LNFDBG

::*********************************************************************
::
::	SUBROUTINE:	INLNFH:
::	FUNCTION:	INCREMENT "LNFHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INLNFH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLNFH	HS	0
	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,LNFSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLNFH


::*********************************************************************
::
::	SUBROUTINE:	INLNFB:
::	FUNCTION:	INCREMENT "LNFHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INLNFB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLNFB	HS	0
	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,LNFSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLNFB

::*********************************************************************
::
::	SUBROUTINE:	EVNLNF:
::	FUNCTION:	EVEN UP "LNFHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNLNF
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNLNF	HS	0
	AIS	R6,1
	NHI	R6,-2		:INSURE HALF WORD BOUNDARY
	JR	R4		:END OF EVNLNF

::*********************************************************************
::
::	SUBROUTINE:	MRKLNF:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING LNFHST
::	CALLING SEQ:	JAL	R15,MRKLNF
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::			R3 - ROUTINE NUMBER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKLNF	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,LNFHST,R6,
	JAL	R4,INLNFH
	STH	R3,LNFHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INLNFH
	JR	R15			:END OF MRKLNF

::*********************************************************************
::
::	SUBROUTINE:	BUFLNF:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING LNFHST
::	CALLING SEQ:	JAL	R3,BUFLNF
::	INPUT:		R6 - RING POINTER
::			R3 - LINK REGISTER
::			R2 - BUFFER NUMBER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFLNF	HS	0
	STH	R2,LNFHST,R6,	:BUFFER NUMBER
	JAL	R4,INLNFH
	LHL	R4,BF,R2,
	STH	R4,LNFHST,R6,	:BF OF BUFFER (R2)
	JAL	R4,INLNFH
	LHL	R4,BF+4,R2,
	STH	R4,LNFHST,R6,	:BF OF BUFFER (R2)+4
	JAL	R4,INLNFH
	JR	R3		:END OF BUFLNF


::*********************************************************************
::
::	SUBROUTINE:	CLALNF:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R10) INTO RING LNFHST
::	CALLING SEQ:	JAL	R3,CLALNF
::	INPUT:		R6  - RING POINTER
::			R10 - ADDRESS OF CALLER
::			R3 - LINK REGISTER
::	OUTPUT:		R6  - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

CLALNF	HS	0
	EXHR	R10,R10
	STH	R10,LNFHST,R6,                  :CALLER (R10)
	EXHR	R10,R10
	JAL	R4,INLNFH
	STH	R10,LNFHST,R6,
	JAL	R4,INLNFH
	JR	R3		:END OF CLALNF

	EI	:LNFDBG


	IF	CBZDBG

::*********************************************************************
::
::	SUBROUTINE:	INCBZH:
::	FUNCTION:	INCREMENT "CBZHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INCBZH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INCBZH	HS	0
	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,CBZSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INCBZH


::*********************************************************************
::
::	SUBROUTINE:	INCBZB:
::	FUNCTION:	INCREMENT "CBZHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INCBZB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INCBZB	HS	0
	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,CBZSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INCBZB

::*********************************************************************
::
::	SUBROUTINE:	EVNCBZ:
::	FUNCTION:	EVEN UP "CBZHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNCBZ
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNCBZ	HS	0
	AIS	R6,1
	NHI	R6,-2		:INSURE HALF WORD BOUNDARY
	JR	R4		:END OF EVNCBZ

::*********************************************************************
::
::	SUBROUTINE:	MRKCBZ:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING CBZHST
::	CALLING SEQ:	JAL	R15,MRKCBZ
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKCBZ	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,CBZHST,R6,
	JAL	R4,INCBZH
	STH	R3,CBZHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INCBZH
	JR	R15			:END OF MRKCBZ

::*********************************************************************
::
::	SUBROUTINE:	BUFCBZ:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING CBZHST
::	CALLING SEQ:	JAL	R3,BUFCBZ
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFCBZ	HS	0
	STH	R2,CBZHST,R6,	:BUFFER NUMBER
	JAL	R4,INCBZH
	LHL	R4,BF,R2,
	STH	R4,CBZHST,R6,	:BF OF BUFFER
	JAL	R4,INCBZH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,CBZHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INCBZH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFCBZ

::*********************************************************************
::
::	SUBROUTINE:	CL9CBZ:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R9) INTO RING CBZHST
::	CALLING SEQ:	JAL	R3,CL9CBZ
::	INPUT:		R6 - RING POINTER
::			R9 - ADDRESS OF CALLER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

CL9CBZ	HS	0
	EXHR	R9,R9
	STH	R9,CBZHST,R6,	:CALLER
	EXHR	R9,R9
	JAL	R4,INCBZH
	STH	R9,CBZHST,R6,
	JAL	R4,INCBZH
	JR	R3		:END OF CL9CBZ

	EI	:CBZDBG


	IF	BFSDBG

::*********************************************************************
::
::	SUBROUTINE:	INBFSH:
::	FUNCTION:	INCREMENT "BFSHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INBFSH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INBFSH	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,BFSSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INBFSH


::*********************************************************************
::
::	SUBROUTINE:	INBFSB:
::	FUNCTION:	INCREMENT "BFSHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INBFSB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INBFSB	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,BFSSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INBFSB

::*********************************************************************
::
::	SUBROUTINE:	EVNBFS:
::	FUNCTION:	EVEN UP "BFSHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNBFS
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNBFS	HS	0
	AIS	R6,1
	NHI	R6,-2		:INSURE HW BOUNDARY
	JR	R4		:END OF EVNBFS

::*********************************************************************
::
::	SUBROUTINE:	MRKBFS:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING BFSHST
::	CALLING SEQ:	JAL	R15,MRKBFS
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKBFS	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,BFSHST,R6,
	JAL	R4,INBFSH
	STH	R3,BFSHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INBFSH
	JR	R15			:END OF MRKBFS

::*********************************************************************
::
::	SUBROUTINE:	BUFBFS:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING BFSHST
::	CALLING SEQ:	JAL	R3,BUFBFS
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFBFS	HS	0
	STH	R2,BFSHST,R6,	:BUFFER NUMBER
	JAL	R4,INBFSH
	LHL	R4,BF,R2,
	STH	R4,BFSHST,R6,	:BF OF BUFFER
	JAL	R4,INBFSH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,BFSHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INBFSH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFBFS

::*********************************************************************
::
::	SUBROUTINE:	CL3BFS:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R3) INTO RING BFSHST
::	CALLING SEQ:	JAL	R15,CL3BFS
::	INPUT:		R6 - RING POINTER
::			R3 - ADDRESS OF CALLER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

CL3BFS	EXHR	R3,R3
	STH	R3,BFSHST,R6,	:CALLER
	EXHR	R3,R3
	JAL	R4,INBFSH
	STH	R3,BFSHST,R6,
	JAL	R4,INBFSH
	JR	R15		:END OF CL3BFS

::*********************************************************************
::
::	SUBROUTINE:	FRLTDB:
::	FUNCTION:	SAVE "FREELT" INTO RING BFSHST
::	CALLING SEQ:	JAL	R3,FRLTDB
::	INPUT:		R6 - RING POINTER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

FRLTDB	HS	0
	LHL	R4,FREELT
	STH	R4,BFSHST,R6,	:SAVE FREELT INTO RING BFSHST
	JAL	R4,INBFSH
	JR	R3		:END OF FRLTDB

::*********************************************************************
::
::	SUBROUTINE:	REBLDB:
::	FUNCTION:	SAVE "REBL" INTO RING BFSHST
::	CALLING SEQ:	JAL	R3,REBLDB
::	INPUT:		R6 - RING POINTER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

REBLDB	HS	0
	LHL	R4,REBL
	STH	R4,BFSHST,R6,	:SAVE REBL INTO RING BFSHST
	JAL	R4,INBFSH
	JR	R3		:END OF REBLDB

	EI	:BFSDBG

	IF	LPGDBG

::*********************************************************************
::
::	SUBROUTINE:	INLPGH:
::	FUNCTION:	INCREMENT "LPGHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INLPGH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLPGH	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,LPGSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLPGH


::*********************************************************************
::
::	SUBROUTINE:	INLPGB:
::	FUNCTION:	INCREMENT "LPGHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INLPGB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLPGB	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,LPGSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLPGB

::*********************************************************************
::
::	SUBROUTINE:	EVNLPG:
::	FUNCTION:	EVEN UP "LPGHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNLPG
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

EVNLPG	HS	0
	AIS	R6,1
	NHI	R6,-2		:INSURE HW BOUNDARY
	JR	R4		:END OF EVNLPG

::*********************************************************************
::
::	SUBROUTINE:	MRKLPG:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING LPGHST
::	CALLING SEQ:	JAL	R15,MRKLPG
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKLPG	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,LPGHST,R6,
	JAL	R4,INLPGH
	STH	R3,LPGHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INLPGH
	JR	R15			:END OF MRKLPG

::*********************************************************************
::
::	SUBROUTINE:	BUFLPG:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING LPGHST
::	CALLING SEQ:	JAL	R3,BUFLPG
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFLPG	HS	0
	STH	R2,LPGHST,R6,	:BUFFER NUMBER
	JAL	R4,INLPGH
	LHL	R4,BF,R2,
	STH	R4,LPGHST,R6,	:BF OF BUFFER
	JAL	R4,INLPGH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,LPGHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INLPGH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFLPG

	EI	:LPGDBG


	IF	LNKDBG

::*********************************************************************
::
::	SUBROUTINE:	INLNKH:
::	FUNCTION:	INCREMENT "LNKHST" RING POINTER BY HALFWORD
::	CALLING SEQ:	JAL	R4,INLNKH
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLNKH	AIS	R6,2		:INCREMENT POINTER BY HALFWORD
	CHI	R6,LNKSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLNKH


::*********************************************************************
::
::	SUBROUTINE:	INLNKB:
::	FUNCTION:	INCREMENT "LNKHST" RING POINTER BY BYTE
::	CALLING SEQ:	JAL	R4,INLNKB
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

INLNKB	AIS	R6,1		:INCREMENT POINTER BY BYTE
	CHI	R6,LNKSIZ	:CHECK IF NEED WRAP AROUND
	JLR	R4		:DON'T NEED WRAP
	LIS	R6,0		:YES,WRAP AROUND
	JR	R4		:END OF INLNKB

::*********************************************************************
::
::	SUBROUTINE:	EVNLNK:
::	FUNCTION:	EVEN UP "LNKHST" RING POINTER (INSURE HW BOUNDARY)
::	CALLING SEQ:	JAL	R4,EVNLNK
::	INPUT:		R6 - RING POINTER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************


EVNLNK	AIS	R6,1
	NHI	R6,-2		:INSURE HW BOUNDARY
	JR	R4		:END OF EVNLNK

::*********************************************************************
::
::	SUBROUTINE:	MRKLNK:
::	FUNCTION:	WRITE MARK AND ROUTINE NUMBER INTO RING LNKHST
::	CALLING SEQ:	JAL	R15,MRKLNK
::	INPUT:		R6 - RING POINTER
::			R3 - ROUTINE NUMBER
::			R4 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::
::*********************************************************************

MRKLNK	LHI	R4,HSUMRK		:WRITE MARK FIRST
	STH	R4,LNKHST,R6,
	JAL	R4,INLNKH
	STH	R3,LNKHST,R6,		:FOLLOWED BY A ROUTINE NUMBER
	JAL	R4,INLNKH
	JR	R15			:END OF MRKLNK

::*********************************************************************
::
::	SUBROUTINE:	BUFLNK:
::	FUNCTION:	WRITE BUFFER (R2)'S STRUCTURE INTO RING LNKHST
::	CALLING SEQ:	JAL	R3,BUFLNK
::	INPUT:		R6 - RING POINTER
::			R2 - BUFFER NUMBER
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

BUFLNK	HS	0
	STH	R2,LNKHST,R6,	:BUFFER NUMBER
	JAL	R4,INLNKH
	LHL	R4,BF,R2,
	STH	R4,LNKHST,R6,	:BF OF BUFFER
	JAL	R4,INLNKH
	XHI	R2,4
	LHL	R4,BF,R2,
	STH	R4,LNKHST,R6,	:BF OF COMPLEMENTARY BUFFER
	JAL	R4,INLNKH
	XHI	R2,4		:SWITCH TO ORIGINAL BUFFER
	JR	R3		:END OF BUFLNK

::*********************************************************************
::
::	SUBROUTINE:	ST1LNK:
::	FUNCTION:	SAVE ADDRESS OF CALLER (R8) INTO RING LNKHST
::	CALLING SEQ:	JAL	R3,ST1LNK
::	INPUT:		R6 - RING POINTER
::			R1 - WORD TO SAVE
::			R3 - LINK REGISTER
::	OUTPUT:		R6 - RING POINTER
::	DESTROYED:	R4
::
::*********************************************************************

ST1LNK	EXHR	R1,R1           :stores word of R1                      ###sdw
	STH	R8,LNKHST,R6,	:CALLER
	EXHR	R1,R1
	JAL	R4,INLNKH
	STH	R1,LNKHST,R6,
	JAL	R4,INLNKH
	JR	R3		:END OF ST1LNK

	EI	:LNKDBG



	SUBTTL 	DEBUG ( PORT LOGON/LOGOFF DEBUGGER <LNFDBG> )

	IF	LNFDBG		:PORT LOGON/LOGOFF DEBUGGER

::*********************************************************************
::
::	SUBROUTINE:	LINDB1
::	FUNCTION:	DEBUGGER 1 FOR LOGIN
::	CALLING SEQ:	JAL	R14,LINDB1
::
::*********************************************************************

LINDB1	LHL	R3,LINDIS       :DEBUGGER FOR LOGIN
	JER	R14
	LHL	R6,LNFPTR,,
	LIS	R3,2		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLNF
	STH	CHN,LNFHST,R6,	:ABS LOGIN CHANNEL NUMBER
	JAL	R4,INLNFH
	JAL	R3,BUFLNF	:STORE BUFFER STRUCTURE OF LOGIN BUFFER
	LHL	R3,TVRBUF
	STH	R3,LNFHST,R6,	:SUPERVISOR BUFFER
	JAL	R4,INLNFH
	STH	R0,LNFHST,R6,	:TID OF THE PORT
	JAL	R4,INLNFH
	STH	R6,LNFPTR,,
	JR	R14		:END OF LINDB1

	EI	:LNFDBG		:END OF PORT LOGON/LOGOFF DEBUGGER



	SUBTTL DEBUG ( CRQ BUILDING/ZAPPING DEBUGGER <CBZDBG> )

	IF	CBZDBG		:CIRCUIT BUILDING/ZAPPING DEBUGGER

::*********************************************************************
::
::	SUBROUTINE:	CRHDB1:
::	FUNCTION:	DEBUGGER 1 FOR CRQHCR
::	CALLING SEQ:	JAL	R14,CRHDB1
::
::*****************************************************************

CRHDB1	LHL	R3,CRQDIS       :DEBUGGER  1 FOR CRQHCR
	JER	R14
	LHL	R6,CBZPTR,,
	LIS	R3,8		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
	JAL	R3,BUFCBZ	:BUFFER STRUCTURE OF ORIGINAL BUFFER
	STH	R6,CBZPTR,,
	JR	R14		:END OF CRHDB1

::*********************************************************************
::
::	SUBROUTINE:	CRQDB1:
::	FUNCTION:	DEBUGGER 1 FOR CRQ
::	CALLING SEQ:	JAL	R14,CRQDB1
::
::*********************************************************************

CRQDB1	LHL	R3,CRQDIS       :DEBUGGER  1 FOR CRQ
	JER	R14
	LHL	R6,CBZPTR,,
	LIS	R3,9		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
	JAL	R3,BUFCBZ	:BUFFER STRUCTURE OF NEEDLE BUFFER
	STH	R6,CBZPTR,,
	JR	R14		:END OF CRQDB1

::*********************************************************************
::
::	SUBROUTINE:	ZPHDB1:
::	FUNCTION:	DEBUGGER FOR ZAPHRD
::	CALLING SEQ:	JAL	R14,ZPHDB1
::
::*********************************************************************

ZPHDB1	LHL	R3,ZAPDIS	:DEBUGGER FOR  ZAPHRD
	JER	R14

	LHL	R6,CBZPTR,,
	LIS	R3,0A		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
	JAL	R3,BUFCBZ	:STORE BUFFER STRUCTURE OF ORIGINAL BUF.
	STH	R6,CBZPTR,,
	JR	R14		:END OF ZPHDB1

::*********************************************************************
::
::	SUBROUTINE:	ZPVDB1:
::	FUNCTION:	DEBUGGER FOR ZAPV
::	CALLING SEQ:	JAL	R14,ZPVDB1
::
::*********************************************************************

ZPVDB1	LHL	R3,ZAPDIS	:DEBUGGER FOR  ZAPV
	JER	R14
	LHL	R6,CBZPTR,,
	LIS	R3,0B		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
	JAL	R3,BUFCBZ	:SOTRE BUFFER STRUCTURE OF ORIGINAL BUF.
	STH	R6,CBZPTR,,
	JR	R14		:END OF ZPVDB1

::::*************************************************
:  Debugger for gateway GB3CR3
:   R5 channel clearing IOTAB
:                                       sdw
::***************************************************

        IF      T2GATE
GPZDB3  LHL     R3,ZAPDIS       :DEBUGGER FOR DB3CR3
        JER     R14

	LHL	R6,CBZPTR,,
	LHI	R3,1E		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
        STH     R5,CBZHST,R6,    :save the channel number
        JAL     R4,INCBZH       :bump up pointer by 2
	STH	R6,CBZPTR,,
	JR	R14		:END OF ZPVDB1
        EI      :T2GATE

::::*************************************************
:  Debugger for gateway ZAPX7
:   R3 channel clearing IOTAB
:                                       sdw
::***************************************************

        IF      T2GATE
GPZDB2	LHL	R3,ZAPDIS	:DEBUGGER FOR  ZAPX7
	JER	R14
	LHL	R6,CBZPTR,,
	LHI	R3,1E		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
        L       R3,REGST+3*4    :we want what was register R3
        STH     R3,CBZHST,R6,   :save the channel number
        JAL     R4,INCBZH       :bump up pointer by 2
	STH	R6,CBZPTR,,
	JR	R14		:END OF ZPVDB1
        EI      :T2GATE


::::*************************************************
:  Debugger for gateway GLZPV
:   r9 link, r5 channel clearing IOTAB
:                                       sdw
::***************************************************

        IF      T2GATE
GPZDB1	LHL	R3,ZAPDIS	:DEBUGGER FOR  GLZPV
        JER     R14
	LHL	R6,CBZPTR,,
	LHI	R3,1C		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKCBZ
	JAL	R3,CL9CBZ	:CALLER (R9)
        STH     R5,CBZHST,R6,    :save the channel number
        JAL     R4,INCBZH       :bump up pointer by 2
	STH	R6,CBZPTR,,
	JR	R14		:END OF ZPVDB1
        EI      :T2GATE

::*******************************************************
:   Replace NDREAD's use of buffers by use of debugging routine
:       All of buffer in R2 is needle
:                                       sdw
::********************************************************

       IF       NDREAD

NEDDB1  LHL     R3,CRQDIS       :level 2
        JER     R14
        LHL     R6,CBZPTR,,
        LIS     R3,7            :debugger #7
        JAL     R15,MRKCBZ
        L       R3,BB,R2,       :get start of data
NEDDB2  JAL     R8,PCI,,
        STB     R1,CBZHST,R6,
        JAL     R4,INCBZB
        C       R3,BE,R2,
        JNBS    NEDDB2          :copy needle
        AIS     R6,1
        NHI     R6,-2           :put on HW boundary again
        STH     R6,CBZPTR,,
        JR      R14

       EI       :NDREAD

       IF       SUPER           :supe build zap debuggers
::*****************************************************************
::   SUIDB1 save chn 1 msg into ring (these generally cause the supe
::          to zap the circuit so belong in build zap debugger)         ###sdw
::**********************************************************************

SUIDB1  LHL     R3,ZAPDIS       :deals with zapping
        JER     R14
        LHL     R6,CBZPTR,,     :ring pointer
        LHI     R3,0E           :for supe control (error) chars
        JAL     R15,MRKCBZ,,    :put a mark into buffer
        STH     R5,CBZHST,R6,   :chn number of bad chars
        JAL     R4,INCBZH
        LHL     R0,REGST,,      :get message type
        STH     R0,CBZHST,R6,   :save it
        JAL     R4,INCBZH       :update ring
        LHL     R0,SUICHR       :get offending chars
        JAL     R4,INCBZH
        STH     R6,CBZPTR,,     :save pointer
        JR      R14             :and done

        EI      :SUPER          :supe zapping

	EI	:CBZDBG		:END OF CRQ BUILDING/ZAPPING DEBUGGER



	SUBTTL DEBUG ( BUFFER STRUCTURE DEBUGGER <BFSDBG> )

	IF	BFSDBG		:BUFFER STRUCTURE DEBUGGER

::*********************************************************************
::
::	SUBROUTINE:	GFCDB1:
::	FUNCTION:	DEBUGGER FOR GFCBUF
::	CALLING SEQ:	JAL	R14,GFCDB1
::
::*********************************************************************

GFCDB1	LHL     R3,GRFDIS
        JER     R14
	LHL	R6,BFSPTR,,	
	LIS	R3,0C		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	LR	R3,R8		:CALLER (R8)
	JAL	R15,CL3BFS
	LHL	R2,FREELB
	STH	R2,BFSHST,R6,	:BUFFER NUMBER
	JAL	R4,INBFSH
	STH	R6,BFSPTR,,	
	JR	R14		:END OF GFCDB1

::*********************************************************************
::
::	SUBROUTINE:	RFCDB1:
::	FUNCTION:	DEBUGGER FOR RFCBUF
::	CALLING SEQ:	JAL	R14,RFCDB1
::
::*********************************************************************

RFCDB1	LHL     R3,GRFDIS
        JER     R14
	LHL	R6,BFSPTR,,
	LIS	R3,0D		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	LR	R3,R8		:CALLER (R8)
	JAL	R15,CL3BFS
	JAL	R3,BUFBFS	:STORE THE BUFFER (R2)'S STRUCTURE
	STH	R6,BFSPTR,,	
	JR	R14		:END OF RFCDB1

::*********************************************************************
::
::	SUBROUTINE:	CBCDB1:
::	FUNCTION:	DEBUGGER 1 FOR CBCLR
::	CALLING SEQ:	JAL	R14,CBCDB1
::
::*********************************************************************

CBCDB1	LHL	R3,CBCDIS	:DEBUGGER  1 FOR   CBCLR
        JER     R14
	LHL	R6,BFSPTR,,
	LHI	R3,0F		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	LR	R3,R8		:CALLER (R8)
	JAL	R15,CL3BFS
	JAL	R3,BUFBFS	:STRUCTURE OF ORIGINAL BUFFER
	LHL	R4,BCT,R2,
	STH	R4,BFSHST,R6,	:BCT OF ORIGINAL
	JAL	R4,INBFSH
	JAL	R3,FRLTDB	:OLD FREELT (BEFORE BUFFER IS CLEARED)
	STH	R6,BFSPTR,,
	JR	R14		:END OF CBCDB1

::*********************************************************************
::
::	SUBROUTINE:	CBCDB2:
::	FUNCTION:	DEBUGGER 2 FOR CBCLR
::	CALLING SEQ:	JAL	R14,CBCDB2
::
::*********************************************************************

CBCDB2	LHL	R3,CBCDIS	:DEBUGGER  2 FOR  CBCLR
        JER     R14
	LHL	R6,BFSPTR,,
	JAL	R3,FRLTDB	:NEW FREELT (AFTER BUFFER IS CLEARED)
	STH	R6,BFSPTR,,
	JR	R14		:END OF CBCDB2

::*********************************************************************
::
::	SUBROUTINE:	WREDB1:
::	FUNCTION:	DEBUGGER 1 FOR WRE
::	CALLING SEQ:	JAL	R14,WREDB1
::
::*********************************************************************

WREDB1	LHL	R3,WREDIS	:DEBUGGER 1 FOR  WRE
        JER     R14
	LHL	R6,BFSPTR,,
	LHI	R3,10		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	LR	R3,R0		:CALLER (R0)
	JAL	R15,CL3BFS
	JAL	R3,FRLTDB	:OLD FREELT (BEFORE LINK RESERVE TANK)
	JAL	R3,REBLDB	:OLD REBL (BEFORE LINK RESERVE TANK)
	STH	R6,BFSPTR,,
	JR	R14		:END OF WREDB1

::*********************************************************************
::
::	SUBROUTINE:	WREDB2:
::	FUNCTION:	DEBUGGER 2 FOR WRE
::	CALLING SEQ:	JAL	R14,WREDB2
::
::*********************************************************************

WREDB2	LHL	R3,WREDIS	:DEBUGGER 2 FOR  WRE
        JER     R14
	LHL	R6,BFSPTR,,
	JAL	R3,FRLTDB	:NEW FREELT (AFTER LINK RESERVE TANK)
	JAL	R3,REBLDB	:NEW REBL (AFTER LINK RESERVE TANK)
	STH	R6,BFSPTR,,
	JR	R14		:END OF WREDB2

::*********************************************************************
::
::	SUBROUTINE:	CKZDB1:
::	FUNCTION:	DEBUGGER 1 FOR CKZB
::	CALLING SEQ:	JAL	R14,CKZDB1
::
::*********************************************************************

CKZDB1	LHL	R3,WREDIS	:DEBUGGER 1  FOR  CKZB
        JER     R14
	LHL	R6,BFSPTR,,
	LHI	R3,11		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	JAL	R3,FRLTDB	:NEW FREELT (AFTER GOT 80 BUFFERLETS
				:AND REFILLED THE RESERVE TANK)
	JAL	R3,REBLDB	:NEW REBL (AFTER GOT 80 BUFFERLETS 
				:AND REFILLED THE RESERVE TANK)
	STH	R6,BFSPTR,,
	JR	R14		:END OF CKZDB1

::*********************************************************************
::
::	SUBROUTINE:	RBZDB1
::	FUNCTION:	DEBUGGER 1 FOR REBZ
::	CALLING SEQ:	JAL	R14,RBZDB1
::
::*********************************************************************

RBZDB1	LHL	R3,WREDIS	:DEBUGGER 1 FOR  REBZ
        JER     R14
	LHL	R6,BFSPTR,,
	LHI	R3,12		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	STH	R2,BFSHST,R6,	:THE BUFFER ZAPPED
	JAL	R4,INBFSH
	JAL	R3,FRLTDB	:NEW FREELT (AFTER BUFFER IS ZAPPED)
	STH	R6,BFSPTR,,
	JR	R14		:END OF RBZDB1

::*********************************************************************
::
::	SUBROUTINE:	BFZDB1
::	FUNCTION:	DEBUGGER 1 FOR BUFZAP
::	CALLING SEQ:	JAL	R14,BFZDB1
::
::*********************************************************************

BFZDB1	LHL	R3,WREDIS	:DEBUGGER  1 FOR  BUFZAP
        JER     R14
	LHL	R6,BFSPTR,,
	LHI	R3,13		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKBFS
	LR	R3,R0		:CALLER (R0)
	JAL	R15,CL3BFS
	STH	R2,BFSHST,R6,	:BUFFER NUMBER TO BE ZAPPED
	JAL	R4,INBFSH	
	STH	R8,BFSHST,R6,	:BUFFER COUNT OF THE BUFFER 
	JAL	R4,INBFSH
	JAL	R3,FRLTDB	:NEW FREELT (AFTER BUFFER IS CLEARED)
	JAL	R4,INBFSH
	STH	R6,BFSPTR,,
	JR	R14		:END OF BFZDB1


	EI	:BFSDBG		:END OF BUFFER STRUCTURE DEBUGGER



	SUBTTL	DEBUG ( NODE CODE - SUPE COMM. DEBUGGER <LPGDBG> )

	IF	LPGDBG

::*********************************************************************
::
::	SUBROUTINE:	LEPDB1
::	FUNCTION:	DEBUGGER 1 FOR LEP
::	CALLING SEQ:	JAL	R14,LEPDB1
::
::*********************************************************************

LEPDB1	LHL	R3,LPGDIS	:DEBUGGER  1  FOR  LEP
        JER     R14
	LHL	R6,LPGPTR,,
	LHI	R3,14		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLPG
	STH	R1,LPGHST,R6,	:LEADING 0
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	JR	R14		:END OF LEPDB1

::*********************************************************************
::
::	SUBROUTINE:	LEPDB2
::	FUNCTION:	DEBUGGER 2 FOR LEP
::	CALLING SEQ:	JAL	R14,LEPDB2
::	INPUT:		R5 - LRC (BYTE COUNT OF MESSAGE)
::
::*********************************************************************

LEPDB2	LHL	R3,LPGDIS	:DEBUGGER  2  FOR  LEP
        JER     R14
	LHL	R6,LPGPTR,,
	SIS	R5,2		:LRC INCLUDES LEADING 0 AND LRC ITSELF
        L       R3,BB,R2,

HSULE3	JAL	R8,PCI,,	:THE DATA IN LEP BUFFER
	STB	R1,LPGHST,R6,
	JAL	R4,INLPGB
	SIS	R5,1		:DECREMENT THE BYTE COUNT
	JGBS	HSULE3

	JAL	R4,EVNLPG	:EVEN UP RING POINTER
	STH	R6,LPGPTR,,
	JR	R14		:END OF LEPDB2

::*********************************************************************
::
::	SUBROUTINE:	LPDDB1
::	FUNCTION:	DEBUGGER 1 FOR LEP0D
::	CALLING SEQ:	JAL	R14,LPDDB1
::
::*********************************************************************

LPDDB1	LHL	R3,LPDDIS	:DEBUGGER  1  FOR  LEP0D
        JER     R14
	LHL	R6,LPGPTR,,
	LHI	R3,16		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLPG
	STH	CHN,LPGHST,R6,	:CHN (ABS LOGIN CHANNEL NUMBER)
	JAL	R4,INLPGH
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	LR	R3,R7
	NHI	R3,0E0
	STB	R3,LPGHST,R6,	:FLAG
	JAL	R4,INLPGB
	LR	R3,R7
	NHI	R3,1F
	STB	R3,LPGHST,R6,	:MESSAGE SUB TYPE
	JAL	R4,INLPGB
	STH	R6,LPGPTR,,
	JR	R14		:END OF LPDDB1

::*********************************************************************
::
::	SUBROUTINE:	LP9DB1:
::	FUNCTION:	DEBUGGER 1 FOR LEP09
::	CALLING SEQ:	JAL	R14,LP9DB1
::	INPUT:		R6 - LOGIN BUFFER
::			R7 - TO NETWORK BUFFER		
::
::*********************************************************************

LP9DB1	LHL	R3,LPDDIS	:DEBUGGER  1  FOR  LEP09
        JER     R14
	LR	R2,R6		:LOAD LOGIN BUFFER INTO R2
	LHL	R6,LPGPTR,,
	LHI	R3,17		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLPG
	STH	CHN,LPGHST,R6,	:CHN (ABS LOGIN CHANNEL NUMBER)
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	STH	R7,LPGHST,R6,	:TO NETWORK BUFFER NUMBER
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	JR	R14		:END OF LP9DB1

::*********************************************************************
::
::	SUBROUTINE:	LP9DB2:
::	FUNCTION:	DEBUGGER 2 FOR LEP09
::	CALLING SEQ:	JAL	R14,LP9DB2
::	INPUT:		R3 - CASE #
::
::*********************************************************************

LP9DB2	LHL	R3,LPDDIS	:DEBUGGER  2 FOR  LEP09
        JER     R14
	LHL	R6,LPGPTR,,
	STH	R3,LPGHST,R6,	:CASE NUMBER
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	JR	R14		:END OF LP9DB2

::*********************************************************************
::
::	SUBROUTINE:	LPZDB1
::	FUNCTION:	DEBUGGER 1 FOR LEPZLI
::	CALLING SEQ:	JAL	R14,LPZDB1
::
::*********************************************************************

LPZDB1	LHL	R3,LPDDIS	:DEBUGGER  1  FOR  LEPZLI
        JER     R14
	LHL	R6,LPGPTR,,
	LHI	R3,18		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLPG
	STH	CHN,LPGHST,R6,	:CHN (ABS LOGIN CHANNEL NUMBER)
	JAL	R4,INLPGH
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	STH	R6,LPGPTR,,
	JR	R14		:END OF LPZDB1


::*********************************************************************
::
::	SUBROUTINE:	LGGDB2
::	FUNCTION:	DEBUGGER 2 FOR LOGGER TO SAVE CASE #
::	CALLING SEQ:	JAL	R14,LGGDB2
::	INPUT:		R1 - CASE #
::
::*********************************************************************

LGGDB2	LHL	R3,LPGDIS	:DEBUGGER  2 FOR  LOGGER
        JER     R14
	LHL	R6,LPGPTR,,
	LHI	R3,15		:WRITE MARK AND ROUTINE NUMBER FIRST
	JAL	R15,MRKLPG
	JAL	R3,BUFLPG	:LOGIN BUFFER'S STRUCTURE
	STH	R1,LPGHST,R6,	:CASE #
	JAL	R4,INLPGH
	STH	R6,LPGPTR,,
	JR	R14		:END OF LGGDB2

::*********************************************************************
::
::	SUBROUTINE:	LGGDB3
::	FUNCTION:	DEBUGGER 3 FOR LOGGER
::	CALLING SEQ:	JAL	R14,LGGDB3
::	INPUT:		R2 - TVRBUF (SUPERVISOR BUFFER)
::
::*********************************************************************

LGGDB3	LHL	R3,LPGDIS	:DEBUGGER  3  FOR  LOGGER
        JER     R14
	LHL	R6,LPGPTR,,
	LHL	R3,BCT,R2,	:IS BUFFER EMPTY ?
	JLER	R14		:YES

	L	R3,LPGSSV	:GET POINTER TO MSG TYPE
HSULG5	HS	0
	LB	R1,0,R3		:GET CHARACTER
	STB	R1,LPGHST,R6,
	JAL	R4,INLPGB
	CL	R3,BE,R2,	:IS IT THE LAST CHAR. ?
	JEFS	HSULG6		:YES
	JAL	R8,NCI,,	:CALCULATE BUFFER OUTPUT POINTER
	J	HSULG5		:CONTINUE TO GET CHAR.
HSULG6	JAL	R4,EVNLPG	:EVEN UP RING POINTER
	STH	R6,LPGPTR,,
	JR	R14		:END OF LGGDB3

	EI	:LPGDBG		:END OF NODE CODE - SUPE COMM DEBUGGER


	SUBTTL	DEBUG ( LINK/LINE DEBUGGER <LNKDBG> )

	IF	LNKDBG		:LINE/LINK DEBUGGER                     ###sdw

::*********************************************************************
::
::      SUBROUTINE:     RTSDB1, RMSDB1
::      FUNCTION:       SAVES ALL REGS AT TIME OF LINK SNIP
::      CALLING SEQ:    JAL     R14,RTSDB1 (JAL R14,RMSDB1)
::      INPUT:          SAVED REGS AT REGST
::
::*********************************************************************

RMSDB1  LIS     R3,1            :RMK link snip
        JFS     RMSDB9
RTSDB1  LIS     R3,0            :RTD link Snip
RMSDB9  LHL     R6,LNKPTR,,     :get pointer of ring
        JAL     R15,MRKLNK      :put routine mark into ring
        LHI     R5,LNKSIZ       :set ourselves up for save reg routine
        LA      R7,LNKHST,,
        JAL     R4,DBSVRG       :move all saved regs to ring
        STH     R6,LNKPTR,,     :move all saved regs to ring
        JR      R14

::*********************************************************************
::
::	SUBROUTINE:	RTSDB2
::	FUNCTION:	SAVE PACKET THAT CAUSED LINK SNIP
::	CALLING SEQ:	JAL	R14,RTSDB2
::	INPUT:		CD (r13)
::
::*********************************************************************


RTSDB2  LIS     R3,3                    :routine #3             ###sdw
        LHL     R6,LNKPTR,,
        JAL     R15,MRKLNK              :put in our mark
        LR      R3,R13                  :R3 is index into BREC
        LIS     R10,1                   :how many packets to save
        J       TSODB6

::*********************************************************************
::
::	SUBROUTINE:	TSIDB1
::	FUNCTION:	DEBUGGER 1 SAVES INPUT WINDOW OF UPTO 25% OF HIST RING
::	CALLING SEQ:	JAL	R14,TSIDB1
::	INPUT:		KD - R15 linK Descriptor
::
::*********************************************************************

TSIDB1  LHL     R3,LKLDIS       :we to run?
        JER     R14
        LIS     R3,5            :our mark for input packets
        LHL     R6,LNKPTR,,     :get our pointer
        JAL     R15,MRKLNK      :mark our routine name
        L       R15,REGST+KD*4  :restore KD
        LB      R10,WSIZ,KD     :number of packets to move
	LHL	R3,ISEC,KD	:INITIAL INPUT SECTOR (PACKET 0 MOD WSIZ)
        J       TSODB6          :put our packets

::*********************************************************************
::
::	SUBROUTINE:	TSODB1
::	FUNCTION:	DEBUGGER 1 SAVES OUTPUT WINDOW OF UPTO 25% OF HIST RING
::	CALLING SEQ:	JAL	R14,TSODB1
::	INPUT:		KD - R15 linK Descriptor
::
::*********************************************************************

TSODB1  LHL     R3,LKLDIS       :we to run?
        JER     R14
        LIS     R3,4            :our mark for output packets
        LHL     R6,LNKPTR,,     :get our pointer
        JAL     R15,MRKLNK      :mark our routine name
        L       R15,REGST+KD*4  :restore KD
	LHL	R3,OSEC,KD	:INITIAL OUTPUT SECTOR (PACKET 0 MOD WSIZ)
	LB	R10,WSIZ,KD	:NUMBER OF PACKETS TO MOVE


:       Line/link packet save logic  R10 = number packets to save
:                                    R3  = index into BREC
TSODB6                          :our save packets routine name
	L	R3,BREC,R3
        LHI     R5,LNKSIZ       :get ring size
        LA      R7,LNKHST,,     :get ring address
	LR	R8,R3		:R8 POINTS TO FIRST SECTOR
        LIS     R11,0           :total moved (don't do too much)
TSODB9  LB      R9,0,R8         :get BORI
        NHI     R9,0F           :get count
        LB      R9,SYTWCN,R9,
        JAL     R3,DBMOVE       :move data to ring
        AHI     R8,80           :move it up to next packet in sector
        AR      R11,R9          :update how many moved
        CLHI    R11,LNKSIZ/8    :no more than 25% of ring
        JGFS    TSODB8
        SIS     R10,1
        JG      TSODB9          :move the entire window
TSODB8  STH     R6,LNKPTR,,
	JR	R14		:RETURN


::*********************************************************************
::
::	SUBROUTINE:	SIPDB1
::	FUNCTION:	DEBUGGER 1 SAVES BAD SIO PACKET (1ST 20 BYTES OF IT)
::	CALLING SEQ:	JAL	R14,SIPDB1
::	INPUT:		LN - R14 Line Number
::
::*********************************************************************

       IF       SILINS

SIPDB1  LHL     R3,LKLDIS       :is this debugger in use?
        JER     R14
	LHL	R8,PSLNUM	:Check if have line to check
        JLR     R14             :no line being traced
	AR	R8,R8		:2*LINE#
	CLH     R8,RGST+LN*4    :against the current (saved) line number
        JNR     R14
        LHL     R6,LNKPTR,,     :get pointer into our ring
        LIS     R3,6            :Bad SIO record received
        JAL     R15,MRKLNK      :save routine name
        LR      R1,R9           :save link (to SIPKSV)
        JAL     R3,ST1LNK       :save it
        STH     R8,LNKHST,R6,   :save line number
        JAL     R4,INLNKH
	LHI	R9,PKSVLH	:TOTAL LENTH OF SAVING
SIPDB9	L	R1,SIBUF,R11,R13
        GL      SIBUF
	AIS	R11,4
        SIS     R9,4            :count of how many saved
        JAL     R3,ST1LNK       :save it
        JGEBS   SIPDB9
        STH     R6,LNKPTR,,
	JR	R14
       EI       :SILINS

::*********************************************************************
::
::      SUBROUTINE:     SIBDB1
::      FUNCTION:       SAVES FIRST TWO WORDS OF SIO BUF WITH ILLEGAL
::                      COUNT AND R10-R15.
::      CALLING SEQ:    JAL     R14,SIBDB1
::      INPUT:          SIBUF, SIBUF+4 REGS 10-15
::
::*********************************************************************

       IF       SILINS

SIBDB1  LHL     R3,LKLDIS               :enabled?
        JER     R14
        LHL     R6,LNKPTR,,
        LHI     R3,19                   :debugger routine #
        JAL     R15,MRKLNK              :put in our mark
        LHI     R5,LNKSIZ               :set ourselves up for DBMOVE
        LA      R7,LNKHST,,             :ring address
        LIS     R9,8                    :bytes to move (two words)
        L       R11,RGST+4*R11
        L       R13,RGST+4*R13
        LA      R8,SIBUF,R11,R13        :start of sio buffer
        JAL     R3,DBMOVE               :save first two words
        LA      R8,RGST+4*R10           :now regs r10-r15
        LHI     R9,6*4                  :6 Regs
        JAL     R3,DBMOVE
        STH     R6,LNKPTR,,
        JR      R14                     :done                           ###sdw

       EI       :SILINS


	EI	:LNKDBG		:END OF LINK/LINE DEBUGGER


	SUBTTL	DEBUG (OTHER DEBUGGING AIDS)

::*********************************************************************
::
::	SUBROUTINE:	BFZDB2
::	FUNCTION:	DEBUGGER 2 FOR BUFZAP PROBLEM
::			SAVE SOME DATA OF THE BUFFER TO BE ZAPPED
::			BECAUSE OF BCT OVERFLOW.
::	CALLING SEQ:	JAL	R14,BFZDB2
::	INPUT:		R2 - BUFFER NUMBER TO BE ZAPED
::
::*********************************************************************

BFZDB2	LIS	R6,0		:POINTER TO THE SAVED BUFFER
	LHL	R3,BCT,R2,	:DOES BCT OF BUFFER OVERFLOW ?
	CI	R3,0FFF0	
	JLR	R14		:NO, EXIT

	L	R3,BB,R2,
HSUFZ5	HS	0
	LB	R1,0,R3		:GET CHARACTER
	STB	R1,BUFZSV,R6,	:STORE INTO BUFFER BUFZSV.
	CL	R3,BE,R2,	:IS IT THE LAST CHAR. ?
	JER	R14		:YES, EXIT
	JAL	R8,NCI,,	:CALCULATE BUFFER OUTPUT POINTER
	AIS	R6,1		:INCREMENT POINTER
	CHI	R6,BUFZSZ	:HAVE WE STORED BUFSZ BYTES YET ?
	JL	HSUFZ5		:CONTINUE GETTING CHAR.
	JR	R14		:END OF BFZDB2


	SUBTTL	DEBUG (XRAY COMMANDS)

::*********************************************************************
::
::	TABLE:		INTERP
::	FUNCTION:	THIS IS A TABLE TO SHOW 7-LETTER INTERPRETATIONS
::			FOR SOME OF THE ROUTINES.  ALL STRINGS MUST BE 7 CHARS
::			SINCE THE BYTE COUNT MAKES IT AN EIGHT BYTE STRUCTURE.
::
::*********************************************************************
	IF	DBGON
INTERP	HS	0
	SC	/RTDsnip/	:		ROUTINE NUMBER 0
	SC	/RMKsnip/	:          	ROUTINE NUMBER 1
	SC	/LOGIN  /	:LOGIN		ROUTINE NUMBER 2
	SC	/SnpPCKT/	:		ROUTINE NUMBER 3
	SC	/OUTWNDW/	:		ROUTINE NUMBER 4
	SC	/INWNDW /	:TEAR LINK IN	ROUTINE NUMBER 5
	SC	/BadSIOR/	:		ROUTINE NUMBER 6
	SC	/NEEDLE /	:display needle ROUTINE NUMBER 7
	SC	/CRQHCR /	:CRQHCR		ROUTINE NUMBER 8
	SC	/CRQ    /	:CRQ		ROUTINE NUMBER 9
	SC	/ZAPHRD /	:ZAPHRD		ROUTINE NUMBER A
	SC	/ZPV    /	:ZAPV		ROUTINE NUMBER B
	SC	/GFCBUF /	:GFCBUF		ROUTINE NUMBER C
	SC	/RFCBUF /	:RFCBUF		ROUTINE NUMBER D
	SC	/ERRtoSP/	:chn 1 to supe  ROUTINE NUMBER E
	SC	/CBCLR  /	:CBCLR		ROUTINE NUMBER F
	SC	/WRE    /	:WRE		ROUTINE NUMBER 10
	SC	/CKZB   /	:CKZB		ROUTINE NUMBER 11
	SC	/REBZ   /	:REBZ		ROUTINE NUMBER 12
	SC	/BUFZAP /	:BUFZAP		ROUTINE NUMBER 13
	SC	/LEP    /	:LEP		ROUTINE NUMBER 14
	SC	/LOGGER /	:LOGGER		ROUTINE NUMBER 15
	SC	/LEP0D  /	:LEP0D		ROUTINE NUMBER 16
	SC	/LEP09  /	:LEP09		ROUTINE NUMBER 17
	SC	/LEPZLI /	:LEPZLI		ROUTINE NUMBER 18
	SC	/SIBufEr/	:SIOBER	        ROUTINE NUMBER 19
	SC	/unused /	:               ROUTINE NUMBER 1A
	SC	/unused /	:               ROUTINE NUMBER 1B
	SC	/GLZPV  /	:GLZPV		ROUTINE NUMBER 1C
	SC	/GB3CR3 /	:GB3CR3		ROUTINE NUMBER 1D
	SC	/ZAPX7  /	:ZAPX7		ROUTINE NUMBER 1E
MXRTNM	EQ	(.-INTERP)/8-1	:MAX ROUTINE NUMBER

::*********************************************************************
::
::	SUBROUTINE:	TYPCIU
::	FUNCTION:	TYPE MESSAGE "This command is in use"
::
::*********************************************************************
TYPCIU	LA	R2,ASCCIU	:TYPE "This command is in use."
	JAL	R7,TYPASC,,
	J	XRCRLF,,	:QUIT AND YIELD

ASCCIU	SC	/"0D"0AThis command is in use./

::*********************************************************************
::
::	SUBROUTINE:	RSTCIU
::	FUNCTION:	RESET COMMAND IN USE INDICATOR TO INDICATE
::			THE COMMAND IS NOT IN USE.
::			0 = NOT IN USE,  1 = IN USE.
::	INPUT:		R8 = THE POINTER TO THE INDICATOR
::*********************************************************************
RSTCIU	LIS	R3,0
	STH	R3,,R8,		:RESET COMMAND IN USE INDICATOR
	J	XRCRLF,,	:QUIT AND YIELD

::*********************************************************************
::
::	SUBROUTINE:	XRDSRN
::	FUNCTION:	DISPLAY ALL THE DATA IN A HISTORY RING
::	CALLING SEQ:	JUMP 
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - COMMAND IN USE INDICATOR
::
::*********************************************************************
XRDSRN	HS	0
	LR	R12,R11		:KEEP THE ORIGINAL RING POINTER IN R12
DBINS1  LH      R3,SAVHST,R11,  :FLUSH LEADING ZEROS
        JNFS    DBINST
        AIS     R11,2
        CR      R11,R5
        JLFS    DBNWP1
        LIS     R11,0
DBNWP1  CR      R11,R12
        JNBS    DBINS1          :loop until done or all no more leading 0s
        J       RSTCIU          :is done

:       Now that leading 0s are gone we are ready to start printing
DBINST				:INITIALIZE THE STATE MARKERS
	LIS	R6,0		:HEAD LINE INDICATOR.  1 -- HEAD LINE.
	LIS	R10,8		:MAX # OF HW PER LINE. 9 -- HEAD LINE.
DBGTHW	LH      R3,SAVHST,R11,
	LR	R6,R6		:ARE WE EXPECTING A ROUTINE NUMBER
	JL	DBRTNM		:YES,
	CHI	R3,HSUMRK	:NO, THEN IS THIS A ROUTINE MARKER ?
	JE	DBHEAD		:YES, 
	CHI	R10,8		:IS IT THE FIRST DATA BYTE ?
	JNFS	DBTPHW		:NO, NOT THE FIRST DATA
	LR	R6,R6		:NEW LINE OF DATA -- DO WE FOLLOW A
				:HEADER ?
	JNFS	DBTPHW		:YES, FOLLOW A HEADER, JUST TYPE DATA
	JAL	R7,TYPCRL,,	:OTHERWISE, START A NEW LINE
	LA	R2,ASC8SP,,	:AND SPACE IN 8 PLACES
	JAL	R7,TYPASC,,
DBTPHW	HS	0		:NO, IT IS NOT THE FIRST DATA 
	JAL	R9,TYPHW,,	:OUTPUT THE HALFWORD IN HEX FROM R3
DBUPST	HS	0		:UPDATE THE STATE MARKERS
	SIS	R10,1		:DECREMENT LINE COUNTER
	AIS	R11,2		:INCREMENT RING OUT POINTER
	CR	R11,R5		:CHECK FOR RING WRAP
	JLFS	DBNOWP		:NO,
	LIS	R11,0		:YES, WRAP, REINIT TO BEGINNING OF RING
DBNOWP	CR	R11,R12		:HAVE WE GOTTEN BACK TO THE START YET ?
	JE	RSTCIU		:YES, GO TO RESET THE COMMAND IN USE
				:INDICATOR, AND THEN EXIT
	LR	R10,R10		:CHECK FOR END OF LINE
	JE	DBINST		:YES, HAS REACHED THE END OF LINE
				:GO TO REINIT THE STATE MARKER, AND
				:KEEP ON READING FROM RING
	J	DBGTHW		:OTHERWISE, JUST KEEP ON READING FROM RING
DBFLSH	HS	0		:FLUSH LEADING ZEROS
	AIS	R11,2		:INCREMENT RING OUT POINTER
	CR	R11,R5		:CHECK FOR RING WRAP
	JLFS	DBNWP		:NO,
	LIS	R11,0		:YES, WRAP, REINIT TO BEGINNING OF RING
DBNWP	CR	R11,R12		:HAVE WE GOTTEN BACK TO THE START YET ?
	JE	RSTCIU		:YES, GO TO RESET THE COMMAND IN USE
				:INDICATOR, AND THEN EXIT
	J	DBGTHW		:KEEP ON READING FROM RING

DBRTNM	HS	0
	LR	R3,R3		:CHECK IF GOT RIGHT ROUTINE NUMBER
	JL	DBFLSH		:NO, GET THE NEXT HW (get a new HW ###sdw)
	CHI	R3,MXRTNM	:SEE IF IT IS TOO BIG
	JG	DBFLSH		:IT IS TOO BIG, (get a new HW ###sdw 3-3-87)
	LR	R7,R3		:FOR INDEXING
        SLLS    R7,3            :make byte index into 8 byte index
	LA	R2,INTERP,R7,	:GET 7-LETTER INTERPRETATION
	JAL	R7,TYPASC,,	:TYPE 7-LETTER INTERPRETATION
	LA	R2,ASC1SP,,
	JAL	R7,TYPASC,,	:TYPE 2 SPACES
	LIS	R6,1		:INDICATE HAVE GOTTEN ROUTINE NUMBER
	J	DBUPST		:GO TO UPDATE STATE MARKER
DBHEAD	HS	0
	JAL	R7,TYPCRL,,	:START A NEW LINE
	LCS	R6,1		:REINIT THE HEAD LINE INDICATOR
				: -1 INDICATES WE ARE EXPECTING A
				:ROUTINE NUMBER.
	LIS	R10,9		:REINIT THE HEAD LINE COUNTER
	J	DBFLSH		:FLUSH THE ROUTINE MARKER, AND THEN
				:GO TO GET THE ROUTNE NUMBER
	EI	:DBGON

::*********************************************************************
::
::	SUBROUTINE:	LGXRDB
::	FUNCTION:	XRAY COMMAND "LG" TO DISPLAY HISTORY RING  
::			LNFHST --- PORT LOGON/LOGOFF HISTORY RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	LNFDBG
LGXRDB	HS	0
	LHI	R5,LNFSIZ
	LHL	R11,LNFPTR,,
	TS	LGINUS		:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,LGINUS
	LA	R1,LNFHST+LNFSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+LNFSIZ-2,,	:LAST DESTINATION HW
	LI	R3,10*(LNFSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING LNFHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:LNFDBG		:THE END OF LGXRDB
::*********************************************************************
::
::	SUBROUTINE:	CZXRDB
::	FUNCTION:	XRAY COMMAND "CZ" TO DISPLAY HISTORY RING  
::			CBZHST --- CIRCUIT BUILDING/ZAPPING HISTORY 
::					RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	CBZDBG
CZXRDB	HS	0
	LHI	R5,CBZSIZ
	LHL	R11,CBZPTR,,
	TS	CZINUS		:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,CZINUS
	LA	R1,CBZHST+CBZSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+CBZSIZ-2,,	:LAST DESTINATION HW
	LI	R3,10*(CBZSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING CBZHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:CBZDBG		:THE END OF CZXRDB
::*********************************************************************
::
::	SUBROUTINE:	BFXRDB
::	FUNCTION:	XRAY COMMAND "BF" TO DISPLAY HISTORY RING  
::			BFSHST --- BUFFER STRUCTURE  HISTORY RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	BFSDBG
BFXRDB	HS	0
	LHI	R5,BFSSIZ
	LHL	R11,BFSPTR,,
	TS	BFINUS		:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,BFINUS
	LA	R1,BFSHST+BFSSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+BFSSIZ-2,,	:LAST DESTINATION HW
	LI	R3,10*(BFSSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING BFSHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:BFSDBG		:THE END OF BFXRDB
::*********************************************************************
::
::	SUBROUTINE:	LLXRDB
::	FUNCTION:	XRAY COMMAND "LL" TO DISPLAY HISTORY RING  
::			LPGHST --- LEP/LOGGER HISTORY RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11- RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	LPGDBG
LLXRDB	HS	0
	LHI	R5,LPGSIZ
	LHL	R11,LPGPTR,,
	TS	LLINUS		:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,LLINUS
	LA	R1,LPGHST+LPGSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+LPGSIZ-2,,	:LAST DESTINATION HW
	LI	R3,10*(LPGSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING LPGHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:LPGDBG		:THE END OF LLXRDB
::*********************************************************************
::
::	SUBROUTINE:	LHXRDB
::	FUNCTION:	XRAY COMMAND "LH" TO DISPLAY HISTORY RING  
::			LNKHST --- LINE/LINK HISTORY RING.
::			LNKHST --- LINK/LINK RING.
::	CALLING SEQ:	JUMP FROM XLOOP
::	OUTPUT:		R5 - RING SIZE
::			R11 - RING POINTER
::			R8 - POINTER TO COMMAND IN USE INDICATOR
::
::*********************************************************************

	IF	LNKDBG
LHXRDB	LHI	R5,LNKSIZ
	LHL	R11,LNKPTR,,
	TS	LKINUS		:CHECK IF THIS COMMAND IS IN USE
	JN	TYPCIU		:YES, THIS COMMAND IS IN USE. EXIT
	LA	R8,LKINUS
	LA	R1,LNKHST+LNKSIZ-2,,	:LAST SOURCE HW
	LA	R2,SAVHST+LNKSIZ-2,,	:LAST DESTINATION HW
	LI	R3,10*(LNKSIZ/2-1)	:NUMBER OF HW TO BE MOVED
	COPY	R1,R3		:SAVE RING LNKHST INTO RING SAVHST
				:FIRST, AND THEN DISPLAY IT.
	J	XRDSRN		:GO TO DISPLAY THE RING.
	EI	:LNKDBG		:THE END OF LHXRDB

::*********************************************************************
::
::	SUBROUTINE:	THXRDB
::	FUNCTION:	XRAY COMMAND "TH" TO TURN ON/OFF HISTORY TRACE
::	CALLING SEQ:	JUMP FROM XLOOP
::	INPUT:		R3=ARGUMENT
::
::*********************************************************************

	IF	DBGON
THXRDB	HS	0
	CLHI	R2,4		:MUST BE SINGLE ARG
	JN	COMERR,,
	L	R3,VALUE1,XD	:GET TRACING LEVEL
	CHI	R3,0
	JE	THXR00		:LEVEL = 0, GO TO TURN FLAGS OFF
	CHI	R3,1
	JL	COMERR,,	:EXIT, IF LEVEL < 1
	CHI	R3,3		:					###wjl
	JG	COMERR,,	:EXIT, IF LEVEL > 3
	J	THXR01		:GO TO TURN FLAGS ON
THXR00	HS	0
	LIS	R1,0		:ARGUMENT  = 0
	LIS	R3,3		:TURN OFF ALL THE DEBUGGERS		###wjl
	J	THXR
THXR01	HS	0		:ARGUMENT  >= 1  AND <= 3
	LIS	R1,1
THXR	HS	0
	IF	CBZDBG
	STH	R1,ZAPDIS
	EI	:CBZDBG
	IF	BFSDBG
	STH	R1,GRFDIS
	EI	:BFSDBG
	IF	LPGDBG
	STH	R1,LPGDIS
	EI	:LPGDBG
	CHI	R3,2		:IS ARGUMENT >= 2 ?
	JL	XRCRLF,,	:NO, EXIT
THXR02	HS	0		:YES, ARGUMENT >= 2 AND <= 3
	IF	LNFDBG
	STH	R1,LINDIS
	EI	:LNFDBG
	IF	CBZDBG
	STH	R1,CRQDIS
	EI	:CBZDBG
	IF	BFSDBG
	STH	R1,CBCDIS
	EI	:BFSDBG
        IF      LNKDBG
        STH     R1,LKLDIS
        EI                      :LINK DEBUGGER
	IF	LPGDBG
	STH	R1,LPDDIS
	EI	:LPGDBG
	CHI	R3,3		:IS ARGUMENT = 3 ?
	JL	XRCRLF,,	:NO, EXIT
THXR03	HS	0		:YES
	IF	BFSDBG
	STH	R1,WREDIS
	EI	:BFSDBG
	J	XRCRLF,,	:EXIT

	EI	:DBGON

	ENDMO.(DEBUG)
	EI	:1-KILLIT
	KILMSG(DEBUG)

:	***NOTHING PAST THIS POINT***



	SUBTTL	FIN

:			***** ***** *   *
:			*       *   **  *
:			****    *   * * *
:			*       *   *  **
:			*     ***** *   *

::#####################################################################
::
::	MODULE:		F I N
::
::	FUNCTION:	SOME LAST MINUTE DEFINITIONS AND ERROR COMMENTS
::
::	SUBTTLS:
::		DMA region
::		Patch Areas, XRAY Symbol Table
::		Segment usuage
::		Physical addresses
::		BS - Bufferlet Statistics
::		Memory allocation symbol declaration
::
::#####################################################################

	IF	1-KILLIT	:TO ASSEMBLE OR NOT TO ASSEMBLE
	BEGMO.

:	SOME LAST MINUTE DEFINITIONS AND ERROR COMMENTS:

CRETIM	CURGMT
	SYAD(CRETIM)

        SEG.(0)
	RA	0

::*********************************************************************
::
::	CPU Utilization tables, counts, times
::
::*********************************************************************

	IF	DB.CPU

	IF	DSPTRC
EXADR0	WS	$A40		:DISPATCH TRACE TABLE		###OAS
EXTBLE	EQ	.-EXADR0	:DISPATCH TRACE TABLE LENGTH	###OAS
EXCNT0	WS	$A40		:DISPATCH TRACE COUNT TABLE	###OAS
	EI	:DSPTRC

EXC1CT	WS	1		:DISPATCH COUNT			###OAS
EXC2CT	WS	1		:TOP OF EXEC LOOP COUNT		###OAS
	IF	DB.CLK
EXCTIM	HS	1		:TIME IN EXEC PROCESSING	###OAS
EXCTM1	WS	1		:TIME OF LAST YIELD OR DISMISS	###OAS
	EI	:DB.CLK
CSYTCT	HS	1		:SYLVER DISMISS COUNT
	IF	DB.CLK
CPUTII	HS	1		:SLOT0 INTERVAL TIME
CSYTTM	HS	1		:SYLVER TIME 
CSYTFC	WS	1		:SYLVER DISPATCH TIME IN FASTC
CSYTSC	HS	1		:SYLVER DISPATCH TIME IN SLOT0 FASTC
CSYFRC	HS	1		:SYLVER FORCED DISMISS COUNT
	EI	:DB.CLK
	IF	SUPER
SUICCT	WS	1		:SUPIN CHARACTER COUNT OVER INTERVAL
SUOCCT	WS	1		:SUPOUT CHARACTER COUNT OVER INTERVAL
	EI	:SUPER
CPUTFL	HS	1		:<0 IF CPUTIL ACTIVE
CPUTTO	HS	2		:FASTC AT WHICH CPUTIL TIMES OUT IF >0
CPUTIN	HS	2		:CPUTIL MEASUREMENT INTERVAL
CPUTRQ	HS	1		:INIT TO -1 - SET TO LOG2 NO. SEC'S 
				:REQUESTED FOR CPUTIL.
CPUNRQ	HS	1		:SAVED VALUE OF CPUTRQ
CPUTFC	HS	2		:CPUTIL START FASTC
CPUTCD	HS	1		:CODE FOR ROUTINE CURRENTLY UNDER CPUTIL
CPUTTT	HS	1		:TOTAL TIME OF CPUTIL
CPUTTC	HS	1		:TOTAL DISMISS COUNT FOR CPUTIL
	IF	DSPTRC
CPUTND	HS	1		:TOTAL 'FAKE' DISMISS COUNT FOR CPUTIL	###OAS
	EI	:DSPTRC
CPUTTB	HS	(CPUTNE-1)*3	:CPUTIL STAT TABLE, 3 HW'S FOR EACH ROUTINE
	EI	:DB.CPU

	SUBTTL	FIN (DMA region)

::*********************************************************************
::
::	Define the DMA region for SIO mother board interface.
::	Define the DMA region in seg 0 here if switch SIBFRL is not
::	turned on. Otherwise, relocate DMA region to seg 2 (DATA module).
::	
::	************	NOTE	*************
::	Both of SIO DMA regions defined here and defined in DATA must
::	be the same.  Any change to them must be the same.	###LSH
::
::*********************************************************************

	SUBTTL	FIN (PATCH MACROS)

::*********************************************************************
::
::	MACRO:		PATCH:/CONPATCH:/ENDPATCH:
::	FUNCTION:
::	This code defines symbols and macros used for patching
::	released code and keeping a history of patches in Engine memory.
::
::	A file containing the actual patches to the code should be
::	assembled as the last file before saving the NIB file.
::
::	Patches are added by ORGing to the area to patch,
::	zeroing memory for the length of the patch, writing new
::	code starting at that area.
::	Three macros have been defined to do this.
::	Each patch should start with a PATCH macro and if the
::	patch is for more than one area it should be continued
::	with a CONPATCH macro.  The patch should be ended with
::	an ENDPATCH macro.
::
::	Using these macros will cause the patch number, author
::	area patched, and reason for patch to be output during assembly.
::	Also, a history table starting at PATHIS will be created with
::	16 (10hex) byte entries.
::	Each entry will contain the date and time of patch and the author
::	and can by displayed using the XRAY 'PQ' command.
::
::	If a patch must be temporarily added by hand, the
::	history area should updated accordingly.
::
::	SEGn,SnSIZE are defined for all node code segments and
::	segment address limit checking is performed for patches.
::
::	The following symbols are used by the patch macros.
::	They may be read by, but should not be modified by, a patch.
::
::	PAHPTR	pointer to the next available entry in PATHIS
::	PA0PTR	This symbol may be used to place a patch at the next
::		available address in the PATCH0 area.  It starts out
::		equal to PATCH0 and is moved up after each patch in
::		the PATCH0 area.  Use of the symbol assumes that all
::		patches from PATCH0 to PATCH0+P0SIZE will be done in order.
::	PA1PTR	This symbol may be used to place a patch at the next
::		available address in the PATCH1 area.  It starts out
::		equal to PATCH1 and is moved up after each patch in
::		the PATCH1 area.  Use of the symbol assumes that all
::		patches from PATCH1 to PATCH1+P1SIZE will be done in order.
::	QPATS	current patch segment number
::	QPATB	starting address of current patch
::	QPATL	length of current patch
::	QPATA	0 IF PATCH IS IN PATCH0 AREA, 1 IF IN PATCH1, ELSE -1
::	PATACT	> 0 if when a patch is active.
::
::	PATCH(yymmdd,hhmm,uname,fba,lba1,len)	grab a patch area
::
::		yymmdd	Date patch written, if patch is modified in ANY
::			way this must be updated.
::		hhmm	Time patch written, current Cupertino time.
::			If patch is modified this also must be updated.
::		uname	ONTYME username of person who authored patch.
::			Personal name, not NETMID or NET3 or such.
::		fba	address of start of patch
::		lba1	address of next byte after end of patch
::		len	length (in hex) of patch in bytes if lba1 is missing
::
::	CONPATCH(fba,lba1,len)	continue a patch in a new area
::		Similar to PATCH but moves to a new area, must be
::		preceeded by a PATCH statement.
::
::	ENDPATCH(comment)	End a PATCH started with PATCH call.
::
::		comment	Description of patch to be output during
::			assembly.  Commas should be preceeded by `.
::
::	Example:
::	:	PATCH TO FIX HDLC ROOM CHECKING ROUTINE
::	  IF	HDLC&(LAPB!LAP)
::	PATCH(811009,1422,FRED,XROOM,,2)
::		LIS	R4,7
::	ENDPATCH(fix hdlc room checking routine)
::	  EI
::
::	:	PATCH TO FIX TRANSMITTER BUG
::	PATCH(811009,1630,DDM,XSEND,XSE010)
::	  IF	FINACT	:IF INTERFRAME FILL TIMER ENABLED
::		J	PA1PTR
::	  EI
::	PATRTN	LR	R6,RSIO
::		AHI	R6,OUTSCT,RSIP
::
::	CONPATCH(PA1PTR,,0C)
::		SBT	RL,FRMTMT,,	:INDICATE FRAME TRANSMITTED
::		JNR	R7		:IF ALREADY TRANSMITTED
::		J	PATRTN		:RETURN TO PATCHED AREA
::	ENDPATCH(fix transmitter bug)
::
::*********************************************************************

	GL	PAHPTR,PA0PTR,PA1PTR,QPATS,QPATB,QPATL,QPATA,PATACT
	GL	PATHIS,PATCH0,PATCH1,P0SIZE,P1SIZE,PHSIZE

:	DEFINE SOME MACROS
	GL	.35.
.35.	EQ	$A 35
	KILL	.NE.
.NE.	MACRO(P1,P2)[(((P1)-(P2))!((P2)-(P1)))^-.35.]
	KILL	.GT.
.GT.	MACRO(P1,P2)[((P2)-(P1))^-.35.]

:	DEFINE SOME SYMBOLS
PATACT	EQ	0	:FLAG NO PATCH ACTIVE
QPATA	EQ	-1	:CLEAR PATCH AREA FLAG
QPATS	EQ	-1
QPATB	EQ	-1
QPATL	EQ	-1

	KILL	PATCH
PATCH	macro(day,tim,usr,fba,lba1,len)[
  IF	PATACT
 REMARK %>>>> ERROR **** Previous PATCH not ended with ENDPATCH <<<<%
        QUIT    ; KILL SEG0,PRIVBG
  ELSE
PATACT	EQ	1
  EI
 REMARK %%PATCH added on day at tim by usr`.
	SEG	0
	ORG	PAHPTR
   IF	(PAHPTR+1)-(PATHIS+PHSIZE)
 REMARK %>>>> ERROR **** Too many PATCHs, increase PHSIZE beyond ; NUMBER $0PHSIZE
 REMARK x and reassemble <<<<%
 remark %>>>> NOTE: PHSIZE is a Tymfile equate.  example:  PHSIZE EQ $0 300 <<<<%%
        QUIT    ; KILL SEG0,PRIVBG
   EI
	WC	$0 day!19000000
	HC	$0 tim
Q	AC	\usr\
Q1	HS
	ORG	Q+$a10	:skip to next history area
PAHPTR	HS
  IF	Q1-.	:IF UNAME>10 CHARARACTERS, CLEAR OVERFLOW
	RE	Q1-.
	BC	0
	ER
  EI

QPATS	EQ	((fba)&$00FF0000)^-$010
QPATB	EQ	fba
QPATC	EQ	lba1
  IF	lba1 0
QPATL	EQ	(lba1)-(fba)
  ELSE
QPATL	EQ	len 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of patch end < address of patch start <<<<%
        QUIT    ; KILL SEG0,PRIVBG
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
 REMARK %>>>> Expand P1SIZE beyond ; NUMBER (QPATB+QPATL-PATCH1)
 REMARK x and reassemble. <<<<%
 remark %>>>> NOTE: P1SIZE is a Tymfile equate.  example:  P1SIZE EQ $0 0C00 <<<<%%
        QUIT    ; KILL SEG0,PRIVBG
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
 REMARK %>>>> Expand P0SIZE beyond ; NUMBER (QPATB+QPATL-PATCH0)
 REMARK x and reassemble. <<<<%
 remark %>>>> NOTE: P0SIZE is a Tymfile equate.  example:  P1SIZE EQ $0 200 <<<<%%
        QUIT    ; KILL SEG0,PRIVBG
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK %	Starts at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK %     Starts at fba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI

	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	(.+1)-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK  overflow <<<<%
        QUIT    ; KILL SEG0,PRIVBG
  EI
QPATRM  EQ      0                       :last macro was PATCH   ###sdw
	ORG	QPATB

]               :end PATCH

:	>>CONPAT(fba,lba1,len)<<	CONTINUE A PATCH

	KILL	CONPAT
CONPAT	MACRO(cfba,clba1,clen)[
PATACT	EQ	PATACT+1
  IF	2-PATACT
REMARK %>>>> ERROR **** CONPAT not preceded by a PATCH <<<<%
        QUIT    ; KILL SEG0,PRIVBG
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
QPATS	EQ	((cfba)&$00FF0000)^-$010
QPATB	EQ	cfba
QPATC	EQ	clba1
  IF	clba1 0
QPATL	EQ	(clba1)-(cfba)
  ELSE
QPATL	EQ	clen 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of conpatch end < address of conpatch start <<<<%
        QUIT    ; KILL SEG0,PRIVBG
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
 REMARK %>>>> Expand P1SIZE beyond ; NUMBER (QPATB+QPATL-PATCH1)
 REMARK x and reassemble. <<<<
 remark %>>>> NOTE: P1SIZE is a Tymfile equate.  example:  P1SIZE EQ $0 0C00 <<<<%%
        QUIT    ; KILL SEG0,PRIVBG
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
 REMARK %>>>> Expand P0SIZE beyond ; NUMBER (QPATB+QPATL-PATCH0)
 REMARK x and reassemble. <<<<%%
 remark %>>>> NOTE: P0SIZE is a Tymfile equate.  example:  P1SIZE EQ $0 200 <<<<%%
        QUIT    ; KILL SEG0,PRIVBG
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK 	Continues at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK 	Continues at cfba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI
	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	.-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK overflow <<<<$
        QUIT    ; KILL SEG0,PRIVBG
  EI
qpatrm  eq      1               :last macro run was CONPATCH
	ORG	QPATB
]

:	>>ENDPATCH(com)<<  End a patch - does error checking, outputs comment

	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
        IF      QPATRM          :if last was CONPATCH
 REMARK %>>>> ERROR **** BAD CONPATCH **** <<<<%
        else                    :last was PATCH
 REMARK %>>>> ERROR **** BAD PATCH **** <<<<%
        ei                      :print correct remark
        QUIT    ; KILL SEG0,PRIVBG
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	1
 REMARK <<< c1 >>>
]

	SUBTTL	FIN (Patch Areas, XRAY Symbol Table)

::*********************************************************************
::
::	PATCH AREAS
::
::	PATHIS:	defines the start of the patch history area,
::		each entry will be 16 bytes as follows,
::		19yy/mmdd/hhmm/uname(10 chars 0 filled)
::		where 19yy, mmdd and hhmm are in bcd (4 bits per decimal
::		digit) and uname is in ASCII.
::	PATCH0:	defines the start of the Segment 0 patch area.
::	PATCH1:	defines the start of the Segment 1 patch area.
::
::*********************************************************************

	SEG.(0)

PATCH0	HS	P0SIZE/2	:PATCH READ WRITE AREA
	SYAD(PATCH0)

	SEG.(1)
CRCDTB	HC	0FE63		:Debug crash code
	IF	CRHRMK
	REMARK	%Crash codes defined in this version:%
	EI
.QC.	EQ	1
	RE	.NCCD
	DFC.|.QC.|((CT.|.QC.|),(CST.|.QC.|))
.QC.	EQ	.QC.+1
	ER

PATHIS	WS	PHSIZE/4	:PATCH HISTORY TABLE
PATCH1	HS	P1SIZE/2	:FOR READ ONLY PATCH CODE
	SYAD(PATCH1)

:	PAHPTR:	pointer to the next available entry in PATHIS
:	PA0PTR:	This symbol may be used to place a patch at the next
:		available address in the PATCH0 area.  It starts out
:		equal to PATCH0 and is moved up after each patch in
:		the PATCH0 area.  Use of the symbol assumes that all
:		patches from PATCH0 to PATCH0+P0SIZE will be done in order.
:	PA1PTR:	This symbol may be used to place a patch at the next
:		available address in the PATCH1 area.  It starts out
:		equal to PATCH1 and is moved up after each patch in
:		the PATCH1 area.  Use of the symbol assumes that all
:		patches from PATCH1 to PATCH1+P1SIZE will be done in order.

PAHPTR	EQ	PATHIS	:INIT HISTORY POINTER TO START OF AREA
PA0PTR	EQ	PATCH0	:INIT PTR TO START OF AREA
PA1PTR	EQ	PATCH1	:INIT PTR TO START OF AREA

::*********************************************************************
::
::	TABLE:		SYMTBL:
::	FUNCTION:	Create the XRAY Symbol Table, at the end of seg D
::
::*********************************************************************

      IF	NAD68
	SEG.(1)				:Xray in SEG1 in 68K environment###wjl
      ELSE	:Engine
	SEG.(0D)			:Xray runs in SEGD
      EI	:NAD68

SYMTBL	WS	0
Q	EQ	0
	RE	NSYMBL
	SYAD|Q|
Q	EQ	Q+1
	ER
SRESER	HS	0			:SYMBOL RESERVE AREA
	ORG	.+(3*ADRESZ)		:room for HIADDR, ENDNOD, OPTMEM
SYMTSZ	EQ	.-SYMTBL		:SYMBOL TABLE ENDS HERE

	SUBTTL	FIN (Segment usuage)

::*********************************************************************
::
::	SEG 0 : NODE CODE DATA AREA
::	SEG 1 : NODE CODE EXECUTE-ONLY AREA
::	SEG 2 - SEG C : NEW DATA STRUCTURE:START FROM SEG 2 WILL BE IN
::		ONE MEMORY AREA, DATA THEN BUFFERLETS, NO SEG RESTRICTN##AL
::	SEG D : XRAY
::	SEG E : CTA TABLE
::
::*********************************************************************

:	DETERMINE SQSIZE FOR SEGS 0, 1, 0D, AND 0E
        SEG.(0)
S0SIZE  EQ      .-SEG0
	IF	(S0SIZE-10000)	:WARNS ASSEMBLER IF SEG0 OVERFLOW	###AL
	REMARK	%********** SEG0 SPACE NOT ENOUGH, S0SIZE =
	NUMBER $0 S0SIZE
	REMARK	%********** CONFIGURATION ERROR **********
	KILLER(1)
	EI

        SEG.(1)
S1SIZE  EQ      .-SEG1

      IF	NAD68
	SEG.(2)
S2SIZE	EQ	.-SEG2			:Section 2 is SEG2 ==> SEGC	###wjl
	SEG.(1)				:Restore SEG1 for Xray symbols	###wjl
Q	EQ	3
	RE	$A 11
S|Q|SIZE EQ	0			:SEG 3 ==> SEGD unused in 68K	###wjl
Q	EQ	Q+1
	ER
      ELSE	:Engine
	SEG.(0D)
SDSIZE	EQ	.-SEGD			:XRAY CODE
      EI	:NAD68


:	ROUND UP SEGMENT SIZES TO APPROPRIATE BOUNDARY
      IF	NAD68
PAGESZ	EQ	1000			:###wjl
      ELSE      TSI			:###wjl
PAGESZ  EQ      400
      ELSE	:Engine			:###wjl
PAGESZ  EQ      100
      EI	:NAD68			:###wjl

Q	EQ	0
	RE	$A 15
	IF	\S|Q|SIZE
S|Q|SZ	EQ	(S|Q|SIZE+PAGESZ-1)&1FF00&(-PAGESZ)
	EI	:S|Q|SIZE
Q	EQ	Q+1
	ER

:	ASSIGN ISIS PHYSICAL ADDRESSES
	IF	1-\NCTA
NCTA	EQ	10000		:DEFINE NCTA IF NOT THERE
	EI	:1-\NCTA
SESZ	EQ	(SESIZE+PAGESZ-1)&1FF00&(-PAGESZ)
SEPH	EQ	NCTA
KERNSZ	EQ	0		:SIZE OF SOLO KERNEL (NOT PRESENT FOR ISIS)
CTASIZE	EQ	SESZ		:CTA TABLE IS ALL OF SEG E

:	HIADDR IS THE TOTAL STORAGE REQUIREMENT FOR CODE AND DATA AREAS,
:	EXCLUDING THE BUFFERLETS.
:	CHRBUF MARKS THE BEGINNING OF BUFFERLET STORAGE.
HIADDR	EQ	SESZ+S0SZ+S1SZ+SDSZ+(CHRBUF-SEG2)	:		###wjl

	ORG	SRESER
	SC	/HIADDR:/
	WC	HIADDR

:	COMPUTE THE SIZE OF THE EXCESS MEMORY TO BE ALLOCATED TO BUFFERLETS
	IF	MEMAVL-HIADDR
CHBFSZ	EQ	MEMAVL-HIADDR		:BUFFERLET AREA SIZE
MEMORE	EQ	0			:we have enough for code, etc,	###wjl
	ELSE	:NOT NEARLY ENOUGH MEMORY...
CHBFSZ	EQ	0
MEMORE	EQ	HIADDR-MEMAVL		:we need this much more for code, etc.
	EI	:MEMAVL-HIADDR

:	IF THERE ISN'T AT LEAST ONE BUFLET/CKT or if THERE IS LESS THAN 4K
:	BUFLET SPACE...make an error remark
	IF	(NCIRCS*10)-CHBFSZ
CHBCIR	EQ	(NCIRCS*10)-CHBFSZ	:we need at least one buflet/ckt###wjl
	ELSE
CHBCIR	EQ	0			:we have at least one buflet/ckt###wjl
	EI
	IF	1000-CHBFSZ
CHB4K	EQ	1000-CHBFSZ		:we need at least 4k buflet space##wjl
	ELSE
CHB4K	EQ	0			:we have at least 4k buflet space##wjl
	EI

	IF	CHBCIR!CHB4K
MEMORE	EQ	MEMORE+CHBCIR+CHB4K		:a little extra won't hurt#wjl
	REMARK	%%Fatal error - configuration too large!%
	NUMBER	$A (MEMAVL+1023)/1024
	REMARK	d KB specified as available,%
	REMARK	MUST be increased by AT LEAST 
	NUMBER	$A (MEMORE+1023)/1024		:###wjl
	REMARK	d KB!%
	KILLER(1)
	EI	:CHBCIR!CHB4K

:	COMPUTE SIZES OF SEGMENTS 2-C
Q	EQ	(CHRBUF-SEG2)+CHBFSZ	:NOW COMPUTE SIZES OF SEGS 2-0C	###wjl
Q1	EQ	2
	RE	$A 11
	IF	Q-10000
S|Q1|SIZE EQ	10000
	ELSE	:NOT Q-10000
	IF	Q
S|Q1|SIZE EQ	Q
	ELSE	:NOT Q
S|Q1|SIZE EQ	0
	EI	:Q
	EI	:Q-10000
Q	EQ	Q-10000
Q1	EQ	Q1+1
	ER

:	ROUND SEGMENT SIZES UP TO MAC PAGE BOUNDARY
Q	EQ	2
	RE	$A 11			:SEG2-SEGC
S|Q|SZ	EQ	(S|Q|SIZE+PAGESZ-1)&1FF00&(-PAGESZ)
Q	EQ	Q+1
	ER

:	COMPUTE ENDNOD, THE TOTAL AMOUNT OF MEMORY USED. THIS CAN NEVER BE 
:	LARGER THAN MEMAVL, THE AVAILABLE MEMORY.
ENDNOD	EQ	HIADDR+S2SZ+S3SZ+S4SZ+S5SZ+S6SZ+S7SZ+S8SZ+S9SZ+SASZ+SBSZ+SCSZ-(CHRBUF-SEG2)

	SC	/ENDNOD:/
	WC	ENDNOD

	IF	MEMAVL-ENDNOD+10	:DON'T RUN OFF THE END OF LAST SEG
CHBFSZ	EQ	ENDNOD-HIADDR-10	:MORE MEMORY AVAILABLE THAN MAC
	EI	:MEMVAL-ENDNOD

RCBFSZ	EQ	CHBFSZ			:REAL CHAR. BUFFERLET SIZE ###LSH


	SUBTTL	FIN (BS - Bufferlet Statistics)

::*********************************************************************
::
::	Bufferlet Statistics
::
::*********************************************************************

NBFLET	EQ	CHBFSZ/CBSZ	:NUMBER OF BUFFERLETS ALLOCATED
NBFLE2	EQ	NBFLET*(CBSZ-2)	
ISCALX	EQ	0		:DETERMINE SCALE PARAMETER FOR B'LET HISTOGRAM
ISTEP	EQ	$A1024		:ASSUME SMALLEST STEP SIZE
Q	EQ	$A13
	RE	$A10
QQX	EQ	1^Q-1
	IF	(NBFLE2-QQX)	:IF NBFLE2 IS LARGER
ISCALX	EQ	ISCALX+1	:INCREMENT SCALE FACTOR
ISTEP	EQ	ISTEP*2		:AND SCALE STEP SIZE
	EI
Q	EQ	Q+1
	ER
NSTEPS	EQ	NBFLE2/ISTEP+1	:NUMBER OF LINES TO DISPLAY

	ORG	XBUFH2
ISCALE	EQ	ISCALX+0A       :amount to shift in use
        IF      ISCALE-0F       :MAX RANGE IS TO 512K BYTES IN 64K BYTE STEPS
        SC      /448K-512K/
        SC      /384K-448K/
        SC      /320K-384K/
        SC      /256K-320K/
        SC      /192K-256K/
        SC      /128K-192K/
        SC      /64K -128K/
        SC      /UNDER 64K/
        ELSE
        IF      ISCALE-0E       :MAX RANGE IS TO 256K BYTES IN 32K BYTE STEPS
        SC      /224K-256K/
        SC      /192K-224K/
        SC      /160K-192K/
        SC      /128K-160K/
        SC      /96K -128K/
        SC      /64K - 96K/
        SC      /32K - 64K/
        SC      /UNDER 32K/
        ELSE
        IF      ISCALE-0D       :ISCALE = 14 => UP TO 128K BYTES IN 16K STEPS
        SC      /112K-128K/
        SC      /96K -112K/
        SC      /80K - 96K/
        SC      /64K - 80K/
        SC      /48K - 64K/
        SC      /32K - 48K/
        SC      /16K - 32K/
        SC      /UNDER 16K/
        ELSE
        IF      ISCALE-0C       :ISCALE = 13 => TO 64K IN 8K STEPS
        SC      /56K - 64K/
        SC      /48K - 56K/
        SC      /40K - 48K/
        SC      /32K - 40K/
        SC      /24K - 32K/
        SC      /16K - 24K/
        SC      /8K  - 16K/
        SC      /UNDER  8K/
        ELSE
        IF      ISCALE-0B       :ISCALE = 12
        SC      /28K - 32K/
        SC      /24K - 28K/
        SC      /20K - 24K/
        SC      /16K - 20K/
        SC      /12K - 16K/
        SC      / 8K - 12K/
        SC      / 4K -  8K/
        SC      /UNDER  4K/
        ELSE
        IF      ISCALE-0A       :ISCALE = 10
        SC      /14K - 16K/
        SC      /12K - 14K/
        SC      /10K - 12K/
        SC      / 8K - 10K/
        SC      / 6K -  8K/
        SC      / 4K -  6K/
	SC	/ 2K -  4K/
        SC      /UNDER  2K/
        ELSE                    :ISCALE=10d (smallest value)
        SC      / 7K -  8K/
        SC      / 6K -  7K/
        SC      / 5K -  6K/
	SC	/ 4K -  5K/
        SC      / 3K -  4K/
        SC      / 2K -  3K/
        SC      / 1K -  2K/
        SC      / UNDER 1K/
        EI
        EI
        EI
	EI
	EI
	EI

:	NUMBER OF DATA BYTES IN BUFFERLET

:	USER MAY DEFINE NUMBER OF BUFFERLETS/CIRCUIT REQUIRED
	IF	1-\BFPCIR
BFPCIR	EQ	40/(cbsz)	:DEFAULT TO 64 bytes of BUFFERLETS PER CIRCUIT
        if      1-bfpcir
bfpcir  eq      1
        ei      :1-bfpcir
	EI	:1-\BFPCIR

	IF	REBILD
	DEFAULT(BFPHIS,80/cbsz)	:MINIMUM # OF BFLETS PER HISTORY BUFFER
        if      1-bfphis
bfphis  eq      1
        ei      :1-bfphis
	ELSE	:
BFPHIS	EQ	0
	EI	:REBILD

OPTMEM	EQ	(HIADDR+(BFPCIR*NCIRCS*CBSZ)+(BFPHIS*NTERMS*CBSZ))

	ORG	SRESER+(2*ADRESZ)
	SC	/OPTMEM:/
	WC	OPTMEM

	ENDMO.(FIN)
	EI	:1-KILLIT
	KILMSG(FIN)

BADCOD	ERRCNT
	KILLER(BADCOD)
	IF	KILLIT

	REMARK	%%%%
	REMARK	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%
	REMARK	!!! FATAL ERROR !!! FATAL ERROR !!!%
	REMARK	!!! ASSEMBLY HAS BEEN KILLED !!!!!!%
	REMARK	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	REMARK	%%%%

	KILL	SEG0,PRIVBG		:Don't allow write-out

	EI	:KILLIT
	UN

:	***NOTHING PAST THIS POINT***

	SUBTTL	CONFIG

:			 ***   ***  *   * ***** *****  ***
:			*   * *   * **  * *       *   *   *
:			*     *   * * * * ****    *   *
:			*   * *   * *  ** *       *   *  **
:			 ***   ***  *   * *     *****  ****

::#####################################################################
::
::	MODULE:		C O N F I G
::
::	FUNCTION:	Display assembly configuration
::
::#####################################################################

	IF	1-KILLIT

::*********************************************************************
::
::	Display assembly configuration, based on value of CONFIG -
::		CONFIG = 0 means no display
::			 1 means simple display
::		       > 1 means full display
::	Simple display (CONFIG = 1) looks like this:
::
::	TYMNET-II Node Code Version 5.12, ISIS Node
::
::	Node: 2161  Kernel Host: 633
::
::	Ports:		Lines:		Links:
::	    32d Pthru	    16d Sync	     6d TIILNK
::	     3d Xray	    18 SIO	    10d XLNK
::			    24d Total	    16d Total
::	   512d Disp
::	     4d Krnl
::
::	Maximum number of circuits =  604d
::
::
::	Bufferlet storage space:
::
::	 0AA76 bytes ( 43d KB) for  604d total circuits  ( 72d bytes per circuit)
::
::
::	Memory used by this configuration = 40000x, 256d KB.
::
::	Optimal amount of memory for this configuration =   246d  KB.
::
::*********************************************************************

	DEFAULT(CONFIG,(1+BLAB))

	IF	CONFIG

:	IDENTITY REMARKS...

	REMARK	%%TYMNET-II Node Code, Version 
	NUMBER $8(VERSION/100)&77
	 IF	$81-(VERSION&070)
	REMARK .0
	 ELSE	:NO LEADING ZERO REQUIRED
	REMARK .
	 EI	:$81-(VERSION&070)
	NUMBER $8VERSION&77
	  IF	T2GATE
	REMARK	, GATEWAY Node
	  ELSE
	REMARK	, ISIS Node
	  EI	:T2GATE
	CRLF.(2)
	REMARK	Node: 
	NUMBER	$8MACHNM

	IF	T2GATE
	REMARK	  H-Net Host (Kernel):
	NUMBER	$AHHOST
	REMARK    I-Net Host:
	NUMBER	$AIHOST
	CRLF.(2)
	ELSE	:NOT T2GATE

	REMARK	  Kernel Host: 
	NUMBER	$AHST0
	CRLF.(2)
	EI	:T2GATE

:	REPORT LINES AND LINKS AND PORTS
	REMARK	Ports:		Lines:		Links:
	CRLF.

	NMBR.(NPASTH,A,6)		:CHANGED BY ###EV
	REMARK	Pthru
	TAB.
	NMBR.((NLINES-SILINS),A,6)
	REMARK	Sync
	TAB.
	NMBR.((NLINKS-XLINKS),A,6)
	REMARK	TIILNK
	CRLF.

	NMBR.(NXUBLK-1,A,6)
	REMARK	Xray
	TAB.
	NMBR.(SILINS,A,6)
	REMARK	SIO
	TAB.
	NMBR.(XLINKS,A,6)
	REMARK	XLNK
	CRLF.

	TAB.(2)
	NMBR.(NLINES,A,6)
	REMARK	Total
	TAB.
	NMBR.(NLINKS,A,6)
	REMARK	Total
	CRLF.

	NMBR.(NDP,A,6)
	REMARK	Disp
	CRLF.

	NMBR.(NKU,A,6)
	REMARK	Krnl
	CRLF.

	 IF	SUPER
	NMBR.(NSP,A,6)
	REMARK	Supe
	CRLF.
	 EI	:SUPER

      IF	MNC68K
	NMBR.(NMNCC,A,6)
	REMARK	Inter-NC
	CRLF.
      EI	:MNC68K

	CRLF.

	REMARK Maximum number of circuits = 
	NMBR.(NCIRCS,A,4)
	CRLF.(2)

BTPCIR	EQ	BFPCIR*(CBSZ-2)	: Bufferlet bytes per circuit -- Recommended
BTPHIS	EQ	BFPHIS*(CBSZ-2)	: Bufferlet bytes per history Buffer
NBFLBT	EQ	NBFLET*(CBSZ-2)	: Number of Bufferlet bytes
NCIRBT	EQ	NBFLBT		: Number of Circuit bytes
NHISBT	EQ	0		: Number of History bytes

	REMARK	%Bufferlet storage space:%%

	 IF	REBILD
	  IF	NBFLETS+1-(NCIRCS*BFPCIR)
NCIRBT	EQ	NCIRCS*BTPCIR	:Number of Circuit bytes
	  ELSE
NCIRBT	EQ	NBFLBT
	  EI

	  IF	NBFLBT-NCIRBT
NHISBT	EQ	(NBFLBT-NCIRBT)	: Number of History bytes
	  EI

	NMBR.(NCIRBT,0,6)
	REMARK	bytes (
	NMBR.(((NCIRBT+1023)/1024),A,3)
	REMARK	KB) for 
	NMBR.(NCIRCS,A,4)
	REMARK	circuit buffers (
	NMBR.((NCIRBT/NCIRCS),A,3)
	REMARK	bytes per circuit)%

	NMBR.(NHISBT,0,6)
	REMARK	bytes (
	NMBR.(((NHISBT+1023)/1024),A,3)
	REMARK	KB) for 
	NMBR.(NTERMS,A,4)
	REMARK	history buffers (
	NMBR.((NHISBT/NTERMS),A,3)
	REMARK	bytes per termination)%
	 EI	:REBILD

	NMBR.(NBFLBT,0,6)
	REMARK	bytes (
	NMBR.(((NBFLBT+1023)/1024),A,3)
	REMARK	KB) for 
	NMBR.(NCIRCS,A,4)
	REMARK	total circuits  (
	NMBR.((NBFLBT/NCIRCS),A,3)
	REMARK	bytes per circuit)%%

Q	EQ	(NCIRCS*BTPCIR)+(NTERMS*BTPHIS)

	 IF	Q-NBFLBT
	REMARK	****************************************************************
	REMARK	%Number of bufferlets allocated is insufficient...%
	  IF	REBILD
	NMBR.(BTPCIR,A,3)
	REMARK	bytes per circuit buffer recommended, 
	NMBR.((NCIRBT/NCIRCS),A,3)
	REMARK	bytes allocated.%
	NMBR.(BTPHIS,A,3)
	REMARK	bytes per history buffer recommended, 
	NMBR.((NHISBT/NTERMS),A,3)
	REMARK	bytes allocated.%
	  EI	:REBILD
	NMBR.((((NCIRCS*BTPCIR)+(NTERMS*BTPHIS))/NCIRCS),A,3)
	REMARK	total bytes per circuit recommended,  
	NMBR.((NBFLBT/NCIRCS),A,3)
	REMARK	bytes allocated.%%
	NUMBER $A(100-(NBFLBT*100)/Q)
	REMARK	 percent below recommended level,
	NMBR.((((Q-NBFLBT)+2*((Q-NBFLBT)/(CBSZ-2))+1023)/1024),A,3)
	REMARK	KB additional memory recommended.%
	REMARK	****************************************************************
	 EI	:Q-ETC...

	REMARK %Memory used by this configuration = 
	NUMBER $0 ENDNOD
	REMARK x, 
	NUMBER $A (ENDNOD+1023)/1024
	REMARK d KB.%


	REMARK %Optimal amount of memory for this configuration = 
	NMBR.(((OPTMEM+1023)/1024),A,4)
:	NUMBER $A ((HIADDR+(BFPCIR*NCIRCS)*CBSZ)+1023)/1024
	REMARK  KB.%

	 IF	MEMRMK-1
:	TELL MEMORY REQUIREMENTS
	REMARK	Memory:
QQ	EQ	0
QQCT	EQ	3
	RE      0F
	  IF	\S|QQ|SIZE
	   IF	S|QQ|SIZE
	    IF	(QQCT&3)-2
	CRLF.
	    ELSE
	TAB.
	    EI
	    IF	0A-QQ
	REMARK	SEG0
	    ELSE
	REMARK	SEG
	    EI
	NUMBER	QQ
	REMARK	=
	NMBR.((S|QQ|SZ),0,6)
:	NUMBER	S|QQ|SZ
:	REMARK	x
QQCT	EQ	QQCT+1
	   EI
	  EI
QQ	EQ	QQ+1
	ER
	CRLF.
	 EI	:MEMRMK-1


	IF	CONFIG-1

NCFRMK	EQ	0
	REMARK	%Assembly switches and options were set as follow:%
	REMARK	CONSAT -
	CFGRMK(CONSAT)
	REMARK	DB.BTR -
	CFGRMK(DB.BTR)
	REMARK	DB.BUB -
	CFGRMK(DB.BUB)
	REMARK	DB.CIR -
	CFGRMK(DB.CIR)
	REMARK	DB.DEB -
	CFGRMK(DB.DEB)
	REMARK	DB.SYN -
	CFGRMK(DB.SYN)
	REMARK	DB.TRC -
	CFGRMK(DB.TRC)
	REMARK	KNRING -
	CFGRMK(KNRING)
	REMARK	NEWALI -
	CFGRMK(NEWALI)
	REMARK	REBILD -
	CFGRMK(REBILD)
	REMARK	SRING  -
	CFGRMK(SRING)
	REMARK	SUPER  -
	CFGRMK(SUPER)
	EI	:CONFIG-1
	EI	:CONFIG
	EI	:1-KILLIT

	END

:	***NOTHING PAST THIS POINT***

  7@ 